[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.io.StdIn._\nobject Main extends App {\n  loop()\n  @tailrec def loop(): Unit = {\n    val Array(ax1, ay1, bx1, by1) = readLine.trim.split(' ').map(_.toInt)\n    if (ax1 == 0 && ay1 == 0 && bx1 == 0 && by1 == 0) return\n    val line1 = Line(Point(ax1, ay1), Point(bx1, by1))\n    val Array(line2, line3) = Array.tabulate(2){_ ⇒\n      val Array(ax, ay, bx, by) = readLine.trim.split(' ').map(_.toInt)\n      Line(Point(ax, ay), Point(bx, by))\n    }\n    println(Some((areas _).curried).flatMap(line1.crossPoint(line2).map).flatMap(line2.crossPoint(line3).map).flatMap(line3.crossPoint(line1).map) match {\n      case Some(area) if area >= 1900000 ⇒ \"dai-kichi\"\n      case Some(area) if area >= 1000000 ⇒ \"chu-kichi\"\n      case Some(area) if area >= 100000 ⇒ \"kichi\"\n      case Some(area) if area >= 0.000001 ⇒ \"syo-kichi\"\n      case _ ⇒ \"kyo\"\n    })\n    loop()\n  }\n  def areas(a: Point, b: Point, c: Point): Double = {\n    val s = (a.distance(b) + b.distance(c) + c.distance(a)) / 2\n    math.sqrt(s * (s - a.distance(b)) * (s - b.distance(c)) * (s - c.distance(a)))\n  }\n}\n\ncase class Point(x: Double, y: Double) {\n  def -(that: Point): Vector = Vector(x - that.x, y - that.y)\n  def distance(that: Point): Double = (this - that).length\n}\ncase class Vector(x: Double, y: Double) {\n  def dot(that: Vector): Double = x * that.x + y * that.y\n  def cross(that: Vector): Double = x * that.y - y * that.x\n  def length: Double = math.sqrt(x * x + y * y)\n  def sin(that: Vector): Double = {\n    cross(that) / length / that.length\n  }\n  def cos(that: Vector): Double = {\n    dot(that) / length / that.length\n  }\n}\ncase class Line(endA: Point, endB: Point) {\n  private val a = endB.y - endA.y\n  private val b = endA.x - endB.x\n  private val c = endA.y * endB.x - endA.x * endB.y\n  def crossPoint(that: Line): Option[Point] = {\n    val d = a * that.b - b * that.a\n    if (math.abs(d) < 0.0000001) None\n    else {\n      val cp = Point((b * that.c - c * that.b) / d, (c * that.a - a * that.c) / d)\n      Some(cp).filter(isOnLine).filter(that.isOnLine)\n    }\n  }\n  private def isOnLine(that: Point): Boolean = {\n    val am = endA - that\n    val mb = endB - that\n    am.sin(mb).abs <= 0.000001 && (am.cos(mb) + 1 ).abs <= 0.000001\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0-EPS)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0-EPS)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0-EPS)cout<<\"kichi\"<<endl;\n    else if(area>0.0-EPS)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <utility>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<double,double> pdd;\n#define x first\n#define y second\nconst double EPS = 1e-9;\nconst double INF = 1e18;\n\ntemplate<class T>\nT sqr(T obj) { return obj * obj; }\n\npdd pt(pdd a0, pdd a1, pdd b0, pdd b1) {\n\tdouble div;\n\tpdd ret;\n\n\tdiv = (a1.y - a0.y) * (b1.x - b0.x) - (b1.y - b0.y) * (a1.x - a0.x);\n\tif(fabs(div) < EPS)\n\t\treturn pdd(INF,INF);\n\n\tret.x = (a1.x - a0.x) * (b1.x * b0.y - b0.x * b1.y) - (b1.x - b0.x) * (a1.x * a0.y - a0.x * a1.y);\n\tret.y = (a1.y - a0.y) * (b1.x * b0.y - b0.x * b1.y) - (b1.y - b0.y) * (a1.x * a0.y - a0.x * a1.y);\n\tret.x /= div;\n\tret.y /= div;\n\n\treturn ret;\n}\n\nint main() {\n\twhile(1) {\n\t\tvector<pdd> v;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tdouble a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv.push_back(pdd(a,b));\n\t\t\t}\n\t\t\tif(fabs(v[0].x) < EPS && fabs(v[0].y) < EPS && fabs(v[1].x) < EPS && fabs(v[1].y) < EPS)\n\t\t\t\tgoto EXIT;\n\t\t}\n\n\t\tvector<pdd> p;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tp.push_back(pt(v[i*2 % 6], v[(i*2+1) % 6], v[(i+1)*2 % 6], v[((i+1)*2+1) % 6]));\n\t\t}\n\n\t\tstring res = \"\";\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tdouble dist0, dist1;\n\t\t\tdist0 = sqrt(sqr(v[i*2%6].x - v[(i*2+1)%6].x) + sqr(v[i*2%6].y - v[(i*2+1)%6].y));\n\t\t\tdist1 = sqrt(sqr(v[i*2%6].x - p[i].x) + sqr(v[i*2%6].y - p[i].y))\n\t\t\t\t+ sqrt(sqr(v[(i*2+1)%6].x - p[i].x) + sqr(v[(i*2+1)%6].y - p[i].y));\n\t\t\tif(p[i].x == INF || p[i].y == INF || fabs(dist0 - dist1) > EPS) {\n\t\t\t\tres = \"kyo\";\n\t\t\t}\n\t\t\t//cout << p[i].x << \",\" << p[i].y << endl;\n\t\t}\n\n\t\tif(res == \"\") {\n\t\t\tdouble S;\n\t\t\tS = ((p[1].x - p[0].x) * (p[2].y - p[0].y) - (p[1].y - p[0].y) * (p[2].x - p[0].x)) / 2;\n\t\t\tS = fabs(S);\n\n\t\t\tif(S + EPS>= 1900000)\n\t\t\t\tres = \"dai-kichi\";\n\t\t\telse if(S + EPS >= 1000000)\n\t\t\t\tres = \"chu-kichi\";\n\t\t\telse if(S + EPS >= 100000)\n\t\t\t\tres = \"kichi\";\n\t\t\telse if(S < EPS)\n\t\t\t\tres = \"kyo\";\n\t\t\telse\n\t\t\t\tres = \"syo-kichi\";\n\t\t}\n\t\tcout << res << endl;\n\t}\n\nEXIT:;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=EPS)cout<<\"syo-kichi\"<<endl;\n      else cout<<\"kyo\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(!equals(a.real(), b.real())) return a.real() < b.real();\n    if(!equals(a.imag(), b.imag())) return a.imag() < b.imag();\n    return false;\n  }\n  bool operator == (const P &a, const P &b) {\n    return !(a < b) && !(b < a);\n  }\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isParallel(P a, P b) {\n  return equals(cross(a,b), 0);\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n           ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\ndouble heron(double a, double b, double c) {\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\ndouble heron(P a, P b, P c) {\n  return heron(abs(a-b), abs(a-c), abs(b-c));\n}\n\nint main() {\n  while(1) {\n    vector<P> a(3), b(3);\n    for(int i = 0; i < 3; ++i) {\n      cin >> a[i].real() >> a[i].imag() >> b[i].real() >> b[i].imag();\n      if(a[i].real() == 0 && a[i].imag() == 0 && b[i].real() == 0 && b[i].imag() == 0) return 0;\n    }\n    vector<P> ps;\n    for(int i = 0; i < 3; ++i) {\n      for(int j = i+1; j < 3; ++j) {\n        P s = b[i] - a[i];\n        P t = b[j] - a[j];\n        if(!isParallel(s,t) && isIntersect(a[i],b[i],a[j],b[j])) {\n          ps.push_back(getCrossP(a[i],b[i],a[j],b[j]));\n        }\n      }\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n    double S = -1;\n    if(ps.size() == 3) S = heron(ps[0], ps[1], ps[2]);\n    if(S < 0) cout << \"kyo\" << endl;\n    else if(S < 100000) cout << \"syo-kichi\" << endl;\n    else if(S < 1000000) cout << \"kichi\" << endl;\n    else if(S < 1900000) cout << \"chu-kichi\" << endl;\n    else cout << \"dai-kichi\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-6;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n    if( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n    return ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 点 a から 点 b への角度を返す [0,2π]\ndouble dir(P a, P b) {\n\tP p = a - b;\n\tdouble angle = atan2( p.Y , p.X );\n\tif( p.X < 0 ) angle += PI;\n\tif( angle < 0 ) angle += 2.0 * PI;\n\treturn angle;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n};\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n    Triangle(){}\n\t// 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n};\n\n\nint main(){\n\tint x1, y1, x2, y2;\n\twhile( cin >> x1 >> y1 >> x2 >> y2 , x1 || y1 || x2 || y2 ){\n\t\tSegment s1( P(x1,y1) , P(x2,y2) );\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tSegment s2( P(x1,y1) , P(x2,y2) );\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tSegment s3( P(x1,y1) , P(x2,y2) );\n\t\tvector<P> v;\n\t\tif( s1.is_intersection(s2) ){\n\t\t\tP p;\n\t\t\ts1.intersection(s2,p);\n\t\t\tif( p != INF_P ) v.push_back( p );\n\t\t}\n\t\tif( s2.is_intersection(s3) ){\n\t\t\tP p;\n\t\t\ts2.intersection(s3,p);\n\t\t\tif( p != INF_P ) v.push_back( p );\n\t\t}\n\t\tif( s3.is_intersection(s1) ){\n\t\t\tP p;\n\t\t\ts3.intersection(s1,p);\n\t\t\tif( p != INF_P ) v.push_back( p );\n\t\t}\n\t\t\n\t\tdouble s = 0;\n\t\tTriangle t;\n\t\tif( v.size() == 3 ){\n\t\t\tt = Triangle( v[0] , v[1] , v[2] );\n\t\t\ts = t.get_area();\n\t\t}\n\t\tif( s >= 1900000 ){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if( s >= 1000000 ){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if( s >= 100000 ){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if( s > 0 ){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n#include <complex>\n#include <cassert>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool isParallel(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint x[2], y[2];\n\twhile(cin>>x[0]>>y[0]>>x[1]>>y[1]){\n\t\tif(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0) break;\n\t\tvector<L> l;\n\t\tl.pb({P(x[0], y[0]), P(x[1], y[1])});\n\t\trep(i, 2){\n\t\t\trep(j, 2) cin>>x[j]>>y[j];\n\t\t\tl.pb({P(x[0], y[0]), P(x[1], y[1])});\n\t\t}\n\t\tbool f = true;\n\t\tvector<P> p;\n\t\trep(i, 3) rep(j, i){\n\t\t\tif(isParallel(l[i], l[j]) || (!intersectSS(l[i], l[j]))){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp.pb(crosspoint(l[i], l[j]));\n\t\t}\n\t\tif(f == false){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble s = 0.0;\n\t\trep(i, 3){\n\t\t\ts += cross({0.0,0.0}, p[i]);\n\t\t}\n\t\ts /= 2.0;\n\t\ts = abs(s);\n\t\tstring ans;\n\t\tif(s + EPS >\t\t1900000) ans = \"dai-kichi\";\n\t\telse if(s + EPS >\t1000000) ans = \"chu-kichi\";\n\t\telse if( s + EPS >\t100000) ans = \"kichi\";\n\t\telse ans = \"syo-kichi\";\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// ??´??? a1, a2 ??¨??´???b1, b2?????????????±???????\n// Verified: AOJ CGL_2_C.cpp\nP crossp_ll(P a1, P a2, P b1, P b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if( EQ(d1,0) && EQ(d2,0) ) return a1; // same line\n    if( EQ(d2,0) ) assert(false); // precondition not satisfied\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\n// ????§???¢????¬????????????¢???\ndouble area_n(const vector<P> &v) {\n    double ans = 0;\n    double x, y, z;\n    P init = v[0];\n    rep(i,2,v.size()) {\n        x = sqrt(norm(v[i] - init));\n        y = sqrt(norm(v[i-1] - init));\n        z = sqrt(norm(v[i] - v[i-1]));\n\n        double s = (x + y + z) / 2;\n        ans += sqrt(s * (s-x) * (s-y) * (s-z));\n    }\n    return ans;\n}\n\n// 2??´?????????????????? (?????????0??§???????????¨)\nbool is_parallel(P a1, P a2, P b1, P b2) {\n    // printf(\"cross: %.12lf\\n\", cross(a1-a2, b1-b2));\n    return EQ( cross(a1-a2, b1-b2), 0.0);\n}\n\nsigned main() {\n    double x1, y1, x2, y2;\n    while(cin >> x1 >> y1 >> x2 >> y2) {\n        if(x1 == y1 && y1 == x2 && x2 == y2 && y2 == 0.0) break;\n        vector<L> ls; vector<P> ps;\n        ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        rep(i,0,2) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        }\n\n        bool ng = false;\n        rep(i,0,3) {\n            P a1 = ls[i].fr, a2 = ls[i].sc;\n            P b1 = ls[(i+1)%3].fr, b2 = ls[(i+1)%3].sc;\n            if(is_parallel(a1, a2, b1, b2)) ng = true;\n            P temp = crossp_ll(a1, a2, b1, b2);\n            // printf(\"crosspoint: (%.12lf, %.12lf)\\n\", temp.X, temp.Y);\n            rep(k,0,ps.size()) {if(temp == ps[k]) ng = true;}\n            ps.push_back(temp);\n        }\n\n        double ans = area_n(ps);\n        if(ng) cout << \"kyo\" << endl;\n        else if(ans < 100000.0 + EPS) cout << \"syo-kichi\" << endl;\n        else if(ans < 1000000.0 + EPS) cout << \"kichi\" << endl;\n        else if(ans < 1900000.0 + EPS) cout << \"chu-kichi\" << endl;\n        else cout << \"dai-kichi\" << endl;\n        // printf(\"debug: ans = %.12lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += abs(cross(ps[i], ps[(i+1) % ps.size()]));\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=abs(area(v));\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>0)cout<<\"syo-kichi\"<<endl;\n      else exit(1);\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const vector<Point>& polygon){\n  double area = 0;\n  for (int i = 0; i < polygon.size(); ++i) {\n    area += cross(polygon[i], polygon[(i+1) % polygon.size()]);\n  }\n  return area;\n}\n\nint main(){\n  int x1,y1,x2,y2;\n  while(~scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2)){\n    if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n    vector<Line> lines;\n    lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    \n    for(int i = 0; i < 2; i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    }\n\n    bool isok = true;\n    \n    vector<Point> polygon;\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        if(intersectSS(lines[i],lines[j])){\n          Point p = crosspoint(lines[i],lines[j]);\n          polygon.push_back(p);\n        }\n        else{\n          isok = false;\n          goto ng;\n        }\n      }\n    }\n  ng:;\n\n    sort(polygon.begin(),polygon.end());\n    double area = -1.0;\n    if(isok){\n      area = compute_area(polygon);\n    }\n\n    if(1900000.0 - EPS <= area){\n      printf(\"%s\\n\",\"dai-kichi\");\n    }\n    else if(1000000.0 - EPS <= area && area < 1900000.0){\n      printf(\"%s\\n\",\"chu-kichi\");\n    }\n    else if(100000.0 - EPS <= area && area < 1000000.0){\n      printf(\"%s\\n\",\"kichi\");\n    }\n    else if(0 - EPS <= area && area < 100000.0){\n      printf(\"%s\\n\",\"syo-kichi\");\n    }\n    else {\n      printf(\"%s\\n\",\"kyo\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n#ifdef _MSC_VER\n#include \"_lib_msc.h\"\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           for(int(i)=0;(i)<(n);++(i))\n#define REPEAT(i, k, n)     for(int(i)=(k);(i)<((k)+(n));++(i))\n#define RREP(i, n)          for(int(i)=(n)-1;(i)>=0;--(i))\n#define RREPEAT(i, k, n)    for(int(i)=(k)+(n)-1;(i)>=(k);--(i))\n#define FROMTO(i,f,t)       for(int(i)=(f);(i)<(t);(++i))\n#define ALL(c)              (c).begin(), (c).end()\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p2<p1)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\ninline int clz(ui n){return n==0?32:__builtin_clz(n);}\ninline int clz(ull n){return n==0?64:__builtin_clzll(n);}\ninline int crz(ui n){return n==0?32:__builtin_ctz(n);}\ninline int crz(ull n){return n==0?64:__builtin_ctzll(n);}\ninline int bitc(ui n){return __builtin_popcount(n);}\ninline int bitc(ull n){return __builtin_popcountll(n);} \n#ifdef _DEBUG\n#include \"_lib_dbg.h\"\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n#endif\n\nconst char *tbl[] = { \"dai-kichi\",\"chu-kichi\",\"kichi\",\"syo-kichi\",\"kyo\" };\n\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\nbool is_parallel(const P &a, const P &b, const P &c, const P &d){\n    return DEQ(outprd(a-b, c-d), 0.0);\n}\nbool is_intersected_ls(const P &a, const P &b, const P &c, const P &d){\n    return (outprd(b-a, c-a) * outprd(b-a, d-a) < EPS) && (outprd(d-c, a-c) * outprd(d-c, b-c) < EPS);\n}\nP intersection_l(const P &a, const P &b, const P &c, const P &d) {\n    P v1 = b - a; P v2 = d - c;\n    return a + v1 * outprd(v2, c-a) / outprd(v2, v1);\n}\nD triangle_S(P p1, P p2, P p3){\n    D l1 = sqrt(norm(p1-p2));\n    D l2 = sqrt(norm(p2-p3));\n    D l3 = sqrt(norm(p3-p1));\n    D z = (l1 + l2 + l3) / 2;\n    return sqrt(z * (z - l1) * (z - l2) * (z - l3));\n}\n\nint solve(int *x1, int *y1, int *x2, int *y2){\n    P p11(x1[0],y1[0]), p12(x2[0],y2[0]);\n    P p21(x1[1],y1[1]), p22(x2[1],y2[1]);\n    P p31(x1[2],y1[2]), p32(x2[2],y2[2]);\n    if(is_parallel(p11,p12,p21,p22)) return 4;\n    if(is_parallel(p21,p22,p31,p32)) return 4;\n    if(is_parallel(p31,p32,p11,p12)) return 4;\n    if(!is_intersected_ls(p11,p12,p21,p22)) return 4;\n    if(!is_intersected_ls(p21,p22,p31,p32)) return 4;\n    if(!is_intersected_ls(p31,p32,p11,p12)) return 4;\n    P p1 = intersection_l(p11,p12,p21,p22);\n    P p2 = intersection_l(p21,p22,p31,p32);\n    P p3 = intersection_l(p31,p32,p11,p12);\n    D s = triangle_S(p1,p2,p3);\n    if(s + EPS >= 1900000.0) return 0;\n    if(s + EPS >= 1000000.0) return 1;\n    if(s + EPS >= 100000.0) return 2;\n    return 3;\n}\n\nint main(void){\n    int x1[3],y1[3],x2[3],y2[3];\n    while(1){\n        cin >> x1[0] >> y1[0] >> x2[0] >> y2[0];\n        if(x1[0] == 0 && y1[0] == 0 && x2[0] == 0 && y2[0] == 0) break;\n        cin >> x1[1] >> y1[1] >> x2[1] >> y2[1];\n        cin >> x1[2] >> y1[2] >> x2[2] >> y2[2];\n        cout << tbl[solve(x1,y1,x2,y2)] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-b1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    VP v;\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      VP v;\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000)cout<<\"kichi\"<<endl;\n      else if(are>=0.0000000000001)cout<<\"syo-kichi\"<<endl;\n      else cout<<\"kyo\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <utility>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<double,double> pdd;\n#define x first\n#define y second\nconst double EPS = 1e-9;\nconst double INF = 1e18;\n\ntemplate<class T>\nT sqr(T obj) { return obj * obj; }\n\npdd pt(pdd a0, pdd a1, pdd b0, pdd b1) {\n\tdouble div;\n\tpdd ret;\n\n\tdiv = (a1.y - a0.y) * (b1.x - b0.x) - (b1.y - b0.y) * (a1.x - a0.x);\n\tif(fabs(div) < EPS)\n\t\treturn pdd(INF,INF);\n\n\tret.x = (a1.x - a0.x) * (b1.x * b0.y - b0.x * b1.y) - (b1.x - b0.x) * (a1.x * a0.y - a0.x * a1.y);\n\tret.y = (a1.y - a0.y) * (b1.x * b0.y - b0.x * b1.y) - (b1.y - b0.y) * (a1.x * a0.y - a0.x * a1.y);\n\tret.x /= div;\n\tret.y /= div;\n\n\treturn ret;\n}\n\nint main() {\n\twhile(1) {\n\t\tvector<pdd> v;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tdouble a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv.push_back(pdd(a,b));\n\t\t\t}\n\t\t\tif(fabs(v[0].x) < EPS && fabs(v[0].y) < EPS && fabs(v[1].x) < EPS && fabs(v[1].y) < EPS)\n\t\t\t\tgoto EXIT;\n\t\t}\n\n\t\tvector<pdd> p;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tp.push_back(pt(v[i*2 % 6], v[(i*2+1) % 6], v[(i+1)*2 % 6], v[((i+1)*2+1) % 6]));\n\t\t}\n\n\t\tstring res = \"\";\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tdouble dist0, dist1;\n\t\t\t\tdist0 = sqrt(sqr(v[(i+j)*2%6].x - v[((i+j)*2+1)%6].x) + sqr(v[(i+j)*2%6].y - v[((i+j)*2+1)%6].y));\n\t\t\t\tdist1 = sqrt(sqr(v[(i+j)*2%6].x - p[i].x) + sqr(v[(i+j)*2%6].y - p[i].y))\n\t\t\t\t\t+ sqrt(sqr(v[((i+j)*2+1)%6].x - p[i].x) + sqr(v[((i+j)*2+1)%6].y - p[i].y));\n\t\t\t\tif(p[i].x == INF || p[i].y == INF || fabs(dist0 - dist1) > EPS) {\n\t\t\t\t\tres = \"kyo\";\n\t\t\t\t}\n\t\t\t\t//cout << p[i].x << \",\" << p[i].y << endl;\n\t\t\t}\n\t\t}\n\n\t\tif(res == \"\") {\n\t\t\tdouble S;\n\t\t\tS = ((p[1].x - p[0].x) * (p[2].y - p[0].y) - (p[1].y - p[0].y) * (p[2].x - p[0].x)) / 2;\n\t\t\tS = fabs(S);\n\n\t\t\tif(S + EPS>= 1900000)\n\t\t\t\tres = \"dai-kichi\";\n\t\t\telse if(S + EPS >= 1000000)\n\t\t\t\tres = \"chu-kichi\";\n\t\t\telse if(S + EPS >= 100000)\n\t\t\t\tres = \"kichi\";\n\t\t\telse if(S < EPS)\n\t\t\t\tres = \"kyo\";\n\t\t\telse\n\t\t\t\tres = \"syo-kichi\";\n\t\t}\n\t\tcout << res << endl;\n\t}\n\nEXIT:;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n#ifdef _MSC_VER\n#include \"_lib_msc.h\"\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           for(int(i)=0;(i)<(n);++(i))\n#define REPEAT(i, k, n)     for(int(i)=(k);(i)<((k)+(n));++(i))\n#define RREP(i, n)          for(int(i)=(n)-1;(i)>=0;--(i))\n#define RREPEAT(i, k, n)    for(int(i)=(k)+(n)-1;(i)>=(k);--(i))\n#define FROMTO(i,f,t)       for(int(i)=(f);(i)<(t);(++i))\n#define ALL(c)              (c).begin(), (c).end()\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p2<p1)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\ninline int clz(ui n){return n==0?32:__builtin_clz(n);}\ninline int clz(ull n){return n==0?64:__builtin_clzll(n);}\ninline int crz(ui n){return n==0?32:__builtin_ctz(n);}\ninline int crz(ull n){return n==0?64:__builtin_ctzll(n);}\ninline int bitc(ui n){return __builtin_popcount(n);}\ninline int bitc(ull n){return __builtin_popcountll(n);} \n#ifdef _DEBUG\n#include \"_lib_dbg.h\"\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n#endif\n\nconst char *tbl[] = { \"dai-kichi\",\"chu-kichi\",\"kichi\",\"syo-kichi\",\"kyo\" };\n\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\nbool is_intersected_ls(const P &a, const P &b, const P &c, const P &d){\n    return (outprd(b-a, c-a) * outprd(b-a, d-a) < EPS) && (outprd(d-c, a-c) * outprd(d-c, b-c) < EPS);\n}\nP intersection_l(const P &a, const P &b, const P &c, const P &d) {\n    P v1 = b - a; P v2 = d - c;\n    return a + v1 * outprd(v2, c-a) / outprd(v2, v1);\n}\nD triangle_S(P p1, P p2, P p3){\n    D l1 = sqrt(norm(p1-p2));\n    D l2 = sqrt(norm(p2-p3));\n    D l3 = sqrt(norm(p3-p1));\n    D z = (l1 + l2 + l3) / 2;\n    return sqrt(z * (z - l1) * (z - l2) * (z - l3));\n}\n\nint solve(int *x1, int *y1, int *x2, int *y2){\n    P p11(x1[0],y1[0]), p12(x2[0],y2[0]);\n    P p21(x1[1],y1[1]), p22(x2[1],y2[1]);\n    P p31(x1[2],y1[2]), p32(x2[2],y2[2]);\n    if(!is_intersected_ls(p11,p12,p21,p22)) return 4;\n    if(!is_intersected_ls(p21,p22,p31,p32)) return 4;\n    if(!is_intersected_ls(p31,p32,p11,p12)) return 4;\n    P p1 = intersection_l(p11,p12,p21,p22);\n    P p2 = intersection_l(p21,p22,p31,p32);\n    P p3 = intersection_l(p31,p32,p11,p12);\n    D s = triangle_S(p1,p2,p3);\n    if(s + EPS >= 1900000.0) return 0;\n    if(s + EPS >= 1000000.0) return 1;\n    if(s + EPS >= 100000.0) return 2;\n    return 3;\n}\n\nint main(void){\n    int x1[3],y1[3],x2[3],y2[3];\n    while(1){\n        cin >> x1[0] >> y1[0] >> x2[0] >> y2[0];\n        if(x1[0] == 0 && y1[0] == 0 && x2[0] == 0 && y2[0] == 0) break;\n        cin >> x1[1] >> y1[1] >> x2[1] >> y2[1];\n        cin >> x1[2] >> y1[2] >> x2[2] >> y2[2];\n        cout << tbl[solve(x1,y1,x2,y2)] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n  \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n\n    cout << cross(curr(p,i),next(p,i)) << endl;\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\n\nint main(){\n  L ls[3];\n  int x1[3], y1[3], x2[3], y2[3];\n  while( cin >> x1[0] >> y1[0] >> x2[0] >> y2[0], x1[0]|y1[0]|x2[0]|y2[0] ){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      ls[i] = L( P( x1[i], y1[i]), P( x2[i], y2[i]));\n    }\n\n    G triangle(3);\n    bool flag = true;\n    for(int i = 0 ; i < 3 ; i++ ){\n      const int NEXT = ( i + 1 ) % 3;\n      if(!intersect( ls[i], ls[NEXT])){\n        flag = false;\n        break;\n      }else{\n        triangle[i] = crosspoint( ls[i], ls[NEXT]);\n      }\n    }\n\n    double s = abs(triangle[0]-triangle[1])+abs(triangle[1]-triangle[2])+abs(triangle[2]-triangle[0]);\n    double area = sqrt(s * ( s - abs(triangle[0] - triangle[1])) * ( s - abs(triangle[1] - triangle[2])) * ( s - abs(triangle[2] - triangle[0])));\n    if(!flag || area < EPS) cout << \"kyo\" << endl;\n    else if(area < 100000) cout << \"syo-kichi\" << endl;\n    else if(area < 1000000) cout << \"kichi\" << endl;\n    else if(area < 1900000) cout << \"chu-kichi\" << endl;\n    else cout << \"dai-kichi\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-b1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    VP v;\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      VP v;\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=EPS)cout<<\"syo-kichi\"<<endl;\n      else cout<<\"kyo\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nclass Line\n{\npublic:\n    double a, b, c; // a*x + b*y + c = 0\n    Line(){\n        a = c = 0.0;\n        b = 1.0;\n    }\n    Line(double a0, double b0, double c0){\n        a = a0;\n        b = b0;\n        c = c0;\n    }\n    Line(const Point& p1, const Point& p2){ // 2_ðÔ¼ü\n        double dy = p2.y - p1.y;\n        double dx = p2.x - p1.x;\n        if(abs(dy / dx) < EPS){\n            a = 0.0;\n            b = 1.0;\n            c = -p1.y;\n        }else if(abs(dx / dy) < EPS){\n            a = 1.0;\n            b = 0.0;\n            c = -p1.x;\n        }else{\n            a = - dy / dx;\n            b = 1.0;\n            c = dy / dx * p1.x - p1.y;\n        }\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) + EPS || min(b1.x, b2.x) > max(a1.x, a2.x) + EPS || min(a1.y, a2.y) > max(b1.y, b2.y) + EPS || min(b1.y, b2.y) > max(a1.y, a2.y) + EPS)\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) <= EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) <= EPS);\n}\n\nbool linesIntersection(const Line& l1, const Line& l2, Point& intersection)\n{\n    double s = l1.a*l2.b - l2.a*l1.b;\n    if(abs(s) < EPS)\n        return false;\n\n    intersection = Point(l2.a*l1.c - l1.a*l2.c, l1.b*l2.c - l2.b*l1.c) / s;\n    return true;\n}\n\ndouble polygonArea(const vector<Point>& p)\n{\n    int n = p.size();\n    double ret = 0.0;\n    for(int i=0; i<n; ++i)\n        ret += p[i].cross(p[(i+1)%n]);\n    return abs(ret) / 2.0;\n}\n\nint main()\n{\n    for(;;){\n        vector<Point> p(6);\n        for(int i=0; i<6; ++i)\n            cin >> p[i].x >> p[i].y;\n        if(p[0].x == 0 && p[0].y == 0 && p[1].x == 0 && p[1].y == 0)\n            return 0;\n\n        bool kyo = false;\n        for(int i=0; i<3; ++i){\n            if(!segmentsCollide(p[i*2], p[i*2+1], p[(i+1)*2%6], p[((i+1)*2+1)%6]))\n                kyo = true;\n        }\n        if(kyo){\n            cout << \"kyo\" << endl;\n            continue;\n        }\n\n        vector<Line> line(3);\n        for(int i=0; i<3; ++i)\n            line[i] = Line(p[i*2], p[i*2+1]);\n        vector<Point> p1(3);\n        for(int i=0; i<3; ++i)\n            kyo |= !linesIntersection(line[i], line[(i+1)%3], p1[i]);\n        if(kyo){\n            cout << \"kyo\" << endl;\n            continue;\n        }\n\n        double area = polygonArea(p1);\n        if(area > 1900000 - EPS)\n            cout << \"dai-kichi\" << endl;\n        else if(area > 1000000 - EPS)\n            cout << \"chu-kichi\" << endl;\n        else if(area > 100000 - EPS)\n            cout << \"kichi\" << endl;\n        else\n            cout << \"syo-kichi\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// Triangle and Circle\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool on_edge(const Point&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\n\nusing namespace std;\n\nint main() {\n    double x1, y1, x2, y2;\n    while(cin >> x1 >> y1 >> x2 >> y2, x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0) {\n        Segment s1(x1, y1, x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s2(x1, y1, x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s3(x1, y1, x2, y2);\n\n        if(s1.intersect(s2) && s2.intersect(s3) && s3.intersect(s1)) {\n            Polygon triangle;\n            triangle.add(s1.line().crosspoint(s2.line()));\n            triangle.add(s2.line().crosspoint(s3.line()));\n            triangle.add(s3.line().crosspoint(s1.line()));\n            if(triangle.area() >= 1900000.0) cout << \"dai-kichi\" << endl;\n            else if(triangle.area() >= 1000000.0) cout << \"chu-kichi\" << endl;\n            else if(triangle.area() >= 100000.0) cout << \"kichi\" << endl;\n            else cout << \"syo-kichi\" << endl;\n        } else {\n            cout << \"kyo\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += abs(cross(ps[i], ps[(i+1) % ps.size()]));\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=abs(area(v));\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>0)cout<<\"syo-kichi\"<<endl;\n      else cout<<\"kyo\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tdouble q1,q2,q3,q4;\n\twhile(cin>>q1>>q2>>q3>>q4,q1+q2+q3+q4){\n\t\tL a(P(q1,q2),P(q3,q4));\n\t\tcin>>q1>>q2>>q3>>q4;\n\t\tL b(P(q1,q2),P(q3,q4));\n\t\tcin>>q1>>q2>>q3>>q4;\n\t\tL c(P(q1,q2),P(q3,q4));\n\t\tif(para(a,b)||para(b,c)||para(c,a)){cout<<\"kyo\"<<endl;continue;}\n\t\tif((!intersectSS(a,b))||(!intersectSS(c,b))||(!intersectSS(a,c))){cout<<\"kyo\"<<endl;continue;}\n\t\tP p1=crosspointLL(a,b);\n\t\tP p2=crosspointLL(c,b);\n\t\tP p3=crosspointLL(a,c);\n\t\tif(p1==p2||p2==p3||p3==p1){cout<<\"kyo\"<<endl;continue;}\n\t\tp2-=p1;\n\t\tp3-=p1;\n\t\tdouble S=abs(p2.real()*p3.imag()-p2.imag()*p3.real())/2.0;\n\t\tif(S<100000)cout<<\"syo-kichi\"<<endl;\n\t\telse if(S<1000000)cout<<\"kichi\"<<endl;\n\t\telse if(S<1900000)cout<<\"chu-kichi\"<<endl;\n\t\telse cout<<\"dai-kichi\"<<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n\n/*\n  ô½Cu\n*/\n\n#include<vector>\n#include<stack>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\n// _Iy[^\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\n// CCW oXg¾ªA¸xÉæé\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\n// üªÌð·»èAºÍ_ÌÝÅßéo[WA»ÌºÍxNg(üªÌ[_Åðíé)\nbool intersected_seg(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\nbool intersected_l(line a, line b){\n  return !prll(a.fr,a.sc,b.fr,b.sc);\n}\npoint intersection_seg(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersection_l(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersection_seg(seg a, seg b, point &ret){\n  if( intersected_seg(a,b) ){\n    ret = intersection_seg(a,b);\n    return true;\n  }\n  return false;\n}\nbool intersection_l(line a, line b, point &ret){\n  if( intersected_l( a, b ) ){\n    ret = intersection_l( a, b );\n    return true;\n  }\n  return false;\n}\nbool intersection_lseg(line l, seg s, point &ret){\n  point tmp;\n  if( intersection_l(l,s,tmp) ){\n    if(ccw(s.fr,s.sc,tmp)&OVER){\n      ret=tmp;\n      return true;\n    }\n  }\n  return false;\n}\n\n// Op`ÌÊÏ\nelem areaOfTriangle(elem a, elem b, elem c){\n  elem s = (a+b+c)/2;\n  return sqrt( s * (s-a) * (s-b) * (s-c) );\n}\n\nusing namespace std;\nint main(){\n  while(true){\n    seg s[3];\n    bool inv=false;\n    for(int i = 0; i <3; ++i){\n      elem x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(eq(x1,0)&&eq(y1,0)&&eq(x2,0)&&eq(y2,0))return 0;\n      s[i] = seg(point(x1,y1),point(x2,y2));\n    }\n    point a,b,c;\n    if( !intersection_seg( s[0], s[1], a ) ||\n\t!intersection_seg( s[1], s[2], b ) || \n\t!intersection_seg( s[2], s[0], c ) )\n      inv=true;\n    \n    //    cout << \" A : \" << a << \" B : \" << b << \" C : \" << c << endl;\n    elem area = areaOfTriangle( abs(b-a), abs(c-b), abs(a-c) );\n    if( inv ){\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    \n    if( geq( area, 19000000 ) ){\n      cout << \"dai-kichi\" << endl;\n    }else if( geq( area, 1000000 ) ){\n      cout << \"chu-kichi\" << endl;\n    }else if( geq( area, 100000 ) ){\n      cout << \"kichi\" << endl;\n    }else if( gtz( area ) ){\n      cout << \"syo-kichi\" << endl;\n    }else{\n      cout << \"kyo\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\ntypedef complex<double> P;\n \n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n \n// // ????????????a?????????????????????n1,n2????±???????\n// P n1 = a * P(0, 1);\n// P n2 = a * P(0, -1);\n \n// // ????????????a???????????????????????????un1,un2????±???????\n// P un1 = (a * P(0, +1)) / abs(a);\n// P un2 = (a * P(0, -1)) / abs(a);\n \n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n \n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n \n// ???c?????´???a,b???????????????????????? ???????????? WA?????????\n// int is_point_on_line(P a, P b, P c) {\n//   return EQ( cross(b-a, c-a), 0.0 );\n// }\n \n// ???c?????????a,b????????????????????????(1)\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 ) &&\n        (dot(b-a, c-a) > -EPS) &&\n        (dot(a-b, c-b) > -EPS);\n}\n \n// ???c?????????a,b????????????????????????(2)\n// |a-c| + |c-b| <= |a-b| ???????????????\n// int is_point_on_line(P a, P b, P c) {\n  // return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n// }\n// a??????b???????????£???, 1 -> ???, -1 -> ???, 2 -> a????????????, -2 -> b??????????\\\\??????, 0 -> ??????ab???????????¨\nint ccw(P a,P b, P c){\n    P d = b - a;\n    c -= a;\n    double cr = cross(d, c);\n    if(cr < -EPS){ return 1; }\n    if(cr > EPS){ return -1; }\n    if(dot(d, c) < -EPS){ return 2; }\n    if(norm(d) < norm(c) - EPS){ return -2; }\n    return 0;\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n \n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n\t\t   ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\n \n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(P a1, P a2, P b1, P b2) {\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n\n    return a1 + (a2-a1) * t;\n}\n \n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n \n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ntypedef pair<P,P> S;\n\nbool is_intersected(S a, S b){\n\tif(abs(ccw(a.F, a.S, b.F))!=1&&abs(ccw(a.F, a.S, b.S))!=1) return false;\n\tif(!is_intersected_ls(a.F, a.S, b.F, b.S)) return false;\n\treturn true;\n}\n\ndouble clac_area(P a, P b, P c){\n\tdouble aa = abs(a-b), bb = abs(b-c), cc = abs(c-a);\n\tdouble s = (aa + bb + cc) / 2;\n\treturn sqrt(s * (s-aa) * (s-bb) * (s-cc));\n}\n\n\nvoid mainmain(){\n\tdouble a,b,c,d;\n\twhile(cin>>a>>b>>c>>d){\n\t\tif(a==b&&b==c&&c==d&&a==-1){\n\t\t\treturn;\n\t\t}\n\t\tvector<S> v(3);\n\t\tv[0] = {P(a,b),P(c,d)};\n\t\tcin>>a>>b>>c>>d;\n\t\tv[1] = {P(a,b),P(c,d)};\n\t\tcin>>a>>b>>c>>d;\n\t\tv[2] = {P(a,b),P(c,d)};\n\t\tbool ok = true;\n\t\trep(i,3){\n\t\t\tok &= is_intersected(v[i], v[(i+1)%3]);\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\treturn;\n\t\t}\n\t\tvector<P> w(3);\n\t\trep(i,3){\n\t\t\tw[i] = intersection_ls(v[i].F, v[i].S, v[(i+1)%3].F, v[(i+1)%3].S);\n\t\t}\n\t\tdouble ans = clac_area(w[0], w[1], w[2]);\n\t\tstring s[] = {\"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\"};\n\t\tdouble sigma[] = {1900000.0, 1000000.0, 100000.0, 0};\n\t\trep(i,4){\n\t\t\tif(ans >= sigma[i]){\n\t\t\t\tcout<<s[i]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i==3){\n\t\t\t\tcout<<s[4]<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\ntypedef complex<double> P;\n \n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n \n// // ????????????a?????????????????????n1,n2????±???????\n// P n1 = a * P(0, 1);\n// P n2 = a * P(0, -1);\n \n// // ????????????a???????????????????????????un1,un2????±???????\n// P un1 = (a * P(0, +1)) / abs(a);\n// P un2 = (a * P(0, -1)) / abs(a);\n \n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n \n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n \n// ???c?????´???a,b???????????????????????? ???????????? WA?????????\n// int is_point_on_line(P a, P b, P c) {\n//   return EQ( cross(b-a, c-a), 0.0 );\n// }\n \n// ???c?????????a,b????????????????????????(1)\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 ) &&\n        (dot(b-a, c-a) > -EPS) &&\n        (dot(a-b, c-b) > -EPS);\n}\n \n// ???c?????????a,b????????????????????????(2)\n// |a-c| + |c-b| <= |a-b| ???????????????\n// int is_point_on_line(P a, P b, P c) {\n  // return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n// }\n// a??????b???????????£???, 1 -> ???, -1 -> ???, 2 -> a????????????, -2 -> b??????????\\\\??????, 0 -> ??????ab???????????¨\nint ccw(P a,P b, P c){\n    P d = b - a;\n    c -= a;\n    double cr = cross(d, c);\n    if(cr < -EPS){ return 1; }\n    if(cr > EPS){ return -1; }\n    if(dot(d, c) < -EPS){ return 2; }\n    if(norm(d) < norm(c) - EPS){ return -2; }\n    return 0;\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n \n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n\t\t   ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\n \n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(P a1, P a2, P b1, P b2) {\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n\n    return a1 + (a2-a1) * t;\n}\n \n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n \n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ntypedef pair<P,P> S;\n\nbool is_intersected(S a, S b){\n\tif(abs(ccw(a.F, a.S, b.F))!=1&&abs(ccw(a.F, a.S, b.S))!=1) return false;\n\tif(!is_intersected_ls(a.F, a.S, b.F, b.S)) return false;\n\treturn true;\n}\n\ndouble clac_area(P a, P b, P c){\n\tdouble aa = abs(a-b), bb = abs(b-c), cc = abs(c-a);\n\tdouble s = (aa + bb + cc) / 2;\n\treturn sqrt(s * (s-aa) * (s-bb) * (s-cc));\n}\n\n\nvoid mainmain(){\n\tdouble a,b,c,d;\n\twhile(cin>>a>>b>>c>>d){\n\t\tif(a==b&&b==c&&c==d&&a==-1){\n\t\t\treturn;\n\t\t}\n\t\tvector<S> v(3);\n\t\tv[0] = {P(a,b),P(c,d)};\n\t\tcin>>a>>b>>c>>d;\n\t\tv[1] = {P(a,b),P(c,d)};\n\t\tcin>>a>>b>>c>>d;\n\t\tv[2] = {P(a,b),P(c,d)};\n\t\tbool ok = true;\n\t\trep(i,3){\n\t\t\tok &= is_intersected(v[i], v[(i+1)%3]);\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\treturn;\n\t\t}\n\t\tvector<P> w(3);\n\t\trep(i,3){\n\t\t\tw[i] = intersection_ls(v[i].F, v[i].S, v[(i+1)%3].F, v[(i+1)%3].S);\n\t\t}\n\t\tdouble ans = clac_area(w[0], w[1], w[2]);\n\t\tstring s[] = {\"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\"};\n\t\tdouble sigma[] = {1900000.0, 1000000.0, 100000.0, 0};\n\t\trep(i,4){\n\t\t\tif(ans >= sigma[i]){\n\t\t\t\tcout<<s[i]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i==3){\n\t\t\t\tassert(0);\n\t\t\t\tcout<<s[4]<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint sig(double r){return (r<-EPS)?-1:(r>EPS)?1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y) : x(x),y(y){}\n\tPt operator+(const Pt &a)const{return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt &a)const{return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt &a)const{return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt &a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt &a)const{return x*a.y-y*a.x;}\n\tbool operator<(const Pt &a)const{return (x!=a.x)?(x<a.x):(y<a.y);}\n\tbool operator==(const Pt &a)const{return (sig(x-a.x)==0&&sig(y-a.y)==0);}\n};\nostream &operator<<(ostream &os,const Pt &a){os<<\"(\"<<a.x<<\", \"<<a.y<<\")\";return os;}\ndouble tri(Pt a,Pt b,Pt c){return (b-a).det(c-a);}\n\nPt proj(Pt a,Pt b){return a*a.dot(b)/a.abs2();}\nPt perp(Pt a,Pt b,Pt c){return a+proj(b-a,c-a);}\nPt refl(Pt a,Pt b,Pt c){return perp(a,b,c)*2-c;}\n\nint iSP(Pt a,Pt b,Pt c){\n\tint s=sig((b-a).det(c-a));\n\tif(s)return s;\n\tif(sig((b-a).dot(c-a))<0)return -2;\n\tif(sig((a-b).dot(c-b))<0)return +2;\n\treturn 0;\n}\n\nint iLL(Pt a,Pt b,Pt c,Pt d){\n\tif(sig((b-a).det(d-c)))return 1;\n\tif(sig((b-a).det(c-a)))return 0;\n\treturn -1;\n}\n\nbool iSS(Pt a,Pt b,Pt c,Pt d){\n\treturn (iSP(a,b,c)*iSP(a,b,d)<=0&&iSP(c,d,a)*iSP(c,d,b)<=0);\n}\n\nPt pLL(Pt a,Pt b,Pt c, Pt d){\n\tb=b-a;d=d-c;\n\treturn a+b*(c-a).det(d)/b.det(d);\n}\n\nint main() {\n\tPt p[3][2];\n\tIL{\n\t\tcin>>p[0][0].x>>p[0][0].y;\n\t\tcin>>p[0][1].x>>p[0][1].y;\n\t\tif(p[0][0].abs()+p[0][1].abs()==0)break;\n\t\tcin>>p[1][0].x>>p[1][0].y;\n\t\tcin>>p[1][1].x>>p[1][1].y;\n\t\tcin>>p[2][0].x>>p[2][0].y;\n\t\tcin>>p[2][1].x>>p[2][1].y;\n\t\tbool ok=true;\n\t\trep(i,3){\n\t\t\tif(!iSS(p[i][0],p[i][1],p[(i+1)%3][0],p[(i+1)%3][1])\n\t\t\t\t||iLL(p[i][0],p[i][1],p[(i+1)%3][0],p[(i+1)%3][1])<1){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\\n\";\n\t\t}else{\n\t\t\tPt a,b,c;\n\t\t\ta=pLL(p[0][0],p[0][1],p[1][0],p[1][1]);\n\t\t\tb=pLL(p[1][0],p[1][1],p[2][0],p[2][1]);\n\t\t\tc=pLL(p[2][0],p[2][1],p[0][0],p[0][1]);\n//debug<<a<<endl;\n//debug<<b<<endl;\n//debug<<c<<endl;\n\t\t\tdouble s=fabs(tri(a,b,c))/2;\n//debug<<s<<endl;\n\t\t\tif(s>=1900000){\n\t\t\t\tcout<<\"dai-kichi\\n\";\n\t\t\t}else if(s>=1000000){\n\t\t\t\tcout<<\"chu-kichi\\n\";\n\t\t\t}else if(s>=100000){\n\t\t\t\tcout<<\"kichi\\n\";\n\t\t\t}else{\n\t\t\t\tcout<<\"syo-kichi\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <complex>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nbool on_line(const P& a, const L& l){\n  return dot(l[0]-a,l[1]-a)<EPS;\n}\n\nP crosspoint(const L &l, const L &m) throw(bool){\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) throw(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint x1,y1,x2,y2;\n\tfor(;~scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2),x1||y1||x2||y2;){\n\t\ttry{\n\t\t\tL A(P(x1,y1),P(x2,y2));\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tL B(P(x1,y1),P(x2,y2));\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tL C(P(x1,y1),P(x2,y2));\n\t\t\tP a=crosspoint(A,B),b=crosspoint(B,C),c=crosspoint(C,A);\n\t\t\tif(!on_line(a,A)||!on_line(a,B)||!on_line(b,B)||!on_line(b,C)||!on_line(c,C)||!on_line(c,A)){puts(\"kyo\");continue;}\n\t\t\tdouble s=abs(cross(a,b)+cross(b,c)+cross(c,a))/2;\n\t\t\tif(s<EPS)puts(\"kyo\");\n\t\t\telse if(s<100000)puts(\"syo-kichi\");\n\t\t\telse if(s<1000000)puts(\"kichi\");\n\t\t\telse if(s<1900000)puts(\"chu-kichi\");\n\t\t\telse puts(\"dai-kichi\");\n\t\t}catch(bool e){puts(\"kyo\");}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nbool intersect(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy){\n\tlong long ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n\tlong long tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n\tlong long tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n\tlong long td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n\tif(ta*tb<=0LL&&tc*td<=0LL)return true;\n\telse return false;\n}\npair<double,double>getpoint(int ax,int ay,int bx,int by,int cx,int cy ,int dx,int dy){\n\tdouble acx=cx-ax;\n\tdouble acy=cy-ay;\n\tdouble bunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tdouble r=(acx*(dy-cy)-acy*(dx-cx))/bunbo;\n\treturn make_pair(ax+(bx-ax)*r,ay+(by-ay)*r);\n}\ndouble ABS(double a){return a<0.0?-a:a;}\nint main(){\n\tint x1,x2,x3,x4,x5,x6;\n\tint y1,y2,y3,y4,y5,y6;\n\twhile(scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2),x1||x2||y1||y2){\n\t\tscanf(\"%d%d%d%d%d%d%d%d\",&x3,&y3,&x4,&y4,&x5,&y5,&x6,&y6);\n\t\tif(!intersect(x1,y1,x2,y2,x3,y3,x4,y4))printf(\"kyo\\n\");\n\t\telse if(!intersect(x1,y1,x2,y2,x5,y5,x6,y6))printf(\"kyo\\n\");\n\t\telse if(!intersect(x5,y5,x6,y6,x3,y3,x4,y4))printf(\"kyo\\n\");\n\t\telse{\n\t\t\tpair<double,double> p,q,r;\n\t\t\tp=getpoint(x1,y1,x2,y2,x3,y3,x4,y4);\n\t\t\tq=getpoint(x1,y1,x2,y2,x5,y5,x6,y6);\n\t\t\tr=getpoint(x5,y5,x6,y6,x3,y3,x4,y4);\n\t\t\tq=make_pair(q.first-p.first,q.second-p.second);\n\t\t\tr=make_pair(r.first-p.first,r.second-p.second);\n\t\t\tdouble S=ABS(q.first*r.second-q.second*r.first)/2;\n\t\t\tif(S<0.00001)printf(\"kyo\\n\");\n\t\t\telse if(S<100000.0-0.00001)printf(\"syo-kichi\\n\");\n\t\t\telse if(S<1000000.0-0.00001)printf(\"kichi\\n\");\n\t\t\telse if(S<1900000.0-0.00001)printf(\"chu-kichi\\n\");\n\t\t\telse printf(\"dai-kichi\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-b1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      VP v;\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[2].first,p[2].second));\n      D are=area(v);\n      if(are>=1900000)cout<<\"dai-kiti\"<<endl;\n      else if(are>=1000000)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000)cout<<\"kichi\"<<endl;\n      else cout<<\"syo-kichi\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n\nint main(){\n\n\tvector<pair<P,P> > v;\n\tint x1,y1,x2,y2;\n\twhile(cin>>x1>>y1>>x2>>y2&&!(x1==0&&y1==0&&x2==0&&y2==0)){\n\t\tv.clear();\n\t\tv.push_back(make_pair(P(x1,y1),P(x2,y2)));\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tcin>>x1>>y1>>x2>>y2;\n\t\t\tv.push_back(make_pair(P(x1,y1),P(x2,y2)));\n\t\t}\n\t\t// 3ð_\n\t\tvector<P> vp;\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = i + 1; j < 3; j++){\n\t\t\t\tif(is_intersected_ls(v[i].first,v[i].second,v[j].first,v[j].second)){\n\t\t\t\t\t// ð_ðvZ\n\t\t\t\t\tP p = intersection_ls(v[i].first,v[i].second,v[j].first,v[j].second);\n\t\t\t\t\tvp.push_back(p);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(f)\n\t\t\tcout<<\"kyo\"<<endl;\n\t\telse{\n\t\t\tif(EQV(vp[0],vp[1])||EQV(vp[1],vp[2])||EQV(vp[2],vp[0])){\n\t\t\t\tcout<<\"kyo\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ÊÏvZ\n\t\t\t\tdouble S = calcAreaOfTriangle(vp[0],vp[1],vp[2]);\n\t\t\t\tif(EQ(1900000,S)||S>1900000){\n\t\t\t\t\tcout<<\"dai-kichi\"<<endl;\n\t\t\t\t}\n\t\t\t\telse if((EQ(1000000,S)||S>1000000)&&(S<1900000||!EQ(1900000,S))){\n\t\t\t\t\tcout<<\"chu-kichi\"<<endl;\n\t\t\t\t}\n\t\t\t\telse if((EQ(100000,S)||S>100000)&&(S<1000000||!EQ(1000000,S))){\n\t\t\t\t\tcout<<\"kichi\"<<endl;\n\t\t\t\t}\n\t\t\t\telse if((S>0)&&(S<1000000||!EQ(1000000,S))){\n\t\t\t\t\tcout<<\"syo-kichi\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      point p[3];\n      for(int i=0;i<2;i++)\n\t    p[i]=intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b);\n      p[2]=intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b);\n\n      double z=(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]))/2;\n      double res=sqrt(z*(z-dist(p[0],p[1]))*(z-dist(p[1],p[2]))*(z-dist(p[2],p[0])));\n\n      if(res>1900000-EPS)cout <<\"dai-kichi\"<<endl;\n      else if(res>1000000-EPS)cout <<\"chu-kichi\"<<endl;\n      else if(res>100000-EPS)cout <<\"kichi\"<<endl;\n      else if(res>0+EPS)cout << \"syo-kichi\"<<endl;\n      else cout <<\"kyo\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double Eps = 1e-6;\n\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / (a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < 0)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) < 0)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(point, a, b);\n}\nbool is_in_triangle(const Point& point, const Point* triangle)\n{\n\tdouble t[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tt[i] = cross(triangle[(i+1)%3] - triangle[i], point - triangle[i]);\n\treturn t[0] >= 0 && t[1] >= 0 && t[2] >= 0\n\t\t|| t[0] <= 0 && t[1] <= 0 && t[2] <= 0;\n}\nbool is_in_triangle(const Point& point, const Point& a, const Point& b, const Point& c)\n{\n\tPoint t[3] = { a, b, c };\n\treturn is_in_triangle(point, t);\n}\nbool is_circle_in_triangle(const Point& center, double radius, const Point* triangle)\n{\n\tif (!is_in_triangle(center, triangle))\n\t\treturn false;\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_line_point(center, triangle[i], triangle[(i+1)%3]) < radius - Eps)\n\t\t\treturn false;\n\treturn true;\n}\nbool is_triangle_in_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (abs(triangle[i]-center) > radius + Eps)\n\t\t\treturn false;\n\treturn true;\n}\nbool is_interect_linesegments(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n\treturn cross(a2-a1, b1-a1)*cross(a2-a1, b2-a2) < Eps\n\t\t&& cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < Eps;\n}\nbool is_interect_triangle_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_linesegment_point(center, triangle[i], triangle[(i+1)%3]) < radius + Eps)\n\t\t\treturn true;\n\treturn false;\n}\nPoint intersectin_point(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n\tdouble d1 = distance_linesegment_point(a1, b1, b2);\n\tdouble d2 = distance_linesegment_point(a2, b1, b2);\n\tdouble prop = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * prop;\n}\ndouble area_polygon(const Point* points, int n)\n{\n\tdouble s = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\ts += cross(points[i], points[(i+1) % n]);\n\treturn abs(s / 2);\n}\ndouble area_triangle(const Point* points)\n{\n\treturn area_polygon(points, 3);\n}\ndouble area_triangle(const Point& a, const Point& b, const Point& c)\n{\n\tPoint t[] = { a, b, c };\n\treturn area_triangle(t);\n}\n\nint main()\n{\n\tdouble thresh[] = { 1900000, 1000000, 100000, 2*Eps, -1e10 };\n\tchar* kuji[] = { \"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\" };\n\twhile (true)\n\t{\n\t\tPoint p[6];\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t{\n\t\t\tint a, b, c, d;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\t\tif (i == 0 && !(a | b | c | d))\n\t\t\t\tgoto End;\n\t\t\tp[2*i] = Point(a, b);\n\t\t\tp[2*i + 1] = Point(c, d);\n\t\t}\n\n\t\tbool ng = false;\n\t\tPoint inter_p[3];\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t{\n\t\t\tif (is_interect_linesegments(p[2*i], p[2*i+1], p[2*(i+1)%6], p[(2*(i+1)+1)%6]))\n\t\t\t\tinter_p[i] = intersectin_point(p[2*i], p[2*i+1], p[2*(i+1)%6], p[(2*(i+1)+1)%6]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ng)\n\t\t{\n\t\t\tputs(\"kyo\");\n\t\t\tcontinue;\n\t\t}\n\t\tdouble area = area_triangle(inter_p);\n\t\tint i;\n\t\tfor (i = 0; i < 5; ++i)\n\t\t\tif (area + Eps > thresh[i])\n\t\t\t\tbreak;\n\t\tputs(kuji[i]);\n\t}\nEnd:\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>0)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<0)return CLOCKWISE;\n    if(dot(a,b)<0)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        double s=area(g);\n        string res;\n        if (s - 1900000 > -EPS) res = \"dai-kichi\";\n        else if (s - 1000000 > -EPS) res = \"chu-kichi\";\n        else if (s - 100000 > -EPS) res = \"kichi\";\n        else if (s > 0) res = \"syo-kichi\";\n        else res = \"kyo\";\n        cout << res << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-8\n\nusing namespace std;\n\nstruct Point \n{\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    \n\tdouble distance (const Point &o) const \n\t{\n        return sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));\n    }\n\n    Point operator+(const Point &o) const \n\t{\n        return Point(x+o.x, y+o.y);\n    }\n \n    Point operator-(const Point &o) const \n\t{\n        return Point(x-o.x, y-o.y);\n    }\n \t\n    Point operator*(const double m) const \n\t{\n   \t   return Point(x*m, y*m);\n    }\n\n    Point operator/(const double d) const \n\t{\n       return Point(x/d, y/d);\n    }\n\n    double cross(const Point &o) const \n\t{\n       return x * o.y - y * o.x;\n    }\n \n    double dot(const Point &o) const \n\t{\n        return x * o.x + y * o.y;\n    }\n \n    double atan() const \n\t{\n        return atan2(y, x);\n    }\n\n    double norm() const \n\t{\n        return sqrt(dot(*this));\n    }\n\n\tdouble area_abs(const Point &a,const Point &b) const\n\t{\n\t\tdouble t = (a.x - x) * (b.y - y);\n\t\tdouble t2 = (a.y - y) * (b.x - x);\n\t\tdouble areas = abs(t-t2);\n\t\treturn areas/2;\n\t}\n\n\t//符号付き面積\n\tdouble area(const Point &a,const Point &b)\n\t{\n\t\treturn ((a.x - x) * (b.y - y)) + ((b.x - x) * (y - a.y));\n\t}\n\t//線分abが自身の含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)\n\t\t{\n\t\t\treturn ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t\t}\n\t}\n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n\t\tif((b-a).dot(*this-a) < EPS) \n\t\t{\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS)\n\t\t{\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n\n\t//点a,b,cからなる三角形の中に自身が含まれているかどうか\n\tbool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n\t\tdouble t = (b-a).cross(*this-b);\n\t\tdouble t2 = (c-b).cross(*this-c);\n\t\tdouble t3 = (a-c).cross(*this-a);\n\t\t\n\t\tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\nstruct Seg\n{\n\tPoint a,b;\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n\n\tbool isIntersect(Seg &s)\n\t{\n\t\treturn ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);\n\t}\n\n\tPoint getCrossPoint(Seg &s)\n\t{\n\t\tPoint p = a - s.a;\n\t\tdouble temp = (b.x - a.x) * (s.b.y - s.a.y) - (b.y - a.y) * (s.b.x - s.a.x);\n\t\t\n\t\tif(fabs(temp) > EPS)\n\t\t{\n\t\t\tdouble r = ((s.b.y - s.a.y) * p.x - (s.b.x - s.a.y) * p.y) / temp;\n\t\t\tdouble s = ((b.y - a.y) * p.x - (b.x - a.x) * p.y) / temp;\n\n\t\t\tp.x = a.x + r * (b.x - a.x);\n\t\t\tp.y = a.y + r * (b.y - a.y);\n\t\t}\n\n\t\treturn p;\t\n\t}\n};\n\nint main()\n{\n\tdouble x1,y1,x2,y2,x3,y3;\n\twhile(cin >> x1 >> y1 >> x2 >> y2)\n\t{\n\t\tif(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n\t\t\n\t\tvector<Seg> v;\n\n\t\tv.push_back(Seg(Point(x1,y1),Point(x2,y2)));\n\n\t\trep(i,2)\n\t\t{\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tv.push_back(Seg(Point(x1,y1),Point(x2,y2)));\n\t\t}\n\t\t\n\t\tbool flag = false;\n\n\t\tif(!v[0].isIntersect(v[1])) flag = true;\n\t\tif(!v[1].isIntersect(v[2])) flag = true;\n\t\tif(!v[2].isIntersect(v[0])) flag = true;\n\n\t\tif(flag) cout << \"kyo\" << endl;\n\t\telse\n\t\t{\n\t\t\tPoint p1 = v[0].getCrossPoint(v[1]);\n\t\t\tPoint p2 = v[1].getCrossPoint(v[2]);\n\t\t\tPoint p3 = v[2].getCrossPoint(v[0]);\n\n\t\t\tdouble ans = p1.area_abs(p2,p3);\n\n\t\t\tif(ans >= 1900000) cout << \"dai-kichi\" << endl;\n\t\t\telse if(ans >= 1000000) cout << \"chu-kichi\" << endl;\n\t\t\telse if(ans >= 100000) cout << \"kichi\" << endl;\n\t\t\telse if (ans > 0) cout << \"syo-kichi\" << endl;\n\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n\n/*\n  ô½Cu\n*/\n\n#include<vector>\n#include<stack>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-4;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\n// _Iy[^\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\n// CCW oXg¾ªA¸xÉæé\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\n// üªÌð·»èAºÍ_ÌÝÅßéo[WA»ÌºÍxNg(üªÌ[_Åðíé)\nbool intersected_seg(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\nbool intersected_l(line a, line b){\n  return !prll(a.fr,a.sc,b.fr,b.sc);\n}\npoint intersection_seg(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersection_l(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersection_seg(seg a, seg b, point &ret){\n  if( intersected_seg(a,b) ){\n    ret = intersection_seg(a,b);\n    return true;\n  }\n  return false;\n}\nbool intersection_l(line a, line b, point &ret){\n  if( intersected_l( a, b ) ){\n    ret = intersection_l( a, b );\n    return true;\n  }\n  return false;\n}\nbool intersection_lseg(line l, seg s, point &ret){\n  point tmp;\n  if( intersection_l(l,s,tmp) ){\n    if(ccw(s.fr,s.sc,tmp)&OVER){\n      ret=tmp;\n      return true;\n    }\n  }\n  return false;\n}\n\n// Op`ÌÊÏ\nelem areaOfTriangle(elem a, elem b, elem c){\n  elem s = (a+b+c)/2;\n  return sqrt( s * (s-a) * (s-b) * (s-c) );\n}\n\nusing namespace std;\nint main(){\n  while(true){\n    seg s[3];\n    bool inv=false;\n    for(int i = 0; i <3; ++i){\n      elem x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(eq(x1,0)&&eq(y1,0)&&eq(x2,0)&&eq(y2,0))return 0;\n      s[i] = seg(point(x1,y1),point(x2,y2));\n    }\n    point a,b,c;\n    if( !intersection_seg( s[0], s[1], a ) ||\n\t!intersection_seg( s[1], s[2], b ) || \n\t!intersection_seg( s[2], s[0], c ) )\n      inv=true;\n    \n    //    cout << \" A : \" << a << \" B : \" << b << \" C : \" << c << endl;\n    elem area = areaOfTriangle( abs(b-a), abs(c-b), abs(a-c) );\n    if( inv ){\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    \n    if( geq( area, 19000000 ) ){\n      cout << \"dai-kichi\" << endl;\n    }else if( geq( area, 1000000 ) ){\n      cout << \"chu-kichi\" << endl;\n    }else if( geq( area, 100000 ) ){\n      cout << \"kichi\" << endl;\n    }else if( gtz( area ) ){\n      cout << \"syo-kichi\" << endl;\n    }else{\n      cout << \"kyo\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ndouble cross(P a,P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_parallel(P a1,P a2,P b1,P b2){\n\treturn EQ(cross(a1-a2,b1-b2),0.0);\n}\n\nint is_intersected_ls(P a1,P a2,P b1,P b2){\n\treturn cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS &&\n\t\tcross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS;\n}\n\nP intersection_ls(P a1,P a2,P b1,P b2){\n\tP b = b2 - b1;\n\tdouble d1 = abs(cross(b,a1-b1));\n\tdouble d2 = abs(cross(b,a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * t;\n}\n\ndouble polygon_area(int n, P p[]){\n\tdouble s = cross(p[n-1],p[0]);\n\tfor(int i=0;i<n-1;i++) s += cross(p[i],p[i+1]); \n\treturn fabs(s) / 2;\n}\n\nint main(void){\n\twhile(1){\n\t\tdouble s=0;\n\t\tP l[3][2],p[3];\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(!(cin>>l[i][0].real()>>l[i][0].imag()>>l[i][1].real()>>l[i][1].imag())) return 0;\n\t\t}\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint j = (i + 1) % 3;\n\t\t\tif(is_parallel(l[i][0],l[i][1],l[j][0],l[j][1]) ||\n\t\t\t\t !is_intersected_ls(l[i][0],l[i][1],l[j][0],l[j][1])){\n\t\t\t\ts = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp[i] = intersection_ls(l[i][0],l[i][1],l[j][0],l[j][1]);\n\t\t\t}\n\t\t}\n\n\t\tif(s == -1 || p[0]==p[1] && p[1]==p[2]){\n\t\t\tcout<<\"kyo\\n\";\n\t\t}\n\t\telse{\n\t\t\ts = polygon_area(3,p);\n\t\t\tif(s >= 1900000) cout<<\"dai-kichi\\n\";\n\t\t\telse if(s >= 1000000) cout<<\"chu-kichi\\n\";\n\t\t\telse if(s >= 100000) cout<<\"kichi\\n\";\n\t\t\telse cout<<\"syo-kichi\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0)cout<<\"kichi\"<<endl;\n    else if(area>0.0)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const vector<Point>& polygon){\n  double area = 0;\n  for (int i = 0; i < polygon.size(); ++i) {\n    area += cross(polygon[i], polygon[(i+1) % polygon.size()]);\n  }\n  return area;\n}\n\nint main(){\n  int x1,y1,x2,y2;\n  while(~scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2)){\n    if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n    vector<Line> lines;\n    lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    \n    for(int i = 0; i < 2; i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    }\n\n    bool isok = true;\n    \n    vector<Point> polygon;\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        if(intersectSS(lines[i],lines[j])){\n          Point p = crosspoint(lines[i],lines[j]);\n          polygon.push_back(p);\n        }\n        else{\n          isok = false;\n          goto ng;\n        }\n      }\n    }\n  ng:;\n\n    sort(polygon.begin(),polygon.end());\n    double area = -1.0;\n    if(isok){\n      area = compute_area(polygon);\n    }\n\n    if(1900000.0 <= area){\n      printf(\"%s\\n\",\"dai-kichi\");\n    }\n    else if(1000000.0 <= area && area < 1900000.0){\n      printf(\"%s\\n\",\"chu-kichi\");\n    }\n    else if(100000.0 <= area && area < 1000000.0){\n      printf(\"%s\\n\",\"kichi\");\n    }\n    else if(0.0 <= area && area < 100000.0){\n      printf(\"%s\\n\",\"syo-kichi\");\n    }\n    else {\n      printf(\"%s\\n\",\"kyo\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0)cout<<\"kichi\"<<endl;\n    else if(area>0.0)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <utility>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<double,double> pdd;\n#define x first\n#define y second\nconst double EPS = 1e-9;\nconst double INF = 1e18;\n\ntemplate<class T>\nT sqr(T obj) { return obj * obj; }\n\npdd pt(pdd a0, pdd a1, pdd b0, pdd b1) {\n\tdouble div;\n\tpdd ret;\n\n\tdiv = (a1.y - a0.y) * (b1.x - b0.x) - (b1.y - b0.y) * (a1.x - a0.x);\n\tif(fabs(div) < EPS)\n\t\treturn pdd(INF,INF);\n\n\tret.x = (a1.x - a0.x) * (b1.x * b0.y - b0.x * b1.y) - (b1.x - b0.x) * (a1.x * a0.y - a0.x * a1.y);\n\tret.y = (a1.y - a0.y) * (b1.x * b0.y - b0.x * b1.y) - (b1.y - b0.y) * (a1.x * a0.y - a0.x * a1.y);\n\tret.x /= div;\n\tret.y /= div;\n\n\treturn ret;\n}\n\nint main() {\n\twhile(1) {\n\t\tvector<pdd> v;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tdouble a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv.push_back(pdd(a,b));\n\t\t\t}\n\t\t\tif(fabs(v[0].x) < EPS && fabs(v[0].y) < EPS && fabs(v[1].x) < EPS && fabs(v[1].y) < EPS)\n\t\t\t\tgoto EXIT;\n\t\t}\n\n\t\tvector<pdd> p;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tp.push_back(pt(v[i*2 % 6], v[(i*2+1) % 6], v[(i+1)*2 % 6], v[((i+1)*2+1) % 6]));\n\t\t}\n\n\t\tstring res = \"\";\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tdouble dist0, dist1;\n\t\t\tdist0 = sqrt(sqr(v[i*2%6].x - v[(i*2+1)%6].x) + sqr(v[i*2%6].y - v[(i*2+1)%6].y));\n\t\t\tdist1 = sqrt(sqr(v[i*2%6].x - p[i].x) + sqr(v[i*2%6].y - p[i].y))\n\t\t\t\t+ sqrt(sqr(v[(i*2+1)%6].x - p[i].x) + sqr(v[(i*2+1)%6].y - p[i].y));\n\t\t\tif(p[i].x == INF || p[i].y == INF || fabs(dist0 - dist1) > EPS) {\n//\t\t\t\tcout << p[i].x << \",\" << p[i].y << endl;\n\t\t\t\tres = \"kyo\";\n\t\t\t}\n\t\t}\n\n\t\tif(res == \"\") {\n\t\t\tdouble S;\n\t\t\tS = (p[1].x - p[0].x) * (p[2].y - p[0].y) - (p[1].y - p[0].y) * (p[2].x - p[0].x);\n\t\t\tS = fabs(S);\n\n\t\t\tif(S >= 1900000)\n\t\t\t\tres = \"dai-kichi\";\n\t\t\telse if(S >= 1000000)\n\t\t\t\tres = \"chu-kichi\";\n\t\t\telse if(S >= 100000)\n\t\t\t\tres = \"kichi\";\n\t\t\telse if(S < EPS)\n\t\t\t\tres = \"kyo\";\n\t\t\telse\n\t\t\t\tres = \"syo-kichi\";\n\t\t}\n\t\tcout << res << endl;\n\t}\n\nEXIT:;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint sig(double r){return (r<-EPS)?-1:(r>EPS)?1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y) : x(x),y(y){}\n\tPt operator+(const Pt &a)const{return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt &a)const{return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt &a)const{return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt &a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt &a)const{return x*a.y-y*a.x;}\n\tbool operator<(const Pt &a)const{return (x!=a.x)?(x<a.x):(y<a.y);}\n\tbool operator==(const Pt &a)const{return (sig(x-a.x)==0&&sig(y-a.y)==0);}\n};\nostream &operator<<(ostream &os,const Pt &a){os<<\"(\"<<a.x<<\", \"<<a.y<<\")\";return os;}\ndouble tri(Pt a,Pt b,Pt c){return (b-a).det(c-a);}\n\nPt proj(Pt a,Pt b){return a*a.dot(b)/a.abs2();}\nPt perp(Pt a,Pt b,Pt c){return a+proj(b-a,c-a);}\nPt refl(Pt a,Pt b,Pt c){return perp(a,b,c)*2-c;}\n\nint iSP(Pt a,Pt b,Pt c){\n\tint s=sig((b-a).det(c-a));\n\tif(s)return s;\n\tif(sig((b-a).dot(c-a))<0)return -2;\n\tif(sig((a-b).dot(c-b))<0)return +2;\n\treturn 0;\n}\n\nbool iSS(Pt a,Pt b,Pt c,Pt d){\n\treturn (iSP(a,b,c)*iSP(a,b,d)<=0&&iSP(c,d,a)*iSP(c,d,b)<=0);\n}\n\nPt pLL(Pt a,Pt b,Pt c, Pt d){\n\tb=b-a;d=d-c;\n\treturn a+b*(c-a).det(d)/b.det(d);\n}\n\nint main() {\n\tPt p[3][2];\n\tIL{\n\t\tcin>>p[0][0].x>>p[0][0].y;\n\t\tcin>>p[0][1].x>>p[0][1].y;\n\t\tif(p[0][0].abs()+p[0][1].abs()==0)break;\n\t\tcin>>p[1][0].x>>p[1][0].y;\n\t\tcin>>p[1][1].x>>p[1][1].y;\n\t\tcin>>p[2][0].x>>p[2][0].y;\n\t\tcin>>p[2][1].x>>p[2][1].y;\n\t\tbool ok=true;\n\t\trep(i,3){\n\t\t\tif(!iSS(p[i][0],p[i][1],p[(i+1)%3][0],p[(i+1)%3][1])){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\\n\";\n\t\t}else{\n\t\t\tPt a,b,c;\n\t\t\ta=pLL(p[0][0],p[0][1],p[1][0],p[1][1]);\n\t\t\tb=pLL(p[1][0],p[1][1],p[2][0],p[2][1]);\n\t\t\tc=pLL(p[2][0],p[2][1],p[0][0],p[0][1]);\n//debug<<a<<endl;\n//debug<<b<<endl;\n//debug<<c<<endl;\n\t\t\tdouble s=abs(tri(a,b,c))/2;\n//debug<<s<<endl;\n\t\t\tif(s>=1900000){\n\t\t\t\tcout<<\"dai-kichi\\n\";\n\t\t\t}else if(s>=1000000){\n\t\t\t\tcout<<\"chu-kichi\\n\";\n\t\t\t}else if(s>=100000){\n\t\t\t\tcout<<\"kichi\\n\";\n\t\t\t}else{\n\t\t\t\tcout<<\"syo-kichi\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\ndouble areaTriangle(polygon p) {\n\tp[0] = p[0] - p[2];\n\tp[1] = p[1] - p[2];\n\treturn fabs(p[0].x * p[1].y - p[1].x * p[0].y) / 2.0;\n}\n\nstring omikuji(const vector<segment>& segments) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tconst segment& s = segments[i], t = segments[(i + 1) % 3];\n\t\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\t\tif(abs(tmp) < EPS || !intersect(s, t))\n\t\t\treturn \"kyo\";\n\t}\n\n\tpolygon triangle;\n\tfor(int i = 0; i < 3; ++i)\n\t\ttriangle.push_back(crosspoint(segments[i], segments[(i + 1) % 3]));\n\n\tconst double area_of_triangle = areaTriangle(triangle);\n\tif(area_of_triangle >= 1900000)\n\t\treturn \"dai-kichi\";\n\n\tif(area_of_triangle >= 1000000)\n\t\treturn \"chu-kichi\";\n\n\tif(area_of_triangle >= 100000)\n\t\treturn \"kichi\";\n\n\treturn \"syo-kichi\";\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y, x2, y2; cin >> x >> y >> x2 >> y2, (x | y | x2 | y2);) {\n\t\tvector<segment> segments;\n\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y >> x2 >> y2;\n\t\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\t}\n\n\t\tstring result = omikuji(segments);\n\t\tcout << result << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        double s=area(g);\n        string res;\n        if (s - 1900000 > -EPS) res = \"dai-kichi\";\n        else if (s - 1000000 > -EPS) res = \"chu-kichi\";\n        else if (s - 100000 > -EPS) res = \"kichi\";\n        else if (s > 0) res = \"syo-kichi\";\n        else res = \"kyo\";\n        cout << res << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nPoint Minus(Point a, Point b) { return Point{ a.px - b.px,a.py - b.py }; }\nPoint Plus(Point a, Point b) { return Point{ a.px + b.px,a.py + b.py }; }\nlong double area(vector<Point> v) {\n\tlong double ret = 0.0L;\n\tfor (int i = 0; i < v.size(); i++) ret += crs(v[i], v[(i + 1) % v.size()]);\n\treturn ret / 2;\n}\nPoint crp(Line a, Line b) {\n\tPoint c = Minus(b.p2, b.p1);\n\tlong double d1 = abs(crs(c, Minus(a.p1 , b.p1)));\n\tlong double d2 = abs(crs(c, Minus(a.p2, b.p1)));\n\tlong double T = d1 / (d1 + d2);\n\tPoint H = Plus(a.p1, Minus(a.p2, a.p1));\n\tH.px *= T; H.py *= T;\n\treturn H;\n}\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0); }\nbool its(const Line& s1, const Line& s2) { return its(s1.p1, s1.p2, s2.p1, s2.p2); }\nint main() {\n\twhile (true) {\n\t\tvector<Point>I; Line E[3]; bool OK = false;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> E[i].p1.px >> E[i].p1.py >> E[i].p2.px >> E[i].p2.py;\n\t\t\tif (i == 0 && E[0].p1.px + E[0].p1.py + E[0].p2.px + E[0].p2.py < 1e-10) { OK = true; goto E; }\n\t\t}\n\tE:; if (OK == true)break;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (its(E[i], E[(i + 1) % 3]) == true) {\n\t\t\t\tI.push_back(crp(E[i], E[(i + 1) % 3]));\n\t\t\t}\n\t\t}\n\t\tint A = area(I);\n\t\tif (A >= 1900000)cout << \"dai-kichi\" << endl;\n\t\telse if (A >= 1000000)cout << \"chu-kichi\" << endl;\n\t\telse if (A >= 100000)cout << \"kichi\" << endl;\n\t\telse if (A > 1e-9)cout << \"syo-kichi\" << endl;\n\t\telse { cout << \"kyo\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n        if(isParallel(a,b)||isParallel(b,c)||isParallel(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        if(equalsv(g[0],g[1])&&equalsv(g[1],g[2])&&equalsv(g[2],g[0])){\n            puts(\"kyo\");\n            continue;\n        }\n        double x=area(g);\n        if(x<100000)puts(\"syo-kichi\");\n        else if(x<1000000)puts(\"kichi\");\n        else if(x<1900000)puts(\"chu-kichi\");\n        else puts(\"dai-kichi\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const vector<Point>& polygon){\n  double area = 0;\n  for (int i = 0; i < polygon.size(); ++i) {\n    area += cross(polygon[i], polygon[(i+1) % polygon.size()]);\n  }\n  return area;\n}\n\nint main(){\n  int x1,y1,x2,y2;\n  while(~scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2)){\n    if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n    vector<Line> lines;\n    lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    \n    for(int i = 0; i < 2; i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    }\n\n    bool isok = true;\n    \n    vector<Point> polygon;\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        if(intersectSS(lines[i],lines[j])){\n          Point p = crosspoint(lines[i],lines[j]);\n          polygon.push_back(p);\n        }\n        else{\n          isok = false;\n          goto ng;\n        }\n      }\n    }\n  ng:;\n\n    sort(polygon.begin(),polygon.end());\n    double area = -1.0;\n    if(isok){\n      area = compute_area(polygon);\n    }\n\n    if(1900000.0 <= area){\n      printf(\"%s\\n\",\"dai-kichi\");\n    }\n    else if(1000000.0 <= area && area < 1900000.0){\n      printf(\"%s\\n\",\"chu-kichi\");\n    }\n    else if(100000.0 <= area && area < 1000000.0){\n      printf(\"%s\\n\",\"kichi\");\n    }\n    else if(0 <= area && area < 100000.0){\n      printf(\"%s\\n\",\"syo-kichi\");\n    }\n    else {\n      printf(\"%s\\n\",\"kyo\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define EPS 1e-8\n\nusing namespace std;\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tdouble distance (const Point &o) const\n\t{\n\t\treturn sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));\n\t}\n\n\tPoint operator+(const Point &o) const\n\t{\n\t\treturn Point(x+o.x, y+o.y);\n\t}\n\n\tPoint operator-(const Point &o) const\n\t{\n\t\treturn Point(x-o.x, y-o.y);\n\t}\n\n\tPoint operator*(const double m) const\n\t{\n\t\treturn Point(x*m, y*m);\n\t}\n\n\tPoint operator/(const double d) const\n\t{\n\t\treturn Point(x/d, y/d);\n\t}\n\n\tdouble cross(const Point &o) const\n\t{\n\t\treturn x * o.y - y * o.x;\n\t}\n\n\tdouble dot(const Point &o) const\n\t{\n\t\treturn x * o.x + y * o.y;\n\t}\n\n\tdouble atan() const\n\t{\n\t\treturn atan2(y, x);\n\t}\n\n\tdouble norm() const\n\t{\n\t\treturn sqrt(dot(*this));\n\t}\n\n\tdouble area_abs(const Point &a,const Point &b) const\n\t{\n\t\tdouble t = (a.x - x) * (b.y - y);\n\t\tdouble t2 = (a.y - y) * (b.x - x);\n\t\tdouble areas = abs(t-t2);\n\t\treturn areas/2;\n\t}\n\n\t//符号付き面積\n\tdouble area(const Point &a,const Point &b)\n\t{\n\t\treturn ((a.x - x) * (b.y - y)) + ((b.x - x) * (y - a.y));\n\t}\n\n\t//線分abが自身に含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)\n\t\t{\n\t\t\treturn ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t\t}\n\t}\n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n\t\tif((b-a).dot(*this-a) < EPS)\n\t\t{\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS)\n\t\t{\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n\n\t//点a,b,cからなる三角形の中に自身が含まれているかどうか\n\tbool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n\t\tdouble t = (b-a).cross(*this-b);\n\t\tdouble t2 = (c-b).cross(*this-c);\n\t\tdouble t3 = (a-c).cross(*this-a);\n\t\tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\nstruct Seg\n{\n\tPoint a,b;\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n\n\tbool isIntersect(Seg &s)\n\t{\n\t\tif(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);\n\t}\n\n   \tPoint getCrossPoint(Seg &s)\n\t{\n\t\tPoint p = s.b - s.a;\n\t\tdouble d = abs(p.cross(a-s.a));\n\t\tdouble d2 = abs(p.cross(b-s.a));\n\n\t\tdouble t = d / (d+d2);\n\t\treturn a + (b-a)*t;\n\t}\n\n};\n\ndouble polygonArea(const vector<Point>& p)\n{\n    int n = p.size();\n    double ret = 0.0;\n    for(int i=0; i<n; ++i)\n        ret += p[i].cross(p[(i+1)%n]);\n    return abs(ret) / 2.0;\n}\n\nint main()\n{\n\tdouble xa,ya,xb,yb;\n\twhile(cin >> xa >> ya >> xb >> yb)\n\t{\n\t\tif(xa == 0 && ya == 0 && xb == 0 && yb == 0) break;\n\n\t\tvector<Seg> v;\n\t\tv.push_back(Seg(Point(xa,ya),Point(xb,yb)));\n\n\t\trep(i,2)\n\t\t{\n\t\t\tcin >> xa >> ya >> xb >> yb;\n\t\t\tv.push_back(Seg(Point(xa,ya),Point(xb,yb)));\n\t\t}\n\t\t\n\t\tbool flag = false;\n\t\tif(!v[0].isIntersect(v[1])) flag = true;\n\t\tif(!v[1].isIntersect(v[2])) flag = true;\n\t\tif(!v[2].isIntersect(v[0])) flag = true;\n\n\t\tif(flag) cout << \"kyo\" << endl;\n\t\telse\n\t\t{\n\t\t\tvector<Point> p;\n\t\t\trep(i,3)\n\t\t\t{\n\t\t\t\tp.push_back(v[i].getCrossPoint(v[(i+1)%3]));\n\t\t\t}\n\n\t\t\tdouble ret = polygonArea(p);\n\t\t\tif(ret >= 1900000.0)\n\t\t\t{\n\t\t\t\tcout << \"dai-kichi\" << endl;\n\t\t\t}\n\t\t\telse if(ret >= 1000000.0)\n\t\t\t{\n\t\t\t\tcout << \"chu-kichi\" << endl;\n\t\t\t}\n\t\t\telse if(ret >= 100000.0)\n\t\t\t{\n\t\t\t\tcout << \"kichi\" << endl;\n\t\t\t}\n\t\t\telse if(ret > EPS)\n\t\t\t{\n\t\t\t\tcout << \"syo-kichi\" << endl;\n\t\t\t} \n\t\t\telse cout << \"kyo\" << endl;\n\t\t}\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n        if(isParallel(a,b)||isParallel(b,c)||isParallel(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        if(equalsv(g[0],g[1])&&equalsv(g[1],g[2])&&equalsv(g[2],g[0])){\n            puts(\"kyo\");\n            continue;\n        }\n        double x=area(g);\n        if(x<EPS)puts(\"kyo\");\n        else if(x<100000)puts(\"syo-kichi\");\n        else if(x<1000000)puts(\"kichi\");\n        else if(x<1900000)puts(\"chu-kichi\");\n        else puts(\"dai-kichi\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  if(!isIntersect(a1,a2,b1,b2))\n    {\n      return Point(-9993999,-9993999);\n    }\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  double a,b,c;\n  a = sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));\n  b = sqrt(pow(p2.x-p3.x,2)+pow(p2.y-p3.y,2));\n  c = sqrt(pow(p1.x-p3.x,2)+pow(p1.y-p3.y,2));\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n\n\n      if((c1 == c2 && c2 == c3) || !isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n     \n      double area = getArea(c1,c2,c3);\n\n      if(0.0 <= area && area < 100000)\n\tcout << \"syo-kichi\" << endl;\n      else if(100000 <= area && area < 1000000)\n\tcout << \"kichi\" << endl;\n      else if(1000000 <= area && area < 1900000)\n\tcout << \"chu-kichi\" << endl;\n      else if(1900000 <= area)\n\tcout << \"dai-kichi\" << endl; \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      point p[3];\n      for(int i=0;i<2;i++)\n\t    p[i]=intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b);\n      p[2]=intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b);\n\n      double z=(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]))/2;\n      double res=sqrt(z*(z-dist(p[0],p[1]))*(z-dist(p[1],p[2]))*(z-dist(p[2],p[0])));\n\n      if(res>1900000-EPS)cout <<\"dai-kichi\"<<endl;\n      else if(res>1000000-EPS)cout <<\"chu-kichi\"<<endl;\n      else if(res>100000-EPS)cout <<\"kichi\"<<endl;\n      else cout << \"syo-kichi\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n// struct G : public vector<Point>\n// {\n//     G() {}\n//     G(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| is_on_seg(seg1, seg2.first)\n\t\t|| is_on_seg(seg1, seg2.second)\n\t\t|| is_on_seg(seg2, seg1.first)\n\t\t|| is_on_seg(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"cross_point_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"cross_point_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079\ngtype area(const G& p)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\ts += cross(p[i], p[(i + 1) % p.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain{ OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (is_on_seg(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// 円\nenum res_circle_rela\n{\n    a_in_b,\n    b_in_a,\n\n    tangent,\n    intersect,\n    not_intersect,\n};\n// AOJ0023(feps = 0)\nres_circle_rela circle_rela(const Circle& a, const Circle& b)\n{\n    const gtype feps = 0;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    Point ab = b.p - a.p;\n    Point c = a.p + ab * (a.r / (a.r + b.r));\n\n    gtype dis = abs(a.p - c);\n    if (dis > a.r + feps)\n        return vector<Point>();\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - dis*dis));\n\n    Point u = ab * Point(0, 1) / abs(ab);\n    Point v = ab * Point(0, -1) / abs(ab);\n\n    Point p = c + u * h;\n    Point q = c + v * h;\n\n    vector<Point> res;\n    res.push_back(p);\n    if (abs(p - q) > feps)\n        res.push_back(q); // 2点で交わっている\n\n    return res;\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nbool contain_CP(const Circle& c, const Point& p)\n{\n    return abs(c.p - p) < c.r;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\nint main()\n{\n    for (;;)\n    {\n        Line l[3];\n        rep(i, 3)\n            if (!(cin >> l[i].first >> l[i].second))\n                goto END;\n\n        G g;\n        rep(i, 3) rep(j, i)\n            if (intersect_SS(l[i], l[j]) && !is_parallel(l[i], l[j]))\n                g.pb(ip_SS(l[i], l[j]));\n\n        string res;\n        if (g.size() == 3)\n        {\n            double s = area(g);\n            if (s >= 1900000)\n                res = \"dai-\";\n            else if (s >= ten(6))\n                res = \"chu-\";\n            else if (s >= ten(5))\n                res = \"\";\n            else\n                res = \"syo-\";\n            res += \"kichi\";\n        }\n        else\n            res = \"kyo\";\n        cout << res << endl;\n    }\nEND:\n    ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\ntypedef long long int Int;\nconst Int N = 3;\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nInt ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npair<bool, P> crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return pair<bool, P>(0, m[0]); // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return pair<bool, P>(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nbool input(L &l){\n  Int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n  l = L(P(x1, y1), P(x2, y2));\n  return (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0);\n}\n\ndouble area(const G &P) {\n  double A = 0.0;\n  for (Int i = 0; i < P.size(); ++i) A += cross(curr(P, i), next(P, i));\n  return abs(A / 2.0);\n}\n\nstring solve(L ls[N]){\n  G g;\n  REP(i, N){\n    if(!intersectSS(ls[i], ls[(i + 1) % N])) return \"kyo\";\n    else{\n      pair<bool, P> res = crosspointLL(ls[i], ls[(i + 1) % N]);\n      if(!res.first) return \"kyo\";\n      g.push_back(res.second);\n    }\n  }\n  double r = area(g);\n  if(r > 0 && r < 100000) return \"syo-kichi\";\n  else if(r < 1000000) return \"kichi\";\n  else if(r < 1900000) return \"chu-kichi\";\n  return \"dai-kichi\";\n}\n\nint main() {\n  L ls[N];\n  while(input(ls[0])){\n    FOR(i, 1, N) input(ls[i]);\n    cout <<solve(ls) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\ntypedef ld  Weight;\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,c??????????¨???¨?????????????????¶\n//-1: a,b,c???????¨???¨?????????????????¶\n// 2: c,a,b???????????´???????????¶\n//-2: a,b,c???????????´???????????¶\n// 0: a,c,b???????????´???????????¶\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//???????±??????????????????????\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n/*  0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), all(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n//???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\trep(i, n) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\n\n\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) {\n\t\t\tif (isis_sp(s[i], p[j]))\n\t\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\t}\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, 1, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\npair<vector<Point>, Graph> sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll2(s[i], s[j])[0]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\tsort(crss.begin(), crss.end());\n\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\n\treturn make_pair(crss, segment_arrangement(s, crss));\n}\n\nGraph Circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tconst int n = p.size(), m = c.size();\n\tGraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, 1, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, 1, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main() {\n\twhile (1) {\n\t\tbool flag = true;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (!x1&&!x2&&!y1&&!y2)flag = false;\n\t\t\tls.push_back(Line(Point(x1, y1), Point(x2, y2)));\n\t\t}\n\t\tif (!flag) {\n\t\t\tbreak;\n\t\t}\n\t\tvector<Point>ps;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tLine l(ls[i]);\n\t\t\tLine r(ls[(i + 1) % 3]);\n\t\t\tif (!isis_ss(l, r))flag = false;\n\t\t\telse {\n\t\t\t\tps.emplace_back(is_ss(l, r));\n\t\t\t}\n\t\t}\n\t\tif (!flag){\n\t\t\tcout << \"kyo\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tld aarea = abs(area(ps));\n\t\taarea += eps;\n\t\tif (aarea < 2 * eps)cout << \"kyo\" << endl;\n\t\telse if (aarea < 100000)cout << \"syo-kichi\" << endl;\n\t\telse if (aarea < 1000000)cout << \"kichi\" << endl;\n\t\telse if (aarea < 1900000)cout << \"chu-kichi\" << endl;\n\t\telse cout << \"dai-kichi\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/////////////////////???Library???/////////////////////////\n\nint xx1, yy1, xx2, yy2;\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tif (xx1 == 0 && yy1 == 0 && xx2 == 0 && yy2 == 0) break;\n\t\t\n\t\tSegment s1(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s2(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s3(Point(xx2, yy2), Point(xx1, yy1));\n\n\t\tif (isParallel(s1, s2) || isParallel(s1, s3) || isParallel(s2, s3))\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint kousa_num = 0;\n\t\tif (intersect(s1, s2)) kousa_num++;\n\t\tif (intersect(s1, s3)) kousa_num++;\n\t\tif (intersect(s2, s3)) kousa_num++;\n\t\t//printf(\"kousa_num = %d\\n\", kousa_num);\n\t\tif (kousa_num <= 2)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tPoint p1 = getCrossPoint(s1, s2);\n\t\tPoint p2 = getCrossPoint(s1, s3);\n\t\tPoint p3 = getCrossPoint(s2, s3);\n\n\t\t/*\n\t\tprintf(\"p1 = (%f, %f)\\n\", p1.x, p1.y);\n\t\tprintf(\"p2 = (%f, %f)\\n\", p2.x, p2.y);\n\t\tprintf(\"p3 = (%f, %f)\\n\", p3.x, p3.y);\n\t\t*/\n\n\t\tif (p1 == p2 && p2 == p3)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVector v12 = p2 - p1;\n\t\tVector v13 = p3 - p1;\n\n\t\tdouble ans = abs(cross(v12, v13) / 2.0f);\n\t\tif (ans >= 1900000.0f) printf(\"dai-kichi\\n\");\n\t\telse if (ans >= 1000000.0f) printf(\"chu-kichi\\n\");\n\t\telse if (ans >= 100000.0f) printf(\"kichi\");\n\t\telse printf(\"syo-kichi\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\n#define EPS\t\t\t(1e-10)\n#define PI\t\t\t(3.14159265358979323846)\n\n\n#define X(a)\t\t( (a).real() )\n#define Y(a)\t\t( (a).imag() )\n#define EQ(a,b)\t\t( -EPS<(a)-(b) && (a)-(b)<EPS )\n#define EQV(a,b)\t( EQ(X(a),X(b)) && EQ(Y(a),Y(b)) )\n\n#define unit(a)\t\t( (a)/abs(a) )\n#define normal(a)\t( (a)*P(0,1) )\n#define dot(a,b)\t( X((a)*conj(b)) )\n#define cross(a,b)\t( Y(conj(a)*(b)) )\n\n// 3ツ点ツづ個暗環置ツ甘鳴係\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t// a--b--c on line\n\treturn 0;\n}\n\n// ツ静シツ閉ェツづ静シツ閉ェツづ個古ーツ債キツ板サツ津ィ\nbool intersectSS(P a, P b, P c, P d)\n{\n\treturn\tccw(a,b,c)*ccw(a,b,d) <= 0 &&\n\t\t\tccw(c,d,a)*ccw(c,d,b) <= 0;\n}\n\nP crosspointLL(P a, P b, P c, P d)\n{\n\tdouble det=cross(d-c,b-a);\n\tassert(!(abs(det)<EPS));\n\n\treturn a + (b-a) * cross(d-c,c-a)/det;\n\t\n\t// u=b-a  ->  a + tu ( t = cross(d-c,c-a)/det )\n\t// v=d-c  =>  c + sv ( s = cross(b-a,c-a)/det )\n}\n\nint main()\n{\n\tP p[6];\n\twhile(cin >> X(p[0]) >> Y(p[0]) >> X(p[1]) >> Y(p[1]), X(p[0])||Y(p[0])||X(p[1])||Y(p[1]))\n\t{\n\t\tcin >> X(p[2]) >> Y(p[2]) >> X(p[3]) >> Y(p[3]);\n\t\tcin >> X(p[4]) >> Y(p[4]) >> X(p[5]) >> Y(p[5]);\n\n\t\tbool crs = true;\n\t\tfor(int i=0; i<6; i+=2)\n\t\t{\n\t\t\tif(!intersectSS(p[i],p[i+1],p[(i+2)%6],p[(i+3)%6]))\n\t\t\t{\n\t\t\t\tcrs=false; break;\n\t\t\t}\n\n\t\t\tif(EQ(cross(p[i+1]-p[i],p[(i+3)%6]-p[(i+2)%6]),0.0))\n\t\t\t{\n\t\t\t\tcrs=false; break;\n\t\t\t}\n\t\t}\n\n\t\tif(crs)\n\t\t{\n\t\t\tP c[3];\n\n\t\t\tfor(int i=0; i<6; i+=2)\n\t\t\t{\n\t\t\t\t\tc[i/2] = crosspointLL(p[i],p[i+1],p[(i+2)%6],p[(i+3)%6]);\n\t\t\t}\n\t\t\t\n\t\t\tdouble s = abs(cross(c[1]-c[0],c[2]-c[0]))/2;\n\n\t\t\tif(EQ(s,0.0))\n\t\t\t{\n\t\t\t\tcout << \"kyo\" << endl;\n\t\t\t}\n\t\t\telse if(s<100000)\n\t\t\t{\n\t\t\t\tcout << \"syo-kichi\" << endl;\n\t\t\t}\n\t\t\telse if(s<1000000)\n\t\t\t{\n\t\t\t\tcout << \"kichi\" << endl;\n\t\t\t}\n\t\t\telse if(s<1900000)\n\t\t\t{\n\t\t\t\tcout << \"chu-kichi\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"dai-kichi\" << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/////////////////////???Library???/////////////////////////\n\nint xx1, yy1, xx2, yy2;\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tif (xx1 == 0 && yy1 == 0 && xx2 == 0 && yy2 == 0) break;\n\t\t\n\t\tSegment s1(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s2(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s3(Point(xx2, yy2), Point(xx1, yy1));\n\n\t\tif (isParallel(s1, s2) || isParallel(s1, s3) || isParallel(s2, s3))\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint kousa_num = 0;\n\t\tif (intersect(s1, s2)) kousa_num++;\n\t\tif (intersect(s1, s3)) kousa_num++;\n\t\tif (intersect(s2, s3)) kousa_num++;\n\t\t//printf(\"kousa_num = %d\\n\", kousa_num);\n\t\tif (kousa_num <= 2)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tPoint p1 = getCrossPoint(s1, s2);\n\t\tPoint p2 = getCrossPoint(s1, s3);\n\t\tPoint p3 = getCrossPoint(s2, s3);\n\n\t\t/*\n\t\tprintf(\"p1 = (%f, %f)\\n\", p1.x, p1.y);\n\t\tprintf(\"p2 = (%f, %f)\\n\", p2.x, p2.y);\n\t\tprintf(\"p3 = (%f, %f)\\n\", p3.x, p3.y);\n\t\t*/\n\n\t\tif (p1 == p2 || p2 == p3 || p1 == p3)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVector v12 = p2 - p1;\n\t\tVector v13 = p3 - p1;\n\n\t\tdouble ans = fabs(cross(v12, v13)) / 2.0f;\n\t\tif (ans >= 1900000.0f) printf(\"dai-kichi\\n\");\n\t\telse if (ans >= 1000000.0f) printf(\"chu-kichi\\n\");\n\t\telse if (ans >= 100000.0f) printf(\"kichi\");\n\t\telse printf(\"syo-kichi\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0-EPS)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0-EPS)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0-EPS)cout<<\"kichi\"<<endl;\n    else if(area>=0.0)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      point p[3];\n      for(int i=0;i<2;i++)\n\t    p[i]=intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b);\n      p[2]=intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b);\n\n      double z=(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]))/2;\n      double res=sqrt(z*(z-dist(p[0],p[1]))*(z-dist(p[1],p[2]))*(z-dist(p[2],p[0])));\n\n      if(res>=1900000)cout <<\"dai-kichi\"<<endl;\n      else if(res>=1000000 && res <1900000)cout <<\"chu-kichi\"<<endl;\n      else if(res>=100000 && res<1000000)cout <<\"kichi\"<<endl;\n      else if(res>0 && res<100000)cout << \"syo-kichi\"<<endl;\n      else cout <<\"kyo\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\n// geometry library start\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n\tP proj(const P& p) const { double k=det(p)/norm2(); return P(x*k, y*k); }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\nint sign(double r) { return r < -EPS ? -1 : r > EPS ? 1 : 0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tP proj(const P& p) { return s + vec().proj(p - s); }\n\tint iLL(const L& l) const {\n\t\tif(sign(vec().det(l.vec()))) return 1;\n\t\tif(sign(vec().det(l.s - s))) return 0;\n\t\treturn -1;\n\t}\n\tbool iLS(const L& l) const { return sign(tri(s, t, l.s)) * sign(tri(s, t, l.t)) <= 0; } \n\tbool iSS(const L& l) const { return iLS(l) && l.iLS(*this); }\n\tP pLL(const L& l) const { return s + vec() * (l.s - s).det(l.vec()) / t.det(l.vec()); }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) >= 0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n// geometry library end\nint x1, z1, x2, z2;\nL E[3];\nP T[3];\n\nint area[4] = { 1900000, 1000000, 100000, 0 };\nstring fort[4] = { \"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\" };\n\nvoid solve() {\n\trep(i,3) {\n\t\tif(!E[i].iSS(E[(i+1)%3])) {\n\t\t\tprintf(\"kyo\\n\");\n\t\t\treturn;\n\t\t}\n\t\tT[i] = E[i].pLL(E[(i+1)%3]);\n\t}\n\t\n\tdouble S = abs((T[1] - T[0]).det(T[2] - T[1])) * 0.5;\n\trep(i,4) {\n\t\tif(S >= area[i]) {\n\t\t\tcout << fort[i] << endl;\n\t\t\treturn;\n\t\t}\n\t}\t\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tif(x1==0 && z1==0 && x2==0 && z2==0) break;\n\t\tE[0] = L(P(x1, z1), P(x2, z2));\n\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tE[1] = L(P(x1, z1), P(x2, z2));\n\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tE[2] = L(P(x1, z1), P(x2, z2));\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)); s2 = abs(cross(a1,b2));\n\tif(s1<EPS && s2<EPS) return false;\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\tif(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x || p.x<min(m.a.x,m.b.x) || max(m.a.x,m.b.x)<p.x ||\n\t   p.y<min(l.a.y,l.b.y) || max(l.a.y,l.b.y)<p.y || p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2.0);\n\t\t//printf(\"\\t%lf\\n\",s);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000.0) puts(\"syo-kichi\");\n\t\telse if(s<1000000.0) puts(\"kichi\");\n\t\telse if(s<1900000.0) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\ntypedef complex<double> Point;\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\ntypedef Line Segment;\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\ndouble CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tdouble sign=Signum(Cross(d1,d2));\n\tif(sign)\n\t\treturn sign;\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\n\treturn 0;\n}\n\n// 直線と線分が重なるとき，線分の端点が直線上にあるときもtrue\nbool IntersectLS(Line a,Segment b)\n{\n\treturn CCW(a.pos,a.pos+a.dir,b.pos)*CCW(a.pos,a.pos+a.dir,b.pos+b.dir)<=0;\n}\nbool IntersectSS(Segment a,Segment b)\n{\n\treturn IntersectLS(a,b) && IntersectLS(b,a);\n}\n\n// aとbが平行でないことが前提\nPoint IntersectPoint(Line a,Line b)\n{\n\treturn a.pos+a.dir*Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir);\n}\n\nconst char* solve(Line* ls)\n{\n\tPoint ps[3];\n\tfor(int i=0;i<3;i++){\n\t\tLine l1=ls[i],l2=ls[(i+1)%3];\n\t\tif(Signum(Cross(l1.dir,l2.dir))==0)\n\t\t\treturn \"kyo\";\n\t\tif(!IntersectSS(l1,l2))\n\t\t\treturn \"kyo\";\n\t\tps[i]=IntersectPoint(l1,l2);\n\t}\n\t\n\tdouble area=abs(Cross(ps[1]-ps[0],ps[2]-ps[0]));\n\tif(area<1.0e5-EPS)\n\t\treturn \"syo-kichi\";\n\tif(area<1.0e6-EPS)\n\t\treturn \"kichi\";\n\tif(area<1.9e6-EPS)\n\t\treturn \"chu-kichi\";\n\treturn \"dai-kichi\";\n}\n\nint main()\n{\n\tfor(;;){\n\t\tLine ls[3];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint x1,y1,x2,y2; scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tls[i]=Line(Point(x1,y1),Point(x2-x1,y2-y1));\n\t\t}\n\t\tif(feof(stdin))\n\t\t\tbreak;\n\t\tputs(solve(ls));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    c -= a;\n    b -= a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isIntersect(L s1, L s2){\n    return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n             ccw(s2.first,s2.second,s2.first) * ccw(s2.first,s2.second,s1.second) <= 0);\n}\n\nP crossPoint(L l, L m){\n    double A = cross(l.second - l.first, m.second - m.first);\n    double B = cross(l.second - l.first, l.second - m.first);\n    if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n    else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n    double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum / 2.0);\n}\n\nstring ans(vector<P> v){\n    double a = area(v);\n    if(a < EPS) return \"kyo\";\n    if(a < 100000.0) return \"syo-kichi\";\n    if(a < 1000000.0) return \"kichi\";\n    if(a < 1900000.0) return \"chu-kichi\";\n    return \"dai-kichi\";\n}\n\nint main(){\n    double x1,y1,x2,y2;\n    while(cin >> x1 >> y1 >> x2 >> y2 && (x1||y1||x2||y2)){\n        L v[3];\n        vector<P> p(3);\n        bool f = false;\n        v[0] = L(P(x1,y1),P(x2,y2));\n        for(int i=1;i<3;i++) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            v[i] = L(P(x1,y1),P(x2,y2));\n            if(!isIntersect(v[0],v[i])) f = true;\n            else p[i-1] = crossPoint(v[0],v[i]);\n        }\n        if(!isIntersect(v[1],v[2])) f = true;\n        else p[2] = crossPoint(v[1],v[2]);\n\n        for(int i=0;i<3;i++){\n            for(int j=i+1;j<3;j++){\n                if(abs(p[i]-p[j]) < EPS) f = true;\n            }\n        }\n\n        if(f) cout << \"kyo\" << endl;\n        else cout << ans(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int i,j,x1[3],y1[3],x2[3],y2[3],ty[3]/*x=c >> 1, y=c >> 2*/;\n  double a[3],b[3],x3[3],y3[3],sen[3],s;\n  long long ans;\n  while(1){\n    cin >> x1[0] >> y1[0] >> x2[0] >> y2[0];\n    if(x1[0] == 0 && x2[0] == 0 && y1[0] == 0 && y2[0] == 0) break;\n    for(i=1;i<3;i++) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\n    for(i=0;i<3;i++){// y = a * x + b\n      a[i] = b[i] = 0.0;\n      if(x1[i] == x2[i]) ty[i] = 1;\n      else if(y1[i] == y2[i]){\n\tty[i] = 2;\n\ta[i] = 0.0;\n\tb[i] = (double)y1[i];\n      }\n      else{\n\ta[i] =(double)  (y1[i] - y2[i]) / (x1[i] - x2[i]);\n\tb[i] = (double) y1[i] - a[i] * x1[i];\n\tty[i] = 0;\n      }\n    }\n\n    ans = 0;\n    for(i=0;i<3;i++){ //ÃÂ¿ÃÂ¹ÃÂ¤ÃÂ¾ÃÂ¬ÃÂ¹ÃÂ§\n      if(ty[i] == 1 && ty[(i+1)%3] == 1){\n\tans = -1;\n\tbreak;\n      }\n      else if(ty[i] != 1 && ty[(i+1)%3] != 1 && a[i] == a[(i+1)%3]){\n\tans = -1;\n\tbreak;\n      }\n    }\n\n    if(ans == 0){\n      for(i=0;i<3;i++){\n\tif(ty[i] == 1){\n\t  x3[i] = (double)x1[i];\n\t  y3[i] = a[(i+1)%3] * x3[i] + b[(i+1)%3];\n\t}\n\telse{\n\t  x3[i] = (b[(i+1)%3] - b[i]) / (a[i] - a[(i+1)%3]);\n\t  if(b[(i+1)%3] == b[i]) x3[i] = 0.0;\n\t  y3[i] = a[i] * x3[i] + b[i];\n\t}\n\n\tif( (x1[i] <= x2[i] &&(x1[i] > x3[i] || x3[i] > x2[i]))  ||  (x2[i] < x1[i] &&(x2[i] > x3[i] || x3[i] > x1[i]))  ||  (y1[i] <= y2[i] &&(y1[i] > y3[i] || y3[i] > y2[i]))  ||  (y2[i] < y1[i] &&(y2[i] > y3[i] || y3[i] > y1[i])) ){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n\telse if( (x1[(i+1)%3] <= x2[(i+1)%3] &&(x1[(i+1)%3] > x3[i] || x3[i] > x2[(i+1)%3]))  ||  (x2[(i+1)%3] < x1[(i+1)%3] &&(x2[(i+1)%3] > x3[i] || x3[i] > x1[(i+1)%3]))  ||  (y1[(i+1)%3] <= y2[(i+1)%3] &&(y1[(i+1)%3] > y3[i] || y3[i] > y2[(i+1)%3]))  ||  (y2[(i+1)%3] < y1[(i+1)%3] &&(y2[(i+1)%3] > y3[i] || y3[i] > y1[(i+1)%3])) ){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n      }\n\n      s = 0.0;\n      for(i=0;i<3;i++){\n\tsen[i] = sqrt( pow(x3[i] - x3[(i+1)%3],2) + pow(y3[i] - y3[(i+1)%3],2));\n\ts += sen[i];\n      }\n      \n      s /= 2;\n      if(ans == 0) ans = (long long)sqrt(s * (s - sen[0]) * (s - sen[1]) * (s - sen[2]));\n      \n      int c = 0;\n      for(i=0;i<3;i++){ //ÃÂ£ÃÂ³ÃÂ¤ÃÂ¤ÃÂÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂ¬ÃÂ£ÃÂ±ÃÂÃÂÃÂ¤ÃÂ¸ÃÂ²ÃÂ¤ÃÂ¯ÃÂ¤ÃÂ«\n\tif(x3[i] == x3[(i+1)%3] && y3[i] == y3[(i+1)%3]) c++;\n      }\n      if(c == 3) ans = -1;\n    }\n\n    if(ans >= 1900000) cout << \"dai-kichi\" << endl;\n    else if(ans >= 1000000) cout << \"chu-kichi\" << endl;\n    else if(ans >= 100000) cout << \"kichi\" << endl;\n    else if(ans > 0) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  if(!isIntersect(a1,a2,b1,b2))\n    {\n      return Point(-9993999,-9993999);\n    }\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(4);\n  p[0] = p1,p[1] = p2,p[2] = p3,p[3] = p[0];\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += (p[i].x - p[i+1].x)*(p[i].y+p[i+1].y);\n  return fabs(sum/2.0);\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n     \n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上 (aがbまたはcと重なる場合を含む)\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  // 直線lと直線mが平行でない\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  // 直線lとl[0]からm[0]への直線が並行\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(注意: 同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  // 直線lについて、線分sの端点が異なる側にある\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; \n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  // 直線lとl[0]からpへの直線が平行\n  return abs(cross(l.vector(), p - l[0])) < EPS;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定(端点を含む)\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  // 円の中心と点の距離が、円の半径以下である\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  // pからlに下ろした垂線の長さ\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  // 平行でないときは0, 平行のときは垂線の長さ\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); // 垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\n// 点が多角形のどこにあるのか判定する\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p){\n  // 点pから半直線をひき、辺と交差する回数を数える\n  bool in = false;\n  REP(i, P.size()){\n    Point a = curr(P, i) - p;\n    Point b = next(P, i) - p;\n    if(a.y > b.y) swap(a, b);\n    // aからbの直線がy=0と交わり、その交点は原点の右側である\n    if(a.y <= 0 && 0 < b.y && cross(a, b) < 0){ \n      in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// 多角形の面積\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\n\nstring solve(vector<Line>& ls){\n  vector<Point> ps;\n  REP(i, 3) FOR(j, i + 1, 3){\n    if(equalLL(ls[i], ls[j])) return \"kyo\";\n    if(!intersectSS(ls[i], ls[j])) return \"kyo\";\n    ps.push_back(crosspointLL(ls[i], ls[j]));\n  }\n  double res = area(ps);\n  if(res < 0) res *= -1;\n  if(res > 1900000 - EPS) return \"dai-kichi\";\n  if(res > 1000000 - EPS) return \"chu-kichi\";\n  if(res > 100000 - EPS) return \"kichi\";\n  if(res > EPS) return \"syo-kichi\";\n  return \"kyo\";\n}\nint main(){\n  while(true){\n    vector<Line> ls;\n    REP(i, 3){\n      Point a, b; cin >> a >> b;\n      ls.push_back(Line(a, b));\n    }\n    if(cin.eof()) return 0;\n    cout << solve(ls) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\n// geometry library start\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n\tP proj(const P& p) const { double k=det(p)/norm2(); return P(x*k, y*k); }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\nint sign(double r) { return r < -EPS ? -1 : r > EPS ? 1 : 0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tP proj(const P& p) { return s + vec().proj(p - s); }\n\tint iLL(const L& l) const {\n\t\tif(sign(vec().det(l.vec()))) return 1;\n\t\tif(sign(vec().det(l.s - s))) return 0;\n\t\treturn -1;\n\t}\n\tbool iLS(const L& l) const { return sign(tri(s, t, l.s)) * sign(tri(s, t, l.t)) <= 0; } \n\tbool iSS(const L& l) const { return iLS(l) && l.iLS(*this); }\n\tP pLL(const L& l) const { return s + vec() * (l.s - s).det(l.vec()) / t.det(l.vec()); }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) >= 0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n// geometry library end\nint x1, z1, x2, z2;\nL E[3];\nP T[3];\n\nint area[4] = { 1900000, 1000000, 100000, 0 };\nstring fort[4] = { \"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\" };\n\nvoid solve() {\n\trep(i,3) {\n\t\tif(!E[i].iSS(E[(i+1)%3])) {\n\t\t\tprintf(\"kyo\\n\");\n\t\t\treturn;\n\t\t}\n\t\tT[i] = E[i].pLL(E[(i+1)%3]);\n\t}\n\t\n\tdouble S = abs((T[1] - T[0]).det(T[2] - T[1])) * 0.5;\n\trep(i,4) {\n\t\tif(i==3) {\n\t\t\tif(sign(S - area[i]) > 0) {\n\t\t\t\tcout << fort[i] << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if(sign(S - area[i]) >= 0) {\n\t\t\tcout << fort[i] << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"kyo\\n\");\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tif(x1==0 && z1==0 && x2==0 && z2==0) break;\n\t\tE[0] = L(P(x1, z1), P(x2, z2));\n\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tE[1] = L(P(x1, z1), P(x2, z2));\n\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tE[2] = L(P(x1, z1), P(x2, z2));\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Point{\n\tdouble x,y;\n};\n\nstruct Line{\n\tPoint p1,p2;\n};\nLine line[3];\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\ndouble calc_S(Point a,Point b,Point c){\n\treturn fabs((b.x*a.y - b.y*a.x)+(c.x*b.y - c.y*b.x)+(a.x*c.y - a.y*c.x))/2;\n}\n\nvoid func(){\n\n\tscanf(\"%lf %lf %lf %lf\",&line[1].p1.x,&line[1].p1.y,&line[1].p2.x,&line[1].p2.y);\n\tscanf(\"%lf %lf %lf %lf\",&line[2].p1.x,&line[2].p1.y,&line[2].p2.x,&line[2].p2.y);\n\n\tbool cross_12 = false,cross_13 = false,cross_23 = false;\n\tPoint A,B,C;\n\n\tif(func(line[0].p1.x,line[0].p1.y,line[0].p2.x,line[0].p2.y,line[1].p1.x,line[1].p1.y)*\n\t\t\tfunc(line[0].p1.x,line[0].p1.y,line[0].p2.x,line[0].p2.y,line[1].p2.x,line[1].p2.y) <= 0 &&\n\t\t\tfunc(line[1].p1.x,line[1].p1.y,line[1].p2.x,line[1].p2.y,line[0].p1.x,line[0].p1.y)*\n\t\t\tfunc(line[1].p1.x,line[1].p1.y,line[1].p2.x,line[1].p2.y,line[0].p2.x,line[0].p2.y) <= 0){\n\t\tcross_12 = true;\n\t\tA = calc_Cross_Point(line[0].p1.x,line[0].p2.x,line[1].p1.x,line[1].p2.x,line[0].p1.y,line[0].p2.y,line[1].p1.y,line[1].p2.y);\n\t}\n\tif(!cross_12){\n\t\tprintf(\"kyo\\n\");\n\t\treturn;\n\t}\n\n\tif(func(line[0].p1.x,line[0].p1.y,line[0].p2.x,line[0].p2.y,line[2].p1.x,line[2].p1.y)*\n\t\t\tfunc(line[0].p1.x,line[0].p1.y,line[0].p2.x,line[0].p2.y,line[2].p2.x,line[2].p2.y) <= 0 &&\n\t\t\tfunc(line[2].p1.x,line[2].p1.y,line[2].p2.x,line[2].p2.y,line[0].p1.x,line[0].p1.y)*\n\t\t\tfunc(line[2].p1.x,line[2].p1.y,line[2].p2.x,line[2].p2.y,line[0].p2.x,line[0].p2.y) <= 0){\n\t\tcross_13 = true;\n\t\tB = calc_Cross_Point(line[0].p1.x,line[0].p2.x,line[2].p1.x,line[2].p2.x,line[0].p1.y,line[0].p2.y,line[2].p1.y,line[2].p2.y);\n\t}\n\tif(!cross_13){\n\t\tprintf(\"kyo\\n\");\n\t\treturn;\n\t}\n\n\n\tif(func(line[1].p1.x,line[1].p1.y,line[1].p2.x,line[1].p2.y,line[2].p1.x,line[2].p1.y)*\n\t\t\tfunc(line[1].p1.x,line[1].p1.y,line[1].p2.x,line[1].p2.y,line[2].p2.x,line[2].p2.y) <= 0 &&\n\t\t\tfunc(line[2].p1.x,line[2].p1.y,line[2].p2.x,line[2].p2.y,line[1].p1.x,line[1].p1.y)*\n\t\t\tfunc(line[2].p1.x,line[2].p1.y,line[2].p2.x,line[2].p2.y,line[1].p2.x,line[1].p2.y) <= 0){\n\t\tcross_23 = true;\n\t\tC = calc_Cross_Point(line[1].p1.x,line[1].p2.x,line[2].p1.x,line[2].p2.x,line[1].p1.y,line[1].p2.y,line[2].p1.y,line[2].p2.y);\n\t}\n\tif(!cross_23){\n\t\tprintf(\"kyo\\n\");\n\t\treturn;\n\t}\n\n\n\tdouble S = calc_S(A,B,C);\n\n\tif(S < EPS){\n\t\tprintf(\"kyo\\n\");\n\t}else{\n\t\tif(S >= 1900000.0){\n\t\t\tprintf(\"dai-kichi\\n\");\n\t\t}else if(S >= 1000000.0){\n\t\t\tprintf(\"chu-kichi\\n\");\n\t\t}else if(S >= 100000.0){\n\t\t\tprintf(\"kichi\\n\");\n\t\t}else{\n\t\t\tprintf(\"syo-kichi\\n\");\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%lf %lf %lf %lf\",&line[0].p1.x,&line[0].p1.y,&line[0].p2.x,&line[0].p2.y);\n\t\tif(line[0].p1.x == 0 && line[0].p1.y == 0 && line[0].p2.x == 0 && line[0].p2.y == 0)break;\n\n\t\tfunc();\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    c -= a;\n    b -= a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isIntersect(L s1, L s2){\n    return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n             ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0);\n}\n\nP crossPoint(L l, L m){\n    double A = cross(l.second - l.first, m.second - m.first);\n    double B = cross(l.second - l.first, l.second - m.first);\n    if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n    else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n    double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum / 2.0);\n}\n\nstring ans(vector<P> v){\n    double a = area(v);\n    if(a < EPS) return \"kyo\";\n    if(a < 100000.0-EPS) return \"syo-kichi\";\n    if(a < 1000000.0-EPS) return \"kichi\";\n    if(a < 1900000.0-EPS) return \"chu-kichi\";\n    return \"dai-kichi\";\n}\n\nint main(){\n    double x1,y1,x2,y2;\n    while(cin >> x1 >> y1 >> x2 >> y2 && (x1||y1||x2||y2)){\n        L v[3];\n        vector<P> p;\n        bool f = false;\n        v[0] = L(P(x1,y1),P(x2,y2));\n        for(int i=1;i<3;i++) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            v[i] = L(P(x1,y1),P(x2,y2));\n            if(!isIntersect(v[0],v[i])) f = true;\n            else p.push_back(crossPoint(v[0],v[i]));\n        }\n        if(!isIntersect(v[1],v[2])) f = true;\n        else p.push_back(crossPoint(v[1],v[2]));\n\n        if(!f){\n            for(int i=0;i<3;i++){\n                for(int j=i+1;j<3;j++){\n                    if(abs(p[i]-p[j]) < EPS) f = true;\n                }\n            }\n        }\n\n        if(f) cout << \"kyo\" << endl;\n        else cout << ans(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) < EPS &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) < EPS );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define EPS (1e-10)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\ndouble getArea(vector<Point>& vec)\n{\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(vec[i],vec[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\n\n\nint main()\n{\n\n int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Segment s1(a,b),s2(c,d),s3(e,f);\n\n\n      if(!isIntersect(s1,s2) || !isIntersect(s2,s3) || !isIntersect(s3,s1))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(s1.p1,s1.p2,s2.p1,s2.p2);\n      c2 = getCrossPoint(s2.p1,s2.p2,s3.p1,s3.p2);\n      c3 = getCrossPoint(s3.p1,s3.p2,s1.p1,s1.p2);\n      vector<Point> vec;\n      vec.push_back(c1),vec.push_back(c2),vec.push_back(c3);\n      double area = getArea(vec);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { }};\nint ccw(P a, P b, P c) {b -= a; c -= a;if (cross(b, c) > 0)   return +1;if (cross(b, c) < 0)   return -1;if (dot(b, c) < 0) return +2;if (norm(b) < norm(c)) return -2;return 0;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nP crosspoint(const L &l, const L &m) {double A = cross(l[1] - l[0], m[1] - m[0]);double B = cross(l[1] - l[0], l[1] - m[0]);if (abs(A) < EPS && abs(B) < EPS) return m[0];return m[0] + B / A * (m[1] - m[0]);}\ndouble area2(P a, P b , P c){\n\t\tb-=a, c-=a , a-=a;\n\t\treturn fabs( b.real() * c.imag() - c.real() * b.imag() )/2; \n}\nint main(){\n\tdouble a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a+b+c+d != 0){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tdouble ret = 0;\n\t\t/*\n\t\t\tcout << intersectSS(one,two) << endl;\n\t\t\tcout << intersectSS(two,three) << endl;\n\t\t\tcout << intersectSS(one,three) << endl;\n\t\t*/\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tG npts;\n\t\t\tnpts.push_back( crosspoint(one,two) );\n\t\t\tnpts.push_back( crosspoint(two,three) );\n\t\t\tnpts.push_back( crosspoint(one,three) );\n\t\t\t//sort(all(npts));\n\t\t\tret = area2(npts[0],npts[1],npts[2]);\n\t\t}\n\t\tif(ret >= 1900000){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if(ret >= 1000000+EPS){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if(ret >= 100000+EPS){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret >= EPS){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#define EPS 1e-10\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQP(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){return real(conj(a)*b);}\ndouble cross(P a,P b){return imag(conj(a)*b);}\ndouble area(P a,P b,P c){return abs(cross(b-a,c-a)/2);}\nbool para(P a1,P a2,P b1,P b2){return abs(cross(a1-a2,b1-b2))<EPS;}\nbool is_cp(P a1,P a2,P b1,P b2){\n  if(cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS)\n    if(cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) < EPS)return true;\n  return false;\n}\nP seg_cp(P a1,P a2,P b1,P b2){\n  b2-=b1;\n  double d = abs(cross(b2,a1-b1));\n  return a1 + (a2-a1)*d/( d + abs(cross(b2,a2-b1)) );\n}\n\nint main(){\n  P p11,p12,p21,p22,p31,p32;\n\n  for(;;){\n    cin >> p11.real() >> p11.imag() >> p12.real() >> p12.imag();\n    if(!abs(p11) && !abs(p12))break;\n    cin >> p21.real() >> p21.imag() >> p22.real() >> p22.imag();\n    cin >> p31.real() >> p31.imag() >> p32.real() >> p32.imag();\n\n    if(para(p11,p12,p21,p22) || para(p21,p22,p31,p32) || para(p31,p32,p11,p12))\n      cout << \"kyo\\n\";\n    else if(!is_cp(p11,p12,p21,p22) || !is_cp(p21,p22,p31,p32) || !is_cp(p31,p32,p11,p12))\n      cout << \"kyo\\n\";\n    else{\n      P cp1 = seg_cp(p11,p12,p21,p22);\n      P cp2 = seg_cp(p21,p22,p31,p32);\n      P cp3 = seg_cp(p31,p32,p11,p12);\n      if(EQP(cp1,cp2))cout << \"kyo\\n\";\n      else{\n\tdouble s = area(cp1,cp2,cp3);\n\tif(s+EPS>1900000)cout << \"dai-kichi\\n\";\n\telse if(s+EPS>1000000)cout << \"chu-kichi\\n\";\n\telse if(s+EPS>100000)cout << \"kichi\\n\";\n\telse cout << \"syo-kichi\\n\";\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define EPS (1e-10)\n\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point (double x=0,double y=0): x(x),y(y){}\n    \n    Point operator + (Point p)\t{return Point( x+p.x,y+p.y );\t}\n    Point operator - (Point p)\t{return Point( x-p.x,y-p.y );\t}\n    Point operator * (double a)\t{return Point( a*x,a*y );\t\t}\n    Point operator / (double a)\t{return Point( x/a,y/a );\t\t}\n    \n    double abs(){ return sqrt(norm());}\n    double norm(){ return x*x + y*y; }\n    \n    bool operator < ( const Point &p ) const{\n        return x!= p.x ? x<p.x : y<p.y;\n    }\n    \n    bool operator == ( const Point &p ) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\n\nstruct Segment{\n    Point p1,p2;\n};\n\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2-s2.p1;\n    double d1=abs(cross(base, s1.p1-s2.p1));\n    double d2=abs(cross(base, s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)  return 1;\n    if(cross(a,b)<-EPS) return -1;\n    if(dot(a,b)<-EPS)   return 2;\n    if(a.norm()<b.norm())return -2;\n    \n    return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4) <=EPS &&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2) <=EPS );\n}\n\n\nbool isCross(Segment s1,Segment s2){\n    return intersect(s1.p1, s1.p2,s2.p1,s2.p2);\n}\n\nint main(){\n    \n    int a,b,c,d;\n    while(cin>>a>>b>>c>>d){\n        int flag=false;\n        if(a==0 && b==0 && c==0 && d==0)break;\n        \n        Point p[6];\n        p[0]=Point(a,b);\n        p[1]=Point(c,d);\n        rep(i,4){\n            int m,n;\n            cin>>m>>n;\n            p[2+i]=Point(m,n);\n        }\n        //end input\n        \n        Segment seg[3];\n        rep(i,3){\n            seg[i].p1=p[i*2];\n            seg[i].p2=p[i*2+1];\n        }\n        \n        Point cr[3];\n        rep(i,3){\n            if( !isCross( seg[i],seg[ (i+1)%3 ] ) )flag=true;\n            else{\n                cr[i]=getCrossPoint(seg[i],seg[ (i+1)%3 ]);\n                if( isnan(cr[i].x) || isnan(cr[i].y) )flag=true;\n            }\n        }\n        if( abs(cr[0].x-cr[1].x)<EPS && abs(cr[0].y-cr[1].y)<EPS && abs(cr[1].x-cr[2].x)<EPS && abs(cr[1].y-cr[2].y)<EPS )flag=true;\n        \n        if(flag)cout<<\"kyo\"<<endl;\n        else{\n            double ans=abs(  ( cr[0].x * cr[1].y + cr[1].x*cr[2].y + cr[2].x*cr[0].y -cr[0].y*cr[1].x - cr[2].y*cr[0].x )/2  );\n            if(ans<100000+EPS)cout<<\"syo-kichi\"<<endl;\n            else if(ans<1000000+EPS)cout<<\"kichi\"<<endl;\n            else if(ans<1900000+EPS)cout<<\"chu-kichi\"<<endl;\n            else cout<<\"dai-kichi\"<<endl;\n            \n        }\n        \n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n  \n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n \n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n  \n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n    return sqrt(norm(p));\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<=0)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<=0);\n}\n\nbool intersectLL(Line l,Line m){\n\treturn fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS || //平行である\n\t\t\tfabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //同一の線\n}\n\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5;\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea;\n}\n \n\n\nPoint crosspoint(Line l,Line m){\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nint main(){\n\twhile(true){\n        bool endflg = false;\n        Line l[3];\n        rep(i,3){\n            double x1,y1,x2,y2;\n            scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n            if(i == 0){\n                if(x1 == 0.0 && y1 == 0.0 && x2 == 0.0 && y2 == 0.0){\n                    endflg = true;\n                    break;\n                }\n            }\n            l[i].PB(Point(x1,y1));\n            l[i].PB(Point(x2,y2));\n        }\n        if(endflg)break;\n        Point p[3];\n        p[0] = crosspoint(l[0],l[1]);\n        p[1] = crosspoint(l[0],l[2]);\n        p[2] = crosspoint(l[1],l[2]);\n        if(intersectLL(l[0],l[1])||intersectLL(l[0],l[2])||intersectLL(l[1],l[2])){\n        \tputs(\"kyo\");\n        \tcontinue;\n        }\n        double area = fabs(TriangleArea(p[0],p[1],p[2]));\n        if(area-1900000>EPS)puts(\"dai-kichi\");\n        else if(area-1000000>EPS)puts(\"chu-kichi\");\n        else if(area-100000>EPS)puts(\"kichi\");\n        else if(area>EPS)puts(\"syo-kichi\");\n        else puts(\"kyo\");\n        //printf(\"%.10lf\\n\",area);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nPoint Minus(Point a, Point b) { return Point{ a.px - b.px,a.py - b.py }; }\nPoint Plus(Point a, Point b) { return Point{ a.px + b.px,a.py + b.py }; }\nlong double area(vector<Point> v) {\n\tlong double ret = 0.0L;\n\tfor (int i = 0; i < v.size(); i++) ret += crs(v[i], v[(i + 1) % v.size()]);\n\treturn ret / 2;\n}\nPoint crp(Line a, Line b) {\n\tPoint c = Minus(b.p2, b.p1);\n\tlong double d1 = abs(crs(c, Minus(a.p1 , b.p1)));\n\tlong double d2 = abs(crs(c, Minus(a.p2, b.p1)));\n\tlong double T = d1 / (d1 + d2);\n\tPoint H = Plus(a.p1, Minus(a.p2, a.p1));\n\tH.px *= T; H.py *= T;\n\treturn H;\n}\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) { return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0); }\nbool its(const Line& s1, const Line& s2) { return its(s1.p1, s1.p2, s2.p1, s2.p2); }\nint main() {\n\twhile (true) {\n\t\tvector<Point>I; Line E[3]; bool OK = false;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> E[i].p1.px >> E[i].p1.py >> E[i].p2.px >> E[i].p2.py;\n\t\t\tif (i == 0 && E[0].p1.px + E[0].p1.py + E[0].p2.px + E[0].p2.py < 1e-10) { OK = true; goto E; }\n\t\t}\n\tE:; if (OK == true)break;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (its(E[i], E[(i + 1) % 3]) == true) {\n\t\t\t\tI.push_back(crp(E[i], E[(i + 1) % 3]));\n\t\t\t}\n\t\t}\n\t\tint A = area(I);\n\t\tif (A >= 1899999.999999)cout << \"dai-kichi\" << endl;\n\t\telse if (A >= 999999.999999)cout << \"chu-kichi\" << endl;\n\t\telse if (A >= 99999.99999)cout << \"kichi\" << endl;\n\t\telse if (A > 1e-6)cout << \"syo-kichi\" << endl;\n\t\telse { cout << \"kyo\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=EPS)cout<<\"syo-kichi\"<<endl;\n      else exit(1);\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nbool intersect(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy){\n\tlong long ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n\tlong long tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n\tlong long tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n\tlong long td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n\tif(ta*tb<=0LL&&tc*td<=0LL)return true;\n\telse return false;\n}\npair<double,double>getpoint(int ax,int ay,int bx,int by,int cx,int cy ,int dx,int dy){\n\tdouble acx=cx-ax;\n\tdouble acy=cy-ay;\n\tdouble bunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tdouble r=(acx*(dy-cy)-acy*(dx-cx))/bunbo;\n\treturn make_pair(ax+(bx-ax)*r,ay+(by-ay)*r);\n}\ndouble ABS(double a){return a<0.0?-a:a;}\nint main(){\n\tint x1,x2,x3,x4,x5,x6;\n\tint y1,y2,y3,y4,y5,y6;\n\twhile(scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2),x1||x2||y1||y2){\n\t\tscanf(\"%d%d%d%d%d%d%d%d\",&x3,&y3,&x4,&y4,&x5,&y5,&x6,&y6);\n\t\tif(!intersect(x1,y1,x2,y2,x3,y3,x4,y4))printf(\"kyo\\n\");\n\t\telse if(!intersect(x1,y1,x2,y2,x5,y5,x6,y6))printf(\"kyo\\n\");\n\t\telse if(!intersect(x5,y5,x6,y6,x3,y3,x4,y4))printf(\"kyo\\n\");\n\t\telse{\n\t\t\tpair<double,double> p,q,r;\n\t\t\tp=getpoint(x1,y1,x2,y2,x3,y3,x4,y4);\n\t\t\tq=getpoint(x1,y1,x2,y2,x5,y5,x6,y6);\n\t\t\tr=getpoint(x5,y5,x6,y6,x3,y3,x4,y4);\n\t\t\tq=make_pair(q.first-p.first,q.second-p.second);\n\t\t\tr=make_pair(r.first-p.first,r.second-p.second);\n\t\t\tdouble S=ABS(q.first*r.second-q.second*r.first)/2;\n\t\t\tif(S<0.00001)printf(\"kyo\\n\");\n\t\t\telse if(S<100000.0-0.00001)printf(\"syo-kichi\\n\");\n\t\t\telse if(S<1000000.0-0.00001)printf(\"kichi\\n\");\n\t\t\telse if(S<1900000.0-0.00001)printf(\"chu-kichi\\n\");\n\t\t\telse printf(\"dai-kichi\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1.0e-12;\n\nstruct Point {\n  public:\n    double x, y;\n    Point() {};\n    Point(double _x, double _y) : x(_x), y(_y) {};\n    Point operator+(const Point &rhs) const {\n      return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n      return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(double rhs) const {\n      return Point(this->x * rhs, this->y * rhs); \n    }\n};\n\nPoint intersect(Point &a0, Point &a1, Point &b0, Point &b1, int &err) {\n  Point p;\n  double s, t;\n  Point a01 = a1 - a0;\n  Point b10 = b0 - b1;\n  Point c = b0 - a0;\n  double det = a01.x * b10.y - a01.y * b10.x;\n  \n  err = 0;\n  if (abs(det) < EPS) { // two lines are parallel\n    err = 1;\n  } else {\n    s = (b10.y * c.x - b10.x * c.y) / det;\n    t = (a01.x * c.y - a01.y * c.x) / det;\n    if (s < -EPS || s > 1.0 + EPS || t < -EPS || t > 1.0 + EPS) {\n      err = 2;\n    }\n    p = a0 + a01 * s;\n  }\n  return p;\n}\n\ndouble triangleArea(Point &a, Point &b, Point &c) {\n  Point ab = b - a;\n  Point ac = c - a;\n  return abs(ab.x * ac.y - ab.y * ac.x);\n}\n\nint main() {\n  int err;\n  double area;\n  Point p[6];\n  Point a, b, c;\n  while (1) {\n    cin >> p[0].x >> p[0].y;\n    cin >> p[1].x >> p[1].y;\n    if (!p[0].x && !p[0].y && !p[1].x && !p[1].y) {\n      break;\n    }\n    for (int i=2; i<6; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    a = intersect(p[0], p[1], p[2], p[3], err);\n    if (!err) b = intersect(p[2], p[3], p[4], p[5], err);\n    if (!err) c = intersect(p[4], p[5], p[0], p[1], err);\n    if (err) {\n      cout << \"kyo\" << endl;\n    } else {\n      area = triangleArea(a, b, c);\n      if (area < 100000) {\n        cout << \"syo-kichi\" << endl;\n      } else if (area < 1000000) {\n        cout << \"kichi\" << endl;\n      } else if (area < 1900000) {\n        cout << \"chu-kichi\" << endl;\n      } else {\n        cout << \"dai-kichi\" << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\ntypedef long long int Int;\nconst Int N = 3;\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nInt ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npair<bool, P> crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return pair<bool, P>(0, m[0]); // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return pair<bool, P>(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nbool input(L &l){\n  Int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n  l = L(P(x1, y1), P(x2, y2));\n  return (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0);\n}\n\ndouble area(const G &P) {\n  double A = 0.0;\n  for (Int i = 0; i < P.size(); ++i) A += cross(curr(P, i), next(P, i));\n  return abs(A / 2.0);\n}\n\nstring solve(L ls[N]){\n  G g;\n  REP(i, N){\n    if(!intersectSS(ls[i], ls[(i + 1) % N])) return \"kyo\";\n    else{\n      pair<bool, P> res = crosspointLL(ls[i], ls[(i + 1) % N]);\n      if(!res.first) return \"kyo\";\n      g.push_back(res.second);\n    }\n  }\n  double r = area(g);\n  if(r < 100000) return \"syo-kichi\";\n  if(r < 1000000) return \"kichi\";\n  if(r < 1900000) return \"chu-kichi\";\n  return \"dai-kichi\";\n}\n\nint main() {\n  L ls[N];\n  while(input(ls[0])){\n    FOR(i, 1, N) input(ls[i]);\n    cout <<solve(ls) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) return P(11111,11111);   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += abs(cross(ps[i], ps[(i+1) % ps.size()]));\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=abs(area(v));\n      rep(i,3)if(v[i].X==v[i].Y&&v[i].X==11111)goto L;\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=0)cout<<\"syo-kichi\"<<endl;\n      else{\n        L:;\n        cout<<\"kyo\"<<endl;\n      }\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nclass Line\n{\npublic:\n    double a, b, c; // a*x + b*y + c = 0\n    Line(){\n        a = c = 0.0;\n        b = 1.0;\n    }\n    Line(double a0, double b0, double c0){\n        a = a0;\n        b = b0;\n        c = c0;\n    }\n    Line(const Point& p1, const Point& p2){ // 2_ðÔ¼ü\n        double dy = p2.y - p1.y;\n        double dx = p2.x - p1.x;\n        if(abs(dy / dx) < EPS){\n            a = 0.0;\n            b = 1.0;\n            c = -p1.y;\n        }else if(abs(dx / dy) < EPS){\n            a = 1.0;\n            b = 0.0;\n            c = -p1.x;\n        }else{\n            a = - dy / dx;\n            b = 1.0;\n            c = dy / dx * p1.x - p1.y;\n        }\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) + EPS || min(b1.x, b2.x) > max(a1.x, a2.x) + EPS || min(a1.y, a2.y) > max(b1.y, b2.y) + EPS || min(b1.y, b2.y) > max(a1.y, a2.y) + EPS)\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) <= EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) <= EPS);\n}\n\nbool linesIntersection(const Line& l1, const Line& l2, Point& intersection)\n{\n    double s = l1.a*l2.b - l2.a*l1.b;\n    if(abs(s) < EPS)\n        return false;\n\n    intersection = Point(l2.a*l1.c - l1.a*l2.c, l1.b*l2.c - l2.b*l1.c) / s;\n    return true;\n}\n\ndouble polygonArea(const vector<Point>& p)\n{\n    int n = p.size();\n    double ret = 0.0;\n    for(int i=0; i<n; ++i)\n        ret += p[i].cross(p[(i+1)%n]);\n    return abs(ret) / 2.0;\n}\n\nint main()\n{\n    for(;;){\n        vector<Point> p(6);\n        for(int i=0; i<6; ++i)\n            cin >> p[i].x >> p[i].y;\n        if(p[0].x == 0 && p[0].y == 0 && p[1].x == 0 && p[1].y == 0)\n            return 0;\n\n        bool kyo = false;\n        for(int i=0; i<3; ++i){\n            if(!segmentsCollide(p[i*2], p[i*2+1], p[(i+1)*2%6], p[((i+1)*2+1)%6]))\n                kyo = true;\n        }\n        if(kyo){\n            cout << \"kyo\" << endl;\n            continue;\n        }\n\n        vector<Line> line(3);\n        for(int i=0; i<3; ++i)\n            line[i] = Line(p[i*2], p[i*2+1]);\n        vector<Point> p1(3);\n        for(int i=0; i<3; ++i)\n            linesIntersection(line[i], line[(i+1)%3], p1[i]);\n\n        double area = polygonArea(p1);\n        if(area > 1900000 - EPS)\n            cout << \"dai-kichi\" << endl;\n        else if(area > 1000000 - EPS)\n            cout << \"chu-kichi\" << endl;\n        else if(area > 100000 - EPS)\n            cout << \"kichi\" << endl;\n        else\n            cout << \"syo-kichi\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-6;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n    if( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n    return ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 点 a から 点 b への角度を返す [0,2π]\ndouble dir(P a, P b) {\n\tP p = a - b;\n\tdouble angle = atan2( p.Y , p.X );\n\tif( p.X < 0 ) angle += PI;\n\tif( angle < 0 ) angle += 2.0 * PI;\n\treturn angle;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n};\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n\t// 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n};\n\n\nint main(){\n\tint x1, y1, x2, y2;\n\twhile( cin >> x1 >> y1 >> x2 >> y2 , x1 || y1 || x2 || y2 ){\n\t\tSegment s1( P(x1,y1) , P(x2,y2) );\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tSegment s2( P(x1,y1) , P(x2,y2) );\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tSegment s3( P(x1,y1) , P(x2,y2) );\n\t\tvector<P> v;\n\t\tif( s1.is_intersection(s2) ){\n\t\t\tP p;\n\t\t\ts1.intersection(s2,p);\n\t\t\tif( p != INF_P ) v.push_back( p );\n\t\t}\n\t\tif( s2.is_intersection(s3) ){\n\t\t\tP p;\n\t\t\ts2.intersection(s3,p);\n\t\t\tif( p != INF_P ) v.push_back( p );\n\t\t}\n\t\tif( s3.is_intersection(s1) ){\n\t\t\tP p;\n\t\t\ts3.intersection(s1,p);\n\t\t\tif( p != INF_P ) v.push_back( p );\n\t\t}\n\t\t\n\t\tif( v.size() == 3 ){\n\t\t\tTriangle t( v[0] , v[1] , v[2] );\n\t\t\tdouble s = t.get_area();\n\t\t\tif( s < 100000 ){\n\t\t\t\tcout << \"syo-kichi\" << endl;\n\t\t\t}else if( s < 1000000 ){\n\t\t\t\tcout << \"kichi\" << endl;\n\t\t\t}else if( s < 1900000 ){\n\t\t\t\tcout << \"chu-kichi\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"dai-kichi\" << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);//count common tangents\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nmain()\n{\n\tSegment a,b,c;\n\twhile(cin>>a.p1>>a.p2>>b.p1>>b.p2>>c.p1>>c.p2)\n\t{\n\t\tif(parallel(a,b)||parallel(b,c)||parallel(c,a))\n\t\t{\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!intersect(a,b)||!intersect(b,c)||!intersect(c,a))\n\t\t{\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tPoint s,t,u;\n\t\ts=crosspoint(a,b);\n\t\tt=crosspoint(b,c);\n\t\tu=crosspoint(c,a);\n\t\tif(s==t||t==u||u==s)\n\t\t{\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble A=area(convex_full(Polygon{s,t,u}));\n\t\tif(A<1e5)cout<<\"syo-kichi\"<<endl;\n\t\telse if(A<1e6)cout<<\"kichi\"<<endl;\n\t\telse if(A<19e5)cout<<\"chu-kichi\"<<endl;\n\t\telse cout<<\"dai-kichi\"<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\ntypedef long long int Int;\nconst Int N = 3;\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nInt ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npair<bool, P> crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return pair<bool, P>(0, m[0]); // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return pair<bool, P>(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nbool input(L &l){\n  Int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n  l = L(P(x1, y1), P(x2, y2));\n  return (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0);\n}\n\ndouble area(const G &P) {\n  double A = 0.0;\n  for (Int i = 0; i < P.size(); ++i) A += cross(curr(P, i), next(P, i));\n  return abs(A / 2.0);\n}\n\nstring solve(L ls[N]){\n  G g;\n  REP(i, N){\n    if(!intersectSS(ls[i], ls[(i + 1) % N])) return \"kyo\";\n    else{\n      pair<bool, P> res = crosspointLL(ls[i], ls[(i + 1) % N]);\n      if(!res.first) return \"kyo\";\n      g.push_back(res.second);\n    }\n  }\n  double r = area(g);\n  if(r > 0 && r < 10000) return \"syo-kichi\";\n  else if(r < 1000000) return \"kichi\";\n  else if(r < 1900000) return \"chu-kichi\";\n  return \"dai-kichi\";\n}\n\nint main() {\n  L ls[N];\n  while(input(ls[0])){\n    FOR(i, 1, N) input(ls[i]);\n    cout <<solve(ls) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) { return a < b - EPS ? -1 : (a > b + EPS ? 1 : 0); }\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める (時計回りだと負になる)\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn res/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n\n/** Problem0187 : Stoining Fortune **/\nint main()\n{\n\tL s, t, u;\n\twhile (true) {\n\t\tD x1, y1, x2, y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tif (x1==0 && x2==0 && y1==0 && y2==0) break;\n\t\t\n\t\ts = L(P(x1, y1), P(x2, y2));\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tt = L(P(x1, y1), P(x2, y2));\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tu = L(P(x1, y1), P(x2, y2));\n\t\t\n\t\t\n\t\tif (iSS(s, t) && iSS(t, u) && iSS(u, s)) {\n\t\t\tP a = cSS(s, t), b = cSS(t, u), c = cSS(u, s);\n\t\t\tG g; g.push_back(a), g.push_back(b), g.push_back(c);\n\t\t\tD tmp = area(g);\n\t\t\t\n\t\t\tif (tmp >= 1900000) cout << \"dai-kichi\" << endl;\n\t\t\telse if (tmp >= 1000000) cout << \"chu-kichi\" << endl;\n\t\t\telse if (tmp >= 100000) cout << \"kichi\" << endl;\n\t\t\telse cout << \"syo-kichi\" << endl;\n\t\t} else {\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cmath>\n#define EPS (1e-10)\nusing namespace std;\n\nint main(){\n  int i,j,x1[3],y1[3],x2[3],y2[3],ty[3]/*x=c >> 1, y=c >> 2*/;\n  double a[3],b[3],x3[3],y3[3],sen[3],s,ans;\n  while(1){\n    cin >> x1[0] >> y1[0] >> x2[0] >> y2[0];\n    if(x1[0] == 0 && x2[0] == 0 && y1[0] == 0 && y2[0] == 0) break;\n    for(i=1;i<3;i++) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\n    for(i=0;i<3;i++){// y = a * x + b\n      a[i] = b[i] = 0.0;\n      if(x1[i] == x2[i]) ty[i] = 1;\n      else if(y1[i] == y2[i]){\n\tty[i] = 2;\n\ta[i] = 0.0;\n\tb[i] = (double)y1[i];\n      }\n      else{\n\ta[i] =(double)  (y1[i] - y2[i]) / (x1[i] - x2[i]);\n\tb[i] = (double) y1[i] - a[i] * x1[i];\n\tty[i] = 0;\n      }\n    }\n\n    ans = 0.0;\n\n    for(i=0;i<3;i++){ //ÃÂ±ÃÂ°ÃÂ¬ÃÂ¾ÃÂÃÂ¾ÃÂ¾ÃÂ¥ (ty[i] != 1)\n      if(ty[i] != 1 && ty[(i+1)%3] != 1 && a[i] == a[(i+1)%3] && b[i] == b[(i+1)%3]){\n\tans = -1.0;\n\tbreak;\n      }\n    }\n\n    if(ans == 0.0){\n      for(i=0;i<3;i++){\n\tif(ty[i] == 1){\n\t  x3[i] = (double)x1[i];\n\t  y3[i] = a[(i+1)%3] * x3[i] + b[(i+1)%3];\n\t}\n\telse{\n\t  x3[i] = (b[(i+1)%3] - b[i]) / (a[i] - a[(i+1)%3]);\n\t  if(b[(i+1)%3] == b[i]) x3[i] = 0.0;\n\t  y3[i] = a[i] * x3[i] + b[i];\n\t}\n\n\tif( (x1[i] <= x2[i] &&(x1[i] > x3[i] || x3[i] > x2[i]))  ||  (x2[i] < x1[i] &&(x2[i] > x3[i] || x3[i] > x1[i]))  ||  (y1[i] <= y2[i] &&(y1[i] > y3[i] || y3[i] > y2[i]))  ||  (y2[i] < y1[i] &&(y2[i] > y3[i] || y3[i] > y1[i])) ){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n\telse if( (x1[(i+1)%3] <= x2[(i+1)%3] &&(x1[(i+1)%3] > x3[i] || x3[i] > x2[(i+1)%3]))  ||  (x2[(i+1)%3] < x1[(i+1)%3] &&(x2[(i+1)%3] > x3[i] || x3[i] > x1[(i+1)%3]))  ||  (y1[(i+1)%3] <= y2[(i+1)%3] &&(y1[(i+1)%3] > y3[i] || y3[i] > y2[(i+1)%3]))  ||  (y2[(i+1)%3] < y1[(i+1)%3] &&(y2[(i+1)%3] > y3[i] || y3[i] > y1[(i+1)%3])) ){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n      }\n\n    for(i=0;i<3;i++){ //ÃÂ±ÃÂ°ÃÂ¬ÃÂ¾ÃÂÃÂ¾ÃÂ¾ÃÂ¥ (ty[i] == 1)\n      if(ty[i] == 1 && ty[(i+1)%3] == 1 && x3[i] == x3[(i+1)]){\n\tans = -1.0;\n\tbreak;\n      }\n    }\n\n      s = 0.0;\n      for(i=0;i<3;i++){\n\tsen[i] = sqrt( pow(x3[i] - x3[(i+1)%3],2) + pow(y3[i] - y3[(i+1)%3],2));\n\ts += sen[i];\n      }\n      \n      s /= 2;\n      if(ans == 0.0) ans = sqrt(s * (s - sen[0]) * (s - sen[1]) * (s - sen[2]));\n      \n      int c = 0;\n      for(i=0;i<3;i++){ //ÃÂ£ÃÂ³ÃÂ¤ÃÂ¤ÃÂÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂ¬ÃÂ£ÃÂ±ÃÂÃÂÃÂ¤ÃÂ¸ÃÂ²ÃÂ¤ÃÂ¯ÃÂ¤ÃÂ«\n\tif(x3[i] == x3[(i+1)%3] && y3[i] == y3[(i+1)%3]) c++;\n      }\n      if(c == 3) ans = -1;\n    }\n\n    if(ans >= 1900000.0) cout << \"dai-kichi\" << endl;\n    else if(ans >= 1000000.0) cout << \"chu-kichi\" << endl;\n    else if(ans >= 100000.0) cout << \"kichi\" << endl;\n    else if(ans > 0.0) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\ntypedef complex<double> P;\n \n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n \n// // ????????????a?????????????????????n1,n2????±???????\n// P n1 = a * P(0, 1);\n// P n2 = a * P(0, -1);\n \n// // ????????????a???????????????????????????un1,un2????±???????\n// P un1 = (a * P(0, +1)) / abs(a);\n// P un2 = (a * P(0, -1)) / abs(a);\n \n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n \n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n \n// ???c?????´???a,b???????????????????????? ???????????? WA?????????\n// int is_point_on_line(P a, P b, P c) {\n//   return EQ( cross(b-a, c-a), 0.0 );\n// }\n \n// ???c?????????a,b????????????????????????(1)\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 ) &&\n        (dot(b-a, c-a) > -EPS) &&\n        (dot(a-b, c-b) > -EPS);\n}\n \n// ???c?????????a,b????????????????????????(2)\n// |a-c| + |c-b| <= |a-b| ???????????????\n// int is_point_on_line(P a, P b, P c) {\n  // return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n// }\n// a??????b???????????£???, 1 -> ???, -1 -> ???, 2 -> a????????????, -2 -> b??????????\\\\??????, 0 -> ??????ab???????????¨\nint ccw(P a,P b, P c){\n    P d = b - a;\n    c -= a;\n    double cr = cross(d, c);\n    if(cr < -EPS){ return 1; }\n    if(cr > EPS){ return -1; }\n    if(dot(d, c) < -EPS){ return 2; }\n    if(norm(d) < norm(c) - EPS){ return -2; }\n    return 0;\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n \n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n\t\t   ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\n \n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(P a1, P a2, P b1, P b2) {\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n\n    return a1 + (a2-a1) * t;\n}\n \n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n \n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ntypedef pair<P,P> S;\n\nbool is_intersected(S a, S b){\n\tif(abs(ccw(a.F, a.S, b.F))!=1&&abs(ccw(a.F, a.S, b.S))!=1) return false;\n\tif(!is_intersected_ls(a.F, a.S, b.F, b.S)) return false;\n\treturn true;\n}\n\ndouble clac_area(P a, P b, P c){\n\tdouble aa = abs(a-b), bb = abs(b-c), cc = abs(c-a);\n\tdouble s = (aa + bb + cc) / 2;\n\treturn sqrt(s * (s-aa) * (s-bb) * (s-cc));\n}\n\n\nvoid mainmain(){\n\tdouble a,b,c,d;\n\twhile(cin>>a>>b>>c>>d){\n\t\tif(a==b&&b==c&&c==d&&a==0){\n\t\t\treturn;\n\t\t}\n\t\tvector<S> v(3);\n\t\tv[0] = {P(a,b),P(c,d)};\n\t\tcin>>a>>b>>c>>d;\n\t\tv[1] = {P(a,b),P(c,d)};\n\t\tcin>>a>>b>>c>>d;\n\t\tv[2] = {P(a,b),P(c,d)};\n\t\tbool ok = true;\n\t\trep(i,3){\n\t\t\tok &= is_intersected(v[i], v[(i+1)%3]);\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<P> w(3);\n\t\trep(i,3){\n\t\t\tw[i] = intersection_ls(v[i].F, v[i].S, v[(i+1)%3].F, v[(i+1)%3].S);\n\t\t}\n\t\tdouble ans = clac_area(w[0], w[1], w[2]);\n\t\tstring s[] = {\"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\"};\n\t\tdouble sigma[] = {1900000.0, 1000000.0, 100000.0, 0};\n\t\trep(i,4){\n\t\t\tif(ans >= sigma[i]){\n\t\t\t\tcout<<s[i]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i==3){\n\t\t\t\tcout<<s[4]<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool sameline(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  return (abs(A) < EPS && abs(B) < EPS) ; // same line\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  while(1) {\n    L ls[3];\n    REP(i,3) {\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      if (!x1&&!y1&&!x2&&!y2) return 0;\n      ls[i] = L(P(x1,y1), P(x2,y2));\n    }\n    if (!intersectSS(ls[0], ls[1]) || !intersectSS(ls[1], ls[2]) || !intersectSS(ls[2],ls[0])\n        ||sameline(ls[0], ls[1]) ||sameline(ls[1], ls[2]) || sameline(ls[2], ls[3])) {\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    P cp[3];\n    REP(i,3)\n      cp[i] = crosspoint(ls[i], ls[(i+1)%3]);\n    double S = cross(cp[2]-cp[0], cp[1]-cp[0]) / 2;\n    if (S >= 1900000) cout << \"dai-kichi\" << endl;\n    else if (S >= 1000000) cout << \"chu-kichi\" << endl;\n    else if (S >= 100000) cout << \"kichi\" << endl;\n    else if (S > EPS) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n};\n\nclass LineInfo {\npublic:\n\tPoint p1, p2;\n\n\tLineInfo() {\n\t\tp1.x = p1.y = p2.x = p2.y = 1001;\n\t}\n};\n\nLineInfo LineData[3];\nPoint CrossPoint[3];\ndouble Result;\n\n\ndouble Cross_Prouct(Point A, Point B, Point C) {\t\t\t\t\t//ABxAC\n\treturn (B.x - A.x)*(C.y - A.y) - (B.y - A.y)*(C.x - A.x);\n}\n\nvoid getCrossPoint(int index, Point s1p1, Point s1p2, Point s2p1, Point s2p2) {\n\n\tdouble d1 = fabs(Cross_Prouct(s2p1, s2p2, s1p1));\n\tdouble d2 = fabs(Cross_Prouct(s2p1, s2p2, s1p2));\n\tdouble t = d1 / (d1 + d2);\n\tCrossPoint[index].x = s1p1.x + (s1p2.x - s1p1.x)*t;\n\tCrossPoint[index].y = s1p1.y + (s1p2.y - s1p1.y)*t;\n}\n\nbool isIntersection(Point A, Point B, Point C, Point D) {\n\tif (max(A.x, B.x) < min(C.x, D.x)) {\n\t\treturn false;\n\t}\n\tif (max(C.x, D.x) < min(A.x, B.x)) {\n\t\treturn false;\n\t}\n\tif (max(A.y, B.y) < min(C.y, D.y)) {\n\t\treturn false;\n\t}\n\tif (max(C.y, D.y) < min(A.y, B.y)) {\n\t\treturn false;\n\t}\n\tif (Cross_Prouct(A, B, C)*Cross_Prouct(A, B, D) <= 0 &&\n\t\tCross_Prouct(C, D, A)*Cross_Prouct(C, D, B) <= 0) {\n\t\treturn true;\n\t}\n\t/*if (min(A.x, B.x) <= max(C.x, D.x) &&\n\t\tmin(C.x, D.x) <= max(A.x, B.x) &&\n\t\tmin(A.y, B.y) <= max(C.y, D.y) &&\n\t\tmin(C.y, D.y) <= max(A.y, B.y) &&\n\t\tCross_Prouct(A, B, C)*Cross_Prouct(A, B, D) <= 0 &&\n\t\tCross_Prouct(C, D, A)*Cross_Prouct(C, D, B) <= 0) {\n\t\treturn true;\n\t}*/\n\treturn false;\n}\n\nvoid solve() {\n\n\tif (!isIntersection(LineData[0].p1, LineData[0].p2, LineData[1].p1, LineData[1].p2)) {\n\t\t//三角形なし\n\t\tResult = 0.0;\n\t\treturn;\n\t}\n\tif (!isIntersection(LineData[1].p1, LineData[1].p2, LineData[2].p1, LineData[2].p2)) {\n\t\t//三角形なし\n\t\tResult = 0.0;\n\t\treturn;\n\t}\n\tif (!isIntersection(LineData[2].p1, LineData[2].p2, LineData[0].p1, LineData[0].p2)) {\n\t\t//三角形なし\n\t\tResult = 0.0;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tgetCrossPoint(i, LineData[i].p1, LineData[i].p2, LineData[(i + 1) % 3].p1, LineData[(i + 1) % 3].p2);\n\t}\n\n\tResult = fabs(Cross_Prouct(CrossPoint[0], CrossPoint[1], CrossPoint[2])) / 2.0;\n\t//cout << Result << endl;\n}\n\nint main() {\n\tint x1, y1, x2, y2;\n\n\twhile (1) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tif (i == 0 && x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tLineData[i].p1.x = x1;\n\t\t\tLineData[i].p1.y = y1;\n\t\t\tLineData[i].p2.x = x2;\n\t\t\tLineData[i].p2.y = y2;\n\t\t}\n\t\t/*for (int i = 0; i < 3; i++) {\n\t\t\tcout << LineData[i].p1.x << \" \" << LineData[i].p1.y << \" \" << LineData[i].p2.x << \" \" << LineData[i].p2.y << endl;\n\t\t}*/\n\t\tsolve();\n\t\tif (Result >= 1900000) {\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}\n\t\telse if (Result >= 1000000) {\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}\n\t\telse if (Result >= 100000) {\n\t\t\tcout << \"kichi\" << endl;\n\t\t}\n\t\telse if (Result > 0) {\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py * d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nPoint prj(const Segment& a, const Point& b) { return a.p1 + (a.p2 - a.p1) * dot(b - a.p1, a.p2 - a.p1) / norm(a.p2 - a.p1); }\nPoint rfl(const Segment& a, const Point& b) { return b + (prj(a, b) - b) * 2.0L; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint crp(Segment a, Segment b) {\n\tlong double d1 = abs(crs(b.p2 - b.p1, a.p1 - b.p1));\n\tlong double d2 = abs(crs(b.p2 - b.p1, a.p2 - b.p1));\n\tPoint d = (a.p2 - a.p1);\n\tPoint r = a.p1 + (a.p2 - a.p1) * d1 / (d1 + d2);\n\treturn r;\n}\nlong double area(vector<Point> v) {\n\tlong double ret = 0.0L;\n\tfor (int i = 0; i < v.size(); i++) ret += crs(v[i], v[(i + 1) % v.size()]);\n\treturn ret / 2;\n}\nSegment s1, s2, s3;\nint main() {\n\twhile (cin >> s1.p1.px >> s1.p1.py >> s1.p2.px >> s1.p2.py >> s2.p1.px >> s2.p1.py >> s2.p2.px >> s2.p2.py >> s3.p1.px >> s3.p1.py >> s3.p2.px >> s3.p2.py) {\n\t\tif (!its(s1, s2) || !its(s2, s3) || !its(s3, s1)) puts(\"kyo\");\n\t\telse {\n\t\t\tPoint p1 = crp(s1, s2), p2 = crp(s2, s3), p3 = crp(s3, s1);\n\t\t\tlong double a = area({ p1, p2, p3 });\n\t\t\tif (a >= 1900000.0L) puts(\"dai-kichi\");\n\t\t\telse if (a >= 1000000.0L) puts(\"chu-kichi\");\n\t\t\telse if (a >= 100000.0L) puts(\"kichi\");\n\t\t\telse if (a >= 1e-10) puts(\"sho-kichi\");\n\t\t\telse puts(\"kyo\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=abs(area(v));\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=0)cout<<\"syo-kichi\"<<endl;\n      else exit(1);\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(true)\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(x1+y1+x2+y2 == 0)\n\tbreak;\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n    \n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\n\n#define EPS (1e-10)\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn\n\t\t( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn a1 + (a2-a1) * t;\n}\n\ndouble area(vector<P> v){\n\tint n = v.size();\n\tdouble res = 0.0;\n\n\tfor(int i=0;i<n;i++){\n\t\tres += cross(v[i],v[(i+1)%n]);\n\t}\n\treturn fabs(res)/2;\n}\n\nint main(void){\n\tP s[3],g[3];\n\n\twhile(1){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>s[i].real()>>s[i].imag()>>g[i].real()>>g[i].imag();\n\t\t\tif(s[i] == P(0,0) && g[i] == P(0,0)) return 0;\n\t\t}\n\n\t\tif(!is_intersected_ls(s[0],g[0],s[1],g[1]) ||\n\t\t\t !is_intersected_ls(s[1],g[1],s[2],g[2]) ||\n\t\t\t !is_intersected_ls(s[2],g[2],s[0],g[0]))\n\t\t\tcout<<\"kyo\\n\";\n\t\telse{\n\t\t\tvector<P> v;\n\t\t\tv.push_back(intersection_ls(s[0],g[0],s[1],g[1]));\n\t\t\tv.push_back(intersection_ls(s[1],g[1],s[2],g[2]));\n\t\t\tv.push_back(intersection_ls(s[2],g[2],s[0],g[0]));\n\n\t\t\tdouble a = area(v);\n\t\t\tif(a >= 1900000) cout<<\"dai-kichi\\n\";\n\t\t\telse if(a >= 1000000) cout<<\"chu-kichi\\n\";\n\t\t\telse if(a >= 100000) cout<<\"kichi\\n\";\n\t\t\telse if(a > 0) cout<<\"syo-kichi\\n\";\n\t\t\telse cout<<\"kyo\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(true)\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0)\n\tbreak;\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n    \n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n  \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n\n    cout << cross(curr(p,i),next(p,i)) << endl;\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\n\nint main(){\n  L ls[3];\n  int x1[3], y1[3], x2[3], y2[3];\n  while( cin >> x1[0] >> y1[0] >> x2[0] >> y2[0], x1[0]|y1[0]|x2[0]|y2[0] ){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      ls[i] = L( P( x1[i], y1[i]), P( x2[i], y2[i]));\n    }\n\n    G triangle(3);\n    bool flag = true;\n    for(int i = 0 ; i < 3 ; i++ ){\n      const int NEXT = ( i + 1 ) % 3;\n      if(!intersect( ls[i], ls[NEXT])){\n        flag = false;\n        break;\n      }else{\n        triangle[i] = crosspoint( ls[i], ls[NEXT]);\n      }\n    }\n\n    double s = (abs(triangle[0]-triangle[1])+abs(triangle[1]-triangle[2])+abs(triangle[2]-triangle[0])) / 2;\n    double area = sqrt(s * ( s - abs(triangle[0] - triangle[1])) * ( s - abs(triangle[1] - triangle[2])) * ( s - abs(triangle[2] - triangle[0])));\n    if(!flag || area < EPS) cout << \"kyo\" << endl;\n    else if(area < 100000) cout << \"syo-kichi\" << endl;\n    else if(area < 1000000) cout << \"kichi\" << endl;\n    else if(area < 1900000) cout << \"chu-kichi\" << endl;\n    else cout << \"dai-kichi\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n\n/*\n  ô½Cu\n*/\n\n#include<vector>\n#include<stack>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-4;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\n// _Iy[^\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\n// CCW oXg¾ªA¸xÉæé\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\n// üªÌð·»èAºÍ_ÌÝÅßéo[WA»ÌºÍxNg(üªÌ[_Åðíé)\nbool intersected_seg(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\nbool intersected_l(line a, line b){\n  return !prll(a.fr,a.sc,b.fr,b.sc);\n}\npoint intersection_seg(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersection_l(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersection_seg(seg a, seg b, point &ret){\n  if( intersected_seg(a,b) ){\n    ret = intersection_seg(a,b);\n    return true;\n  }\n  return false;\n}\nbool intersection_l(line a, line b, point &ret){\n  if( intersected_l( a, b ) ){\n    ret = intersection_l( a, b );\n    return true;\n  }\n  return false;\n}\nbool intersection_lseg(line l, seg s, point &ret){\n  point tmp;\n  if( intersection_l(l,s,tmp) ){\n    if(ccw(s.fr,s.sc,tmp)&OVER){\n      ret=tmp;\n      return true;\n    }\n  }\n  return false;\n}\n\n// Op`ÌÊÏ\nelem areaOfTriangle(elem a, elem b, elem c){\n  elem s = (a+b+c)/2;\n  return sqrt( s * (s-a) * (s-b) * (s-c) );\n}\n\nusing namespace std;\nint main(){\n  while(true){\n    seg s[3];\n    bool inv=false;\n    for(int i = 0; i <3; ++i){\n      elem x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(eq(x1,0)&&eq(y1,0)&&eq(x2,0)&&eq(y2,0))return 0;\n      s[i] = seg(point(x1,y1),point(x2,y2));\n    }\n    point a,b,c;\n    if( !intersection_seg( s[0], s[1], a ) ||\n\t!intersection_seg( s[1], s[2], b ) || \n\t!intersection_seg( s[2], s[0], c ) )\n      inv=true;\n    \n    //    cout << \" A : \" << a << \" B : \" << b << \" C : \" << c << endl;\n    elem area = areaOfTriangle( abs(b-a), abs(c-b), abs(a-c) );\n    if( inv ){\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    \n    if( geq( area, 19000000 ) ){\n      cout << \"dai-kichi\" << endl;\n    }else if( geq( area, 1000000 ) ){\n      cout << \"chu-kichi\" << endl;\n    }else if( geq( area, 100000 ) ){\n      cout << \"kichi\" << endl;\n    }else if( gtz( area ) ){\n      cout << \"sho-kichi\" << endl;\n    }else{\n      cout << \"kyo\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py * d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nPoint prj(const Segment& a, const Point& b) { return a.p1 + (a.p2 - a.p1) * dot(b - a.p1, a.p2 - a.p1) / norm(a.p2 - a.p1); }\nPoint rfl(const Segment& a, const Point& b) { return b + (prj(a, b) - b) * 2.0L; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint crp(Segment a, Segment b) {\n\tlong double d1 = abs(crs(b.p2 - b.p1, a.p1 - b.p1));\n\tlong double d2 = abs(crs(b.p2 - b.p1, a.p2 - b.p1));\n\tPoint d = (a.p2 - a.p1);\n\tPoint r = a.p1 + (a.p2 - a.p1) * d1 / (d1 + d2);\n\treturn r;\n}\nlong double area(vector<Point> v) {\n\tlong double ret = 0.0L;\n\tfor (int i = 0; i < v.size(); i++) ret += crs(v[i], v[(i + 1) % v.size()]);\n\treturn ret / 2;\n}\nSegment s1, s2, s3;\nint main() {\n\twhile (cin >> s1.p1.px >> s1.p1.py >> s1.p2.px >> s1.p2.py >> s2.p1.px >> s2.p1.py >> s2.p2.px >> s2.p2.py >> s3.p1.px >> s3.p1.py >> s3.p2.px >> s3.p2.py) {\n\t\tif (!its(s1, s2) || !its(s2, s3) || !its(s3, s1)) puts(\"kyo\");\n\t\telse {\n\t\t\tPoint p1 = crp(s1, s2), p2 = crp(s2, s3), p3 = crp(s3, s1);\n\t\t\tlong double a = labs(area({ p1, p2, p3 }));\n\t\t\tif (a >= 1900000.0L) puts(\"dai-kichi\");\n\t\t\telse if (a >= 1000000.0L) puts(\"chu-kichi\");\n\t\t\telse if (a >= 100000.0L) puts(\"kichi\");\n\t\t\telse if (a >= 1e-10) puts(\"syo-kichi\");\n\t\t\telse puts(\"kyo\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nconst double EPS=1e-12;\nconst double INF=1e12;\n\ntypedef complex<double>Point;\n\nnamespace std{\n    bool operator<(const Point &P,const Point &Q){\n        return real(P)!=real(Q)?real(P)<real(Q):imag(P)<imag(Q);\n    }\n}\n\ndouble dot(const Point &P,const Point &Q){\n    return real(P)*real(Q)+imag(P)*imag(Q);\n}\n\ndouble cross(const Point &P,const Point &Q){\n    return real(P)*imag(Q)-real(Q)*imag(P);\n}\n\nstruct Line{\n    Point a,b;\n    Line(Point P,Point Q){\n        a=P;b=Q;\n    }\n    Line(){}\n};\n\nstruct Segment{\n    Point a,b;\n    Segment(Point P,Point Q){\n        a=P;b=Q;\n    }\n    Segment(){}\n};\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point P,double l){\n        c=P;r=l;\n    }\n};\n\ntypedef vector<Point>Polygon;\n\nint ccw(Point A,Point B,Point C){\n    B-=A;C-=A;\n    if(cross(B,C)>0)return 1; //ccw\n    if(cross(B,C)<0)return -1; //cw\n    if(dot(B,C)<0)return 2; //c-b-a\n    if(norm(B)<norm(C))return -2; //a-b-c\n    return 0; //a-c-b\n}\n\ninline bool parallelism(const Line &L,const Line &M){\n    return fabs(cross(L.a-L.b,M.a-M.b))<EPS;\n}\n\ninline bool orthogonal(const Line &L,const Line &M){\n    return fabs(dot(L.a-L.b,M.a-M.b))<EPS;\n}\n\ninline bool intersect(const Line &L,const Line &M){\n    return cross(L.a-L.b,M.a-M.b)>EPS ||cross(L.a-L.b,M.a-M.b)<-EPS;\n}\n\ninline bool intersect(const Line &L,const Segment &S){\n    return cross(L.b-L.a,S.a-L.a)*cross(L.b-L.a,S.b-L.a)<-EPS;\n}\n\ninline bool intersect(const Line &L,const Point &P){\n    return abs(ccw(L.a,L.b,P))!=1;\n}\n\ninline bool intersect(const Segment &S, const Segment &T){\n    return ccw(S.a,S.b,T.a)*ccw(S.a,S.b,T.b)<=0&&\n        ccw(T.a,T.b,S.a)*ccw(T.a,T.b,S.b) <= 0;\n}\n\ninline bool intersect(const Segment &S,const Point &P){\n    return ccw(S.a,S.b,P)==0;\n}\n\ninline bool intersect(const Circle &C,const Point &P){\n    return abs(C.c-P)<=C.r+EPS;\n}\n\ninline bool intersect(const Circle &C,const Circle &D){\n    return abs(C.c-D.c)<=C.r+D.r&&abs(C.c-D.c)>=fabs(C.r-D.r);\n}\n\ninline bool onSameLine(const Segment &S,const Segment &T){\n    return abs(ccw(S.a,S.b,T.a)*ccw(S.a,S.b,T.b))!=1;\n}\n\ninline Point crossPoint(const Line &L,const Line &M){\n    double crs=cross(L.b-L.a,M.b-M.a);\n    return M.a+(M.b-M.a)*cross(L.b-L.a,L.a-M.a)*(1.0/crs);\n}\n\ninline Point crossPoint(const Segment &S,const Segment &T){\n    double crs=cross(S.b-S.a,T.b-T.a);\n    return T.a+(T.b-T.a)*cross(S.b-S.a,S.b-T.a)*(1.0/crs);\n}\ndouble areaTriangle(Point A,Point B,Point C){\n    B-=A;C-=A;\n    return fabs(cross(B,C))*0.5;\n}\n\ndouble areaPolygon(Polygon &G){\n    const int Sz=G.size();\n    if(Sz<3)return 0;\n    if(Sz==3)return areaTriangle(G[0],G[1],G[2]);\n\n    double res=cross(G[Sz-1],G[0]);\n    for(int i=1;i<Sz;i++)res+=cross(G[i-1],G[i]);\n\n    return fabs(res)*0.5;\n}\n\n\n\nint main(){\n    double x1,x2,y1,y2;\n    while(cin>>x1>>y1>>x2>>y2,x1||y1||x2||y2){\n        Segment S[3];\n        S[0]=Segment(Point(x1,y1),Point(x2,y2));\n        for(int i=1;i<3;i++){\n            cin>>x1>>y1>>x2>>y2;\n            S[i]=Segment(Point(x1,y1),Point(x2,y2));\n        }\n        bool flag=false;\n        for(int i=0;i<3;i++){\n            flag|=(!intersect(S[i],S[(i+1)%3]));\n            flag|=onSameLine(S[i],S[(i+1)%3]);\n        }\n        if(flag){\n            cout<<\"kyo\"<<endl;\n            continue;\n        }\n        Point P[3];\n        for(int i=0;i<3;i++){\n            P[i]=crossPoint(S[i],S[(i+1)%3]);\n        }\n        double me=areaTriangle(P[0],P[1],P[2]);\n\n        if(me<EPS)cout<<\"kyo\"<<endl;\n        else if(me<100000+EPS)cout<<\"syo-kichi\"<<endl;\n        else if(me<1000000+EPS)cout<<\"kichi\"<<endl;\n        else if(me<1900000+EPS)cout<<\"chu-kichi\"<<endl;\n        else cout<<\"dai-kichi\"<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n        if(isParallel(a,b)||isParallel(b,c)||isParallel(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        if(equalsv(g[0],g[1])&&equalsv(g[1],g[2])&&equalsv(g[2],g[0])){\n            puts(\"kyo\");\n            continue;\n        }\n        double x=area(g);\n        if(x<EPS)puts(\"kyo\");\n        else if(x<100000-EPS)puts(\"syo-kichi\");\n        else if(x<1000000-EPS)puts(\"kichi\");\n        else if(x<1900000-EPS)puts(\"chu-kichi\");\n        else puts(\"dai-kichi\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n  \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n\n    cout << cross(curr(p,i),next(p,i)) << endl;\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\n\nint main(){\n  L ls[3];\n  int x1[3], y1[3], x2[3], y2[3];\n  while( cin >> x1[0] >> y1[0] >> x2[0] >> y2[0], x1[0]|y1[0]|x2[0]|y2[0] ){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      ls[i] = L( P( x1[i], y1[i]), P( x2[i], y2[i]));\n    }\n\n    G triangle(3);\n    bool flag = true;\n    for(int i = 0 ; i < 3 ; i++ ){\n      const int NEXT = ( i + 1 ) % 3;\n      if(!intersect( ls[i], ls[NEXT])){\n        flag = false;\n        break;\n      }else{\n        triangle[i] = crosspoint( ls[i], ls[NEXT]);\n      }\n    }\n\n    double s = abs(triangle[0]-triangle[1])+abs(triangle[1]-triangle[2])+abs(triangle[2]-triangle[0]);\n    double area = sqrt(s * ( s - abs(triangle[0] - triangle[1])) * ( s - abs(triangle[1] - triangle[2])) * ( s - abs(triangle[2] - triangle[0])));\n\n    cout << area << endl;\n    if(!flag || area < EPS) cout << \"kyo\" << endl;\n    else if(area < 100000) cout << \"syo-kichi\" << endl;\n    else if(area < 1000000) cout << \"kichi\" << endl;\n    else if(area < 1900000) cout << \"chu-kichi\" << endl;\n    else cout << \"dai-kichi\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n#include <complex>\n#include <cassert>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool isParallel(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint x[2], y[2];\n\twhile(cin>>x[0]>>y[0]>>x[1]>>y[1]){\n\t\tif(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0) break;\n\t\tvector<L> l;\n\t\tl.pb({P(x[0], y[0]), P(x[1], y[1])});\n\t\trep(i, 2){\n\t\t\trep(j, 2) cin>>x[j]>>y[j];\n\t\t\tl.pb({P(x[0], y[0]), P(x[1], y[1])});\n\t\t}\n\t\tbool f = true;\n\t\tvector<P> p;\n\t\trep(i, 3) rep(j, i){\n\t\t\tif(isParallel(l[i], l[j]) || (!intersectSS(l[i], l[j]))){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp.pb(crosspoint(l[i], l[j]));\n\t\t}\n\t\tif(f == false){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble s = 0.0;\n\t\trep(i, 3){\n\t\t\ts += cross({0.0,0.0}, p[i]);\n\t\t}\n\t\ts /= 2.0;\n\t\tstring ans;\n\t\tif(s + EPS > 1900000) ans = \"dai-kichi\";\n\t\telse if(s + EPS > 1000000) ans = \"chu-kichi\";\n\t\telse if( s + EPS > 100000) ans = \"kichi\";\n\t\telse ans = \"syo-kichi\";\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n  \n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n \n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n  \n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n    return sqrt(norm(p));\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<=0)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<=0);\n}\n \ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return fabs(cross(b,c))*0.5;\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n}\n \nPoint crosspoint(Line l,Line m){\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nint main(){\n    while(true){\n        bool endflg = false;\n        Line l[3];\n        rep(i,3){\n            double x1,y1,x2,y2;\n            scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n            if(i == 0){\n                if(x1 == 0.0 && y1 == 0.0 && x2 == 0.0 && y2 == 0.0){\n                    endflg = true;\n                    break;\n                }\n            }\n            l[i].PB(Point(x1,y1));\n            l[i].PB(Point(x2,y2));\n        }\n        if(endflg)break;\n        Point p[3];\n        p[0] = crosspoint(l[0],l[1]);\n        p[1] = crosspoint(l[0],l[2]);\n        p[2] = crosspoint(l[1],l[2]);\n        double area = TriangleArea(p[0],p[1],p[2]);\n        if(area-1900000>-EPS)puts(\"dai-kichi\");\n        else if(area-1000000>-EPS)puts(\"chu-kichi\");\n        else if(area-100000>-EPS)puts(\"kichi\");\n        else if(area>EPS)puts(\"syo-kichi\");\n        else puts(\"kyo\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool intersectSS(Line s,Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n    if(intersectSS(l,m)==false) return false;\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)/2); s2 = abs(cross(a1,b2)/2);\n\tif(s1<EPS && s2<EPS) return false;\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\t/*if(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x || p.x<min(m.a.x,m.b.x) || max(m.a.x,m.b.x)<p.x ||\n\t   p.y<min(l.a.y,l.b.y) || max(l.a.y,l.b.y)<p.y || p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;*/\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\t//printf(\"\\t%lf\\n\",s);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000.0) puts(\"syo-kichi\");\n\t\telse if(s<1000000.0) puts(\"kichi\");\n\t\telse if(s<1900000.0) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)); s2 = abs(cross(a1,b2));\n\tif(s1<EPS && s2<EPS) return false;\n\tif(s1<EPS) swap(s1,s2);\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\tif(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x ||\n\t   p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000) puts(\"syo-kichi\");\n\t\telse if(s<1000000) puts(\"kichi\");\n\t\telse if(s<1900000) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    Point p[3], q[3], x[3];\n    double S;\n\t\n    while (1){\n        for (int i = 0; i < 3; i++){\n\t\t\tint x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\t\n            if (i == 0 && x1 == 0 && x2 == 0 && y1 == 0 && y2 == 0) return (0);\n\t\t\t\n\t\t\tp[i] = Point(x1, y1); q[i] = Point(x2, y2);\n        }\n\t\t\n\t\tint k = 0;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\t\tif (!isIntersect(p[i], q[i], p[j], q[j])){\n\t\t\t\t\tprintf(\"kyo\\n\");\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tx[k++] = interPointS(p[i], q[i], p[j], q[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (x[0] == x[1] || x[1] == x[2] || x[0] == x[2]){\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tgoto next;\n\t\t}\n\t\t\n\t\tS = area(x[0], x[1], x[2]);\n\t\t\n\t\tif (S >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (S >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (S >= 100000) printf(\"kichi\\n\");\n\t\telse printf(\"syo-kichi\\n\");\n\t\t\n\t\tnext:;\n\t}\t\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e99\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &ppoint;\n\ndouble cross(ppoint a, ppoint b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble intersect(point pa1, point pa2, point pb1, point pb2) {\n\tpoint difa = pa2 - pa1;\n\tpoint difb = pb2 - pb1;\n\tpoint difab1 = pb1 - pa1;\n\n\tdouble D = cross(difa, -difb);\n\n\tif (abs(D) > EPS) {\n\t\tdouble t = cross(difab1, -difb) / D;\n\t\tdouble s = cross(difa, difab1) / D;\n\n\t\tif (t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0) {\n\t\t\treturn t;\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main() {\n\tpoint s[3], f[3], z[3];\n\tint x1, x2, y1, y2;\n\n\twhile (true) {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2) != 4) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ts[i] = point(x1, y1);\n\t\t\tf[i] = point(x2, y2);\n\t\t}\n\n\t\tint j;\n\t\tfor (j = 0; j < 3; ++j) {\n\t\t\tdouble t = intersect(s[j], f[j], s[(j + 1) % 3], f[(j + 1) % 3]);\n\t\t\tif (t == INF) {\n\t\t\t\tputs(\"kyo\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tz[j] = (1.0 - t) * s[j] + t * f[j];\n\t\t}\n\n\t\tif (j == 3) {\n\t\t\tdouble s = abs(cross(z[1] - z[0], z[2] - z[0])) * 0.5;\n\n\t\t\tif (s >= 1.9e6) {\n\t\t\t\tputs(\"dai-kichi\");\n\t\t\t} else if (s >= 1e6) {\n\t\t\t\tputs(\"chu-kichi\");\n\t\t\t} else if (s >= 1e5) {\n\t\t\t\tputs(\"kichi\");\n\t\t\t} else if (s > EPS) {\n\t\t\t\tputs(\"syo-kichi\");\n\t\t\t} else {\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=-10000000)cout<<\"syo-kichi\"<<endl;\n      else exit(1);\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nstring omikuji(const vector<segment>& segments) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tconst segment& s = segments[i], t = segments[(i + 1) % 3];\n\t\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\t\tif(abs(tmp) < EPS || !intersect(s, t))\n\t\t\treturn \"kyo\";\n\t}\n\n\tpolygon triangle;\n\tfor(int i = 0; i < 3; ++i)\n\t\ttriangle.push_back(crosspoint(segments[i], segments[(i + 1) % 3]));\n\n\tconst double area_of_triangle = area(triangle);\n\tif(area_of_triangle > 1900000 - EPS)\n\t\treturn \"dai-kichi\";\n\n\tif(area_of_triangle > 1000000 - EPS)\n\t\treturn \"dai-kichi\";\n\n\tif(area_of_triangle > 100000 - EPS)\n\t\treturn \"dai-kichi\";\n\n\treturn \"syo-kichi\";\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y, x2, y2; cin >> x >> y >> x2 >> y2, (x | y | x2 | y2);) {\n\t\tvector<segment> segments;\n\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y >> x2 >> y2;\n\t\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\t}\n\n\t\tstring result = omikuji(segments);\n\t\tcout << result << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*テ」ツ??・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテゥツ敖「テァツゥツ催・ツ?ャテ・ツシツ?(テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ョテ・ツ?エテ・ツ青? */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\nint main(){\n\twhile(1){\n\t\tvector<L> l(3,L(P(0,0),P(0,0)));\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tfor(int j = 0 ; j < 2 ; j++)\n\t\t\t\tcin >> l[i][j].real() >> l[i][j].imag();\n\t\t}\n\t\tif( l[0][0] == P(0,0) && l[0][1] == P(0,0) ){\n\t\t\tbreak;\n\t\t}\n\t\tint kyo = 0;\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\tif( !intersectSS(l[i],l[j]) ){\n\t\t\t\t\tkyo = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(kyo){\n\t\t\tcout << \"kyo\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<P> p;\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tfor(int j = i+1 ; j < 3 ; j++){\n\t\t\t\tp.push_back(crosspoint(l[i],l[j]));\n\t\t\t}\n\t\t}\n\t\tdouble s = abs(AreaOfPolygon(p));\n\t\tif( s < EPS ){\n\t\t\tcout << \"kyo\" << endl;\n\t\t}else if( s < 100000 - EPS){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else if( s < 1000000 - EPS ){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if( s < 1900000 - EPS ){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<complex>\n#include<cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + P(2,0) * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  //if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ndouble area2(const G& p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) \n    A += cross(curr(p, i), next(p, i));\n  return A;\n}\n\nint main(){\n\tdouble x1,y1,x2,y2,a;\n\twhile(cin>>x1>>y1>>x2>>y2,x1||y1||x2||y2){\n\t\tP p1(x1,y1),p2(x2,y2);\n\t\tcin>>x1>>y1>>x2>>y2; P p3(x1,y1),p4(x2,y2);\n\t\tcin>>x1>>y1>>x2>>y2; P p5(x1,y1),p6(x2,y2);\n\t\tL l1(p1,p2),l2(p3,p4),l3(p5,p6);\n\t\tif(!intersectSS(l1,l2)||!intersectSS(l2,l3)||!intersectSS(l3,l1)){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tP q1=crosspoint(l1,l2),q2=crosspoint(l2,l3),q3=crosspoint(l3,l1);\n\t\tG t; t.push_back(q1),t.push_back(q2),t.push_back(q3);\n\t\t\n\t\ta=abs(area2(t)/2);\n\t\tif(a>=1900000)cout<<\"dai-kichi\"<<endl;\n\t\telse if(a>=1000000)cout<<\"chu-kichi\"<<endl;\n\t\telse if(a>=100000)cout<<\"kichi\"<<endl;\n\t\telse if(a<EPS)cout<<\"kyo\"<<endl;\n\t\telse cout<<\"syo-kichi\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\n#define EPS\t\t\t(1e-10)\n#define PI\t\t\t(3.14159265358979323846)\n\n\n#define X(a)\t\t( (a).real() )\n#define Y(a)\t\t( (a).imag() )\n#define EQ(a,b)\t\t( -EPS<(a)-(b) && (a)-(b)<EPS )\n#define EQV(a,b)\t( EQ(X(a),X(b)) && EQ(Y(a),Y(b)) )\n\n#define unit(a)\t\t( (a)/abs(a) )\n#define normal(a)\t( (a)*P(0,1) )\n#define dot(a,b)\t( X((a)*conj(b)) )\n#define cross(a,b)\t( Y(conj(a)*(b)) )\n\n// 3ツ点ツづ個暗環置ツ甘鳴係\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t// a--b--c on line\n\treturn 0;\n}\n\n// ツ静シツ閉ェツづ静シツ閉ェツづ個古ーツ債キツ板サツ津ィ\nbool intersectSS(P a, P b, P c, P d)\n{\n\treturn\tccw(a,b,c)*ccw(a,b,d) <= 0 &&\n\t\t\tccw(c,d,a)*ccw(c,d,b) <= 0;\n}\n\nP crosspointLL(P a, P b, P c, P d)\n{\n\tdouble det=cross(d-c,b-a);\n\tassert(!(abs(det)<EPS));\n\n\treturn a + (b-a) * cross(d-c,c-a)/det;\n\t\n\t// u=b-a  ->  a + tu ( t = cross(d-c,c-a)/det )\n\t// v=d-c  =>  c + sv ( s = cross(b-a,c-a)/det )\n}\n\nint main()\n{\n\tP p[6];\n\twhile(cin >> X(p[0]) >> Y(p[0]) >> X(p[1]) >> Y(p[1]), X(p[0])||Y(p[0])||X(p[1])||Y(p[1]))\n\t{\n\t\tcin >> X(p[2]) >> Y(p[2]) >> X(p[3]) >> Y(p[3]);\n\t\tcin >> X(p[4]) >> Y(p[4]) >> X(p[5]) >> Y(p[5]);\n\n\t\tbool crs = true;\n\t\tfor(int i=0; i<6; i+=2)\n\t\t{\n\t\t\tif(!intersectSS(p[i],p[i+1],p[(i+2)%6],p[(i+3)%6]))\n\t\t\t{\n\t\t\t\tcrs=false; break;\n\t\t\t}\n\t\t}\n\n\t\tif(crs)\n\t\t{\n\t\t\tP c[3];\n\n\t\t\tfor(int i=0; i<6; i+=2)\n\t\t\t{\n\t\t\t\t\tc[i/2] = crosspointLL(p[i],p[i+1],p[(i+2)%6],p[(i+3)%6]);\n\t\t\t}\n\t\t\t\n\t\t\tdouble s = abs(cross(c[1]-c[0],c[2]-c[0]));\n\n\t\t\tif(EQ(s,0.0))\n\t\t\t{\n\t\t\t\tcout << \"kyo\" << endl;\n\t\t\t}\n\t\t\telse if(s<100000)\n\t\t\t{\n\t\t\t\tcout << \"syo-kichi\" << endl;\n\t\t\t}\n\t\t\telse if(s<1000000)\n\t\t\t{\n\t\t\t\tcout << \"kichi\" << endl;\n\t\t\t}\n\t\t\telse if(s<1900000)\n\t\t\t{\n\t\t\t\tcout << \"chu-kichi\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"dai-kichi\" << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cmath>\n#define EPS (1e-10)\nusing namespace std;\n\nint main(){\n  int i,j,x1[3],y1[3],x2[3],y2[3],ty[3]/*x=c >> 1, y=c >> 2*/;\n  double a[3],b[3],x3[3],y3[3],sen[3],s,ans;\n  while(1){\n    cin >> x1[0] >> y1[0] >> x2[0] >> y2[0];\n    if(x1[0] == 0 && x2[0] == 0 && y1[0] == 0 && y2[0] == 0) break;\n    for(i=1;i<3;i++) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\n    for(i=0;i<3;i++){// y = a * x + b\n      a[i] = b[i] = 0.0;\n      if(x1[i] == x2[i]) ty[i] = 1;\n      else if(y1[i] == y2[i]){\n\tty[i] = 2;\n\ta[i] = 0.0;\n\tb[i] = (double)y1[i];\n      }\n      else{\n\ta[i] =(double)  (y1[i] - y2[i]) / (x1[i] - x2[i]);\n\tb[i] = (double) y1[i] - a[i] * x1[i];\n\tty[i] = 0;\n      }\n    }\n\n    ans = 0.0;\n    for(i=0;i<3;i++){ //ÃÂ¿ÃÂ¹ÃÂ¤ÃÂ¾ÃÂ¬ÃÂ¹ÃÂ§\n      if(ty[i] == 1 && ty[(i+1)%3] == 1){\n\tans = -1.0;\n\tbreak;\n      }\n      else if(ty[i] != 1 && ty[(i+1)%3] != 1 && a[i] == a[(i+1)%3]){\n\tans = -1.0;\n\tbreak;\n      }\n    }\n\n    if(ans == 0.0){\n      for(i=0;i<3;i++){\n\tif(ty[i] == 1){\n\t  x3[i] = (double)x1[i];\n\t  y3[i] = a[(i+1)%3] * x3[i] + b[(i+1)%3];\n\t}\n\telse{\n\t  x3[i] = (b[(i+1)%3] - b[i]) / (a[i] - a[(i+1)%3]);\n\t  if(b[(i+1)%3] == b[i]) x3[i] = 0.0;\n\t  y3[i] = a[i] * x3[i] + b[i];\n\t}\n\n\tif( (x1[i] <= x2[i] &&(x1[i] > x3[i] || x3[i] > x2[i]))  ||  (x2[i] < x1[i] &&(x2[i] > x3[i] || x3[i] > x1[i]))  ||  (y1[i] <= y2[i] &&(y1[i] > y3[i] || y3[i] > y2[i]))  ||  (y2[i] < y1[i] &&(y2[i] > y3[i] || y3[i] > y1[i])) ){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n\telse if( (x1[(i+1)%3] <= x2[(i+1)%3] &&(x1[(i+1)%3] > x3[i] || x3[i] > x2[(i+1)%3]))  ||  (x2[(i+1)%3] < x1[(i+1)%3] &&(x2[(i+1)%3] > x3[i] || x3[i] > x1[(i+1)%3]))  ||  (y1[(i+1)%3] <= y2[(i+1)%3] &&(y1[(i+1)%3] > y3[i] || y3[i] > y2[(i+1)%3]))  ||  (y2[(i+1)%3] < y1[(i+1)%3] &&(y2[(i+1)%3] > y3[i] || y3[i] > y1[(i+1)%3])) ){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n      }\n\n      s = 0.0;\n      for(i=0;i<3;i++){\n\tsen[i] = sqrt( pow(x3[i] - x3[(i+1)%3],2) + pow(y3[i] - y3[(i+1)%3],2));\n\ts += sen[i];\n      }\n      \n      s /= 2;\n      if(ans == 0) ans = sqrt(s * (s - sen[0]) * (s - sen[1]) * (s - sen[2]));\n      \n      int c = 0;\n      for(i=0;i<3;i++){ //ÃÂ£ÃÂ³ÃÂ¤ÃÂ¤ÃÂÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂ¬ÃÂ£ÃÂ±ÃÂÃÂÃÂ¤ÃÂ¸ÃÂ²ÃÂ¤ÃÂ¯ÃÂ¤ÃÂ«\n\tif(x3[i] == x3[(i+1)%3] && y3[i] == y3[(i+1)%3]) c++;\n      }\n      if(c == 3) ans = -1;\n    }\n\n    if(ans >= 1900000.0) cout << \"dai-kichi\" << endl;\n    else if(ans >= 1000000.0) cout << \"chu-kichi\" << endl;\n    else if(ans >= 100000.0) cout << \"kichi\" << endl;\n    else if(ans > EPS) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n#include <complex>\n#include <cassert>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool isParallel(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint x[2], y[2];\n\twhile(cin>>x[0]>>y[0]>>x[1]>>y[1]){\n\t\tif(x[0] == 0 && y[0] == 0 && x[1] == 0 && y[1] == 0) break;\n\t\tvector<L> l;\n\t\tl.pb({P(x[0], y[0]), P(x[1], y[1])});\n\t\trep(i, 2){\n\t\t\trep(j, 2) cin>>x[j]>>y[j];\n\t\t\tl.pb({P(x[0], y[0]), P(x[1], y[1])});\n\t\t}\n\t\tbool f = true;\n\t\tvector<P> p;\n\t\trep(i, 3) rep(j, i){\n\t\t\tif(isParallel(l[i], l[j]) || (!intersectSS(l[i], l[j]))){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp.pb(crosspoint(l[i], l[j]));\n\t\t}\n\t\tif(f == false){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble s = cross(p[1]-p[0], p[2]-p[0]);\n\t\t//rep(i, 3) cout<<\" \"<<real(p[i])<<\" \"<<imag(p[i])<<endl;\n\t\ts = abs(s);\n\t\ts /= 2.0;\n\t\t//cout<<\" \"<<s<<endl;\n\t\tstring ans;\n\t\tif(s + EPS >\t\t1900000.0) ans = \"dai-kichi\";\n\t\telse if(s + EPS >\t1000000.0) ans = \"chu-kichi\";\n\t\telse if( s + EPS >\t100000.0) ans = \"kichi\";\n\t\telse if( s < EPS) ans = \"kyo\";\n\t\telse ans = \"syo-kichi\";\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n \nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n    P c;double r;\n    C(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n        //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b); \n    }\n    bool operator == (const P& a, const P& b) {\n        return a.real()==b.real()&&a.imag()==b.imag();\n    }\n}\nP pin(){\n    double x,y;\n    char d;\n    cin>>x>>y;\n    P p(x,y);\n    return p;\n}\nvoid PIN(P* a,int n){\n    rep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n    return real(conj(a)*b);\n}\ndouble cross(P a,P b){\n    return imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n    double t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n    return a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n    return p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n    double t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n    double t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n    return b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n    P pr=projection(l,c.c);\n    P e=(l[1]-l[0])/abs(l[1]-l[0]);\n    double t=sqrt(c.r*c.r-norm(pr-c.c));\n    P a=pr+t*e;\n    P b=pr-t*e;\n    if(b<a)swap(a,b);\n    return L(a,b);\n}\nL crosspointCC(C a,C b){\n    P tmp=b.c-a.c;\n    double d=abs(tmp);\n    double q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n    double t=arg(tmp);//atan(tmp.imag()/tmp.real());\n    P p1=a.c+polar(a.r,t+q);\n    P p2=a.c+polar(a.r,t-q);\n    if(p2<p1)swap(p1,p2);\n    return L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n    int n=g.size();\n    rep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n    return true;\n}\nint inconvex(const G& g, const P& p) {\n    bool in = false;\n    int n=g.size();\n    rep(i,n){\n        P a=g[i%n]-p;\n        P b=g[(i+1)%n]-p;\n        if(imag(a)>imag(b))swap(a, b);\n        if(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n        if(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n    }\n    return in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n    sort(ps.begin(), ps.end());\n    G ch(2*n);\n    for(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n        while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n    for(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n        while(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n    ch.resize(k-1);\n    return ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n    return p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n    printf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n    P p=pin();\n    double r;\n    cin>>r;\n    return C(p,r);\n}\nbool para(L a,L b){\n    return (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n    double q1,q2,q3,q4;\n    while(cin>>q1>>q2>>q3>>q4,q1||q2||q3||q4){\n        L a(P(q1,q2),P(q3,q4));\n        cin>>q1>>q2>>q3>>q4;\n        L b(P(q1,q2),P(q3,q4));\n        cin>>q1>>q2>>q3>>q4;\n        L c(P(q1,q2),P(q3,q4));\n        if(para(a,b)||para(b,c)||para(c,a)){cout<<\"kyo\"<<endl;continue;}\n        if((!intersectSS(a,b))||(!intersectSS(c,b))||(!intersectSS(a,c))){cout<<\"kyo\"<<endl;continue;}\n        P p1=crosspointLL(a,b);\n        P p2=crosspointLL(c,b);\n        P p3=crosspointLL(a,c);\n        if(p1==p2||p2==p3||p3==p1){cout<<\"kyo\"<<endl;continue;}\n        p2-=p1;\n        p3-=p1;\n        double S=abs(p2.real()*p3.imag()-p2.imag()*p3.real())/2.0;\n        if(S<100000)cout<<\"syo-kichi\"<<endl;\n        else if(S<1000000)cout<<\"kichi\"<<endl;\n        else if(S<1900000)cout<<\"chu-kichi\"<<endl;\n        else cout<<\"dai-kichi\"<<endl;\n    }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    c -= a;\n    b -= a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isIntersect(L s1, L s2){\n    return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n             ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0);\n}\n\nP crossPoint(L l, L m){\n    double A = cross(l.second - l.first, m.second - m.first);\n    double B = cross(l.second - l.first, l.second - m.first);\n    if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n    else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n    double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum / 2.0);\n}\n\nstring ans(vector<P> v){\n    double a = area(v);\n    if(a < EPS) return \"kyo\";\n    if(a < 100000.0) return \"syo-kichi\";\n    if(a < 1000000.0) return \"kichi\";\n    if(a < 1900000.0) return \"chu-kichi\";\n    return \"dai-kichi\";\n}\n\nint main(){\n    double x1,y1,x2,y2;\n    while(cin >> x1 >> y1 >> x2 >> y2 && (x1||y1||x2||y2)){\n        L v[3];\n        vector<P> p;\n        bool f = false;\n        v[0] = L(P(x1,y1),P(x2,y2));\n        for(int i=1;i<3;i++) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            v[i] = L(P(x1,y1),P(x2,y2));\n            if(!isIntersect(v[0],v[i])) f = true;\n            else p.push_back(crossPoint(v[0],v[i]));\n        }\n        if(!isIntersect(v[1],v[2])) f = true;\n        else p.push_back(crossPoint(v[1],v[2]));\n\n        if(!f){\n            for(int i=0;i<3;i++){\n                for(int j=i+1;j<3;j++){\n                    if(abs(p[i]-p[j]) < EPS) f = true;\n                }\n            }\n        }\n\n        if(f) cout << \"kyo\" << endl;\n        else cout << ans(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      point p[3];\n      for(int i=0;i<2;i++)\n\t    p[i]=intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b);\n      p[2]=intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b);\n\n      double z=(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]))/2;\n      double res=sqrt(z*(z-dist(p[0],p[1]))*(z-dist(p[1],p[2]))*(z-dist(p[2],p[0])));\n\n      if(res>1900000-EPS)cout <<\"dai-kichi\"<<endl;\n      else if(res>1000000-EPS)cout <<\"chu-kichi\"<<endl;\n      else if(res>100000-EPS)cout <<\"kichi\"<<endl;\n      else if(res>0+EPS)cout << \"syo-kichi\"<<endl;\n      else cout <<\"kyo\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\n#define EPS\t\t\t(1e-10)\n#define PI\t\t\t(3.14159265358979323846)\n\n\n#define X(a)\t\t( (a).real() )\n#define Y(a)\t\t( (a).imag() )\n#define EQ(a,b)\t\t( -EPS<(a)-(b) && (a)-(b)<EPS )\n#define EQV(a,b)\t( EQ(X(a),X(b)) && EQ(Y(a),Y(b)) )\n\n#define unit(a)\t\t( (a)/abs(a) )\n#define normal(a)\t( (a)*P(0,1) )\n#define dot(a,b)\t( X((a)*conj(b)) )\n#define cross(a,b)\t( Y(conj(a)*(b)) )\n\n// 3ツ点ツづ個暗環置ツ甘鳴係\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t// a--b--c on line\n\treturn 0;\n}\n\n// ツ静シツ閉ェツづ静シツ閉ェツづ個古ーツ債キツ板サツ津ィ\nbool intersectSS(P a, P b, P c, P d)\n{\n\treturn\tccw(a,b,c)*ccw(a,b,d) <= 0 &&\n\t\t\tccw(c,d,a)*ccw(c,d,b) <= 0;\n}\n\nP crosspointLL(P a, P b, P c, P d)\n{\n\tdouble det=cross(d-c,b-a);\n\tassert(!(abs(det)<EPS));\n\n\treturn a + (b-a) * cross(d-c,c-a)/det;\n\t\n\t// u=b-a  ->  a + tu ( t = cross(d-c,c-a)/det )\n\t// v=d-c  =>  c + sv ( s = cross(b-a,c-a)/det )\n}\n\nint main()\n{\n\tP p[6];\n\twhile(cin >> X(p[0]) >> Y(p[0]) >> X(p[1]) >> Y(p[1]), X(p[0])||Y(p[0])||X(p[1])||Y(p[1]))\n\t{\n\t\tcin >> X(p[2]) >> Y(p[2]) >> X(p[3]) >> Y(p[3]);\n\t\tcin >> X(p[4]) >> Y(p[4]) >> X(p[5]) >> Y(p[5]);\n\n\t\tbool crs = true;\n\t\tfor(int i=0; i<6; i+=2)\n\t\t{\n\t\t\tif(!intersectSS(p[i],p[i+1],p[(i+2)%6],p[(i+3)%6]))\n\t\t\t{\n\t\t\t\tcrs=false; break;\n\t\t\t}\n\n\t\t\tif(EQ(cross(p[i+1]-p[i],p[(i+3)%6]-p[(i+2)%6]),0.0))\n\t\t\t{\n\t\t\t\tcrs=false; break;\n\t\t\t}\n\t\t}\n\n\t\tif(crs)\n\t\t{\n\t\t\tP c[3];\n\n\t\t\tfor(int i=0; i<6; i+=2)\n\t\t\t{\n\t\t\t\t\tc[i/2] = crosspointLL(p[i],p[i+1],p[(i+2)%6],p[(i+3)%6]);\n\t\t\t}\n\t\t\t\n\t\t\tdouble s = abs(cross(c[1]-c[0],c[2]-c[0]));\n\n\t\t\tif(EQ(s,0.0))\n\t\t\t{\n\t\t\t\tcout << \"kyo\" << endl;\n\t\t\t}\n\t\t\telse if(s<100000)\n\t\t\t{\n\t\t\t\tcout << \"syo-kichi\" << endl;\n\t\t\t}\n\t\t\telse if(s<1000000)\n\t\t\t{\n\t\t\t\tcout << \"kichi\" << endl;\n\t\t\t}\n\t\t\telse if(s<1900000)\n\t\t\t{\n\t\t\t\tcout << \"chu-kichi\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"dai-kichi\" << endl;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool intersect_ss(Line l,Line m) {\n    return ccw(l.a,m.a,l.b)*ccw(l.a,m.b,l.b)<=0 && ccw(m.a,l.a,m.b)*ccw(m.a,l.b,m.b)<=0;\n}\n\nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)/2); s2 = abs(cross(a1,b2)/2);\n\tif(s1<EPS && s2<EPS) return false;\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\treturn true;\n}\n\nbool crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return false;\n\treturn crosspoint_ll(l,m,p);\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(crosspoint_ss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\t//printf(\"\\t%lf\\n\",s);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000.0) puts(\"syo-kichi\");\n\t\telse if(s<1000000.0) puts(\"kichi\");\n\t\telse if(s<1900000.0) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n \n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(4);\n  p[0] = p1,p[1] = p2,p[2] = p3,p[3] = p[0];\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += (p[i].x - p[i+1].x)*(p[i].y+p[i+1].y);\n  return fabs(sum/2.0);\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n     \n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nstruct Point { double x, y; };\n\nint crs(double x1, double y1, double x2, double y2) {\n    double z = x1 * y2 - y1 * x2;\n    return (0 < z ? 1 : (z < 0 ? -1 : 0));\n}\n\nbool intersect(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\n    if (0 <= crs(x2-x1, y2-y1, x3-x1, y3-y1) * crs(x2-x1, y2-y1, x4-x1, y4-y1)) return false;\n    if (0 <= crs(x4-x3, y4-y3, x1-x3, y1-y3) * crs(x4-x3, y4-y3, x2-x3, y2-y3)) return false;\n    return true;\n}\n\nPoint intersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (x3 == x4) {\n        swap(x1, x3); swap(y1, y3); swap(x2, x4); swap(y2, y4);\n    }\n    double x, y, a, b, c, d;\n    if (x1 == x2) {\n        c = (y4 - y3) / (x4 - x3);\n        d = y3 - c * x3;\n        x = x1;\n        y = c * x + d;\n    } else {\n        a = (y2 - y1) / (x2 - x1);\n        b = y1 - a * x1;\n        c = (y4 - y3) / (x4 - x3);\n        d = y3 - c * x3;\n        x = (d - b) / (a - c);\n        y = a * x + b;\n    }\n    return (Point){x, y};\n}\n\nint main() {\n    int x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6;\n    while (cin >> x1 >> y1 >> x2 >> y2, (x1 || y1 || x2 || y2)) {\n        cin >> x3 >> y3 >> x4 >> y4 >> x5 >> y5 >> x6 >> y6;\n        if ( ! intersect(x1, y1, x2, y2, x3, y3, x4, y4) ||\n             ! intersect(x3, y3, x4, y4, x5, y5, x6, y6) ||\n             ! intersect(x5, y5, x6, y6, x1, y1, x2, y2)) {\n            cout << \"kyo\" << endl;\n        } else {\n            Point p1 = intersection(x1, y1, x2, y2, x3, y3, x4, y4);\n            Point p2 = intersection(x3, y3, x4, y4, x5, y5, x6, y6);\n            Point p3 = intersection(x5, y5, x6, y6, x1, y1, x2, y2);\n            double area = abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)) / 2.0;\n            if (area < 0.00000001)\n                cout << \"kyo\" << endl;\n            else if (1899999.99999999 < area)\n                cout << \"dai-kichi\" << endl;\n            else if (999999.99999999 < area)\n                cout << \"chu-kichi\" << endl;\n            else if (99999.99999999 < area)\n                cout << \"kichi\" << endl;\n            else\n                cout << \"syo-kichi\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      point p[3];\n      for(int i=0;i<2;i++)\n\t    p[i]=intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b);\n      p[2]=intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b);\n\n      double z=(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]))/2;\n      double res=sqrt(z*(z-dist(p[0],p[1]))*(z-dist(p[1],p[2]))*(z-dist(p[2],p[0])));\n\n      if(res>1900000-EPS)cout <<\"dai-kichi\"<<endl;\n      else if(res>1000000-EPS)cout <<\"chu-kichi\"<<endl;\n      else if(res>100000-EPS)cout <<\"kichi\"<<endl;\n      else if(res>0+EPS)cout << \"syo-kichi\"<<endl;\n      else cout <<\"kyo\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <complex>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nbool on_line(const P& a, const L& l){\n  return dot(l[0]-a,l[1]-a)<EPS;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint x1,y1,x2,y2;\n\tfor(;~scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2),x1||y1||x2||y2;){\n\t\tL A(P(x1,y1),P(x2,y2));\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL B(P(x1,y1),P(x2,y2));\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL C(P(x1,y1),P(x2,y2));\n\t\tif(A[0]==A[1]||B[0]==B[1]||C[0]==C[1]){puts(\"kyo\");continue;}\n\t\tP a=crosspoint(A,B),b=crosspoint(B,C),c=crosspoint(C,A);\n\t\tif(!on_line(a,A)||!on_line(a,B)||!on_line(b,B)||!on_line(b,C)||!on_line(c,C)||!on_line(c,A)){puts(\"kyo\");continue;}\n\t\tdouble s=abs(cross(a,b)+cross(b,c)+cross(c,a));\n\t\tif(s<EPS)puts(\"kyo\");\n\t\telse if(s<100000)puts(\"syo-kichi\");\n\t\telse if(s<1000000)puts(\"kichi\");\n\t\telse if(s<1900000)puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n// struct G : public vector<Point>\n// {\n//     G() {}\n//     G(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| is_on_seg(seg1, seg2.first)\n\t\t|| is_on_seg(seg1, seg2.second)\n\t\t|| is_on_seg(seg2, seg1.first)\n\t\t|| is_on_seg(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"cross_point_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"cross_point_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079\ngtype area(const G& p)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\ts += cross(p[i], p[(i + 1) % p.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain{ OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (is_on_seg(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// 円\nenum res_circle_rela\n{\n    a_in_b,\n    b_in_a,\n\n    tangent,\n    intersect,\n    not_intersect,\n};\n// AOJ0023(feps = 0)\nres_circle_rela circle_rela(const Circle& a, const Circle& b)\n{\n    const gtype feps = 0;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    Point ab = b.p - a.p;\n    Point c = a.p + ab * (a.r / (a.r + b.r));\n\n    gtype dis = abs(a.p - c);\n    if (dis > a.r + feps)\n        return vector<Point>();\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - dis*dis));\n\n    Point u = ab * Point(0, 1) / abs(ab);\n    Point v = ab * Point(0, -1) / abs(ab);\n\n    Point p = c + u * h;\n    Point q = c + v * h;\n\n    vector<Point> res;\n    res.push_back(p);\n    if (abs(p - q) > feps)\n        res.push_back(q); // 2点で交わっている\n\n    return res;\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nbool contain_CP(const Circle& c, const Point& p)\n{\n    return abs(c.p - p) < c.r;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\nint main()\n{\n    for (;;)\n    {\n        Line l[3];\n        rep(i, 3)\n            if (!(cin >> l[i].first >> l[i].second))\n                goto END;\n\n        G g;\n        rep(i, 3) rep(j, i)\n            if (intersect_SS(l[i], l[j]) && !is_parallel(l[i], l[j]))\n                g.pb(ip_SS(l[i], l[j]));\n\n        string res;        \n        if (g.size() == 3)\n        {\n            double s = area(g) + 1e-9;\n            if (s > 1.9 * 1e6)\n                res = \"dai-kichi\";\n            else if (s > 1e6)\n                res = \"chu-kichi\";\n            else if (s > 1e5)\n                res = \"kichi\";\n            else\n                res = \"syo-kichi\";\n        }\n        else\n            res = \"kyo\";\n        cout << res << endl;\n    }\nEND:\n    ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#define EPS 1e-10\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQP(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){return real(conj(a)*b);}\ndouble cross(P a,P b){return imag(conj(a)*b);}\ndouble area(P a,P b,P c){return abs(cross(b-a,c-a)/2);}\nbool para(P a1,P a2,P b1,P b2){return abs(cross(a1-a2,b1-b2))<EPS;}\nbool is_cp(P a1,P a2,P b1,P b2){\n  if(cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS)\n    if(cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) < EPS)return true;\n  return false;\n}\nP seg_cp(P a1,P a2,P b1,P b2){\n  b2-=b1;\n  double d = abs(cross(b2,a1-b1));\n  return a1 + (a2-a1)*d/( d + abs(cross(b2,a2-b1)) );\n}\n\nint main(){\n  P p11,p12,p21,p22,p31,p32;\n  for(;;){\n    cin >> p11.real() >> p11.imag() >> p12.real() >> p12.imag();\n    if(!abs(p11) && !abs(p12))break;\n    cin >> p21.real() >> p21.imag() >> p22.real() >> p22.imag();\n    cin >> p31.real() >> p31.imag() >> p32.real() >> p32.imag();\n\n    if(para(p11,p12,p21,p22) || para(p21,p22,p31,p32) || para(p31,p32,p11,p12))\n      cout << \"kyo\\n\";\n    else if(!is_cp(p11,p12,p21,p22) || !is_cp(p21,p22,p31,p32) || !is_cp(p31,p32,p11,p12))\n      cout << \"kyo\\n\";\n    else{\n      P cp1 = seg_cp(p11,p12,p21,p22);\n      P cp2 = seg_cp(p21,p22,p31,p32);\n      P cp3 = seg_cp(p31,p32,p11,p12);\n      if(EQP(cp1,cp2))cout << \"kyo\\n\";\n      else{\n\tdouble s = area(cp1,cp2,cp3);\n\tif(s+EPS>1900000)cout << \"dai-kichi\\n\";\n\telse if(s+EPS>1e6)cout << \"chu-kichi\\n\";\n\telse if(s+EPS>1e5)cout << \"kichi\\n\";\n\telse cout << \"syo-kichi\\n\";\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n// struct G : public vector<Point>\n// {\n//     G() {}\n//     G(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| is_on_seg(seg1, seg2.first)\n\t\t|| is_on_seg(seg1, seg2.second)\n\t\t|| is_on_seg(seg2, seg1.first)\n\t\t|| is_on_seg(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"cross_point_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"cross_point_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079\ngtype area(const G& p)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\ts += cross(p[i], p[(i + 1) % p.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain{ OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (is_on_seg(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// 円\nenum res_circle_rela\n{\n    a_in_b,\n    b_in_a,\n\n    tangent,\n    intersect,\n    not_intersect,\n};\n// AOJ0023(feps = 0)\nres_circle_rela circle_rela(const Circle& a, const Circle& b)\n{\n    const gtype feps = 0;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    Point ab = b.p - a.p;\n    Point c = a.p + ab * (a.r / (a.r + b.r));\n\n    gtype dis = abs(a.p - c);\n    if (dis > a.r + feps)\n        return vector<Point>();\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - dis*dis));\n\n    Point u = ab * Point(0, 1) / abs(ab);\n    Point v = ab * Point(0, -1) / abs(ab);\n\n    Point p = c + u * h;\n    Point q = c + v * h;\n\n    vector<Point> res;\n    res.push_back(p);\n    if (abs(p - q) > feps)\n        res.push_back(q); // 2点で交わっている\n\n    return res;\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nbool contain_CP(const Circle& c, const Point& p)\n{\n    return abs(c.p - p) < c.r;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\nint main()\n{\n    for (;;)\n    {\n        Line l[3];\n        rep(i, 3)\n            if (!(cin >> l[i].first >> l[i].second))\n                goto END;\n\n        G g;\n        rep(i, 3) rep(j, i)\n            if (intersect_SS(l[i], l[j]) && !is_parallel(l[i], l[j]))\n                g.pb(ip_SS(l[i], l[j]));\n\n        string res;\n        if (g.size() == 3)\n        {\n            double s = area(g);\n            if (s >= 1900000)\n                res = \"dai-\";\n            else if (s >= ten(6))\n                res = \"chu-\";\n            else if (s >= ten(5))\n                res = \"\";\n            else\n                res = \"syo-\";\n            res += \"kichi\";\n\n            if (s < 1e-9)\n                res = \"kyo\";\n        }\n        else\n            res = \"kyo\";\n        cout << res << endl;\n    }\nEND:\n    ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\ntypedef complex<double> Point;\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\ntypedef Line Segment;\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\ndouble CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tdouble sign=Signum(Cross(d1,d2));\n\tif(sign)\n\t\treturn sign;\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\n\treturn 0;\n}\n\n// 直線と線分が重なるとき，線分の端点が直線上にあるときもtrue\nbool IntersectLS(Line a,Segment b)\n{\n\treturn CCW(a.pos,a.pos+a.dir,b.pos)*CCW(a.pos,a.pos+a.dir,b.pos+b.dir)<=0;\n}\nbool IntersectSS(Segment a,Segment b)\n{\n\treturn IntersectLS(a,b) && IntersectLS(b,a);\n}\n\n// aとbが平行でないことが前提\nPoint IntersectPoint(Line a,Line b)\n{\n\treturn a.pos+a.dir*Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir);\n}\n\nconst char* solve(Line* ls)\n{\n\tPoint ps[3];\n\tfor(int i=0;i<3;i++){\n\t\tLine l1=ls[i],l2=ls[(i+1)%3];\n\t\tif(Signum(Cross(l1.dir,l2.dir))==0)\n\t\t\treturn \"kyo\";\n\t\tif(!IntersectSS(l1,l2))\n\t\t\treturn \"kyo\";\n\t\tps[i]=IntersectPoint(l1,l2);\n\t}\n\t\n\tdouble area=abs(Cross(ps[1]-ps[0],ps[2]-ps[0]))/2;\n\tif(area<1.0e5-EPS)\n\t\treturn \"syo-kichi\";\n\tif(area<1.0e6-EPS)\n\t\treturn \"kichi\";\n\tif(area<1.9e6-EPS)\n\t\treturn \"chu-kichi\";\n\treturn \"dai-kichi\";\n}\n\nint main()\n{\n\tfor(;;){\n\t\tLine ls[3];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint x1,y1,x2,y2; scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tls[i]=Line(Point(x1,y1),Point(x2-x1,y2-y1));\n\t\t}\n\t\tif(feof(stdin))\n\t\t\tbreak;\n\t\tputs(solve(ls));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nint main(){\n\twhile(1){\n\t\tint x1,y1,x2,y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif(x1==0 && y1==0 && x2==0 && y2==0) break;\n\t\tvector<L> line(3);\n\t\tfor(int i=0; i<3; i++){\n\t\t\tif(i != 0) cin >> x1 >> y1 >> x2 >> y2;\n\t\t\tline[i] = L(P(x1,y1), P(x2,y2));\n\t\t}\n\t\tVP v;\n\t\tfor(int i=0; i<3; i++){\n\t\t\tif(!isParallel(line[i], line[(i+1)%3]) && intersectSS(line[i], line[(i+1)%3])){\n\t\t\t\tv.push_back(crosspointLL(line[i], line[(i+1)%3]));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t\tif((int)v.size() != 3){\n\t\t\tcout << \"kyo\" << endl;\n\t\t}else{\n\t\t\tif(ccw(v[0], v[1], v[2]) == -1) swap(v[1], v[2]);\n\t\t\tdouble s = getarea(v);\n\t\t\tif(s >= 1900000){\n\t\t\t\tcout << \"dai-kichi\" << endl;\n\t\t\t}else if(s >= 1000000){\n\t\t\t\tcout << \"chu-kichi\" << endl;\n\t\t\t}else if(s >= 100000){\n\t\t\t\tcout << \"kichi\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"syo-kichi\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n    \n    return fabs(res)*0.5;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        double s=area(g);\n        string res;\n        if (s - 1900000 > -EPS) res = \"dai-kichi\";\n        else if (s - 1000000 > -EPS) res = \"chu-kichi\";\n        else if (s - 100000 > -EPS) res = \"kichi\";\n        else if (s > 0) res = \"syo-kichi\";\n        else res = \"kyo\";\n        cout << res << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\ntypedef complex < double > Point;\n/*\n    Pointの使い方\n    Point AにおけるX座標...real(A) or A.real()\n                   Y座標...imag(A) or A.imag() 状況によってちょいちょい使い分けとか\n\n    Point A,BにおいてA+B,A-B,(double)k * Aは定義済み\n    原点からの距離はsqrt(norm(A))\n    二点間の距離はsqrt(norm(A-B))\n    norm(A)はX^2+Y^2を返す\n*/\ntypedef vector < Point > Polygon;\nnamespace std {\n    bool operator < (Point a,Point b) {\n        //ここで座標の比較における\"大きい\"を定義\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n\n\nstruct Line : Polygon{\n    Line(){};\n    Line(Point p,Point q){ push_back(p);push_back(q); }\n};\nstruct Circle{\n    Point p;\n    double r;\n    Circle(Point a, double s){ p = a;r = s; }\n};\n\n// ベクタの長さ\ndouble VectorLength(Point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble DistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\nPoint UnitVector(Point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<Point,Point> NormalVector(Point a){\n    Point n1 = a * Point(0,1);\n    Point n2 = a * Point(0,-1);\n    return make_pair(n1,n2);\n}\n\n//外積\ndouble cross(Point p,Point q){\n    return imag(conj(p)*q);\n}\n\n//内積\ndouble dot(Point p,Point q){\n    return real(conj(p)*q);\n}\n\nint ccw(Point a,Point b,Point c){\n    b-=a,c-=a;\n    if(cross(b,c)>0)return 1; //反時計回り\n    if(cross(b,c)<0)return -1; //時計回り\n    if(dot(b,c)<0)return 2; //直線上に c - a - b\n    if(norm(b)<norm(c))return -2; // 直線上に a - b - c\n    return 0; // 直線上に a - c - b\n}\n\nPoint normalize(Point P, double l){\n    double a = real(P), b = imag(P);\n    double y = sqrt(b*b/(a*a+b*b)*l*l);\n    double x = (a/b)*y;\n\n    return Point(x,y);\n}\n\n//三角形の面積\ndouble TriangleArea(Point A, Point B, Point C){\n    return abs(cross(B-A,C-A)/2);\n}\n\n//多角形の面積\ndouble VertexArea(Polygon v){\n    double ret = 0;\n    for(int i=1;i<v.size()-1;i++){\n        ret += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return abs(ret);\n}\n\nbool intersectLL(Line l, Line m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // 平行でない\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // 同一の線\n}\nbool intersectLS(Line l, Line s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] が lの左\n           cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] が lの右\n}\nbool intersectLP(Line l, Point p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(Line l, Point p);\nbool intersectCS(Circle C,Line l){\n    return (distanceLP(l,C.p) < C.r + EPS and\n             (C.r < abs(C.p-l[0]) + EPS or C.r < abs(C.p-l[1]) + EPS));\n}\n//↓2円の交点二つを返す（ポインタ）,戻り値は交点の個数\nint intersectCC(Circle A, Circle B, Point *p, Point *q){\n\n    Point P,Q;\n    if(B.p<A.p)swap(A.p,B.p);\n    Point dv = B.p - A.p;//ベクトル\n\n\n    double L = sqrt(norm(dv));\n    int num;\n    //距離がLの場合\n    if( L==(A.r + B.r) ){\n        num = 1;\n        //交点1つ\n        //虚数軸に沿って並んでいるとバグる？\n        dv = normalize(dv,A.r);\n        P = Q = Point(real(dv)+real(A.p),imag(dv)+imag(A.p));\n    }\n    else if( L<(A.r + B.r) && L > fabs(A.r - B.r) ){\n        num = 2;\n        //交点2つ\n        /*\n        交点の一方Qからベクトルdvに垂線を下ろしたところをptとする\n        ふたつの直角三角形p0-pt-Q、p1-pt-Qができる\n        p0-pt間の長さをtとすると、これらの三角形のQ-ptの長さは等しいため、\n\n        r0*r0 - t*t = r1*r1 - (L-t)*(L-t)\n        r0*r0 - t*t = r1*r1 - L*L - t*t + 2*L*t\n        t = (r0*r0 - r1*r1 + L*L)/(2*L)\n\n        tから、p0-Qベクトルとdvベクトルとの角度aを求め、\n        dvベクトルから、+a,-aの座標を求めれば交点となる\n        */\n\n        //tを求める\n        double t = 0.5*( A.r*A.r - B.r*B.r + L*L)/L;\n\n        //p0-Qベクトルとdvベクトルの角度\n        double a = acos( t/A.r );\n\n        //dvベクトルの角度\n        double a0 = atan2( imag(dv), real(dv) );\n\n        //交点\n        P = Point( real(A.p) + A.r*cos(a0+a), imag(A.p) + A.r*sin(a0+a) );\n        Q = Point( real(A.p) + A.r*cos(a0-a), imag(A.p) + A.r*sin(a0-a) );\n\n    }\n    else{\n        num = 0;\n        //交点なし\n    }\n\n    *p = P;\n    *q = Q;\n\n    return num;\n}\nPoint projection(Line l, Point p) {//射影\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t * (l[0]-l[1]);\n}\nPoint reflection(Line l, Point p) {//反射\n    return p + (projection(l, p) - p) + (projection(l, p) - p);\n}\ndouble distanceLP(Line l, Point p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(Line l, Line s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(Line s, Point p) {\n    const Point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(Line s, Line t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nPoint crosspoint(Line l, Line m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS);\n    return m[0] + B / A * (m[1] - m[0]);\n}\n/*\ndouble area(Polygon P) {//多角形の面積\n    double A = 0;\n    for (int i = 0; i < P.size(); ++i)\n        A += cross(curr(P, i), next(P, i));\n    return A;\n}\n*/\nPolygon ConvexHull(Polygon ps) {//凸包\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// 点が真に多角形の中にはいっているか\nbool IsInnerPointVertex(Polygon ps,Point a){\n    int cc = ccw(ps[0],ps[1],a);\n    if(not(cc == 1 or cc == -1)) return false;\n    for(int i=0;i<ps.size();i++){\n        if(cc != ccw(ps[i],ps[(i+1)%ps.size()],a)) return false;\n    }\n    return true;\n}\nint main(){\n\n\n    while(1){\n        Line l[3];\n        for(int i = 0;i < 3;i++){\n            double x1,y1,x2,y2;\n            cin>>x1>>y1>>x2>>y2;\n            if(x1==y1&&y1==x2&&x2==y2&&y2==0)goto end;\n            Point p = Point(x1,y1);\n            Point q = Point(x2,y2);\n            l[i] = Line(p,q);\n        }\n        if(!(intersectSS(l[0],l[1])&&intersectSS(l[1],l[2])&&intersectSS(l[0],l[2]))){\n            cout<<\"kyo\"<<endl;\n            continue;\n        }\n        Point A,B,C;\n        A = crosspoint(l[0],l[1]);\n        B = crosspoint(l[1],l[2]);\n        C = crosspoint(l[0],l[2]);\n        double S = TriangleArea(A,B,C);\n        if(S < EPS)cout<<\"kyo\"<<endl;\n        else if(S < 100000)cout<<\"syo-kichi\"<<endl;\n        else if(S < 1000000)cout<<\"kichi\"<<endl;\n        else if(S < 1900000)cout<<\"chu-kichi\"<<endl;\n        else cout<<\"dai-kichi\"<<endl;\n\n    }\n    end:\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nint sgn(double d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n \nstruct Point {\n  double x, y;\n  Point() {}\n  Point (const double x, const double y) : x(x), y(y) {}\n  Point& operator += (const Point& other) { x += other.x; y += other.y; return *this; }\n  Point& operator -= (const Point& other) { x -= other.x; y -= other.y; return *this; }\n  Point& operator *= (const double& factor) { x *= factor; y *= factor; return *this; }\n  Point& operator /= (const double& factor) { x /= factor; y /= factor; return *this; }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>;\nPoint operator + (const Point&lhs, const Point& rhs) { return Point(lhs.x + rhs.x, lhs.y + rhs.y); }\nPoint operator - (const Point& lhs, const Point& rhs) { return Point(lhs.x - rhs.x, lhs.y - rhs.y); }\nPoint operator * (const Point& lhs, const double& factor) { return Point(lhs.x * factor, lhs.y * factor); }\nPoint operator * (const double& factor, const Point& rhs) { return Point(factor * rhs.x, factor * rhs.y); }\nPoint operator / (const Point& lhs, const double& factor) { return Point(lhs.x / factor, lhs.y / factor); }\ndouble operator * (const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }\ndouble operator ^ (const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }\nbool operator == (const Point& lhs, const Point& rhs) { return sgn(lhs.x - rhs.x) == 0 && sgn(lhs.y - rhs.y) == 0; }\nbool operator != (const Point& lhs, const Point& rhs) { return !(lhs == rhs); }\nbool operator < (const Point& lhs, const Point& rhs) { return sgn(lhs.x - rhs.x) ? lhs.x < rhs.x : lhs.y < rhs.y; }\nbool operator > (const Point& lhs, const Point& rhs) { return rhs < lhs; }\nbool operator <= (const Point& lhs, const Point& rhs) { return !(lhs > rhs); }\nbool operator >= (const Point& lhs, const Point& rhs) { return !(lhs < rhs); }\nistream& operator >> (istream& is, Point& point) { return is >> point.x >> point.y; }\nostream& operator << (ostream& os, Point& point) { return os << \"(\" << point.x << \",\" << point.y << \")\"; }\ndouble norm(const Point& point) { return point.x * point.x + point.y * point.y; }\ndouble abs(const Point& point) { return sqrt(norm(point)); }\ndouble arg(const Point& point) { return atan2(point.y, point.x); }\nPoint polar(const double& a, const double& r) { return Point(cos(r) * a, sin(r) * a); }\nbool sort_x(Point lhs, Point rhs) { return sgn(lhs.x - rhs.x) ? lhs.x < rhs.x : lhs.y < rhs.y; }\nbool sort_y(Point lhs, Point rhs) { return sgn(lhs.y - rhs.y) ? lhs.y < rhs.y : lhs.x < rhs.x; }\n \nstruct Segment {\n  Point p1, p2;\n  Segment() {}\n  Segment(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}\n};\nusing Line = Segment;\nistream& operator >> (istream& is, Segment& segment) { return is >> segment.p1 >> segment.p2; }\nostream& operator << (ostream& os, Segment& segment) { return os << \"(\" << segment.p1 << \",\" << segment.p2 << \")\"; }\n \nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (sgn(a ^ b) > 0) return CCW_COUNTER_CLOCKWISE;\n  if (sgn(a ^ b) < 0) return CCW_CLOCKWISE;\n  if (sgn(a * b) < 0) return CCW_ONLINE_BACK;\n  if (sgn(norm(a) - norm(b)) < 0) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n \nbool intersectSS(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n  return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nbool intersectSS(const Segment& s1, const Segment& s2) {\n  return intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPointSS(const Segment& s1, const Segment& s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(base ^ (s1.p1 - s2.p1));\n  double d2 = abs(base ^ (s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  Segment l[3];\n  while (cin >> l[0] >> l[1] >> l[2]) {\n    bool no = false;\n    for (int i = 0; i < 3; i++) {\n      if (ccw(l[i].p1, l[i].p2, l[(i + 1) % 3].p1) == CCW_ON_SEGMENT) no = true;\n      if (ccw(l[i].p1, l[i].p2, l[(i + 1) % 3].p2) == CCW_ON_SEGMENT) no = true;\n    }\n    for (int i = 0; i < 3; i++) {\n      if (!intersectSS(l[i], l[(i + 1) % 3])) no = true;\n    }\n    if (no) {\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    Point cp[3];\n    for (int i = 0; i < 3; i++) {\n      cp[i] = getCrossPointSS(l[i], l[(i + 1) % 3]);\n    }\n    if (cp[0] == cp[1] && cp[1] == cp[2]) {\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    double S = abs((cp[1] - cp[0]) ^ (cp[2] - cp[0])) / 2;\n    if (sgn(S - 1900000) >= 0) cout << \"dai-kichi\" << endl;\n    else if (sgn(S - 1000000) >= 0) cout << \"chu-kichi\" << endl;\n    else if (sgn(S - 100000) >= 0) cout << \"kichi\" << endl;\n    else cout << \"syo-kichi\" << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)/2); s2 = abs(cross(a1,b2)/2);\n\tif(s1<EPS && s2<EPS) return false;\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\tif(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x || p.x<min(m.a.x,m.b.x) || max(m.a.x,m.b.x)<p.x ||\n\t   p.y<min(l.a.y,l.b.y) || max(l.a.y,l.b.y)<p.y || p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\t//printf(\"\\t%lf\\n\",s);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000.0) puts(\"syo-kichi\");\n\t\telse if(s<1000000.0) puts(\"kichi\");\n\t\telse if(s<1900000.0) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\n\nreal angle(Point A, Point B){\n    return acos(dot(A, B)/abs(A)/abs(B));\n}\n\n\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool intersect(Segment s, Line t){\n    int a = ccw(t.a, t.b, s.a), b = ccw(t.a, t.b, s.b);\n    return (!(a&1) || !(b&1) || a != b);\n}\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nstatic constexpr int CONTAIN = 0;\nstatic constexpr int INSCRIBE = 1;\nstatic constexpr int INTERSECT = 2;\nstatic constexpr int CIRCUMSCRIBED = 3;\nstatic constexpr int SEPARATE = 4;\n\nint intersect(Circle c1, Circle c2){\n    if(c1.r < c2.r) swap(c1, c2);\n    real d = abs(c1.c-c2.c);\n    real r = c1.r + c2.r;\n    if(fabs(d-r) < EPS) return CIRCUMSCRIBED;\n    if(d > r) return SEPARATE;\n    if(fabs(d+c2.r-c1.r) < EPS) return INSCRIBE;\n    if(d+c2.r < c1.r) return CONTAIN;\n    return INTERSECT;\n}\n\nreal distance(Line l, Point c){\n    return abs(cross(l.b-l.a, c-l.a)/abs(l.b-l.a));\n}\n\n\nreal distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\nreal distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\nPoint project(Line l, Point p){\n    Point Q = l.b-l.a;\n    return l.a + Q*(dot(p-l.a, Q) / dot(Q, Q));\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPolygon crossPoint(Circle c, Line l){\n    Point p = project(l, c.c), q = (l.b-l.a)/abs(l.b-l.a);\n    if(abs(distance(l, c.c)-c.r) < EPS){\n        return {p};\n    }\n    double k = sqrt(c.r*c.r-dot(p-c.c, p-c.c));\n    return {p-q*k, p+q*k};\n}\n\nPolygon crossPoint(Circle c, Segment s){\n    auto tmp = crossPoint(c, Line(s.a, s.b));\n    Polygon ret;\n    for (auto &&i : tmp) {\n        if(distance(s, i) < EPS) ret.emplace_back(i);\n    }\n    return ret;\n}\n\n\nPolygon crossPoint(Circle c1, Circle c2){\n    double d = abs(c1.c-c2.c);\n    double a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t = arg(c2.c-c1.c);\n    return {c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a)};\n}\n\nPolygon tangent(Circle c1, Point p){\n    Circle c2 = Circle(p, sqrt(dot(c1.c-p, c1.c-p)-c1.r*c1.r));\n    return crossPoint(c1, c2);\n}\nvector<Line> tangent(Circle c1, Circle c2){\n    vector<Line> ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    double k = dot(c1.c-c2.c, c1.c-c2.c);\n    if(abs(k) < EPS) return {};\n    Point u = (c2.c-c1.c)/sqrt(k);\n    Point v(-u.y, u.x);\n    for (auto &&i : {-1, 1}) {\n        double h = (c1.r+i*c2.r)/sqrt(k);\n        if(abs(h*h-1) < EPS){\n            ret.emplace_back(c1.c+u*c1.r, c1.c+(u+v)*c1.r);\n        }else if(h*h < 1){\n            Point u2 = u*h, v2 = v*sqrt(1-h*h);\n            ret.emplace_back(c1.c+(u2+v2)*c1.r, c2.c-(u2+v2)*c2.r*i);\n            ret.emplace_back(c1.c+(u2-v2)*c1.r, c2.c-(u2-v2)*c2.r*i);\n        }\n    }\n    return ret;\n}\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nreal area(Circle c, Polygon &v){\n    int n = v.size();\n    real ans = 0.0;\n    Polygon u;\n    for (int i = 0; i < n; ++i) {\n        u.emplace_back(v[i]);\n        auto q = crossPoint(c, Segment(v[i], v[(i+1)%n]));\n        for (auto &&j : q) {\n            u.emplace_back(j);\n        }\n    }\n    for (int i = 0; i < u.size(); ++i) {\n        Point A = u[i]-c.c, B = u[(i+1)%u.size()]-c.c;\n        if(abs(A) >= c.r+EPS || abs(B) >= c.r+EPS){\n            Point C = polar(1, arg(B)-arg(A));\n            ans += c.r*c.r*arg(C)/2;\n        }else {\n            ans += cross(A, B)/2;\n        }\n    }\n    return ans;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nbool isconvex(Polygon v){\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        if(ccw(v[(i+n-1)%n], v[i], v[(i+1)%n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint contains(Polygon v, Point p){\n    int n = v.size();\n    bool x = false;\n    static constexpr int IN = 2;\n    static constexpr int ON = 1;\n    static constexpr int OUT = 0;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?IN:OUT);\n}\n\nreal diameter(Polygon v){\n    int n = v.size();\n    if(n == 2) return abs(v[0]-v[1]);\n    int i = 0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if(v[i] < v[k]) i = k;\n        if(!(v[j] < v[k])) j = k;\n    }\n    real ret = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        ret = max(ret, abs(v[i]-v[j]));\n        if(cross(v[(i+1)%n]-v[i], v[(j+1)%n]-v[j]) < 0.0) i = (i+1)%n;\n        else j = (j+1)%n;\n    }\n    return ret;\n}\n\nPolygon convexCut(Polygon v, Line l){\n    Polygon q;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i], b = v[(i+1)%n];\n        if(ccw(l.a, l.b, a) != -1) q.push_back(a);\n        if(ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0){\n            q.push_back(crossPoint(Line(a, b), l));\n        }\n    }\n    return q;\n}\n\nreal closest_pair(Polygon &v, int l = 0, int r = -1){\n    if(!(~r)){\n        r = v.size();\n        sort(v.begin(),v.end());\n    }\n    if(r - l < 2) {\n        return abs(v.front()-v.back());\n    }\n    int mid = (l+r)/2;\n    real p = v[mid].x;\n    real d = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, sorty);\n    Polygon u;\n    for (int i = l; i < r; ++i) {\n        if(fabs(v[i].x-p) >= d) continue;\n        for (int j = 0; j < u.size(); ++j) {\n            real dy = v[i].y-next(u.rbegin(), j)->y;\n            if(dy >= d) break;\n            d = min(d, abs(v[i]-*next(u.rbegin(), j)));\n        }\n        u.emplace_back(v[i]);\n    }\n    return d;\n}\n\n\nint main() {\n    Point x, y;\n    while(cin >> x >> y, abs(x-y) > EPS){\n        Point a, b, c, d; cin >> a >> b >> c >> d;\n        Segment A(x, y), B(a, b), C(c, d);\n        if(!intersect(A, B) || !intersect(B, C) || !intersect(C, A)){\n            puts(\"kyo\");\n            continue;\n        }\n        Polygon P{crossPoint(A, B), crossPoint(B, C), crossPoint(C, A)};\n        real w = abs(area(P));\n        if(w < EPS) puts(\"kyo\");\n        else if(w < 100000) puts(\"syo-kichi\");\n        else if(w < 1000000) puts(\"kichi\");\n        else if(w < 1900000) puts(\"chu-kichi\");\n        else puts(\"dai-kichi\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(){}\n\tL(const P& a, const P& b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b,c) > 0)  return  1;\n\tif(cross(b,c) < 0)  return -1;\n\tif(dot(b,c)   < 0)  return  2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L& s, const L& t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t   ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool crosspoint(const L& l, const L& m, P& out) {\n\tif(!intersectSS(l, m))\n\t\treturn false;\n\t\n\tdouble A = cross(l[1]-l[0], m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0], l[1]-m[0]);\n\tif(abs(A) < EPS && abs(B) < EPS)\n\t\treturn false;\n\tout = m[0] + B/A*(m[1]-m[0]);\n\treturn true;\n}\n\n\nint main()\n{\n\tfor(;;){\n\t\tL s[3];\n\t\trep(i, 3){\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\tif(!x1 && !y1 && !x2 && !y2)\n\t\t\t\treturn 0;\n\t\t\ts[i].push_back(P(x1, y1));\n\t\t\ts[i].push_back(P(x2, y2));\n\t\t}\n\t\t\n\t\tP p[3];\n\t\tbool ok = true;\n\t\trep(i, 3){\n\t\t\tif(!crosspoint(s[i], s[(i+1)%3], p[i])){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble area = 0.0;\n\t\tif(ok){\n\t\t\tarea = abs(cross(p[1]-p[0], p[2]-p[1])/2.0);\n\t\t}\n\t\tif(area >= 1900000)\n\t\t\tputs(\"dai-kichi\");\n\t\telse if(area >= 1000000)\n\t\t\tputs(\"chu-kichi\");\n\t\telse if(area >= 1000000)\n\t\t\tputs(\"kichi\");\n\t\telse if(area >= EPS)\n\t\t\tputs(\"syo-kichi\");\n\t\telse\n\t\t\tputs(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=-10)cout<<\"syo-kichi\"<<endl;\n      else exit(1);\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)); s2 = abs(cross(a1,b2));\n\tif(s1<EPS && s2<EPS) return false;\n\tif(s1<EPS) swap(s1,s2);\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\tif(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x ||\n\t   p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000) puts(\"syo-kichi\");\n\t\telse if(s<1000000) puts(\"kichi\");\n\t\telse if(s<1900000) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Point {\npublic:\n  double x;\n  double y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator +(Point p) { return Point(x+p.x, y+p.y); }\n  Point operator -(Point p) { return Point(x-p.x, y-p.y); }\n  Point operator *(double a) { return Point(x*a, y*a); }\n};\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Vector v) {\n  return v.x*v.x + v.y*v.y;\n}\n\ndouble abs(Vector v) {\n  return sqrt(norm(v));\n}\n\nclass Segment {\npublic:\n  Point p1;\n  Point p2;\n  Segment(Point p1=Point(0,0), Point p2=Point(0,0)) : p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double t = dot(p - s.p1, base)/norm(base);\n  return s.p1 + base*t;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > 0) return 1;\n  if(cross(a, b) < 0) return -1;\n  if(dot(a, b) < 0) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2) {\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2-s1.p1)*t;\n}\n\nint main() {\n  while(1) {\n    Segment s[3];\n    cin >> s[0].p1.x >> s[0].p1.y >> s[0].p2.x >> s[0].p2.y;\n    if(s[0].p1.x == 0 && s[0].p1.y == 0 &&\n       s[0].p2.x == 0 && s[0].p2.y == 0    ) break;\n    for(int i = 1; i < 3; i++) {\n      cin >> s[i].p1.x >> s[i].p1.y >> s[i].p2.x >> s[i].p2.y;\n    }\n\n    double S = -1;\n    bool flag = true;\n    for(int i = 0; i < 3; i++) {\n      if(!isIntersect(s[i], s[(i+1)%3])) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) {\n    Point p[3];\n    for(int i = 0; i < 3; i++) {\n      p[i] = getCrossPoint(s[i], s[(i+1)%3]);\n    }\n    \n    S = abs(p[1] - p[0]) * abs(project(Segment(p[0], p[1]), p[2]) - p[2]) / 2;\n    }\n\n    if(S >= 1900000) cout << \"dai-kichi\" << endl;\n    else if(S >= 1000000) cout << \"chu-kichi\" << endl;\n    else if(S >= 100000) cout << \"kichi\" << endl;\n    else if(S > 0) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0-EPS)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0-EPS)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0-EPS)cout<<\"kichi\"<<endl;\n    else if(area>=0.0)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n        if(isParallel(a,b)||isParallel(b,c)||isParallel(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        double x=area(g);\n        if(x==0)puts(\"kyo\");\n        else if(x<100000)puts(\"syo-kichi\");\n        else if(x<1000000)puts(\"kichi\");\n        else if(x<1900000)puts(\"chu-kichi\");\n        else puts(\"dai-kichi\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool intersectSS(Line l,Line m) {\n    return ccw(l.a,m.a,l.b)*ccw(l.a,m.b,l.b)<=0 && ccw(m.a,l.a,m.b)*ccw(m.a,l.b,m.b)<=0;\n}\n\nbool pss(Line l,Line m,Point &p){\n    if(intersectSS(l,m)==false) return false;\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)/2); s2 = abs(cross(a1,b2)/2);\n\tif(s1<EPS && s2<EPS) return false;\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\t//printf(\"\\t%lf\\n\",s);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000.0) puts(\"syo-kichi\");\n\t\telse if(s<1000000.0) puts(\"kichi\");\n\t\telse if(s<1900000.0) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const long double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst long double INF = 1e12;\ntypedef complex<long double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\nlong double cross(const P& a, const P& b) {return imag(conj(a)*b);}\nlong double dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\nstruct C {P p; long double r;C(const P &p, long double r) : p(p), r(r) { }};\nint ccw(P a, P b, P c) {b -= a; c -= a;if (cross(b, c) > 0)   return +1;if (cross(b, c) < 0)   return -1;if (dot(b, c) < 0) return +2;if (norm(b) < norm(c)) return -2;return 0;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nP crosspoint(const L &l, const L &m) {long double A = cross(l[1] - l[0], m[1] - m[0]);long double B = cross(l[1] - l[0], l[1] - m[0]);if (abs(A) < EPS && abs(B) < EPS) return m[0];return m[0] + B / A * (m[1] - m[0]);}\nlong double getArea(P a, P b , P c){\n\t\tb-=a, c-=a;\n\t\treturn fabs( b.real() * c.imag() - c.real() * b.imag() ) / 2.0\t; \n}\nint main(){\n\tlong double a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a+b+c+d != 0){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tlong double ret = 0;\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tret = getArea( crosspoint(one,two) , crosspoint(two,three) , crosspoint(one,three) );\n\t\t}\n\t\tif(ret == 0){\n\t\t\tcout << \"kyo\" << endl;\n\t\t}else if(ret < 100000-EPS){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else if(ret < 1000000-EPS){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret < 1900000-EPS){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=0)cout<<\"syo-kichi\"<<endl;\n      else exit(1);\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/////////////////////???Library???/////////////////////////\n\nint xx1, yy1, xx2, yy2;\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tif (xx1 == 0 && yy1 == 0 && xx2 == 0 && yy2 == 0) break;\n\t\t\n\t\tSegment s1(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s2(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s3(Point(xx2, yy2), Point(xx1, yy1));\n\n\t\tif (isParallel(s1, s2) || isParallel(s1, s3) || isParallel(s2, s3))\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint kousa_num = 0;\n\t\tif (intersect(s1, s2)) kousa_num++;\n\t\tif (intersect(s1, s3)) kousa_num++;\n\t\tif (intersect(s2, s3)) kousa_num++;\n\t\t//printf(\"kousa_num = %d\\n\", kousa_num);\n\t\tif (kousa_num <= 2)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tPoint p1 = getCrossPoint(s1, s2);\n\t\tPoint p2 = getCrossPoint(s1, s3);\n\t\tPoint p3 = getCrossPoint(s2, s3);\n\n\t\t/*\n\t\tprintf(\"p1 = (%f, %f)\\n\", p1.x, p1.y);\n\t\tprintf(\"p2 = (%f, %f)\\n\", p2.x, p2.y);\n\t\tprintf(\"p3 = (%f, %f)\\n\", p3.x, p3.y);\n\t\t*/\n\n\t\tif (p1 == p2 || p2 == p3 || p1 == p3)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVector v12 = p2 - p1;\n\t\tVector v13 = p3 - p1;\n\n\t\tdouble ans = fabs(cross(v12, v13)) / 2.0f;\n\t\tif (ans >= 1900000.0f) printf(\"dai-kichi\\n\");\n\t\telse if (ans >= 1000000.0f) printf(\"chu-kichi\\n\");\n\t\telse if (ans >= 100000.0f) printf(\"kichi\");\n\t\telse if (ans > 0) printf(\"syo-kichi\\n\");\n\t\telse printf(\"kyo\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nstring omikuji(const vector<segment>& segments) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tconst segment& s = segments[i], t = segments[(i + 1) % 3];\n\t\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\t\tif(abs(tmp) < EPS || !intersect(s, t))\n\t\t\treturn \"kyo\";\n\t}\n\n\tpolygon triangle;\n\tfor(int i = 0; i < 3; ++i)\n\t\ttriangle.push_back(crosspoint(segments[i], segments[(i + 1) % 3]));\n\n\tconst double area_of_triangle = area(triangle);\n\tif(area_of_triangle > 1900000 - EPS)\n\t\treturn \"dai-kichi\";\n\n\tif(area_of_triangle > 1000000 - EPS)\n\t\treturn \"chu-kichi\";\n\n\tif(area_of_triangle > 100000 - EPS)\n\t\treturn \"kichi\";\n\n\treturn \"syo-kichi\";\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y, x2, y2; cin >> x >> y >> x2 >> y2, (x | y | x2 | y2);) {\n\t\tvector<segment> segments;\n\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y >> x2 >> y2;\n\t\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\t}\n\n\t\tstring result = omikuji(segments);\n\t\tcout << result << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/////////////////////???Library???/////////////////////////\n\nint xx1, yy1, xx2, yy2;\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tif (xx1 == 0 && yy1 == 0 && xx2 == 0 && yy2 == 0) break;\n\t\t\n\t\tSegment s1(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s2(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s3(Point(xx2, yy2), Point(xx1, yy1));\n\n\t\tif (isParallel(s1, s2) || isParallel(s1, s3) || isParallel(s2, s3))\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint kousa_num = 0;\n\t\tif (intersect(s1, s2)) kousa_num++;\n\t\tif (intersect(s1, s3)) kousa_num++;\n\t\tif (intersect(s2, s3)) kousa_num++;\n\t\t//printf(\"kousa_num = %d\\n\", kousa_num);\n\t\tif (kousa_num <= 2)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tPoint p1 = getCrossPoint(s1, s2);\n\t\tPoint p2 = getCrossPoint(s1, s3);\n\t\tPoint p3 = getCrossPoint(s2, s3);\n\n\t\t/*\n\t\tprintf(\"p1 = (%f, %f)\\n\", p1.x, p1.y);\n\t\tprintf(\"p2 = (%f, %f)\\n\", p2.x, p2.y);\n\t\tprintf(\"p3 = (%f, %f)\\n\", p3.x, p3.y);\n\t\t*/\n\n\t\tif (p1 == p2 && p2 == p3)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVector v12 = p2 - p1;\n\t\tVector v13 = p3 - p1;\n\n\t\tdouble ans = cross(v12, v13) / 2.0f;\n\t\tif (ans >= 1900000.0f) printf(\"dai-kichi\\n\");\n\t\telse if (ans >= 1000000.0f) printf(\"chu-kichi\\n\");\n\t\telse if (ans >= 100000.0f) printf(\"kichi\");\n\t\telse printf(\"syo-kichi\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\n#define INF 1e99\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef const point &rpoint;\n\n\ndouble cross(rpoint a, rpoint b){\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble intersect(point pa1, point pa2, point pb1, point pb2){\n\tpoint difa = pa2 - pa1;\n\tpoint difb = pb2 - pb1;\n\tpoint difab1 = pb1 - pa1;\n\n\tdouble D = cross(difa, -difb);\n\n\tif(abs(D) > EPS){\n\t\tdouble t = cross(difab1, -difb) / D;\n\t\tdouble s = cross(difa, difab1) / D;\n\t\t\n\t\tif(t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0){\n\t\t\treturn t;\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main(){\n\tpoint s[3], f[3], z[3];\n\tint x1, x2, y1, y2;\n\n\twhile(true){\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tif( scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2) != 4 ){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ts[i] = point(x1, y1);\n\t\t\tf[i] = point(x2, y2);\n\t\t}\n\t\t\n\t\tint j;\n\t\tfor(j = 0; j < 3; ++j){\n\t\t\tdouble t = intersect(s[j], f[j], s[(j+1)%3], f[(j+1)%3]);\n\t\t\tif( t == INF ){\n\t\t\t\tputs(\"kyo\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tz[j] = (1.0 - t) * s[j] + t * f[j];\n\t\t}\n\t\t\n\t\tif( j == 3 ){\n\t\t\tdouble s = abs( cross(z[1] - z[0], z[2] - z[0]) ) * 0.5;\n\t\t\t\n\t\t\tif( s >= 1.9e6 ){\n\t\t\t\tputs(\"dai-kichi\");\n\t\t\t}\n\t\t\telse if( s >= 1e6 ){\n\t\t\t\tputs(\"chu-kichi\");\n\t\t\t}\n\t\t\telse if( s >= 1e5 ){\n\t\t\t\tputs(\"kichi\");\n\t\t\t}\n\t\t\telse if( s > EPS ){\n\t\t\t\tputs(\"syo-kichi\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int i,j,x1[3],y1[3],x2[3],y2[3],ty[3]/*x=c >> 1, y=c >> 2*/;\n  double a[3],b[3],x3[3],y3[3],sen[3],s,ans;\n  while(1){\n    cin >> x1[0] >> y1[0] >> x2[0] >> y2[0];\n    if(x1[0] == 0 && x2[0] == 0 && y1[0] == 0 && y2[0] == 0) break;\n    for(i=1;i<3;i++) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\n    for(i=0;i<3;i++){// y = a * x + b\n      a[i] = b[i] = 0.0;\n      if(x1[i] == x2[i]) ty[i] = 1;\n      else if(y1[i] == y2[i]){\n\tty[i] = 2;\n\ta[i] = 0.0;\n\tb[i] = (double)y1[i];\n      }\n      else{\n\ta[i] =(double)  (y1[i] - y2[i]) / (x1[i] - x2[i]);\n\tb[i] = (double) y1[i] - a[i] * x1[i];\n\tty[i] = 0;\n      }\n    }\n\n    ans = 0.0;\n    for(i=0;i<3;i++){ //ÃÂ¿ÃÂ¹ÃÂ¤ÃÂ¾ÃÂ¬ÃÂ¹ÃÂ§\n      if(ty[i] == 1 && ty[(i+1)%3] == 1){\n\tans = -1.0;\n\tbreak;\n      }\n      else if(ty[i] != 1 && ty[(i+1)%3] != 1 && a[i] == a[(i+1)%3]){\n\tans = -1.0;\n\tbreak;\n      }\n    }\n\n    if(ans == 0.0){\n      for(i=0;i<3;i++){\n\tif(ty[i] == 1){\n\t  x3[i] = (double)x1[i];\n\t  y3[i] = a[(i+1)%3] * x3[i] + b[(i+1)%3];\n\t}\n\telse{\n\t  x3[i] = (b[(i+1)%3] - b[i]) / (a[i] - a[(i+1)%3]);\n\t  if(b[(i+1)%3] == b[i]) x3[i] = 0.0;\n\t  y3[i] = a[i] * x3[i] + b[i];\n\t}\n\n\tif( (x1[i] <= x2[i] &&(x1[i] > x3[i] || x3[i] > x2[i]))  ||  (x2[i] < x1[i] &&(x2[i] > x3[i] || x3[i] > x1[i]))  ||  (y1[i] <= y2[i] &&(y1[i] > y3[i] || y3[i] > y2[i]))  ||  (y2[i] < y1[i] &&(y2[i] > y3[i] || y3[i] > y1[i])) ){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n\telse if( (x1[(i+1)%3] <= x2[(i+1)%3] &&(x1[(i+1)%3] > x3[i] || x3[i] > x2[(i+1)%3]))  ||  (x2[(i+1)%3] < x1[(i+1)%3] &&(x2[(i+1)%3] > x3[i] || x3[i] > x1[(i+1)%3]))  ||  (y1[(i+1)%3] <= y2[(i+1)%3] &&(y1[(i+1)%3] > y3[i] || y3[i] > y2[(i+1)%3]))  ||  (y2[(i+1)%3] < y1[(i+1)%3] &&(y2[(i+1)%3] > y3[i] || y3[i] > y1[(i+1)%3])) ){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n      }\n\n      s = 0.0;\n      for(i=0;i<3;i++){\n\tsen[i] = sqrt( pow(x3[i] - x3[(i+1)%3],2) + pow(y3[i] - y3[(i+1)%3],2));\n\ts += sen[i];\n      }\n      \n      s /= 2;\n      if(ans == 0.0) ans = sqrt(s * (s - sen[0]) * (s - sen[1]) * (s - sen[2]));\n      \n      int c = 0;\n      for(i=0;i<3;i++){ //ÃÂ£ÃÂ³ÃÂ¤ÃÂ¤ÃÂÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂ¬ÃÂ£ÃÂ±ÃÂÃÂÃÂ¤ÃÂ¸ÃÂ²ÃÂ¤ÃÂ¯ÃÂ¤ÃÂ«\n\tif(x3[i] == x3[(i+1)%3] && y3[i] == y3[(i+1)%3]) c++;\n      }\n      if(c == 3) ans = -1.0;\n    }\n\n    if(ans >= 1900000.0) cout << \"dai-kichi\" << endl;\n    else if(ans >= 1000000.0) cout << \"chu-kichi\" << endl;\n    else if(ans >= 100000.0) cout << \"kichi\" << endl;\n    else if(ans > 0.0) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\ndouble cross(const xy_t &a, const xy_t &b){\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n\treturn real(conj(a)*b);\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n\tb -= a, c -= a;\n\tif(cross(b, c) < 0) return 1;\n\tif(cross(b, c) > 0) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const line &s, const line &t){\n\treturn ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0\n\t\t&& ccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\nxy_t crosspoint(const line &l, const line &m){\n\tdouble a = cross(l.second - l.first, m.second - m.first);\n\tdouble b = cross(l.second - l.first, l.second - m.first);\n\tif(abs(a) < EPS && abs(b) < EPS) return m.first;\n\tif(abs(a) < EPS) assert(false);\n\treturn m.first + b / a * (m.second - m.first);\n}\n\nint main(){\n\tline ls[3];\n\txy_t p[3];\n\tint x1, y1, x2, y2;\n\twhile(cin >> x1 >> y1 >> x2 >> y2 && (x1 || y1 || x2 || y2)){\n\t\tls[0] = line(xy_t(x1, y1), xy_t(x2, y2));\n\t\trep2(i, 1, 3) {\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tls[i] = line(xy_t(x1, y1), xy_t(x2,y2));\n\t\t}\n\t\tbool ok = true;\n\t\trep(i, 3) if(!intersectSS(ls[i], ls[(i+1)%3])) ok = false;\n\t\tif(!ok) {\n\t\t\tcout << \"kyo\" << endl;\n\t\t}else{\n\t\t\trep(i, 3) p[i] = crosspoint(ls[i], ls[(i+1)%3]);\n\t\t\tdouble area = abs(cross(p[2] - p[0], p[1] - p[0])) / 2;\n\t\t\tif(area < EPS){\n\t\t\t\tcout << \"kyo\" << endl;\n\t\t\t}else if(area < 100000){\n\t\t\t\tcout << \"syo-kichi\" << endl;\n\t\t\t}else if(area < 1000000){\n\t\t\t\tcout << \"kichi\" << endl;\n\t\t\t}else if(area < 1900000){\n\t\t\t\tcout << \"chu-kichi\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"dai-kichi\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-b1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    VP v;\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      VP v;\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000)cout<<\"kichi\"<<endl;\n      else if(are>=0.00000001)cout<<\"syo-kichi\"<<endl;\n      else cout<<\"kyo\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n//ñ³Ìî{ÆÈé_ð çí·\\¢Ì\ndouble Square(double x){return x*x;}\nstruct Point\n{\n\tdouble x,y;\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint():x(),y(){}\n\tconst Point operator+(const Point &r)const{return Point(x+r.x,y+r.y);}\n\tconst Point operator-(const Point &r)const{return Point(x-r.x,y-r.y);}\n};\nconst Point operator*(const Point &p,double r){return Point(p.x*r,p.y*r);}\nconst Point operator*(double r,const Point &p){return p*r;}\nconst double EPS = 0.001;\n//üªÌð_ðßÜ·\n//»à»àð·µÄÈ©Á½çAfalseðÔµÜ·\nbool IntersectionPoint(Point f1, Point t1, Point f2, Point t2, Point *out)\n{\n\tdouble d = (t1.x-f1.x)*(t2.y-f2.y) - (t1.y-f1.y)*(t2.x-f2.x);\n\tif(fabs(d)<EPS) return false;\t//½s\n\tdouble r = ( (t2.y-f2.y)*(f2.x-f1.x)-(t2.x-f2.x)*(f2.y-f1.y) )/d,\n\t\t   s = ( (t1.y-f1.y)*(f2.x-f1.x)-(t1.x-f1.x)*(f2.y-f1.y) )/d;\n\tif(s<=0 || s>1 || r<=0 || r>1) return false;\n\t*out = f1 + r*(t1-f1);\n\treturn true;\n}\ndouble Distance(Point x,Point y)\n{\n\treturn sqrt(Square(x.x-y.x)+Square(x.y-y.y));\n}\n\nint main()\n{\n\tPoint p[6],c1,c2,c3;\n\tdouble S,s,a,b,c;\n\tint i;\n\tfor(;;)\n\t{\n\t\tfor(i=0;i<6;++i)\n\t\t{\n\t\t\tif(scanf(\"%lf%lf\",&p[i].x,&p[i].y)-2) return 0;\n\t\t}\n\t\tif(IntersectionPoint(p[0],p[1],p[2],p[3],&c1) && \n\t\t\tIntersectionPoint(p[2],p[3],p[4],p[5],&c2) && \n\t\t\tIntersectionPoint(p[4],p[5],p[0],p[1],&c3) )\n\t\t{\n\t\t\ta=Distance(c1,c2);\n\t\t\tb=Distance(c2,c3);\n\t\t\tc=Distance(c3,c1);\n\t\t\ts=(a+b+c)/2;\n\t\t\tS=sqrt(s*(s-a)*(s-b)*(s-c));\n\t\t\tif(S>=1900000)puts(\"dai-kichi\");\n\t\t\telse if(S>=1000000)puts(\"chu-kichi\");\n\t\t\telse if(S>=100000)puts(\"kichi\");\n\t\t\telse puts(\"syo-kichi\");\n\t\t}\n\t\telse puts(\"kyo\");\n\t}\n\treturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>a>>b>>c>>d,a|b|c|d){\n\t\tvector<L>l;\n\t\tl.pb(L(P(a,b),P(c,d)));\n\t\trep(i,2){\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tl.pb(L(P(a,b),P(c,d)));\n\t\t}\n\t\tG g;\n\t\trep(i,3)if(intersectSS(l[i],l[(i+1)%3])){\n\t\t\tg.pb(crosspointSS(l[i],l[(i+1)%3]));\n\t\t}\n\t\tif(g.size()!=3){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble ar=area(g);\n\t\tif(ar<100000)cout<<\"syo-kichi\"<<endl;\n\t\telse if(ar<1000000)cout<<\"kichi\"<<endl;\n\t\telse if(ar<1900000)cout<<\"chu-kichi\"<<endl;\n\t\telse cout<<\"dai-kichi\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define EPS (1e-10)\n\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point (double x=0,double y=0): x(x),y(y){}\n    \n    Point operator + (Point p)\t{return Point( x+p.x,y+p.y );\t}\n    Point operator - (Point p)\t{return Point( x-p.x,y-p.y );\t}\n    Point operator * (double a)\t{return Point( a*x,a*y );\t\t}\n    Point operator / (double a)\t{return Point( x/a,y/a );\t\t}\n    \n    double abs(){ return sqrt(norm());}\n    double norm(){ return x*x + y*y; }\n    \n    bool operator < ( const Point &p ) const{\n        return x!= p.x ? x<p.x : y<p.y;\n    }\n    \n    bool operator == ( const Point &p ) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\ndouble cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\n\nstruct Segment{\n    Point p1,p2;\n};\n\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2-s2.p1;\n    double d1=abs(cross(base, s1.p1-s2.p1));\n    double d2=abs(cross(base, s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)  return 1;\n    if(cross(a,b)<-EPS) return -1;\n    if(dot(a,b)<-EPS)   return 2;\n    if(a.norm()<b.norm())return -2;\n    \n    return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4) <=0 &&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2) <=0 );\n}\n\n\nbool isCross(Segment s1,Segment s2){\n    return intersect(s1.p1, s1.p2,s2.p1,s2.p2);\n}\n\nint main(){\n    \n    int a,b,c,d;\n    while(cin>>a>>b>>c>>d){\n        int flag=false;\n        if(a==0 && b==0 && c==0 && d==0)break;\n        \n        Point p[6];\n        p[0]=Point(a,b);\n        p[1]=Point(c,d);\n        rep(i,4){\n            int m,n;\n            cin>>m>>n;\n            p[2+i]=Point(m,n);\n        }\n        //end input\n        \n        Segment seg[3];\n        rep(i,3){\n            seg[i].p1=p[i*2];\n            seg[i].p2=p[i*2+1];\n        }\n        \n        Point cr[3];\n        rep(i,3){\n            if( !isCross( seg[i],seg[ (i+1)%3 ] ) )flag=true;\n            else{\n                cr[i]=getCrossPoint(seg[i],seg[ (i+1)%3 ]);\n                if( isnan(cr[i].x) || isnan(cr[i].y) )flag=true;\n            }\n        }\n        if( cr[0]==cr[1] && cr[1]==cr[2] )flag=true;\n        \n        if(flag)cout<<\"kyo\"<<endl;\n        else{\n            double ans=abs(  ( cr[0].x * cr[1].y + cr[1].x*cr[2].y + cr[2].x*cr[0].y -cr[0].y*cr[1].x - cr[2].y*cr[0].x )/2  );\n            if(ans<100000)cout<<\"syo-kichi\"<<endl;\n            else if(ans<1000000)cout<<\"kichi\"<<endl;\n            else if(ans<1900000)cout<<\"chu-kichi\"<<endl;\n            else cout<<\"dai-kichi\"<<endl;\n            \n        }\n        \n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\nstatic const double EPS = 1e-12;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble getArea(P a, P b , P c){\n\t\tb-=a, c-=a;\n\t\treturn fabs( b.real() * c.imag() - c.real() * b.imag() ) / 2.0; \n}\nint main(){\n\tdouble a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a || b || c || d){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tdouble ret = 0;\n\t\t\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tret = getArea( crosspoint(one,two) , crosspoint(two,three) , crosspoint(one,three) );\n\t\t}\n\t\tif(ret >= 1900000){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if(ret >= 1000000){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if(ret >= 100000){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret > 0){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const long double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst long double INF = 1e12;\ntypedef complex<long double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\nlong double cross(const P& a, const P& b) {return imag(conj(a)*b);}\nlong double dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\nstruct C {P p; long double r;C(const P &p, long double r) : p(p), r(r) { }};\nint ccw(P a, P b, P c) {b -= a; c -= a;if (cross(b, c) > 0)   return +1;if (cross(b, c) < 0)   return -1;if (dot(b, c) < 0) return +2;if (norm(b) < norm(c)) return -2;return 0;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nlong double area2(const polygon& P) {long double A = 0;for (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));return A;}\nP crosspoint(const L &l, const L &m) {long double A = cross(l[1] - l[0], m[1] - m[0]);long double B = cross(l[1] - l[0], l[1] - m[0]);if (abs(A) < EPS && abs(B) < EPS) return m[0];return m[0] + B / A * (m[1] - m[0]);}\n\nint main(){\n\tlong double a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a+b+c+d != 0){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tlong double ret = 0;\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tG npts;\n\t\t\tnpts.push_back( crosspoint(one,two) );\n\t\t\tnpts.push_back( crosspoint(two,three) );\n\t\t\tnpts.push_back( crosspoint(one,three) );\n\t\t\tsort(all(npts));\n\t\t\tret = area2(npts);\n\t\t}\n\t\tif(ret >= 1900000+EPS){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if(ret >= 1000000+EPS){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if(ret >= 100000+EPS){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret >= EPS){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-9\n\nstruct Point{\n  double x,y;\n  Point(double x = 0.0, double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x,y-p.y); }\n  Point operator * (double a){ return Point(x*a,y*a); }\n  Point operator / (double a){ return Point(x/a,y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nstruct Segment{\n  Vector p1,p2;\n  Segment(){}\n  Segment(Vector p1,Vector p2) : p1(p1),p2(p2) {}\n};\n\nbool intersectSS(const Segment &s,const Segment &t){\n  return (ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0) && \n         (ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0);\n}\n\nPoint getCrossPoint(Segment s,Segment t){\n  Vector b = t.p2 - t.p1;\n  double d1 = abs(cross(b,s.p1-t.p1));\n  double d2 = abs(cross(b,s.p2-t.p1));\n  double d = d1 / (d1 + d2);\n  return s.p1+(s.p2-s.p1)*d;\n}\n\ndouble getArea(Point a,Point b,Point c){\n  return abs(a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2;\n}\n\nSegment s[3];\nvoid solve(){\n  Point p1 = getCrossPoint(s[0],s[1]);\n  Point p2 = getCrossPoint(s[1],s[2]);\n  Point p3 = getCrossPoint(s[2],s[0]);\n\n  double S = getArea(p1,p2,p3);\n  if(S >= 1900000){\n    cout << \"dai-kichi\" << endl;\n  }else if(S >= 1000000){\n    cout << \"chu-kichi\" << endl;\n  }else if(S >= 100000){\n    cout << \"kichi\" << endl;\n  }else{\n    cout << \"syo-kichi\" << endl;\n  }\n}\n\nint main(){\n  while(true){\n    cin >> s[0].p1.x >> s[0].p1.y >> s[0].p2.x >> s[0].p2.y;\n    if(!s[0].p1.x && !s[0].p1.y && !s[0].p2.x && !s[0].p2.y) break;\n\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> s[i+1].p1.x >> s[i+1].p1.y >> s[i+1].p2.x >> s[i+1].p2.y;\n    }\n    if(intersectSS(s[0],s[1]) && intersectSS(s[1],s[2]) && intersectSS(s[2],s[0])){\n      solve();\n    }else{\n      cout << \"kyo\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define EPS (1e-9)\n\nusing namespace std;\n\nbool eq(double a, double b)\n{\n\treturn (fabs(b - a) <= EPS);\n}\n\nbool getP(int x1, int y1, int x2, int y2, int p1, int q1, int p2, int q2, double *r1, double *r2)\n{\n\tint D = (x2 - x1) * (q2 - q1) - (y2 - y1) * (p2 - p1);\n\tif (D == 0) return (false);\n\t\n\tdouble r, s;\n\t\n\tr = ((q2 - q1) * (p1 - x1) - (p2 - p1) * (q1 - y1)) / (double)D;\n\ts = ((y2 - y1) * (p1 - x1) - (y2 - y1) * (q1 - y1)) / (double)D;\n\t//printf(\"%lf %lf\\n\", r, s);\n\tif (0 <= r + EPS && r - EPS <= 1 &&\n\t\t0 <= s + EPS && s - EPS <= 1){\n\t\t*r1 = x1 + r * (x2 - x1);\n\t\t*r2 = y1 + r * (y2 - y1);\n\t\treturn (true);\n\t}\n\t\n\treturn (false);\n}\n\nint main()\n{\n\tint x1[3], y1[3], x2[3], y2[3];\n\tdouble x3[3], y3[3];\n\t\n\twhile (1){\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tscanf(\"%d %d %d %d\", x1 + i, y1 + i, x2 + i, y2 + i);\n\t\t\tif (x1[i] == 0 && x2[i] == 0 && y1[i] == 0 && y2[i] == 0) return (0);\n\t\t}\n\t\t\n\t\tint k = 0;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\t\tif (!getP(x1[i], y1[i], x2[i], y2[i],\n\t\t\t\t\t\t  x1[j], y1[j], x2[j], y2[j],\n\t\t\t\t\t\t  &x3[k], &y3[k])){\n\t\t\t\t\t\t  printf(\"kyo\\n\");\n\t\t\t\t\t\t  goto ng;\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 3; i++) for (int j = i + 1; j < 3; j++) if (eq(x3[i], x3[j]) && eq(y3[i], y3[j])){\n\t\t\tprintf(\"kyo\\n\"); goto ng;\n\t\t}\n\t\tx3[0] -= x3[2]; x3[1] -= x3[2];\n\t\ty3[0] -= y3[2]; y3[1] -= y3[2];\n\t\t\n\t\tdouble S;\n\t\t\n\t\tS = 0.5 * fabs(x3[0] * y3[1] - y3[0] * x3[1]);\n\t\t\n\t\tif (S + EPS >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (S + EPS >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (S + EPS >= 100000) printf(\"kichi\\n\");\n\t\telse if (S + EPS > 0) printf(\"syo-kichi\\n\");\n\t\telse printf(\"kyo\\n\");\n\t\t\n\t\tng:;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\ndouble cross(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4) {\n\tdouble m;\n\tm=(x4-x3)*(y2-y1)-(x2-x1)*(y4-y3);\n\tif (m==0) return -1;\n\treturn ((x1-x3)*(y4-y3)-(x4-x3)*(y1-y3))/m;\n }\n\nint main() {\n  double a,s,sx[3],sy[3],ex[3],ey[3],cx[3],cy[3],hx,lx,hy,ly;\n  int i,k;\n  while(true) {\n\tlx=ly=9999999; hx=hy=-lx;  \n   for (i=0;i<3;i++) {\n\t      cin >> sx[i] >> sy[i] >> ex[i] >> ey[i];\n\t      if (sx[i]==0 &&  sy[i]==0 && ex[i]==0 && ey[i]==0) return 0; \n\t      }\n\t   for (i=0;i<3;i++) {\n\t\tk=(i+1) % 3;\n\t\ts=cross(sx[i],sy[i],ex[i],ey[i],sx[k],sy[k],ex[k],ey[k]);\n\t\tcx[i]=sx[i]+s*(ex[i]-sx[i]); cy[i]=sy[i]+s*(ey[i]-sy[i]);\n\t\tif (s<0 || s>1 || (cx[i]<sx[k] && cx[i]<ex[k]) || (cx[i]>sx[k] && cx[i]>ex[k]) || (cy[i]<sy[k] && cy[i]<ey[k]) || (cy[i]>sy[k] && cy[i]>ey[k])) break;\n\t\thx=hx<cx[i] ? cx[i]:hx; lx=lx>cx[i] ? cx[i]:lx;\n\t\thy=hy<cy[i] ? cy[i]:hy; ly=ly>cy[i] ? cy[i]:ly;\n\t}\n\tif (i!=3) { cout << \"kyo\" << endl; continue;}\n\tfor (s=0,i=0;i<3;i++) s+=fabs(cx[i]-cx[(i+1) % 3])*fabs(cy[i]-cy[(i+1) % 3]);\n\ta=(hx-lx)*(hy-ly)-s/2;\n\tcout << \"memseki= \" << a << endl;\n\tif (a>=1900000) cout << \"dai-kichi\"; else if (a>=1000000) cout << \"chu-kichi\";\n\telse if (a>=100000) cout << \"kichi\"; else if (a>0) cout << \"syo-kichi\";\n\telse cout << \"kyo\";\n\tcout << endl; \n } \n  return 0;\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(true)\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(x1+y1+x2+y2 == 0)\n\tbreak;\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n    \n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint sig(double r){return (r<-EPS)?-1:(r>EPS)?1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y) : x(x),y(y){}\n\tPt operator+(const Pt &a)const{return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt &a)const{return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt &a)const{return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt &a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt &a)const{return x*a.y-y*a.x;}\n\tbool operator<(const Pt &a)const{return (x!=a.x)?(x<a.x):(y<a.y);}\n\tbool operator==(const Pt &a)const{return (sig(x-a.x)==0&&sig(y-a.y)==0);}\n};\nostream &operator<<(ostream &os,const Pt &a){os<<\"(\"<<a.x<<\", \"<<a.y<<\")\";return os;}\ndouble tri(Pt a,Pt b,Pt c){return (b-a).det(c-a);}\n\nPt proj(Pt a,Pt b){return a*a.dot(b)/a.abs2();}\nPt perp(Pt a,Pt b,Pt c){return a+proj(b-a,c-a);}\nPt refl(Pt a,Pt b,Pt c){return perp(a,b,c)*2-c;}\n\nint iSP(Pt a,Pt b,Pt c){\n\tint s=sig((b-a).det(c-a));\n\tif(s)return s;\n\tif(sig((b-a).dot(c-a))<0)return -2;\n\tif(sig((a-b).dot(c-b))<0)return +2;\n\treturn 0;\n}\n\nint iLL(Pt a,Pt b,Pt c,Pt d){\n\tif(sig((b-a).det(d-c)))return 1;\n\tif(sig((b-a).det(c-a)))return 0;\n\treturn -1;\n}\n\nbool iSS(Pt a,Pt b,Pt c,Pt d){\n\treturn (iSP(a,b,c)*iSP(a,b,d)<=0&&iSP(c,d,a)*iSP(c,d,b)<=0);\n}\n\nPt pLL(Pt a,Pt b,Pt c, Pt d){\n\tb=b-a;d=d-c;\n\treturn a+b*(c-a).det(d)/b.det(d);\n}\n\nint main() {\n\tPt p[3][2];\n\tIL{\n\t\tcin>>p[0][0].x>>p[0][0].y;\n\t\tcin>>p[0][1].x>>p[0][1].y;\n\t\tif(p[0][0].abs()+p[0][1].abs()==0)break;\n\t\tcin>>p[1][0].x>>p[1][0].y;\n\t\tcin>>p[1][1].x>>p[1][1].y;\n\t\tcin>>p[2][0].x>>p[2][0].y;\n\t\tcin>>p[2][1].x>>p[2][1].y;\n\t\tbool ok=true;\n\t\trep(i,3){\n\t\t\tif(!iSS(p[i][0],p[i][1],p[(i+1)%3][0],p[(i+1)%3][1])\n\t\t\t\t||iLL(p[i][0],p[i][1],p[(i+1)%3][0],p[(i+1)%3][1])<1){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\\n\";\n\t\t}else{\n\t\t\tPt a,b,c;\n\t\t\ta=pLL(p[0][0],p[0][1],p[1][0],p[1][1]);\n\t\t\tb=pLL(p[1][0],p[1][1],p[2][0],p[2][1]);\n\t\t\tc=pLL(p[2][0],p[2][1],p[0][0],p[0][1]);\n//debug<<a<<endl;\n//debug<<b<<endl;\n//debug<<c<<endl;\n\t\t\tdouble s=abs(tri(a,b,c))/2;\n//debug<<s<<endl;\n\t\t\tif(s>=1900000){\n\t\t\t\tcout<<\"dai-kichi\\n\";\n\t\t\t}else if(s>=1000000){\n\t\t\t\tcout<<\"chu-kichi\\n\";\n\t\t\t}else if(s>=100000){\n\t\t\t\tcout<<\"kichi\\n\";\n\t\t\t}else if(s>0){\n\t\t\t\tcout<<\"syo-kichi\\n\";\n\t\t\t}else{\n\t\t\t\tcout<<\"kyo\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nbool isequal(const P& a, const P& b)\n{\n\treturn a.real()+EPS > b.real() && a.real() < b.real()+EPS &&\n\t\t   a.imag()+EPS > b.imag() && a.imag() < b.imag()+EPS;\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS; // non-parallel\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main()\n{\n\tint x1,y1,x2,y2;\n\twhile(scanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2), (x1||y1||x2||y2))\n\t{\n\t\tvector<L> Lines;\n\t\tvector<P> xp;\n\t\tLines.push_back(L(P(x1,y1),P(x2,y2)));\n\t\tfor(int i=0; i<2; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2);\n\t\t\tLines.push_back(L(P(x1,y1),P(x2,y2)));\n\t\t}\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\tfor(int j=i+1; j<3; j++)\n\t\t{\n\t\t\tif(!intersectLL(Lines[i], Lines[j])) g=false;\n\t\t\tif(!intersectSS(Lines[i], Lines[j])) g=false;\n\t\t\t\n\t\t\tif(g)\n\t\t\t{\n\t\t\t\txp.push_back(crosspoint(Lines[i], Lines[j]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<xp.size(); i++)\n\t\tfor(int j=i+1; j<xp.size(); j++)\n\t\t{\n\t\t\tif(isequal(xp[i], xp[j])) g=false;\n\t\t}\n\t\t\n\t\tif(!g)\n\t\t{\n\t\t\tputs(\"kyo\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt=0;\n\t\tdouble ls[3];\n\t\tfor(int i=0; i<xp.size(); i++)\n\t\tfor(int j=i+1; j<xp.size(); j++)\n\t\t{\n\t\t\tls[cnt]=sqrt((xp[i].real()-xp[j].real())*(xp[i].real()-xp[j].real())+(xp[i].imag()-xp[j].imag())*(xp[i].imag()-xp[j].imag()));\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tdouble area=0.5*((xp[1].real()-xp[0].real())*(xp[2].imag()-xp[0].imag())-(xp[2].real()-xp[1].real())*(xp[1].imag()-xp[0].imag()));\n\t\tif(area < 100000) puts(\"syo-kichi\");\n\t\telse if(area < 1000000) puts(\"kichi\");\n\t\telse if(area < 1900000) puts(\"chu-kichi\");\n\t\telse\tputs(\"dai-kichi\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nPoint prj(const Segment& a, const Point& b) { return a.p1 + (a.p2 - a.p1) * dot(b - a.p1, a.p2 - a.p1) / norm(a.p2 - a.p1); }\nPoint rfl(const Segment& a, const Point& b) { return b + (prj(a, b) - b) * 2.0L; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint crp(Segment a, Segment b) {\n\tPoint c = b.p2 - b.p1;\n\tlong double d1 = abs(crs(c, a.p1 - b.p1));\n\tlong double d2 = abs(crs(c, a.p2 - b.p1));\n\treturn a.p1 + (a.p2 - a.p1) * (d1 / (d1 + d2));\n}\nlong double area(vector<Point> v) {\n\tlong double ret = 0.0L;\n\tfor (int i = 0; i < v.size(); i++) ret += crs(v[i], v[(i + 1) % v.size()]);\n\treturn ret / 2;\n}\nSegment s1, s2, s3;\nint main() {\n\twhile (cin >> s1.p1.px >> s1.p1.py >> s1.p2.px >> s1.p2.py >> s2.p1.px >> s2.p1.py >> s2.p2.px >> s2.p2.py >> s3.p1.px >> s3.p1.py >> s3.p2.px >> s3.p2.py) {\n\t\tif (!its(s1, s2) || !its(s2, s3) || !its(s3, s1)) puts(\"kyo\");\n\t\telse {\n\t\t\tPoint p1 = crp(s1, s2), p2 = crp(s2, s3), p3 = crp(s3, s1);\n\t\t\tlong double a = area({ p1, p2, p3 });\n\t\t\tif (a > 1900000.0L) puts(\"dai-kichi\");\n\t\t\telse if (a > 1000000.0L) puts(\"chu-kichi\");\n\t\t\telse if (a > 100000.0L) puts(\"kichi\");\n\t\t\telse if (a > 0.000001L) puts(\"sho-kichi\");\n\t\t\telse puts(\"kyo\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\n#include<complex>\n#define EPS (1e-10)\n\nusing namespace std;\n\nusing std::complex;\ntypedef complex<double> P;\n\nstatic inline bool eq(const P &a, const P &b){\n  return abs(a-b) < EPS;\n}\n\nstatic inline double inp(const P &a, const P &b){\n  return (conj(a)*b).real();\n}\n\nstatic inline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\n\nstruct S{\n  P p1;\n  P p2;\n  S(P p,P q) : p1(p), p2(q) {}\n  S(){}\n};\n\nint ccw(P p0, P p1, P p2){\n  P d1 = p1-p0;\n  P d2 = p2-p0;\n  double dx1 = d1.real(), dx2 = d2.real();\n  double dy1 = d1.imag(), dy2 = d2.imag();\n\n  if(dx1*dy2 > dy1*dx2) return  1;\n  if(dx1*dy2 < dy1*dx2) return -1;\n  if((dx1*dx2 < 0) || (dy1*dy2 < 0)) return -1;\n  if((dx1*dx1+dy1*dy1) < (dx2*dx2+dy2*dy2)) return 1;\n  return 0;\n}\n\nbool intersect(const S &s1, const S &s2){\n  return ((ccw(s1.p1, s1.p2, s2.p1)\n\t   *ccw(s1.p1, s1.p2, s2.p2)) <= 0)\n    &&((ccw(s2.p1, s2.p2, s1.p1)\n\t*ccw(s2.p1, s2.p2, s1.p2)) <= 0);\n}\n\nclass Line{\npublic:\n  P p;\n  P d;\n  Line(){}\n  Line(P pos, P dir){p=pos; d=dir/abs(dir);}\n};\n\nLine LineDirect(P pos, P dir){\n  return Line(pos, dir);\n}\n\nLine LinePos(P p1, P p2){\n  return Line(p1, p2-p1);\n}\n\nP crossPoint(const Line &l1, const Line &l2){\n  double num = outp(l2.d, l2.p-l1.p);\n  double denom = outp(l2.d, l1.d);\n  return P(l1.p + l1.d * num/denom);\n}\n\n\nint main(){\n  int x1, y1, x2, y2;\n  while(scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2), (x1 | x2 | y1 | y2)){\n    S s[3];\n    vector<P> p;\n\n    s[0] = S(P(x1, y1), P(x2, y2));\n    REP(i,2){\n      scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n      s[i + 1] = S(P(x1, y1), P(x2, y2));\n    }\n\n    for(int i = 0; i < 3; i++){\n      for(int j = i + 1; j < 3; j++){\n\tP dir1 = s[i].p1 - s[i].p2;\n\tP dir2 = s[j].p1 - s[j].p2;\n\n\tP tmp = dir1 / dir2;\n\tif(std::abs(tmp.imag()) > EPS && intersect(s[i], s[j])){\n\t  Line l1 = LinePos(s[i].p1, s[i].p2);\n\t  Line l2 = LinePos(s[j].p1, s[j].p2);\n\t  p.push_back(crossPoint(l1, l2));\n\t}\n      }\n    }\n\n    const char *un[] = {\n      \"dai-kichi\",\n      \"chu-kichi\",\n      \"kichi\",\n      \"syo-kichi\",\n      \"kyo\"\n    };\n    int ans = 4;\n\n    if(p.size() == 3){\n      P p1 = p[2] - p[0];\n      P p2 = p[1] - p[0];\n\n      double sz = std::abs(outp(p1, p2)) / 2.0;\n\n      if(sz + EPS > 1900000){\n\tans = 0;\n      }else if(sz + EPS > 1000000){\n\tans = 1;\n      }else if(sz + EPS > 100000){\n\tans = 2;\n      }else if(sz > EPS){\n\tans = 3;\n      }\n    }\n\n    puts(un[ans]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n \n#define EPS (1e-9)\n \nusing namespace std;\n \nbool eq(double a, double b)\n{\n    return (fabs(b - a) <= EPS);\n}\n \nbool getP(int x1, int y1, int x2, int y2, int p1, int q1, int p2, int q2, double *r1, double *r2)\n{\n    int D = (x2 - x1) * (q2 - q1) - (y2 - y1) * (p2 - p1);\n    if (D == 0) return (false);\n     \n    double r, s;\n     \n    r = ((q2 - q1) * (p1 - x1) - (p2 - p1) * (q1 - y1)) / (double)D;\n    s = ((y2 - y1) * (p1 - x1) - (y2 - y1) * (q1 - y1)) / (double)D;\n    //printf(\"%lf %lf\\n\", r, s);\n    if (0 <= r + EPS && r - EPS <= 1 &&\n        0 <= s + EPS && s - EPS <= 1){\n        *r1 = x1 + r * (x2 - x1);\n        *r2 = y1 + r * (y2 - y1);\n        return (true);\n    }\n     \n    return (false);\n}\n \nint main()\n{\n    int x1[3], y1[3], x2[3], y2[3];\n    double x3[3], y3[3];\n     \n    while (1){\n        for (int i = 0; i < 3; i++){\n            scanf(\"%d %d %d %d\", x1 + i, y1 + i, x2 + i, y2 + i);\n            if (x1[i] == 0 && x2[i] == 0 && y1[i] == 0 && y2[i] == 0) return (0);\n        }\n         \n        int k = 0;\n        for (int i = 0; i < 3; i++){\n            for (int j = i + 1; j < 3; j++){\n                if (!getP(x1[i], y1[i], x2[i], y2[i],\n                          x1[j], y1[j], x2[j], y2[j],\n                          &x3[k], &y3[k])){\n                          printf(\"kyo\\n\");\n                          goto ng;\n                }\n                k++;\n            }\n        }\n         \n        for (int i = 0; i < 3; i++) for (int j = i + 1; j < 3; j++) if (eq(x3[i], x3[j]) && eq(y3[i], y3[j])){\n            printf(\"kyo\\n\"); goto ng;\n        }\n        x3[0] -= x3[2]; x3[1] -= x3[2];\n        y3[0] -= y3[2]; y3[1] -= y3[2];\n         \n        double S;\n         \n        S = 0.5 * fabs(x3[0] * y3[1] - y3[0] * x3[1]);\n         \n        if (eq(S, 0)) printf(\"kyo\\n\");\n        else if (S + EPS >= 1900000) printf(\"dai-kichi\\n\");\n        else if (S + EPS >= 1000000) printf(\"chu-kichi\\n\");\n        else if (S + EPS >= 100000) printf(\"kichi\\n\");\n        else printf(\"syo-kichi\\n\");\n         \n        ng:;\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <complex>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nbool on_line(const P& a, const L& l){\n  return dot(l[0]-a,l[1]-a)<EPS;\n}\n\nP crosspoint(const L &l, const L &m) throw(bool){\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) throw(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint x1,y1,x2,y2;\n\tfor(;~scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2),x1||y1||x2||y2;){\n\t\ttry{\n\t\tL A(P(x1,y1),P(x2,y2));\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL B(P(x1,y1),P(x2,y2));\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL C(P(x1,y1),P(x2,y2));\n\t\tP a=crosspoint(A,B),b=crosspoint(B,C),c=crosspoint(C,A);\n\t\tif(!on_line(a,A)||!on_line(a,B)||!on_line(b,B)||!on_line(b,C)||!on_line(c,C)||!on_line(c,A)){puts(\"kyo\");continue;}\n\t\tdouble s=abs(cross(a,b)+cross(b,c)+cross(c,a));\n\t\tif(s<EPS)puts(\"kyo\");\n\t\telse if(s<100000)puts(\"syo-kichi\");\n\t\telse if(s<1000000)puts(\"kichi\");\n\t\telse if(s<1900000)puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t\t}catch(bool e){puts(\"kyo\");}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/////////////////////???Library???/////////////////////////\n\nint xx1, yy1, xx2, yy2;\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tif (xx1 == 0 && yy1 == 0 && xx2 == 0 && yy2 == 0) break;\n\t\t\n\t\tSegment s1(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s2(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s3(Point(xx2, yy2), Point(xx1, yy1));\n\n\t\tif (isParallel(s1, s2) || isParallel(s1, s3) || isParallel(s2, s3))\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint kousa_num = 0;\n\t\tif (intersect(s1, s2)) kousa_num++;\n\t\tif (intersect(s1, s3)) kousa_num++;\n\t\tif (intersect(s2, s3)) kousa_num++;\n\t\t//printf(\"kousa_num = %d\\n\", kousa_num);\n\t\tif (kousa_num <= 2)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tPoint p1 = getCrossPoint(s1, s2);\n\t\tPoint p2 = getCrossPoint(s1, s3);\n\t\tPoint p3 = getCrossPoint(s2, s3);\n\n\t\t/*\n\t\tprintf(\"p1 = (%f, %f)\\n\", p1.x, p1.y);\n\t\tprintf(\"p2 = (%f, %f)\\n\", p2.x, p2.y);\n\t\tprintf(\"p3 = (%f, %f)\\n\", p3.x, p3.y);\n\t\t*/\n\n\t\tif (p1 == p2 && p2 == p3)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVector v12 = p2 - p1;\n\t\tVector v13 = p3 - p1;\n\n\t\tdouble ans = cross(v12, v13) / 2.0f;\n\t\tif (ans >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (ans >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (ans >= 100000) printf(\"kichi\");\n\t\telse printf(\"syo-kichi\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += abs(cross(ps[i], ps[(i+1) % ps.size()]));\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=abs(area(v));\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=0)cout<<\"syo-kichi\"<<endl;\n      else exit(1);\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\ntypedef complex<double> Point;\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\ntypedef Line Segment;\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\ndouble CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tdouble sign=Signum(Cross(d1,d2));\n\tif(sign)\n\t\treturn sign;\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\n\treturn 0;\n}\n\n// 直線と線分が重なるとき，線分の端点が直線上にあるときもtrue\nbool IntersectLS(Line a,Segment b)\n{\n\treturn CCW(a.pos,a.pos+a.dir,b.pos)*CCW(a.pos,a.pos+a.dir,b.pos+b.dir)<=0;\n}\nbool IntersectSS(Segment a,Segment b)\n{\n\treturn IntersectLS(a,b) && IntersectLS(b,a);\n}\n\n// aとbが平行でないことが前提\nPoint IntersectPoint(Line a,Line b)\n{\n\treturn a.pos+a.dir*Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir);\n}\n\nconst char* solve(Line* ls)\n{\n\tPoint ps[3];\n\tfor(int i=0;i<3;i++){\n\t\tLine l1=ls[i],l2=ls[(i+1)%3];\n\t\tif(Signum(Cross(l1.dir,l2.dir))==0)\n\t\t\treturn \"kyo\";\n\t\tif(!IntersectSS(l1,l2))\n\t\t\treturn \"kyo\";\n\t\tps[i]=IntersectPoint(l1,l2);\n\t}\n\t\n\tdouble area=abs(Cross(ps[1]-ps[0],ps[2]-ps[0]))/2;\n\tif(area<EPS)\n\t\treturn \"kyo\";\n\tif(area<1.0e5-EPS)\n\t\treturn \"syo-kichi\";\n\tif(area<1.0e6-EPS)\n\t\treturn \"kichi\";\n\tif(area<1.9e6-EPS)\n\t\treturn \"chu-kichi\";\n\treturn \"dai-kichi\";\n}\n\nint main()\n{\n\tfor(;;){\n\t\tLine ls[3];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint x1,y1,x2,y2; scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tls[i]=Line(Point(x1,y1),Point(x2-x1,y2-y1));\n\t\t}\n\t\tif(feof(stdin))\n\t\t\tbreak;\n\t\tputs(solve(ls));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-9\n\nstruct Point{\n  double x,y;\n  Point(double x = 0.0, double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x,y-p.y); }\n  Point operator * (double a){ return Point(x*a,y*a); }\n  Point operator / (double a){ return Point(x/a,y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nstruct Segment{\n  Vector p1,p2;\n  Segment(){}\n  Segment(Vector p1,Vector p2) : p1(p1),p2(p2) {}\n};\n\nbool intersectSS(const Segment &s,const Segment &t){\n  return (ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0) && \n         (ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0);\n}\n\nPoint getCrossPoint(Segment s,Segment t){\n  Vector b = t.p2 - t.p1;\n  double d1 = abs(cross(b,s.p1-t.p1));\n  double d2 = abs(cross(b,s.p2-t.p1));\n  double d = d1 / (d1 + d2);\n  return s.p1+(s.p2-s.p1)*d;\n}\n\ndouble heron(Point p1,Point p2,Point p3){\n  double a = sqrt(pow(p1.x-p2.x,2.) + pow(p1.y-p2.y,2.));\n  double b = sqrt(pow(p1.x-p3.x,2.) + pow(p1.y-p3.y,2.));\n  double c = sqrt(pow(p2.x-p3.x,2.) + pow(p2.y-p3.y,2.));\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nSegment s[3];\nvoid solve(){\n  Point p1 = getCrossPoint(s[0],s[1]);\n  Point p2 = getCrossPoint(s[1],s[2]);\n  Point p3 = getCrossPoint(s[2],s[0]);\n\n  double S = heron(p1,p2,p3)+EPS;\n  if(S >= 1900000){\n    cout << \"dai-kichi\" << endl;\n  }else if(S >= 1000000){\n    cout << \"chu-kichi\" << endl;\n  }else if(S >= 100000){\n    cout << \"kichi\" << endl;\n  }else{\n    cout << \"syo-kichi\" << endl;\n  }\n}\n\nint main(){\n  while(true){\n    cin >> s[0].p1.x >> s[0].p1.y >> s[0].p2.x >> s[0].p2.y;\n    if(!s[0].p1.x && !s[0].p1.y && !s[0].p2.x && !s[0].p2.y) break;\n\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> s[i+1].p1.x >> s[i+1].p1.y >> s[i+1].p2.x >> s[i+1].p2.y;\n    }\n    if(intersectSS(s[0],s[1]) && intersectSS(s[1],s[2]) && intersectSS(s[2],s[0])){\n      solve();\n    }else{\n      cout << \"kyo\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0-EPS)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0-EPS)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0-EPS)cout<<\"kichi\"<<endl;\n    else if(area>0.0+EPS)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <complex>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nbool on_line(const P& a, const L& l){\n  return dot(l[0]-a,l[1]-a)<EPS;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint x1,y1,x2,y2;\n\tfor(;~scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2),x1||y1||x2||y2;){\n\t\tL A(P(x1,y1),P(x2,y2));\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL B(P(x1,y1),P(x2,y2));\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tL C(P(x1,y1),P(x2,y2));\n\t\tP a=crosspoint(A,B),b=crosspoint(B,C),c=crosspoint(C,A);\n\t\tif(!on_line(a,A)||!on_line(a,B)||!on_line(b,B)||!on_line(b,C)||!on_line(c,C)||!on_line(c,A)){puts(\"kyo\");continue;}\n\t\tdouble s=abs(cross(a,b)+cross(b,c)+cross(c,a));\n\t\tif(s<EPS)puts(\"kyo\");\n\t\telse if(s<100000)puts(\"syo-kichi\");\n\t\telse if(s<1000000)puts(\"kichi\");\n\t\telse if(s<1900000)puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    Point p[3], q[3], x[3];\n    double S;\n\t\n    while (1){\n        for (int i = 0; i < 3; i++){\n\t\t\tint x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\t\n            if (i == 0 && x1 == 0 && x2 == 0 && y1 == 0 && y2 == 0) return (0);\n\t\t\t\n\t\t\tp[i] = Point(x1, y1); q[i] = Point(x2, y2);\n        }\n\t\t\n\t\tint k = 0;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\t\tif (!isIntersect(p[i], q[i], p[j], q[j])){\n\t\t\t\t\tprintf(\"kyo\\n\");\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tx[k++] = interPointS(p[i], q[i], p[j], q[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (x[0] == x[1] || x[1] == x[2] || x[0] == x[2]){\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tgoto next;\n\t\t}\n\t\t\n\t\tS = area(x[0], x[1], x[2]);\n\t\t\n\t\tif (S >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (S >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (S >= 100000) printf(\"kichi\\n\");\n\t\telse printf(\"syo-kichi\\n\");\n\t\t\n\t\tnext:;\n\t}\t\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint sig(double r){return (r<-EPS)?-1:(r>EPS)?1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y) : x(x),y(y){}\n\tPt operator+(const Pt &a)const{return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt &a)const{return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt &a)const{return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt &a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt &a)const{return x*a.y-y*a.x;}\n\tbool operator<(const Pt &a)const{return (x!=a.x)?(x<a.x):(y<a.y);}\n\tbool operator==(const Pt &a)const{return (sig(x-a.x)==0&&sig(y-a.y)==0);}\n};\nostream &operator<<(ostream &os,const Pt &a){os<<\"(\"<<a.x<<\", \"<<a.y<<\")\";return os;}\ndouble tri(Pt a,Pt b,Pt c){return (b-a).det(c-a);}\n\nPt proj(Pt a,Pt b){return a*a.dot(b)/a.abs2();}\nPt perp(Pt a,Pt b,Pt c){return a+proj(b-a,c-a);}\nPt refl(Pt a,Pt b,Pt c){return perp(a,b,c)*2-c;}\n\nint iSP(Pt a,Pt b,Pt c){\n\tint s=sig((b-a).det(c-a));\n\tif(s)return s;\n\tif(sig((b-a).dot(c-a))<0)return -2;\n\tif(sig((a-b).dot(c-b))<0)return +2;\n\treturn 0;\n}\n\nbool iSS(Pt a,Pt b,Pt c,Pt d){\n\treturn (iSP(a,b,c)*iSP(a,b,d)<=0&&iSP(c,d,a)*iSP(c,d,b)<=0);\n}\n\nPt pLL(Pt a,Pt b,Pt c, Pt d){\n\tb=b-a;d=d-c;\n\treturn a+b*(c-a).det(d)/b.det(d);\n}\n\nint main() {\n\tPt p[3][2];\n\tIL{\n\t\tcin>>p[0][0].x>>p[0][0].y;\n\t\tcin>>p[0][1].x>>p[0][1].y;\n\t\tif(p[0][0].abs()+p[0][1].abs()==0)break;\n\t\tcin>>p[1][0].x>>p[1][0].y;\n\t\tcin>>p[1][1].x>>p[1][1].y;\n\t\tcin>>p[2][0].x>>p[2][0].y;\n\t\tcin>>p[2][1].x>>p[2][1].y;\n\t\tbool ok=true;\n\t\trep(i,3){\n\t\t\tif(!iSS(p[i][0],p[i][1],p[(i+1)%3][0],p[(i+1)%3][1])){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\\n\";\n\t\t}else{\n\t\t\tPt a,b,c;\n\t\t\ta=pLL(p[0][0],p[0][1],p[1][0],p[1][1]);\n\t\t\tb=pLL(p[1][0],p[1][1],p[2][0],p[2][1]);\n\t\t\tc=pLL(p[2][0],p[2][1],p[0][0],p[0][1]);\n//debug<<a<<endl;\n//debug<<b<<endl;\n//debug<<c<<endl;\n\t\t\tdouble s=fabs(tri(a,b,c))/2;\n//debug<<s<<endl;\n\t\t\tif(s>=1900000){\n\t\t\t\tcout<<\"dai-kichi\\n\";\n\t\t\t}else if(s>=1000000){\n\t\t\t\tcout<<\"chu-kichi\\n\";\n\t\t\t}else if(s>=100000){\n\t\t\t\tcout<<\"kichi\\n\";\n\t\t\t}else{\n\t\t\t\tcout<<\"syo-kichi\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/////////////////////???Library???/////////////////////////\n\nint xx1, yy1, xx2, yy2;\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tif (xx1 == 0 && yy1 == 0 && xx2 == 0 && yy2 == 0) break;\n\t\t\n\t\tSegment s1(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s2(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s3(Point(xx2, yy2), Point(xx1, yy1));\n\n\t\tif (isParallel(s1, s2) || isParallel(s1, s3) || isParallel(s2, s3))\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint kousa_num = 0;\n\t\tif (intersect(s1, s2)) kousa_num++;\n\t\tif (intersect(s1, s3)) kousa_num++;\n\t\tif (intersect(s2, s3)) kousa_num++;\n\t\t//printf(\"kousa_num = %d\\n\", kousa_num);\n\t\tif (kousa_num <= 1)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tPoint p1 = getCrossPoint(s1, s2);\n\t\tPoint p2 = getCrossPoint(s1, s3);\n\t\tPoint p3 = getCrossPoint(s2, s3);\n\n\t\t/*\n\t\tprintf(\"p1 = (%f, %f)\\n\", p1.x, p1.y);\n\t\tprintf(\"p2 = (%f, %f)\\n\", p2.x, p2.y);\n\t\tprintf(\"p3 = (%f, %f)\\n\", p3.x, p3.y);\n\t\t*/\n\n\t\tif (p1 == p2 && p2 == p3)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVector v12 = p2 - p1;\n\t\tVector v13 = p3 - p1;\n\n\t\tdouble ans = cross(v12, v13) / 2.0f;\n\t\tif (ans >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (ans >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (ans >= 100000) printf(\"kichi\");\n\t\telse printf(\"syo-kichi\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    c -= a;\n    b -= a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isIntersect(L s1, L s2){\n    return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n             ccw(s2.first,s2.second,s2.first) * ccw(s2.first,s2.second,s1.second) <= 0);\n}\n\nP crossPoint(L l, L m){\n    double A = cross(l.second - l.first, m.second - m.first);\n    double B = cross(l.second - l.first, l.second - m.first);\n    if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n    else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n    double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum / 2.0);\n}\n\nstring ans(vector<P> v){\n    double a = area(v);\n    if(a < EPS) return \"kyo\";\n    if(a < 100000.0-EPS) return \"syo-kichi\";\n    if(a < 1000000.0-EPS) return \"kichi\";\n    if(a < 1900000.0-EPS) return \"chu-kichi\";\n    return \"dai-kichi\";\n}\n\nint main(){\n    double x1,y1,x2,y2;\n    while(cin >> x1 >> y1 >> x2 >> y2 && (x1||y1||x2||y2)){\n        L v[3];\n        vector<P> p;\n        bool f = false;\n        v[0] = L(P(x1,y1),P(x2,y2));\n        for(int i=1;i<3;i++) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            v[i] = L(P(x1,y1),P(x2,y2));\n            if(!isIntersect(v[0],v[i])) f = true;\n            else p.push_back(crossPoint(v[0],v[i]));\n        }\n        if(!isIntersect(v[1],v[2])) f = true;\n        else p.push_back(crossPoint(v[1],v[2]));\n\n        if(!f){\n            for(int i=0;i<3;i++){\n                for(int j=i+1;j<3;j++){\n                    if(abs(p[i]-p[j]) < EPS) f = true;\n                }\n            }\n        }\n\n        if(f) cout << \"kyo\" << endl;\n        else cout << ans(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// Triangle and Circle\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool on_edge(const Point&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\n\nusing namespace std;\n\nint main() {\n    double x1, y1, x2, y2;\n    while(cin >> x1 >> y1 >> x2 >> y2, x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0) {\n        Segment s1(x1, y1, x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s2(x1, y1, x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s3(x1, y1, x2, y2);\n\n        if(s1.intersect(s2) && s2.intersect(s3) && s3.intersect(s1)) {\n            Polygon triangle;\n            triangle.add(s1.line().crosspoint(s2.line()));\n            triangle.add(s2.line().crosspoint(s3.line()));\n            triangle.add(s3.line().crosspoint(s1.line()));\n            if(triangle.area() >= 1900000.0) cout << \"dai-kichi\" << endl;\n            else if(triangle.area() >= 1000000.0) cout << \"chu-kichi\" << endl;\n            else if(triangle.area() >= 100000.0) cout << \"kichi\" << endl;\n            else cout << \"syo-kichi\" << endl;\n        } else {\n            cout << \"kyo\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py * d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nPoint prj(const Segment& a, const Point& b) { return a.p1 + (a.p2 - a.p1) * dot(b - a.p1, a.p2 - a.p1) / norm(a.p2 - a.p1); }\nPoint rfl(const Segment& a, const Point& b) { return b + (prj(a, b) - b) * 2.0L; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint crp(Segment a, Segment b) {\n\tlong double d1 = abs(crs(b.p2 - b.p1, a.p1 - b.p1));\n\tlong double d2 = abs(crs(b.p2 - b.p1, a.p2 - b.p1));\n\tPoint d = (a.p2 - a.p1);\n\tPoint r = a.p1 + (a.p2 - a.p1) * d1 / (d1 + d2);\n\treturn r;\n}\nlong double area(vector<Point> v) {\n\tlong double ret = 0.0L;\n\tfor (int i = 0; i < v.size(); i++) ret += crs(v[i], v[(i + 1) % v.size()]);\n\treturn ret / 2;\n}\nSegment s1, s2, s3;\nint main() {\n\twhile (cin >> s1.p1.px >> s1.p1.py >> s1.p2.px >> s1.p2.py >> s2.p1.px >> s2.p1.py >> s2.p2.px >> s2.p2.py >> s3.p1.px >> s3.p1.py >> s3.p2.px >> s3.p2.py) {\n\t\tif (!its(s1, s2) || !its(s2, s3) || !its(s3, s1)) puts(\"kyo\");\n\t\telse {\n\t\t\tPoint p1 = crp(s1, s2), p2 = crp(s2, s3), p3 = crp(s3, s1);\n\t\t\tlong double a = labs(area({ p1, p2, p3 }));\n\t\t\tif (a >= 1900000.0L) puts(\"dai-kichi\");\n\t\t\telse if (a >= 1000000.0L) puts(\"chu-kichi\");\n\t\t\telse if (a >= 100000.0L) puts(\"kichi\");\n\t\t\telse if (a >= 1e-10) puts(\"sho-kichi\");\n\t\t\telse puts(\"kyo\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double INF = 1e8;\nconst double eps = 1e-8;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) : x(x), y(y) {};\n};\n\nclass LineSeg {\npublic:\n    bool vertical;\n    double a, b; // y = a * x + b\n    Point p1, p2;\n    double min_x, max_x, min_y, max_y;\n    LineSeg(Point p1, Point p2) : p1(p1), p2(p2) {\n        if (p1.x == p2.x) {\n            vertical = true;\n            a = 0;\n            b = 0;\n        } else {\n            vertical = false;\n            a = (p2.y - p1.y) / (p2.x - p1.x);\n            b = p1.y - a * p1.x;\n        }\n        min_x = min(p1.x, p2.x); max_x = max(p1.x, p2.x);\n        min_y = min(p1.y, p2.y); max_y = max(p1.y, p2.y);\n    }\n};\n\ndouble eq(double x, double y) {\n    return abs(x - y) < eps;\n}\n\nbool isParallel(LineSeg &L1, LineSeg &L2) {\n    if (L1.vertical && L2.vertical) return true;\n    if (!L1.vertical && !L2.vertical && abs(L1.a - L2.a) < eps) return true;\n    return false;\n}\n\nPoint intersection(LineSeg L1, LineSeg L2) {\n    if (isParallel(L1, L2)) {\n        return Point(INF, INF);\n    }\n    double x, y;\n    if (L1.vertical) {\n        x = L1.min_x;\n        y = L2.a * x + L2.b;\n    } else if (L2.vertical) {\n        x = L2.min_x;\n        y = L1.a * x + L1.b;\n    } else {\n        x = (L2.b - L1.b) / (L1.a - L2.a);\n        y = L1.a * x + L1.b;\n    }\n    if (x < L1.min_x || L1.max_x < x || y < L1.min_y || L1.max_y < y ||\n        x < L2.min_x || L2.max_x < x || y < L2.min_y || L2.max_y < y) {\n        return Point(INF, INF);\n    }\n    return Point(x, y);\n}\n\ndouble areaOfTriangle(Point A, Point B, Point C) {\n    return abs((B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x)) / 2.0;\n}\n\nint main() {\n    int x1, y1, x2, y2;\n    while (cin >> x1 >> y1 >> x2 >> y2, (x1 || y1 || x2 || y2)) {\n\n        vector<LineSeg> L;\n        L.push_back( LineSeg(Point(x1,y1), Point(x2,y2)) );\n        for (int i=1; i<3; ++i) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            L.push_back( LineSeg(Point(x1,y1), Point(x2,y2)) );\n        }\n\n        bool kyo = false;\n        vector<Point> P;\n        for (int i=0; i<3 && !kyo; ++i) {\n            for (int j=i+1; j<3 && !kyo; ++j) {\n                Point p = intersection(L[i], L[j]);\n                if (p.x == INF) {\n                    kyo = true;\n                } else {\n                    P.push_back(p);\n                }\n            }\n        }\n\n        if (kyo) {\n            cout << \"kyo\" << endl;\n        } else {\n            double area = areaOfTriangle(P[0], P[1], P[2]);\n            if (area < eps) {\n                cout << \"kyo\" << endl;\n            } else if (1900000 <= area + eps) {\n                cout << \"dai-kichi\" << endl;\n            } else if (1000000 <= area + eps) {\n                cout << \"chu-kichi\" << endl;\n            } else if (100000 <= area + eps) {\n                cout << \"kichi\" << endl;\n            } else {\n                cout << \"syo-kichi\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(){}\n\tL(const P& a, const P& b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b,c) > 0)  return  1;\n\tif(cross(b,c) < 0)  return -1;\n\tif(dot(b,c)   < 0)  return  2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L& s, const L& t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t   ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool crosspoint(const L& l, const L& m, P& out) {\n\tif(!intersectSS(l, m))\n\t\treturn false;\n\t\n\tdouble A = cross(l[1]-l[0], m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0], l[1]-m[0]);\n\tif(abs(A) < EPS && abs(B) < EPS)\n\t\treturn false;\n\tout = m[0] + B/A*(m[1]-m[0]);\n\treturn true;\n}\n\n\nint main()\n{\n\tfor(;;){\n\t\tL s[3];\n\t\trep(i, 3){\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\tif(!x1 && !y1 && !x2 && !y2)\n\t\t\t\treturn 0;\n\t\t\ts[i].push_back(P(x1, y1));\n\t\t\ts[i].push_back(P(x2, y2));\n\t\t}\n\t\t\n\t\tP p[3];\n\t\tbool ok = true;\n\t\trep(i, 3){\n\t\t\tif(!crosspoint(s[i], s[(i+1)%3], p[i])){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble area = 0.0;\n\t\tif(ok){\n\t\t\tarea = abs(cross(p[1]-p[0], p[2]-p[1])/2.0);\n\t\t}\n\t\tif(area >= 1900000.0)\n\t\t\tputs(\"dai-kichi\");\n\t\telse if(area >= 1000000.0)\n\t\t\tputs(\"chu-kichi\");\n\t\telse if(area >= 100000.0)\n\t\t\tputs(\"kichi\");\n\t\telse if(area >= EPS)\n\t\t\tputs(\"syo-kichi\");\n\t\telse\n\t\t\tputs(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(true)\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(x1+y1+x2+y2 == 0)\n\tbreak;\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n    \n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=EPS)cout<<\"syo-kichi\"<<endl;\n      else cout<<\"kyo\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n \nusing namespace std;\n \n#define EPS 1e-8\n \nstruct Point {\n    double x,y;\n    Point(double x = 0.0, double y = 0.0) : x(x),y(y) {}\n    Point operator + (Point p){ return Point(x+p.x,y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x,y-p.y); }\n    Point operator * (double a){ return Point(x*a,y*a); }\n    Point operator / (double a){ return Point(x/a,y/a); }\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x*x + y*y; }\n};\n \ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n \nint ccw(Point p0,Point p1,Point p2)\n{\n    Point a = p1-p0;\n    Point b = p2-p0;\n    if (cross(a,b) > EPS) return 1;\n    if (cross(a,b) < -EPS) return -1;\n    if (dot(a,b) < -EPS) return 2;\n    if (a.norm() < b.norm()) return -2;\n    return 0;\n}\n \nstruct Segment {\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1,Point p2) : p1(p1),p2(p2) {}\n};\n \nbool intersectSS(const Segment &s,const Segment &t)    \n{\n    return (ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0) && \n\t(ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0);\n}\n \nPoint getCrossPoint(Segment s, Segment t)\n{\n    Point b = t.p2 - t.p1;\n    double d1 = abs(cross(b,s.p1-t.p1));\n    double d2 = abs(cross(b,s.p2-t.p1));\n    double d = d1 / (d1 + d2);\n    return s.p1+(s.p2-s.p1)*d;\n}\n \ndouble getArea(Point a, Point b, Point c)\n{\n    return fabs(a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2;\n}\n \nSegment s[3];\nvoid solve()\n{\n    Point p1 = getCrossPoint(s[0],s[1]);\n    Point p2 = getCrossPoint(s[1],s[2]);\n    Point p3 = getCrossPoint(s[2],s[0]);\n    double S = getArea(p1,p2,p3);\n    if (S >= 1900000) {\n\tcout << \"dai-kichi\" << endl;\n    } else if (S >= 1000000) {\n\tcout << \"chu-kichi\" << endl;\n    } else if (S >= 100000) {\n\tcout << \"kichi\" << endl;\n    } else if(S > 0) {\n\tcout << \"syo-kichi\" << endl;\n    } else {\n\tcout << \"kyo\" << endl;\n    }\n}\n \nint main()\n{\n    while (true) {\n\tcin >> s[0].p1.x >> s[0].p1.y >> s[0].p2.x >> s[0].p2.y;\n\tif (!s[0].p1.x && !s[0].p1.y && !s[0].p2.x && !s[0].p2.y) break;\n\tfor (int i = 0; i < 2; i++) {\n\t    cin >> s[i+1].p1.x >> s[i+1].p1.y >> s[i+1].p2.x >> s[i+1].p2.y;\n\t}\n\tif (intersectSS(s[0],s[1]) && intersectSS(s[1],s[2]) && intersectSS(s[2],s[0])) {\n\t    solve();\n\t} else {\n\t    cout << \"kyo\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n// struct G : public vector<Point>\n// {\n//     G() {}\n//     G(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| is_on_seg(seg1, seg2.first)\n\t\t|| is_on_seg(seg1, seg2.second)\n\t\t|| is_on_seg(seg2, seg1.first)\n\t\t|| is_on_seg(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"cross_point_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"cross_point_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079\ngtype area(const G& p)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\ts += cross(p[i], p[(i + 1) % p.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain{ OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (is_on_seg(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// 円\nenum res_circle_rela\n{\n    a_in_b,\n    b_in_a,\n\n    tangent,\n    intersect,\n    not_intersect,\n};\n// AOJ0023(feps = 0)\nres_circle_rela circle_rela(const Circle& a, const Circle& b)\n{\n    const gtype feps = 0;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    Point ab = b.p - a.p;\n    Point c = a.p + ab * (a.r / (a.r + b.r));\n\n    gtype dis = abs(a.p - c);\n    if (dis > a.r + feps)\n        return vector<Point>();\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - dis*dis));\n\n    Point u = ab * Point(0, 1) / abs(ab);\n    Point v = ab * Point(0, -1) / abs(ab);\n\n    Point p = c + u * h;\n    Point q = c + v * h;\n\n    vector<Point> res;\n    res.push_back(p);\n    if (abs(p - q) > feps)\n        res.push_back(q); // 2点で交わっている\n\n    return res;\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nbool contain_CP(const Circle& c, const Point& p)\n{\n    return abs(c.p - p) < c.r;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\nint main()\n{\n    for (;;)\n    {\n        Line l[3];\n        rep(i, 3)\n            if (!(cin >> l[i].first >> l[i].second))\n                goto END;\n\n        G g;\n        rep(i, 3) rep(j, i)\n            if (intersect_SS(l[i], l[j]) && !is_parallel(l[i], l[j]))\n                g.pb(ip_SS(l[i], l[j]));\n        assert(0 <= g.size() && g.size() <= 3);\n\n        string res;\n        if (g.size() == 3)\n        {\n            double s = area(g) + 1e-9;\n            if (s > 1.9 * 1e6)\n                res = \"dai-\";\n            else if (s > 1e6)\n                res = \"chu-\";\n            else if (s > 1e5)\n                res = \"\";\n            else\n                res = \"syo-\";\n            res += \"kichi\";\n        }\n        else\n            res = \"kyo\";\n        cout << res << endl;\n    }\nEND:\n    ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n        if(isParallel(a,b)||isParallel(b,c)||isParallel(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        if(equalsv(g[0],g[1])&&equalsv(g[1],g[2])&&equalsv(g[2],g[0])){\n            puts(\"kyo\");\n            continue;\n        }\n        double x=area(g);\n        if(x<EPS)puts(\"kyo\");\n        else if(x<100000-EPS)puts(\"syo-kichi\");\n        else if(x<1000000-EPS)puts(\"kichi\");\n        else if(x<1900000-EPS)puts(\"chu-kichi\");\n        else puts(\"dai-kichi\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n\n/*\n  ô½Cu\n*/\n\n#include<vector>\n#include<stack>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\n// _Iy[^\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\n// CCW oXg¾ªA¸xÉæé\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( abs(b) < abs(x) ) return FRONT;\n  return OVER;\n}\n\n// üªÌð·»èAºÍ_ÌÝÅßéo[WA»ÌºÍxNg(üªÌ[_Åðíé)\nbool intersected_seg(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\nbool intersected_l(line a, line b){\n  return !prll(a.fr,a.sc,b.fr,b.sc);\n}\npoint intersection_seg(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersection_l(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\nbool intersection_seg(seg a, seg b, point &ret){\n  if( intersected_seg(a,b) ){\n    ret = intersection_seg(a,b);\n    return true;\n  }\n  return false;\n}\nbool intersection_l(line a, line b, point &ret){\n  if( intersected_l( a, b ) ){\n    ret = intersection_l( a, b );\n    return true;\n  }\n  return false;\n}\nbool intersection_lseg(line l, seg s, point &ret){\n  point tmp;\n  if( intersection_l(l,s,tmp) ){\n    if(ccw(s.fr,s.sc,tmp)&OVER){\n      ret=tmp;\n      return true;\n    }\n  }\n  return false;\n}\n\n// Op`ÌÊÏ\nelem areaOfTriangle(elem a, elem b, elem c){\n  elem s = (a+b+c)/2;\n  return sqrt( s * (s-a) * (s-b) * (s-c) );\n}\n\nusing namespace std;\nint main(){\n  while(true){\n    seg s[3];\n    bool inv=false;\n    for(int i = 0; i <3; ++i){\n      elem x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(eq(x1,0)&&eq(y1,0)&&eq(x2,0)&&eq(y2,0))return 0;\n      s[i] = seg(point(x1,y1),point(x2,y2));\n    }\n    point a,b,c;\n    if( !intersection_seg( s[0], s[1], a ) ||\n\t!intersection_seg( s[1], s[2], b ) || \n\t!intersection_seg( s[2], s[0], c ) )\n      inv=true;\n    if(near(a,b)&&near(b,c)&&near(c,a))inv=true;\n    \n    //    cout << \" A : \" << a << \" B : \" << b << \" C : \" << c << endl;\n    elem area = areaOfTriangle( abs(b-a), abs(c-b), abs(a-c) );\n    if( inv ){\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    \n    if( geq( area, 1900000 ) ){\n      cout << \"dai-kichi\" << endl;\n    }else if( geq( area, 1000000 ) ){\n      cout << \"chu-kichi\" << endl;\n    }else if( geq( area, 100000 ) ){\n      cout << \"kichi\" << endl;\n    }else if( gtz( area ) ){\n      cout << \"syo-kichi\" << endl;\n    }else{\n      cout << \"kyo\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace geometry\n{\t\n\ttypedef double D;\n\ttypedef complex<D> P;\n\ttypedef pair<P, P> S;\n\ttypedef S L;\n\ttypedef pair<P, D> C;\n\t\n\t#define EPS \t\t(1e-10)\n\t#define EQ(a, b) \t(abs((a) - (b)) < EPS)\n\t#define EQV(a, b) \t(EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\t\n\tstatic const int COUNTER_CLOCKWISE \t=  1;\n\tstatic const int CLOCKWISE\t\t\t= -1;\n\tstatic const int ONLINE_BACK\t\t=  2;\n\tstatic const int ONLINE_FRONT\t\t= -2;\n\tstatic const int ON_SEGMENT\t\t\t=  0;\n\t\n\tD norm(P a) { return a.real() * a.real() + a.imag() * a.imag(); }\n\t\n\tD dot(P a, P b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\tD cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\t\n\tbool isOrthogonal(P a1, P a2, P b1, P b2) { return EQ(dot(a1 - a2, b1 - b2), 0.0); }\n\tbool isOrthogonal(L a, L b) { return isOrthogonal(a.first, a.second, b.first, b.second); }\n\tbool isParallel(P a1, P a2, P b1, P b2) { return EQ(cross(a1 - a2, b1 - b2), 0.0); }\n\tbool isParallel(L a, L b) { return isParallel(a.first, a.second, b.first, b.second); }\n\t\n\tbool isPointOnLine(P a, P b, P c) { return EQ(cross(b - a, c - a), 0.0); }\n\tbool isPointOnLine(L a, P b) { return isPointOnLine(a.first, a.second, b); }\n\tbool isPointOnSegment(P a, P b, P c) {\n\t\treturn EQ(cross(b - a, c - a), 0.0) &&\n\t\t       (dot(b - a, c - a) > -EPS) &&\n\t\t\t   (dot(a - b, c - b) > -EPS);\n\t}\n\tbool isPointOnSegment(S a, P b) { return isPointOnLine(a.first, a.second, b); }\n\t\n\tint ccw(P p0, P p1, P p2){\n\t\tP a = p1 - p0;\n\t\tP b = p2 - p0;\n\t\tif (cross(a, b) > EPS) \treturn COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS)\treturn ONLINE_BACK;\n\t\tif (norm(a) < norm(b))\treturn ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\tbool intersect(P p1, P p2, P p3, P p4){\n\t\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t       ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n\t}\n\tbool intersect(S s1, S s2){\n\t\treturn intersect(s1.first, s1.second, s2.first, s2.second);\n\t}\n\t\n\tD distanceLP(P a, P b, P c) { return abs(cross(b - a, c - a)) / abs(b - a); }\n\tD distanceLP(L a, P b) { return distanceLP(a.first, a.second, b); }\n\tD distanceSP(P a, P b, P c) {\n\t\tif (dot(b - a, c - a) < EPS) return abs(c - a);\n\t\tif (dot(a - b, c - b) < EPS) return abs(c - b);\n\t\treturn abs(cross(b - a, c - a)) / abs(b - a);\n\t}\n\tD distanceSP(S a, P b) { return distanceSP(a.first, a.second, b); }\n\t\n\tbool intersectCL(C c, L l){\n\t\treturn c.second - distanceLP(l, c.first) > -EPS;\n\t}\n\tbool intersectCS(C c, S s){\n\t\tif (EQ(c.second - abs(c.first - s.first), 0.0) ||\n\t\t\tEQ(c.second - abs(c.first - s.second), 0.0)) return true;\n\t\tif (c.second - distanceSP(s, c.first) > -EPS){\n\t\t\treturn (c.second - abs(c.first - s.first) < EPS ||\n\t\t\t\t    c.second - abs(c.first - s.second) < EPS);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tP project(S s, P p){\n\t\tP base = s.second - s.first;\n\t\tD r = dot(p - s.first, base) / norm(base);\n\t\treturn s.first + base * r;\n\t}\n\tP reflect(S s, P p){\n\t\treturn p + (project(s, p) - p) * (D)2.0;\n\t}\n\t\n\tP crossPoint(S s1, S s2){\n\t\tP base = s2.second - s2.first;\n\t\tD d1 = abs(cross(base, s1.first - s2.first));\n\t\tD d2 = abs(cross(base, s1.second - s2.first));\n\t\tD t = d1 / (d1 + d2);\n\t\treturn s1.first + (s1.second - s1.first) * t;\n\t}\n\t\n\tD area(vector<P> poly){\n\t\tif (poly.size() < 3) return 0.0;\n\t\tD res = 0.0;\n\t\tfor (int i = 0; i < poly.size() - 2; i++){\n\t\t\tP v1 = poly[i + 1] - poly[i];\n\t\t\tP v2 = poly[i + 2] - poly[i];\n\t\t\tres += abs(cross(v1, v2)) / 2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid debug(P p){\n\t\tprintf(\"x: %f, y: %f\\n\", p.real(), p.imag()); \n\t}\n\tvoid debug(C c){\n\t\tprintf(\"x: %f, y: %f, r: %f\\n\", c.first.real(), c.first.imag(), c.second);\n\t}\n\tvoid debug(S s){\n\t\tprintf(\"{\\n\");\n\t\tprintf(\"    \");\n\t\tdebug(s.first);\n\t\tprintf(\"    \");\n\t\tdebug(s.second);\n\t\tprintf(\"}\\n\");\n\t}\n\tvoid debug(vector<P> poly){\n\t\tprintf(\"{\\n\");\n\t\tfor (int i = 0; i < poly.size(); i++){\n\t\t\tprintf(\"    \");\n\t\t\tdebug(poly[i]);\n\t\t}\n\t\tprintf(\"}\\n\");\n\t}\n}\n\nusing namespace geometry;\n\nint main()\n{\n\twhile (true){\n\t\tvector<S> ss;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tint x[2], y[2];\n\t\t\tfor (int j = 0; j < 2; j++){\n\t\t\t\tscanf(\"%d %d\", &x[j], &y[j]);\n\t\t\t}\n\t\t\tss.push_back(S(P(x[0], y[0]), P(x[1], y[1])));\n\t\t\tif (!x[0] && !x[1] && !y[0] && !y[1]) return 0;\n\t\t}\n\t\tvector<P> ps;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tif (!intersect(ss[i], ss[(i + 1) % 3])) break;\n\t\t\tps.push_back(crossPoint(ss[i], ss[(i + 1) % 3]));\n\t\t}\n\t\t//debug(ps);\n\t\tD s = area(ps);\n\t\tstring res;\n\t\tif (s - 1900000 > -EPS) res = \"dai-kichi\";\n\t\telse if (s - 1000000 > -EPS) res = \"chu-kichi\";\n\t\telse if (s - 100000 > -EPS) res = \"kichi\";\n\t\telse if (s > 0) res = \"syo-kichi\";\n\t\telse res = \"kyo\";\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n\ndouble cross(P a,P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1,P a2,P b1,P b2){\n\treturn cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS &&\n\t\tcross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS;\n}\n\nP intersection_ls(P a1,P a2,P b1,P b2){\n\tP b = b2 - b1;\n\tdouble d1 = abs(cross(b,a1-b1));\n\tdouble d2 = abs(cross(b,a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * t;\n}\n\ndouble polygon_area(int n, P p[]){\n\tdouble s = cross(p[n-1],p[0]);\n\tfor(int i=0;i<n-1;i++) s += cross(p[i],p[i+1]); \n\treturn fabs(s) / 2;\n}\n\nint main(void){\n\twhile(1){\n\t\tdouble s=0;\n\t\tP l[3][2],p[3];\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(!(cin>>l[i][0].real()>>l[i][0].imag()>>l[i][1].real()>>l[i][1].imag())) return 0;\n\t\t}\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint j = (i + 1) % 3;\n\t\t\tif(is_intersected_ls(l[i][0],l[i][1],l[j][0],l[j][1])){\n\t\t\t\tp[i] = intersection_ls(l[i][0],l[i][1],l[j][0],l[j][1]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(s == 0){\n\t\t\ts = polygon_area(3,p);\n\t\t\tif(s >= 1900000) cout<<\"dai-kichi\\n\";\n\t\t\telse if(s >= 1000000) cout<<\"chu-kichi\\n\";\n\t\t\telse if(s >= 100000) cout<<\"kichi\\n\";\n\t\t\telse cout<<\"syo-kichi\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"kyo\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nclass Line\n{\npublic:\n    double a, b, c; // a*x + b*y + c = 0\n    Line(){\n        a = c = 0.0;\n        b = 1.0;\n    }\n    Line(double a0, double b0, double c0){\n        a = a0;\n        b = b0;\n        c = c0;\n    }\n    Line(const Point& p1, const Point& p2){ // 2_ðÔ¼ü\n        double dy = p2.y - p1.y;\n        double dx = p2.x - p1.x;\n        if(abs(dy / dx) < EPS){\n            a = 0.0;\n            b = 1.0;\n            c = -p1.y;\n        }else if(abs(dx / dy) < EPS){\n            a = 1.0;\n            b = 0.0;\n            c = -p1.x;\n        }else{\n            a = - dy / dx;\n            b = 1.0;\n            c = dy / dx * p1.x - p1.y;\n        }\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) <= 0) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) <= 0);\n}\n\nbool linesIntersection(const Line& l1, const Line& l2, Point& intersection)\n{\n    double s = l1.a*l2.b - l2.a*l1.b;\n    if(abs(s) < EPS)\n        return false;\n\n    intersection = Point(l2.a*l1.c - l1.a*l2.c, l1.b*l2.c - l2.b*l1.c) / s;\n    return true;\n}\n\ndouble polygonArea(const vector<Point>& p)\n{\n    int n = p.size();\n    double ret = 0.0;\n    for(int i=0; i<n; ++i)\n        ret += p[i].cross(p[(i+1)%n]);\n    return abs(ret) / 2.0;\n}\n\nint main()\n{\n    for(;;){\n        vector<Point> p(6);\n        for(int i=0; i<6; ++i)\n            cin >> p[i].x >> p[i].y;\n        if(p[0].x == 0 && p[0].y == 0 && p[1].x == 0 && p[1].y == 0)\n            return 0;\n\n        bool kyo = false;\n        for(int i=0; i<3; ++i){\n            if(!segmentsCollide(p[i*2], p[i*2+1], p[(i+1)*2%6], p[((i+1)*2+1)%6]))\n                kyo = true;\n        }\n        if(kyo){\n            cout << \"kyo\" << endl;\n            continue;\n        }\n\n        vector<Line> line(3);\n        for(int i=0; i<3; ++i)\n            line[i] = Line(p[i*2], p[i*2+1]);\n        vector<Point> p1(3);\n        for(int i=0; i<3; ++i)\n            linesIntersection(line[i], line[(i+1)%3], p1[i]);\n\n        double area = polygonArea(p1);\n        if(area > 1900000 - EPS)\n            cout << \"dai-kichi\" << endl;\n        else if(area > 1000000 - EPS)\n            cout << \"chu-kichi\" << endl;\n        else if(area > 100000 - EPS)\n            cout << \"kichi\" << endl;\n        else\n            cout << \"syo-kichi\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nPoint prj(const Segment& a, const Point& b) { return a.p1 + (a.p2 - a.p1) * dot(b - a.p1, a.p2 - a.p1) / norm(a.p2 - a.p1); }\nPoint rfl(const Segment& a, const Point& b) { return b + (prj(a, b) - b) * 2.0L; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint crp(Segment a, Segment b) {\n\tPoint c = b.p2 - b.p1;\n\tlong double d1 = abs(crs(c, a.p1 - b.p1));\n\tlong double d2 = abs(crs(c, a.p2 - b.p1));\n\treturn a.p1 + (a.p2 - a.p1) * (d1 / (d1 + d2));\n}\nlong double area(vector<Point> v) {\n\tlong double ret = 0.0L;\n\tfor (int i = 0; i < v.size(); i++) ret += crs(v[i], v[(i + 1) % v.size()]);\n\treturn ret / 2;\n}\nSegment s1, s2, s3;\nint main() {\n\twhile (cin >> s1.p1.px >> s1.p1.py >> s1.p2.px >> s1.p2.py >> s2.p1.px >> s2.p1.py >> s2.p2.px >> s2.p2.py >> s3.p1.px >> s3.p1.py >> s3.p2.px >> s3.p2.py) {\n\t\tif (!its(s1, s2) || !its(s2, s3) || !its(s3, s1)) puts(\"kyo\");\n\t\telse {\n\t\t\tPoint p1 = crp(s1, s2), p2 = crp(s2, s3), p3 = crp(s3, s1);\n\t\t\tlong double a = area({ p1, p2, p3 });\n\t\t\tif (a >= 1900000.0L) puts(\"dai-kichi\");\n\t\t\telse if (a >= 1000000.0L) puts(\"chu-kichi\");\n\t\t\telse if (a >= 100000.0L) puts(\"kichi\");\n\t\t\telse if (a >= 1e-10) puts(\"sho-kichi\");\n\t\t\telse puts(\"kyo\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(const Point &cc,double rr) : c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", \"M sessuru L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ndouble area(const Point &a,const Point &b,const Point &c){\n\treturn abs(cross(b-a,c-a))/2;\n}\n\ndouble area(const Polygon &pl){\n\tint n=pl.size();\n\tdouble a=0;\n\tfor(int i=0;i<n;i++)\ta+=cross(pl[i],pl[(i+1)%n]);\n\treturn abs(a)/2;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\twhile(1){\n\t\tPoint a,b,c,d,e,f;\n\t\tscanf(\"%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y);\n\t\tscanf(\"%lf%lf%lf%lf\",&c.x,&c.y,&d.x,&d.y);\n\t\tscanf(\"%lf%lf%lf%lf\",&e.x,&e.y,&f.x,&f.y);\n\t\tif(a.x==0 && a.y==0 && b.x==0 && b.y==0)\tbreak;\n\t\tSegment s(a,b),t(c,d),u(e,f);\n\t\tPoint p,q,r;\n\t\tif(intersect(s,t,&p) && intersect(t,u,&q) && intersect(u,s,&r)){\n\t\t\tdouble a=area(p,q,r);\n\t\t\tif     (a>1900000-EPS)\tputs(\"dai-kichi\");\n\t\t\telse if(a>1000000-EPS)\tputs(\"chu-kichi\");\n\t\t\telse if(a>100000-EPS)\tputs(\"kichi\");\n\t\t\telse if(a>EPS)\t\tputs(\"sho-kichi\");\n\t\t\telse\t\t\t\tputs(\"kyo\");\n\t\t}\n\t\telse\tputs(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint sig(double r){return (r<-EPS)?-1:(r>EPS)?1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y) : x(x),y(y){}\n\tPt operator+(const Pt &a)const{return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt &a)const{return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt &a)const{return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt &a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt &a)const{return x*a.y-y*a.x;}\n\tbool operator<(const Pt &a)const{return (x!=a.x)?(x<a.x):(y<a.y);}\n\tbool operator==(const Pt &a)const{return (sig(x-a.x)==0&&sig(y-a.y)==0);}\n};\nostream &operator<<(ostream &os,const Pt &a){os<<\"(\"<<a.x<<\", \"<<a.y<<\")\";return os;}\ndouble tri(Pt a,Pt b,Pt c){return (b-a).det(c-a);}\n\nPt proj(Pt a,Pt b){return a*a.dot(b)/a.abs2();}\nPt perp(Pt a,Pt b,Pt c){return a+proj(b-a,c-a);}\nPt refl(Pt a,Pt b,Pt c){return perp(a,b,c)*2-c;}\n\nint iSP(Pt a,Pt b,Pt c){\n\tint s=sig((b-a).det(c-a));\n\tif(s)return s;\n\tif(sig((b-a).dot(c-a))<0)return -2;\n\tif(sig((a-b).dot(c-b))<0)return +2;\n\treturn 0;\n}\n\nbool iSS(Pt a,Pt b,Pt c,Pt d){\n\treturn (iSP(a,b,c)*iSP(a,b,d)<=0&&iSP(c,d,a)*iSP(c,d,b)<=0);\n}\n\nPt pLL(Pt a,Pt b,Pt c, Pt d){\n\tb=b-a;d=d-c;\n\treturn a+b*(c-a).det(d)/b.det(d);\n}\n\nint main() {\n\tPt p[3][2];\n\tIL{\n\t\tcin>>p[0][0].x>>p[0][0].y;\n\t\tcin>>p[0][1].x>>p[0][1].y;\n\t\tif(p[0][0].abs()+p[0][1].abs()==0)break;\n\t\tcin>>p[1][0].x>>p[1][0].y;\n\t\tcin>>p[1][1].x>>p[1][1].y;\n\t\tcin>>p[2][0].x>>p[2][0].y;\n\t\tcin>>p[2][1].x>>p[2][1].y;\n\t\tbool ok=true;\n\t\trep(i,3){\n\t\t\tif(!iSS(p[i][0],p[i][1],p[(i+1)%3][0],p[(i+1)%3][1])){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\\n\";\n\t\t}else{\n\t\t\tPt a,b,c;\n\t\t\ta=pLL(p[0][0],p[0][1],p[1][0],p[1][1]);\n\t\t\tb=pLL(p[1][0],p[1][1],p[2][0],p[2][1]);\n\t\t\tc=pLL(p[2][0],p[2][1],p[0][0],p[0][1]);\n\t\t\tdouble s=tri(a,b,c)/2;\n\t\t\tif(s>=1900000){\n\t\t\t\tcout<<\"dai-kichi\\n\";\n\t\t\t}else if(s>=1000000){\n\t\t\t\tcout<<\"chu-kichi\\n\";\n\t\t\t}else if(s>=100000){\n\t\t\t\tcout<<\"kichi\\n\";\n\t\t\t}else{\n\t\t\t\tcout<<\"syo-kichi\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\nnamespace FP {\n    bool isZero(double x) {\n        return (abs(x) <= EPS);\n    }\n};\n\nstruct Point {\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << \"(\" << x << \",\" << y << \")\";\n        return os.str();\n    }\n    bool operator<(const Point &o) const {\n        return x == o.x ? y < o.y : x < o.x;\n    }\n    bool operator==(const Point &o) const {\n        return x == o.x && y == o.y;\n    }\n    Point operator+(const Point &o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator-(const Point &o) const {\n        return Point(x-o.x, y-o.y);\n    }\n    Point operator*(const double m) const {\n        return Point(x*m, y*m);\n    }\n    Point operator/(const double d) const {\n        return Point(x/d, y/d);\n    }\n    // 外積\n    double cross(const Point &o) const {\n        return x * o.y - y * o.x;\n    }\n    // 内積\n    double dot(const Point &o) const {\n        return x * o.x + y * o.y;\n    }\n    // ベクトルがx軸となす角\n    double atan() const {\n        return atan2(y, x);\n    }\n    // ベクトルの長さの二乗\n    double norm() const {\n        return dot(*this);\n    }\n};\n\nstruct Line {\n    double a, b, c;\n    Line(double a=0, double b=0, double c=0) :\n        a(a), b(b), c(c) {}\n    Point intersectionPoint(const Line &l) const {\n        double d = a * l.b - l.a * b;\n        if (!intersects(l)) {\n            throw string(\"The 2 Lines are parallel\");\n        }\n        double x = (b * l.c - l.b * c) / d;\n        double y = (l.a * c - a * l.c) / d;\n        return Point(x, y);\n    }\n    bool intersects(const Line &l) const {\n        return !FP::isZero(a * l.b - l.a * b);\n    }\n    string to_s() {\n        ostringstream os;\n        os << a << ' ' << b << ' ' << c;\n        return os.str();\n    }\n    static Line fromPoints(const Point &a, const Point &b) {\n        double dx = b.x - a.x;\n        double dy = b.y - a.y;\n        return Line(dy, -dx, dx * a.y - dy * a.x);\n    }\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n        return fromPoints(Point(x1, y1), Point(x2, y2));\n    }\n};\n\nstruct LineSegment {\n    Point start, end;\n    LineSegment(const Point &start, const Point &end) : start(start), end(end) {}\n    LineSegment(double x1=0, double y1=0, double x2=0, double y2=0) : start(Point(x1, y1)), end(Point(x2, y2)) {}\n    string to_s() {\n        ostringstream os;\n        os << '(' << start.x << ',' << start.y << ')' << '-' << '(' << end.x << ',' << end.y << ')' << endl;\n        return os.str();\n    }\n    Line toLine() const {\n        return Line::fromPoints(start, end);\n    }\n    bool intersects(const Line &l) const {\n        double t1 = l.a * start.x + l.b * start.y + l.c;\n        double t2 = l.a * end.x + l.b * end.y + l.c;\n        return t1 * t2 <= 0;\n    }\n    bool intersects(const LineSegment &s) const {\n        return intersects(s.toLine()) && s.intersects(toLine());\n    }\n    Point intersectionPoint(const LineSegment &s) const {\n        if (!intersects(s)) {\n            throw \"The 2 line segments are parallel\";\n        }\n        return (toLine().intersectionPoint(s.toLine()));\n    }\n};\n\nint main() {\n    Point s, e;\n    while (cin >> s.x >> s.y >> e.x >> e.y) {\n        if (s.x == 0 && s.y == 0 && e.x == 0 && e.y == 0) break;\n\n        LineSegment seg[3];\n        seg[0] = LineSegment(s, e);\n        for (int i = 1; i < 3; i++) {\n            cin >> s.x >> s.y >> e.x >> e.y;\n            seg[i] = LineSegment(s, e);\n        }\n\n        if (!seg[0].intersects(seg[1]) || !seg[1].intersects(seg[2])\n                                       || !seg[2].intersects(seg[0])) {\n            cout << \"kyo\" << endl;\n            break;\n        }\n\n        Point vertex[3];\n        vertex[0] = seg[0].intersectionPoint(seg[1]);\n        vertex[1] = seg[1].intersectionPoint(seg[2]);\n        vertex[2] = seg[2].intersectionPoint(seg[0]);\n        if (vertex[0] == vertex[1] && vertex[1] == vertex[2]) {\n            cout << \"kyo\" << endl;\n            break;\n        }\n        \n        double area = abs((vertex[1] - vertex[0]).cross(vertex[2] - vertex[0]) / 2.0);\n//        cout << area << endl;\n        if (area - 100000 < EPS) {\n            cout << \"syo-kichi\" << endl;\n        } else if (area - 1000000 < EPS) {\n            cout << \"kichi\" << endl;\n        } else if (area - 1900000 < EPS) {\n            cout << \"chu-kichi\" << endl;\n        } else {\n            cout << \"dai-kichi\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  if(!isIntersect(a1,a2,b1,b2))\n    {\n      return Point(-9993999,-9993999);\n    }\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(4);\n  p[0] = p1,p[1] = p2,p[2] = p3,p[3] = p[0];\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += (p[i].x - p[i+1].x)*(p[i].y+p[i+1].y);\n  return fabs(sum/2.0);\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n     \n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# -*- coding: utf-8 -*-\nEPS = 1e-9\n\nclass Point\n  attr_reader :x, :y\n  def initialize(x, y=nil)\n    @x, @y = x, y if y\n    @x, @y = x[0], x[1] unless y\n  end\n  def +(other)\n    Point.new(@x + other.x, @y + other.y)\n  end\n  def -(other)\n    Point.new(@x - other.x, @y - other.y)\n  end\n  def *(other)\n    Point.new(@x * other, @y * other)\n  end\nend\n\nclass Line\n  attr_reader :s, :t\n  def initialize(s, t=nil)\n    @s, @t = s, t if t\n    @s, @t = Point.new(s[0..1]), Point.new(s[2..3]) unless t\n  end\nend\n\ndef dot(a, b); a.x * b.x + a.y * b.y; end\ndef cross(a, b);  a.x * b.y - b.x * a.y; end\n\ndef is_intersected_ls(a, b)\n  cross(a.t - a.s, b.s - a.s) * cross(a.t - a.s, b.t - a.s) < EPS and\n    cross(b.t - b.s, a.s - b.s) * cross(b.t - b.s, a.t - b.s) < EPS\nend\n\ndef intersection_ls(a, b)\n  tmp = b.t - b.s\n\n  d1 = cross(tmp, a.s - b.s).abs\n  d2 = cross(tmp, a.t - b.s).abs\n  t = d1 / (d1 + d2)\n\n  a.s + (a.t - a.s) * t\nend\n\ndef area(points)\n  cross(points[0] - points[2], points[1] - points[2]).abs / 2\nend\n\ndef fortune(x)\n  case x\n  when 0; \"kyo\"\n  when 0..100000; \"syo-kichi\"\n  when 0..1000000; \"kichi\"\n  when 0..1900000; \"chu-kichi\"\n  else; \"dai-kichi\"\n  end\nend\n\nwhile input = gets.split.map(&:to_i) and input.count(0) != 4\n  l = [ Line.new(input) ]\n  2.times{ l << Line.new(gets.split.map(&:to_i)) }\n\n  res = nil\n  points = []\n  for i in 0..2\n    res = \"kyo\" unless is_intersected_ls(l[i], l[(i + 1) % 3])\n\n    points << intersection_ls(l[i], l[(i + 1) % 3]) unless res\n  end\n\n  res = fortune(area(points)) unless res\n\n  puts res\nend"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  if(!isIntersect(a1,a2,b1,b2))\n    {\n      return Point(-9993999,-9993999);\n    }\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  double a,b,c;\n  a = sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));\n  b = sqrt(pow(p2.x-p3.x,2)+pow(p2.y-p3.y,2));\n  c = sqrt(pow(p1.x-p3.x,2)+pow(p1.y-p3.y,2));\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n\n\n      if((c1 == c2 && c2 == c3) || c1 == Point(-9993999,-9993999) || c2 == Point(-9993999,-9993999) || c3 == Point(-9993999,-9993999))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n     \n      double area = getArea(c1,c2,c3);\n\n      if(0.0 <= area && area < 100000)\n\tcout << \"syo-kichi\" << endl;\n      else if(100000 <= area && area < 1000000)\n\tcout << \"kichi\" << endl;\n      else if(1000000 <= area && area < 1900000)\n\tcout << \"chu-kichi\" << endl;\n      else if(1900000 <= area)\n\tcout << \"dai-kichi\" << endl; \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) { return a < b - EPS ? -1 : (a > b + EPS ? 1 : 0); }\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める (時計回りだと負になる)\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn res/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n\n/** Problem0187 : Stoining Fortune **/\nint main()\n{\n\tL s, t, u;\n\twhile (true) {\n\t\tD x1, y1, x2, y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tif (x1==0 && x2==0 && y1==0 && y2==0) break;\n\t\t\n\t\ts = L(P(x1, y1), P(x2, y2));\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tt = L(P(x1, y1), P(x2, y2));\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tu = L(P(x1, y1), P(x2, y2));\n\t\t\n\t\t\n\t\tif (iSS(s, t) && iSS(t, u) && iSS(u, s)) {\n\t\t\tP a = cSS(s, t), b = cSS(t, u), c = cSS(u, s);\n\t\t\tG g; g.push_back(a), g.push_back(b), g.push_back(c);\n\t\t\tD tmp = abs(area(g));\n\t\t\t\n\t\t\tif (tmp >= 1900000) cout << \"dai-kichi\" << endl;\n\t\t\telse if (tmp >= 1000000) cout << \"chu-kichi\" << endl;\n\t\t\telse if (tmp >= 100000) cout << \"kichi\" << endl;\n\t\t\telse cout << \"syo-kichi\" << endl;\n\t\t} else {\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nclass Line\n{\npublic:\n    double a, b, c; // a*x + b*y + c = 0\n    Line(){\n        a = c = 0.0;\n        b = 1.0;\n    }\n    Line(double a0, double b0, double c0){\n        a = a0;\n        b = b0;\n        c = c0;\n    }\n    Line(const Point& p1, const Point& p2){ // 2_ðÔ¼ü\n        double dy = p2.y - p1.y;\n        double dx = p2.x - p1.x;\n        if(abs(dy / dx) < EPS){\n            a = 0.0;\n            b = 1.0;\n            c = -p1.y;\n        }else if(abs(dx / dy) < EPS){\n            a = 1.0;\n            b = 0.0;\n            c = -p1.x;\n        }else{\n            a = - dy / dx;\n            b = 1.0;\n            c = dy / dx * p1.x - p1.y;\n        }\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) + EPS || min(b1.x, b2.x) > max(a1.x, a2.x) + EPS || min(a1.y, a2.y) > max(b1.y, b2.y) + EPS || min(b1.y, b2.y) > max(a1.y, a2.y) + EPS)\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS);\n}\n\nbool linesIntersection(const Line& l1, const Line& l2, Point& intersection)\n{\n    double s = l1.a*l2.b - l2.a*l1.b;\n    if(abs(s) < EPS)\n        return false;\n\n    intersection = Point(l2.a*l1.c - l1.a*l2.c, l1.b*l2.c - l2.b*l1.c) / s;\n    return true;\n}\n\ndouble polygonArea(const vector<Point>& p)\n{\n    int n = p.size();\n    double ret = 0.0;\n    for(int i=0; i<n; ++i)\n        ret += p[i].cross(p[(i+1)%n]);\n    return abs(ret) / 2.0;\n}\n\nint main()\n{\n    for(;;){\n        vector<Point> p(6);\n        for(int i=0; i<6; ++i)\n            cin >> p[i].x >> p[i].y;\n        if(p[0].x == 0 && p[0].y == 0 && p[1].x == 0 && p[1].y == 0)\n            return 0;\n\n        bool kyo = false;\n        for(int i=0; i<3; ++i){\n            if(!segmentsCollide(p[i*2], p[i*2+1], p[(i+1)*2%6], p[((i+1)*2+1)%6]))\n                kyo = true;\n        }\n        if(kyo){\n            cout << \"kyo\" << endl;\n            continue;\n        }\n\n        vector<Line> line(3);\n        for(int i=0; i<3; ++i)\n            line[i] = Line(p[i*2], p[i*2+1]);\n        vector<Point> p1(3);\n        for(int i=0; i<3; ++i)\n            linesIntersection(line[i], line[(i+1)%3], p1[i]);\n\n        double area = polygonArea(p1);\n        if(area > 1900000 - EPS)\n            cout << \"dai-kichi\" << endl;\n        else if(area > 1000000 - EPS)\n            cout << \"chu-kichi\" << endl;\n        else if(area > 100000 - EPS)\n            cout << \"kichi\" << endl;\n        else if(area > EPS)\n            cout << \"syo-kichi\" << endl;\n        else\n            cout << \"kyo\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { }};\nint ccw(P a, P b, P c) {b -= a; c -= a;if (cross(b, c) > 0)   return +1;if (cross(b, c) < 0)   return -1;if (dot(b, c) < 0) return +2;if (norm(b) < norm(c)) return -2;return 0;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ndouble area2(const polygon& P) {double A = 0;for (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));return A;}\nP crosspoint(const L &l, const L &m) {double A = cross(l[1] - l[0], m[1] - m[0]);double B = cross(l[1] - l[0], l[1] - m[0]);if (abs(A) < EPS && abs(B) < EPS) return m[0];return m[0] + B / A * (m[1] - m[0]);}\n\nint main(){\n\tdouble a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a+b+c+d != 0){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tdouble ret = 0;\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tG npts;\n\t\t\tnpts.push_back( crosspoint(one,two) );\n\t\t\tnpts.push_back( crosspoint(two,three) );\n\t\t\tnpts.push_back( crosspoint(one,three) );\n\t\t\tsort(all(npts));\n\t\t\tret = area2(npts);\n\t\t}\n\t\tif(ret >= 1900000){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if(ret >= 1000000){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if(ret >= 100000){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret >= EPS){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\nstruct L {\n    P x, y;\n    L() {};\n    L(P a, P b) {x=a, y=b;};\n};\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble dot(P a, P b) { return real(conj(a)*b); }\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;\n    if (cross(b, c) < 0) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool insLL(L &l, L &m) {\n    if (abs(cross(l.y-l.x, m.y-m.x)) > EPS) return true;\n    if (abs(cross(l.y-l.x, m.y-l.x)) < EPS) return true;\n    return false;\n}\n\nbool insLS(L &l, L &s) {\n    double a = cross(l.y-l.x, s.x-l.x);\n    double b = cross(l.y-l.x, s.y-l.x);\n    if (a*b < EPS) return true;\n    return false;\n}\n\nbool insSP(L &s, P &p) {\n    return abs(s.x-p)+abs(s.y-p)+abs(s.y-s.x) < EPS;\n}\n\nbool insSS(L &s, L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nP crossp(L &l, L &m) {\n    double A = cross(l.y-l.x, m.y-m.x);\n    double B = cross(l.y-l.x, l.y-m.x);\n    if (abs(A) < EPS && abs(B) < EPS) return m.x;\n    return m.x+B/A*(m.y-m.x);\n}\n\nint main() {\n    while (true) {\n        L l1, l2, l3;\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (!x1 && !y1 && !x2 && !y2) break;\n        l1.x = P(x1, y1); l1.y = P(x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        l2.x = P(x1, y1); l2.y = P(x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        l3.x = P(x1, y1); l3.y = P(x2, y2);\n        P p1 = crossp(l1, l2);\n        P p2 = crossp(l2, l3);\n        P p3 = crossp(l3, l2);\n        double s = abs(cross(p2-p1, p3-p1))/2;\n        if (1900000 <= s) cout << \"dai-kichi\" << endl;\n        else if (1000000 <= s) cout << \"chu-kichi\" << endl;\n        else if (100000 <= s) cout << \"kichi\" << endl;\n        else if (EPS <= s) cout << \"syo-kichi\" << endl;\n        else cout << \"kyo\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\nnamespace FP {\n    bool isZero(double x) {\n        return (abs(x) <= EPS);\n    }\n};\n\nstruct Point {\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << \"(\" << x << \",\" << y << \")\";\n        return os.str();\n    }\n    bool operator<(const Point &o) const {\n        return x == o.x ? y < o.y : x < o.x;\n    }\n    bool operator==(const Point &o) const {\n        return x == o.x && y == o.y;\n    }\n    Point operator+(const Point &o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator-(const Point &o) const {\n        return Point(x-o.x, y-o.y);\n    }\n    Point operator*(const double m) const {\n        return Point(x*m, y*m);\n    }\n    Point operator/(const double d) const {\n        return Point(x/d, y/d);\n    }\n    // 外積\n    double cross(const Point &o) const {\n        return x * o.y - y * o.x;\n    }\n    // 内積\n    double dot(const Point &o) const {\n        return x * o.x + y * o.y;\n    }\n    // ベクトルがx軸となす角\n    double atan() const {\n        return atan2(y, x);\n    }\n    // ベクトルの長さの二乗\n    double norm() const {\n        return dot(*this);\n    }\n};\n\nstruct Line {\n    double a, b, c;\n    Line(double a=0, double b=0, double c=0) :\n        a(a), b(b), c(c) {}\n    Point intersectionPoint(const Line &l) const {\n        double d = a * l.b - l.a * b;\n        if (!intersects(l)) {\n            throw string(\"The 2 Lines are parallel\");\n        }\n        double x = (b * l.c - l.b * c) / d;\n        double y = (l.a * c - a * l.c) / d;\n        return Point(x, y);\n    }\n    bool intersects(const Line &l) const {\n        return !FP::isZero(a * l.b - l.a * b);\n    }\n    string to_s() {\n        ostringstream os;\n        os << a << ' ' << b << ' ' << c;\n        return os.str();\n    }\n    static Line fromPoints(const Point &a, const Point &b) {\n        double dx = b.x - a.x;\n        double dy = b.y - a.y;\n        return Line(dy, -dx, dx * a.y - dy * a.x);\n    }\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n        return fromPoints(Point(x1, y1), Point(x2, y2));\n    }\n};\n\nstruct LineSegment {\n    Point start, end;\n    LineSegment(const Point &start, const Point &end) : start(start), end(end) {}\n    LineSegment(double x1=0, double y1=0, double x2=0, double y2=0) : start(Point(x1, y1)), end(Point(x2, y2)) {}\n    string to_s() {\n        ostringstream os;\n        os << '(' << start.x << ',' << start.y << ')' << '-' << '(' << end.x << ',' << end.y << ')' << endl;\n        return os.str();\n    }\n    Line toLine() const {\n        return Line::fromPoints(start, end);\n    }\n    bool intersects(const Line &l) const {\n        double t1 = l.a * start.x + l.b * start.y + l.c;\n        double t2 = l.a * end.x + l.b * end.y + l.c;\n        return t1 * t2 <= 0;\n    }\n    bool intersects(const LineSegment &s) const {\n        return intersects(s.toLine()) && s.intersects(toLine());\n    }\n    Point intersectionPoint(const LineSegment &s) const {\n        if (!intersects(s)) {\n            throw \"The 2 line segments are parallel\";\n        }\n        return (toLine().intersectionPoint(s.toLine()));\n    }\n};\n\nint main() {\n    Point s, e;\n    while (cin >> s.x >> s.y >> e.x >> e.y) {\n        if (s.x == 0 && s.y == 0 && e.x == 0 && e.y == 0) break;\n\n        LineSegment seg[3];\n        seg[0] = LineSegment(s, e);\n        for (int i = 1; i < 3; i++) {\n            cin >> s.x >> s.y >> e.x >> e.y;\n            seg[i] = LineSegment(s, e);\n        }\n\n        if (!seg[0].intersects(seg[1]) || !seg[1].intersects(seg[2])\n                                       || !seg[2].intersects(seg[0])) {\n            cout << \"kyo\" << endl;\n            break;\n        }\n\n        Point vertex[3];\n        vertex[0] = seg[0].intersectionPoint(seg[1]);\n        vertex[1] = seg[1].intersectionPoint(seg[2]);\n        vertex[2] = seg[2].intersectionPoint(seg[0]);\n        if (vertex[0] == vertex[1] && vertex[1] == vertex[2]) {\n            cout << \"kyo\" << endl;\n            break;\n        }\n        \n        double area = abs((vertex[1] - vertex[0]).cross(vertex[2] - vertex[0]) / 2.0);\n        cout << area << endl;\n        if (area < 100000) {\n            cout << \"syo-kichi\" << endl;\n        } else if (area < 1000000) {\n            cout << \"kichi\" << endl;\n        } else if (area < 1900000) {\n            cout << \"chu-kichi\" << endl;\n        } else {\n            cout << \"dai-kichi\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  if(!isIntersect(a1,a2,b1,b2))\n    {\n      return Point(-9993999,-9993999);\n    }\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(4);\n  p[0] = p1,p[1] = p2,p[2] = p3,p[3] = p[0];\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += (p[i].x - p[i+1].x)*(p[i].y+p[i+1].y);\n  return fabs(sum/2.0);\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n\n\n      if((c1 == c2 && c2 == c3) || !isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n     \n      double area = getArea(c1,c2,c3);\n\n      if(0 < area && area < 100000)\n\tcout << \"syo-kichi\" << endl;\n      else if(100000 <= area && area < 1000000)\n\tcout << \"kichi\" << endl;\n      else if(1000000 <= area && area < 1900000)\n\tcout << \"chu-kichi\" << endl;\n      else if(1900000 <= area)\n\tcout << \"dai-kichi\" << endl; \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\nstatic const double EPS = 1e-12;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble getArea(P a, P b , P c){\n\t\tb-=a, c-=a;\n\t\treturn fabs( b.real() * c.imag() - c.real() * b.imag() ) / 2.0; \n}\nint main(){\n\tdouble a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a || b || c || d){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tdouble ret = 0;\n\t\t\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tret = getArea( crosspoint(one,two) , crosspoint(two,three) , crosspoint(one,three) );\n\t\t}\n\t\tif(ret >= 1900000){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if(ret >= 1000000){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if(ret >= 100000){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret > 0){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-12;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble getArea(P a, P b , P c){\n\t\tb-=a, c-=a;\n\t\treturn fabs( b.real() * c.imag() - c.real() * b.imag() ) / 2.0; \n}\nint main(){\n\tdouble a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a || b || c || d){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tdouble ret = 0;\n\t\t\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tret = getArea( crosspoint(one,two) , crosspoint(two,three) , crosspoint(one,three) );\n\t\t}\n\t\tif(ret >= 1900000){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if(ret >= 1000000){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if(ret >= 100000){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret > 0){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define EPS (1e-9)\n\nusing namespace std;\n\nbool eq(double a, double b)\n{\n\treturn (fabs(b - a) <= EPS);\n}\n\nbool getP(int x1, int y1, int x2, int y2, int p1, int q1, int p2, int q2, double *r1, double *r2)\n{\n\tint D = (x2 - x1) * (q2 - q1) - (y2 - y1) * (p2 - p1);\n\tif (D == 0) return (false);\n\t\n\tdouble r, s;\n\t\n\tr = ((q2 - q1) * (p1 - x1) - (p2 - p1) * (q1 - y1)) / (double)D;\n\ts = ((y2 - y1) * (p1 - x1) - (y2 - y1) * (q1 - y1)) / (double)D;\n\t//printf(\"%lf %lf\\n\", r, s);\n\tif (0 <= r + EPS && r - EPS <= 1 &&\n\t\t0 <= s + EPS && s - EPS <= 1){\n\t\t*r1 = x1 + r * (x2 - x1);\n\t\t*r2 = y1 + r * (y2 - y1);\n\t\treturn (true);\n\t}\n\t\n\treturn (false);\n}\n\nint main()\n{\n\tint x1[3], y1[3], x2[3], y2[3];\n\tdouble x3[3], y3[3];\n\t\n\twhile (1){\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tscanf(\"%d %d %d %d\", x1 + i, y1 + i, x2 + i, y2 + i);\n\t\t\tif (x1[i] == 0 && x2[i] == 0 && y1[i] == 0 && y2[i] == 0) return (0);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\t\tif (!getP(x1[i], y1[i], x2[i], y2[i],\n\t\t\t\t\t\t  x1[j], y1[j], x2[j], y2[j],\n\t\t\t\t\t\t  &x3[i], &y3[i])){\n\t\t\t\t\t\t  printf(\"kyo\\n\");\n\t\t\t\t\t\t  goto ng;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 3; i++) for (int j = i + 1; j < 3; j++) if (eq(x3[i], x3[j]) && eq(y3[i], y3[j])){\n\t\t\tprintf(\"kyo\\n\"); goto ng;\n\t\t}\n\t\tx3[0] -= x3[2]; x3[1] -= x3[2];\n\t\ty3[0] -= y3[2]; y3[1] -= y3[2];\n\t\t\n\t\tdouble S;\n\t\t\n\t\tS = 0.5 * fabs(x3[0] * y3[1] - y3[0] * x3[1]);\n\t\t\n\t\tif (S >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (S >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (S >= 100000) printf(\"kichi\\n\");\n\t\telse if (S > 0) printf(\"syo-kichi\\n\");\n\t\telse printf(\"kyo\\n\");\n\t\t\n\t\tng:;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define EPS (1e-7)\n\ntypedef complex<double> P;\nstruct Line : public vector<P>\n{\n  Line() {\n  }\n  Line(P a, P b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\nbool is_cross_ss(Line const& a, Line const& b) {\n  return ( cross(a[1]-a[0], b[0]-a[0]) * cross(a[1]-a[0], b[1]-a[0]) < EPS )\n    && ( cross(b[1]-b[0], a[0]-b[0]) * cross(b[1]-b[0], a[1]-b[0]) < EPS );\n}\n\nP crosspoint_ss(Line const& a, Line const& b) {\n  P vb = b[1]-b[0];\n  double d1 = abs(cross(vb, a[0]-b[0]));\n  double d2 = abs(cross(vb, a[1]-b[0]));\n  double t = d1 / (d1+d2);\n  return a[0] + (a[1]-a[0]) * t;\n}\n\nbool operator == (P const& a, P const& b) {\n  return ( abs(a.real()-b.real()) < EPS && abs(a.imag()-b.imag()) < EPS );\n}\n\nint main() {\n  \n  while(1) {\n    Line l[3];\n    rep(i, 3) {\n      double sx, sy, gx, gy;\n      cin >> sx >> sy >> gx >> gy;\n      if(i == 0 && sx == 0 && sy == 0 && gx == 0 && gy == 0) return 0;\n      l[i] = Line(P(sx, sy), P(gx, gy));\n    }\n    \n    \n    vector<P> ps;\n    rep(i, 3) {\n      if(is_cross_ss(l[i], l[(i+1)%3])) {\n        P cp = crosspoint_ss(l[i], l[(i+1)%3]);\n        bool ok = 1;\n        rep(j, (int)ps.size())\n          if(ps[j] == cp) { ok = 0; }\n        if(ok) {\n          ps.push_back(cp);\n        }\n      }\n    }\n    \n    if(ps.size() < 3) {\n      cout << \"kyo\\n\";\n      continue;\n    }\n    if(ps.size() > 3) {\n      assert(false && \"sine\");\n    }\n    \n    double ans = abs(cross(ps[2]-ps[0], ps[1]-ps[0])) / 2.;\n    if(ans >= 1900000.) {\n      cout << \"dai-kichi\\n\";\n    }\n    else if(ans >= 1000000.) {\n      cout << \"chu-kichi\\n\";\n    }\n    else if(ans >= 100000.) {\n      cout << \"kichi\\n\";\n    }\n    else if(ans > EPS) {\n      cout << \"syo-kichi\\n\";\n    }\n    else {\n      cout << \"kyo\\n\";\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(const Point &cc,double rr) : c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", \"M sessuru L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ndouble area(const Point &a,const Point &b,const Point &c){\n\treturn abs(cross(b-a,c-a))/2;\n}\n\ndouble area(const Polygon &pl){\n\tint n=pl.size();\n\tdouble a=0;\n\tfor(int i=0;i<n;i++)\ta+=cross(pl[i],pl[(i+1)%n]);\n\treturn abs(a)/2;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\twhile(1){\n\t\tPoint a,b,c,d,e,f;\n\t\tscanf(\"%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y);\n\t\tscanf(\"%lf%lf%lf%lf\",&c.x,&c.y,&d.x,&d.y);\n\t\tif(scanf(\"%lf%lf%lf%lf\",&e.x,&e.y,&f.x,&f.y)==EOF)\tbreak;\n\t\tSegment s(a,b),t(c,d),u(e,f);\n\t\tPoint p,q,r;\n\t\tif(intersect(s,t,&p) && intersect(t,u,&q) && intersect(u,s,&r)){\n\t\t\tdouble a=area(p,q,r);\n\t\t\tif     (a>=1900000)\tputs(\"dai-kichi\");\n\t\t\telse if(a>=1000000)\tputs(\"chu-kichi\");\n\t\t\telse if(a>=100000)\tputs(\"kichi\");\n\t\t\telse if(a>EPS)\t\tputs(\"sho-kichi\");\n\t\t\telse\t\t\t\tputs(\"kyo\");\n\t\t}\n\t\telse\tputs(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\n// geometry library start\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n\tP proj(const P& p) const { double k=det(p)/norm2(); return P(x*k, y*k); }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\nint sign(double r) { return r < -EPS ? -1 : r > EPS ? 1 : 0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tP proj(const P& p) { return s + vec().proj(p - s); }\n\tint iLL(const L& l) const {\n\t\tif(sign(vec().det(l.vec()))) return 1;\n\t\tif(sign(vec().det(l.s - s))) return 0;\n\t\treturn -1;\n\t}\n\tbool iLS(const L& l) const { return sign(tri(s, t, l.s)) * sign(tri(s, t, l.t)) <= 0; } \n\tbool iSS(const L& l) const { return iLS(l) && l.iLS(*this); }\n\tP pLL(const L& l) const { return s + vec() * (l.s - s).det(l.vec()) / vec().det(l.vec()); }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) >= 0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n// geometry library end\nint x1, z1, x2, z2;\nL E[3];\nP T[3];\n\nint area[4] = { 1900000, 1000000, 100000, 0 };\nstring fort[4] = { \"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\" };\n\nvoid solve() {\n\trep(i,3) {\n\t\tif(!E[i].iSS(E[(i+1)%3])) {\n\t\t\tprintf(\"kyo\\n\");\n\t\t\treturn;\n\t\t}\n\t\tT[i] = E[i].pLL(E[(i+1)%3]);\n\t}\n\t\n\tdouble S = abs((T[1] - T[0]).det(T[2] - T[1])) * 0.5;\n\trep(i,4) {\n\t\tif(i==3) {\n\t\t\tif(sign(S - area[i]) > 0) {\n\t\t\t\tcout << fort[i] << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if(sign(S - area[i]) >= 0) {\n\t\t\tcout << fort[i] << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"kyo\\n\");\n}\n\nint main() {\n\tfor(;;) {\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tif(x1==0 && z1==0 && x2==0 && z2==0) break;\n\t\tE[0] = L(P(x1, z1), P(x2, z2));\n\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tE[1] = L(P(x1, z1), P(x2, z2));\n\n\t\tscanf(\"%d%d%d%d\", &x1, &z1, &x2, &z2);\n\t\tE[2] = L(P(x1, z1), P(x2, z2));\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)); s2 = abs(cross(a1,b2));\n\tif(s1<EPS && s2<EPS) return false;\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\tif(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x ||\n\t   p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\t//printf(\"\\t%lf\\n\",s);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000) puts(\"syo-kichi\");\n\t\telse if(s<1000000) puts(\"kichi\");\n\t\telse if(s<1900000) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\ntypedef long long int Int;\nconst Int N = 3;\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nInt ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npair<bool, P> crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return pair<bool, P>(0, m[0]); // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return pair<bool, P>(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nbool input(L &l){\n  Int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n  l = L(P(x1, y1), P(x2, y2));\n  return (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0);\n}\n\ndouble area(const G &P) {\n  double A = 0.0;\n  for (Int i = 0; i < P.size(); ++i) A += cross(curr(P, i), next(P, i));\n  return abs(A / 2.0);\n}\n\nstring solve(L ls[N]){\n  G g;\n  REP(i, N){\n    if(!intersectSS(ls[i], ls[(i + 1) % N])) continue;\n    else{\n      pair<bool, P> res = crosspointLL(ls[i], ls[(i + 1) % N]);\n      if(res.first) g.push_back(res.second);\n    }\n  }\n  double r = area(g);\n  if(g.size() < 3 || r <= 0) return \"kyo\";\n  if(r < 100000) return \"syo-kichi\";\n  if(r < 1000000) return \"kichi\";\n  if(r < 1900000) return \"chu-kichi\";\n  return \"dai-kichi\";\n}\n\nint main() {\n  L ls[N];\n  while(input(ls[0])){\n    FOR(i, 1, N) input(ls[i]);\n    cout <<solve(ls) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\ntypedef complex<double> P;\n \n// 2??????????????????????????????????????????\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2??????????????????????????????????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n \n// // ????????????a?????????????????????n1,n2????±???????\n// P n1 = a * P(0, 1);\n// P n2 = a * P(0, -1);\n \n// // ????????????a???????????????????????????un1,un2????±???????\n// P un1 = (a * P(0, +1)) / abs(a);\n// P un2 = (a * P(0, -1)) / abs(a);\n \n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n \n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n \n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n \n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n \n// ???c?????´???a,b???????????????????????? ???????????? WA?????????\n// int is_point_on_line(P a, P b, P c) {\n//   return EQ( cross(b-a, c-a), 0.0 );\n// }\n \n// ???c?????????a,b????????????????????????(1)\nint is_point_on_line(P a, P b, P c) {\n    return EQ( cross(b-a, c-a), 0.0 ) &&\n        (dot(b-a, c-a) > -EPS) &&\n        (dot(a-b, c-b) > -EPS);\n}\n \n// ???c?????????a,b????????????????????????(2)\n// |a-c| + |c-b| <= |a-b| ???????????????\n// int is_point_on_line(P a, P b, P c) {\n  // return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n// }\n// a??????b???????????£???, 1 -> ???, -1 -> ???, 2 -> a????????????, -2 -> b??????????\\\\??????, 0 -> ??????ab???????????¨\nint ccw(P a,P b, P c){\n    P d = b - a;\n    c -= a;\n    double cr = cross(d, c);\n    if(cr < -EPS){ return 1; }\n    if(cr > EPS){ return -1; }\n    if(dot(d, c) < -EPS){ return 2; }\n    if(norm(d) < norm(c) - EPS){ return -2; }\n    return 0;\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n \n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 &&\n\t\t   ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0;\n}\n \n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nP intersection_ls(P a1, P a2, P b1, P b2) {\n    P b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n\n    return a1 + (a2-a1) * t;\n}\n \n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n \n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\ntypedef pair<P,P> S;\n\nbool is_intersected(S a, S b){\n\tif(abs(ccw(a.F, a.S, b.F))!=1&&abs(ccw(a.F, a.S, b.S))!=1) return false;\n\tif(!is_intersected_ls(a.F, a.S, b.F, b.S)) return false;\n\treturn true;\n}\n\ndouble clac_area(P a, P b, P c){\n\tdouble aa = abs(a-b), bb = abs(b-c), cc = abs(c-a);\n\tdouble s = (aa + bb + cc) / 2;\n\treturn sqrt(s * (s-aa) * (s-bb) * (s-cc));\n}\n\n\nvoid mainmain(){\n\tdouble a,b,c,d;\n\twhile(cin>>a>>b>>c>>d){\n\t\tif(a==b&&b==c&&c==d&&a==0){\n\t\t\treturn;\n\t\t}\n\t\tvector<S> v(3);\n\t\tv[0] = {P(a,b),P(c,d)};\n\t\tcin>>a>>b>>c>>d;\n\t\tv[1] = {P(a,b),P(c,d)};\n\t\tcin>>a>>b>>c>>d;\n\t\tv[2] = {P(a,b),P(c,d)};\n\t\tbool ok = true;\n\t\trep(i,3){\n\t\t\tok &= is_intersected(v[i], v[(i+1)%3]);\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<P> w(3);\n\t\trep(i,3){\n\t\t\tw[i] = intersection_ls(v[i].F, v[i].S, v[(i+1)%3].F, v[(i+1)%3].S);\n\t\t}\n\t\trep(i,2){\n\t\t\tif(EQV(w[i], w[i+1])){\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble ans = clac_area(w[0], w[1], w[2]);\n\t\t// cout<<ans<<endl;\n\t\tstring s[] = {\"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\"};\n\t\tdouble sigma[] = {1900000.0, 1000000.0, 100000.0, 0};\n\t\trep(i,4){\n\t\t\tif(ans >= sigma[i]){\n\t\t\t\tcout<<s[i]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i==3){\n\t\t\t\tcout<<s[4]<<endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\nconst int N = 3;\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npair<bool, P> crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return pair<bool, P>(0, m[0]); // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return pair<bool, P>(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nbool input(L &l){\n  int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n  l = L(P(x1, y1), P(x2, y2));\n  return (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0);\n}\n\ndouble area(const G &P) {\n  double A = 0.0;\n  for (int i = 0; i < P.size(); ++i) A += cross(curr(P, i), next(P, i));\n  return abs(A / 2.0);\n}\n\nstring solve(L ls[N]){\n  G g;\n  REP(i, N){\n    if(!intersectSS(ls[i], ls[(i + 1) % N])) return \"kyo\";\n    else{\n      pair<bool, P> res = crosspointLL(ls[i], ls[(i + 1) % N]);\n      if(!res.first) return \"kyo\";\n      g.push_back(res.second);\n    }\n  }\n  double r = area(g);\n  if(r > 0 && r < 10000) return \"syo-kichi\";\n  else if(r < 1000000) return \"kichi\";\n  else if(r < 1900000) return \"chu-kichi\";\n  return \"dai-kichi\";\n}\n\nint main() {\n  L ls[N];\n  while(input(ls[0])){\n    FOR(i, 1, N) input(ls[i]);\n    cout <<solve(ls) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0)cout<<\"kichi\"<<endl;\n    else if(area>0.0)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const vector<Point>& polygon){\n  double area = 0;\n  for (int i = 0; i < polygon.size(); ++i) {\n    area += cross(polygon[i], polygon[(i+1) % polygon.size()]);\n  }\n  return area;\n}\n\nint main(){\n  int x1,y1,x2,y2;\n  while(~scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2)){\n    if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n    vector<Line> lines;\n    lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    \n    for(int i = 0; i < 2; i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    }\n\n    bool isok = true;\n    \n    vector<Point> polygon;\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        if(intersectSS(lines[i],lines[j])){\n          Point p = crosspoint(lines[i],lines[j]);\n          polygon.push_back(p);\n        }\n        else{\n          isok = false;\n          goto ng;\n        }\n      }\n    }\n  ng:;\n\n    double area = -1;\n    if(isok){\n      area = compute_area(polygon);\n    }\n\n    if(1900000.0 - EPS <= area){\n      printf(\"%s\\n\",\"dai-kichi\");\n    }\n    else if(1000000.0 - EPS <= area && area < 1900000.0){\n      printf(\"%s\\n\",\"chu-kichi\");\n    }\n    else if(100000.0 - EPS <= area && area < 1000000.0){\n      printf(\"%s\\n\",\"kichi\");\n    }\n    else if(0 - EPS <= area && area < 100000.0){\n      printf(\"%s\\n\",\"syo-kichi\");\n    }\n    else {\n      printf(\"%s\\n\",\"kyo\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (double a){return Point(x*a,y*a); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// ??´??? a1, a2 ??¨??´???b1, b2?????????????±???????\n// Verified: AOJ CGL_2_C.cpp\nP crossp_ll(P a1, P a2, P b1, P b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if( EQ(d1,0) && EQ(d2,0) ) return a1; // same line\n    if( EQ(d2,0) ) assert(false); // precondition not satisfied\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// ?????? a1, a2 ??¨?????? b1, b2 ???????????????\n// Verified: CGL_2_B: Intersection\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\ndouble area_n(const vector<P> &v) {\n    double ans = 0;\n    double x, y, z;\n    P init = v[0];\n    rep(i,2,v.size()) {\n        x = sqrt(norm(v[i] - init));\n        y = sqrt(norm(v[i-1] - init));\n        z = sqrt(norm(v[i] - v[i-1]));\n\n        double s = (x + y + z) / 2;\n        ans += sqrt(s * (s-x) * (s-y) * (s-z));\n    }\n    return ans;\n}\n\nsigned main() {\n    double x1, y1, x2, y2;\n    while(cin >> x1 >> y1 >> x2 >> y2) {\n        if(x1 == y1 && y1 == x2 && x2 == y2 && y2 == 0.0) break;\n        vector<L> ls; vector<P> ps;\n        ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        rep(i,0,2) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        }\n\n        bool ng = false;\n        rep(i,0,3) {\n            P a1 = ls[i].fr, a2 = ls[i].sc;\n            P b1 = ls[(i+1)%3].fr, b2 = ls[(i+1)%3].sc;\n            if(!isec_ss(a1, a2, b1, b2)) {ng = true; break;}\n            P temp = crossp_ll(a1, a2, b1, b2);\n            rep(k,0,ps.size()) {if(temp == ps[k]) {ng = true; break;}}\n            ps.push_back(temp);\n        }\n\n        if(ng) cout << \"kyo\" << endl;\n        else {\n            // double ans = fabs(cross(ps[0]-ps[1], ps[0]-ps[2]) / 2.0);\n            double ans = area_n(ps);\n            if(ans < 100000.0 + EPS) cout << \"syo-kichi\" << endl;\n            else if(ans < 1000000.0 + EPS) cout << \"kichi\" << endl;\n            else if(ans < 1900000.0 + EPS) cout << \"chu-kichi\" << endl;\n            else cout << \"dai-kichi\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool sameline(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  return (abs(A) < EPS && abs(B) < EPS) ; // same line\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  while(1) {\n    L ls[3];\n    bool fff = 0;\n    REP(i,3) {\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      if (!x1&&!y1&&!x2&&!y2) {\n        fff = 1;\n        break;\n      }\n      ls[i] = L(P(x1,y1), P(x2,y2));\n    }\n    if (fff) break;\n    \n    if (!intersectSS(ls[0], ls[1]) || !intersectSS(ls[1], ls[2]) || !intersectSS(ls[2],ls[0])\n        ||sameline(ls[0], ls[1]) ||sameline(ls[1], ls[2]) || sameline(ls[2], ls[0])) {\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    P cp[3];\n    REP(i,3) {\n      cp[i] = crosspoint(ls[i], ls[(i+1)%3]);\n//      cout << cp[i] << endl;\n    }\n    double S = abs(cross(cp[2]-cp[0], cp[1]-cp[0])) / 2;\n\n//    cout << S << endl;\n    if (S >= 1900000) cout << \"dai-kichi\" << endl;\n    else if (S >= 1000000) cout << \"chu-kichi\" << endl;\n    else if (S >= 100000) cout << \"kichi\" << endl;\n    else if (S > EPS) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nstring omikuji(const vector<segment>& segments) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tconst segment& s = segments[i], t = segments[(i + 1) % 3];\n\t\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\t\tif(abs(tmp) < EPS || !intersect(s, t))\n\t\t\treturn \"kyo\";\n\t}\n\n\tpolygon triangle;\n\tfor(int i = 0; i < 3; ++i)\n\t\ttriangle.push_back(crosspoint(segments[i], segments[(i + 1) % 3]));\n\n\tconst double area_of_triangle = area(triangle);\n\tif(area_of_triangle >= 1900000)\n\t\treturn \"dai-kichi\";\n\n\tif(area_of_triangle >= 1000000)\n\t\treturn \"chu-kichi\";\n\n\tif(area_of_triangle >= 100000)\n\t\treturn \"kichi\";\n\n\treturn \"syo-kichi\";\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y, x2, y2; cin >> x >> y >> x2 >> y2, (x | y | x2 | y2);) {\n\t\tvector<segment> segments;\n\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y >> x2 >> y2;\n\t\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\t}\n\n\t\tstring result = omikuji(segments);\n\t\tcout << result << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)); s2 = abs(cross(a1,b2));\n\tif(s1<EPS && s2<EPS) return false;\n\tif(s1<EPS) swap(s1,s2);\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\tif(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x ||\n\t   p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000) puts(\"syo-kichi\");\n\t\telse if(s<1000000) puts(\"kichi\");\n\t\telse if(s<1900000) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const Point &l,const Point &m){\n  return abs(cross(l,m)) / 2.0;\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nint main(){\n  int x1,y1,x2,y2;\n  while(~scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2)){\n    if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n    vector<Line> lines;\n    lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    \n    for(int i = 0; i < 2; i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    }\n\n    bool isok = true;\n    \n    vector<Point> polygon;\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        if(intersectSS(lines[i],lines[j])){\n          Point p = crosspoint(lines[i],lines[j]);\n          polygon.push_back(p);\n        }\n        else{\n          isok = false;\n          goto ng;\n        }\n      }\n    }\n  ng:;\n\n    sort(polygon.begin(),polygon.end());\n    \n    if(isok){\n      bool tmp = false;\n      for(int i=0;i<3;i++){\n        for(int j=i+1;j<3;j++){\n          if(!is_equal(polygon[i],polygon[j])){\n            tmp = true;\n            break;\n          }\n        }\n      }\n\n      isok = tmp;\n    }\n\n    double area = -1.0;\n    if(isok){\n      area = compute_area(polygon[1] - polygon[0],polygon[2] - polygon[0]);\n    }\n\n    if(1900000.0 <= area){\n      printf(\"%s\\n\",\"dai-kichi\");\n    }\n    else if(1000000.0 <= area && area < 1900000.0){\n      printf(\"%s\\n\",\"chu-kichi\");\n    }\n    else if(100000.0 <= area && area < 1000000.0){\n      printf(\"%s\\n\",\"kichi\");\n    }\n    else if(0.0 <= area && area < 100000.0){\n      printf(\"%s\\n\",\"syo-kichi\");\n    }\n    else {\n      printf(\"%s\\n\",\"kyo\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Triangle and Circle\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool on_edge(const Point&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\n\nusing namespace std;\n\nint main() {\n    double x1, y1, x2, y2;\n    while(cin >> x1 >> y1 >> x2 >> y2, x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0) {\n        Segment s1(x1, y1, x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s2(x1, y1, x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        Segment s3(x1, y1, x2, y2);\n\n        if((s1.intersect(s2) && s2.intersect(s3) && s3.intersect(s1)) && !s1.line().parallel(s2.line()) && !s2.line().parallel(s3.line()) && !s3.line().parallel(s1.line())) {\n            Polygon triangle;\n            triangle.add(s1.line().crosspoint(s2.line()));\n            triangle.add(s2.line().crosspoint(s3.line()));\n            triangle.add(s3.line().crosspoint(s1.line()));\n            if(triangle.vertex(0) == triangle.vertex(1) || triangle.vertex(1) == triangle.vertex(2) || triangle.vertex(2) == triangle.vertex(0)) cout << \"kyo\" << endl;\n            else if(triangle.area() >= 1900000.0) cout << \"dai-kichi\" << endl;\n            else if(triangle.area() >= 1000000.0) cout << \"chu-kichi\" << endl;\n            else if(triangle.area() >= 100000.0) cout << \"kichi\" << endl;\n            else cout << \"syo-kichi\" << endl;\n        } else {\n            cout << \"kyo\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cfloat>\n#include<cassert>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define EPS (1e-8)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nint main()\n{\n\tPoint p[3], q[3], x[3];\n    double S;\n\t\n    while (1){\n        for (int i = 0; i < 3; i++){\n\t\t\tint x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\t\n            if (i == 0 && x1 == 0 && x2 == 0 && y1 == 0 && y2 == 0) return (0);\n\t\t\t\n\t\t\tp[i] = Point(x1, y1); q[i] = Point(x2, y2);\n        }\n\t\t\n\t\tint k = 0;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\t\tif (!isIntersect(p[i], q[i], p[j], q[j])){\n\t\t\t\t\tprintf(\"kyo\\n\");\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tx[k++] = interpointS(p[i], q[i], p[j], q[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (x[0] == x[1] || x[1] == x[2] || x[0] == x[2]){\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tgoto next;\n\t\t}\n\t\t\n\t\tS = area(x[0], x[1], x[2]);\n\t\t\n\t\tif (S >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (S >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (S >= 100000) printf(\"kichi\\n\");\n\t\telse printf(\"syo-kichi\\n\");\n\t\t\n\t\tnext:;\n\t}\t\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nbool isequal(const P& a, const P& b)\n{\n\treturn a.real()+EPS > b.real() && a.real() < b.real()+EPS &&\n\t\t   a.imag()+EPS > b.imag() && a.imag() < b.imag()+EPS;\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS; // non-parallel\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main()\n{\n\tint x1,y1,x2,y2;\n\twhile(scanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2), (x1||y1||x2||y2))\n\t{\n\t\tvector<L> Lines;\n\t\tvector<P> xp;\n\t\tLines.push_back(L(P(x1,y1),P(x2,y2)));\n\t\tfor(int i=0; i<2; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2);\n\t\t\tLines.push_back(L(P(x1,y1),P(x2,y2)));\n\t\t}\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\tfor(int j=i+1; j<3; j++)\n\t\t{\n\t\t\tif(!intersectLL(Lines[i], Lines[j])) g=false;\n\t\t\tif(!intersectSS(Lines[i], Lines[j])) g=false;\n\t\t\t\n\t\t\tif(g)\n\t\t\t{\n\t\t\t\txp.push_back(crosspoint(Lines[i], Lines[j]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<xp.size(); i++)\n\t\tfor(int j=i+1; j<xp.size(); j++)\n\t\t{\n\t\t\tif(isequal(xp[i], xp[j])) g=false;\n\t\t}\n\t\t\n\t\tif(!g)\n\t\t{\n\t\t\tputs(\"kyo\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt=0;\n\t\tdouble ls[3];\n\t\tfor(int i=0; i<xp.size(); i++)\n\t\tfor(int j=i+1; j<xp.size(); j++)\n\t\t{\n\t\t\tls[cnt]=sqrt((xp[i].real()-xp[j].real())*(xp[i].real()-xp[j].real())+(xp[i].imag()-xp[j].imag())*(xp[i].imag()-xp[j].imag()));\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tdouble s=ls[0]+ls[1]+ls[2];\n\t\tdouble area=sqrt(s*(s-ls[0])*(s-ls[1])*(s-ls[2]));\n\t\t\n\t\tif(area < 100000) puts(\"syo-kichi\");\n\t\telse if(area < 1000000) puts(\"kichi\");\n\t\telse if(area < 1900000) puts(\"chu-kichi\");\n\t\telse\tputs(\"dai-kichi\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  if(!isIntersect(a1,a2,b1,b2))\n    {\n      return Point(-9993999,-9993999);\n    }\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(4);\n  p[0] = p1,p[1] = p2,p[2] = p3,p[3] = p[0];\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += (p[i].x - p[i+1].x)*(p[i].y+p[i+1].y);\n  return fabs(sum/2.0);\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n\n\n      if((c1 == c2 && c2 == c3) || !isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n     \n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-8\n\nstruct Point{\n  double x,y;\n  Point(double x = 0.0, double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x,y-p.y); }\n  Point operator * (double a){ return Point(x*a,y*a); }\n  Point operator / (double a){ return Point(x/a,y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nstruct Segment{\n  Vector p1,p2;\n  Segment(){}\n  Segment(Vector p1,Vector p2) : p1(p1),p2(p2) {}\n};\n\nbool intersectSS(const Segment &s,const Segment &t){\n  return (ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0) && \n         (ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0);\n}\n\nPoint getCrossPoint(Segment s,Segment t){\n  Vector b = t.p2 - t.p1;\n  double d1 = abs(cross(b,s.p1-t.p1));\n  double d2 = abs(cross(b,s.p2-t.p1));\n  if(d1 < EPS && d2 < EPS) return t.p1;\n  double d = d1 / (d1 + d2);\n  return s.p1+(s.p2-s.p1)*d;\n}\n\ndouble getArea(Point a,Point b,Point c){\n  return fabs(a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2;\n}\n\nSegment s[3];\nvoid solve(){\n  Point p1 = getCrossPoint(s[0],s[1]);\n  Point p2 = getCrossPoint(s[1],s[2]);\n  Point p3 = getCrossPoint(s[2],s[0]);\n  double S = getArea(p1,p2,p3);\n  if(S >= 1900000){\n    cout << \"dai-kichi\" << endl;\n  }else if(S >= 1000000){\n    cout << \"chu-kichi\" << endl;\n  }else if(S >= 100000){\n    cout << \"kichi\" << endl;\n  }else{\n    cout << \"syo-kichi\" << endl;\n  }\n}\n\nint main(){\n  while(true){\n    cin >> s[0].p1.x >> s[0].p1.y >> s[0].p2.x >> s[0].p2.y;\n    if(!s[0].p1.x && !s[0].p1.y && !s[0].p2.x && !s[0].p2.y) break;\n\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> s[i+1].p1.x >> s[i+1].p1.y >> s[i+1].p2.x >> s[i+1].p2.y;\n    }\n    if(intersectSS(s[0],s[1]) && intersectSS(s[1],s[2]) && intersectSS(s[2],s[0])){\n      solve();\n    }else{\n      cout << \"kyo\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { }};\nint ccw(P a, P b, P c) {b -= a; c -= a;if (cross(b, c) > 0)   return +1;if (cross(b, c) < 0)   return -1;if (dot(b, c) < 0) return +2;if (norm(b) < norm(c)) return -2;return 0;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nP crosspoint(const L &l, const L &m) {double A = cross(l[1] - l[0], m[1] - m[0]);double B = cross(l[1] - l[0], l[1] - m[0]);if (abs(A) < EPS && abs(B) < EPS) return m[0];return m[0] + B / A * (m[1] - m[0]);}\ndouble getArea(P a, P b , P c){\n\t\tb-=a, c-=a;\n\t\treturn fabs( b.real() * c.imag() - c.real() * b.imag() ) / 2.0\t; \n}\nint main(){\n\tdouble a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a+b+c+d != 0){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tdouble ret = 0;\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tret = getArea( crosspoint(one,two) , crosspoint(two,three) , crosspoint(one,three) );\n\t\t}\n\t\tif(ret == 0){\n\t\t\tcout << \"kyo\" << endl;\n\t\t}else if(ret < 100000){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else if(ret < 1000000){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret < 1900000){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nconst char* fortune[] = {\n\t\"dai-kichi\",\n\t\"chu-kichi\",\n\t\"kichi\",\n\t\"syo-kichi\",\n\t\"kyo\",\n};\n\ntemplate<class T> class Vector2\n{\npublic:\n\tint crossProduct( const Vector2& v )\n\t{\n\t\treturn x * v.y - v.x * y;\n\t}\n\n\tT x, y;\n};\n\nint main()\n{\n\tint x1, y1, x2, y2;\n\twhile( cin >> x1 >> y1 >> x2 >> y2 && ( x1 || y1 || x2 || y2 ) ){\n\t\tVector2<int> p[ 3 ][ 2 ];\n\t\tVector2<int> v[ 3 ];\n\t\tp[ 0 ][ 0 ].x = x1;\n\t\tp[ 0 ][ 0 ].y = y1;\n\t\tp[ 0 ][ 1 ].x = x2;\n\t\tp[ 0 ][ 1 ].y = y2;\n\t\tv[ 0 ].x = x2 - x1;\n\t\tv[ 0 ].y = y2 - y1;\n\t\tfor( int i = 1; i < 3; ++i ){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tp[ i ][ 0 ].x = x1;\n\t\t\tp[ i ][ 0 ].y = y1;\n\t\t\tp[ i ][ 1 ].x = x2;\n\t\t\tp[ i ][ 1 ].y = y2;\n\t\t\tv[ i ].x = x2 - x1;\n\t\t\tv[ i ].y = y2 - y1;\n\t\t}\n\n\t\tint result = 0;\n\t\tif( v[ 0 ].crossProduct( v[ 1 ] ) * v[ 1 ].crossProduct( v[ 2 ] ) * v[ 2 ].crossProduct( v[ 0 ] ) == 0 ){\n\t\t\tresult = 4;\n\t\t}else{\n\t\t\tVector2<double> e[ 3 ];\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tint a = i;\n\t\t\t\tint b = ( i + 1 ) % 3;\n\t\t\t\tint ax = p[ a ][ 0 ].x;\n\t\t\t\tint ay = p[ a ][ 0 ].y;\n\t\t\t\tint cx = p[ b ][ 0 ].x;\n\t\t\t\tint cy = p[ b ][ 0 ].y;\n\t\t\t\tint abx = v[ a ].x;\n\t\t\t\tint aby = v[ a ].y;\n\t\t\t\tint cdx = v[ b ].x;\n\t\t\t\tint cdy = v[ b ].y;\n\t\t\t\tdouble s = static_cast<double>( cdy * ( cx - ax ) - cdx * ( cy - ay ) )\n\t\t\t\t\t/ static_cast<double>( abx * cdy - cdx * aby );\n\t\t\t\tdouble t = static_cast<double>( aby * ( cx - ax ) - abx * ( cy - ay ) )\n\t\t\t\t\t/ static_cast<double>( abx * cdy - cdx * aby );\n\t\t\t\tif( s + EPS > 1.0 || s - EPS < 0.0 ){\n\t\t\t\t\tresult = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( t + EPS > 1.0 || t - EPS < 0.0 ){\n\t\t\t\t\tresult = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\te[ i ].x = p[ i ][ 0 ].x + s * v[ i ].x;\n\t\t\t\te[ i ].y = p[ i ][ 0 ].y + s * v[ i ].y;\n\t\t\t}\n\t\t\tif( result != 4 ){\n\t\t\t\tVector2<double> tmp;\n\t\t\t\ttmp.x = e[ 0 ].x;\n\t\t\t\ttmp.y = e[ 0 ].y;\n\t\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\t\te[ i ].x -= tmp.x;\n\t\t\t\t\te[ i ].y -= tmp.y;\n\t\t\t\t}\n\t\t\t\tdouble sq = fabs( e[ 1 ].x * e[ 2 ].y - e[ 2 ].x * e[ 1 ].y ) / 2;\n\t\t\t\tif( sq < EPS ){\n\t\t\t\t\tresult = 4;\n\t\t\t\t}else if( sq < 100000 ){\n\t\t\t\t\tresult = 3;\n\t\t\t\t}else if( sq < 1000000 ){\n\t\t\t\t\tresult = 2;\n\t\t\t\t}else if( sq < 1900000 ){\n\t\t\t\t\tresult = 1;\n\t\t\t\t}else{\n\t\t\t\t\tresult = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fortune[ result ] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    c -= a;\n    b -= a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isIntersect(L s1, L s2){\n    return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n             ccw(s2.first,s2.second,s2.first) * ccw(s2.first,s2.second,s1.second) <= 0);\n}\n\nP crossPoint(L l, L m){\n    double A = cross(l.second - l.first, m.second - m.first);\n    double B = cross(l.second - l.first, l.second - m.first);\n    if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n    else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n    double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum / 2.0);\n}\n\nstring ans(vector<P> v){\n    double a = area(v);\n    if(a < EPS) return \"kyo\";\n    if(a < 100000.0) return \"syo-kichi\";\n    if(a < 1000000.0) return \"kichi\";\n    if(a < 1900000.0) return \"chi-kichi\";\n    return \"dai-kichi\";\n}\n\nint main(){\n    double x1,y1,x2,y2;\n    while(cin >> x1 >> y1 >> x2 >> y2 && (x1||y1||x2||y2)){\n        L v[3];\n        vector<P> p(3);\n        bool f = false;\n        v[0] = L(P(x1,y1),P(x2,y2));\n        for(int i=1;i<3;i++) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            v[i] = L(P(x1,y1),P(x2,y2));\n            if(!isIntersect(v[0],v[i])) f = true;\n            else p[i-1] = crossPoint(v[0],v[i]);\n        }\n        if(!isIntersect(v[1],v[2])) f = true;\n        else p[2] = crossPoint(v[1],v[2]);\n\n        for(int i=0;i<3;i++){\n            for(int j=i+1;j<3;j++){\n                if(abs(p[i]-p[j]) < EPS) f = true;\n            }\n        }\n\n        if(f) cout << \"kyo\" << endl;\n        else cout << ans(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nstruct Segment{\n  Point p1, p2;\n};\n\ntypedef Segment Line;\n\nconst double EPS = 1e-10;\n\nbool equals(double a, double b){\n  return abs(a-b) < EPS;\n}\n\ndouble dot(Point a, Point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n  Point base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nmain(){\n  double a, b, c, d;\n  while(cin >> a >> b >> c >> d && (a || b || c || d)){\n    Segment s1, s2, s3;\n    s1.p1.real() = a;\n    s1.p1.imag() = b;\n    s1.p2.real() = c;\n    s1.p2.imag() = d;\n    cin >> a >> b >> c >> d;\n    s2.p1.real() = a;\n    s2.p1.imag() = b;\n    s2.p2.real() = c;\n    s2.p2.imag() = d;\n    cin >> a >> b >> c >> d;\n    s3.p1.real() = a;\n    s3.p1.imag() = b;\n    s3.p2.real() = c;\n    s3.p2.imag() = d;\n    if(!isIntersect(s1, s2) || !isIntersect(s2, s3) || !isIntersect(s3, s1)){\n      cout << \"kyo\" << endl;\n    }else{\n      Point a, b, c;\n      a = getCrossPoint(s1, s2);\n      b = getCrossPoint(s2, s3);\n      c = getCrossPoint(s3, s1);\n      b.real() -= a.real();\n      b.imag() -= a.imag();\n      c.real() -= a.real();\n      c.imag() -= a.imag();\n      double s = abs(b.real()*c.imag() - b.imag()*c.real()) / 2.0;\n      if(s > 1900000.0 - EPS) cout << \"dai-kichi\" << endl;\n      else if(s > 1000000.0 - EPS) cout << \"chu-kichi\" << endl;\n      else if(s > 100000.0 - EPS) cout << \"kichi\" << endl;\n      else if(s > 0 + EPS) cout << \"syo-kichi\" << endl;\n      else cout << \"kyo\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) < EPS &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) < EPS );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n  \n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n \n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n  \n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n    return sqrt(norm(p));\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<=0)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<=0);\n}\n\nbool intersectLL(Line l,Line m){\n\treturn fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //平行でない\n\t\t\tfabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //同一の線\n}\n\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5;\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea;\n}\n \n\n\nPoint crosspoint(Line l,Line m){\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nint main(){\n\twhile(true){\n        bool endflg = false;\n        Line l[3];\n        rep(i,3){\n            double x1,y1,x2,y2;\n            scanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n            if(i == 0){\n                if(x1 == 0.0 && y1 == 0.0 && x2 == 0.0 && y2 == 0.0){\n                    endflg = true;\n                    break;\n                }\n            }\n            l[i].PB(Point(x1,y1));\n            l[i].PB(Point(x2,y2));\n        }\n        if(endflg)break;\n        Point p[3];\n        p[0] = crosspoint(l[0],l[1]);\n        p[1] = crosspoint(l[0],l[2]);\n        p[2] = crosspoint(l[1],l[2]);\n        if(!(intersectSS(l[0],l[1])&&intersectSS(l[0],l[2])&&intersectSS(l[1],l[2]))){\n        \tputs(\"kyo\");\n        \tcontinue;\n        }\n        double area = fabs(TriangleArea(p[0],p[1],p[2]));\n        if(area-1900000>EPS)puts(\"dai-kichi\");\n        else if(area-1000000>EPS)puts(\"chu-kichi\");\n        else if(area-100000>EPS)puts(\"kichi\");\n        else if(area>EPS)puts(\"syo-kichi\");\n        else puts(\"kyo\");\n        //printf(\"%.10lf\\n\",area);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(4);\n  p[0] = p1,p[1] = p2,p[2] = p3,p[3] = p[0];\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += (p[i].x - p[i+1].x)*(p[i].y+p[i+1].y);\n  return fabs(sum/2.0);\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(true)\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(x1+y1+x2+y2 == 0)\n\tbreak;\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n    \n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) < EPS &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) < EPS );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n \n \tPoint operator / (double k){\n \t\treturn Point(x/k,y/k);\n \t}\n\n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n \n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n \ndouble pabs(Point p){\n    return sqrt(norm(p));\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<=0)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<=0);\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n\tb = b - a;\n\tc = c - a;\n\treturn fabs(cross(b,c))*0.5;\n}\n\ndouble VertexArea(Polygon v){\n\tdouble subArea = 0.0;\n\trep(i,v.size()-1){\n\t\tsubArea += TriangleArea(v[0],v[i],v[i+1]);\n\t}\n}\n\nPoint crosspoint(Line l,Line m){\n\tif(intersectSS(l,m) == false)return Point(INF,INF);\n\treturn m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n\nint main(){\n\twhile(true){\n\t\tbool endflg = false;\n\t\tLine l[3];\n\t\trep(i,3){\n\t\t\tdouble x1,y1,x2,y2;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n\t\t\tif(i == 0){\n\t\t\t\tif(x1 == 0.0 && y1 == 0.0 && x2 == 0.0 && y2 == 0.0){\n\t\t\t\t\tendflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tl[i].PB(Point(x1,y1));\n\t\t\tl[i].PB(Point(x2,y2));\n\t\t}\n\t\tif(endflg)break;\n\t\tPoint p[3];\n\t\tp[0] = crosspoint(l[0],l[1]);\n\t\tp[1] = crosspoint(l[0],l[2]);\n\t\tp[2] = crosspoint(l[1],l[2]);\n\t\tdouble area = TriangleArea(p[0],p[1],p[2]);\n\t\tif(area-1900000>-EPS)puts(\"dai-kichi\");\n\t\telse if(area-1000000>-EPS)puts(\"chu-kichi\");\n\t\telse if(area-100000>-EPS)puts(\"kichi\");\n\t\telse if(area>-EPS)puts(\"syo-kichi\");\n\t\telse puts(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// ??´??? a1, a2 ??¨??´???b1, b2?????????????±???????\n// Verified: AOJ CGL_2_C.cpp\nP crossp_ll(P a1, P a2, P b1, P b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if( EQ(d1,0) && EQ(d2,0) ) return a1; // same line\n    if( EQ(d2,0) ) assert(false); // precondition not satisfied\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\n// ????§???¢????¬????????????¢???\ndouble area_n(const vector<P> &v) {\n    double ans = 0;\n    double x, y, z;\n    P init = v[0];\n    rep(i,2,v.size()) {\n        x = sqrt(norm(v[i] - init));\n        y = sqrt(norm(v[i-1] - init));\n        z = sqrt(norm(v[i] - v[i-1]));\n\n        double s = (x + y + z) / 2;\n        ans += sqrt(s * (s-x) * (s-y) * (s-z));\n    }\n    return ans;\n}\n\n// 2??´?????????????????? (?????????0??§???????????¨)\nbool is_parallel(P a1, P a2, P b1, P b2) {\n    // printf(\"cross: %.12lf\\n\", cross(a1-a2, b1-b2));\n    return EQ( cross(a1-a2, b1-b2), 0.0);\n}\n\nsigned main() {\n    double x1, y1, x2, y2;\n    while(cin >> x1 >> y1 >> x2 >> y2) {\n        if(x1 == y1 && y1 == x2 && x2 == y2 && y2 == 0.0) break;\n        vector<L> ls; vector<P> ps;\n        ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        rep(i,0,2) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        }\n\n        bool ng = false;\n        rep(i,0,3) {\n            P a1 = ls[i].fr, a2 = ls[i].sc;\n            P b1 = ls[(i+1)%3].fr, b2 = ls[(i+1)%3].sc;\n            if(is_parallel(a1, a2, b1, b2)) {ng = true; break;}\n            P temp = crossp_ll(a1, a2, b1, b2);\n            // printf(\"crosspoint: (%.12lf, %.12lf)\\n\", temp.X, temp.Y);\n            rep(k,0,ps.size()) {if(temp == ps[k]) {ng = true; break;}}\n            ps.push_back(temp);\n        }\n\n        double ans = area_n(ps);\n        if(ng) cout << \"kyo\" << endl;\n        else if(ans < 100000.0 + EPS) cout << \"syo-kichi\" << endl;\n        else if(ans < 1000000.0 + EPS) cout << \"kichi\" << endl;\n        else if(ans < 1900000.0 + EPS) cout << \"chu-kichi\" << endl;\n        else cout << \"dai-kichi\" << endl;\n        // printf(\"debug: ans = %.12lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) < EPS &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) < EPS );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\ndouble cross(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4) {\n\tdouble m;\n\tm=(x4-x3)*(y2-y1)-(x2-x1)*(y4-y3);\n\tif (m==0) return -1;\n\treturn ((x1-x3)*(y4-y3)-(x4-x3)*(y1-y3))/m;\n }\n\nint main() {\n  double a,s,sx[3],sy[3],ex[3],ey[3],cx[3],cy[3],hx,lx,hy,ly;\n  int i,k;\n  while(true) {\n\tlx=ly=9999999; hx=hy=-lx;  \n   for (i=0;i<3;i++) {\n\t      cin >> sx[i] >> sy[i] >> ex[i] >> ey[i];\n\t      if (sx[i]==0 &&  sy[i]==0 && ex[i]==0 && ey[i]==0) return 0; \n\t      }\n\t   for (i=0;i<3;i++) {\n\t\tk=(i+1) % 3;\n\t\ts=cross(sx[i],sy[i],ex[i],ey[i],sx[k],sy[k],ex[k],ey[k]);\n\t\tif (s<0 || s>1) break;\n\t\tcx[i]=sx[i]+s*(ex[i]-sx[i]); cy[i]=sy[i]+s*(ey[i]-sy[i]);\n\t\thx=hx<cx[i] ? cx[i]:hx; lx=lx>cx[i] ? cx[i]:lx;\n\t\thy=hy<cy[i] ? cy[i]:hy; ly=ly>cy[i] ? cy[i]:ly;\n\t}\n\tif (i!=3) { cout << \"kyo\" << endl; continue;}\n\tfor (s=0,i=0;i<3;i++) s+=fabs(cx[i]-cx[(i+1) % 3])*fabs(cy[i]-cy[(i+1) % 3]);\n\ta=(hx-lx)*(hy-ly)-s/2;\n\tif (a>=1900000) cout << \"dai-kichi\"; else if (a>=1000000) cout << \"chu-kichi\";\n\telse if (a>=100000) cout << \"kichi\"; else if (a>0) cout << \"syo-kichi\";\n\telse cout << \"kyo\";\n\tcout << endl; \n } \n  return 0;\n}\t\t "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1))/2; s2 = abs(cross(a1,b2))/2;\n\tif(s1<EPS && s2<EPS) return false;\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\tif(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x || p.x<min(m.a.x,m.b.x) || max(m.a.x,m.b.x)<p.x ||\n\t   p.y<min(l.a.y,l.b.y) || max(l.a.y,l.b.y)<p.y || p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\t//printf(\"\\t%lf\\n\",s);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000) puts(\"syo-kichi\");\n\t\telse if(s<1000000) puts(\"kichi\");\n\t\telse if(s<1900000) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\nnamespace FP {\n    bool isZero(double x) {\n        return (abs(x) <= EPS);\n    }\n};\n\nstruct Point {\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << \"(\" << x << \",\" << y << \")\";\n        return os.str();\n    }\n    bool operator<(const Point &o) const {\n        return x == o.x ? y < o.y : x < o.x;\n    }\n    bool operator==(const Point &o) const {\n        return x == o.x && y == o.y;\n    }\n    Point operator+(const Point &o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator-(const Point &o) const {\n        return Point(x-o.x, y-o.y);\n    }\n    Point operator*(const double m) const {\n        return Point(x*m, y*m);\n    }\n    Point operator/(const double d) const {\n        return Point(x/d, y/d);\n    }\n    // 外積\n    double cross(const Point &o) const {\n        return x * o.y - y * o.x;\n    }\n    // 内積\n    double dot(const Point &o) const {\n        return x * o.x + y * o.y;\n    }\n    // ベクトルがx軸となす角\n    double atan() const {\n        return atan2(y, x);\n    }\n    // ベクトルの長さの二乗\n    double norm() const {\n        return dot(*this);\n    }\n};\n\nstruct Line {\n    double a, b, c;\n    Line(double a=0, double b=0, double c=0) :\n        a(a), b(b), c(c) {}\n    Point intersectionPoint(const Line &l) const {\n        double d = a * l.b - l.a * b;\n        if (!intersects(l)) {\n            throw string(\"The 2 Lines are parallel\");\n        }\n        double x = (b * l.c - l.b * c) / d;\n        double y = (l.a * c - a * l.c) / d;\n        return Point(x, y);\n    }\n    bool intersects(const Line &l) const {\n        return !FP::isZero(a * l.b - l.a * b);\n    }\n    string to_s() {\n        ostringstream os;\n        os << a << ' ' << b << ' ' << c;\n        return os.str();\n    }\n    static Line fromPoints(const Point &a, const Point &b) {\n        double dx = b.x - a.x;\n        double dy = b.y - a.y;\n        return Line(dy, -dx, dx * a.y - dy * a.x);\n    }\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n        return fromPoints(Point(x1, y1), Point(x2, y2));\n    }\n};\n\nstruct LineSegment {\n    Point start, end;\n    LineSegment(const Point &start, const Point &end) : start(start), end(end) {}\n    LineSegment(double x1=0, double y1=0, double x2=0, double y2=0) : start(Point(x1, y1)), end(Point(x2, y2)) {}\n    string to_s() {\n        ostringstream os;\n        os << '(' << start.x << ',' << start.y << ')' << '-' << '(' << end.x << ',' << end.y << ')' << endl;\n        return os.str();\n    }\n    Line toLine() const {\n        return Line::fromPoints(start, end);\n    }\n    bool intersects(const Line &l) const {\n        double t1 = l.a * start.x + l.b * start.y + l.c;\n        double t2 = l.a * end.x + l.b * end.y + l.c;\n        return t1 * t2 <= 0;\n    }\n    bool intersects(const LineSegment &s) const {\n        return intersects(s.toLine()) && s.intersects(toLine());\n    }\n    Point intersectionPoint(const LineSegment &s) const {\n        if (!intersects(s)) {\n            throw \"The 2 line segments are parallel\";\n        }\n        return (toLine().intersectionPoint(s.toLine()));\n    }\n};\n\nint main() {\n    Point s, e;\n    while (cin >> s.x >> s.y >> e.x >> e.y) {\n        if (s.x == 0 && s.y == 0 && e.x == 0 && e.y == 0) break;\n\n        LineSegment seg[3];\n        seg[0] = LineSegment(s, e);\n        for (int i = 1; i < 3; i++) {\n            cin >> s.x >> s.y >> e.x >> e.y;\n            seg[i] = LineSegment(s, e);\n        }\n\n        if (!seg[0].intersects(seg[1]) || !seg[1].intersects(seg[2])\n                                       || !seg[2].intersects(seg[0])) {\n            cout << \"kyo\" << endl;\n            break;\n        }\n\n        Point vertex[3];\n        vertex[0] = seg[0].intersectionPoint(seg[1]);\n        vertex[1] = seg[1].intersectionPoint(seg[2]);\n        vertex[2] = seg[2].intersectionPoint(seg[0]);\n        if (vertex[0] == vertex[1] && vertex[1] == vertex[2]) {\n            cout << \"kyo\" << endl;\n            break;\n        }\n        \n        double area = abs((vertex[1] - vertex[0]).cross(vertex[2] - vertex[0]) / 2.0);\n//        cout << area << endl;\n        if (area < 100000) {\n            cout << \"syo-kichi\" << endl;\n        } else if (area < 1000000) {\n            cout << \"kichi\" << endl;\n        } else if (area < 1900000) {\n            cout << \"chu-kichi\" << endl;\n        } else {\n            cout << \"dai-kichi\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/22 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nbool kousa(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tif(((x1-x2)*(y3-y1)+(y1-y2)*(x1-x3))*((x1-x2)*(y4-y1)+(y1-y2)*(x1-x4))<0\n\t &&((x3-x4)*(y1-y3)+(y3-y4)*(x3-x1))*((x3-x4)*(y2-y3)+(y3-y4)*(x3-x2))<0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\ndouble koutenX(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tint bunbo = (x1-x2)*(y3-y4)-(x3-x4)*(y1-y2);\n\tint bunsi = (x3-x4)*(x1*y2-x2*y1)-(x1-x2)*(x3*y4-x4*y3);\n\n\treturn (double)bunsi/(double)bunbo;\n}\n\ndouble koutenY(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tint bunbo = (x1-x2)*(y3-y4)-(x3-x4)*(y1-y2);\n\tint bunsi = (y3-y4)*(x1*y2-x2*y1)-(y1-y2)*(x3*y4-x4*y3);\n\n\treturn (double)bunsi/(double)bunbo;\n}\n\nint main()\n{\n\twhile(true){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif(x1==0&&y1==0&&x2==0&&y2==0)\n\t\t\tbreak;\n\n\t\tint x3, y3, x4, y4;\n\t\tcin >> x3 >> y3 >> x4 >> y4;\n\t\tint x5, y5, x6, y6;\n\t\tcin >> x5 >> y5 >> x6 >> y6;\n\n\t\tif(kousa(x1, y1, x2, y2, x3, y3, x4, y4)==false\n\t\t ||kousa(x3, y3, x4, y4, x5, y5, x6, y6)==false\n\t\t ||kousa(x5, y5, x6, y6, x1, y1, x2, y2)==false){\n\t\t\tcout << \"kyo\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble X1 = koutenX(x1, y1, x2, y2, x3, y3, x4, y4);\n\t\tdouble Y1 = koutenY(x1, y1, x2, y2, x3, y3, x4, y4);\n\t\tdouble X2 = koutenX(x3, y3, x4, y4, x5, y5, x6, y6);\n\t\tdouble Y2 = koutenY(x3, y3, x4, y4, x5, y5, x6, y6);\n\t\tdouble X3 = koutenX(x5, y5, x6, y6, x1, y1, x2, y2);\n\t\tdouble Y3 = koutenY(x5, y5, x6, y6, x1, y1, x2, y2);\n\n\t\tdouble S = (X1*Y2+X2*Y3+X3*Y1-Y1*X2-Y2*X3-Y3*X1)/2.0;\n\t\tif(S<0.0)\n\t\t\tS *= -1.0;\n\n\t\t     if(S>=1900000.0)\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\telse if(S>=1000000.0)\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\telse if(S>= 100000.0)\n\t\t\tcout << \"kichi\" << endl;\n\t\telse if(S>=      0.0)\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\telse\n\t\t\tcout << \"kyo\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>a>>b>>c>>d,a|b|c|d){\n\t\tvector<L>l;\n\t\tl.pb(L(P(a,b),P(c,d)));\n\t\trep(i,2){\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tl.pb(L(P(a,b),P(c,d)));\n\t\t}\n\t\tG g;\n\t\trep(i,3)if(intersectSS(l[i],l[(i+1)%3])&&!para(l[i],l[(i+1)%3])){\n\t\t\tg.pb(crosspointSS(l[i],l[(i+1)%3]));\n\t\t}\n\t\tif(g.size()!=3){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble ar=area(g);\n\t\tif(abs(ar)<EPS){\n\t\t\tcout<<\"kyo\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(ar<100000)cout<<\"syo-kichi\"<<endl;\n\t\telse if(ar<1000000)cout<<\"kichi\"<<endl;\n\t\telse if(ar<1900000)cout<<\"chu-kichi\"<<endl;\n\t\telse cout<<\"dai-kichi\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// ??´??? a1, a2 ??¨??´???b1, b2?????????????±???????\n// Verified: AOJ CGL_2_C.cpp\nP crossp_ll(P a1, P a2, P b1, P b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if( EQ(d1,0) && EQ(d2,0) ) return a1; // same line\n    if( EQ(d2,0) ) assert(false); // precondition not satisfied\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\n// ????§???¢????¬????????????¢???\ndouble area_n(const vector<P> &v) {\n    double ans = 0;\n    double x, y, z;\n    P init = v[0];\n    rep(i,2,v.size()) {\n        x = sqrt(norm(v[i] - init));\n        y = sqrt(norm(v[i-1] - init));\n        z = sqrt(norm(v[i] - v[i-1]));\n\n        double s = (x + y + z) / 2;\n        ans += sqrt(s * (s-x) * (s-y) * (s-z));\n    }\n    return ans;\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// ?????? a1, a2 ??¨?????? b1, b2 ???????????????\n// Verified: CGL_2_B: Intersection\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\nsigned main() {\n    double x1, y1, x2, y2;\n    while(cin >> x1 >> y1 >> x2 >> y2) {\n        if(x1 == y1 && y1 == x2 && x2 == y2 && y2 == 0.0) break;\n        vector<L> ls; vector<P> ps;\n        ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        rep(i,0,2) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        }\n\n        bool ng = false;\n        rep(i,0,3) {\n            P a1 = ls[i].fr, a2 = ls[i].sc;\n            P b1 = ls[(i+1)%3].fr, b2 = ls[(i+1)%3].sc;\n            if(!isec_ss(a1, a2, b1, b2)) {ng = true; break;}\n            P temp = crossp_ll(a1, a2, b1, b2);\n            // printf(\"crosspoint: (%.12lf, %.12lf)\\n\", temp.X, temp.Y);\n            rep(k,0,ps.size()) {if(temp == ps[k]) {ng = true; break;}}\n            ps.push_back(temp);\n        }\n\n        double ans = area_n(ps);\n        if(ng) cout << \"kyo\" << endl;\n        else if(ans < 100000.0 + EPS) cout << \"syo-kichi\" << endl;\n        else if(ans < 1000000.0 + EPS) cout << \"kichi\" << endl;\n        else if(ans < 1900000.0 + EPS) cout << \"chu-kichi\" << endl;\n        else cout << \"dai-kichi\" << endl;\n        // printf(\"debug: ans = %.12lf\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n  \n#define EPS (1e-9)\n  \nusing namespace std;\n  \nbool eq(double a, double b)\n{\n    return (fabs(b - a) <= EPS);\n}\n  \nbool getP(int x1, int y1, int x2, int y2, int p1, int q1, int p2, int q2, double *r1, double *r2)\n{\n    int D = (x2 - x1) * (q2 - q1) - (y2 - y1) * (p2 - p1);\n    if (D == 0) return (false);\n      \n    double r, s;\n      \n    r = ((q2 - q1) * (p1 - x1) - (p2 - p1) * (q1 - y1)) / (double)D;\n    s = ((y2 - y1) * (p1 - x1) - (y2 - y1) * (q1 - y1)) / (double)D;\n    //printf(\"%lf %lf\\n\", r, s);\n    if (0 <= r + EPS && r - EPS <= 1 &&\n        0 <= s + EPS && s - EPS <= 1){\n        *r1 = x1 + r * (x2 - x1);\n        *r2 = y1 + r * (y2 - y1);\n        return (true);\n    }\n      \n    return (false);\n}\n  \nint main()\n{\n    int x1[3], y1[3], x2[3], y2[3];\n    double x3[3], y3[3];\n      \n    while (1){\n        for (int i = 0; i < 3; i++){\n            scanf(\"%d %d %d %d\", x1 + i, y1 + i, x2 + i, y2 + i);\n            if (i == 0 && x1[i] == 0 && x2[i] == 0 && y1[i] == 0 && y2[i] == 0) return (0);\n        }\n          \n        int k = 0;\n        for (int i = 0; i < 3; i++){\n            for (int j = i + 1; j < 3; j++){\n                if (!getP(x1[i], y1[i], x2[i], y2[i],\n                          x1[j], y1[j], x2[j], y2[j],\n                          &x3[k], &y3[k])){\n                          printf(\"kyo\\n\");\n                          goto ng;\n                }\n                k++;\n            }\n        }\n          \n        for (int i = 0; i < 3; i++) for (int j = i + 1; j < 3; j++) if (eq(x3[i], x3[j]) && eq(y3[i], y3[j])){\n            printf(\"kyo\\n\"); goto ng;\n        }\n        x3[0] -= x3[2]; x3[1] -= x3[2];\n        y3[0] -= y3[2]; y3[1] -= y3[2];\n          \n        double S;\n          \n        S = 0.5 * fabs(x3[0] * y3[1] - y3[0] * x3[1]);\n          \n        if (eq(S, 0)) printf(\"kyo\\n\");\n        else if (S + EPS >= 1900000) printf(\"dai-kichi\\n\");\n        else if (S + EPS >= 1000000) printf(\"chu-kichi\\n\");\n        else if (S + EPS >= 100000) printf(\"kichi\\n\");\n        else printf(\"syo-kichi\\n\");\n          \n        ng:;\n    }\n      \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n        if(isParallel(a,b)||isParallel(b,c)||isParallel(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getDistanceSS(a,b));\n        g.push_back(getDistanceSS(b,c));\n        g.push_back(getDistanceSS(c,a));\n\n        if(equalsv(g[0],g[1])&&equalsv(g[1],g[2])&&equalsv(g[2],g[0])){\n            puts(\"kyo\");\n            continue;\n        }\n        double x=area(g);\n        if(x<100000)puts(\"syo-kichi\");\n        else if(x<1000000)puts(\"kichi\");\n        else if(x<1900000)puts(\"chu-kichi\");\n        else puts(\"dai-kichi\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(true)\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(x1+y1+x2+y2 == 0)\n\tbreak;\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n    \n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        double s=area(g);\n        string res;\n        if (s - 1900000 > -EPS) res = \"dai-kichi\";\n        else if (s - 1000000 > -EPS) res = \"chu-kichi\";\n        else if (s - 100000 > -EPS) res = \"kichi\";\n        else if (s > 0) res = \"syo-kichi\";\n        else res = \"kyo\";\n        cout << res << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\ndouble areaPol(vector<point> t){\n  t.push_back(t[0]);\n  int tsz=t.size();\n  double area=0;\n  for(int i=0;i<tsz-1;i++){\n    area+=(t[i].x-t[i+1].x)*(t[i].y+t[i+1].y);\n  }\n  return abs(area)/2.0;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      vector<point>p;\n      for(int i=0;i<2;i++)\n\tp.push_back(intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b));\n      p.push_back(intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b));\n\n      double res=areaPol(p);\n      if(res>=1900000)cout <<\"dai-kichi\"<<endl;\n      else if(res>=1000000 && res <1900000)cout <<\"chu-kichi\"<<endl;\n      else if(res>=100000 && res<1000000)cout <<\"kichi\"<<endl;\n      else if(res>0 && res<100000)cout << \"syo-kichi\"<<endl;\n      else cout <<\"kyo\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\n\n#define EPS (1e-10)\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn\n\t\t( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn a1 + (a2-a1) * t;\n}\n\ndouble area(vector<P> v){\n\tint n = v.size();\n\tdouble res = 0.0;\n\n\tfor(int i=0;i<n;i++){\n\t\tres += cross(v[i],v[(i+1)%n]);\n\t}\n\treturn fabs(res)/2;\n}\n\nint main(void){\n\tP s[3],g[3];\n\n\twhile(1){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>s[i].real()>>s[i].imag()>>g[i].real()>>g[i].imag();\n\t\t\tif(s[i] == P(0,0) && g[i] == P(0,0)) return 0;\n\t\t}\n\n\t\tif(!is_intersected_ls(s[0],g[0],s[1],g[1]) ||\n\t\t\t !is_intersected_ls(s[1],g[1],s[2],g[2]) ||\n\t\t\t !is_intersected_ls(s[2],g[2],s[0],g[0]))\n\t\t\tcout<<\"kyo\\n\";\n\t\telse{\n\t\t\tvector<P> v;\n\t\t\tv.push_back(intersection_ls(s[0],g[0],s[1],g[1]));\n\t\t\tv.push_back(intersection_ls(s[1],g[1],s[2],g[2]));\n\t\t\tv.push_back(intersection_ls(s[2],g[2],s[0],g[0]));\n\n\t\t\tdouble a = area(v);\n\t\t\tif(a >= 1900000) cout<<\"dai-kichi\\n\";\n\t\t\telse if(a >= 1000000) cout<<\"chu-kichi\\n\";\n\t\t\telse if(a >= 100000) cout<<\"kichi\\n\";\n\t\t\telse if(a > 0) cout<<\"syo-kichi\\n\";\n\t\t\telse cout<<\"kyo\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return P(11111,11111);  // same line\n  if (EQ(d2, 0)) return P(11111,11111);   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += abs(cross(ps[i], ps[(i+1) % ps.size()]));\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=abs(area(v));\n      rep(i,3)if(v[i].X==v[i].Y&&v[i].X==11111)goto L;\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else if(are>=0)cout<<\"syo-kichi\"<<endl;\n      else{\n        L:;\n        cout<<\"kyo\"<<endl;\n      }\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(const Point &cc,double rr) : c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", \"M sessuru L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ndouble area(const Point &a,const Point &b,const Point &c){\n\treturn abs(cross(b-a,c-a))/2;\n}\n\ndouble area(const Polygon &pl){\n\tint n=pl.size();\n\tdouble a=0;\n\tfor(int i=0;i<n;i++)\ta+=cross(pl[i],pl[(i+1)%n]);\n\treturn abs(a)/2;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\twhile(1){\n\t\tPoint a,b,c,d,e,f;\n\t\tscanf(\"%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y);\n\t\tscanf(\"%lf%lf%lf%lf\",&c.x,&c.y,&d.x,&d.y);\n\t\tscanf(\"%lf%lf%lf%lf\",&e.x,&e.y,&f.x,&f.y);\n\t\tif(a.x==0 && a.y==0 && b.x==0 && b.y==0)\tbreak;\n\t\tSegment s(a,b),t(c,d),u(e,f);\n\t\tPoint p,q,r;\n\t\tif(intersect(s,t,&p) && intersect(t,u,&q) && intersect(u,s,&r)){\n\t\t\tdouble a=area(p,q,r);\n\t\t\tif     (a>1900000-EPS)\tputs(\"dai-kichi\");\n\t\t\telse if(a>1000000-EPS)\tputs(\"chu-kichi\");\n\t\t\telse if(a>100000-EPS)\tputs(\"kichi\");\n\t\t\telse if(a>EPS)\t\tputs(\"syo-kichi\");\n\t\t\telse\t\t\t\tputs(\"kyo\");\n\t\t}\n\t\telse\tputs(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-8\n\nstruct Point{\n  double x,y;\n  Point(double x = 0.0, double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x,y-p.y); }\n  Point operator * (double a){ return Point(x*a,y*a); }\n  Point operator / (double a){ return Point(x/a,y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nstruct Segment{\n  Vector p1,p2;\n  Segment(){}\n  Segment(Vector p1,Vector p2) : p1(p1),p2(p2) {}\n};\n\nbool intersectSS(const Segment &s,const Segment &t){\n  return (ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0) && \n         (ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0);\n}\n\nPoint getCrossPoint(Segment s,Segment t){\n  Vector b = t.p2 - t.p1;\n  double d1 = abs(cross(b,s.p1-t.p1));\n  double d2 = abs(cross(b,s.p2-t.p1));\n  double d = d1 / (d1 + d2);\n  return s.p1+(s.p2-s.p1)*d;\n}\n\ndouble getArea(Point a,Point b,Point c){\n  return fabs(a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2;\n}\n\nSegment s[3];\nvoid solve(){\n  Point p1 = getCrossPoint(s[0],s[1]);\n  Point p2 = getCrossPoint(s[1],s[2]);\n  Point p3 = getCrossPoint(s[2],s[0]);\n  double S = getArea(p1,p2,p3);\n  if(S >= 1900000){\n    cout << \"dai-kichi\" << endl;\n  }else if(S >= 1000000){\n    cout << \"chu-kichi\" << endl;\n  }else if(S >= 100000){\n    cout << \"kichi\" << endl;\n  }else if(S > 0){\n    cout << \"syo-kichi\" << endl;\n  }else{\n    cout << \"kyo\" << endl;\n  }\n}\n\nint main(){\n  while(true){\n    cin >> s[0].p1.x >> s[0].p1.y >> s[0].p2.x >> s[0].p2.y;\n    if(!s[0].p1.x && !s[0].p1.y && !s[0].p2.x && !s[0].p2.y) break;\n\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> s[i+1].p1.x >> s[i+1].p1.y >> s[i+1].p2.x >> s[i+1].p2.y;\n    }\n    if(intersectSS(s[0],s[1]) && intersectSS(s[1],s[2]) && intersectSS(s[2],s[0])){\n      solve();\n    }else{\n      cout << \"kyo\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\ndouble areaTriangle(polygon p) {\n\tp[0] = p[0] - p[2];\n\tp[1] = p[1] - p[2];\n\treturn fabs(p[0].x * p[1].y - p[1].x * p[0].y) / 2.0;\n}\n\nstring omikuji(const vector<segment>& segments) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tconst segment& s = segments[i], t = segments[(i + 1) % 3];\n\t\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\t\tif(abs(tmp) < EPS || !intersect(s, t))\n\t\t\treturn \"kyo\";\n\t}\n\n\tpolygon triangle;\n\tfor(int i = 0; i < 3; ++i)\n\t\ttriangle.push_back(crosspoint(segments[i], segments[(i + 1) % 3]));\n\n\tconst double area_of_triangle = areaTriangle(triangle);\n\tif(area_of_triangle >= 1900000)\n\t\treturn \"dai-kichi\";\n\n\tif(area_of_triangle >= 1000000)\n\t\treturn \"chu-kichi\";\n\n\tif(area_of_triangle >= 100000)\n\t\treturn \"kichi\";\n\n\tif(area_of_triangle > 0)\n\t\treturn \"syo-kichi\";\n\n\treturn \"kyo\";\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y, x2, y2; cin >> x >> y >> x2 >> y2, (x | y | x2 | y2);) {\n\t\tvector<segment> segments;\n\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y >> x2 >> y2;\n\t\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\t}\n\n\t\tstring result = omikuji(segments);\n\t\tcout << result << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nclass CPoint;\ntypedef CPoint CVector2D;\nclass CSegment;\ntypedef vector <CSegment> CSegments;\ndouble GetSquare( double );\nbool Equal( double, double );\nbool LessthanEqual( double, double );\ndouble GetCrossProduct( double, double, double, double );\ndouble GetCrossProduct( CPoint, CPoint );\ndouble GetDotProduct( double, double, double, double );\ndouble GetDotProduct( CPoint, CPoint );\ndouble GetGradientFromTwoPoints( CPoint, CPoint );\nint CheckCounterClockWise( CPoint, CPoint, CPoint );\nbool Intersect( CPoint, CPoint, CPoint, CPoint );\nbool Intersect( CSegment, CSegment );\nCPoint GetCrossPoint( CSegment, CSegment );\ndouble GetLength( CPoint, CPoint );\ndouble GetDistance( CPoint, CPoint );\ndouble GetDistance( CSegment, CPoint );\nCPoint GetLowestY( CPoint, CPoint );\nclass CPoint {\npublic:\n    double x, y;\n    CPoint( double x, double y ): x(x), y(y) {}\n    CPoint(): x(0), y(0) {};\n    double getNorm() {\n        return x * x + y * y;\n    }\n    double getAbs() {\n        return sqrt( getNorm() );\n    }\n    CPoint operator + ( CPoint p ) {\n        return CPoint( x + p.x, y + p.y );\n    }\n    CPoint operator - ( CPoint p ) {\n        return CPoint( x - p.x, y - p.y );\n    }\n    CPoint operator * ( double k ) {\n        return CPoint( x * k, y * k );\n    }\n    bool operator < ( const CPoint& p ) const {\n        if ( x < p.x ) return true;\n        return x == p.x ? y < p.y : false;\n    }\n};\nCPoint operator * ( double k, CPoint p ) {\n    return CPoint( p.x * k, p.y * k );\n}\nostream& operator << ( ostream& os, CPoint p0 ) {\n    os << \"(\" << p0.x << \", \" << p0.y << \")\";\n    return os;\n}\nclass CSegment {\npublic:\n    CPoint a, b;\n    CSegment( int x1, int y1, int x2, int y2 ): a(CPoint( x1, y1 )), b(CPoint( x2, y2 )) {}\n    CSegment( CPoint a, CPoint b ): a(a), b(b) {}\n    CSegment() {}\n    double getGradient() {\n        return GetGradientFromTwoPoints( a, b );\n    }\n    double getLength() {\n        return GetLength( a, b );\n    }\n    double getMinX() {\n        return min( a.x, b.x );\n    }\n    double getMinY() {\n        return min( a.y, b.y );\n    }\n    double getMaxX() {\n        return max( a.x, b.x );\n    }\n    double getMaxY() {\n        return max( a.y, b.y );\n    }\n    bool operator < ( const CSegment& s ) const {\n        return b.y > s.b.y;\n    }\n    \n};\nostream& operator << ( ostream& os, CSegment s0 ) {\n    os << \"(\" << s0.a << \" - \" << s0.b << \")\";\n    return os;\n}\nclass CCircle {\npublic:\n    CPoint p;\n    int r;\n    CCircle(): p( 0, 0 ), r(0) {}\n    CCircle( int x, int y, int r ): p(x, y), r(r) {}\n    CCircle( CPoint p, int r ): p(p), r(r) {}\n};\nostream& operator << ( ostream& os, CCircle c0 ) {\n    os << \"{(\" << c0.p.x << \", \" << c0.p.y << \"), r = \" << c0.r << \")\";\n    return os;\n}\nclass CTriangle {\npublic:\n    CPoint a;\n    CPoint b;\n    CPoint c;\n    CTriangle( int x1, int y1, int x2, int y2, int x3, int y3 ):\n        a(CPoint(x1,y1)), b(CPoint(x2,y2)), c(CPoint(x3,y3)) {}\n    CTriangle( CPoint a, CPoint b, CPoint c ):\n        a(a), b(b), c(c) {}\n    double getArea() {\n        CSegment AB( a, b );\n        CSegment BC( b, c );\n        CSegment CA( c, a );\n        double aa = AB.getLength();\n        double bb = BC.getLength();\n        double cc = CA.getLength();\n        double s = ( aa + bb + cc ) / 2.0;\n        return sqrt( s * ( s - aa ) * ( s - bb ) * ( s - cc ) );\n    }\n};\nostream& operator << ( ostream& os, CTriangle t0 ) {\n    os << \"{\" << t0.a << \", \" << t0.b << \", \" << t0.c << \"}\";\n    return os;\n}\nconst double EPS = 1e-9;\ndouble GetSquare( double x ) {\n    return x * x;\n}\nbool Equal( double a, double b ) {\n    return fabs( b - a ) < EPS;\n}\nbool LessthanEqual( double a, double b ) {\n    return a < b ? true : ( fabs( b - a ) < EPS );\n}\ndouble GetCrossProduct( double x1, double y1, double x2, double y2 ) {\n    return x1 * y2 - y1 * x2;\n}\ndouble GetCrossProduct( CPoint a, CPoint b ) {\n    return GetCrossProduct( a.x, a.y, b.x, b.y );\n}\ndouble GetDotProduct( double x1, double y1, double x2, double y2 ) {\n    return x1 * x2 + y1 * y2;\n}\ndouble GetDotProduct( CPoint a, CPoint b ) {\n    return GetDotProduct( a.x, a.y, b.x, b.y );\n}\nbool Intersect( CPoint p1, CPoint p2, CPoint p3, CPoint p4 ) {\n    bool f1 = LessthanEqual( CheckCounterClockWise( p1, p2, p3 ) * CheckCounterClockWise( p1, p2, p4 ), 0 );\n    bool f2 = LessthanEqual( CheckCounterClockWise( p3, p4, p1 ) * CheckCounterClockWise( p3, p4, p2 ), 0 );\n    return f1 && f2;\n}\nbool Intersect( CSegment s1, CSegment s2 ) {\n    return Intersect( s1.a, s1.b, s2.a, s2.b );\n}\nbool Contain( CTriangle a, CPoint p ) {\n    CVector2D AP = p - a.a;\n    CVector2D BP = p - a.b;\n    CVector2D CP = p - a.c;\n    CVector2D AB = a.b - a.a;\n    CVector2D BC = a.c - a.b;\n    CVector2D CA = a.a - a.c;\n    if ( GetCrossProduct( AP, AB ) < 0.0\n         && GetCrossProduct( BP, BC ) < 0.0\n         && GetCrossProduct( CP, CA ) < 0.0 ) return true;\n    if ( GetCrossProduct( AP, AB ) > 0.0\n         && GetCrossProduct( BP, BC ) > 0.0\n         && GetCrossProduct( CP, CA ) > 0.0 ) return true;\n    return false;\n}\nbool Contain( CCircle cir, CTriangle tri ) {\n    double maxd = 0.0;\n    maxd = max( maxd, GetDistance( tri.a, cir.p ) );\n    maxd = max( maxd, GetDistance( tri.b, cir.p ) );\n    maxd = max( maxd, GetDistance( tri.c, cir.p ) );\n    return LessthanEqual( maxd, cir.r );\n}\nbool Contain( CTriangle tri, CCircle cir ) {\n    double mind = GetDistance(CSegment(tri.a, tri.b), cir.p);\n    mind = min( mind, GetDistance(CSegment(tri.b, tri.c), cir.p) );\n    mind = min( mind, GetDistance(CSegment(tri.c, tri.a), cir.p) );\n    return LessthanEqual( cir.r, mind );\n}\ndouble GetGradientFromTwoPoints( CPoint a, CPoint b ) {\n    return ( b.y - a.y ) / ( b.x - a.x );\n}\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\nint CheckCounterClockWise( CPoint p0, CPoint p1, CPoint p2 ) {\n    CVector2D a = p1 - p0;\n    CVector2D b = p2 - p0;\n    if ( GetCrossProduct( a, b ) > EPS ) return COUNTER_CLOCKWISE;\n    if ( GetCrossProduct( a, b ) < EPS ) return CLOCKWISE;\n    if ( GetDotProduct( a, b ) < -EPS ) return ONLINE_BACK;\n    if ( a.getNorm() < b.getNorm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nCPoint GetCrossPoint( CSegment s1, CSegment s2 ) {\n    CVector2D base = s2.b - s2.a;\n    double d1 = abs( GetCrossProduct( base, s1.a - s2.a ) );\n    double d2 = abs( GetCrossProduct( base, s1.b - s2.a ) );\n    double t = d1 / ( d1 + d2 );\n    return s1.a + ( s1.b - s1.a ) * t;\n}\ndouble GetLength( CPoint a, CPoint b ) {\n    return sqrt( GetSquare( a.x - b.x ) + GetSquare( a.y - b.y ) );\n}\ndouble GetDistance( CPoint a, CPoint b ) {\n    return GetLength( a, b );\n}\nCPoint GetLowestY( CPoint a, CPoint b ) {\n    if ( a.y == b.y ) return a.x < b.x ? a : b;\n    return a.y < b.y ? a : b;\n}\ndouble GetDistance( CSegment seg, CPoint p ) {\n    if ( GetDotProduct( seg.b - seg.a, p - seg.a ) < EPS ) return (p - seg.a).getAbs();\n    if ( GetDotProduct( seg.a - seg.b, p - seg.b ) < EPS ) return (p - seg.b).getAbs();\n    return fabs( GetCrossProduct( seg.b - seg.a, p - seg.a ) ) / ( seg.b - seg.a ).getAbs();\n}\nbool CheckIntersect( CSegment seg, CCircle c ) {\n    bool f1 = LessthanEqual( ( c.p - seg.a ).getAbs(), c.r );\n    bool f2 = LessthanEqual( ( c.p - seg.b ).getAbs(), c.r );\n    if ( f1 ^ f2 ) return true;\n    return LessthanEqual( GetDistance( seg, c.p ), c.r ) && ( ! f1 && ! f2 );\n}\nbool CheckIntersect( CTriangle tri, CCircle cir ) {\n    return CheckIntersect( CSegment( tri.a, tri.b ), cir )\n        || CheckIntersect( CSegment( tri.b, tri.c ), cir )\n        || CheckIntersect( CSegment( tri.c, tri.a ), cir );\n}\n\n\nconst string DAI = \"dai-kichi\";\nconst string CHU = \"chu-kichi\";\nconst string KIC = \"kichi\";\nconst string SYO = \"syo-kichi\";\nconst string KYO = \"kyo\";\n\nstring solve( CSegment s0, CSegment s1, CSegment s2 ) {\n    if ( ! Intersect( s0, s1 ) || ! Intersect( s1, s2 ) || ! Intersect( s2, s0 ) ) {\n        return KYO;\n    }\n    CTriangle tri( GetCrossPoint( s0, s1 ), GetCrossPoint( s1, s2 ), GetCrossPoint( s2, s0 ) );\n    double area = tri.getArea();\n    if ( fabs( area ) < 1e-9 ) {\n        return KYO;\n    } else if ( area < 100000.0 ) {\n        return SYO;\n    } else if ( area < 1000000.0 ) {\n        return KIC;\n    } else if ( area < 1900000.0 ) {\n        return CHU;\n    }\n    return DAI;\n}\n\nint main() {\n    int x1, y1, x2, y2;\n    while ( cin >> x1 >> y1 >> x2 >> y2 ) {\n        if ( x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0 ) break;\n        CSegment S0( x1, y1, x2, y2 );\n        cin >> x1 >> y1 >> x2 >> y2;\n        CSegment S1( x1, y1, x2, y2 );\n        cin >> x1 >> y1 >> x2 >> y2;\n        CSegment S2( x1, y1, x2, y2 );\n        cout << solve( S0, S1, S2 ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define EPS (1e-7)\n\ntypedef complex<double> P;\nstruct Line : public vector<P>\n{\n  Line() {\n  }\n  Line(P a, P b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\nbool is_cross_ss(Line const& a, Line const& b) {\n  return ( cross(a[1]-a[0], b[0]-a[0]) * cross(a[1]-a[0], b[1]-a[0]) < EPS )\n    && ( cross(b[1]-b[0], a[0]-b[0]) * cross(b[1]-b[0], a[1]-b[0]) < EPS );\n}\n\nP crosspoint_ss(Line const& a, Line const& b) {\n  P vb = b[1]-b[0];\n  double d1 = abs(cross(vb, a[0]-b[0]));\n  double d2 = abs(cross(vb, a[1]-b[0]));\n  double t = d1 / (d1+d2);\n  return a[0] + (a[1]-a[0]) * t;\n}\n\nbool operator == (P const& a, P const& b) {\n  return ( abs(a.real()-b.real()) < EPS && abs(a.imag()-b.imag()) < EPS );\n}\n\nint main() {\n  \n  while(1) {\n    Line l[3];\n    rep(i, 3) {\n      double sx, sy, gx, gy;\n      cin >> sx >> sy >> gx >> gy;\n      if(i == 0 && sx == 0 && sy == 0 && gx == 0 && gy == 0) return 0;\n      l[i] = Line(P(sx, sy), P(gx, gy));\n    }\n    \n    \n    vector<P> ps;\n    rep(i, 3) {\n      if(is_cross_ss(l[i], l[(i+1)%3])) {\n        P cp = crosspoint_ss(l[i], l[(i+1)%3]);\n        bool ok = 1;\n        rep(j, (int)ps.size())\n          if(ps[j] == cp) { ok = 0; }\n        if(ok) {\n          ps.push_back(cp);\n        }\n      }\n    }\n    \n    if(ps.size() < 3) {\n      cout << \"kyo\\n\";\n      continue;\n    }\n    if(ps.size() > 3) {\n      assert(false && \"sine\");\n    }\n    \n    double ans = abs(ps[1]-ps[0])*abs(ps[2]-ps[0]) / 2.;\n    if(ans < 100000.) {\n      cout << \"syo-kichi\\n\";\n    }\n    else if(ans < 1000000.) {\n      cout << \"kichi\\n\";\n    }\n    else if(ans < 1900000) {\n      cout << \"chu-kichi\\n\";\n    }\n    else {\n      cout << \"dai-kichi\\n\";\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\ntypedef long long int Int;\nconst Int N = 3;\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nInt ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npair<bool, P> crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return pair<bool, P>(0, m[0]); // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return pair<bool, P>(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nbool input(L &l){\n  Int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n  l = L(P(x1, y1), P(x2, y2));\n  return (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0);\n}\n\ndouble area(const G &P) {\n  double A = 0.0;\n  for (Int i = 0; i < P.size(); ++i) A += cross(curr(P, i), next(P, i));\n  return abs(A / 2.0);\n}\n\nstring solve(L ls[N]){\n  G g;\n  REP(i, N){\n    if(!intersectSS(ls[i], ls[(i + 1) % N])) return \"kyo\";\n    else{\n      pair<bool, P> res = crosspointLL(ls[i], ls[(i + 1) % N]);\n      if(!res.first) return \"kyo\";\n      g.push_back(res.second);\n    }\n  }\n  double r = area(g);\n  if(r >= 1900000) return \"dai-kichi\";\n  if(r >= 1000000) return \"chu-kichi\";\n  if(r >= 100000) return \"kichi\";\n  return \"syo-kichi\";\n  //if(r < 100000) return \"syo-kichi\";\n  //if(r < 1000000) return \"kichi\";\n  //if(r < 1900000) return \"chu-kichi\";\n  //return \"dai-kichi\";\n}\n\nint main() {\n  L ls[N];\n  while(input(ls[0])){\n    FOR(i, 1, N) input(ls[i]);\n    cout <<solve(ls) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n  \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\n\nint main(){\n  L ls[3];\n  int x1[3], y1[3], x2[3], y2[3];\n  while( cin >> x1[0] >> y1[0] >> x2[0] >> y2[0], x1[0]|y1[0]|x2[0]|y2[0] ){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      ls[i] = L( P( x1[i], y1[i]), P( x2[i], y2[i]));\n    }\n\n    G triangle(3);\n    bool flag = true;\n    for(int i = 0 ; i < 3 ; i++ ){\n      const int NEXT = ( i + 1 ) % 3;\n      if(!intersect( ls[i], ls[NEXT])){\n        flag = false;\n        break;\n      }else{\n        triangle[i] = crosspoint( ls[i], ls[NEXT]);\n      }\n    }\n    double area = abs(area2(triangle));\n\n    if(!flag || area < EPS) cout << \"kyo\" << endl;\n    else if(area < 100000) cout << \"syo-kichi\" << endl;\n    else if(area < 1000000) cout << \"kichi\" << endl;\n    else if(area < 1900000) cout << \"chu-kichi\" << endl;\n    else cout << \"dai-kichi\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nconst double EPS=1e-12;\nconst double INF=1e12;\n\ntypedef complex<double>Point;\n\nnamespace std{\n    bool operator<(const Point &P,const Point &Q){\n        return real(P)!=real(Q)?real(P)<real(Q):imag(P)<imag(Q);\n    }\n}\n\ndouble dot(const Point &P,const Point &Q){\n    return real(P)*real(Q)+imag(P)*imag(Q);\n}\n\ndouble cross(const Point &P,const Point &Q){\n    return real(P)*imag(Q)-real(Q)*imag(P);\n}\n\nstruct Line{\n    Point a,b;\n    Line(Point P,Point Q){\n        a=P;b=Q;\n    }\n    Line(){}\n};\n\nstruct Segment{\n    Point a,b;\n    Segment(Point P,Point Q){\n        a=P;b=Q;\n    }\n    Segment(){}\n};\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point P,double l){\n        c=P;r=l;\n    }\n};\n\ntypedef vector<Point>Polygon;\n\nint ccw(Point A,Point B,Point C){\n    B-=A;C-=A;\n    if(cross(B,C)>0)return 1; //ccw\n    if(cross(B,C)<0)return -1; //cw\n    if(dot(B,C)<0)return 2; //c-b-a\n    if(norm(B)<norm(C))return -2; //a-b-c\n    return 0; //a-c-b\n}\n\ninline bool parallelism(const Line &L,const Line &M){\n    return fabs(cross(L.a-L.b,M.a-M.b))<EPS;\n}\n\ninline bool orthogonal(const Line &L,const Line &M){\n    return fabs(dot(L.a-L.b,M.a-M.b))<EPS;\n}\n\ninline bool intersect(const Line &L,const Line &M){\n    return cross(L.a-L.b,M.a-M.b)>EPS ||cross(L.a-L.b,M.a-M.b)<-EPS;\n}\n\ninline bool intersect(const Line &L,const Segment &S){\n    return cross(L.b-L.a,S.a-L.a)*cross(L.b-L.a,S.b-L.a)<-EPS;\n}\n\ninline bool intersect(const Line &L,const Point &P){\n    return abs(ccw(L.a,L.b,P))!=1;\n}\n\ninline bool intersect(const Segment &S, const Segment &T){\n    return ccw(S.a,S.b,T.a)*ccw(S.a,S.b,T.b)<=0&&\n        ccw(T.a,T.b,S.a)*ccw(T.a,T.b,S.b) <= 0;\n}\n\ninline bool intersect(const Segment &S,const Point &P){\n    return ccw(S.a,S.b,P)==0;\n}\n\ninline bool intersect(const Circle &C,const Point &P){\n    return abs(C.c-P)<=C.r+EPS;\n}\n\ninline bool intersect(const Circle &C,const Circle &D){\n    return abs(C.c-D.c)<=C.r+D.r&&abs(C.c-D.c)>=fabs(C.r-D.r);\n}\n\ninline bool onSameLine(const Segment &S,const Segment &T){\n    return abs(ccw(S.a,S.b,T.a)*ccw(S.a,S.b,T.b))!=1;\n}\n\ninline Point crossPoint(const Line &L,const Line &M){\n    double crs=cross(L.b-L.a,M.b-M.a);\n    return M.a+(M.b-M.a)*cross(L.b-L.a,L.a-M.a)*(1.0/crs);\n}\n\ninline Point crossPoint(const Segment &S,const Segment &T){\n    double crs=cross(S.b-S.a,T.b-T.a);\n    return T.a+(T.b-T.a)*cross(S.b-S.a,S.b-T.a)*(1.0/crs);\n}\ndouble areaTriangle(Point A,Point B,Point C){\n    B-=A;C-=A;\n    return fabs(cross(B,C))*0.5;\n}\n\ndouble areaPolygon(Polygon &G){\n    const int Sz=G.size();\n    if(Sz<3)return 0;\n    if(Sz==3)return areaTriangle(G[0],G[1],G[2]);\n\n    double res=cross(G[Sz-1],G[0]);\n    for(int i=1;i<Sz;i++)res+=cross(G[i-1],G[i]);\n\n    return fabs(res)*0.5;\n}\n\n\n\nint main(){\n    double x1,x2,y1,y2;\n    while(cin>>x1>>y1>>x2>>y2,x1||y1||x2||y2){\n        Segment S[3];\n        S[0]=Segment(Point(x1,y1),Point(x2,y2));\n        for(int i=1;i<3;i++){\n            cin>>x1>>y1>>x2>>y2;\n            S[i]=Segment(Point(x1,y1),Point(x2,y2));\n        }\n        bool flag=false;\n        for(int i=0;i<3;i++){\n            flag|=(!intersect(S[i],S[(i+1)%3]));\n            flag|=onSameLine(S[i],S[(i+1)%3]);\n        }\n        if(flag){\n            cout<<\"kyo\"<<endl;\n            continue;\n        }\n        Point P[3];\n        for(int i=0;i<3;i++){\n            P[i]=crossPoint(S[i],S[(i+1)%3]);\n        }\n        double me=areaTriangle(P[0],P[1],P[2]);\n\n        if(me==0)cout<<\"kyo\"<<endl;\n        else if(me<100000)cout<<\"syo-kichi\"<<endl;\n        else if(me<1000000)cout<<\"kichi\"<<endl;\n        else if(me<1900000)cout<<\"chu-kichi\"<<endl;\n        else cout<<\"dai-kichi\"<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct point\n{\n    double x, y;\n    point(double x, double y) : x(x), y(y){}\n};\n\nstruct line\n{\n    point start, end;\n    complex<double> v;\n    line(point start, point end) : start(start), end(end)\n    {\n        v = complex<double>(end.x - start.x, end.y - start.y);\n    }\n};\n\nbool is_cross(line l1, line l2)\n{\n    point a = l1.start;\n    point b = l1.end;\n    point c = l2.start;\n    point d = l2.end;\n    double ta = (c.x - d.x) * (a.y - c.y) + (c.y - d.y) * (c.x - a.x);\n    double tb = (c.x - d.x) * (b.y - c.y) + (c.y - d.y) * (c.x - b.x);\n    double tc = (a.x - b.x) * (c.y - a.y) + (a.y - b.y) * (a.x - c.x);\n    double td = (a.x - b.x) * (d.y - a.y) + (a.y - b.y) * (a.x - d.x);\n\n    return ta * tb < 0 and tc * td < 0;\n}\n\npoint cross_point(line l1, line l2)\n{\n    point a = l1.start;\n    point b = l1.end;\n    point c = l2.start;\n    point d = l2.end;\n    double ksi, eta, delta;\n    double lambda;\n\n    ksi = (d.y - c.y) * (d.x - a.x) - (d.x - c.x) * (d.y - a.y);\n    eta = (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x);\n    delta = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);\n\n    lambda = ksi / delta;\n\n    return point(a.x + lambda * (b.x - a.x), a.y + lambda * (b.y - a.y));\n}\n\ndouble triangle_area(point p1, point p2, point p3)\n{\n    line a(p1, p2);\n    line b(p2, p3);\n    line c(p3, p1);\n    double s = (abs(a.v) + abs(b.v) + abs(c.v)) / 2;\n    return sqrt(s * (s - abs(a.v)) * (s - abs(b.v)) * (s - abs(c.v)));\n}\n\nint main(void)\n{\n    int x1, y1;\n    int x2, y2;\n\n    while (scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 || y1 || x2 || y2){\n        line l1(point(x1, y1), point(x2, y2));\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        line l2(point(x1, y1), point(x2, y2));\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        line l3(point(x1, y1), point(x2, y2));\n\n        if (is_cross(l1, l2) and is_cross(l2, l3) and is_cross(l3, l1)){\n            point p1 = cross_point(l1, l2);\n            point p2 = cross_point(l2, l3);\n            point p3 = cross_point(l3, l1);\n            double area = triangle_area(p1, p2, p3);\n\n            if (19e5 <= area) puts(\"dai-kichi\");\n            else if (1e6 <= area) puts(\"chu-kichi\");\n            else if (1e5 <= area) puts(\"kichi\");\n            else puts(\"syo-kichi\");\n        }\n        else {\n            puts(\"kyo\");\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-10\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n\tPoint operator *(const double d)const{\n\t\treturn Point(x*d,y*d);\n\t}\n};\n\nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n};\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n\ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n\nint ccw(Point a,Point b,Point c){\n    if(cross(b-a,c-b)>0) return +1;\n    if(cross(b-a,c-b)<0) return -1;\n    return 0;\n}\n\nbool pss(Line l,Line m,Point &p){\n\tPoint a1,a2,b1,b2;\n\ta1 = l.b-l.a; a2 = m.b-m.a;\n\tb1 = m.a-l.a; b2 = m.b-l.a;\n\tdouble s1,s2;\n\ts1 = abs(cross(a1,b1)); s2 = abs(cross(a1,b2));\n\tif(s1<EPS && s2<EPS) return false;\n\tp = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n\tif(p.x<min(l.a.x,l.b.x) || max(l.a.x,l.b.x)<p.x || p.x<min(m.a.x,m.b.x) || max(m.a.x,m.b.x)<p.x ||\n\t   p.y<min(l.a.y,l.b.y) || max(l.a.y,l.b.y)<p.y || p.y<min(m.a.y,m.b.y) || max(m.a.y,m.b.y)<p.y)\n\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tLine l[3];\n\twhile(true){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>l[i].a.x>>l[i].a.y>>l[i].b.x>>l[i].b.y;\n\t\t\tif(l[i].a.x==0 && l[i].a.y==0 && l[i].b.x==0 && l[i].b.y==0) return 0;\n\t\t}\n\t\tPoint p[3];\n\t\tbool kyo = false;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(pss(l[i],l[(i+1)%3],p[i])==false) kyo = true;\n\t\t}\n\t\tif(kyo==true){\n\t\t\tputs(\"kyo\"); continue;\n\t\t}\n\t\tdouble s = abs(cross(p[1]-p[0],p[2]-p[0])/2);\n\t\t//printf(\"\\t%lf\\n\",s);\n\t\tif(s<EPS) puts(\"kyo\");\n\t\telse if(s<100000) puts(\"syo-kichi\");\n\t\telse if(s<1000000) puts(\"kichi\");\n\t\telse if(s<1900000) puts(\"chu-kichi\");\n\t\telse puts(\"dai-kichi\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n \n \tPoint operator / (double k){\n \t\treturn Point(x/k,y/k);\n \t}\n\n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n \n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n \ndouble pabs(Point p){\n    return sqrt(norm(p));\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<=0)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<=0);\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n\tb = b - a;\n\tc = c - a;\n\treturn fabs(cross(b,c))*0.5;\n}\n\ndouble VertexArea(Polygon v){\n\tdouble subArea = 0.0;\n\trep(i,v.size()-1){\n\t\tsubArea += TriangleArea(v[0],v[i],v[i+1]);\n\t}\n}\n\nPoint crosspoint(Line l,Line m){\n\tif(intersectSS(l,m) == false)return Point(INF,INF);\n\treturn m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n\nint main(){\n\twhile(true){\n\t\tbool endflg = false;\n\t\tLine l[3];\n\t\trep(i,3){\n\t\t\tdouble x1,y1,x2,y2;\n\t\t\tscanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n\t\t\tif(i == 0){\n\t\t\t\tif(x1 == 0.0 && y1 == 0.0 && x2 == 0.0 && y2 == 0.0){\n\t\t\t\t\tendflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tl[i].PB(Point(x1,y1));\n\t\t\tl[i].PB(Point(x2,y2));\n\t\t}\n\t\tif(endflg)break;\n\t\tPoint p[3];\n\t\tp[0] = crosspoint(l[0],l[1]);\n\t\tp[1] = crosspoint(l[0],l[2]);\n\t\tp[2] = crosspoint(l[1],l[2]);\n\t\tdouble area = TriangleArea(p[0],p[1],p[2]);\n\t\tif(area-1900000>EPS)puts(\"dai-kichi\");\n\t\telse if(area-1000000>EPS)puts(\"chu-kichi\");\n\t\telse if(area-100000>EPS)puts(\"kichi\");\n\t\telse if(area>EPS)puts(\"syo-kichi\");\n\t\telse puts(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <string>\n#define EPS 1e-10\nusing namespace std;\n\nstruct point{\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tpoint operator +(point p){\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\tpoint operator -(point p){\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\tpoint operator *(double d){\n\t\treturn point(x*d,y*d);\n\t}\n\tdouble dot(point p){\n\t\treturn p.x*x+p.y*y;\n\t}\n\tdouble det(point p){\n\t\treturn x*p.y-y*p.x;\n\t}\n\tdouble len(){\n\t\treturn sqrt(x*x+y*y);\n\t}\n};\n\nbool on_seg(point p1,point p2,point q){\n\treturn (p2-p1).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n\npoint intersection(point p1,point p2,point q1,point q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\ndouble x[4][4];\ndouble y[4][4];\npoint p[8];\npoint g[3];\ndouble len[3];\nstring check(){\n\tif((p[0]-p[2]).dot(p[1]-p[3])==0)return \"kyo\";\n\tg[0]=intersection(p[0],p[1],p[2],p[3]);\n\tif(!(on_seg(p[0],p[1],g[0]) && on_seg(p[2],p[3],g[0])))return \"kyo\";\n\tif((p[0]-p[4]).dot(p[1]-p[5])==0)return \"kyo\";\n\tg[1]=intersection(p[0],p[1],p[4],p[5]);\n\tif(!(on_seg(p[0],p[1],g[1]) && on_seg(p[4],p[5],g[1])))return \"kyo\";\n\tif((p[2]-p[4]).dot(p[3]-p[5])==0)return \"kyo\";\n\tg[2]=intersection(p[2],p[3],p[4],p[5]);\n\tif(!(on_seg(p[2],p[3],g[2]) && on_seg(p[4],p[5],g[2])))return \"kyo\";\n\tlen[0]=(g[0]-g[1]).len();\n\tlen[1]=(g[1]-g[2]).len();\n\tlen[2]=(g[0]-g[2]).len();\n\tdouble s=(len[0]+len[1]+len[2])/2.0;\n\tdouble S=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n\tif(S<EPS)return \"kyo\";\n\tif(S<100000.0)return \"syo-kichi\";\n\tif(S<1000000.0)return \"kichi\";\n\tif(S<1900000.0)return \"chu-kichi\";\n\treturn \"dai-kichi\";\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%lf %lf %lf %lf\",&x[0][0],&y[0][0],&x[1][0],&y[1][0]);\n\t\tif(x[0][0]==0.0 && y[0][0]==0.0 && x[1][0]==0.0 && y[1][0]==0.0)break;\n\t\tp[0]=point(x[0][0],y[0][0]);\n\t\tp[1]=point(x[1][0],y[1][0]);\n\t\tfor(int i=1;i<=2;i++){\n\t\t\tscanf(\"%lf %lf %lf %lf\",&x[0][i],&y[0][i],&x[1][i],&y[1][i]);\n\t\t\tp[i*2+0]=point(x[0][i],y[0][i]);\n\t\t\tp[i*2+1]=point(x[1][i],y[1][i]);\n\t\t}\n\t\tcout << check() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-b1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    VP v;\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      VP v;\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000)cout<<\"kichi\"<<endl;\n      else cout<<\"syo-kichi\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\ntypedef long long int Int;\nconst Int N = 3;\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nInt ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npair<bool, P> crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return pair<bool, P>(0, m[0]); // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return pair<bool, P>(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nbool input(L &l){\n  Int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n  l = L(P(x1, y1), P(x2, y2));\n  return (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0);\n}\n\ndouble area(const G &P) {\n  double A = 0.0;\n  for (Int i = 0; i < P.size(); ++i) A += cross(curr(P, i), next(P, i));\n  return abs(A / 2.0);\n}\n\nstring solve(L ls[N]){\n  G g;\n  REP(i, N){\n    if(!intersectSS(ls[i], ls[(i + 1) % N])) return \"kyo\";\n    else{\n      pair<bool, P> res = crosspointLL(ls[i], ls[(i + 1) % N]);\n      if(!res.first) return \"kyo\";\n      g.push_back(res.second);\n    }\n  }\n  double r = area(g);\n  if(r > 0 && r < 100000) return \"syo-kichi\";\n  else if(r < 1000000) return \"kichi\";\n  else if(r < 1900000) return \"chu-kichi\";\n  return \"dai-kichi\";\n}\n\nint main() {\n  L ls[N];\n  while(input(ls[0])){\n    FOR(i, 1, N) input(ls[i]);\n    cout <<solve(ls) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\ntypedef complex<double> Point;\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\ntypedef Line Segment;\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\ndouble CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tdouble sign=Signum(Cross(d1,d2));\n\tif(sign)\n\t\treturn sign;\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\n\treturn 0;\n}\n\n// 直線と線分が重なるとき，線分の端点が直線上にあるときもtrue\nbool IntersectLS(Line a,Segment b)\n{\n\treturn CCW(a.pos,a.pos+a.dir,b.pos)*CCW(a.pos,a.pos+a.dir,b.pos+b.dir)<=0;\n}\nbool IntersectSS(Segment a,Segment b)\n{\n\treturn IntersectLS(a,b) && IntersectLS(b,a);\n}\n\n// aとbが平行でないことが前提\nPoint IntersectPoint(Line a,Line b)\n{\n\treturn a.pos+a.dir*Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir);\n}\n\nconst char* solve(Line* ls)\n{\n\tPoint ps[3];\n\tfor(int i=0;i<3;i++){\n\t\tLine l1=ls[i],l2=ls[(i+1)%3];\n\t\tif(Signum(Cross(l1.dir,l2.dir))==0)\n\t\t\treturn \"kyo\";\n\t\tif(!IntersectSS(l1,l2))\n\t\t\treturn \"kyo\";\n\t\tps[i]=IntersectPoint(l1,l2);\n\t}\n\t\n\tdouble area=abs(Cross(ps[1]-ps[0],ps[2]-ps[0]));\n\tif(area<1.0e5-EPS)\n\t\treturn \"syo-kichi\";\n\tif(area<1.0e6-EPS)\n\t\treturn \"kichi\";\n\tif(area<1.9e5-EPS)\n\t\treturn \"chu-kichi\";\n\treturn \"dai-kichi\";\n}\n\nint main()\n{\n\tfor(;;){\n\t\tLine ls[3];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint x1,y1,x2,y2; scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tls[i]=Line(Point(x1,y1),Point(x2-x1,y2-y1));\n\t\t}\n\t\tif(feof(stdin))\n\t\t\tbreak;\n\t\tputs(solve(ls));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <utility>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<double,double> pdd;\n#define x first\n#define y second\nconst double EPS = 1e-9;\nconst double INF = 1e18;\n\ntemplate<class T>\nT sqr(T obj) { return obj * obj; }\n\npdd pt(pdd a0, pdd a1, pdd b0, pdd b1) {\n\tdouble div;\n\tpdd ret;\n\n\tdiv = (a1.y - a0.y) * (b1.x - b0.x) - (b1.y - b0.y) * (a1.x - a0.x);\n\tif(fabs(div) < EPS)\n\t\treturn pdd(INF,INF);\n\n\tret.x = (a1.x - a0.x) * (b1.x * b0.y - b0.x * b1.y) - (b1.x - b0.x) * (a1.x * a0.y - a0.x * a1.y);\n\tret.y = (a1.y - a0.y) * (b1.x * b0.y - b0.x * b1.y) - (b1.y - b0.y) * (a1.x * a0.y - a0.x * a1.y);\n\tret.x /= div;\n\tret.y /= div;\n\n\treturn ret;\n}\n\nint main() {\n\twhile(1) {\n\t\tvector<pdd> v;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tdouble a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv.push_back(pdd(a,b));\n\t\t\t}\n\t\t\tif(fabs(v[0].x) < EPS && fabs(v[0].y) < EPS && fabs(v[1].x) < EPS && fabs(v[1].y) < EPS)\n\t\t\t\tgoto EXIT;\n\t\t}\n\n\t\tvector<pdd> p;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tp.push_back(pt(v[i*2 % 6], v[(i*2+1) % 6], v[(i+1)*2 % 6], v[((i+1)*2+1) % 6]));\n\t\t}\n\n\t\tstring res = \"\";\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tdouble dist0, dist1;\n\t\t\tdist0 = sqrt(sqr(v[i*2%6].x - v[(i*2+1)%6].x) + sqr(v[i*2%6].y - v[(i*2+1)%6].y));\n\t\t\tdist1 = sqrt(sqr(v[i*2%6].x - p[i].x) + sqr(v[i*2%6].y - p[i].y))\n\t\t\t\t+ sqrt(sqr(v[(i*2+1)%6].x - p[i].x) + sqr(v[(i*2+1)%6].y - p[i].y));\n\t\t\tif(p[i].x == INF || p[i].y == INF || fabs(dist0 - dist1) > EPS) {\n//\t\t\t\tcout << p[i].x << \",\" << p[i].y << endl;\n\t\t\t\tres = \"kyo\";\n\t\t\t}\n\t\t}\n\n\t\tif(res == \"\") {\n\t\t\tdouble S;\n\t\t\tS = (p[1].x - p[0].x) * (p[2].y - p[0].y) - (p[1].y - p[0].y) * (p[2].x - p[0].x);\n\t\t\tS = fabs(S);\n\n\t\t\tif(S >= 1900000)\n\t\t\t\tres = \"dai-kichi\";\n\t\t\telse if(S >= 1000000)\n\t\t\t\tres = \"chu-kichi\";\n\t\t\telse if(S >= 100000)\n\t\t\t\tres = \"kichi\";\n\t\t\telse\n\t\t\t\tres = \"syo-kichi\";\n\t\t}\n\t\tcout << res << endl;\n\t}\n\nEXIT:;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      point p[3];\n      for(int i=0;i<2;i++)\n\t    p[i]=intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b);\n      p[2]=intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b);\n\n      double z=(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]))/2;\n      double res=sqrt(z*(z-dist(p[0],p[1]))*(z-dist(p[1],p[2]))*(z-dist(p[2],p[0])));\n\n      if(res>=1900000)cout <<\"dai-kichi\"<<endl;\n      else if(res>=1000000 && res <1900000)cout <<\"chu-kichi\"<<endl;\n      else if(res>=100000 && res<1000000)cout <<\"kichi\"<<endl;\n      else if(res>0 && res<100000)cout << \"syo-kichi\"<<endl;\n      else cout <<\"kyo\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\ndouble cross(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4) {\n\tdouble m;\n\tm=(x4-x3)*(y2-y1)-(x2-x1)*(y4-y3);\n\tif (m==0) return -1;\n\treturn ((x1-x3)*(y4-y3)-(x4-x3)*(y1-y3))/m;\n }\n\nint main() {\n  double a,s,sx[3],sy[3],ex[3],ey[3],cx[3],cy[3],hx,lx,hy,ly;\n  int i,k;\n  while(true) {\n\tlx=ly=9999999; hx=hy=-lx;  \n   for (i=0;i<3;i++) {\n\t      cin >> sx[i] >> sy[i] >> ex[i] >> ey[i];\n\t      if (sx[i]==0 &&  sy[i]==0 && ex[i]==0 && ey[i]==0) return 0; \n\t      }\n\t   for (i=0;i<3;i++) {\n\t\tk=(i+1) % 3;\n\t\ts=cross(sx[i],sy[i],ex[i],ey[i],sx[k],sy[k],ex[k],ey[k]);\n\t\tcx[i]=sx[i]+s*(ex[i]-sx[i]); cy[i]=sy[i]+s*(ey[i]-sy[i]);\n\t\tif (s<0 || s>1 || (cx[i]<sx[k] && cx[i]<ex[k]) || (cx[i]>sx[k] && cx[i]>ex[k]) || (cy[i]<sy[k] && cy[i]<ey[k]) || (cy[i]>sy[k] && cy[i]>ey[k])) break;\n\t\thx=hx<cx[i] ? cx[i]:hx; lx=lx>cx[i] ? cx[i]:lx;\n\t\thy=hy<cy[i] ? cy[i]:hy; ly=ly>cy[i] ? cy[i]:ly;\n\t}\n\tif (i!=3) { cout << \"kyo\" << endl; continue;}\n\tfor (s=0,i=0;i<3;i++) s+=fabs(cx[i]-cx[(i+1) % 3])*fabs(cy[i]-cy[(i+1) % 3]);\n\ta=(hx-lx)*(hy-ly)-s/2;\n\tif (a>=1900000) cout << \"dai-kichi\"; else if (a>=1000000) cout << \"chu-kichi\";\n\telse if (a>=100000) cout << \"kichi\"; else if (a>0) cout << \"syo-kichi\";\n\telse cout << \"kyo\";\n\tcout << endl; \n } \n  return 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// ??´??? a1, a2 ??¨??´???b1, b2?????????????±???????\n// Verified: AOJ CGL_2_C.cpp\nP crossp_ll(P a1, P a2, P b1, P b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if( EQ(d1,0) && EQ(d2,0) ) return a1; // same line\n    if( EQ(d2,0) ) assert(false); // precondition not satisfied\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\n// ????§???¢????¬????????????¢???\ndouble area_n(const vector<P> &v) {\n    double ans = 0;\n    double x, y, z;\n    P init = v[0];\n    rep(i,2,v.size()) {\n        x = sqrt(norm(v[i] - init));\n        y = sqrt(norm(v[i-1] - init));\n        z = sqrt(norm(v[i] - v[i-1]));\n\n        double s = (x + y + z) / 2;\n        ans += sqrt(s * (s-x) * (s-y) * (s-z));\n    }\n    return ans;\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// ?????? a1, a2 ??¨?????? b1, b2 ???????????????\n// Verified: CGL_2_B: Intersection\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\nsigned main() {\n    double x1, y1, x2, y2;\n    while(cin >> x1 >> y1 >> x2 >> y2) {\n        if(x1 == y1 && y1 == x2 && x2 == y2 && y2 == 0.0) break;\n        vector<L> ls; vector<P> ps;\n        ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        rep(i,0,2) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            ls.push_back(make_pair(P(x1, y1), P(x2, y2)));\n        }\n\n        bool ng = false;\n        rep(i,0,3) {\n            P a1 = ls[i].fr, a2 = ls[i].sc;\n            P b1 = ls[(i+1)%3].fr, b2 = ls[(i+1)%3].sc;\n            if(!isec_ss(a1, a2, b1, b2)) {ng = true; break;}\n            P temp = crossp_ll(a1, a2, b1, b2);\n            // printf(\"crosspoint: (%.12lf, %.12lf)\\n\", temp.X, temp.Y);\n            rep(k,0,ps.size()) {if(temp == ps[k]) {ng = true; break;}}\n            ps.push_back(temp);\n        }\n\n        if(ng) cout << \"kyo\" << endl;\n        else {\n            double ans = fabs(cross(ps[0]-ps[1], ps[0]-ps[2]) / 2.0);\n            if(ans < 100000.0 + EPS) cout << \"syo-kichi\" << endl;\n            else if(ans < 1000000.0 + EPS) cout << \"kichi\" << endl;\n            else if(ans < 1900000.0 + EPS) cout << \"chu-kichi\" << endl;\n            else cout << \"dai-kichi\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(true)\n    {\n      cin >> x1 >> y1 >> x2 >> y2;\n      if(x1+y1+x2+y2 == 0)\n\tbreak;\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n    \n\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  vector<Point> p;\n  p.resize(3);\n  p[0] = p1,p[1] = p2,p[2] = p3;\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(p[i],p[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      double area = getArea(c1,c2,c3);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <utility>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef pair<double,double> pdd;\n#define x first\n#define y second\nconst double EPS = 1e-9;\nconst double INF = 1e18;\n\ntemplate<class T>\nT sqr(T obj) { return obj * obj; }\n\npdd pt(pdd a0, pdd a1, pdd b0, pdd b1) {\n\tdouble div;\n\tpdd ret;\n\n\tdiv = (a1.y - a0.y) * (b1.x - b0.x) - (b1.y - b0.y) * (a1.x - a0.x);\n\tif(fabs(div) < EPS)\n\t\treturn pdd(INF,INF);\n\n\tret.x = (a1.x - a0.x) * (b1.x * b0.y - b0.x * b1.y) - (b1.x - b0.x) * (a1.x * a0.y - a0.x * a1.y);\n\tret.y = (a1.y - a0.y) * (b1.x * b0.y - b0.x * b1.y) - (b1.y - b0.y) * (a1.x * a0.y - a0.x * a1.y);\n\tret.x /= div;\n\tret.y /= div;\n\n\treturn ret;\n}\n\nint main() {\n\twhile(1) {\n\t\tvector<pdd> v;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tdouble a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tv.push_back(pdd(a,b));\n\t\t\t}\n\t\t\tif(fabs(v[0].x) < EPS && fabs(v[0].y) < EPS && fabs(v[1].x) < EPS && fabs(v[1].y) < EPS)\n\t\t\t\tgoto EXIT;\n\t\t}\n\n\t\tvector<pdd> p;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tp.push_back(pt(v[i*2 % 6], v[(i*2+1) % 6], v[(i+1)*2 % 6], v[((i+1)*2+1) % 6]));\n\t\t}\n\n\t\tstring res = \"\";\n\t\tfor(int i = 0; i < p.size(); i++) {\n\t\t\tdouble dist0, dist1;\n\t\t\tdist0 = sqrt(sqr(v[i*2%6].x - v[(i*2+1)%6].x) + sqr(v[i*2%6].y - v[(i*2+1)%6].y));\n\t\t\tdist1 = sqrt(sqr(v[i*2%6].x - p[i].x) + sqr(v[i*2%6].y - p[i].y))\n\t\t\t\t+ sqrt(sqr(v[(i*2+1)%6].x - p[i].x) + sqr(v[(i*2+1)%6].y - p[i].y));\n\t\t\tif(p[i].x == INF || p[i].y == INF || fabs(dist0 - dist1) > EPS) {\n\t\t\t\tres = \"kyo\";\n\t\t\t}\n\t\t\t//cout << p[i].x << \",\" << p[i].y << endl;\n\t\t}\n\n\t\tif(res == \"\") {\n\t\t\tdouble S;\n\t\t\tS = (p[1].x - p[0].x) * (p[2].y - p[0].y) - (p[1].y - p[0].y) * (p[2].x - p[0].x);\n\t\t\tS = fabs(S);\n\n\t\t\tif(S + EPS>= 1900000)\n\t\t\t\tres = \"dai-kichi\";\n\t\t\telse if(S + EPS >= 1000000)\n\t\t\t\tres = \"chu-kichi\";\n\t\t\telse if(S + EPS >= 100000)\n\t\t\t\tres = \"kichi\";\n\t\t\telse if(S < EPS)\n\t\t\t\tres = \"kyo\";\n\t\t\telse\n\t\t\t\tres = \"syo-kichi\";\n\t\t}\n\t\tcout << res << endl;\n\t}\n\nEXIT:;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\n\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\nstruct L {\n    P x, y;\n    L() {};\n    L(P a, P b) {x=a, y=b;};\n};\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble dot(P a, P b) { return real(conj(a)*b); }\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return 1;\n    if (cross(b, c) < 0) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool insLL(L &l, L &m) {\n    if (abs(cross(l.y-l.x, m.y-m.x)) > EPS) return true;\n    if (abs(cross(l.y-l.x, m.y-l.x)) < EPS) return true;\n    return false;\n}\n\nbool insLS(L &l, L &s) {\n    double a = cross(l.y-l.x, s.x-l.x);\n    double b = cross(l.y-l.x, s.y-l.x);\n    if (a*b < EPS) return true;\n    return false;\n}\n\nbool insSP(L &s, P &p) {\n    return abs(s.x-p)+abs(s.y-p)+abs(s.y-s.x) < EPS;\n}\n\nbool insSS(L &s, L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nP crossp(L &l, L &m) {\n    double A = cross(l.y-l.x, m.y-m.x);\n    double B = cross(l.y-l.x, l.y-m.x);\n    if (abs(A) < EPS && abs(B) < EPS) return m.x;\n    return m.x+B/A*(m.y-m.x);\n}\n\nint main() {\n    while (true) {\n        L l1, l2, l3;\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        if (!x1 && !y1 && !x2 && !y2) break;\n        l1.x = P(x1, y1); l1.y = P(x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        l2.x = P(x1, y1); l2.y = P(x2, y2);\n        cin >> x1 >> y1 >> x2 >> y2;\n        l3.x = P(x1, y1); l3.y = P(x2, y2);\n        P p1 = crossp(l1, l2);\n        P p2 = crossp(l2, l3);\n        P p3 = crossp(l3, l1);\n        double s = abs(cross(p2-p1, p3-p1))/2;\n        if (!insSS(l1, l2) || !insSS(l2, l3) || !insSS(l3, l1)) s = 0;\n        if (1900000 <= s) cout << \"dai-kichi\" << endl;\n        else if (1000000 <= s) cout << \"chu-kichi\" << endl;\n        else if (100000 <= s) cout << \"kichi\" << endl;\n        else if (EPS <= s) cout << \"syo-kichi\" << endl;\n        else cout << \"kyo\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\nnamespace FP {\n    bool isZero(double x) {\n        return (abs(x) <= EPS);\n    }\n};\n\nstruct Point {\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    string to_s() {\n        ostringstream os;\n        os << \"(\" << x << \",\" << y << \")\";\n        return os.str();\n    }\n    bool operator<(const Point &o) const {\n        return x == o.x ? y < o.y : x < o.x;\n    }\n    bool operator==(const Point &o) const {\n        return x == o.x && y == o.y;\n    }\n    Point operator+(const Point &o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator-(const Point &o) const {\n        return Point(x-o.x, y-o.y);\n    }\n    Point operator*(const double m) const {\n        return Point(x*m, y*m);\n    }\n    Point operator/(const double d) const {\n        return Point(x/d, y/d);\n    }\n    // 外積\n    double cross(const Point &o) const {\n        return x * o.y - y * o.x;\n    }\n    // 内積\n    double dot(const Point &o) const {\n        return x * o.x + y * o.y;\n    }\n    // ベクトルがx軸となす角\n    double atan() const {\n        return atan2(y, x);\n    }\n    // ベクトルの長さの二乗\n    double norm() const {\n        return dot(*this);\n    }\n};\n\nstruct Line {\n    double a, b, c;\n    Line(double a=0, double b=0, double c=0) :\n        a(a), b(b), c(c) {}\n    Point intersectionPoint(const Line &l) const {\n        double d = a * l.b - l.a * b;\n        if (!intersects(l)) {\n            throw string(\"The 2 Lines are parallel\");\n        }\n        double x = (b * l.c - l.b * c) / d;\n        double y = (l.a * c - a * l.c) / d;\n        return Point(x, y);\n    }\n    bool intersects(const Line &l) const {\n        return !FP::isZero(a * l.b - l.a * b);\n    }\n    string to_s() {\n        ostringstream os;\n        os << a << ' ' << b << ' ' << c;\n        return os.str();\n    }\n    static Line fromPoints(const Point &a, const Point &b) {\n        double dx = b.x - a.x;\n        double dy = b.y - a.y;\n        return Line(dy, -dx, dx * a.y - dy * a.x);\n    }\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n        return fromPoints(Point(x1, y1), Point(x2, y2));\n    }\n};\n\nstruct LineSegment {\n    Point start, end;\n    LineSegment(const Point &start, const Point &end) : start(start), end(end) {}\n    LineSegment(double x1=0, double y1=0, double x2=0, double y2=0) : start(Point(x1, y1)), end(Point(x2, y2)) {}\n    string to_s() {\n        ostringstream os;\n        os << '(' << start.x << ',' << start.y << ')' << '-' << '(' << end.x << ',' << end.y << ')' << endl;\n        return os.str();\n    }\n    Line toLine() const {\n        return Line::fromPoints(start, end);\n    }\n    bool intersects(const Line &l) const {\n        double t1 = l.a * start.x + l.b * start.y + l.c;\n        double t2 = l.a * end.x + l.b * end.y + l.c;\n        return t1 * t2 <= 0;\n    }\n    bool intersects(const LineSegment &s) const {\n        return intersects(s.toLine()) && s.intersects(toLine());\n    }\n    Point intersectionPoint(const LineSegment &s) const {\n        if (!intersects(s)) {\n            throw \"The 2 line segments are parallel\";\n        }\n        return (toLine().intersectionPoint(s.toLine()));\n    }\n};\n\nint main() {\n    Point s, e;\n    while (cin >> s.x >> s.y >> e.x >> e.y) {\n        if (s.x == 0 && s.y == 0 && e.x == 0 && e.y == 0) break;\n\n        LineSegment seg[3];\n        seg[0] = LineSegment(s, e);\n        for (int i = 1; i < 3; i++) {\n            cin >> s.x >> s.y >> e.x >> e.y;\n            seg[i] = LineSegment(s, e);\n        }\n\n        if (!seg[0].intersects(seg[1]) || !seg[1].intersects(seg[2])\n                                       || !seg[2].intersects(seg[0])) {\n            cout << \"kyo\" << endl;\n            break;\n        }\n\n        Point vertex[3];\n        vertex[0] = seg[0].intersectionPoint(seg[1]);\n        vertex[1] = seg[1].intersectionPoint(seg[2]);\n        vertex[2] = seg[2].intersectionPoint(seg[0]);\n        if (vertex[0] == vertex[1] && vertex[1] == vertex[2]) {\n            cout << \"kyo\" << endl;\n            break;\n        }\n        \n        double area = (vertex[1] - vertex[0]).cross(vertex[2] - vertex[0]) / 2.0;\n        if (area < 100000) {\n            cout << \"syo-kichi\" << endl;\n        } else if (area < 1000000) {\n            cout << \"kichi\" << endl;\n        } else if (area < 1900000) {\n            cout << \"chu-kichi\" << endl;\n        } else {\n            cout << \"dai-kichi\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define EPS (1e-5)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nstruct Circle;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l); // 誤差の検証をしていない\nbool intersect(Circle c1, Circle c2); // 誤差の検証をしていない\n\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point,Point> getCrossPoints(Circle c, Line l);\npair<Point,Point> getCrossPoints(Circle c1, Circle c2); // 誤差の検証をしていない\npair<Point,Point> getContactPoints(Circle c, Point p); // 接点 点は円の外部\n\ndouble area(Polygon g); // convexでなくてもよい. absを消せば符号付き面積\nbool isConvex(Polygon g); // O(n^2) 線形時間アルゴリズムが存在するらしい\nint contains(Polygon g, Point p);\n\ndouble arg(Vector p);   // 偏角\nVector polar(double a, double r); // 極座標系->ベクトル\n\nPolygon andrewScan(Polygon g); // 凸包の辺上の点も含めたければ!=CLOCKWISEを==COUNTER_CLOCKWISEに\ndouble convexDiameter(Polygon g); // gはconvex \n\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l){\n    return getDistanceLP(l, c.c) < c.r+EPS;\n}\nbool intersect(Circle c1, Circle c2){\n    return abs(c1.r-c2.r) <= getDistance(c1.c, c2.c) && getDistance(c1.c, c2.c) < c1.r+c2.r+EPS;\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1-s2.p1));\n    double d2 = abs(cross(base, s1.p2-s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point,Point> getCrossPoints(Circle c, Line l){\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n    assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos( (c1.r*c1.r + d*d - c2.r*c2.r)/(2*c1.r*d) );\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\npair<Point,Point> getContactPoints(Circle c, Point p){\n    assert(c.r < getDistance(c.c, p));\n    double d = getDistance(c.c, p);\n    return getCrossPoints(c, Circle(p, sqrt(d*d-c.r*c.r)));\n}\n\ndouble area(Polygon g){\n    if(g.size() < 3)    return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for(int i = 0; i < n; i++)  s += cross(g[i]-o, g[(i+1)%n]-o);\n    return abs(s) / 2.0;\n}\n\nbool isConvex(Polygon g){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            if(cross(g[i]-g[(i+n-1)%n], g[j]-g[(i+n-1)%n]) < -EPS || cross(g[(i+1)%n]-g[i], g[j]-g[i]) < -EPS){\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i+1)%n] - p;\n        if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)   return ON;\n        if(a.y > b.y)   swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return x ? IN : OUT;\n}\n\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(a * cos(r), a * sin(r));\n}\n\n\nPolygon andrewScan(Polygon g){\n    Polygon u, l;\n    if(g.size() < 3)    return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size()-1]);\n    l.push_back(g[g.size()-2]);\n\n    // upper\n    for(int i = 2; i < g.size(); i++){\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], g[i]) != CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for(int i = g.size()-3; i >= 0; i--){\n        for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], g[i]) != CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size()-2; i >= 1; i--)    l.push_back(u[i]);\n\n    return l;\n}\n\ndouble convexDiameter(Polygon g){\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n        if(g[i].y > g[is].y)    is = i;\n        if(g[i].y < g[js].y)    js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        if(cross(g[(i+1)%n]-g[i], g[(j+1)%n]-g[j]) >= 0.0)  j = (j+1)%n;\n        else    i = (i+1)%n;\n        if(getDistance(g[i], g[j]) > d){\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    }while(i != is || j != js);\n\n    return d; // farthest pair is (maxi, maxj).\n}\n\n\n\nint main(){\n    int a, b, c, d;\n    Point p[6];\n    while(cin >> a >> b >> c >> d, a!=0||b!=0||c!=0||d!=0){\n        p[0] = Point(a, b), p[1] = Point(c, d);\n        cin >> a >> b >> c >> d;\n        p[2] = Point(a, b), p[3] = Point(c, d);\n        cin >> a >> b >> c >> d;\n        p[4] = Point(a, b), p[5] = Point(c, d);\n        Polygon g;\n        bool valid = true;\n        for(int i = 0; i < 3; i++){\n            for(int j = i+1; j < 3; j++){\n                if(intersect(p[2*i], p[2*i+1], p[2*j], p[2*j+1])){\n                    g.push_back(getCrossPoint(Segment(p[2*i], p[2*i+1]), Segment(p[2*j], p[2*j+1])));\n                }else{\n                    valid = false;\n                }\n            }\n        }\n        for(int i = 0; i < g.size(); i++){\n            for(int j = i+1; j < g.size(); j++){\n                if(equals(g[i].x,g[j].x) && equals(g[i].y,g[j].y))  valid = false;\n            }\n        }\n        if(!valid){\n            cout << \"kyo\" << endl;\n            continue;\n        }\n        double s = area(g);\n        if(s >= 1900000)        cout << \"dai-kichi\" << endl;\n        else if(s >= 1000000)   cout << \"chu-kichi\" << endl;\n        else if(s >= 100000)    cout << \"kichi\" << endl;\n        else                    cout << \"syo-kichi\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      point p[3];\n      for(int i=0;i<2;i++)\n\t    p[i]=intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b);\n      p[2]=intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b);\n\n      double z=(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]))/2;\n      double res=sqrt(z*(z-dist(p[0],p[1]))*(z-dist(p[1],p[2]))*(z-dist(p[2],p[0])));\n\n      if(res>=1900000-EPS)cout <<\"dai-kichi\"<<endl;\n      else if(res>=1000000-EPS && res<1900000)cout <<\"chu-kichi\"<<endl;\n      else if(res>=100000-EPS && res<1000000)cout <<\"kichi\"<<endl;\n      else cout << \"syo-kichi\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0-EPS)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0-EPS)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0-EPS)cout<<\"kichi\"<<endl;\n    else if(area>0.0)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define EPS (1e-10)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPoint getCorssPoint(Segment s1,Segment s2)\n{\n  return getCrossPoint(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\ndouble getArea(vector<Point>& vec)\n{\n  double sum = 0;\n  for(int i=0;i<3;i++)\n    sum += cross(vec[i],vec[(i+1)%3]);\n  return fabs(sum)/2.0;\n}\n\n\n\nint main()\n{\n\n int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n\n      if(!isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n      vector<Point> vec;\n      vec.push_back(c1),vec.push_back(c2),vec.push_back(c3);\n      double area = getArea(vec);\n\n      if(area >= 1900000)\n\tcout << \"dai-kichi\" << endl;\n      else if(area >= 1000000)\n\tcout << \"chu-kichi\" << endl;\n      else if(area >= 100000)\n\tcout << \"kichi\" << endl;\n      else if(area > 0)\n\tcout << \"syo-kichi\" << endl;\n      else \n\tcout << \"kyo\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool sameline(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  return (abs(A) < EPS && abs(B) < EPS) ; // same line\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  while(1) {\n    L ls[3];\n    bool fff = 0;\n    REP(i,3) {\n      int x1,y1,x2,y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      if (!x1&&!y1&&!x2&&!y2) {\n        fff = 1;\n        break;\n      }\n      ls[i] = L(P(x1,y1), P(x2,y2));\n    }\n    if (fff) break;\n    \n    if (!intersectSS(ls[0], ls[1]) || !intersectSS(ls[1], ls[2]) || !intersectSS(ls[2],ls[0])\n        ||sameline(ls[0], ls[1]) ||sameline(ls[1], ls[2]) || sameline(ls[2], ls[0])) {\n      cout << \"kyo\" << endl;\n      continue;\n    }\n    P cp[3];\n    REP(i,3)\n      cp[i] = crosspoint(ls[i], ls[(i+1)%3]);\n    double S = cross(cp[2]-cp[0], cp[1]-cp[0]) / 2;\n\n//    cout << S << endl;\n    if (S >= 1900000) cout << \"dai-kichi\" << endl;\n    else if (S >= 1000000) cout << \"chu-kichi\" << endl;\n    else if (S >= 100000) cout << \"kichi\" << endl;\n    else if (S > EPS) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double INF = 1e8;\nconst double eps = 1e-8;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) : x(x), y(y) {};\n};\n\nclass LineSeg {\npublic:\n    bool vertical;\n    double a, b; // y = a * x + b\n    Point p1, p2;\n    double min_x, max_x, min_y, max_y;\n    LineSeg(Point p1, Point p2) : p1(p1), p2(p2) {\n        if (p1.x == p2.x) {\n            vertical = true;\n            a = 0;\n            b = 0;\n        } else {\n            vertical = false;\n            a = (p2.y - p1.y) / (p2.x - p1.x);\n            b = p1.y - a * p1.x;\n        }\n        min_x = min(p1.x, p2.x); max_x = max(p1.x, p2.x);\n        min_y = min(p1.y, p2.y); max_y = max(p1.y, p2.y);\n    }\n};\n\ndouble eq(double x, double y) {\n    return abs(x - y) < eps;\n}\n\nbool isParallel(LineSeg &L1, LineSeg &L2) {\n    if (L1.vertical && L2.vertical) return true;\n    if (!L1.vertical && !L2.vertical && abs(L1.a - L2.a) < eps) return true;\n    return false;\n}\n\nPoint intersection(LineSeg L1, LineSeg L2) {\n    if (isParallel(L1, L2)) {\n        return Point(INF, INF);\n    }\n    double x, y;\n    if (L1.vertical) {\n        x = L1.min_x;\n        y = L2.a * x + L2.b;\n    } else if (L2.vertical) {\n        x = L2.min_x;\n        y = L1.a * x + L1.b;\n    } else {\n        x = (L2.b - L1.b) / (L1.a - L2.a);\n        y = L1.a * x + L1.b;\n    }\n    if (x < L1.min_x || L1.max_x < x || y < L1.min_y || L1.max_y < y ||\n        x < L2.min_x || L2.max_x < x || y < L2.min_y || L2.max_y < y) {\n        return Point(INF, INF);\n    }\n    return Point(x, y);\n}\n\ndouble areaOfTriangle(Point A, Point B, Point C) {\n    return abs((B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x)) / 2.0;\n}\n\nint main() {\n    int x1, y1, x2, y2;\n    while (cin >> x1 >> y1 >> x2 >> y2, (x1 || y1 || x2 || y2)) {\n\n        vector<LineSeg> L;\n        L.push_back( LineSeg(Point(x1,y1), Point(x2,y2)) );\n        for (int i=1; i<3; ++i) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            L.push_back( LineSeg(Point(x1,y1), Point(x2,y2)) );\n        }\n\n        bool kyo = false;\n        vector<Point> P;\n        for (int i=0; i<3 && !kyo; ++i) {\n            for (int j=i+1; j<3 && !kyo; ++j) {\n                Point p = intersection(L[i], L[j]);\n                if (p.x == INF) {\n                    kyo = true;\n                } else {\n                    P.push_back(p);\n                }\n            }\n        }\n\n        if (kyo) {\n            cout << \"kyo\" << endl;\n        } else {\n            double area = areaOfTriangle(P[0], P[1], P[2]) + eps;\n            if (1900000 <= area) {\n                cout << \"dai-kichi\" << endl;\n            } else if (1000000 <= area) {\n                cout << \"chu-kichi\" << endl;\n            } else if (100000 <= area) {\n                cout << \"kichi\" << endl;\n            } else {\n                cout << \"syo-kichi\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <string>\n#define EPS 1e-10\nusing namespace std;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct point{\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tpoint operator +(point p){\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\tpoint operator -(point p){\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\tpoint operator *(double d){\n\t\treturn point(x*d,y*d);\n\t}\n\tdouble dot(point p){\n\t\treturn add(p.x*x,p.y*y);\n\t}\n\tdouble det(point p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tdouble len(){\n\t\treturn sqrt(add(x*x,y*y));\n\t}\n};\n\nbool on_seg(point p1,point p2,point q){\n\treturn (p2-p1).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n\npoint intersection(point p1,point p2,point q1,point q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\ndouble x[4][4];\ndouble y[4][4];\npoint p[8];\npoint g[3];\ndouble len[3];\nstring check(){\n\tif((p[0]-p[2]).dot(p[1]-p[3])==0)return \"kyo\";\n\tg[0]=intersection(p[0],p[1],p[2],p[3]);\n\tif(!(on_seg(p[0],p[1],g[0]) && on_seg(p[2],p[3],g[0])))return \"kyo\";\n\t\n\tif((p[0]-p[4]).dot(p[1]-p[5])==0)return \"kyo\";\n\tg[1]=intersection(p[0],p[1],p[4],p[5]);\n\tif(!(on_seg(p[0],p[1],g[1]) && on_seg(p[4],p[5],g[1])))return \"kyo\";\n\t\n\tif((p[2]-p[4]).dot(p[3]-p[5])==0)return \"kyo\";\n\tg[2]=intersection(p[2],p[3],p[4],p[5]);\n\tif(!(on_seg(p[2],p[3],g[2]) && on_seg(p[4],p[5],g[2])))return \"kyo\";\n\t\n\tlen[0]=(g[0]-g[1]).len();\n\tlen[1]=(g[1]-g[2]).len();\n\tlen[2]=(g[0]-g[2]).len();\n\tdouble s=(len[0]+len[1]+len[2])/2.0;\n\tdouble S=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n\tif(S<EPS)return \"kyo\";\n\tif(S<100000.0)return \"syo-kichi\";\n\tif(S<1000000.0)return \"kichi\";\n\tif(S<1900000.0)return \"chu-kichi\";\n\treturn \"dai-kichi\";\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%lf %lf %lf %lf\",&x[0][0],&y[0][0],&x[1][0],&y[1][0]);\n\t\tif(x[0][0]==0.0 && y[0][0]==0.0 && x[1][0]==0.0 && y[1][0]==0.0)break;\n\t\tp[0]=point(x[0][0],y[0][0]);\n\t\tp[1]=point(x[1][0],y[1][0]);\n\t\tfor(int i=1;i<=2;i++){\n\t\t\tscanf(\"%lf %lf %lf %lf\",&x[0][i],&y[0][i],&x[1][i],&y[1][i]);\n\t\t\tp[i*2+0]=point(x[0][i],y[0][i]);\n\t\t\tp[i*2+1]=point(x[1][i],y[1][i]);\n\t\t}\n\t\tcout << check() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define EPS (1e-7)\n\ntypedef complex<double> P;\nstruct Line : public vector<P>\n{\n  Line() {\n  }\n  Line(P a, P b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\ndouble cross(P const& a, P const& b) {\n  return imag(conj(a)*b);\n}\n\nbool is_cross_ss(Line const& a, Line const& b) {\n  return ( cross(a[1]-a[0], b[0]-a[0]) * cross(a[1]-a[0], b[1]-a[0]) < EPS )\n    && ( cross(b[1]-b[0], a[0]-b[0]) * cross(b[1]-b[0], a[1]-b[0]) < EPS );\n}\n\nP crosspoint_ss(Line const& a, Line const& b) {\n  P vb = b[1]-b[0];\n  double d1 = abs(cross(vb, a[0]-b[0]));\n  double d2 = abs(cross(vb, a[1]-b[0]));\n  double t = d1 / (d1+d2);\n  return a[0] + (a[1]-a[0]) * t;\n}\n\nbool operator == (P const& a, P const& b) {\n  return ( abs(a.real()-b.real()) < EPS && abs(a.imag()-b.imag()) < EPS );\n}\n\nint main() {\n  \n  while(1) {\n    Line l[3];\n    rep(i, 3) {\n      double sx, sy, gx, gy;\n      cin >> sx >> sy >> gx >> gy;\n      if(i == 0 && sx == 0 && sy == 0 && gx == 0 && gy == 0) return 0;\n      l[i] = Line(P(sx, sy), P(gx, gy));\n    }\n    \n    \n    vector<P> ps;\n    rep(i, 3) {\n      if(is_cross_ss(l[i], l[(i+1)%3])) {\n        P cp = crosspoint_ss(l[i], l[(i+1)%3]);\n        bool ok = 1;\n        rep(j, (int)ps.size())\n          if(ps[j] == cp) { ok = 0; }\n        if(ok) {\n          ps.push_back(cp);\n        }\n      }\n    }\n    \n    if(ps.size() < 3) {\n      cout << \"kyo\\n\";\n      continue;\n    }\n    if(ps.size() > 3) {\n      assert(false && \"sine\");\n    }\n    \n    double ans = abs(ps[1]-ps[0])*abs(ps[2]-ps[0]) / 2.;\n    if(ans >= 1900000.) {\n      cout << \"dai-kichi\\n\";\n    }\n    else if(ans >= 1000000.) {\n      cout << \"chu-kichi\\n\";\n    }\n    else if(ans >= 100000.) {\n      cout << \"kichi\\n\";\n    }\n    else if(ans > EPS) {\n      cout << \"syo-kichi\\n\";\n    }\n    else {\n      cout << \"kyo\\n\";\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nbool cmpx(Point &a,Point &b){\n    return !equals(real(a),real(b))?real(a)<real(b):imag(a)<imag(b);\n}\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nvoid getLine(Line &l){\n    getSegment(l);\n}\n\nvoid getCircle(Circle &c){\n    getPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return isOrthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return isParallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool isIntersectSS(Segment s1,Segment s2){\n    return isIntersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getDistancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceLL(Line l,Line m){\n    if(isParallel(l,m))return getDistanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(isIntersectSS(s1,s2))return 0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ndouble area(Polygon g){\n    double res=0.0;\n    for(int i=0;i<g.size();i++){\n        res+=cross(curr(g,i),next(g,i));\n    }\n    return res/2.0;\n}\n\nbool isConvex(Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\nbool isIntersectCL(Circle c,Line l){\n    return getDistanceLP(l,c.p)<=c.r+EPS;\n}\n\nbool isIntersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\npair<Point,Point>getCrossPointsCL(Circle c,Line l){\n    assert(isIntersectCL(c,l));\n\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>getCrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\nint main(){\n    Segment a,b,c;\n    while(true){\n        getSegment(a);\n        if(a.p1.real()==0&&a.p1.imag()==0&&a.p2.real()==0&&a.p2.imag()==0)break;\n        getSegment(b);\n        getSegment(c);\n\n        if(!isIntersectSS(a,b)||!isIntersectSS(b,c)||!isIntersectSS(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n        if(isParallel(a,b)||isParallel(b,c)||isParallel(c,a)){\n            puts(\"kyo\");\n            continue;\n        }\n\n        Polygon g;\n        g.push_back(getCrossPointSS(a,b));\n        g.push_back(getCrossPointSS(b,c));\n        g.push_back(getCrossPointSS(c,a));\n\n        if(equalsv(g[0],g[1])||equalsv(g[1],g[2])||equalsv(g[2],g[0])){\n            puts(\"kyo\");\n            continue;\n        }\n        double x=area(g);\n        if(x<EPS)puts(\"kyo\");\n        else if(x<100000-EPS)puts(\"syo-kichi\");\n        else if(x<1000000-EPS)puts(\"kichi\");\n        else if(x<1900000-EPS)puts(\"chu-kichi\");\n        else puts(\"dai-kichi\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { }};\nint ccw(P a, P b, P c) {b -= a; c -= a;if (cross(b, c) > 0)   return +1;if (cross(b, c) < 0)   return -1;if (dot(b, c) < 0) return +2;if (norm(b) < norm(c)) return -2;return 0;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nP crosspoint(const L &l, const L &m) {double A = cross(l[1] - l[0], m[1] - m[0]);double B = cross(l[1] - l[0], l[1] - m[0]);if (abs(A) < EPS && abs(B) < EPS) return m[0];return m[0] + B / A * (m[1] - m[0]);}\ndouble area2(P a, P b , P c){\n\t\tb-=a, c-=a;\n\t\treturn fabs( b.real() * c.imag() - c.real() * b.imag() )/2; \n}\nint main(){\n\tdouble a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a+b+c+d != 0){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tdouble ret = 0;\n\t\t\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tret = area2( crosspoint(one,two) , crosspoint(two,three) , crosspoint(one,three) );\n\t\t}\n\t\tif(ret >= 1900000){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if(ret >= 1000000){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if(ret >= 100000){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret > 0){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-a1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nVP v;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      v.clear();\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointLL(p[0].first,p[0].second,p[2].first,p[2].second));\n      sort(v.begin(),v.end());\n      D are=area(v);\n      if(are>=1900000-EPS)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000-EPS)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000-EPS)cout<<\"kichi\"<<endl;\n      else cout<<\"syo-kichi\"<<endl;\n      //else exit(1);\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst double EPS = 1e-8;\n\nstruct Point{\n    double cross(const Point& rp) const{\n        return this->x*rp.y - this->y*rp.x;\n    }\n    double dot(const Point& rp) const{\n        return this->x*rp.x + this->y*rp.y;\n    }\n    double norm() const{\n        double x = this->x, y = this->y;\n        return x*x + y*y;\n    }\n    double abs() const{\n        return std::sqrt(norm());\n    }\n\n    double x, y;\n};\n\nPoint operator-(const Point& lhs, const Point& rhs){\n    return {lhs.x-rhs.x, lhs.y-rhs.y};\n}\nPoint operator+(const Point& lhs, const Point& rhs){\n    return {lhs.x+rhs.x, lhs.y+rhs.y};\n}\nPoint operator*(const Point& lhs, const double& val){\n    return {val*lhs.x, val*lhs.y};\n}\nPoint operator*(const double& val, const Point& rhs){\n    return {val*rhs.x, val*rhs.y};\n}\n\nstruct Segment{\n    bool doesIntersect(const Segment& rl) const{\n        Point ab = this->distination - this->source,\n            ac = rl.source - this->source,\n            ad = rl.distination - this->source,\n            cd = rl.distination - rl.source,\n            ca = this->source - rl.source,\n            cb = this->distination - rl.source;\n        return ab.cross(ac) * ab.cross(ad) < EPS &&\n               cd.cross(ca) * cd.cross(cb) < EPS;\n    }\n    Point intersectPoint(const Segment& rl) const{\n        if(!doesIntersect(rl)){} // ない\n        \n        Point ab = this->distination - this->source,\n            ac = rl.source - this->source,\n            bd = rl.distination - this->distination;\n        double dc = std::abs(ab.cross(ac)),\n            dd = std::abs(ab.cross(bd));\n        \n        \n        return rl.source + (dc / (dc+dd)) * (rl.distination - rl.source);\n    }\n    Point source, distination;\n};\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nSegment ss[3];\n\ndouble triangleArea(Point p1, Point p2, Point p3){\n    Point v1 = p2-p1, v2 = p3-p1;\n    return 0.5 * std::abs(v1.cross(v2));\n}\n\nstd::string solve(){\n    const std::string resultText[] = {\"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\"};\n    \n    if(!ss[0].doesIntersect(ss[1]) ||\n       !ss[1].doesIntersect(ss[2]) ||\n       !ss[2].doesIntersect(ss[0])){\n        return resultText[4];\n    }\n\n    Point p1 = ss[0].intersectPoint(ss[1]),\n        p2 = ss[1].intersectPoint(ss[2]),\n        p3 = ss[2].intersectPoint(ss[0]);\n\n    double area = triangleArea(p1, p2, p3);\n    // printf(\"%.10f\\n\", area);\n    if(area + EPS > 1900000.0){\n        return resultText[0];\n    }else if(area + EPS > 1000000.0){\n        return resultText[1];\n    }else if(area + EPS > 100000.0){\n        return resultText[2];\n    }else if(area > 0.0){\n        return resultText[3];\n    }\n    return resultText[4];\n}\n\nint main(){\n    while(true){\n        std::cin >> ss[0].source.x >> ss[0].source.y >> ss[0].distination.x >> ss[0].distination.y;\n        if(std::abs(ss[0].source.x) < EPS &&\n           std::abs(ss[0].source.y) < EPS &&\n           std::abs(ss[0].distination.x) < EPS &&\n           std::abs(ss[0].distination.y) < EPS){\n            break;\n        }\n\n        FOR(i, 1, 3){\n            std::cin >> ss[i].source.x >> ss[i].source.y >> ss[i].distination.x >> ss[i].distination.y;\n        }\n        \n        std::cout << solve() << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0)cout<<\"kichi\"<<endl;\n    else if(area>=0.0)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\ntypedef long long int Int;\nconst Int N = 3;\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nInt ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\npair<bool, P> crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return pair<bool, P>(0, m[0]); // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return pair<bool, P>(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nbool input(L &l){\n  Int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n  l = L(P(x1, y1), P(x2, y2));\n  return (x1 != 0 || y1 != 0 || x2 != 0 || y2 != 0);\n}\n\ndouble area(const G &P) {\n  double A = 0.0;\n  for (Int i = 0; i < P.size(); ++i) A += cross(curr(P, i), next(P, i));\n  return abs(A / 2.0);\n}\n\nstring solve(L ls[N]){\n  G g;\n  REP(i, N){\n    if(!intersectSS(ls[i], ls[(i + 1) % N])) continue;\n    else{\n      pair<bool, P> res = crosspointLL(ls[i], ls[(i + 1) % N]);\n      if(res.first) g.push_back(res.second);\n    }\n  }\n  double r = area(g);\n  if(g.size() < 3) return \"kyo\";\n  if(r < 100000) return \"syo-kichi\";\n  if(r < 1000000) return \"kichi\";\n  if(r < 1900000) return \"chu-kichi\";\n  return \"dai-kichi\";\n}\n\nint main() {\n  L ls[N];\n  while(input(ls[0])){\n    FOR(i, 1, N) input(ls[i]);\n    cout <<solve(ls) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\ndouble getTriArea( double x1, double y1, double x2,double y2, double x3, double y3 ){\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);sum /= 2;\n  return sum;\n}\n\ndouble getTriArea( Point a,Point b,Point c){\n  return getTriArea(a.x , a.y , b.x , b.y , c.x , c.y);\n}\n\n\nint main(){\n  Segment a,b,c;\n  Point d,e,f;\n  while(cin>>a.p1.x>>a.p1.y>>a.p2.x>>a.p2.y){\n    if(a.p1.x==0&&a.p1.y==0&&a.p2.x==0&&a.p2.y==0)break;\n    cin>>b.p1.x>>b.p1.y>>b.p2.x>>b.p2.y;\n    cin>>c.p1.x>>c.p1.y>>c.p2.x>>c.p2.y;\n    \n    if(!isIntersect(a,b)||!isIntersect(b,c)||!isIntersect(c,a)){\n      cout<<\"kyo\"<<endl;\n      continue;\n    }\n    \n    d=getCrossPoint(a,b);e=getCrossPoint(b,c);f=getCrossPoint(c,a);\n    double area = getTriArea(d,e,f);\n    if(area>=1900000.0-EPS)cout<<\"dai-kichi\"<<endl;\n    else if(area>=1000000.0-EPS)cout<<\"chu-kichi\"<<endl;\n    else if(area>=100000.0-EPS)cout<<\"kichi\"<<endl;\n    else if(area>0.0-EPS)cout<<\"syo-kichi\"<<endl;\n    else cout<<\"kyo\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n#ifdef _MSC_VER\n#include \"_lib_msc.h\"\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           for(int(i)=0;(i)<(n);++(i))\n#define REPEAT(i, k, n)     for(int(i)=(k);(i)<((k)+(n));++(i))\n#define RREP(i, n)          for(int(i)=(n)-1;(i)>=0;--(i))\n#define RREPEAT(i, k, n)    for(int(i)=(k)+(n)-1;(i)>=(k);--(i))\n#define FROMTO(i,f,t)       for(int(i)=(f);(i)<(t);(++i))\n#define ALL(c)              (c).begin(), (c).end()\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p2<p1)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\ninline int clz(ui n){return n==0?32:__builtin_clz(n);}\ninline int clz(ull n){return n==0?64:__builtin_clzll(n);}\ninline int crz(ui n){return n==0?32:__builtin_ctz(n);}\ninline int crz(ull n){return n==0?64:__builtin_ctzll(n);}\ninline int bitc(ui n){return __builtin_popcount(n);}\ninline int bitc(ull n){return __builtin_popcountll(n);} \n#ifdef _DEBUG\n#include \"_lib_dbg.h\"\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n#endif\n\nconst char *tbl[] = { \"dai-kichi\",\"chu-kichi\",\"kichi\",\"syo-kichi\",\"kyo\" };\n\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\nbool is_parallel(const P &a, const P &b, const P &c, const P &d){\n    return DEQ(outprd(a-b, c-d), 0.0);\n}\nbool is_intersected_ls(const P &a, const P &b, const P &c, const P &d){\n    return (outprd(b-a, c-a) * outprd(b-a, d-a) < EPS) && (outprd(d-c, a-c) * outprd(d-c, b-c) < EPS);\n}\nP intersection_l(const P &a, const P &b, const P &c, const P &d) {\n    P v1 = b - a; P v2 = d - c;\n    return a + v1 * outprd(v2, c-a) / outprd(v2, v1);\n}\nD triangle_S(P p1, P p2, P p3){\n    D l1 = sqrt(norm(p1-p2));\n    D l2 = sqrt(norm(p2-p3));\n    D l3 = sqrt(norm(p3-p1));\n    D z = (l1 + l2 + l3) / 2;\n    return sqrt(z * (z - l1) * (z - l2) * (z - l3));\n}\n\nint solve(int *x1, int *y1, int *x2, int *y2){\n    P p11(x1[0],y1[0]), p12(x2[0],y2[0]);\n    P p21(x1[1],y1[1]), p22(x2[1],y2[1]);\n    P p31(x1[2],y1[2]), p32(x2[2],y2[2]);\n    if(is_parallel(p11,p12,p21,p22)) return 4;\n    if(is_parallel(p21,p22,p31,p32)) return 4;\n    if(is_parallel(p31,p32,p11,p12)) return 4;\n    if(!is_intersected_ls(p11,p12,p21,p22)) return 4;\n    if(!is_intersected_ls(p21,p22,p31,p32)) return 4;\n    if(!is_intersected_ls(p31,p32,p11,p12)) return 4;\n    P p1 = intersection_l(p11,p12,p21,p22);\n    P p2 = intersection_l(p21,p22,p31,p32);\n    P p3 = intersection_l(p31,p32,p11,p12);\n    if(DEQ(p1,p2) || DEQ(p2,p3) || DEQ(p3,p1)) return 4;\n    D s = triangle_S(p1,p2,p3);\n    if(s + EPS >= 1900000.0) return 0;\n    if(s + EPS >= 1000000.0) return 1;\n    if(s + EPS >= 100000.0) return 2;\n    return 3;\n}\n\nint main(void){\n    int x1[3],y1[3],x2[3],y2[3];\n    while(1){\n        cin >> x1[0] >> y1[0] >> x2[0] >> y2[0];\n        if(x1[0] == 0 && y1[0] == 0 && x2[0] == 0 && y2[0] == 0) break;\n        cin >> x1[1] >> y1[1] >> x2[1] >> y2[1];\n        cin >> x1[2] >> y1[2] >> x2[2] >> y2[2];\n        cout << tbl[solve(x1,y1,x2,y2)] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n \n/* ?????????????????´???????????????????????????????????????????????\\????????´????????????????????¨????????????isec???intersect?????\\ */\n \n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n  // return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nP crosspointSS(P a1, P a2, P b1, P b2){\n  P p=b2-b1;\n  double d1=abs(cross(p,a1-b1));\n  double d2=abs(cross(p,a2-b1));\n  double t=d1/(d1+d2);\n  return a1+(a2-b1)*t;\n}\n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// ???????§???¢????????¨?????????O(logn)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// ????§???¢????????¨??????\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// ???????§???¢?????????????????°\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n \n// ???????§???¢?????´?????????????????????\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n \n// ????§???¢????¬?????????¢???\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nL p[3];\nD x,y,xx,yy;\nint main(){\n  while(cin>>x>>y>>xx>>yy,xx||yy||y||x){\n    p[0].first=P(x,y);\n    p[0].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[1].first=P(x,y);\n    p[1].second=P(xx,yy);\n    cin>>x>>y>>xx>>yy;\n    p[2].first=P(x,y);\n    p[2].second=P(xx,yy);\n    if(isecSS(p[0].first,p[0].second,p[1].first,p[1].second)&&isecSS(p[0].first,p[0].second,p[2].first,p[2].second)&&isecSS(p[2].first,p[2].second,p[1].first,p[1].second)){\n      VP v;\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[2].first,p[2].second,p[1].first,p[1].second));\n      v.push_back(crosspointSS(p[0].first,p[0].second,p[2].first,p[2].second));\n      D are=area(v);\n      if(are>=1900000)cout<<\"dai-kichi\"<<endl;\n      else if(are>=1000000)cout<<\"chu-kichi\"<<endl;\n      else if(are>=100000)cout<<\"kichi\"<<endl;\n      else cout<<\"syo-kichi\"<<endl;\n    }\n    else cout<<\"kyo\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/////////////////////???Library???/////////////////////////\n\nint xx1, yy1, xx2, yy2;\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tif (xx1 == 0 && yy1 == 0 && xx2 == 0 && yy2 == 0) break;\n\t\t\n\t\tSegment s1(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s2(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s3(Point(xx2, yy2), Point(xx1, yy1));\n\n\t\tif (isParallel(s1, s2) || isParallel(s1, s3) || isParallel(s2, s3))\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint kousa_num = 0;\n\t\tif (intersect(s1, s2)) kousa_num++;\n\t\tif (intersect(s1, s3)) kousa_num++;\n\t\tif (intersect(s2, s3)) kousa_num++;\n\t\t//printf(\"kousa_num = %d\\n\", kousa_num);\n\t\tif (kousa_num <= 2)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tPoint p1 = getCrossPoint(s1, s2);\n\t\tPoint p2 = getCrossPoint(s1, s3);\n\t\tPoint p3 = getCrossPoint(s2, s3);\n\n\t\t/*\n\t\tprintf(\"p1 = (%f, %f)\\n\", p1.x, p1.y);\n\t\tprintf(\"p2 = (%f, %f)\\n\", p2.x, p2.y);\n\t\tprintf(\"p3 = (%f, %f)\\n\", p3.x, p3.y);\n\t\t*/\n\n\t\tif (p1 == p2 && p2 == p3)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVector v12 = p2 - p1;\n\t\tVector v13 = p3 - p1;\n\n\t\tdouble ans = fabs(cross(v12, v13) / 2.0f);\n\t\tif (ans >= 1900000.0f) printf(\"dai-kichi\\n\");\n\t\telse if (ans >= 1000000.0f) printf(\"chu-kichi\\n\");\n\t\telse if (ans >= 100000.0f) printf(\"kichi\");\n\t\telse printf(\"syo-kichi\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\ndouble areaTriangle(polygon p) {\n\tp[0] = p[0] - p[2];\n\tp[1] = p[1] - p[2];\n\treturn fabs(p[0].x * p[1].y - p[1].x * p[0].y) / 2.0;\n}\n\nstring omikuji(const vector<segment>& segments) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tconst segment& s = segments[i], t = segments[(i + 1) % 3];\n\t\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\t\tif(abs(tmp) < EPS || !intersect(s, t))\n\t\t\treturn \"kyo\";\n\t}\n\n\tpolygon triangle;\n\tfor(int i = 0; i < 3; ++i)\n\t\ttriangle.push_back(crosspoint(segments[i], segments[(i + 1) % 3]));\n\n\tconst double area_of_triangle = area(triangle); //areaTriangle(triangle);\n\tif(area_of_triangle >= 1900000)\n\t\treturn \"dai-kichi\";\n\n\tif(area_of_triangle >= 1000000)\n\t\treturn \"chu-kichi\";\n\n\tif(area_of_triangle >= 100000)\n\t\treturn \"kichi\";\n\n\tif(area_of_triangle > 0)\n\t\treturn \"syo-kichi\";\n\n\treturn \"kyo\";\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y, x2, y2; cin >> x >> y >> x2 >> y2, (x | y | x2 | y2);) {\n\t\tvector<segment> segments;\n\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y >> x2 >> y2;\n\t\t\tsegments.push_back(segment(point(x, y), point(x2, y2)));\n\t\t}\n\n\t\tstring result = omikuji(segments);\n\t\tcout << result << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/22 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nbool kousa(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tif(((x1-x2)*(y3-y1)+(y1-y2)*(x1-x3))*((x1-x2)*(y4-y1)+(y1-y2)*(x1-x4))<0\n\t &&((x3-x4)*(y1-y3)+(y3-y4)*(x3-x1))*((x3-x4)*(y2-y3)+(y3-y4)*(x3-x2))<0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\ndouble koutenX(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tint bunbo = (x1-x2)*(y3-y4)-(x3-x4)*(y1-y2);\n\tint bunsi = (x3-x4)*(x1*y2-x2*y1)-(x1-x2)*(x3*y4-x4*y3);\n\n\treturn (double)bunsi/(double)bunbo;\n}\n\ndouble koutenY(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tint bunbo = (x1-x2)*(y3-y4)-(x3-x4)*(y1-y2);\n\tint bunsi = (y3-y4)*(x1*y2-x2*y1)-(y1-y2)*(x3*y4-x4*y3);\n\n\treturn (double)bunsi/(double)bunbo;\n}\n\nint main()\n{\n\twhile(true){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif(x1==0&&y1==0&&x2==0&&y2==0)\n\t\t\tbreak;\n\n\t\tint x3, y3, x4, y4;\n\t\tcin >> x3 >> y3 >> x4 >> y4;\n\t\tint x5, y5, x6, y6;\n\t\tcin >> x5 >> y5 >> x6 >> y6;\n\n\t\tif(kousa(x1, y1, x2, y2, x3, y3, x4, y4)==false\n\t\t ||kousa(x3, y3, x4, y4, x5, y5, x6, y6)==false\n\t\t ||kousa(x5, y5, x6, y6, x1, y1, x2, y2)==false){\n\t\t\tcout << \"kyo\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdouble X1 = koutenX(x1, y1, x2, y2, x3, y3, x4, y4);\n\t\tdouble Y1 = koutenY(x1, y1, x2, y2, x3, y3, x4, y4);\n\t\tdouble X2 = koutenX(x3, y3, x4, y4, x5, y5, x6, y6);\n\t\tdouble Y2 = koutenY(x3, y3, x4, y4, x5, y5, x6, y6);\n\t\tdouble X3 = koutenX(x5, y5, x6, y6, x1, y1, x2, y2);\n\t\tdouble Y3 = koutenY(x5, y5, x6, y6, x1, y1, x2, y2);\n\n\t\tdouble S = (X1*Y2+X2*Y3+X3*Y1-Y1*X2-Y2*X3-Y3*X1)/2.0;\n\t\tif(S<0.0)\n\t\t\tS *= -1.0;\n\n\t\t     if(S>=1900000.0)\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\telse if(S>=1000000.0)\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\telse if(S>= 100000.0)\n\t\t\tcout << \"kichi\" << endl;\n\t\telse if(S>       0.0)\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\telse\n\t\t\tcout << \"kyo\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//54\n#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool in(double a,double b,double c,double d){\n  return !(max(a,b)<min(c,d)||max(c,d)<min(a,b));\n}\n\nbool is(P *a,P *b){\n  return in(a[0].real(),a[1].real(),b[0].real(),b[1].real())\n    &&in(a[0].imag(),a[1].imag(),b[0].imag(),b[1].imag())\n    &&cr(a[1]-a[0],b[1]-a[0])*cr(a[1]-a[0],b[0]-a[0])<=0\n    &&cr(b[1]-b[0],a[1]-b[0])*cr(b[1]-b[0],a[0]-b[0])<=0;\n}\n\nint main(){\n  for(;;){\n    P l[3][2];\n    for(int i=0;i<3;i++){\n      int x,y,xx,yy;\n      cin>>x>>y>>xx>>yy;\n      if(i==0&&(x|y|xx|yy)==0)return 0;\n      l[i][0]=P(x,y);\n      l[i][1]=P(xx,yy);\n    }\n    double a=0;\n    if(is(l[0],l[1])&&is(l[1],l[2])&&is(l[2],l[0])){\n      P cp[3];\n      for(int i=0;i<3;i++){\n\tP a,b,c,d;\n\ta=l[i][0];\n\tb=l[i][1];\n\tc=l[(i+1)%3][0];\n\td=l[(i+1)%3][1];\n\tdouble d1=fabs(cr(a-b,c-b)),d2=fabs(cr(a-b,d-b));\n\tcp[i]=(d-c)*d1/(d1+d2)+c;\n      }\n      a=fabs(cr(cp[1]-cp[0],cp[2]-cp[0])/2);\n    }\n    double as[]={0,.1,100000,1000000,1900000};\n    const char *ls[]={\"kyo\",\"syo-kichi\",\"kichi\",\"chu-kichi\",\"dai-kichi\"};\n    cout<<ls[upper_bound(as,as+5,a)-as-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nbool isequal(const P& a, const P& b)\n{\n\treturn a.real()+EPS > b.real() && a.real() < b.real()+EPS &&\n\t\t   a.imag()+EPS > b.imag() && a.imag() < b.imag()+EPS;\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS; // non-parallel\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main()\n{\n\tint x1,y1,x2,y2;\n\twhile(scanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2), (x1||y1||x2||y2))\n\t{\n\t\tvector<L> Lines;\n\t\tvector<P> xp;\n\t\tLines.push_back(L(P(x1,y1),P(x2,y2)));\n\t\tfor(int i=0; i<2; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2);\n\t\t\tLines.push_back(L(P(x1,y1),P(x2,y2)));\n\t\t}\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\tfor(int j=i+1; j<3; j++)\n\t\t{\n\t\t\tif(!intersectLL(Lines[i], Lines[j])) g=false;\n\t\t\tif(!intersectSS(Lines[i], Lines[j])) g=false;\n\t\t\t\n\t\t\tif(g)\n\t\t\t{\n\t\t\t\txp.push_back(crosspoint(Lines[i], Lines[j]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<xp.size(); i++)\n\t\tfor(int j=i+1; j<xp.size(); j++)\n\t\t{\n\t\t\tif(isequal(xp[i], xp[j])) g=false;\n\t\t}\n\t\t\n\t\tif(!g)\n\t\t{\n\t\t\tputs(\"kyo\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble area=0.5*abs(((xp[1].real()-xp[0].real())*(xp[2].imag()-xp[0].imag())-(xp[2].real()-xp[0].real())*(xp[1].imag()-xp[0].imag())));\n\t\tif(area < 100000) puts(\"syo-kichi\");\n\t\telse if(area < 1000000) puts(\"kichi\");\n\t\telse if(area < 1900000) puts(\"chu-kichi\");\n\t\telse\tputs(\"dai-kichi\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-10;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    c -= a;\n    b -= a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isIntersect(L s1, L s2){\n    return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n             ccw(s2.first,s2.second,s2.first) * ccw(s2.first,s2.second,s1.second) <= 0);\n}\n\nP crossPoint(L l, L m){\n    double A = cross(l.second - l.first, m.second - m.first);\n    double B = cross(l.second - l.first, l.second - m.first);\n    if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n    else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n    double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum / 2.0);\n}\n\nstring ans(vector<P> v){\n    double a = area(v);\n    if(a < EPS) return \"kyo\";\n    if(a < 100000.0-EPS) return \"syo-kichi\";\n    if(a < 1000000.0-EPS) return \"kichi\";\n    if(a < 1900000.0-EPS) return \"chu-kichi\";\n    return \"dai-kichi\";\n}\n\nint main(){\n    double x1,y1,x2,y2;\n    while(cin >> x1 >> y1 >> x2 >> y2 && (x1||y1||x2||y2)){\n        L v[3];\n        vector<P> p;\n        bool f = false;\n        v[0] = L(P(x1,y1),P(x2,y2));\n        for(int i=1;i<3;i++) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            v[i] = L(P(x1,y1),P(x2,y2));\n            if(!isIntersect(v[0],v[i])) f = true;\n            else p.push_back(crossPoint(v[0],v[i]));\n        }\n        if(!isIntersect(v[1],v[2])) f = true;\n        else p.push_back(crossPoint(v[1],v[2]));\n\n        if(!f){\n            for(int i=0;i<3;i++){\n                for(int j=i+1;j<3;j++){\n                    if(abs(p[i]-p[j]) < EPS) f = true;\n                }\n            }\n        }\n\n        if(f) cout << \"kyo\" << endl;\n        else cout << ans(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tdouble q1,q2,q3,q4;\n\twhile(cin>>q1>>q2>>q3>>q4,q1||q2||q3||q4){\n\t\tL a(P(q1,q2),P(q3,q4));\n\t\tcin>>q1>>q2>>q3>>q4;\n\t\tL b(P(q1,q2),P(q3,q4));\n\t\tcin>>q1>>q2>>q3>>q4;\n\t\tL c(P(q1,q2),P(q3,q4));\n\t\tif(para(a,b)||para(b,c)||para(c,a)){cout<<\"kyo\"<<endl;continue;}\n\t\tif((!intersectSS(a,b))||(!intersectSS(c,b))||(!intersectSS(a,c))){cout<<\"kyo\"<<endl;continue;}\n\t\tP p1=crosspointLL(a,b);\n\t\tP p2=crosspointLL(c,b);\n\t\tP p3=crosspointLL(a,c);\n\t\tif(p1==p2||p2==p3||p3==p1){cout<<\"kyo\"<<endl;continue;}\n\t\tp2-=p1;\n\t\tp3-=p1;\n\t\tdouble S=abs(p2.real()*p3.imag()-p2.imag()*p3.real())/2.0;\n\t\tif(S<100000)cout<<\"syo-kichi\"<<endl;\n\t\telse if(S<1000000)cout<<\"kichi\"<<endl;\n\t\telse if(S<1900000)cout<<\"chu-kichi\"<<endl;\n\t\telse cout<<\"dai-kichi\"<<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/////////////////////???Library???/////////////////////////\n\nint xx1, yy1, xx2, yy2;\n\nsigned main()\n{\n\twhile (true)\n\t{\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tif (xx1 == 0 && yy1 == 0 && xx2 == 0 && yy2 == 0) break;\n\t\t\n\t\tSegment s1(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s2(Point(xx2, yy2), Point(xx1, yy1));\n\t\tcin >> xx1 >> yy1 >> xx2 >> yy2;\n\t\tSegment s3(Point(xx2, yy2), Point(xx1, yy1));\n\n\t\tif (isParallel(s1, s2) || isParallel(s1, s3) || isParallel(s2, s3))\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint kousa_num = 0;\n\t\tif (intersect(s1, s2)) kousa_num++;\n\t\tif (intersect(s1, s3)) kousa_num++;\n\t\tif (intersect(s2, s3)) kousa_num++;\n\t\t//printf(\"kousa_num = %d\\n\", kousa_num);\n\t\tif (kousa_num <= 2)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tPoint p1 = getCrossPoint(s1, s2);\n\t\tPoint p2 = getCrossPoint(s1, s3);\n\t\tPoint p3 = getCrossPoint(s2, s3);\n\n\t\t/*\n\t\tprintf(\"p1 = (%f, %f)\\n\", p1.x, p1.y);\n\t\tprintf(\"p2 = (%f, %f)\\n\", p2.x, p2.y);\n\t\tprintf(\"p3 = (%f, %f)\\n\", p3.x, p3.y);\n\t\t*/\n\n\t\tif (p1 == p2 && p2 == p3)\n\t\t{\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVector v12 = p2 - p1;\n\t\tVector v13 = p3 - p1;\n\n\t\tdouble ans = fabs(cross(v12, v13)) / 2.0f;\n\t\tif (ans >= 1900000.0f) printf(\"dai-kichi\\n\");\n\t\telse if (ans >= 1000000.0f) printf(\"chu-kichi\\n\");\n\t\telse if (ans >= 100000.0f) printf(\"kichi\");\n\t\telse printf(\"syo-kichi\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble compute_area(const Point &l,const Point &m){\n  return abs(cross(l,m)) / 2.0;\n}\n\nint main(){\n  int x1,y1,x2,y2;\n  while(~scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2)){\n    if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n    vector<Line> lines;\n    lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    \n    for(int i = 0; i < 2; i++){\n      scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n      lines.push_back(Line(Point(x1,y1),Point(x2,y2)));\n    }\n\n    bool isok = true;\n    \n    vector<Point> polygon;\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        if(intersectSS(lines[i],lines[j])){\n          Point p = crosspoint(lines[i],lines[j]);\n          polygon.push_back(p);\n        }\n        else{\n          isok = false;\n          goto ng;\n        }\n      }\n    }\n  ng:;\n\n    sort(polygon.begin(),polygon.end());\n    double area = -1.0;\n    if(isok){\n      area = compute_area(polygon[1] - polygon[0],polygon[2] - polygon[0]);\n    }\n\n    if(1900000.0 <= area){\n      printf(\"%s\\n\",\"dai-kichi\");\n    }\n    else if(1000000.0 <= area && area < 1900000.0){\n      printf(\"%s\\n\",\"chu-kichi\");\n    }\n    else if(100000.0 <= area && area < 1000000.0){\n      printf(\"%s\\n\",\"kichi\");\n    }\n    else if(0.0 <= area && area < 100000.0){\n      printf(\"%s\\n\",\"syo-kichi\");\n    }\n    else {\n      printf(\"%s\\n\",\"kyo\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n// struct G : public vector<Point>\n// {\n//     G() {}\n//     G(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| is_on_seg(seg1, seg2.first)\n\t\t|| is_on_seg(seg1, seg2.second)\n\t\t|| is_on_seg(seg2, seg1.first)\n\t\t|| is_on_seg(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"cross_point_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"cross_point_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079\ngtype area(const G& p)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\ts += cross(p[i], p[(i + 1) % p.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain{ OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (is_on_seg(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// 円\nenum res_circle_rela\n{\n    a_in_b,\n    b_in_a,\n\n    tangent,\n    intersect,\n    not_intersect,\n};\n// AOJ0023(feps = 0)\nres_circle_rela circle_rela(const Circle& a, const Circle& b)\n{\n    const gtype feps = 0;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    Point ab = b.p - a.p;\n    Point c = a.p + ab * (a.r / (a.r + b.r));\n\n    gtype dis = abs(a.p - c);\n    if (dis > a.r + feps)\n        return vector<Point>();\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - dis*dis));\n\n    Point u = ab * Point(0, 1) / abs(ab);\n    Point v = ab * Point(0, -1) / abs(ab);\n\n    Point p = c + u * h;\n    Point q = c + v * h;\n\n    vector<Point> res;\n    res.push_back(p);\n    if (abs(p - q) > feps)\n        res.push_back(q); // 2点で交わっている\n\n    return res;\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nbool contain_CP(const Circle& c, const Point& p)\n{\n    return abs(c.p - p) < c.r;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\nint main()\n{\n    for (;;)\n    {\n        Line l[3];\n        rep(i, 3)\n            if (!(cin >> l[i].first >> l[i].second))\n                goto END;\n\n        G g;\n        rep(i, 3) rep(j, i)\n            if (intersect_SS(l[i], l[j]))\n                g.pb(ip_SS(l[i], l[j]));\n\n        string res;        \n        if (g.size() == 3)\n        {\n            double s = area(g) + 1e-9;\n            if (s > 1.9 * 1e6)\n                res = \"dai-kichi\";\n            else if (s > 1e6)\n                res = \"chu-kichi\";\n            else if (s > 1e5)\n                res = \"kichi\";\n            else\n                res = \"syo-kichi\";\n        }\n        else\n            res = \"kyo\";\n        cout << res << endl;\n    }\nEND:\n    ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\ndouble cross(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4) {\n\tdouble m;\n\tm=(x4-x3)*(y2-y1)-(x2-x1)*(y4-y3);\n\tif (m==0) return -1;\n\treturn ((x1-x3)*(y4-y3)-(x4-x3)*(y1-y3))/m;\n }\n\nint main() {\n  double a,s,sx[3],sy[3],ex[3],ey[3],cx[3],cy[3],hx,lx,hy,ly;\n  int i,k;\n  while(true) {\n\tlx=ly=9999999; hx=hy=-lx;  \n   for (i=0;i<3;i++) {\n\t      cin >> sx[i] >> sy[i] >> ex[i] >> ey[i];\n\t      if (sx[i]==0 &&  sy[i]==0 && ex[i]==0 && ey[i]==0) return 0; \n\t      }\n\t   for (i=0;i<3;i++) {\n\t\tk=(i+1) % 3;\n\t\ts=cross(sx[i],sy[i],ex[i],ey[i],sx[k],sy[k],ex[k],ey[k]);\n\t\tif (s<0 || s>1) break;\n\t\tcx[i]=sx[i]+s*(ex[i]-sx[i]); cy[i]=sy[i]+s*(ey[i]-sy[i]);\n\t\thx=hx<cx[i] ? cx[i]:hx; lx=lx>cx[i] ? cx[i]:lx;\n\t\thy=hy<cy[i] ? cy[i]:hy; ly=ly>cy[i] ? cy[i]:ly;\n\t}\n\tif (i!=3) { cout << \"kyo\" << endl; continue;}\n\tfor (s=0,i=0;i<3;i++) s+=abs(cx[i]-cx[(i+1) % 3])*abs(cy[i]-cy[(i+1) % 3]);\n\ta=(hx-lx)*(hy-ly)-s/2;\n\tif (a>=1900000) cout << \"dai-kichi\"; else if (a>=1000000) cout << \"chu-kichi\";\n\telse if (a>=100000) cout << \"kichi\"; else if (a>0) cout << \"syo-kichi\";\n\telse cout << \"kyo\";\n\tcout << endl; \n } \n  return 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\npoint intersection_ls(point a1, point a2, point b1, point b2) {\n  point b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(void){\n  segment s[3];\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> s[i].a.x >> s[i].a.y >> s[i].b.x >> s[i].b.y;\n      if( s[i].a.x==0 && s[i].a.y==0 && s[i].b.x==0 && s[i].b.y==0)return 0;\n      }\n    \n    int fg[3]={0};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n\tif(i!=j)\n\t  fg[i]+=is_intersected_ls(s[i].a,s[i].b,s[j].a,s[j].b);\n      }\n    }\n\n    if(fg[0]==2 && fg[1]==2 && fg[2]==2){\n      point p[3];\n      for(int i=0;i<2;i++)\n\t    p[i]=intersection_ls(s[i].a,s[i].b,s[i+1].a,s[i+1].b);\n      p[2]=intersection_ls(s[2].a,s[2].b,s[0].a,s[0].b);\n\n      double z=(dist(p[0],p[1])+dist(p[1],p[2])+dist(p[2],p[0]))/2;\n      double res=sqrt(z*(z-dist(p[0],p[1]))*(z-dist(p[1],p[2]))*(z-dist(p[2],p[0])));\n\n      if(res>=1900000)cout <<\"dai-kichi\"<<endl;\n      else if(res>=1000000 && res<1900000)cout <<\"chu-kichi\"<<endl;\n      else if(res>=100000&& res<1000000)cout <<\"kichi\"<<endl;\n      else cout << \"syo-kichi\"<<endl;\n    }\n    else cout <<\"kyo\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define EPS (1e-9)\n\nusing namespace std;\n\nbool eq(double a, double b)\n{\n\treturn (fabs(b - a) <= EPS);\n}\n\nbool getP(int x1, int y1, int x2, int y2, int p1, int q1, int p2, int q2, double *r1, double *r2)\n{\n\tint D = (x2 - x1) * (q2 - q1) - (y2 - y1) * (p2 - p1);\n\tif (D == 0) return (false);\n\t\n\tdouble r, s;\n\t\n\tr = ((q2 - q1) * (p1 - x1) - (p2 - p1) * (q1 - y1)) / (double)D;\n\ts = ((y2 - y1) * (p1 - x1) - (y2 - y1) * (q1 - y1)) / (double)D;\n\t//printf(\"%lf %lf\\n\", r, s);\n\tif (0 <= r + EPS && r - EPS <= 1 &&\n\t\t0 <= s + EPS && s - EPS <= 1){\n\t\t*r1 = x1 + r * (x2 - x1);\n\t\t*r2 = y1 + r * (y2 - y1);\n\t\treturn (true);\n\t}\n\t\n\treturn (false);\n}\n\nint main()\n{\n\tint x1[3], y1[3], x2[3], y2[3];\n\tdouble x3[3], y3[3];\n\t\n\twhile (1){\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tscanf(\"%d %d %d %d\", x1 + i, y1 + i, x2 + i, y2 + i);\n\t\t\tif (x1[i] == 0 && x2[i] == 0 && y1[i] == 0 && y2[i] == 0) return (0);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\t\tif (!getP(x1[i], y1[i], x2[i], y2[i],\n\t\t\t\t\t\t  x1[j], y1[j], x2[j], y2[j],\n\t\t\t\t\t\t  &x3[i], &y3[i])){\n\t\t\t\t\t\t  printf(\"kyo\\n\");\n\t\t\t\t\t\t  goto ng;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 3; i++) for (int j = i + 1; j < 3; j++) if (eq(x3[i], x3[j]) && eq(y3[i], y3[j])){\n\t\t\tprintf(\"kyo\\n\"); goto ng;\n\t\t}\n\t\tx3[0] -= x3[2]; x3[1] -= x3[2];\n\t\ty3[0] -= y3[2]; y3[1] -= y3[2];\n\t\t\n\t\tdouble S;\n\t\t\n\t\tS = 0.5 * fabs(x3[0] * y3[1] - y3[0] * x3[1]);\n\t\t\n\t\tif (S >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (S >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (S >= 100000) printf(\"kichi\\n\");\n\t\telse printf(\"syo-kichi\\n\");\n\t\t\n\t\tng:;\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1.0e-12;\n\nstruct Point {\n  public:\n    double x, y;\n    Point() {};\n    Point(double _x, double _y) : x(_x), y(_y) {};\n    Point operator+(const Point &rhs) const {\n      return Point(this->x + rhs.x, this->y + rhs.y);\n    }\n    Point operator-(const Point &rhs) const {\n      return Point(this->x - rhs.x, this->y - rhs.y);\n    }\n    Point operator*(double rhs) const {\n      return Point(this->x * rhs, this->y * rhs); \n    }\n};\n\nPoint intersect(Point &a0, Point &a1, Point &b0, Point &b1, int &err) {\n  Point p;\n  double s, t;\n  Point a01 = a1 - a0;\n  Point b10 = b0 - b1;\n  Point c = b0 - a0;\n  double det = a01.x * b10.y - a01.y * b10.x;\n  \n  err = 0;\n  if (abs(det) < EPS) { // two lines are parallel\n    err = 1;\n  } else {\n    s = (b10.y * c.x - b10.x * c.y) / det;\n    t = (a01.x * c.y - a01.y * c.x) / det;\n    if (s < -EPS || s > 1.0 + EPS || t < -EPS || t > 1.0 + EPS) {\n      err = 2;\n    }\n    p = a0 + a01 * s;\n  }\n  return p;\n}\n\ndouble triangleArea(Point &a, Point &b, Point &c) {\n  Point ab = b - a;\n  Point ac = c - a;\n  return abs(ab.x * ac.y - ab.y * ac.x) * 0.5;\n}\n\nint main() {\n  int err;\n  double area;\n  Point p[6];\n  Point a, b, c;\n  while (1) {\n    cin >> p[0].x >> p[0].y;\n    cin >> p[1].x >> p[1].y;\n    if (!p[0].x && !p[0].y && !p[1].x && !p[1].y) {\n      break;\n    }\n    for (int i=2; i<6; i++) {\n      cin >> p[i].x >> p[i].y;\n    }\n    a = intersect(p[0], p[1], p[2], p[3], err);\n    if (!err) b = intersect(p[2], p[3], p[4], p[5], err);\n    if (!err) c = intersect(p[4], p[5], p[0], p[1], err);\n    if (err) {\n      cout << \"kyo\" << endl;\n    } else {\n      area = triangleArea(a, b, c);\n      if (area < EPS) {\n        cout << \"kyo\" << endl;\n      } else if (area < 100000) {\n        cout << \"syo-kichi\" << endl;\n      } else if (area < 1000000) {\n        cout << \"kichi\" << endl;\n      } else if (area < 1900000) {\n        cout << \"chu-kichi\" << endl;\n      } else {\n        cout << \"dai-kichi\" << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nbool isequal(const P& a, const P& b)\n{\n\treturn a.real()+EPS > b.real() && a.real() < b.real()+EPS &&\n\t\t   a.imag()+EPS > b.imag() && a.imag() < b.imag()+EPS;\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS; // non-parallel\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main()\n{\n\tint x1,y1,x2,y2;\n\twhile(scanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2), (x1||y1||x2||y2))\n\t{\n\t\tvector<L> Lines;\n\t\tvector<P> xp;\n\t\tLines.push_back(L(P(x1,y1),P(x2,y2)));\n\t\tfor(int i=0; i<2; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2);\n\t\t\tLines.push_back(L(P(x1,y1),P(x2,y2)));\n\t\t}\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\tfor(int j=i+1; j<3; j++)\n\t\t{\n\t\t\tif(!intersectLL(Lines[i], Lines[j])) g=false;\n\t\t\tif(!intersectSS(Lines[i], Lines[j])) g=false;\n\t\t\t\n\t\t\tif(g)\n\t\t\t{\n\t\t\t\txp.push_back(crosspoint(Lines[i], Lines[j]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<xp.size(); i++)\n\t\tfor(int j=i+1; j<xp.size(); j++)\n\t\t{\n\t\t\tif(isequal(xp[i], xp[j])) g=false;\n\t\t}\n\t\t\n\t\tif(!g)\n\t\t{\n\t\t\tputs(\"kyo\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt=0;\n\t\tdouble ls[3];\n\t\tfor(int i=0; i<xp.size(); i++)\n\t\tfor(int j=i+1; j<xp.size(); j++)\n\t\t{\n\t\t\tls[cnt]=sqrt((xp[i].real()-xp[j].real())*(xp[i].real()-xp[j].real())+(xp[i].imag()-xp[j].imag())*(xp[i].imag()-xp[j].imag()));\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tdouble area=0.5*abs(((xp[1].real()-xp[0].real())*(xp[2].imag()-xp[0].imag())-(xp[2].real()-xp[1].real())*(xp[1].imag()-xp[0].imag())));\n\t\tif(area < 100000) puts(\"syo-kichi\");\n\t\telse if(area < 1000000) puts(\"kichi\");\n\t\telse if(area < 1900000) puts(\"chu-kichi\");\n\t\telse\tputs(\"dai-kichi\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int i,j,x1[3],y1[3],x2[3],y2[3],ty[3]/*x=c >> 1, y=c >> 2*/;\n  double a[3],b[3],x3[3],y3[3],sen[3],s,ans;\n  while(1){\n    cin >> x1[0] >> y1[0] >> x2[0] >> y2[0];\n    if(x1[0] == 0 && x2[0] == 0 && y1[0] == 0 && y2[0] == 0) break;\n    for(i=1;i<3;i++) cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];\n\n    for(i=0;i<3;i++){// y = a * x + b\n      a[i] = b[i] = 0.0;\n      if(x1[i] == x2[i]) ty[i] = 1;\n      else if(y1[i] == y2[i]){\n\tty[i] = 2;\n\ta[i] = 0.0;\n\tb[i] = (double)y1[i];\n      }\n      else{\n\ta[i] =(double)  (y1[i] - y2[i]) / (x1[i] - x2[i]);\n\tb[i] = (double) y1[i] - a[i] * x1[i];\n\tty[i] = 0;\n      }\n    }\n\n    ans = 0.0;\n    for(i=0;i<3;i++){ //ÃÂ¿ÃÂ¹ÃÂ¤ÃÂ¾ÃÂ¬ÃÂ¹ÃÂ§\n      if(ty[i] == 1 && ty[(i+1)%3] == 1){\n\tans = -1.0;\n\tbreak;\n      }\n      else if(ty[i] != 1 && ty[(i+1)%3] != 1 && a[i] == a[(i+1)%3]){\n\tans = -1.0;\n\tbreak;\n      }\n    }\n\n    if(ans == 0.0){\n      for(i=0;i<3;i++){\n\tif(ty[i] == 1){\n\t  x3[i] = (double)x1[i];\n\t  y3[i] = a[(i+1)%3] * x3[i] + b[(i+1)%3];\n\t}\n\telse{\n\t  x3[i] = (b[(i+1)%3] - b[i]) / (a[i] - a[(i+1)%3]);\n\t  if(b[(i+1)%3] == b[i]) x3[i] = 0.0;\n\t  y3[i] = a[i] * x3[i] + b[i];\n\t}\n\n\tif(x1[i] <= x2[i] &&(x1[i] > x3[i] || x3[i] > x2[i]) || x2[i] < x1[i] &&(x2[i] > x3[i] || x3[i] > x1[i]) || y1[i] <= y2[i] &&(y1[i] > y3[i] || y3[i] > y2[i]) || y2[i] < y1[i] &&(y2[i] > y3[i] || y3[i] > y1[i])){\n\t  ans = -1.0;\n\t  break; //ÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂÃÂÃÂ¤ÃÂ«ÃÂ¤ÃÂºÃÂÃÂ¤ÃÂ·ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤ÃÂ¤\n\t}\n      }\n\n      s = 0.0;\n      for(i=0;i<3;i++){\n\tsen[i] = sqrt( pow(x3[i] - x3[(i+1)%3],2) + pow(y3[i] - y3[(i+1)%3],2));\n\ts += sen[i];\n      }\n      \n      s /= 2;\n      if(ans == 0.0) ans = sqrt(s * (s - sen[0]) * (s - sen[1]) * (s - sen[2]));\n      \n      int c = 0;\n      for(i=0;i<3;i++){ //ÃÂ£ÃÂ³ÃÂ¤ÃÂ¤ÃÂÃÂÃÂ¾ÃÂ¬ÃÂ¤ÃÂ¬ÃÂ£ÃÂ±ÃÂÃÂÃÂ¤ÃÂ¸ÃÂ²ÃÂ¤ÃÂ¯ÃÂ¤ÃÂ«\n\tif(x3[i] == x3[(i+1)%3] && y3[i] == y3[(i+1)%3]) c++;\n      }\n      if(c == 3) ans = -1.0;\n    }\n\n    if(ans >= 1900000.0) cout << \"dai-kichi\" << endl;\n    else if(ans >= 1000000.0) cout << \"chu-kichi\" << endl;\n    else if(ans >= 100000.0) cout << \"kichi\" << endl;\n    else if(ans > 0.0) cout << \"syo-kichi\" << endl;\n    else cout << \"kyo\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\n\n\nclass Point\n{\npublic:\n  double x,y;\n\n  Point(double x =0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y); }\n  Point operator - (Point p){return Point(x-p.x,y-p.y); }\n  Point operator * (Point p){return Point(x*p.x,y*p.y); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }  \n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nPoint getCrossPoint(Point a1,Point a2,Point b1,Point b2)\n{\n  if(!isIntersect(a1,a2,b1,b2))\n    {\n      return Point(-9993999,-9993999);\n    }\n  Point base = b2 - b1;\n  double d1 = abs(cross(base,a1-b1));\n  double d2 = abs(cross(base,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2 - a1)*t;\n}\n\ndouble getArea(Point p1,Point p2,Point p3)\n{\n  double a,b,c;\n  a = sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));\n  b = sqrt(pow(p2.x-p3.x,2)+pow(p2.y-p3.y,2));\n  c = sqrt(pow(p1.x-p3.x,2)+pow(p1.y-p3.y,2));\n  double s = (a+b+c)/2.0;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nint main()\n{\n  int x1,y1,x2,y2;\n  while(cin >> x1 >> y1 >> x2 >> y2,(x1|y1|x2|y2))\n    {\n      Point a(x1,y1);\n      Point b(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point c(x1,y1);\n      Point d(x2,y2);\n      cin >> x1 >> y1 >> x2 >> y2;\n      Point e(x1,y1);\n      Point f(x2,y2);\n      Point c1,c2,c3;\n      c1 = getCrossPoint(a,b,c,d);\n      c2 = getCrossPoint(c,d,e,f);\n      c3 = getCrossPoint(e,f,a,b);\n\n\n      if((c1 == c2 && c2 == c3) || !isIntersect(a,b,c,d) || !isIntersect(c,d,e,f) || !isIntersect(e,f,a,b))\n\t{\n\t  cout << \"kyo\" << endl;\n\t  continue;\n\t}\n     \n      double area = getArea(c1,c2,c3);\n\n      if(0 < area && area < 100000)\n\tcout << \"syo-kichi\" << endl;\n      else if(100000 <= area && area < 1000000)\n\tcout << \"kichi\" << endl;\n      else if(1000000 <= area && area < 1900000)\n\tcout << \"chu-kichi\" << endl;\n      else if(1900000 <= area)\n\tcout << \"dai-kichi\" << endl; \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    c -= a;\n    b -= a;\n    if(cross(b, c) > EPS) return 1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nbool isIntersect(L s1, L s2){\n    return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n             ccw(s2.first,s2.second,s2.first) * ccw(s2.first,s2.second,s1.second) <= 0);\n}\n\nP crossPoint(L l, L m){\n    double A = cross(l.second - l.first, m.second - m.first);\n    double B = cross(l.second - l.first, l.second - m.first);\n    if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n    else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n    double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum / 2.0);\n}\n\nstring ans(vector<P> v){\n    double a = area(v);\n    //if(a < EPS) return \"kyo\";\n    if(a < 100000.0) return \"syo-kichi\";\n    if(a < 1000000.0) return \"kichi\";\n    if(a < 1900000.0) return \"chi-kichi\";\n    return \"dai-kichi\";\n}\n\nint main(){\n    double x1,y1,x2,y2;\n    while(cin >> x1 >> y1 >> x2 >> y2 && (x1||y1||x2||y2)){\n        L v[3];\n        vector<P> p(3);\n        bool f = false;\n        v[0] = L(P(x1,y1),P(x2,y2));\n        for(int i=1;i<3;i++) {\n            cin >> x1 >> y1 >> x2 >> y2;\n            v[i] = L(P(x1,y1),P(x2,y2));\n            if(!isIntersect(v[0],v[i])) f = true;\n            else p[i-1] = crossPoint(v[0],v[i]);\n        }\n        if(!isIntersect(v[1],v[2])) f = true;\n        else p[2] = crossPoint(v[1],v[2]);\n\n        for(int i=0;i<3;i++){\n            for(int j=i+1;j<3;j++){\n                if(abs(p[i]-p[j]) < EPS) f = true;\n            }\n        }\n\n        if(f) cout << \"kyo\" << endl;\n        else cout << ans(p) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-12;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble getArea(P a, P b , P c){\n\t\tb-=a, c-=a;\n\t\treturn fabs( b.real() * c.imag() - c.real() * b.imag() ) / 2.0; \n}\nint main(){\n\tdouble a,b,c,d;\n\twhile(cin >> a >> b >> c >> d , a || b || c || d){\n\t\tL one = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL two = L(P(a,b),P(c,d));\n\t\tcin >> a >> b >> c >> d;\n\t\tL three = L(P(a,b),P(c,d));\n\t\tdouble ret = 0;\n\t\t\n\t\tif(intersectSS(one,two) && intersectSS(two,three) && intersectSS(one,three)){\n\t\t\tret = getArea( crosspoint(one,two) , crosspoint(two,three) , crosspoint(one,three) );\n\t\t\tcout << ret << endl;\n\t\t}\n\t\tif(ret >= 1900000){\n\t\t\tcout << \"dai-kichi\" << endl;\n\t\t}else if(ret >= 1000000){\n\t\t\tcout << \"chu-kichi\" << endl;\n\t\t}else if(ret >= 100000){\n\t\t\tcout << \"kichi\" << endl;\n\t\t}else if(ret > 0){\n\t\t\tcout << \"syo-kichi\" << endl;\n\t\t}else{\n\t\t\tcout << \"kyo\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\n\nmain :: IO ()\nmain = do\n  xs <- f\n  unless (all (==0) xs) $ do\n    solve (g xs) <$> (g <$> f) <*> (g <$> f) >>= putStrLn\n    main\n  where\n    f = map read <$> words <$> getLine :: IO [Int]\n    g [x1, y1, x2, y2] = let v1 = Vect (fromIntegral x1) (fromIntegral y1)\n                             v2 = Vect (fromIntegral x2) (fromIntegral y2)\n                         in Segment v1 v2\n\nsolve :: Segment Double -> Segment Double -> Segment Double -> String\nsolve s1 s2 s3\n  | not (is1 && is2 && is3) = \"kyo\"\n  | eps > 1900000 - a = \"dai-kichi\"\n  | eps > 1000000 - a = \"chu-kichi\"\n  | eps > 100000 - a = \"kichi\"\n  | eps < a = \"syo-kichi\"\n  | otherwise = \"kyo\"\n  where\n    is1 = intersectSS s1 s2\n    is2 = intersectSS s2 s3\n    is3 = intersectSS s3 s1\n    v1 = crossPoint s1 s2\n    v2 = crossPoint s2 s3\n    v3 = crossPoint s3 s1\n    a = area v1 v2 v3\n\ndata Vect a = Vect {vecX :: a, vecY :: a} deriving Show\ndata Segment a = Segment {segB :: Vect a, segE :: Vect a} deriving Show\ndata PosRel = CCW | CW | OB | OF | OS deriving (Show, Read, Eq)\n\neps :: Floating a => a\neps = 1e-9\n\nnorm :: Num a => Vect a -> a\nnorm (Vect x y) = x ^ 2 + y ^ 2\n\ndot :: Num a => Vect a -> Vect a -> a\ndot (Vect x1 y1) (Vect x2 y2) = x1 * x2 + y1 * y2\n\ncross :: Num a => Vect a -> Vect a -> a\ncross (Vect x1 y1) (Vect x2 y2) = x1 * y2 - y1 * x2\n\n(.+.) :: Num a => Vect a -> Vect a -> Vect a\n(Vect x1 y1) .+. (Vect x2 y2) = Vect (x1 + x2) (y1 + y2)\n\n(.-.) :: Num a => Vect a -> Vect a -> Vect a\n(Vect x1 y1) .-. (Vect x2 y2) = Vect (x1 - x2) (y1 - y2)\n\n(.*.) :: Num a => Vect a -> a -> Vect a\n(Vect x y) .*. k = Vect (x * k) (y * k)\n\nccw :: (Ord a, Floating a) => Vect a -> Vect a -> Vect a -> PosRel\nccw v1 v2 v3\n  | c > eps = CCW\n  | c < negate eps = CW\n  | dot v12 v13 < negate eps = OB\n  | norm v12 < norm v13 = OF\n  | otherwise = OS\n  where\n    v12 = v2 .-. v1\n    v13 = v3 .-. v1\n    c = cross v12 v13\n\nintersectSS :: (Ord a, Floating a) => Segment a -> Segment a -> Bool\nintersectSS s1 s2 = f s1 s2 && f s2 s1\n  where\n    f x y = case (ccw (segB x) (segE x) (segB y), ccw (segB x) (segE x) (segE y)) of\n             (CCW, CW) -> True\n             (CW, CCW) -> True\n             (OS, CCW) -> True\n             (OS, CW) -> True\n             (CCW, OS) -> True\n             (CW, OS) -> True\n             _ -> False\n\ncrossPoint :: (Ord a, Floating a) => Segment a -> Segment a -> Vect a\ncrossPoint s1 s2 = segB s1 .+. ((segE s1 .-. segB s1) .*. t)\n  where\n    bv = segE s2 .-. segB s2\n    d1 = abs $ cross bv $ segB s1 .-. segB s2\n    d2 = abs $ cross bv $ segE s1 .-. segB s2\n    t = d1 / (d1 + d2)\n\narea :: (Floating a) => Vect a -> Vect a -> Vect a -> a\narea v1 v2 v3 = 0.5 * abs (cross v12 v13)\n  where\n    v12 = v2 .-. v1\n    v13 = v3 .-. v1\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble gaiseki(double,double,double,double);\n\nmain(){\n  double x[6], y[6], tenx[3], teny[3], len[3], s, m1, m2, ans, bx[5], by[5], temp1, temp2;\n  int i, j, p=0, f, a;\n\n  while(1){\n    for(i=0;i<6;i+=2){\n      scanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &x[i+1], &y[i+1]);\n      if(x[0]==0 && y[0]==0 && x[1]==0 && y[1]==0){\n\tp=1;\n\tbreak;\n      }\n    }\n    if(p==1) break;\n    f=0;\n    \n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[0];\n    by[1]=y[2]-y[0];\n    bx[2]=x[2]-x[1];\n    by[2]=y[2]-y[1];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[2];\n    by[1]=y[0]-y[2];\n    bx[2]=x[0]-x[3];\n    by[2]=y[0]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[2];\n    by[1]=y[4]-y[2];\n    bx[2]=x[4]-x[3];\n    by[2]=y[4]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[5];\n    by[1]=y[2]-y[5];\n    bx[2]=x[2]-x[4];\n    by[2]=y[2]-y[4];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[4];\n    by[1]=y[0]-y[4];\n    bx[2]=x[0]-x[5];\n    by[2]=y[0]-y[5];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[1];\n    by[1]=y[4]-y[1];\n    bx[2]=x[4]-x[0];\n    by[2]=y[4]-y[0];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n\n\n    m1=(y[1]-y[0])/(x[1]-x[0]);\n    m2=(y[3]-y[2])/(x[3]-x[2]);\n    \n    tenx[0]=(m1*x[0]-m2*x[2]+y[2]-y[0])/(m1-m2);\n    teny[0]=m1*(tenx[0]-x[0])+y[0];\n\n    m1=(y[3]-y[2])/(x[3]-x[2]);\n    m2=(y[5]-y[4])/(x[5]-x[4]);\n\n    tenx[1]=(m1*x[2]-m2*x[4]+y[4]-y[2])/(m1-m2);\n    teny[1]=m1*(tenx[1]-x[2])+y[2];\n\n    m1=(y[5]-y[4])/(x[5]-x[4]);\n    m2=(y[1]-y[0])/(x[1]-x[0]);\n\n    tenx[2]=(m1*x[4]-m2*x[0]+y[0]-y[4])/(m1-m2);\n    teny[2]=m1*(tenx[2]-x[4])+y[4];\n    \n\n    if((tenx[0]==tenx[1] && teny[0]==teny[1]) || tenx[1]==tenx[2] && (teny[1]==teny[2]) || (tenx[2]==tenx[0] && teny[2]==teny[0])){\n      printf(\"kyo\\n\");\n      continue;\n    }\n   \n    for(i=0,j=1;i<3;i++,j++){\n      if(j==3) j=0;\n      len[i]=sqrt((tenx[i]-tenx[j])*(tenx[i]-tenx[j])+(teny[i]-teny[j])*(teny[i]-teny[j]));\n    }\n    \n\n    s=(len[0]+len[1]+len[2])/2;\n    ans=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n    \n    a=ans+0.0000001;\n    if(ans>=1900000) printf(\"dai-kichi\\n\");\n    else if(ans>=1000000) printf(\"chu-kichi\\n\");\n    else if(ans>=100000) printf(\"kichi\\n\");\n    else if(ans>0) printf(\"syo-kichi\\n\");\n  }\n  return 0;\n}\n\n\n\ndouble gaiseki(double a, double b, double c, double d){\n  return (a*d-b*c);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble gaiseki(double,double,double,double);\n\nmain(){\n  double x[6], y[6], tenx[3], teny[3], len[3], s, m1, m2, ans, bx[5], by[5], temp1, temp2;\n  int i, j, p=0, f, a;\n\n  while(1){\n    for(i=0;i<6;i+=2){\n      scanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &x[i+1], &y[i+1]);\n      if(x[0]==0 && y[0]==0 && x[1]==0 && y[1]==0){\n\tp=1;\n\tbreak;\n      }\n    }\n    if(p==1) break;\n    f=0;\n    \n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[0];\n    by[1]=y[2]-y[0];\n    bx[2]=x[2]-x[1];\n    by[2]=y[2]-y[1];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[2];\n    by[1]=y[0]-y[2];\n    bx[2]=x[0]-x[3];\n    by[2]=y[0]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[2];\n    by[1]=y[4]-y[2];\n    bx[2]=x[4]-x[3];\n    by[2]=y[4]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[5];\n    by[1]=y[2]-y[5];\n    bx[2]=x[2]-x[4];\n    by[2]=y[2]-y[4];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[4];\n    by[1]=y[0]-y[4];\n    bx[2]=x[0]-x[5];\n    by[2]=y[0]-y[5];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[1];\n    by[1]=y[4]-y[1];\n    bx[2]=x[4]-x[0];\n    by[2]=y[4]-y[0];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n\n\n    m1=(y[1]-y[0])/(x[1]-x[0]);\n    m2=(y[3]-y[2])/(x[3]-x[2]);\n    \n    tenx[0]=(m1*x[0]-m2*x[2]+y[2]-y[0])/(m1-m2);\n    teny[0]=m1*(tenx[0]-x[0])+y[0];\n\n    m1=(y[3]-y[2])/(x[3]-x[2]);\n    m2=(y[5]-y[4])/(x[5]-x[4]);\n\n    tenx[1]=(m1*x[2]-m2*x[4]+y[4]-y[2])/(m1-m2);\n    teny[1]=m1*(tenx[1]-x[2])+y[2];\n\n    m1=(y[5]-y[4])/(x[5]-x[4]);\n    m2=(y[1]-y[0])/(x[1]-x[0]);\n\n    tenx[2]=(m1*x[4]-m2*x[0]+y[0]-y[4])/(m1-m2);\n    teny[2]=m1*(tenx[2]-x[4])+y[4];\n    \n\n    if((tenx[0]==tenx[1] && teny[0]==teny[1]) || tenx[1]==tenx[2] && (teny[1]==teny[2]) || (tenx[2]==tenx[0] && teny[2]==teny[0])){\n      printf(\"kyo\\n\");\n      continue;\n    }\n   \n    for(i=0,j=1;i<3;i++,j++){\n      if(j==3) j=0;\n      len[i]=sqrt((tenx[i]-tenx[j])*(tenx[i]-tenx[j])+(teny[i]-teny[j])*(teny[i]-teny[j]));\n    }\n    \n\n    s=(len[0]+len[1]+len[2])/2;\n    ans=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n    \n    a=ans+0.0000001;\n    if(ans>=1900000) printf(\"dai-kichi\\n\");\n    else if(ans>=1000000) printf(\"chu-kichi\\n\");\n    else if(ans>=100000) printf(\"kichi\\n\");\n    else if(ans>0) printf(\"syo-kichi\\n\");\n  }\n  return 0;\n}\n\n\n\ndouble gaiseki(double a, double b, double c, double d){\n  return (a*d-b*c);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble gaiseki(double,double,double,double);\n\nmain(){\n  double x[6], y[6], tenx[3], teny[3], len[3], s, m1, m2, ans, bx[5], by[5], temp1, temp2;\n  int i, j, p=0, f, a;\n\n  while(1){\n    for(i=0;i<6;i+=2){\n      scanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &x[i+1], &y[i+1]);\n      if(x[0]==0 && y[0]==0 && x[1]==0 && y[1]==0){\n\tp=1;\n\tbreak;\n      }\n    }\n    if(p==1) break;\n    f=0;\n    \n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[0];\n    by[1]=y[2]-y[0];\n    bx[2]=x[2]-x[1];\n    by[2]=y[2]-y[1];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[2];\n    by[1]=y[0]-y[2];\n    bx[2]=x[0]-x[3];\n    by[2]=y[0]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[2];\n    by[1]=y[4]-y[2];\n    bx[2]=x[4]-x[3];\n    by[2]=y[4]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[5];\n    by[1]=y[2]-y[5];\n    bx[2]=x[2]-x[4];\n    by[2]=y[2]-y[4];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[4];\n    by[1]=y[0]-y[4];\n    bx[2]=x[0]-x[5];\n    by[2]=y[0]-y[5];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[1];\n    by[1]=y[4]-y[1];\n    bx[2]=x[4]-x[0];\n    by[2]=y[4]-y[0];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n\n\n    m1=(y[1]-y[0])/(x[1]-x[0]);\n    m2=(y[3]-y[2])/(x[3]-x[2]);\n    \n    tenx[0]=(m1*x[0]-m2*x[2]+y[2]-y[0])/(m1-m2);\n    teny[0]=m1*(tenx[0]-x[0])+y[0];\n\n    m1=(y[3]-y[2])/(x[3]-x[2]);\n    m2=(y[5]-y[4])/(x[5]-x[4]);\n\n    tenx[1]=(m1*x[2]-m2*x[4]+y[4]-y[2])/(m1-m2);\n    teny[1]=m1*(tenx[1]-x[2])+y[2];\n\n    m1=(y[5]-y[4])/(x[5]-x[4]);\n    m2=(y[1]-y[0])/(x[1]-x[0]);\n\n    tenx[2]=(m1*x[4]-m2*x[0]+y[0]-y[4])/(m1-m2);\n    teny[2]=m1*(tenx[2]-x[4])+y[4];\n    \n   \n    for(i=0,j=1;i<3;i++,j++){\n      if(j==3) j=0;\n      len[i]=sqrt((tenx[i]-tenx[j])*(tenx[i]-tenx[j])+(teny[i]-teny[j])*(teny[i]-teny[j]));\n    }\n    \n\n    s=(len[0]+len[1]+len[2])/2;\n    ans=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n    \n    a=ans+0.00000001;\n    if(a>=1900000) printf(\"dai-kichi\\n\");\n    else if(a>=1000000) printf(\"chu-kichi\\n\");\n    else if(a>=100000) printf(\"kichi\\n\");\n    else if(a>0) printf(\"syo-kichi\\n\");\n    else printf(\"kyo\\n\");\n  }\n  return 0;\n}\n\n\n\ndouble gaiseki(double a, double b, double c, double d){\n  return (a*d-b*c);\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nL(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy,double*X,double*Y){\n\tint acx,acy;\n\tdouble bunbo,r,s;\n\tacx=cx-ax;\n\tacy=cy-ay;\n\tbunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tif(bunbo){\n\t\tr=((dy-cy)*acx-(dx-cx)*acy)/bunbo;\n\t\ts=((by-ay)*acx-(bx-ax)*acy)/bunbo;\n\t\tif(r>=0&&r<=1&&s>=0&&s<=1){\n\t\t\t*X=ax+r*(bx-ax);\n\t\t\t*Y=ay+r*(by-ay);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nmain(){\n\tint x1[3],y1[3],x2[3],y2[3];\n\tdouble X[3],Y[3],S;\n\tint i=0;\n\tfor(;~scanf(\"%d%d%d%d\",x1+i,y1+i,x2+i,y2+i);){\n\t\tif(++i==3){\n\t\t\tif(L(x1[0],y1[0],x2[0],y2[0],x1[1],y1[1],x2[1],y2[1],X+0,Y+0)&&\n\t\t\t   L(x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],X+1,Y+1)&&\n\t\t\t   L(x1[2],y1[2],x2[2],y2[2],x1[0],y1[0],x2[0],y2[0],X+2,Y+2))\n\t\t\t{\n\t\t\t\tS=0;\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tS+=(X[i]-X[(i+1)%3])*(Y[i]+Y[(i+1)%3])/2;\n\t\t\t\t}\n\t\t\t\tS=fabs(S);\n\t\t\t\tif(S<100000)\n\t\t\t\t\tputs(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tputs(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tputs(\"chu-kichi\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"dai-kichi\");\n\t\t\t}else{\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,xa,ya,xb,yb;\ndouble sp[3][2],vec[3][2],pot[3][2],area;\n\nint crosspoint(int i,int j){\n\t\n\tdouble px=sp[i][0],py=sp[i][1];\n\tdouble ax=vec[i][0],ay=vec[i][1];\n\tdouble qx=sp[j][0],qy=sp[j][1];\n\tdouble bx=vec[j][0],by=vec[j][1];\n\n\tif( ( ax*bx+ay*by!=0 ) && ( ax*by==ay*bx ))return 0;\n\n\tdouble a=ax,b=-bx,c=qx-px;\n\tdouble d=ay,e=-by,f=qy-py;\n\tdouble t,x,y;\n\n\tif(a!=0){\n\t\tt=d/a;\n\t\te-=b*t;\n\t\tf-=c*t;\n\t\ty=f/e;\n\t\tx=(c-b*y)/a;\n\t}\n\telse{\n\t\ty=c/b;\n\t\tx=(f-e*y)/d;\n\t}\n\n\tif(x<0 || x>1 || y<0 || y>1)return 0;\n\n\tpot[i][0]=px+ax*x;\n\tpot[i][1]=py+ay*x;\n\n\treturn 1;\n\n}\n\nint main(){\n\twhile(1){\n\t\tfor(i=0;i<3;i++){\n\t\t\tif(scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb)==EOF)goto exit;\n\t\t\tvec[i][0]=xb-xa;vec[i][1]=yb-ya;\n\t\t\tsp[i][0]=xa;sp[i][1]=ya;\n\t\t}\n\t\tfor(i=0;i<3;i++){\n\t\t\tif(crosspoint(i,(i+1)%3)==0)goto bad;\n\t\t}\n\n\t\tdouble vx=pot[1][0]-pot[0][0];\n\t\tdouble vy=pot[1][1]-pot[1][0];\n\t\tdouble wx=pot[2][0]-pot[0][0];\n\t\tdouble wy=pot[2][1]-pot[1][0];\n\n\t\tarea=fabs((vx*wy-vy*wx)/2);\n\n\t\tif(area>=1900000){printf(\"dai-kichi\\n\");continue;}\n\t\tif(area>=1000000){printf(\"chu-kichi\\n\");continue;}\n\t\tif(area>=100000){printf(\"kichi\\n\");continue;}\n\t\tif(area>0){printf(\"syo-kichi\\n\");continue;}\n\t\tbad: printf(\"kyo\\n\");\n\t}\n\texit: return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble gaiseki(double,double,double,double);\n\nmain(){\n  double x[6], y[6], tenx[3], teny[3], len[3], s, m1, m2, ans, bx[5], by[5], temp1, temp2;\n    int i, j, p=0, f;\n\n  while(1){\n    for(i=0;i<6;i+=2){\n      scanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &x[i+1], &y[i+1]);\n      if(x[0]==0 && y[0]==0 && x[1]==0 && y[1]==0){\n\tp=1;\n\tbreak;\n      }\n    }\n    if(p==1) break;\n    f=0;\n    \n    for(j=0;j<3;j++){\n      bx[j]=x[j+1]-x[0];\n    }\n    bx[3]=x[3]-x[1];\n    by[3]=y[3]-y[1];\n    bx[4]=x[2]-x[3];\n    by[4]=y[2]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    temp1=gaiseki(bx[4],by[4],bx[2],by[2]);\n    temp2=gaiseki(bx[4],by[4],bx[3],by[3]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[2];\n    by[1]=y[4]-y[2];\n    bx[2]=x[4]-x[3];\n    by[2]=y[4]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[5];\n    by[1]=y[2]-y[5];\n    bx[2]=x[2]-x[4];\n    by[2]=y[2]-y[4];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[4];\n    by[1]=y[0]-y[4];\n    bx[2]=x[0]-x[5];\n    by[2]=y[0]-y[5];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[1];\n    by[1]=y[4]-y[1];\n    bx[2]=x[4]-x[0];\n    by[2]=y[4]-y[0];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n\n\n    m1=(y[1]-y[0])/(x[1]-x[0]);\n    m2=(y[3]-y[2])/(x[3]-x[2]);\n    \n    tenx[0]=(m1*x[0]-m2*x[2]+y[2]-y[0])/(m1-m2);\n    teny[0]=m1*(tenx[0]-x[0])+y[0];\n\n    m1=(y[3]-y[2])/(x[3]-x[2]);\n    m2=(y[5]-y[4])/(x[5]-x[4]);\n\n    tenx[1]=(m1*x[2]-m2*x[4]+y[4]-y[2])/(m1-m2);\n    teny[1]=m1*(tenx[1]-x[2])+y[2];\n\n    m1=(y[5]-y[4])/(x[5]-x[4]);\n    m2=(y[1]-y[0])/(x[1]-x[0]);\n\n    tenx[2]=(m1*x[4]-m2*x[0]+y[0]-y[4])/(m1-m2);\n    teny[2]=m1*(tenx[2]-x[4])+y[4];\n    \n\n    if((tenx[0]==tenx[1] && teny[0]==teny[1]) || tenx[1]==tenx[2] && (teny[1]==teny[2]) || (tenx[2]==tenx[0] && teny[2]==teny[0])){\n      printf(\"kyo\\n\");\n      continue;\n    }\n   \n    for(i=0,j=1;i<3;i++,j++){\n      if(j==3) j=0;\n      len[i]=sqrt((tenx[i]-tenx[j])*(tenx[i]-tenx[j])+(teny[i]-teny[j])*(teny[i]-teny[j]));\n    }\n    \n\n    s=(len[0]+len[1]+len[2])/2;\n    ans=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n    \n    if(ans>=1900000) printf(\"dai-kichi\\n\");\n    else if(ans>=1000000) printf(\"chu-kichi\\n\");\n    else if(ans>=100000) printf(\"kichi\\n\");\n    else if(ans>0) printf(\"syo-kichi\\n\");\n\n  }\n  return 0;\n}\n\n\n\ndouble gaiseki(double a, double b, double c, double d){\n  return (a*d-b*c);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0187: Stoning Fortune\n// 2017.8.10\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-6\n\ntypedef struct { long long x, y; } PP;\ntypedef struct { double x, y; } fPP;\n\nchar *kichi[] = { \"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\" };\nint std[] = { 1900000, 1000000, 100000, 0, -1 };\n\nPP pp[6];\nfPP fp[3];\n\ndouble dis(fPP *p1, fPP *p2);\nint intersection(fPP *p, PP *p1, PP *p2, PP *p3, PP *p4);\n\nint main()\n{\n\tint i, ans;\n\tdouble a, b, c, s, t;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 6; i += 2) {\n\t\t\tscanf(\"%lld%lld%lld%lld\", &(pp[i].x), &(pp[i].y), &(pp[i + 1].x), &(pp[i + 1].y));\n\t\t\tif (!i && !pp[0].x && !pp[0].y && !pp[1].x && !pp[1].y) return 0;\n\t\t}\n\t\tans = 4;\n\t\tif (!intersection(fp, pp, pp + 1, pp + 2, pp + 3)) goto NG;\n\t\tif (!intersection(fp + 1, pp + 2, pp + 3, pp + 4, pp + 5)) goto NG;\n\t\tif (!intersection(fp + 2, pp + 4, pp + 5, pp, pp + 1)) goto NG;\n\n\t\ta = dis(fp, fp + 1), b = dis(fp + 1, fp + 2), c = dis(fp + 2, fp);\n\t\ts = (a + b + c) / 2.0;\n\t\tt = sqrt(s*(s - a)*(s - b)*(s - c));\n\n\t\tif (fabs(t) > EPS) {\n\t\t\tfor (i = 0; ans == 4 && i < 4; i++) {\n\t\t\t\tif (fabs(t - std[i]) <= EPS || t >= std[i]) ans = i;\n\t\t\t}\n\t\t}\n\tNG:\t\tputs(kichi[ans]);\n\t}\n\treturn 0;\n}\n\ndouble dis(fPP *p1, fPP *p2)\n{\n\tdouble x = p1->x - p2->x, y = p1->y - p2->y;\n\treturn sqrt(x*x + y*y);\n}\n\nint isPointOnSegment(PP *p, PP *p1, PP *p2)\n{\n\tlong long x1 = p1->x, y1 = p1->y, x2 = p2->x, y2 = p2->y;\n\tlong long d;\n\tif (x1 > x2) { d = x1, x1 = x2, x2 = d; d = y1, y1 = y2, y2 = d; }\n\treturn x1 <= p->x && p->x <= x2 &&\n\t\t((y1 <= y2 && y1 <= p->y && p->y <= y2) ||\n\t\t(y1 > y2 && y2 <= p->y && p->y <= y1))\n\t\t&& (p->y - y1)*(x2 - x1) == (y2 - y1)*(p->x - x1);\n}\n\nint intersection(fPP *p, PP *p1, PP *p2, PP *p3, PP *p4)\n{\n\tlong long t1, t2, t3, t4;\n\tlong long bo, ua;\n\n\tif ((p2->y - p1->y)*(p4->x - p3->x) == (p4->y - p3->y)*(p2->x - p1->x)) return 0;\n\n\tt1 = (p1->y - p3->y)*(p3->x - p4->x) - (p1->x - p3->x)*(p3->y - p4->y);\n\tt2 = (p2->y - p3->y)*(p3->x - p4->x) - (p2->x - p3->x)*(p3->y - p4->y);\n\tt3 = (p3->y - p1->y)*(p1->x - p2->x) - (p3->x - p1->x)*(p1->y - p2->y);\n\tt4 = (p4->y - p1->y)*(p1->x - p2->x) - (p4->x - p1->x)*(p1->y - p2->y);\n\n\tif (t1*t2 < 0 && t3*t4 < 0) {\n\t\t// ??????????????§??????\n\t\tbo = (p4->y - p3->y)*(p2->x - p1->x) - (p4->x - p3->x)*(p2->y - p1->y);\n\t\tua = (p4->x - p3->x)*(p1->y - p3->y) - (p4->y - p3->y)*(p1->x - p3->x);\n\t\tp->x = p1->x + (double)ua / bo * (p2->x - p1->x);\n\t\tp->y = p1->y + (double)ua / bo * (p2->y - p1->y);\n\t\treturn 1;\n\t}\n\tt1 = isPointOnSegment(p1, p3, p4), t2 = isPointOnSegment(p2, p3, p4);\n\tif (t1) p->x = p1->x, p->y = p1->y;\n\telse if (t2) p->x = p2->x, p->y = p2->y;\n\tt3 = isPointOnSegment(p3, p1, p2), t4 = isPointOnSegment(p4, p1, p2);\n\tif (t3) p->x = p3->x, p->y = p3->y;\n\telse if (t4) p->x = p4->x, p->y = p4->y;\n\treturn t1 || t2 || t3 || t4;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0187: Stoning Fortune\n// 2017.8.10\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-6\n\ntypedef struct { int x, y; } PP;\ntypedef struct { double x, y; } fPP;\n\nchar *kichi[] = { \"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\" };\nint std[] = { 1900000, 1000000, 100000, 0, -1 };\n\nPP pp[6];\nfPP fp[3];\n\ndouble dis(fPP *p1, fPP *p2);\nint intersection(fPP *p, PP *p1, PP *p2, PP *p3, PP *p4);\n\nint main()\n{\n\tint i, ans;\n\tdouble a, b, c, s, t;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 6; i += 2) {\n\t\t\tscanf(\"%d%d%d%d\", &(pp[i].x), &(pp[i].y), &(pp[i + 1].x), &(pp[i + 1].y));\n\t\t\tif (!i && !pp[0].x && !pp[0].y && !pp[1].x && !pp[1].y) return 0;\n\t\t}\n\t\tans = 4;\n\t\tif (!intersection(fp    , pp    , pp + 1, pp + 2, pp + 3)) goto NG;\n\t\tif (!intersection(fp + 1, pp + 2, pp + 3, pp + 4, pp + 5)) goto NG;\n\t\tif (!intersection(fp + 2, pp + 4, pp + 5, pp    , pp + 1)) goto NG;\n\n\t\ta = dis(fp, fp + 1), b = dis(fp + 1, fp + 2), c = dis(fp + 2, fp);\n\t\ts = (a + b + c) / 2.0;\n\t\tt = sqrt(s*(s - a)*(s - b)*(s - c));\n\n\t\tif (fabs(t) > EPS) {\n\t\t\tfor (i = 0; ans == 4 && i < 4; i++) {\n\t\t\t\tif (fabs(t - std[i]) <= EPS || t >= std[i]) ans = i;\n\t\t\t}\n\t\t}\nNG:\t\tputs(kichi[ans]);\n\t}\n\treturn 0;\n}\n\ndouble dis(fPP *p1, fPP *p2)\n{\n\tdouble x = p1->x - p2->x, y = p1->y - p2->y;\n\treturn sqrt(x*x + y*y);\n}\n\nint intersection(fPP *p, PP *p1, PP *p2, PP *p3, PP *p4)\n{\n\tint t1, t2, t3, t4;\n\tdouble bo, ua;\n\n\tt1 = (p1->y - p3->y)*(p3->x - p4->x) - (p1->x - p3->x)*(p3->y - p4->y);\n\tt2 = (p2->y - p3->y)*(p3->x - p4->x) - (p2->x - p3->x)*(p3->y - p4->y);\n\tt3 = (p3->y - p1->y)*(p1->x - p2->x) - (p3->x - p1->x)*(p1->y - p2->y);\n\tt4 = (p4->y - p1->y)*(p1->x - p2->x) - (p4->x - p1->x)*(p1->y - p2->y);\n\tbo = (p4->y - p3->y)*(p2->x - p1->x) - (p4->x - p3->x)*(p2->y - p1->y);\n\tif (fabs(bo) <= EPS) return 0;\n\tua = (p4->x - p3->x)*(p1->y - p3->y) - (p4->y - p3->y)*(p1->x - p3->x);\n\tp->x = p1->x + ua / bo * (p2->x - p1->x);\n\tp->y = p1->y + ua / bo * (p2->y - p1->y);\n\tif (t1*t2 >= 0 || t3*t4 >= 0) {\n\t\tif ((p1->x == p3->x && p1->y == p3->y) || (p1->x == p4->x && p1->y == p4->y) ||\n\t\t\t(p2->x == p3->x && p2->y == p3->y) || (p2->x == p4->x && p2->y == p4->y));\n\t\telse return 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\t\tint x3,int y3,int x4,int y4) {\n\tlong long b12x,b12y,b34x,b34y;\n\tlong long b24x,b24y;\n\tlong long b13x,b13y,b14x,b14y,b32x,b32y;\n\tlong long g1213,g1214,g3431,g3432;\n\tlong long n1213,n1214,n3431,n3432;\n\tlong long n2123,n2124,n4341,n4342;\n\n\tb12x=x2-x1;b12y=y2-y1;\n\tb34x=x4-x3;b34y=y4-y3;\n\tb13x=x3-x1;b13y=y3-y1;\n\tb14x=x4-x1;b14y=y4-y1;\n\tb32x=x2-x3;b32y=y2-y3;\n\tb24x=x4-x2;b24y=y4-y2;\n\n\tg1213=b12x*b13y-b13x*b12y;\n\tg1214=b12x*b14y-b14x*b12y;\n\tg3431=b34x*(-b13y)-(-b13x)*b34y;\n\tg3432=b34x*b32y-b32x*b34y;\n\n\tn1213=b12x*b13x+b12y*b13y;\n\tn1214=b12x*b14x+b12y*b14y;\n\tn3431=b34x*(-b13x)+b34y*(-b13y);\n\tn3432=b34x*b32x+b34y*b32y;\n\tn2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);\n\tn2124=(-b12x)*b24x+(-b12y)*b24y;\n\tn4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);\n\tn4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);\n\n\tif(\n\t\t((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) &&\n\t\t((g3431<0 && g3432>0) || (g3431>0 && g3432<0))\n\t) return 1;\n\tif(\n\t\t(g1213==0 && n1213>=0 && n2123>=0) ||\n\t\t(g1214==0 && n1214>=0 && n2124>=0) ||\n\t\t(g3431==0 && n3431>=0 && n4341>=0) ||\n\t\t(g3432==0 && n3432>=0 && n4342>=0)\n\t) return 1;\n\n\treturn 0;\n}\n\n/*\na1x+b1y=c1\na2x+b2y=c2\n*/\nint solve_houteisiki(double* x,double* y,\n\t\tint a1,int b1,int c1,\n\t\tint a2,int b2,int c2) {\n\tint d;\n\td=a1*b2-b1*a2;\n\tif(d==0)return 0;\n\t*x=(double)(b2*c1-b1*c2)/d;\n\t*y=(double)(-a2*c1+a1*c2)/d;\n\treturn 1;\n}\n\nint main(void) {\n\tint x[6],y[6];\n\tint no_triangle;\n\tint x1,y1,t1,x2,y2,t2,x3,y3,t3;\n\tdouble tx1,ty1,tx2,ty2,tx3,ty3;\n\tdouble s;\n\twhile(1) {\n\t\tscanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]);\n\t\tif((x[0]|y[0]|x[1]|y[1])==0)break;\n\t\tscanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]);\n\t\tscanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]);\n\t\tno_triangle=0;\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]);\n\t\tif(!no_triangle) {\n\t\t\tx1=y[1]-y[0];\n\t\t\ty1=-(x[1]-x[0]);\n\t\t\tt1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]);\n\t\t\tx2=y[3]-y[2];\n\t\t\ty2=-(x[3]-x[2]);\n\t\t\tt2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]);\n\t\t\tx3=y[5]-y[4];\n\t\t\ty3=-(x[5]-x[4]);\n\t\t\tt3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx1,&ty1,\n\t\t\t\t\tx1,y1,t1,x2,y2,t2);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx2,&ty2,\n\t\t\t\t\tx2,y2,t2,x3,y3,t3);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx3,&ty3,\n\t\t\t\t\tx3,y3,t3,x1,y1,t1);\n\t\t}\n\t\tif(!no_triangle) {\n\t\t\ts=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;\n\t\t\tif(s<0)s=-s;\n\t\t\tif(s<1e-8)puts(\"kyo\");\n\t\t\telse if(s<100000+1e-8)puts(\"syo-kichi\");\n\t\t\telse if(s<1000000+1e-8)puts(\"kichi\");\n\t\t\telse if(s<1900000+1e-8)puts(\"chu-kichi\");\n\t\t\telse puts(\"dai-kichi\");\n\t\t} else puts(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nL(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy,double*X,double*Y){\n\tint acx,acy,bunbo;\n\tint r,s;\n\tacx=cx-ax;\n\tacy=cy-ay;\n\tbunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tif(bunbo){\n\t\tr=((dy-cy)*acx-(dx-cx)*acy);\n\t\ts=((by-ay)*acx-(bx-ax)*acy);\n\t\tif(bunbo<0){\n\t\t\tr=-r;\n\t\t\ts=-s;\n\t\t\tbunbo=-bunbo;\n\t\t}\n\t\tif(r>=0&&r<=bunbo&&s>=0&&s<=bunbo){\n\t\t\t*X=ax+r/(double)bunbo*(bx-ax);\n\t\t\t*Y=ay+r/(double)bunbo*(by-ay);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nmain(){\n\tint x1[3],y1[3],x2[3],y2[3];\n\tdouble X[3],Y[3],S;\n\tint i=0;\n\tfor(;~scanf(\"%d%d%d%d\",x1+i,y1+i,x2+i,y2+i);){\n\t\tif(++i==3){\n\t\t\tif(L(x1[0],y1[0],x2[0],y2[0],x1[1],y1[1],x2[1],y2[1],X+0,Y+0)&&\n\t\t\t   L(x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],X+1,Y+1)&&\n\t\t\t   L(x1[2],y1[2],x2[2],y2[2],x1[0],y1[0],x2[0],y2[0],X+2,Y+2))\n\t\t\t{\n\t\t\t\tS=0;\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tS+=(X[i]-X[(i+1)%3])*(Y[i]+Y[(i+1)%3])/2;\n\t\t\t\t}\n\t\t\t\tS=fabs(S);\n\t\t\t\tif(S==0)\n\t\t\t\t\tputs(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tputs(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tputs(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tputs(\"chu-kichi\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"dai-kichi\");\n\t\t\t}else{\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\t\tint x3,int y3,int x4,int y4) {\n\tlong long b12x,b12y,b34x,b34y;\n\tlong long b24x,b24y;\n\tlong long b13x,b13y,b14x,b14y,b32x,b32y;\n\tlong long g1213,g1214,g3431,g3432;\n\tlong long n1213,n1214,n3431,n3432;\n\tlong long n2123,n2124,n4341,n4342;\n\n\tb12x=x2-x1;b12y=y2-y1;\n\tb34x=x4-x3;b34y=y4-y3;\n\tb13x=x3-x1;b13y=y3-y1;\n\tb14x=x4-x1;b14y=y4-y1;\n\tb32x=x2-x3;b32y=y2-y3;\n\tb24x=x4-x2;b24y=y4-y2;\n\n\tg1213=b12x*b13y-b13x*b12y;\n\tg1214=b12x*b14y-b14x*b12y;\n\tg3431=b34x*(-b13y)-(-b13x)*b34y;\n\tg3432=b34x*b32y-b32x*b34y;\n\n\tn1213=b12x*b13x+b12y*b13y;\n\tn1214=b12x*b14x+b12y*b14y;\n\tn3431=b34x*(-b13x)+b34y*(-b13y);\n\tn3432=b34x*b32x+b34y*b32y;\n\tn2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);\n\tn2124=(-b12x)*b24x+(-b12y)*b24y;\n\tn4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);\n\tn4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);\n\n\tif(\n\t\t((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) &&\n\t\t((g3431<0 && g3432>0) || (g3431>0 && g3432<0))\n\t) return 1;\n\tif(\n\t\t(g1213==0 && n1213>=0 && n2123>=0) ||\n\t\t(g1214==0 && n1214>=0 && n2124>=0) ||\n\t\t(g3431==0 && n3431>=0 && n4341>=0) ||\n\t\t(g3432==0 && n3432>=0 && n4342>=0)\n\t) return 1;\n\n\treturn 0;\n}\n\n/*\na1x+b1y=c1\na2x+b2y=c2\n*/\nint solve_houteisiki(double* x,double* y,\n\t\tdouble a1,double b1,double c1,\n\t\tdouble a2,double b2,double c2) {\n\tdouble d;\n\td=a1*b2-b1*a2;\n\tif(-1e-8<d && d<1e-8)return 0;\n\t*x=(b2*c1-b1*c2)/d;\n\t*y=(-a2*c1+a1*c2)/d;\n\treturn 1;\n}\n\nint main(void) {\n\tint x[6],y[6];\n\tint no_triangle;\n\tdouble x1,y1,t1,x2,y2,t2,x3,y3,t3;\n\tdouble tx1,ty1,tx2,ty2,tx3,ty3;\n\tdouble s;\n\twhile(1) {\n\t\tscanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]);\n\t\tif((x[0]|y[0]|x[1]|y[1])==0)break;\n\t\tscanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]);\n\t\tscanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]);\n\t\tno_triangle=0;\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]);\n\t\tif(!no_triangle) {\n\t\t\tx1=y[1]-y[0];\n\t\t\ty1=-(x[1]-x[0]);\n\t\t\tt1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]);\n\t\t\tx2=y[3]-y[2];\n\t\t\ty2=-(x[3]-x[2]);\n\t\t\tt2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]);\n\t\t\tx3=y[5]-y[4];\n\t\t\ty3=-(x[5]-x[4]);\n\t\t\tt3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx1,&ty1,\n\t\t\t\t\tx1,y1,t1,x2,y2,t2);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx2,&ty2,\n\t\t\t\t\tx2,y2,t2,x3,y3,t3);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx3,&ty3,\n\t\t\t\t\tx3,y3,t3,x1,y1,t1);\n\t\t}\n\t\tif(!no_triangle) {\n\t\t\ts=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;\n\t\t\tif(s<0)s=-s;\n\t\t\tif(s<1e-8)puts(\"kyo\");\n\t\t\telse if(s<100000+1e-8)puts(\"syo-kichi\");\n\t\t\telse if(s<1000000+1e-8)puts(\"kichi\");\n\t\t\telse if(s<1900000+1e-8)puts(\"chu-kichi\");\n\t\t\telse puts(\"dai-kichi\");\n\t\t} else puts(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0187: Stoning Fortune\n// 2017.8.10\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-6\n\ntypedef struct { int x, y; } PP;\ntypedef struct { double x, y; } fPP;\n\nchar *kichi[] = { \"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\" };\nint std[] = { 1900000, 1000000, 100000, 0, -1 };\n\nPP pp[6];\nfPP fp[3];\n\ndouble dis(fPP *p1, fPP *p2);\nint intersection(fPP *p, PP *p1, PP *p2, PP *p3, PP *p4);\n\nint main()\n{\n\tint i, ans;\n\tdouble a, b, c, s, t;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 6; i += 2) {\n\t\t\tscanf(\"%d%d%d%d\", &(pp[i].x), &(pp[i].y), &(pp[i + 1].x), &(pp[i + 1].y));\n\t\t\tif (!i && !pp[0].x && !pp[0].y && !pp[1].x && !pp[1].y) return 0;\n\t\t}\n\t\tans = 4;\n\t\tif (!intersection(fp, pp, pp + 1, pp + 2, pp + 3)) goto NG;\n\t\tif (!intersection(fp + 1, pp + 2, pp + 3, pp + 4, pp + 5)) goto NG;\n\t\tif (!intersection(fp + 2, pp + 4, pp + 5, pp, pp + 1)) goto NG;\n\n\t\ta = dis(fp, fp + 1), b = dis(fp + 1, fp + 2), c = dis(fp + 2, fp);\n\t\ts = (a + b + c) / 2.0;\n\t\tt = sqrt(s*(s - a)*(s - b)*(s - c));\n\n\t\tif (fabs(t) > EPS) {\n\t\t\tfor (i = 0; ans == 4 && i < 4; i++) {\n\t\t\t\tif (fabs(t - std[i]) <= EPS || t >= std[i]) ans = i;\n\t\t\t}\n\t\t}\n\tNG:\t\tputs(kichi[ans]);\n\t}\n\treturn 0;\n}\n\ndouble dis(fPP *p1, fPP *p2)\n{\n\tdouble x = p1->x - p2->x, y = p1->y - p2->y;\n\treturn sqrt(x*x + y*y);\n}\n\nint isPointOnSegment(PP *p, PP *p1, PP *p2)\n{\n\tint x1 = p1->x, y1 = p1->y, x2 = p2->x, y2 = p2->y;\n\tint d;\n\tif (x1 > x2) { d = x1, x1 = x2, x2 = d; d = y1, y1 = y2, y2 = d; }\n\treturn x1 <= p->x && p->x <= x2 &&\n\t\t((y1 <= y2 && y1 <= p->y && p->y <= y2) ||\n\t\t(y1 > y2 && y2 <= p->y && p->y <= y1))\n\t\t&& (p->y - y1)*(x2 - x1) == (y2 - y1)*(p->x - x1);\n}\n\nint intersection(fPP *p, PP *p1, PP *p2, PP *p3, PP *p4)\n{\n\tint t1, t2, t3, t4;\n\tdouble bo, ua;\n\n\tif ((p2->y - p1->y)*(p4->x - p3->x) == (p4->y - p3->y)*(p2->x - p1->x)) return 0;\n\n\tt1 = (p1->y - p3->y)*(p3->x - p4->x) - (p1->x - p3->x)*(p3->y - p4->y);\n\tt2 = (p2->y - p3->y)*(p3->x - p4->x) - (p2->x - p3->x)*(p3->y - p4->y);\n\tt3 = (p3->y - p1->y)*(p1->x - p2->x) - (p3->x - p1->x)*(p1->y - p2->y);\n\tt4 = (p4->y - p1->y)*(p1->x - p2->x) - (p4->x - p1->x)*(p1->y - p2->y);\n\tbo = (p4->y - p3->y)*(p2->x - p1->x) - (p4->x - p3->x)*(p2->y - p1->y);\n\n\tif (t1*t2 < 0 && t3*t4 < 0) {\n\t\t// ??????????????§??????\n\t\tbo = (p4->y - p3->y)*(p2->x - p1->x) - (p4->x - p3->x)*(p2->y - p1->y);\n\t\tua = (p4->x - p3->x)*(p1->y - p3->y) - (p4->y - p3->y)*(p1->x - p3->x);\n\t\tp->x = p1->x + ua / bo * (p2->x - p1->x);\n\t\tp->y = p1->y + ua / bo * (p2->y - p1->y);\n\t\treturn 1;\n\t}\n\tt1 = isPointOnSegment(p1, p3, p4), t2 = isPointOnSegment(p2, p3, p4);\n\tif (t1) p->x = p1->x, p->y = p1->y;\n\telse if (t2) p->x = p2->x, p->y = p2->y;\n\tt3 = isPointOnSegment(p3, p1, p2), t4 = isPointOnSegment(p4, p1, p2);\n\tif (t3) p->x = p3->x, p->y = p3->y;\n\telse if (t4) p->x = p4->x, p->y = p4->y;\n\treturn t1 || t2 || t3 || t4;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,xa,ya,xb,yb;\ndouble sp[3][2],vec[3][2],pot[3][2],area;\n\nint crosspoint(int i,int j){\n\t\n\tdouble px=sp[i][0],py=sp[i][1];\n\tdouble ax=vec[i][0],ay=vec[i][1];\n\tdouble qx=sp[j][0],qy=sp[j][1];\n\tdouble bx=vec[j][0],by=vec[j][1];\n\n\tif( ( ax*bx+ay*by!=0 ) && ( ax*by==ay*bx ))return 0;\n\n\tdouble a=ax,b=-bx,c=qx-px;\n\tdouble d=ay,e=-by,f=qy-py;\n\tdouble t,x,y;\n\n\tif(a!=0){\n\t\tt=d/a;\n\t\te-=b*t;\n\t\tf-=c*t;\n\t\ty=f/e;\n\t\tx=(c-b*y)/a;\n\t}\n\telse{\n\t\ty=c/b;\n\t\tx=(f-e*y)/d;\n\t}\n\n\tif(x<0 || x>1 || y<0 || y>1)return 0;\n\n\tpot[i][0]=px+ax*x;\n\tpot[i][1]=py+ay*x;\n\n\treturn 1;\n\n}\n\nint main(){\n\twhile(1){\n\t\tfor(i=0;i<3;i++){\n\t\t\tif(scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb)==EOF)goto exit;\n\t\t\tvec[i][0]=xb-xa;vec[i][1]=yb-ya;\n\t\t\tsp[i][0]=xa;sp[i][1]=ya;\n\t\t}\n\t\tfor(i=0;i<3;i++){\n\t\t\tif(crosspoint(i,(i+1)%3)==0)goto bad;\n\t\t}\n\n\t\tdouble vx=pot[1][0]-pot[0][0];\n\t\tdouble vy=pot[1][1]-pot[0][1];\n\t\tdouble wx=pot[2][0]-pot[0][0];\n\t\tdouble wy=pot[2][1]-pot[0][1];\n\n\t\tarea=fabs((vx*wy-vy*wx)/2);\n\n\t\tif(area>=1900000){printf(\"dai-kichi\\n\");continue;}\n\t\tif(area>=1000000){printf(\"chu-kichi\\n\");continue;}\n\t\tif(area>=100000){printf(\"kichi\\n\");continue;}\n\t\tif(area>0){printf(\"syo-kichi\\n\");continue;}\n\t\tbad: printf(\"kyo\\n\");\n\t}\n\texit: return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nL(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy,float*X,float*Y){\n\tint acx,acy,bunbo;\n\tint r,s;\n\tacx=cx-ax;\n\tacy=cy-ay;\n\tbunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tif(bunbo){\n\t\tr=((dy-cy)*acx-(dx-cx)*acy);\n\t\ts=((by-ay)*acx-(bx-ax)*acy);\n\t\tif(bunbo<0){\n\t\t\tr=-r;\n\t\t\ts=-s;\n\t\t\tbunbo=-bunbo;\n\t\t}\n\t\tif(r>=0&&r<=bunbo&&s>=0&&s<=bunbo){\n\t\t\t*X=ax+r/(float)bunbo*(bx-ax);\n\t\t\t*Y=ay+r/(float)bunbo*(by-ay);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nmain(){\n\tint x1[3],y1[3],x2[3],y2[3];\n\tfloat X[3],Y[3],S;\n\tint i=0;\n\tfor(;~scanf(\"%d%d%d%d\",x1+i,y1+i,x2+i,y2+i);){\n\t\tif(++i==3){\n\t\t\tif(L(x1[0],y1[0],x2[0],y2[0],x1[1],y1[1],x2[1],y2[1],X+0,Y+0)&&\n\t\t\t   L(x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],X+1,Y+1)&&\n\t\t\t   L(x1[2],y1[2],x2[2],y2[2],x1[0],y1[0],x2[0],y2[0],X+2,Y+2))\n\t\t\t{\n\t\t\t\tS=0;\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tS+=(X[i]-X[(i+1)%3])*(Y[i]+Y[(i+1)%3])/2;\n\t\t\t\t}\n\t\t\t\tS=fabs(S);\n\t\t\t\tif(S==0)\n\t\t\t\t\tputs(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tputs(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tputs(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tputs(\"chu-kichi\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"dai-kichi\");\n\t\t\t}else{\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nL(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy,double*X,double*Y){\n\tint acx,acy,bunbo;\n\tdouble r,s;\n\t//printf(\"(%d,%d)-(%d,%d) , (%d,%d)-(%d,%d) : \",ax,ay,bx,by,cx,cy,dx,dy);\n\tacx=cx-ax;\n\tacy=cy-ay;\n\tbunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tif(bunbo){\n\t\tr=((dy-cy)*acx-(dx-cx)*acy);\n\t\ts=((by-ay)*acx-(bx-ax)*acy);\n\t\tif(bunbo<0){\n\t\t\tr=-r;\n\t\t\ts=-s;\n\t\t\tbunbo=-bunbo;\n\t\t}\n\t\tif(r>=0&&r<=bunbo&&s>=0&&s<=bunbo){\n\t\t\t*X=ax+r*(bx-ax)/(double)bunbo;\n\t\t\t*Y=ay+r*(by-ay)/(double)bunbo;\n\t\t\t//printf(\"(%f,%f)\\n\",*X,*Y);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t//printf(\"NA\\n\");\n\treturn 0;\n}\nmain(){\n\tint x1[3],y1[3],x2[3],y2[3];\n\tdouble X[3],Y[3],S;\n\tint i=0;\n\tfor(;~scanf(\"%d%d%d%d\",x1+i,y1+i,x2+i,y2+i);){\n\t\tif(++i==3){\n\t\t\tif(L(x1[0],y1[0],x2[0],y2[0],x1[1],y1[1],x2[1],y2[1],X+0,Y+0)&&\n\t\t\t   L(x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],X+1,Y+1)&&\n\t\t\t   L(x1[2],y1[2],x2[2],y2[2],x1[0],y1[0],x2[0],y2[0],X+2,Y+2))\n\t\t\t{\n\t\t\t\tS=0;\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tS+=(X[i]-X[(i+1)%3])*(Y[i]+Y[(i+1)%3])/2;\n\t\t\t\t}\n\t\t\t\tS=fabs(S);\n\t\t\t\tif(S<100000)\n\t\t\t\t\tputs(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tputs(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tputs(\"chu-kichi\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"dai-kichi\");\n\t\t\t}else{\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\t\tint x3,int y3,int x4,int y4) {\n\tlong long b12x,b12y,b34x,b34y;\n\tlong long b24x,b24y;\n\tlong long b13x,b13y,b14x,b14y,b32x,b32y;\n\tlong long g1213,g1214,g3431,g3432;\n\tlong long n1213,n1214,n3431,n3432;\n\tlong long n2123,n2124,n4341,n4342;\n\n\tb12x=x2-x1;b12y=y2-y1;\n\tb34x=x4-x3;b34y=y4-y3;\n\tb13x=x3-x1;b13y=y3-y1;\n\tb14x=x4-x1;b14y=y4-y1;\n\tb32x=x2-x3;b32y=y2-y3;\n\tb24x=x4-x2;b24y=y4-y2;\n\n\tg1213=b12x*b13y-b13x*b12y;\n\tg1214=b12x*b14y-b14x*b12y;\n\tg3431=b34x*(-b13y)-(-b13x)*b34y;\n\tg3432=b34x*b32y-b32x*b34y;\n\n\tn1213=b12x*b13x+b12y*b13y;\n\tn1214=b12x*b14x+b12y*b14y;\n\tn3431=b34x*(-b13x)+b34y*(-b13y);\n\tn3432=b34x*b32x+b34y*b32y;\n\tn2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);\n\tn2124=(-b12x)*b24x+(-b12y)*b24y;\n\tn4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);\n\tn4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);\n\n\tif(\n\t\t((g1213<0 && g1214>0) || (g1213>0 && g1214<0)) &&\n\t\t((g3431<0 && g3432>0) || (g3431>0 && g3432<0))\n\t) return 1;\n\tif(\n\t\t(g1213==0 && n1213>=0 && n2123>=0) ||\n\t\t(g1214==0 && n1214>=0 && n2124>=0) ||\n\t\t(g3431==0 && n3431>=0 && n4341>=0) ||\n\t\t(g3432==0 && n3432>=0 && n4342>=0)\n\t) return 1;\n\n\treturn 0;\n}\n\n/*\na1x+b1y=c1\na2x+b2y=c2\n*/\nint solve_houteisiki(double* x,double* y,\n\t\tint a1,int b1,int c1,\n\t\tint a2,int b2,int c2) {\n\tint d;\n\td=a1*b2-b1*a2;\n\tif(d==0)return 0;\n\t*x=(double)(b2*c1-b1*c2)/d;\n\t*y=(double)(-a2*c1+a1*c2)/d;\n\treturn 1;\n}\n\nint main(void) {\n\tint x[6],y[6];\n\tint no_triangle;\n\tint x1,y1,t1,x2,y2,t2,x3,y3,t3;\n\tdouble tx1,ty1,tx2,ty2,tx3,ty3;\n\tdouble s;\n\twhile(1) {\n\t\tscanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]);\n\t\tif((x[0]|y[0]|x[1]|y[1])==0)break;\n\t\tscanf(\"%d%d%d%d\",&x[2],&y[2],&x[3],&y[3]);\n\t\tscanf(\"%d%d%d%d\",&x[4],&y[4],&x[5],&y[5]);\n\t\tno_triangle=0;\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[2],y[2],x[3],y[3],x[4],y[4],x[5],y[5]);\n\t\tno_triangle=no_triangle ||\n\t\t\t!cross(x[4],y[4],x[5],y[5],x[0],y[0],x[1],y[1]);\n\t\tif(!no_triangle) {\n\t\t\tx1=y[1]-y[0];\n\t\t\ty1=-(x[1]-x[0]);\n\t\t\tt1=x[0]*(y[1]-y[0])-y[0]*(x[1]-x[0]);\n\t\t\tx2=y[3]-y[2];\n\t\t\ty2=-(x[3]-x[2]);\n\t\t\tt2=x[2]*(y[3]-y[2])-y[2]*(x[3]-x[2]);\n\t\t\tx3=y[5]-y[4];\n\t\t\ty3=-(x[5]-x[4]);\n\t\t\tt3=x[4]*(y[5]-y[4])-y[4]*(x[5]-x[4]);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx1,&ty1,\n\t\t\t\t\tx1,y1,t1,x2,y2,t2);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx2,&ty2,\n\t\t\t\t\tx2,y2,t2,x3,y3,t3);\n\t\t\tno_triangle=no_triangle ||\n\t\t\t\t!solve_houteisiki(&tx3,&ty3,\n\t\t\t\t\tx3,y3,t3,x1,y1,t1);\n\t\t}\n\t\tif(!no_triangle) {\n\t\t\ts=((tx2-tx1)*(ty3-ty1)-(tx3-tx1)*(ty2-ty1))/2;\n\t\t\tif(s<0)s=-s;\n\t\t\tif(s<1e-8)puts(\"kyo\");\n\t\t\telse if(s<100000)puts(\"syo-kichi\");\n\t\t\telse if(s<1000000)puts(\"kichi\");\n\t\t\telse if(s<1900000)puts(\"chu-kichi\");\n\t\t\telse puts(\"dai-kichi\");\n\t\t} else puts(\"kyo\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nL(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy,double*X,double*Y){\n\tint acx,acy,bunbo;\n\tint r,s;\n\t//printf(\"(%d,%d)-(%d,%d) , (%d,%d)-(%d,%d) : \",ax,ay,bx,by,cx,cy,dx,dy);\n\tacx=cx-ax;\n\tacy=cy-ay;\n\tbunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tif(bunbo){\n\t\tr=((dy-cy)*acx-(dx-cx)*acy);\n\t\ts=((by-ay)*acx-(bx-ax)*acy);\n\t\tif(bunbo<0){\n\t\t\tr=-r;\n\t\t\ts=-s;\n\t\t\tbunbo=-bunbo;\n\t\t}\n\t\tif(r>=0&&r<=bunbo&&s>=0&&s<=bunbo){\n\t\t\t*X=ax+r*(bx-ax)/(double)bunbo;\n\t\t\t*Y=ay+r*(by-ay)/(double)bunbo;\n\t\t\t//printf(\"(%f,%f)\\n\",*X,*Y);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t//printf(\"NA\\n\");\n\treturn 0;\n}\nmain(){\n\tint x1[3],y1[3],x2[3],y2[3];\n\tdouble X[3],Y[3],S;\n\tint i=0;\n\tfor(;~scanf(\"%d%d%d%d\",x1+i,y1+i,x2+i,y2+i);){\n\t\tif(++i==3){\n\t\t\tif(L(x1[0],y1[0],x2[0],y2[0],x1[1],y1[1],x2[1],y2[1],X+0,Y+0)&&\n\t\t\t   L(x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],X+1,Y+1)&&\n\t\t\t   L(x1[2],y1[2],x2[2],y2[2],x1[0],y1[0],x2[0],y2[0],X+2,Y+2))\n\t\t\t{\n\t\t\t\tS=0;\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tS+=(X[i]-X[(i+1)%3])*(Y[i]+Y[(i+1)%3])/2;\n\t\t\t\t}\n\t\t\t\tS=fabs(S);\n\t\t\t\tif(S==0)\n\t\t\t\t\tputs(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tputs(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tputs(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tputs(\"chu-kichi\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"dai-kichi\");\n\t\t\t}else{\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble gaiseki(double,double,double,double);\n\nmain(){\n  double x[6], y[6], tenx[3], teny[3], len[3], s, m1, m2, ans, bx[5], by[5], temp1, temp2;\n  int i, j, p=0, f, a;\n\n  while(1){\n    for(i=0;i<6;i+=2){\n      scanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &x[i+1], &y[i+1]);\n      if(x[0]==0 && y[0]==0 && x[1]==0 && y[1]==0){\n\tp=1;\n\tbreak;\n      }\n    }\n    if(p==1) break;\n    f=0;\n    \n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[0];\n    by[1]=y[2]-y[0];\n    bx[2]=x[2]-x[1];\n    by[2]=y[2]-y[1];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[2];\n    by[1]=y[0]-y[2];\n    bx[2]=x[0]-x[3];\n    by[2]=y[0]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[2];\n    by[1]=y[4]-y[2];\n    bx[2]=x[4]-x[3];\n    by[2]=y[4]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[5];\n    by[1]=y[2]-y[5];\n    bx[2]=x[2]-x[4];\n    by[2]=y[2]-y[4];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[4];\n    by[1]=y[0]-y[4];\n    bx[2]=x[0]-x[5];\n    by[2]=y[0]-y[5];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[1];\n    by[1]=y[4]-y[1];\n    bx[2]=x[4]-x[0];\n    by[2]=y[4]-y[0];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n\n\n    m1=(y[1]-y[0])/(x[1]-x[0]);\n    m2=(y[3]-y[2])/(x[3]-x[2]);\n    \n    tenx[0]=(m1*x[0]-m2*x[2]+y[2]-y[0])/(m1-m2);\n    teny[0]=m1*(tenx[0]-x[0])+y[0];\n\n    m1=(y[3]-y[2])/(x[3]-x[2]);\n    m2=(y[5]-y[4])/(x[5]-x[4]);\n\n    tenx[1]=(m1*x[2]-m2*x[4]+y[4]-y[2])/(m1-m2);\n    teny[1]=m1*(tenx[1]-x[2])+y[2];\n\n    m1=(y[5]-y[4])/(x[5]-x[4]);\n    m2=(y[1]-y[0])/(x[1]-x[0]);\n\n    tenx[2]=(m1*x[4]-m2*x[0]+y[0]-y[4])/(m1-m2);\n    teny[2]=m1*(tenx[2]-x[4])+y[4];\n    \n\n    if((tenx[0]==tenx[1] && teny[0]==teny[1]) || tenx[1]==tenx[2] && (teny[1]==teny[2]) || (tenx[2]==tenx[0] && teny[2]==teny[0])){\n      printf(\"kyo\\n\");\n      continue;\n    }\n   \n    for(i=0,j=1;i<3;i++,j++){\n      if(j==3) j=0;\n      len[i]=sqrt((tenx[i]-tenx[j])*(tenx[i]-tenx[j])+(teny[i]-teny[j])*(teny[i]-teny[j]));\n    }\n    \n\n    s=(len[0]+len[1]+len[2])/2;\n    ans=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n    \n    a=ans+0.0000001;\n    if(ans>=1900000) printf(\"dai-kichi\\n\");\n    else if(ans>=1000000) printf(\"chu-kichi\\n\");\n    else if(ans>=100000) printf(\"kichi\\n\");\n    else if(ans>0) printf(\"syo-kichi\\n\");\n  }\n  return 0;\n}\n\n\n\ndouble gaiseki(double a, double b, double c, double d){\n  return (a*d-b*c);\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nL(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy,double*X,double*Y){\n\tint acx,acy,bunbo;\n\tint r,s;\n\t//printf(\"(%d,%d)-(%d,%d) , (%d,%d)-(%d,%d) : \",ax,ay,bx,by,cx,cy,dx,dy);\n\tacx=cx-ax;\n\tacy=cy-ay;\n\tbunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tif(bunbo){\n\t\tr=((dy-cy)*acx-(dx-cx)*acy);\n\t\ts=((by-ay)*acx-(bx-ax)*acy);\n\t\tif(bunbo<0){\n\t\t\tr=-r;\n\t\t\ts=-s;\n\t\t\tbunbo=-bunbo;\n\t\t}\n\t\tif(r>=0&&r<=bunbo&&s>=0&&s<=bunbo){\n\t\t\t*X=ax+r*(bx-ax)/(double)bunbo;\n\t\t\t*Y=ay+r*(by-ay)/(double)bunbo;\n\t\t\t//printf(\"(%f,%f)\\n\",*X,*Y);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t//printf(\"NA\\n\");\n\treturn 0;\n}\nmain(){\n\tint x1[3],y1[3],x2[3],y2[3];\n\tdouble X[3],Y[3],S;\n\tint i=0;\n\tfor(;~scanf(\"%d%d%d%d\",x1+i,y1+i,x2+i,y2+i);){\n\t\tif(++i==3){\n\t\t\tif(L(x1[0],y1[0],x2[0],y2[0],x1[1],y1[1],x2[1],y2[1],X+0,Y+0)&&\n\t\t\t   L(x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],X+1,Y+1)&&\n\t\t\t   L(x1[2],y1[2],x2[2],y2[2],x1[0],y1[0],x2[0],y2[0],X+2,Y+2))\n\t\t\t{\n\t\t\t\tS=0;\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tS+=(X[i]-X[(i+1)%3])*(Y[i]+Y[(i+1)%3])/2;\n\t\t\t\t}\n\t\t\t\tS=fabs(S);\n\t\t\t\tif(S<1e-6)\n\t\t\t\t\tputs(\"kyo\");\n\t\t\t\telse if(S<100000-1e-6)\n\t\t\t\t\tputs(\"syo-kichi\");\n\t\t\t\telse if(S<1000000-1e-6)\n\t\t\t\t\tputs(\"kichi\");\n\t\t\t\telse if(S<1900000-1e-6)\n\t\t\t\t\tputs(\"chu-kichi\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"dai-kichi\");\n\t\t\t}else{\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    Point p[3], q[3], x[3];\n    double S;\n\t\n    while (1){\n        for (int i = 0; i < 3; i++){\n\t\t\tint x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\t\n            if (i == 0 && x1 == 0 && x2 == 0 && y1 == 0 && y2 == 0) return (0);\n\t\t\t\n\t\t\tp[i] = Point(x1, y1); q[i] = Point(x2, y2);\n        }\n\t\t\n\t\tint k = 0;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\t\tif (!isIntersect(p[i], q[i], p[j], q[j])){\n\t\t\t\t\tprintf(\"kyo\\n\");\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tx[k++] = interPointS(p[i], q[i], p[j], q[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (x[0] == x[1] || x[1] == x[2] || x[0] == x[2]){\n\t\t\tprintf(\"kyo\\n\");\n\t\t\tgoto next;\n\t\t}\n\t\t\n\t\tS = area(x[0], x[1], x[2]);\n\t\t\n\t\tif (S >= 1900000) printf(\"dai-kichi\\n\");\n\t\telse if (S >= 1000000) printf(\"chu-kichi\\n\");\n\t\telse if (S >= 100000) printf(\"kichi\\n\");\n\t\telse printf(\"syo-kichi\\n\");\n\t\t\n\t\tnext:;\n\t}\t\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,xa,ya,xb,yb;\ndouble sp[3][2],vec[3][2],pot[3][2],area;\n\nint crosspoint(int i,int j){\n\t\n\tdouble px=sp[i][0],py=sp[i][1];\n\tdouble ax=vec[i][0],ay=vec[i][1];\n\tdouble qx=sp[j][0],qy=sp[j][1];\n\tdouble bx=vec[j][0],by=vec[j][1];\n\n\tif( ( ax*bx+ay*by!=0 ) && ( ax*by==ay*bx ))return 0;\n\n\tdouble a=ax,b=-bx,c=qx-px;\n\tdouble d=ay,e=-by,f=qy-py;\n\tdouble t,x,y;\n\n\tif(a!=0){\n\t\tt=d/a;\n\t\te-=b*t;\n\t\tf-=c*t;\n\t\ty=f/e;\n\t\tx=(c-b*y)/a;\n\t}\n\telse{\n\t\ty=c/b;\n\t\tx=(f-e*y)/d;\n\t}\n\n\tif(x<0 || x>1 || y<0 || y>1)return 0;\n\n\tpot[i][0]=px+ax*x;\n\tpot[i][1]=py+ay*x;\n\n\treturn 1;\n\n}\n\nint main(){\n\twhile(1){\n\t\tfor(i=0;i<3;i++){\n\t\t\tif(scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb)==EOF)goto exit;\n\t\t\tvec[i][0]=xb-xa;vec[i][1]=yb-ya;\n\t\t\tsp[i][0]=xa;sp[i][1]=ya;\n\t\t}\n\t\tfor(i=0;i<3;i++){\n\t\t\tif(crosspoint(i,(i+1)%3)==0)goto bad;\n\t\t}\n\n\t\tdouble vx=pot[1][0]-pot[0][0];\n\t\tdouble vy=pot[1][1]-pot[1][0];\n\t\tdouble wx=pot[2][0]-pot[0][0];\n\t\tdouble wy=pot[2][1]-pot[1][0];\n\n\t\tarea=fabs((vx*wy-vy*wx)/2);\n\n\t\tif(area>=1900000){printf(\"dai-kichi\\n\");continue;}\n\t\tif(area>=1000000){printf(\"chu-kichi\\n\");continue;}\n\t\tif(area>=100000){printf(\"kichi\\n\");continue;}\n\t\tif(area>0){printf(\"sho-kichi\\n\");continue;}\n\t\tbad: printf(\"kyo\\n\");\n\t}\n\texit: return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble gaiseki(double,double,double,double);\n\nmain(){\n  double x[6], y[6], tenx[3], teny[3], len[3], s, m1, m2, ans, bx[5], by[5], temp1, temp2;\n  int i, j, p=0, f, a;\n\n  while(1){\n    for(i=0;i<6;i+=2){\n      scanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &x[i+1], &y[i+1]);\n      if(x[0]==0 && y[0]==0 && x[1]==0 && y[1]==0){\n\tp=1;\n\tbreak;\n      }\n    }\n    if(p==1) break;\n    f=0;\n    \n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[0];\n    by[1]=y[2]-y[0];\n    bx[2]=x[2]-x[1];\n    by[2]=y[2]-y[1];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[2];\n    by[1]=y[0]-y[2];\n    bx[2]=x[0]-x[3];\n    by[2]=y[0]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[2];\n    by[1]=y[4]-y[2];\n    bx[2]=x[4]-x[3];\n    by[2]=y[4]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[5];\n    by[1]=y[2]-y[5];\n    bx[2]=x[2]-x[4];\n    by[2]=y[2]-y[4];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[4];\n    by[1]=y[0]-y[4];\n    bx[2]=x[0]-x[5];\n    by[2]=y[0]-y[5];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[1];\n    by[1]=y[4]-y[1];\n    bx[2]=x[4]-x[0];\n    by[2]=y[4]-y[0];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n\n\n    m1=(y[1]-y[0])/(x[1]-x[0]);\n    m2=(y[3]-y[2])/(x[3]-x[2]);\n    \n    tenx[0]=(m1*x[0]-m2*x[2]+y[2]-y[0])/(m1-m2);\n    teny[0]=m1*(tenx[0]-x[0])+y[0];\n\n    m1=(y[3]-y[2])/(x[3]-x[2]);\n    m2=(y[5]-y[4])/(x[5]-x[4]);\n\n    tenx[1]=(m1*x[2]-m2*x[4]+y[4]-y[2])/(m1-m2);\n    teny[1]=m1*(tenx[1]-x[2])+y[2];\n\n    m1=(y[5]-y[4])/(x[5]-x[4]);\n    m2=(y[1]-y[0])/(x[1]-x[0]);\n\n    tenx[2]=(m1*x[4]-m2*x[0]+y[0]-y[4])/(m1-m2);\n    teny[2]=m1*(tenx[2]-x[4])+y[4];\n    \n   \n    for(i=0,j=1;i<3;i++,j++){\n      if(j==3) j=0;\n      len[i]=sqrt((tenx[i]-tenx[j])*(tenx[i]-tenx[j])+(teny[i]-teny[j])*(teny[i]-teny[j]));\n    }\n    \n\n    s=(len[0]+len[1]+len[2])/2;\n    ans=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n    \n    a=ans+0.000001;\n    if(a>=1900000) printf(\"dai-kichi\\n\");\n    else if(a>=1000000) printf(\"chu-kichi\\n\");\n    else if(a>=100000) printf(\"kichi\\n\");\n    else if(a>0) printf(\"syo-kichi\\n\");\n    else printf(\"kyo\\n\");\n  }\n  return 0;\n}\n\n\n\ndouble gaiseki(double a, double b, double c, double d){\n  return (a*d-b*c);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0187: Stoning Fortune\n// 2017.8.10\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-6\n\ntypedef struct { int x, y; } PP;\ntypedef struct { double x, y; } fPP;\n\nchar *kichi[] = { \"dai-kichi\", \"chu-kichi\", \"kichi\", \"syo-kichi\", \"kyo\" };\nint std[] = { 1900000, 1000000, 100000, 0, -1 };\n\nPP pp[6];\nfPP fp[3];\n\ndouble dis(fPP *p1, fPP *p2);\nint intersection(fPP *p, PP *p1, PP *p2, PP *p3, PP *p4);\n\nint main()\n{\n\tint i, ans;\n\tdouble a, b, c, s, t;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 6; i += 2) {\n\t\t\tscanf(\"%d%d%d%d\", &(pp[i].x), &(pp[i].y), &(pp[i + 1].x), &(pp[i + 1].y));\n\t\t\tif (!i && !pp[0].x && !pp[0].y && !pp[1].x && !pp[1].y) return 0;\n\t\t}\n\t\tans = 4;\n\t\tif (!intersection(fp    , pp    , pp + 1, pp + 2, pp + 3)) goto NG;\n\t\tif (!intersection(fp + 1, pp + 2, pp + 3, pp + 4, pp + 5)) goto NG;\n\t\tif (!intersection(fp + 2, pp + 4, pp + 5, pp    , pp + 1)) goto NG;\n\n\t\ta = dis(fp, fp + 1), b = dis(fp + 1, fp + 2), c = dis(fp + 2, fp);\n\t\ts = (a + b + c) / 2.0;\n\t\tt = sqrt(s*(s - a)*(s - b)*(s - c));\n\n\t\tif (fabs(t) > EPS) {\n\t\t\tfor (i = 0; ans == 4 && i < 4; i++) {\n\t\t\t\tif (fabs(t - std[i]) <= EPS || t >= std[i]) ans = i;\n\t\t\t}\n\t\t}\nNG:\t\tputs(kichi[ans]);\n\t}\n\treturn 0;\n}\n\ndouble dis(fPP *p1, fPP *p2)\n{\n\tdouble x = p1->x - p2->x, y = p1->y - p2->y;\n\treturn sqrt(x*x + y*y);\n}\n\nint intersection(fPP *p, PP *p1, PP *p2, PP *p3, PP *p4)\n{\n\tint t1, t2, t3, t4;\n\tdouble bo, ua;\n\n\tt1 = (p1->y - p3->y)*(p3->x - p4->x) - (p1->x - p3->x)*(p3->y - p4->y);\n\tt2 = (p2->y - p3->y)*(p3->x - p4->x) - (p2->x - p3->x)*(p3->y - p4->y);\n\tt3 = (p3->y - p1->y)*(p1->x - p2->x) - (p3->x - p1->x)*(p1->y - p2->y);\n\tt4 = (p4->y - p1->y)*(p1->x - p2->x) - (p4->x - p1->x)*(p1->y - p2->y);\n\tbo = (p4->y - p3->y)*(p2->x - p1->x) - (p4->x - p3->x)*(p2->y - p1->y);\n\tif (fabs(bo) <= EPS) return 0;\n\tua = (p4->x - p3->x)*(p1->y - p3->y) - (p4->y - p3->y)*(p1->x - p3->x);\n\tp->x = p1->x + ua / bo * (p2->x - p1->x);\n\tp->y = p1->y + ua / bo * (p2->y - p1->y);\n#if 0\n\tif (t1*t2 >= 0 || t3*t4 >= 0) {\n\t\tif ((p1->x == p3->x && p1->y == p3->y) || (p1->x == p4->x && p1->y == p4->y) ||\n\t\t\t(p2->x == p3->x && p2->y == p3->y) || (p2->x == p4->x && p2->y == p4->y));\n\t\telse return 0;\n\t}\n#endif\n\tif (t1*t2 > 0 || t3*t4 > 0) return 0;\n\treturn 1;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nL(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy,double*X,double*Y){\n\tint acx,acy,bunbo;\n\tint r,s;\n\t//printf(\"(%d,%d)-(%d,%d) , (%d,%d)-(%d,%d) : \",ax,ay,bx,by,cx,cy,dx,dy);\n\tacx=cx-ax;\n\tacy=cy-ay;\n\tbunbo=(bx-ax)*(dy-cy)-(by-ay)*(dx-cx);\n\tif(bunbo){\n\t\tr=((dy-cy)*acx-(dx-cx)*acy);\n\t\ts=((by-ay)*acx-(bx-ax)*acy);\n\t\tif(bunbo<0){\n\t\t\tr=-r;\n\t\t\ts=-s;\n\t\t\tbunbo=-bunbo;\n\t\t}\n\t\tif(r>=0&&r<=bunbo&&s>=0&&s<=bunbo){\n\t\t\t*X=ax+r/(double)bunbo*(bx-ax);\n\t\t\t*Y=ay+r/(double)bunbo*(by-ay);\n\t\t\t//printf(\"(%f,%f)\\n\",*X,*Y);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t//printf(\"NA\\n\");\n\treturn 0;\n}\nmain(){\n\tint x1[3],y1[3],x2[3],y2[3];\n\tdouble X[3],Y[3],S;\n\tint i=0;\n\tfor(;~scanf(\"%d%d%d%d\",x1+i,y1+i,x2+i,y2+i);){\n\t\tif(++i==3){\n\t\t\tif(L(x1[0],y1[0],x2[0],y2[0],x1[1],y1[1],x2[1],y2[1],X+0,Y+0)&&\n\t\t\t   L(x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],X+1,Y+1)&&\n\t\t\t   L(x1[2],y1[2],x2[2],y2[2],x1[0],y1[0],x2[0],y2[0],X+2,Y+2))\n\t\t\t{\n\t\t\t\tS=0;\n\t\t\t\tfor(i=0;i<3;i++){\n\t\t\t\t\tS+=(X[i]-X[(i+1)%3])*(Y[i]+Y[(i+1)%3])/2;\n\t\t\t\t}\n\t\t\t\tS=fabs(S);\n\t\t\t\tif(S<1e-6)\n\t\t\t\t\tputs(\"kyo\");\n\t\t\t\telse if(S<100000-1e-6)\n\t\t\t\t\tputs(\"syo-kichi\");\n\t\t\t\telse if(S<1000000-1e-6)\n\t\t\t\t\tputs(\"kichi\");\n\t\t\t\telse if(S<1900000-1e-6)\n\t\t\t\t\tputs(\"chu-kichi\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"dai-kichi\");\n\t\t\t}else{\n\t\t\t\tputs(\"kyo\");\n\t\t\t}\n\t\t\ti=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble gaiseki(double,double,double,double);\n\nmain(){\n  double x[6], y[6], tenx[3], teny[3], len[3], s, m1, m2, ans, bx[5], by[5], temp1, temp2;\n  int i, j, p=0, f, a;\n\n  while(1){\n    for(i=0;i<6;i+=2){\n      scanf(\"%lf %lf %lf %lf\", &x[i], &y[i], &x[i+1], &y[i+1]);\n      if(x[0]==0 && y[0]==0 && x[1]==0 && y[1]==0){\n\tp=1;\n\tbreak;\n      }\n    }\n    if(p==1) break;\n    f=0;\n    \n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[0];\n    by[1]=y[2]-y[0];\n    bx[2]=x[2]-x[1];\n    by[2]=y[2]-y[1];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[2];\n    by[1]=y[0]-y[2];\n    bx[2]=x[0]-x[3];\n    by[2]=y[0]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[2];\n    by[1]=y[4]-y[2];\n    bx[2]=x[4]-x[3];\n    by[2]=y[4]-y[3];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[2]-x[3];\n    by[0]=y[2]-y[3];\n    bx[1]=x[2]-x[5];\n    by[1]=y[2]-y[5];\n    bx[2]=x[2]-x[4];\n    by[2]=y[2]-y[4];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n    bx[0]=x[0]-x[1];\n    by[0]=y[0]-y[1];\n    bx[1]=x[0]-x[4];\n    by[1]=y[0]-y[4];\n    bx[2]=x[0]-x[5];\n    by[2]=y[0]-y[5];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n    bx[0]=x[4]-x[5];\n    by[0]=y[4]-y[5];\n    bx[1]=x[4]-x[1];\n    by[1]=y[4]-y[1];\n    bx[2]=x[4]-x[0];\n    by[2]=y[4]-y[0];\n    temp1=gaiseki(bx[0],by[0],bx[1],by[1]);\n    temp2=gaiseki(bx[0],by[0],bx[2],by[2]);\n    if(temp1*temp2>=0){\n      printf(\"kyo\\n\");\n      continue;\n    }\n\n\n\n    m1=(y[1]-y[0])/(x[1]-x[0]);\n    m2=(y[3]-y[2])/(x[3]-x[2]);\n    \n    tenx[0]=(m1*x[0]-m2*x[2]+y[2]-y[0])/(m1-m2);\n    teny[0]=m1*(tenx[0]-x[0])+y[0];\n\n    m1=(y[3]-y[2])/(x[3]-x[2]);\n    m2=(y[5]-y[4])/(x[5]-x[4]);\n\n    tenx[1]=(m1*x[2]-m2*x[4]+y[4]-y[2])/(m1-m2);\n    teny[1]=m1*(tenx[1]-x[2])+y[2];\n\n    m1=(y[5]-y[4])/(x[5]-x[4]);\n    m2=(y[1]-y[0])/(x[1]-x[0]);\n\n    tenx[2]=(m1*x[4]-m2*x[0]+y[0]-y[4])/(m1-m2);\n    teny[2]=m1*(tenx[2]-x[4])+y[4];\n    \n\n    if((tenx[0]==tenx[1] && teny[0]==teny[1]) || tenx[1]==tenx[2] && (teny[1]==teny[2]) || (tenx[2]==tenx[0] && teny[2]==teny[0])){\n      printf(\"kyo\\n\");\n      continue;\n    }\n   \n    for(i=0,j=1;i<3;i++,j++){\n      if(j==3) j=0;\n      len[i]=sqrt((tenx[i]-tenx[j])*(tenx[i]-tenx[j])+(teny[i]-teny[j])*(teny[i]-teny[j]));\n    }\n    \n\n    s=(len[0]+len[1]+len[2])/2;\n    ans=sqrt(s*(s-len[0])*(s-len[1])*(s-len[2]));\n    \n    a=ans+0.0000001;\n    if(a>=1900000) printf(\"dai-kichi\\n\");\n    else if(a>=1000000) printf(\"chu-kichi\\n\");\n    else if(a>=100000) printf(\"kichi\\n\");\n    else if(a>0) printf(\"syo-kichi\\n\");\n  }\n  return 0;\n}\n\n\n\ndouble gaiseki(double a, double b, double c, double d){\n  return (a*d-b*c);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\t\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\tif(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[][] lines = new Point2D[3][2];\n\t\t\t\n\t\t\tlines[0][0] = new Point2D(x1, y1);\n\t\t\tlines[0][1] = new Point2D(x2, y2);\n\t\t\tlines[1][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[1][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\t\n\t\t\tPoint2D[] crosses = new Point2D[3];\n\t\t\tboolean not_found = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(Point2D.intersect_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1])){\n\t\t\t\t\tcrosses[i] = Point2D.interpoint_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1]);\n\t\t\t\t}else{\n\t\t\t\t\tcrosses[i] = null;\n\t\t\t\t\tnot_found = true;\n\t\t\t\t}\n\t\t\t\t//System.out.println(crosses[i]);\n\t\t\t}\n\t\t\t\n\t\t\tif(not_found){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tboolean same = true;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(!crosses[i].equals(crosses[i + 1 >= 3 ? 0 : (i + 1)])){\n\t\t\t\t\tsame = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(same){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble S = (((crosses[0].sub(crosses[1]).dist_o() * crosses[0].sub(crosses[1]).dist_o())\n\t\t\t\t\t\t* (crosses[0].sub(crosses[2]).dist_o() * crosses[0].sub(crosses[2]).dist_o())) -\n\t\t\t\t\t\t((crosses[0].sub(crosses[1]).dot(crosses[0].sub(crosses[2])))\n\t\t\t\t\t\t*(crosses[0].sub(crosses[1]).dot(crosses[0].sub(crosses[2])))))/ 2;\n\t\t\tif(S >= 1900000){\n\t\t\t\tSystem.out.println(\"dai-kichi\");\n\t\t\t}else if(S >= 1000000){\n\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t}else if(S >= 100000){\n\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"sho-kichi\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-7;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\t//\t\t\tif(Math.abs(slanting(p1, p2)-slanting(p3, p4))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tif(Math.abs(slanting(p3, p4)-slanting(p5, p6))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tif(Math.abs(slanting(p5, p6)-slanting(p1, p2))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\t//System.out.println(x1+\" \"+y1+\" \"+x2+\" \"+y2+\" \"+x3+\" \"+y3);\n\t\t\t\tif(Math.abs(x1-x2)<EPS&&Math.abs(y1-y2)<EPS)\n\t\t\t\t\tif(Math.abs(x2-x3)<EPS&&Math.abs(y2-y3)<EPS)\n\t\t\t\t\t\tif(Math.abs(x3-x1)<EPS&&Math.abs(y3-y1)<EPS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tSystem.out.println(a+\" \"+b+\" \"+c+\" \"+d);\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-5;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\t\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\tif(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[][] lines = new Point2D[3][2];\n\t\t\t\n\t\t\tlines[0][0] = new Point2D(x1, y1);\n\t\t\tlines[0][1] = new Point2D(x2, y2);\n\t\t\tlines[1][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[1][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\t\n\t\t\tPoint2D[] crosses = new Point2D[3];\n\t\t\tboolean not_found = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(Point2D.intersect_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1])){\n\t\t\t\t\tcrosses[i] = Point2D.interpoint_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1]);\n\t\t\t\t}else{\n\t\t\t\t\tcrosses[i] = null;\n\t\t\t\t\tnot_found = true;\n\t\t\t\t}\n\t\t\t\t//System.out.println(crosses[i]);\n\t\t\t}\n\t\t\t\n\t\t\tif(not_found){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tboolean same = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(crosses[i].equals(crosses[i + 1 >= 3 ? 0 : (i + 1)])){\n\t\t\t\t\tsame = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(same){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble S = Point2D.area(crosses[0], crosses[1], crosses[2]);\n\t\t\t//System.out.println(S);\n\t\t\tif(S >= 1900000){\n\t\t\t\tSystem.out.println(\"dai-kichi\");\n\t\t\t}else if(S >= 1000000){\n\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t}else if(S >= 100000){\n\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t}else if(Double.isNaN(S)){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t}\n\t\t\t\n\t\t\t//なぜかテストケース通らない\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic static double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tdouble EPS=1e-5;\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p1, p2)-slanting(p3, p4))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p3, p4)-slanting(p5, p6))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p5, p6)-slanting(p1, p2))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(Math.abs(x1-x2)<EPS&&Math.abs(y1-y2)<EPS)\n\t\t\t\t\tif(Math.abs(x2-x3)<EPS&&Math.abs(y2-y3)<EPS)\n\t\t\t\t\t\tif(Math.abs(x3-x1)<EPS&&Math.abs(y3-y1)<EPS)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tP[][] ps;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tps=new P[3][2];\n\t\t\tfor(int i=0; i<3; i++){\n\t\t\t\tint x1=sc.nextInt();\n\t\t\t\tint y1=sc.nextInt();\n\t\t\t\tint x2=sc.nextInt();\n\t\t\t\tint y2=sc.nextInt();\n\t\t\t\tps[i][0]=new P(x1, y1);\n\t\t\t\tps[i][1]=new P(x2, y2);\n\t\t\t\tif((x1|y1|x2|y2)==0){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tP[] qs=new P[3];\n\t\tfor(int i=0; i<3; i++){\n\t\t\tif(!crsSS(ps[i][0], ps[i][1], ps[(i+1)%3][0], ps[(i+1)%3][1])){\n\t\t\t\tprintln(\"kyo\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tqs[i]=isLL(ps[i][0], ps[i][1], ps[(i+1)%3][0], ps[(i+1)%3][1]);\n\t\t}\n\t\tdouble[] h=new double[3];\n\t\tfor(int i=0; i<3; i++){\n\t\t\th[i]=qs[i].sub(qs[(i+1)%3]).abs();\n\t\t}\n\t\tdouble s=h[0]+h[1]+h[2];\n\t\tdouble a=Math.sqrt(s*(s-h[0])*(s-h[1])*(s-h[2]));\n\n\t\tif(a+EPS>1900000){\n\t\t\tprintln(\"dai-kichi\");\n\t\t}else if(a+EPS>1000000){\n\t\t\tprintln(\"chu-kichi\");\n\t\t}else if(a+EPS>100000){\n\t\t\tprintln(\"kichi\");\n\t\t}else{\n\t\t\tprintln(\"syo-kichi\");\n\t\t}\n\t}\n\n\tP isLL(P p1, P p2, P q1, P q2){\n\t\tdouble d=q2.sub(q1).det(p2.sub(p1));\n\t\tif(abs(d)<EPS)\n\t\t\treturn null;\n\t\treturn p1.add(p2.sub(p1).mul(q2.sub(q1).det(q1.sub(p1))/d));\n\t}\n\n\tboolean crsSS(P p1, P p2, P q1, P q2){\n\t\tif(max(p1.x, p2.x)+EPS<min(q1.x, q2.x))\n\t\t\treturn false;\n\t\tif(max(q1.x, q2.x)+EPS<min(p1.x, p2.x))\n\t\t\treturn false;\n\t\tif(max(p1.y, p2.y)+EPS<min(q1.y, q2.y))\n\t\t\treturn false;\n\t\tif(max(q1.y, q2.y)+EPS<min(p1.y, p2.y))\n\t\t\treturn false;\n\t\treturn signum(p2.sub(p1).det(q1.sub(p1)))\n\t\t\t\t*signum(p2.sub(p1).det(q2.sub(p1)))<EPS\n\t\t\t\t&&signum(q2.sub(q1).det(p1.sub(q1)))\n\t\t\t\t\t\t*signum(q2.sub(q1).det(p2.sub(q1)))<EPS;\n\t}\n\n\tclass P{\n\t\tdouble x, y;\n\n\t\tP(){\n\t\t\tthis(0, 0);\n\t\t}\n\n\t\tP(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\n\t\tP add(P p){\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p){\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\n\t\tP mul(double m){\n\t\t\treturn new P(x*m, y*m);\n\t\t}\n\n\t\tP div(double d){\n\t\t\treturn new P(x/d, y/d);\n\t\t}\n\n\t\tdouble abs(){\n\t\t\treturn Math.sqrt(abs2());\n\t\t}\n\n\t\tdouble abs2(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\n\t\tdouble arg(){\n\t\t\treturn Math.atan2(y, x);\n\t\t}\n\n\t\t// inner product\n\t\tdouble dot(P p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\n\t\t// outer product\n\t\tdouble det(P p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\n\t\tP rot90(){\n\t\t\treturn new P(-y, x);\n\t\t}\n\n\t\t// conjugation\n\t\tP conj(){\n\t\t\treturn new P(x, -y);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\npublic class Main {\n\t//1442 start\n\t\n\tdouble EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tif((x1|y1|x2|y2) == 0) break;\n\t\t\tLine2D [] list = new Line2D[3];\n\t\t\tlist[0] = new Line2D.Double(x1, y1, x2, y2);\n\t\t\tfor(int i= 1; i < 3; i++){\n\t\t\t\tint xx1 = sc.nextInt();\n\t\t\t\tint yy1 = sc.nextInt();\n\t\t\t\tint xx2 = sc.nextInt();\n\t\t\t\tint yy2 = sc.nextInt();\n\t\t\t\tlist[i] = new Line2D.Double(xx1, yy1, xx2, yy2);\n\t\t\t}\n\t\t\t\n\t\t\tboolean isOK = true;\n\t\t\tPoint2D [] plist = new Point2D[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(list[i].intersectsLine(list[(i+1) % 3])){\n\t\t\t\t\tPoint2D v1 = sub(list[i]);\n\t\t\t\t\tPoint2D v2 = sub(list[(i+1) % 3]);\n\t\t\t\t\tif(Math.abs(cross(v1, v2)) < EPS){\n\t\t\t\t\t\tisOK = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tplist[i] = intersectPtSS(list[i], list[(i+1) % 3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tisOK = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isOK && plist[0].distance(plist[1]) < EPS && plist[0].distance(plist[2]) < EPS) isOK = false;\n\t\t\tif(isOK){\n\t\t\t\tdouble res = area(plist);\n\t\t\t\tif(res < 100000){\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\t}\n\t\t\t\telse if(res < 1000000){\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\t}\n\t\t\t\telse if(res < 1900000){\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate double area(Point2D[] plist) {\n\t\tdouble res = 0;\n\t\tfor(int i = 0; i < plist.length; i++){\n\t\t\tres += cross(plist[i], plist[(i + 1) % plist.length]);\n\t\t}\n\t\treturn Math.abs(res / 2);\n\t}\n\n\tprivate Point2D intersectPtSS(Line2D l, Line2D m) {\n\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\tdouble a = cross(mlv, lv);\n\t\tdouble b = cross(lv, mv);\n\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\tif(l.getP1().distance(m.getP1()) < EPS) return l.getP1();\n\t\t\tif(l.getP1().distance(m.getP2()) < EPS) return l.getP1();\n\t\t\treturn l.getP2();\n\t\t}\n\t\tdouble t = a / b;\n\t\tdouble x = m.getX1() + t * mv.getX();\n\t\tdouble y = m.getY1() + t * mv.getY();\n\t\t\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tprivate Point2D sub(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY(); \n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tprivate double cross(Point2D p1, Point2D p2) {\n\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\treturn res;\n\t}\n\n\tprivate Point2D sub(Line2D l) {\n\t\tdouble x = l.getX1() - l.getX2();\n\t\tdouble y = l.getY1() - l.getY2();\n\t\treturn new Point2D.Double(x,y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tif(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0) break;\n\t\t\tdouble A[] = new double[] {x1,y1};\n\t\t\tdouble B[] = new double[] {x2,y2};\n\t\t\t\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\t\n\t\t\tdouble C[] = new double[] {x3,y3};\n\t\t\tdouble D[] = new double[] {x4,y4};\n\t\t\t\n\t\t\tint x5 = sc.nextInt();\n\t\t\tint y5 = sc.nextInt();\n\t\t\tint x6 = sc.nextInt();\n\t\t\tint y6 = sc.nextInt();\n\t\t\t\n\t\t\tdouble E[] = new double[] {x5,y5};\n\t\t\tdouble F[] = new double[] {x6,y6};\n\t\t\t\n\t\t\tdouble ABCD[] = new double[2];\n\t\t\tdouble ABEF[] = new double[2];\n\t\t\tdouble CDEF[] = new double[2];\n\t\t\t\n\t\t\tint r1 = cross(A,B,C,D,ABCD);\n\t\t\tint r2 = cross(A,B,E,F,ABEF);\n\t\t\tint r3 = cross(C,D,E,F,CDEF);\n\t\t\t\n\t\t\tboolean bad = false;\n\t\t\tif(r1 != 1 || r2 != 1 || r3 != 1) {\n\t\t\t\tbad = true;\n\t\t\t}\n\t\t\tdouble sum = -1;\n\t\t\tif(!bad) {\n\t\t\t\tsum = Math.abs(ABCD[1]*(ABEF[0] - CDEF[0]) + ABEF[1]*(CDEF[0] - ABCD[0]) + CDEF[1]*(ABCD[0] - ABEF[0]))/2.0;\n\t\t\t\tif(sum < 1.0e-9) {\n\t\t\t\t\tbad = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!bad) {\n\t\t\t\tif(sum >= 1900000) {\n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\n\t\t\t\t}\n\t\t\t\telse if(sum >= 1000000) {\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\t}\n\t\t\t\telse if(sum >= 100000) {\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t/*************************************/\n\t/* 2???????????????                       */\n\t/*      A + r(B - A) ??¨ C + s(D - C) */\n\t/*      P : ???????????§?¨?               */\n\t/*      return : =-1 : ???????????????    */\n\t/*               =0 : ????????????????????? */\n\t/*               =1 : ???????????????     */\n\t/*************************************/\n\tstatic int cross(double A[], double B[], double C[], double D[], double P[])\n\t{\n\t\tdouble r, s, AC[] = new double [2], BUNBO, EPS = 1.0e-8;\n\t\tint sw = -1;\n\n\t\tAC[0] = C[0] - A[0];\n\t\tAC[1] = C[1] - A[1];\n\t\tBUNBO = (B[0] - A[0]) * (D[1] - C[1]) - (B[1] - A[1]) * (D[0] - C[0]);\n\t\tif (Math.abs(BUNBO) > EPS) {\n\t\t\tr = ((D[1] - C[1]) * AC[0] - (D[0] - C[0]) * AC[1]) / BUNBO;\n\t\t\ts = ((B[1] - A[1]) * AC[0] - (B[0] - A[0]) * AC[1]) / BUNBO;\n\t\t\tif (r > -EPS && r < 1.0+EPS && s > -EPS && s < 1.0+EPS) {\n\t\t\t\tP[0] = A[0] + r * (B[0] - A[0]);\n\t\t\t\tP[1] = A[1] + r * (B[1] - A[1]);\n\t\t\t\tsw   = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tsw = 0;\n\t\t}\n\n\t\treturn sw;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=0;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-7;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\t//\t\t\tif(Math.abs(slanting(p1, p2)-slanting(p3, p4))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tif(Math.abs(slanting(p3, p4)-slanting(p5, p6))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tif(Math.abs(slanting(p5, p6)-slanting(p1, p2))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\t//System.out.println(x1+\" \"+y1+\" \"+x2+\" \"+y2+\" \"+x3+\" \"+y3);\n//\t\t\t\tif(Math.abs(x1-x2)<EPS&&Math.abs(y1-y2)<EPS)\n//\t\t\t\t\tif(Math.abs(x2-x3)<EPS&&Math.abs(y2-y3)<EPS)\n//\t\t\t\t\t\tif(Math.abs(x3-x1)<EPS&&Math.abs(y3-y1)<EPS)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tSystem.out.println(\"kyo\");\n//\t\t\t\t\t\t\tbreak;\n//\t\t\t\t\t\t}\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\t//System.out.println(a+\" \"+b+\" \"+c+\" \"+d);\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tdouble EPS=1e-8;\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p1, p2)-slanting(p3, p4))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p3, p4)-slanting(p5, p6))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p5, p6)-slanting(p1, p2))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(Math.abs(x1-x2)<EPS&&Math.abs(y1-y2)<EPS)\n\t\t\t\t\tif(Math.abs(x2-x3)<EPS&&Math.abs(y2-y3)<EPS)\n\t\t\t\t\t\tif(Math.abs(x3-x1)<EPS&&Math.abs(y3-y1)<EPS)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-1;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Line2D.Double;\n\npublic class Main {\n\tint[][] p = new int[4][4];\n\tdouble[] x = new double[3];\n\tdouble[] y = new double[3];\n\t\n\tboolean check(int u, int v){\n\t\tint y1 = p[u][1]-p[u][3];\n\t\tint x1 = p[u][0]-p[u][2];\n\t\tint y2 = p[v][1]-p[v][3];\n\t\tint x2 = p[v][0]-p[v][2];\n\t\tLine2D.Double t1 = new Line2D.Double(p[u][0],p[u][1],p[u][2],p[u][3]);\n\t\tLine2D.Double t2 = new Line2D.Double(p[v][0],p[v][1],p[v][2],p[v][3]);\n\t\tif(y1*x2==y2*x1 || !t1.intersectsLine(t2)){\n\t\t\tSystem.out.println(\"kyo\");\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tdouble a, b, c, d;\n\t\tif(x1==0){\n\t\t\tx[u] = p[u][0];\n\t\t\ta = (double)y2/x2;\n\t\t\tb = p[v][1] - a*p[v][0];\n\t\t\ty[u] = a*x[u]+b;\n\t\t}else if(x2==0){\n\t\t\tx[u] = p[v][0];\n\t\t\ta = (double)y1/x1;\n\t\t\tb = p[u][1] - a*p[u][0];\n\t\t\ty[u] = a*x[u]+b;\n\t\t}else{\n\t\t\ta = (double)y1/x1;\n\t\t\tb = p[u][1] - a*p[u][0];\n\t\t\tc = (double)y2/x2; \n\t\t\td = p[v][1] - a*p[v][0];\n\t\t\tx[u] = (d-b)/(a-c);\n\t\t\ty[u] = (a*d-b*c)/(a-c);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfor(int i=0;i<4;i++) p[0][i] = sc.nextInt();\n\t\t\tif(p[0][0]==0 && p[0][1]==0 && p[0][2]==0 && p[0][3]==0) break;\n\t\t\tfor(int i=0;i<4;i++) p[1][i] = sc.nextInt();\n\t\t\tfor(int i=0;i<4;i++) p[2][i] = sc.nextInt();\n\t\t\tif(check(0,1)) continue;\n\t\t\tif(check(1,2)) continue;\n\t\t\tif(check(2,0)) continue;\n\t\t\tdouble sum = Math.abs((x[1]-x[0])*(y[2]-y[0])-(y[1]-y[0])*(x[2]-x[1]))/2;\n\t\t\tString ans = \"kyo\";\n\t\t\tif(sum>=1900000) ans = \"dai-kichi\";\n\t\t\telse if(sum>=1000000) ans = \"chu-kichi\";\n\t\t\telse if(sum>=100000) ans = \"kichi\";\n\t\t\telse if(sum>=0) ans = \"syo-kichi\";\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-7;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\t//\t\t\tif(Math.abs(slanting(p1, p2)-slanting(p3, p4))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tif(Math.abs(slanting(p3, p4)-slanting(p5, p6))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tif(Math.abs(slanting(p5, p6)-slanting(p1, p2))<EPS)\n\t\t\t//\t\t\t\tjudge=false;\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\t//System.out.println(x1+\" \"+y1+\" \"+x2+\" \"+y2+\" \"+x3+\" \"+y3);\n\t\t\t\tif(Math.abs(x1-x2)<EPS&&Math.abs(y1-y2)<EPS)\n\t\t\t\t\tif(Math.abs(x2-x3)<EPS&&Math.abs(y2-y3)<EPS)\n\t\t\t\t\t\tif(Math.abs(x3-x1)<EPS&&Math.abs(y3-y1)<EPS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\t//System.out.println(a+\" \"+b+\" \"+c+\" \"+d);\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tdouble EPS=1e-9;\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p1, p2)-slanting(p3, p4))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p3, p4)-slanting(p5, p6))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p5, p6)-slanting(p1, p2))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(Math.abs(x1-x2)<EPS&&Math.abs(y1-y2)<EPS)\n\t\t\t\t\tif(Math.abs(x2-x3)<EPS&&Math.abs(y2-y3)<EPS)\n\t\t\t\t\t\tif(Math.abs(x3-x1)<EPS&&Math.abs(y3-y1)<EPS)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tdouble EPS=1e-7;\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p1, p2)-slanting(p3, p4))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p3, p4)-slanting(p5, p6))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p5, p6)-slanting(p1, p2))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(Math.abs(x1-x2)<EPS&&Math.abs(y1-y2)<EPS)\n\t\t\t\t\tif(Math.abs(x2-x3)<EPS&&Math.abs(y2-y3)<EPS)\n\t\t\t\t\t\tif(Math.abs(x3-x1)<EPS&&Math.abs(y3-y1)<EPS)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Stoning Fortune\npublic class Main{\n\n\tstatic class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tstatic class Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tstatic Point crosspoint(Line l, Line m) {\n\t\tif(isParallel(l, m)){\n\t\t\treturn null;\n\t\t}\n\t\t  double A = extp(sub(l.t, l.s), sub(m.t, m.s));\n\t\t  double B = extp(sub(l.t, l.s), sub(l.t, m.s));\n\t\t  if (Math.abs(A) < EPS && Math.abs(B) < EPS) return m.s; // same line\n\t\t  if (Math.abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\t  Point tp = sub(m.t, m.s);\n\t\t  return new Point(m.s.x + B/A*tp.x, m.s.y + B/A*tp.y);\n\t}\n\tstatic boolean isParallel(Line l, Line m){\n\t\tPoint a = new Point(l.t.x - l.s.x, l.t.y - l.s.y);\n\t\tPoint b = new Point(m.t.x - m.s.x, m.t.y - m.s.y);\n\t\tif(Math.abs(Math.abs((a.x*b.x + a.y*b.y)/(Math.hypot(a.x, a.y)*Math.hypot(b.x, b.y)) - 1)) < EPS){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tstatic final double EPS = 1.0e-8;\n\tstatic Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tstatic double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tstatic boolean intersectSS(Line s, Line t) {\n\t\treturn ccw(s.s,s.t,t.s)*ccw(s.s,s.t,t.t) <= 0 &&\n\t\t       ccw(t.s,t.t,s.s)*ccw(t.s,t.t,s.t) <= 0;\n\t}\n\tstatic int ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line\n\t}\n\tstatic double inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tstatic double norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tdouble x1 = sc.nextDouble();\n\t\t\tdouble y1 = sc.nextDouble();\n\t\t\tdouble x2 = sc.nextDouble();\n\t\t\tdouble y2 = sc.nextDouble();\n\t\t\tif(x1==0&&y1==0&&x2==0&&y2==0)break;\n\t\t\tLine[] l = new Line[3];\n\t\t\tl[0] = new Line(new Point(x1, y1), new Point(x2, y2));\n\t\t\tfor(int i=1;i<3;i++)l[i]=new Line(new Point(sc.nextDouble(),sc.nextDouble()), new Point(sc.nextDouble(), sc.nextDouble()));\n\t\t\tPoint[] c = new Point[3];\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tc[i] = crosspoint(l[i], l[(i+1)%3]);\n\t\t\t\tif(c[i]==null || !intersectSS(l[i], l[(i+1)%3]))f = false;\n\t\t\t}\n\t\t\tString ans = \"\";\n\t\t\tif(!f)ans = \"kyo\";\n\t\t\telse{\n\t\t\t\tdouble a = 0;\n\t\t\t\tfor(int i=0;i<3;i++)a+=c[i].x*c[(i+1)%3].y-c[i].y*c[(i+1)%3].x;\n\t\t\t\ta = Math.abs(a/2);\n\t\t\t\tif(1900000<=a)ans = \"dai-kichi\";\n\t\t\t\telse if(1000000<=a)ans = \"chu-kichi\";\n\t\t\t\telse if(100000<=a)ans = \"kichi\";\n\t\t\t\telse if(0<a)ans = \"syo-kichi\";\n\t\t\t\telse ans = \"kyo\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tif ((x1 | y1 | x2 | y2) == 0)\n\t\t\t\tbreak;\n\t\t\tTSegment s1 = new TSegment(new TPoint(x1, y1), new TPoint(x2, y2));\n\t\t\tx1 = sc.nextInt();\n\t\t\ty1 = sc.nextInt();\n\t\t\tx2 = sc.nextInt();\n\t\t\ty2 = sc.nextInt();\n\t\t\tTSegment s2 = new TSegment(new TPoint(x1, y1), new TPoint(x2, y2));\n\t\t\tx1 = sc.nextInt();\n\t\t\ty1 = sc.nextInt();\n\t\t\tx2 = sc.nextInt();\n\t\t\ty2 = sc.nextInt();\n\t\t\tTSegment s3 = new TSegment(new TPoint(x1, y1), new TPoint(x2, y2));\n\t\t\tTPoint A = new TPoint();\n\t\t\tTPoint B = new TPoint();\n\t\t\tTPoint C = new TPoint();\n\t\t\tboolean flag = true;\n\t\t\tif (s1.calcIntersection(A, s2) == 0)\n\t\t\t\tflag = false;\n\t\t\tif (s2.calcIntersection(B, s3) == 0)\n\t\t\t\tflag = false;\n\t\t\tif (s1.calcIntersection(C, s3) == 0)\n\t\t\t\tflag = false;\n\t\t\t// 線分の交点を頂点とする三角形の面積 運勢\n\t\t\t// 1,900,000以上 大吉 (dai-kichi)\n\t\t\t// 1,000,000以上1,900,000未満 中吉 (chu-kichi)\n\t\t\t// 100,000以上1,000,000未満 吉 (kichi)\n\t\t\t// 0より大きく 100,000未満 小吉 (syo-kichi)\n\t\t\t// 三角形なし 凶 (kyo)\n\t\t\tif (flag) {\n\t\t\t\tdouble area = calcArea(A, B, C);\n\t\t\t\tif (area >= 1900000)\n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\n\t\t\t\telse if (area >= 1000000 && area < 1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse if (area >= 100000 && area < 1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if (area > 0 && area < 100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double calcArea(TPoint A, TPoint B, TPoint C) {\n\t\treturn Math.abs((B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y)) / 2.0;\n\t}\n}\n\nclass TPoint {\n\n\tdouble x, y;\n\n\tpublic TPoint(TPoint poi) {\n\t\tx = poi.x;\n\t\ty = poi.y;\n\t}\n\n\tpublic TPoint() {\n\t};\n\n\tpublic TPoint(double _x, double _y) {\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\n\tvoid set(double _x, double _y) {\n\t\tx = _x;\n\t\ty = _y;\n\t}\n\n\t// 仮の距離を計算する\n\tstatic double fdist(TPoint p1, TPoint p2) {\n\n\t\treturn (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n\t}\n\n\tpublic void print(PrintStream os) {\n\n\t\tos.print(\"(\" + x + \",\" + y + \")\");\n\t}\n\n\tpublic void read(DataInputStream is) throws IOException {\n\n\t\tx = is.readDouble();\n\t\ty = is.readDouble();\n\t}\n\n}\n\n/**\n * 直線を管理するクラス\n *\n */\n\nclass TLine {\n\n\tdouble a, b, c;\n\n\tTLine(double _a, double _b, double _c) {\n\t\ta = _a;\n\t\tb = _b;\n\t\tc = _c;\n\t}\n\n\tTLine() {\n\t}\n\n\tTLine(TPoint p1, TPoint p2) {\n\n\t\tassign(p1, p2);\n\t}\n\n\tTLine(TPoint p1, double dx, double dy) {\n\n\t\tassign(p1, dx, dy);\n\t}\n\n\t// 2点を通る直線を計算する\n\tpublic void assign(TPoint p1, TPoint p2) {\n\n\t\ta = p2.y - p1.y;\n\t\tb = p1.x - p2.x;\n\t\tc = p2.x * p1.y - p1.x * p2.y;\n\n\t}\n\n\t// 1点と傾きが与えられたときの直線を計算する\n\tpublic void assign(TPoint p1, double dx, double dy) {\n\n\t\ta = dy;\n\t\tb = -dx;\n\t\tc = p1.y * dx - p1.x * dy;\n\n\t}\n\n\t// 直線同士の交点を求める\n\tpublic int calcIntersection(TPoint p1, TLine li) {\n\n\t\tdouble D = a * li.b - li.a * b;\n\n\t\tif (D == 0)\n\t\t\treturn 0;\n\n\t\tp1.x = (b * li.c - li.b * c) / D;\n\t\tp1.y = (li.a * c - a * li.c) / D;\n\n\t\treturn 1;\n\t}\n\n\t// 傾きに逆変換する\n\tpublic void getKata(double d[]) {\n\n\t\td[0] = -b;\n\t\td[1] = a;\n\t}\n\n\t// 表示する\n\tpublic void print(PrintStream os) {\n\n\t\tos.print(\"(\" + a + \",\" + b + \",\" + c + \")\");\n\t}\n}\n\nclass TSegment {\n\n\tTPoint p1, p2;\n\n\tTSegment(TPoint p1_, TPoint p2_) {\n\n\t\tassign(p1_, p2_);\n\t}\n\n\tpublic void assign(TPoint p1_, TPoint p2_) {\n\n\t\tp1 = new TPoint(p1_);\n\t\tp2 = new TPoint(p2_);\n\t}\n\n\t// 線分と直線の交点を求める\n\tpublic int calcIntersection(TPoint p3, TLine li) {\n\n\t\tif (li.calcIntersection(p3, new TLine(p1, p2)) > 0) {\n\n\t\t\t// 誤差をさけるため\n\t\t\tif (Math.abs(p1.x - p2.x) > Math.abs(p1.y - p2.y)) {\n\n\t\t\t\tif (Math.min(p1.x, p2.x) <= p3.x\n\t\t\t\t\t\t&& p3.x <= Math.max(p1.x, p2.x))\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tif (Math.min(p1.y, p2.y) <= p3.y\n\t\t\t\t\t\t&& p3.y <= Math.max(p1.y, p2.y))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t// 線分同士の交点を求める\n\tpublic int calcIntersection(TPoint p3, TSegment li) {\n\n\t\tif (li.calcIntersection(p3, new TLine(p1, p2)) > 0) {\n\n\t\t\t// 誤差をさけるため\n\t\t\tif (Math.abs(p1.x - p2.x) > Math.abs(p1.y - p2.y)) {\n\n\t\t\t\tif (Math.min(p1.x, p2.x) <= p3.x\n\t\t\t\t\t\t&& p3.x <= Math.max(p1.x, p2.x))\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tif (Math.min(p1.y, p2.y) <= p3.y\n\t\t\t\t\t\t&& p3.y <= Math.max(p1.y, p2.y))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t// 直線上での反射を計算する\n\tpublic void reflect(double d[]) {\n\n\t\t// 回転する\n\t\tdouble theta = -Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\tdouble dx2 = d[0] * Math.cos(theta) - d[1] * Math.sin(theta);\n\t\tdouble dy2 = d[0] * Math.sin(theta) + d[1] * Math.cos(theta);\n\n\t\t// 反射処理\n\t\tdy2 = -dy2;\n\n\t\t// 逆回転\n\t\td[0] = dx2 * Math.cos(-theta) - dy2 * Math.sin(-theta);\n\t\td[1] = dx2 * Math.sin(-theta) + dy2 * Math.cos(-theta);\n\t}\n\n\t// 表示する\n\tpublic void print(PrintStream os) {\n\n\t\tp1.print(os);\n\t\tos.print(\"-\");\n\t\tp2.print(os);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-4;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.abs;\nimport static java.lang.Math.atan2;\nimport static java.lang.Math.sqrt;\nimport static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tg:\n\t\tfor (;sc.hasNext();) {\n\t\t\tP[] ps = new P[6];\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tps[i] = new P(x, y);\n\t\t\t\tif (i == 1 && ps[0].x == 0 && ps[0].y == 0 && x == 0 && y == 0) break g;\n\t\t\t}\n\t\t\t\n\t\t\tdouble area = solve(ps);\n\t\t\t\n\t\t\tString ans;\n\t\t\tif (area < EPS) { ans = \"kyo\"; }\n\t\t\telse if (area < 100000 - EPS) { ans = \"syo-kichi\"; }\n\t\t\telse if (area < 1000000 - EPS) { ans = \"kichi\"; }\n\t\t\telse if (area < 1900000 - EPS) { ans = \"chu-kichi\"; }\n\t\t\telse { ans = \"dai-kichi\"; }\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tdouble solve(P[] ps) {\n\n\t\tP p1 = intersectionSS(ps[0], ps[1], ps[2], ps[3]);\n\t\tP p2 = intersectionSS(ps[2], ps[3], ps[4], ps[5]);\n\t\tP p3 = intersectionSS(ps[4], ps[5], ps[0], ps[1]);\n\t\tif (p1 == null || p2 == null || p3 == null) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn area(new P[]{p1, p2, p3});\n\t}\n\n\tdouble area(P[] v) {\n\t\tdouble ret = 0.0;\n\t\tint n = v.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret += v[i].det(v[(i + 1) % n]);\n\t\t}\n\t\treturn abs(ret / 2.0);\n\t}\n\t\n\tP intersectionSS(P a1, P a2, P b1, P b2) {\n\t\tif (isIntersectSS(a1, a2, b1, b2)) {\n\t\t\treturn intersectionLL(a1, a2, b1, b2);\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tfinal double EPS = 1e-10;\n\n\tstatic class P implements Comparable<P> {\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn x != o.x ? Double.compare(x, o.x) : Double.compare(y, o.y);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t\tpublic double abs() {return sqrt(x * x + y * y); }\n\t\tpublic double abs2() {return (x * x + y * y); }\n\t\tpublic double arg() { return atan2(y, x); } // (-pi ? pi)\n\t\tpublic double dist(P o) {return this.sub(o).abs(); }\n\t\tpublic P mul(double k) {return new P(x * k, y * k);}\n\t\tpublic P div(double k) {return new P(x / k, y / k);}\n\t\tpublic P add(P o) {return new P(x + o.x, y + o.y);}\n\t\tpublic P sub(P o) {return new P(x - o.x, y - o.y);}\n\t\tpublic P mul(P o) {return new P(x * o.x - y * o.y,  x * o.y + y * o.x); }\n\t\tpublic P div(P o) {return new P(x * o.x + y * o.y, -x * o.y + y * o.x).div(o.abs2()); }\n\t\tpublic double dot(P o) {return x * o.x + y * o.y;} // a b sin(t)\n\t\tpublic double det(P o) {return x * o.y - y * o.x;} // a b cos(t)\n\t\tpublic P normal() { return this.div(this.abs()); }\n\t\tpublic P rot90() { return new P(-y, x); }\n\t\tpublic static P polar(double d, double rad) {return new P(d * Math.cos(rad), d * Math.sin(rad));}\n\t}\n\tint ccw(P a, P b, P c) {\n\t\tdouble cross = (b.sub(a)).det(c.sub(a));\n\t\tif (cross > EPS) return +1;\n\t\tif (cross < EPS) return -1;\n\t\treturn 0;\n\t}\n\tboolean isIntersectSS(P a1, P a2, P b1, P b2) {\n\t\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 && ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n\t}\n\tP intersectionLL(P a1, P a2, P b1, P b2) {\n\t\tP a = a2.sub(a1);\n\t\tP b = b2.sub(b1);\n\t\treturn a1.add(a.mul(b.det(b1.sub(a1))).div(b.det(a)));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\t\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\tif(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[][] lines = new Point2D[3][2];\n\t\t\t\n\t\t\tlines[0][0] = new Point2D(x1, y1);\n\t\t\tlines[0][1] = new Point2D(x2, y2);\n\t\t\tlines[1][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[1][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\t\n\t\t\tPoint2D[] crosses = new Point2D[3];\n\t\t\tboolean not_found = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(Point2D.intersect_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1])){\n\t\t\t\t\tcrosses[i] = Point2D.interpoint_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1]);\n\t\t\t\t}else{\n\t\t\t\t\tcrosses[i] = null;\n\t\t\t\t\tnot_found = true;\n\t\t\t\t}\n\t\t\t\t//System.out.println(crosses[i]);\n\t\t\t}\n\t\t\t\n\t\t\tif(not_found){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tboolean same = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(crosses[i].equals(crosses[i + 1 >= 3 ? 0 : (i + 1)])){\n\t\t\t\t\tsame = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(same){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble S = Point2D.area(crosses[0], crosses[1], crosses[2]);\n\t\t\t//System.out.println(S);\n\t\t\tif(S >= 1900000){\n\t\t\t\tSystem.out.println(\"dai-kichi\");\n\t\t\t}else if(S >= 1000000){\n\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t}else if(S >= 100000){\n\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t}else if(Double.isNaN(S)){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"sho-kichi\");\n\t\t\t}\n\t\t\t\n\t\t\t//なぜかテストケース通らない\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic static double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-7;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p1, p2)-slanting(p3, p4))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p3, p4)-slanting(p5, p6))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(Math.abs(slanting(p5, p6)-slanting(p1, p2))<EPS)\n\t\t\t\tjudge=false;\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\t\t\t\t\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\t\t\t\t\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\t\t\t\t\n\t\t\t\tif(Math.abs(x1-x2)<EPS&&Math.abs(y1-y2)<EPS)\n\t\t\t\t\tif(Math.abs(x2-x3)<EPS&&Math.abs(y2-y3)<EPS)\n\t\t\t\t\t\tif(Math.abs(x3-x1)<EPS&&Math.abs(y3-y1)<EPS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\t//System.out.println(a+\" \"+b+\" \"+c+\" \"+d);\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\t//System.out.println(S);\n\t\t\t\tif(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic\tdouble EPS=1e-2;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tdouble a=x2-x1;\n\t\t\t\tdouble b=y2-y1;\n\t\t\t\tdouble c=x3-x1;\n\t\t\t\tdouble d=y3-y1;\n\t\t\t\tdouble S=Math.abs(a*d-b*c)/2;\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\t\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\tif(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[][] lines = new Point2D[3][2];\n\t\t\t\n\t\t\tlines[0][0] = new Point2D(x1, y1);\n\t\t\tlines[0][1] = new Point2D(x2, y2);\n\t\t\tlines[1][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[1][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\t\n\t\t\tPoint2D[] crosses = new Point2D[3];\n\t\t\tboolean not_found = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(Point2D.intersect_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1])){\n\t\t\t\t\tcrosses[i] = Point2D.interpoint_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1]);\n\t\t\t\t}else{\n\t\t\t\t\tcrosses[i] = null;\n\t\t\t\t\tnot_found = true;\n\t\t\t\t}\n\t\t\t\t//System.out.println(crosses[i]);\n\t\t\t}\n\t\t\t\n\t\t\tif(not_found){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tboolean same = true;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(!crosses[i].equals(crosses[i + 1 >= 3 ? 0 : (i + 1)])){\n\t\t\t\t\tsame = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(same){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble S = Point2D.area(crosses[0], crosses[1], crosses[2]);\n\t\t\t//System.out.println(S);\n\t\t\tif(S >= 1900000){\n\t\t\t\tSystem.out.println(\"dai-kichi\");\n\t\t\t}else if(S >= 1000000){\n\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t}else if(S >= 100000){\n\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t}else if(Double.isNaN(S)){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"sho-kichi\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic static double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\t\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\tif(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[][] lines = new Point2D[3][2];\n\t\t\t\n\t\t\tlines[0][0] = new Point2D(x1, y1);\n\t\t\tlines[0][1] = new Point2D(x2, y2);\n\t\t\tlines[1][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[1][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][0] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tlines[2][1] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\t\n\t\t\tPoint2D[] crosses = new Point2D[3];\n\t\t\tboolean not_found = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(Point2D.intersect_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1])){\n\t\t\t\t\tcrosses[i] = Point2D.interpoint_s(lines[i][0], lines[i][1], lines[i + 1 >= 3 ? 0 : (i + 1)][0], lines[i + 1 >= 3 ? 0 : (i + 1)][1]);\n\t\t\t\t}else{\n\t\t\t\t\tcrosses[i] = null;\n\t\t\t\t\tnot_found = true;\n\t\t\t\t}\n\t\t\t\t//System.out.println(crosses[i]);\n\t\t\t}\n\t\t\t\n\t\t\tif(not_found){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tboolean same = true;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(!crosses[i].equals(crosses[i + 1 >= 3 ? 0 : (i + 1)])){\n\t\t\t\t\tsame = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(same){\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble S = Point2D.area(crosses[0], crosses[1], crosses[2]);\n\t\t\tif(S >= 1900000){\n\t\t\t\tSystem.out.println(\"dai-kichi\");\n\t\t\t}else if(S >= 1000000){\n\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t}else if(S >= 100000){\n\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"sho-kichi\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\tif (this.x - EPS < another.x && this.x + EPS > another.x\n\t\t\t\t\t&& this.y - EPS < another.y && this.y + EPS > another.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\n\t\t\t// return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Point2D add(double x, double y) {\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\n\tpublic Point2D sub(double x, double y) {\n\t\treturn add(-x, -y);\n\t}\n\n\tpublic Point2D add(Point2D another) {\n\t\treturn add(another.x, another.y);\n\t}\n\n\tpublic Point2D sub(Point2D another) {\n\t\treturn sub(another.x, another.y);\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\n\tpublic Point2D div(double d) {\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\n\tpublic double dot(double x, double y) {\n\t\treturn this.x * x + this.y * y;\n\t}\n\n\tpublic double dot(Point2D another) {\n\t\treturn dot(another.x, another.y);\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn cross(another.x, another.y);\n\t}\n\n\tpublic double dist(double x, double y) {\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t* (this.y - y));\n\t}\n\n\tpublic double dist(Point2D another) {\n\t\treturn dist(another.x, another.y);\n\t}\n\n\tpublic double dist_o() {\n\t\treturn dist(0, 0);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn div(dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS)\n\t\t\t\t&& (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic static double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main\n{\n\tstatic\tdouble EPS=1e-5;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint p1=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p2=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tif(p1.x==0&&p1.y==0&&p2.x==0&&p2.y==0)\n\t\t\t\treturn;\n\t\t\tPoint p3=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p4=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p5=new Point(in.nextDouble(), in.nextDouble()); \n\t\t\tPoint p6=new Point(in.nextDouble(), in.nextDouble());\n\t\t\tboolean judge=true;\n\t\t\tif(!lineCross(p1, p2, p3, p4))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p3, p4, p5, p6))\n\t\t\t\tjudge=false;\n\t\t\tif(!lineCross(p5, p6, p1, p2))\n\t\t\t\tjudge=false;\n\n\t\t\tif(judge)\n\t\t\t{\n\t\t\t\tdouble a1=slanting(p1, p2);\n\t\t\t\tdouble a2=slanting(p3, p4);\n\t\t\t\tdouble x1=(a1*p1.x-p1.y-a2*p3.x+p3.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx1=p1.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx1=p3.x;\n\t\t\t\tdouble y1=(p2.y-p1.y)/(p2.x-p1.x)*(x1-p1.x)+p1.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty1=(p4.y-p3.y)/(p4.x-p3.x)*(x1-p3.x)+p3.y;\n\n\t\t\t\ta1=slanting(p3, p4);\n\t\t\t\ta2=slanting(p5, p6);\n\t\t\t\tdouble x2=(a1*p3.x-p3.y-a2*p5.x+p5.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx2=p3.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx2=p5.x;\n\t\t\t\tdouble y2=(p4.y-p3.y)/(p4.x-p3.x)*(x2-p3.x)+p3.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty2=(p5.y-p6.y)/(p5.x-p6.x)*(x2-p5.x)+p5.y;\n\n\t\t\t\ta1=slanting(p5, p6);\n\t\t\t\ta2=slanting(p1, p2);\n\t\t\t\tdouble x3=(a1*p5.x-p5.y-a2*p1.x+p1.y)/(a1-a2);\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\tx3=p5.x;\n\t\t\t\telse if(a2==-1.123)\n\t\t\t\t\tx3=p1.x;\n\t\t\t\tdouble y3=(p6.y-p5.y)/(p6.x-p5.x)*(x3-p5.x)+p5.y;\n\t\t\t\tif(a1==-1.123)\n\t\t\t\t\ty3=(p2.y-p1.y)/(p2.x-p1.x)*(x3-p1.x)+p1.y;\n\n\t\t\t\tPoint a=new Point(x1, y1);\n\t\t\t\tPoint b=new Point(x2, y2);\n\t\t\t\tPoint c=new Point(x3, y3);\n\t\t\t\tdouble S=triangleArea(a, b, c);\n\t\t\t\t\n\t\t\t\tif(S<EPS)\n\t\t\t\t\tSystem.out.println(\"kyo\");\n\t\t\t\telse if(S<100000)\n\t\t\t\t\tSystem.out.println(\"syo-kichi\");\n\t\t\t\telse if(S<1000000)\n\t\t\t\t\tSystem.out.println(\"kichi\");\n\t\t\t\telse if(S<1900000)\n\t\t\t\t\tSystem.out.println(\"chu-kichi\");\n\t\t\t\telse \n\t\t\t\t\tSystem.out.println(\"dai-kichi\");\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(\"kyo\");\n\t\t}\n\t}\n\n\tstatic boolean lineCross(Point p1,Point p2,Point p3,Point p4)\n\t{\n\t\tdouble jc1=(p1.x-p2.x)*(p3.y-p1.y)+(p1.y-p2.y)*(p1.x-p3.x);\n\t\tdouble jd1=(p1.x-p2.x)*(p4.y-p1.y)+(p1.y-p2.y)*(p1.x-p4.x);\n\t\tdouble jc2=(p3.x-p4.x)*(p1.y-p3.y)+(p3.y-p4.y)*(p3.x-p1.x);\n\t\tdouble jd2=(p3.x-p4.x)*(p2.y-p3.y)+(p3.y-p4.y)*(p3.x-p2.x);\n\t\treturn jc1*jd1<=0 && jc2*jd2<=0;\n\t}\n\n\tstatic double slanting(Point p1,Point p2)\n\t{\n\t\tif(Math.abs(p1.x-p2.x)<EPS)\n\t\t\treturn -1.123;\n\t\telse\n\t\t\treturn (p1.y-p2.y)/(p1.x-p2.x);\n\t}\n\t//3頂点からなる三角形の面積\n\tstatic double triangleArea(Point p1,Point p2,Point p3)\n\t{\n\t\treturn Math.abs((p3.y-p1.y)*(p2.x-p1.x)-(p2.y-p1.y)*(p3.x-p1.x))/2;\n\t}\n}\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.All(x => x == 0)) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = ls1[2] - ls1[0] == 0 ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = ls2[2] - ls2[0] == 0 ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = ls3[2] - ls3[0] == 0 ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((Math.Abs(p1x - p2x) < EPS && Math.Abs(p1y - p2y) < EPS) ||\n                        (Math.Abs(p2x - p3x) < EPS && Math.Abs(p2y - p3y) < EPS) ||\n                        (Math.Abs(p3x - p1x) < EPS && Math.Abs(p3y - p1y) < EPS))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2.0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = int.MinValue;\n            py = int.MinValue;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else Console.WriteLine(\"syo-kichi\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2D;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((Math.Abs(p1x - p2x) < EPS && Math.Abs(p1y - p2y) < EPS) ||\n                        (Math.Abs(p2x - p3x) < EPS && Math.Abs(p2y - p3y) < EPS) ||\n                        (Math.Abs(p3x - p1x) < EPS && Math.Abs(p3y - p1y) < EPS))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2.0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else Console.WriteLine(\"syo-kichi\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else Console.WriteLine(\"syo-kichi\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) <= 0) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) <= 0))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((Math.Abs(p1x - p2x) < EPS && Math.Abs(p1y - p2y) < EPS) ||\n                        (Math.Abs(p2x - p3x) < EPS && Math.Abs(p2y - p3y) < EPS) ||\n                        (Math.Abs(p3x - p1x) < EPS && Math.Abs(p3y - p1y) < EPS))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2.0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-8;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2D;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                        (p2x == p3x && p2y == p3y) ||\n                        (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2D;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2D;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                //double slope1 = ls1[2] - ls1[0] == 0? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                //double slope2 = ls2[2] - ls2[0] == 0? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                //double slope3 = ls3[2] - ls3[0] == 0? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                //if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                //{\n                //    Console.WriteLine(\"kyo\");\n                //    continue;\n                //}\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((Math.Abs(p1x - p2x) < EPS && Math.Abs(p1y - p2y) < EPS) ||\n                        (Math.Abs(p2x - p3x) < EPS && Math.Abs(p2y - p3y) < EPS) ||\n                        (Math.Abs(p3x - p1x) < EPS && Math.Abs(p3y - p1y) < EPS))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2.0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else Console.WriteLine(\"syo-kichi\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) <= 0) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) <= 0))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else Console.WriteLine(\"syo-kichi\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 0) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 0))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else Console.WriteLine(\"syo-kichi\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                        (p2x == p3x && p2y == p3y) ||\n                        (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2.0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = Math.Abs(ls1[2] - ls1[0]) < EPS ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = Math.Abs(ls2[2] - ls2[0]) < EPS ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = Math.Abs(ls3[2] - ls3[0]) < EPS ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((Math.Abs(p1x - p2x) < EPS && Math.Abs(p1y - p2y) < EPS) ||\n                        (Math.Abs(p2x - p3x) < EPS && Math.Abs(p2y - p3y) < EPS) ||\n                        (Math.Abs(p3x - p1x) < EPS && Math.Abs(p3y - p1y) < EPS))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2.0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = ls1[2] - ls1[0] == 0 ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = ls2[2] - ls2[0] == 0 ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = ls3[2] - ls3[0] == 0 ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((Math.Abs(p1x - p2x) < EPS && Math.Abs(p1y - p2y) < EPS) ||\n                        (Math.Abs(p2x - p3x) < EPS && Math.Abs(p2y - p3y) < EPS) ||\n                        (Math.Abs(p3x - p1x) < EPS && Math.Abs(p3y - p1y) < EPS))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2.0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public const double EPS = 1e-10;\n\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = ls1[2] - ls1[0] == 0 ? int.MaxValue : (ls1[3] - ls1[1]) / (double)(ls1[2] - ls1[0]);\n                double slope2 = ls2[2] - ls2[0] == 0 ? int.MaxValue : (ls2[3] - ls2[1]) / (double)(ls2[2] - ls2[0]);\n                double slope3 = ls3[2] - ls3[0] == 0 ? int.MaxValue : (ls3[3] - ls3[1]) / (double)(ls3[2] - ls3[0]);\n\n                if (Math.Abs(slope1 - slope2) < EPS || Math.Abs(slope2 - slope3) < EPS || Math.Abs(slope3 - slope1) < EPS)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((Math.Abs(p1x - p2x) < EPS && Math.Abs(p1y - p2y) < EPS) ||\n                        (Math.Abs(p2x - p3x) < EPS && Math.Abs(p2y - p3y) < EPS) ||\n                        (Math.Abs(p3x - p1x) < EPS && Math.Abs(p3y - p1y) < EPS))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else if (area > 0) Console.WriteLine(\"syo-kichi\");\n                        else Console.WriteLine(\"kyo\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2.0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = int.MinValue;\n            py = int.MinValue;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = (ls1[3] - ls1[1]) / (ls1[2] - ls1[0]);\n                double slope2 = (ls2[3] - ls2[1]) / (ls2[2] - ls2[0]);\n                double slope3 = (ls3[3] - ls3[1]) / (ls3[2] - ls3[0]);\n\n                if(slope1 == slope2 || slope2 == slope3 || slope3 == slope1)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else Console.WriteLine(\"syo-kichi\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) <= 0) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) <= 0))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0187\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] ls1 = RIntAr(); if (ls1.Sum() == 0) break;\n                int[] ls2 = RIntAr();\n                int[] ls3 = RIntAr();\n\n                double p1x, p1y, p2x, p2y, p3x, p3y;\n\n                double slope1 = (ls1[2] - ls1[0]) == 0 ? int.MaxValue : (ls1[3] - ls1[1]) / (ls1[2] - ls1[0]);\n                double slope2 = (ls2[2] - ls2[0]) == 0 ? int.MaxValue : (ls2[3] - ls2[1]) / (ls2[2] - ls2[0]);\n                double slope3 = (ls3[2] - ls3[0]) == 0 ? int.MaxValue : (ls3[3] - ls3[1]) / (ls3[2] - ls3[0]);\n\n                if (slope1 == slope2 || slope2 == slope3 || slope3 == slope1)\n                {\n                    Console.WriteLine(\"kyo\");\n                    continue;\n                }\n\n                bool isCross12 = Vector.IsLineSegmentCrossed(ls1[0], ls1[1], ls1[2], ls1[3], ls2[0], ls2[1], ls2[2], ls2[3], out p1x, out p1y);\n                bool isCross23 = Vector.IsLineSegmentCrossed(ls2[0], ls2[1], ls2[2], ls2[3], ls3[0], ls3[1], ls3[2], ls3[3], out p2x, out p2y);\n                bool isCross31 = Vector.IsLineSegmentCrossed(ls3[0], ls3[1], ls3[2], ls3[3], ls1[0], ls1[1], ls1[2], ls1[3], out p3x, out p3y);\n\n                if (!isCross12 || !isCross23 || !isCross31)\n                {\n                    Console.WriteLine(\"kyo\");\n                }\n                else\n                {\n                    if ((p1x == p2x && p1y == p2y) ||\n                       (p2x == p3x && p2y == p3y) ||\n                       (p3x == p1x && p3y == p1y))\n                    {\n                        Console.WriteLine(\"kyo\");\n                    }\n                    else\n                    {\n\n                        double area = CalcTriangleArea(p1x, p1y, p2x, p2y, p3x, p3y);\n\n                        if (area >= 1900000) Console.WriteLine(\"dai-kichi\");\n                        else if (area >= 1000000) Console.WriteLine(\"chu-kichi\");\n                        else if (area >= 100000) Console.WriteLine(\"kichi\");\n                        else Console.WriteLine(\"syo-kichi\");\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// 3点に囲まれた三角形の面積を求める\n        /// </summary>\n        /// <param name=\"p1x\">p1のx座標</param>\n        /// <param name=\"p1y\">p1のy座標</param>\n        /// <param name=\"p2x\">p2のx座標</param>\n        /// <param name=\"p2y\">p2のy座標</param>\n        /// <param name=\"p3x\">p3のx座標</param>\n        /// <param name=\"p3y\">p3のy座標</param>\n        /// <returns>三角形の面積</returns>\n        public static double CalcTriangleArea(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y)\n        {\n            return Math.Abs((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y)) / 2;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) <= 0) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) <= 0))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};0<s&&s<=1&&0<t&&t<=1&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs q.all?&&%w(dai-kichi chu-kichi kichi syo-kichi)[[38,20,2,1e-9].index{|i|i<=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5}]||\"kyo\"end"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x = x; @y = y\n  end\n\n  def <=>(p)\n    return 1 if @x > p.x\n    return 1 if (@x == p.x) && (@y > p.y)\n    return -1 if @x < p.x\n    return -1 if (@x == p.x) && (@y < p.y)\n    0\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n\n  def dot(p)\n    @x*p.x + @y*p.y\n  end\n  def cross(p)\n    @x*p.y - @y*p.x\n  end\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def norm\n    @x**2 + @y**2\n  end\n  CounterClockwise = 1  # self-p1-p2の順で反時計回り\n  Clockwise = -1        # self-p1-p2の順で時計回り\n  # 3点の位置関係を調べる\n  def ccw(p1, p2)\n    p = p1-self; q = p2-self\n    return 1 if p.cross(q) > 0\n    return -1 if p.cross(q) < 0\n    0\n  end\nend\n\nclass Segment\n  attr_accessor :a, :b\n  def initialize(p1=Point.new, p2=Point.new)\n    @a = p1; @b = p2\n  end\n\n  def include?(p)\n    (@a-p).abs + (@b-p).abs == (b-a).abs\n  end\n  def intersect?(s)\n    s.a.ccw(s.b, self.a) * s.a.ccw(s.b, self.b) < 0 && self.a.ccw(self.b, s.a) * self.a.ccw(self.b, s.b) < 0\n  end\n  def crossingPoint(s)\n    dev = (self.b.y-self.a.y)*(s.b.x-s.a.x) - (self.b.x-self.a.x)*(s.b.y-s.a.y)\n    p \"ERROR\" if dev==0\n    d1 = s.a.y*s.b.x - s.a.x*s.b.y\n    d2 = self.a.y*self.b.x - self.a.x*self.b.y\n    x = d1*(self.b.x - self.a.x) - d2*(s.b.x - s.a.x)\n    x /= dev\n    y = d1*(self.b.y - self.a.y) - d2*(s.b.y - s.a.y)\n    y /= dev\n    Point.new(x, y)\n  end\nend\n\nwhile (x1, y1, x2, y2 = gets.split.map(&:to_i)).find{|v| v != 0} do\n  segment = Array.new\n  crossingPoint = Array.new\n  s = 0\n  segment.push(Segment.new(Point.new(x1, y1), Point.new(x2, y2)))\n  2.times do\n    x1, y1, x2, y2 = gets.split.map(&:to_i)\n    segment.push(Segment.new(Point.new(x1, y1), Point.new(x2, y2)))\n  end\n  3.times do |i|\n    break if !segment[i].intersect?(segment[(i+1)%3])\n    crossingPoint.push(segment[i].crossingPoint(segment[(i+1)%3]))\n  end\n  if crossingPoint.size == 3\n    a = crossingPoint[2] - crossingPoint[0]\n    b = crossingPoint[1] - crossingPoint[0]\n    s = (a.x*b.y - b.x*a.y).abs / 2.0\n  end\n  if s > 1900000\n    puts \"dai-kichi\"\n  elsif s > 1000000\n    puts \"chu-kichi\"\n  elsif s > 100000\n    puts \"kichi\"\n  elsif s > 0\n    puts \"syo-kichi\"\n  else\n    puts \"kyo\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "\ndef intersect?(line1, line2)\n  v1 = [line1[2]-line1[0], line1[3]-line1[1]]\n  p1 = [line2[0]-line1[0], line2[1]-line1[1]]\n  p2 = [line2[2]-line1[0], line2[3]-line1[1]]\n  v1p1 = v1[0]*p1[1] - v1[1]*p1[0]\n  v1p2 = v1[0]*p2[1] - v1[1]*p2[0]\n  v2 = [line2[2]-line2[0], line2[3]-line2[1]]\n  p1 = [line1[0]-line2[0], line1[1]-line2[1]]\n  p2 = [line1[2]-line2[0], line1[3]-line2[1]]\n  v2p1 = v2[0]*p1[1] - v2[1]*p1[0]\n  v2p2 = v2[0]*p2[1] - v2[1]*p2[0]\n  return false if ((v1p1 * v1p2 < 0) && (v2p1 * v2p2 < 0)) == false\n\n  a1 = (line1[3] - line1[1]) / (line1[2] - line1[0])\n  a3 = (line2[3] - line2[1]) / (line2[2] - line2[0])\n  x = (a1*line1[0] - line1[1] - a3 * line2[0] + line2[1]) / (a1 - a3)\n  y = (x - line1[0]) * (line1[3] - line1[1]) / (line1[2] - line1[0]) + line1[1]\n  [x, y]\nend\n\nwhile true do\n  line = Array.new {Array.new}\n  3.times do\n    exit if !line.push(gets.split.map(&:to_f)).last.find{|e| e != 0.0}\n  end\n  isTriangle = true\n  intersectingPoint = Array.new\n  3.times do |i|\n    isTriangle = false if !intersectingPoint.push(intersect?(line[i], line[(i + 1) % 3])).last\n  end\n  case isTriangle\n    when false\n      puts \"kyo\"\n    when true\n      t1 = [intersectingPoint[1][0] - intersectingPoint[0][0], intersectingPoint[1][1] - intersectingPoint[0][1]]\n      t2 = [intersectingPoint[2][0] - intersectingPoint[0][0], intersectingPoint[2][1] - intersectingPoint[0][1]]\n      area = (t1[0]*t2[1] - t1[1]*t2[0]).abs / 2.0\n      if area >= 1900000\n        puts \"dai-kichi\"\n      elsif area >= 1000000\n        puts \"chu-kichi\"\n      elsif area >= 100000\n        puts \"kichi\"\n      elsif area > 0\n        puts \"syo-kichi\"\n      else\n        puts \"kyo\"\n      end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};0<s&&s<=1&&0<t&&t<=1&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs %w(dai-kichi chu-kichi kichi syo-kichi kyo)[q.all?&&[38,20,2,1e-9].index{|i|i<=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5}||4]end"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDELTA = 1.0e-8\n\n### subroutines\n\ndef cross(l1, l2)\n  x1, y1 = l1[0..1]\n  x2, y2 = l1[2..3]\n  x3, y3 = l2[0..1]\n  x4, y4 = l2[2..3]\n\n  d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n  return nil if d.abs < DELTA\n\n  k = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n  e = -(y2 - y1) * (x4 - x1) + (x2 - x1) * (y4 - y1)\n\n  s = k / d\n  t = e / d\n  return nil if s < 0 || s > 1 || t < 0 || t > 1\n\n  [(x2 - x1) * s + x1, (y2 - y1) * s + y1]\nend\n\ndef eqpt(p1, p2)\n  (p2[0] - p1[0]).abs < DELTA && (p2[1] - p1[1]).abs < DELTA\nend\n\n### main\n\nwhile true\n  line = gets.strip\n  break if line == '0 0 0 0'\n\n  l1 = line.split(' ').map{|s| s.to_f}\n  l2 = gets.split(' ').map{|s| s.to_f}\n  l3 = gets.split(' ').map{|s| s.to_f}\n\n  c1 = cross(l1, l2)\n  c2 = cross(l2, l3)\n  c3 = cross(l3, l1)\n\n  if c1.nil? || c2.nil? || c3.nil? || (eqpt(c1, c2) && eqpt(c1, c3))\n    puts 'kyo'\n  else\n    v1 = [c2[0] - c1[0], c2[1] - c1[1]]\n    v2 = [c3[0] - c1[0], c3[1] - c1[1]]\n    s = (v1[0] * v2[1] - v1[1] * v2[0]).abs / 2\n\n    if s >= 1900000\n      puts 'dai-kichi'\n    elsif s >= 1000000\n      puts 'chu-kichi'\n    elsif s >= 100000\n      puts 'kichi'\n    else\n      puts 'sho-kichi'\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Class\n  def ===(other)\n    self==other\n  end\nend\n\nclass Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x.to_f, y.to_f\n  end\n\n  def <=>(p)\n    @x != p.x ? @x <=> p.x : @y <=> p.y\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n\n  def times(f)\n    Point.new(@x*f, @y*f)\n  end\n  def dot(p)\n    @x*p.x + @y*p.y\n  end\n  def cross(p)\n    @x*p.y - @y*p.x\n  end\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def norm\n    @x**2 + @y**2\n  end\n  # 直線abと点pの位置関係を調べる\n  # 0: 線分上, -1: 時計回り, 1: 反時計回り, -2: a-b-p, 2: p-a-b\n  def ccw(b, p)\n    a = self\n    v1, v2 = b-a, p-a\n    return 1 if v1.cross(v2) > 0\n    return -1 if v1.cross(v2) < 0\n    return 2 if v1.dot(v2) < 0\n    return -2 if v1.norm < v2.norm\n    0\n  end\nend\n\nclass Line\n  attr_accessor :a, :b\n  def initialize(p1=Point.new, p2=Point.new)\n    @a, @b = p1, p2\n  end\n\n  # 直線abと点pの位置関係を調べる\n  # 0: 線分上, -1: 時計回り, 1: 反時計回り, -2: a-b-p, 2: p-a-b\n  def ccw(p)\n    v1, v2 = @b - @a, p - @a\n    return 1 if v1.cross(v2) > 0\n    return -1 if v1.cross(v2) < 0\n    return 2 if v1.dot(v2) < 0\n    return -2 if v1.norm < v2.norm\n    0\n  end\n  # 交差判定\n  def intersect?(target)\n    case target.class\n      when Point\n        v1, v2 = @a-target, @b-target\n        return (v2.cross(v1)).abs == 0.0\n      when Segment\n        v1, v2, v3 = @b-@a, target.a-@a, target.b-@a\n        return v1.cross(v2) * v1.cross(v3) <= 0.0\n      when Line\n        v1, v2, v3 = @b-@a, target.b-target.a, target.a-@a\n        return v1.cross(v2).abs > 0.0 || v1.cross(v3).abs == 0.0\n    end\n  end\n  # 直線上に射影した点\n  def projection(p)\n    v1, v2 = p-a, a-b\n    a + v2.times(v1.dot(v2)/v2.norm)\n  end\n  # 直線に関して対象な点\n  def reflection(p)\n    p + (projection(p) - p).times(2.0)\n  end\n  # 距離\n  def distance(target)\n    case target.class\n      when Point\n        return (target - projection(target)).abs\n      when Segment\n        return intersect?(target) ? 0.0 : [distance(target.a), distance(target.b)].min\n      when Line\n        return intersect?(target) ? 0.0 : distance(target.a)\n    end\n  end\n  # 交点\n  def crosspoint(l)\n    v1, v2, v3 = @b-@a, l.b-l.a, @b-l.a\n    a, b = v1.cross(v2), v1.cross(v3)\n    return l.a if a.abs == 0.0 && b.abs == 0.0\n    l.a + v2.times(b/a)\n  end\nend\n\nclass Segment < Line\n  # 交差判定\n  def intersect?(target)\n    case target.class\n      when Point\n        return (@a-target).abs + (@b-target).abs == (@b-@a).abs\n      when Segment\n        return target.ccw(@a) * target.ccw(@b) <= 0 && ccw(target.a) * ccw(target.b) <= 0\n      when Line\n        return target.intersect?(self)\n    end\n  end\n  # 距離\n  def distance(target)\n    case target.class\n      when Point\n        p = projection(target)\n        return intersect?(p) ? (p-target).abs : [(@a-target).abs, (@b-target).abs].min\n      when Segment\n        return intersect?(target) ? 0.0 : [distance(target.a), distance(target.b), target.distance(@a), target.distance(@b)].min\n      when Line\n        return target.distance(self)\n    end\n  end\nend\n\n#交点、同一直線上、一点で交わる　→　凶\nedge = Array.new\nuntil (x1,y1,x2,y2=gets.split.map(&:to_i)).all?(&:zero?) do\n  edge.push(Segment.new(Point.new(x1,y1), Point.new(x2,y2)))\n  next if edge.size < 3\n  point = Array.new\n  for i in 0...3 do\n    break unless edge[i].intersect?(edge[(i+1)%3])\n    break if edge[i].intersect?(edge[(i+1)%3].a) && edge[i].intersect?(edge[(i+1)%3].b)\n    point.push(edge[i].crosspoint(edge[(i+1)%3]))\n  end\n  s = 0\n  unless point.size<3 || point[0]==point[1] || point[1]==point[2] || point[2]==point[0]\n    x1 = point[1].x - point[0].x\n    y1 = point[1].y - point[0].y\n    x2 = point[2].x - point[0].x\n    y2 = point[2].y - point[0].y\n    s = (x1*y2 - x2*y1).abs/2.0\n  end\n  if s==0\n    puts \"kyo\"\n  elsif s<100000\n    puts \"sho-kichi\"\n  elsif s<1000000\n    puts \"kichi\"\n  elsif s<1900000\n    puts \"chu-kichi\"\n  else\n    puts \"dai-kichi\"\n  end\n  edge.clear\nend"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};0<s&&s<=1&&0<t&&t<=1&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs q.all? ? [\"dai-\",\"chu-\",\"\",\"syo-\"][[38,20,2,0].index{|i|i<=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5}]+\"kichi\":\"kyo\"end"
  },
  {
    "language": "Ruby",
    "code": "puts $<.read"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nclass Point\n  attr_accessor :x, :y \n  def initialize p\n    @x = p[0]\n    @y = p[1]\n  end\nend\ndef cross(p1,p2,p3,p4)\n  a = (p4.y - p3.y)*(p4.x - p1.x) - (p4.x - p3.x)*(p4.y - p1.y)\n  b = (p2.x - p1.x)*(p4.y - p1.y) - (p2.y - p1.y)*(p4.x - p1.x)\n  c = (p2.x - p1.x)*(p4.y - p3.y) - (p2.y - p1.y)*(p4.x - p3.x)\n  return nil if c.abs < EPS\n  d = a / c\n  e = b / c\n  return nil if d < 0 || d > 1 || e < 0 || e > 1\n  Point.new([(p2.x - p1.x) * d + p1.x, (p2.y - p1.y) * d + p1.y])\nend\nwhile gets\n  break if $_.strip == \"0 0 0 0\"\n  l1 = $_.split.map(&:to_f)\n  l2 = gets.split.map(&:to_f)\n  l3 = gets.split.map(&:to_f)\n  p1 = Point.new(l1[0,2])\n  p2 = Point.new(l1[2,2])\n  p3 = Point.new(l2[0,2])\n  p4 = Point.new(l2[2,2])\n  p5 = Point.new(l3[0,2])\n  p6 = Point.new(l3[2,2])\n\n  c1 = cross(p1,p2,p3,p4)\n  c2 = cross(p3,p4,p5,p6)\n  c3 = cross(p5,p6,p1,p2)\n\n  unless c1 || c2 || c3\n    puts \"kyo\"\n  elsif (c2.x - c1.x).abs < EPS && (c2.y - c1.y).abs < EPS\n    puts \"kyo\"\n  else\n    s = ((c2.x - c1.x)*(c3.y - c1.y) - (c2.y - c1.y)*(c3.x - c1.x)).abs / 2\n    if s >= 1_900_000 then puts \"dai-kichi\"\n    elsif s >= 1_000_000 then puts \"chu-kichi\"\n    elsif s >= 100_000 then puts \"kichi\"\n    else puts \"syo-kichi\"\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\nEPS = 1e-9\n\nclass Point\n  attr_reader :x, :y\n  def initialize(x, y=nil)\n    @x, @y = x, y if y\n    @x, @y = x[0], x[1] unless y\n  end\n  def +(other)\n    Point.new(@x + other.x, @y + other.y)\n  end\n  def -(other)\n    Point.new(@x - other.x, @y - other.y)\n  end\n  def *(other)\n    Point.new(@x * other, @y * other)\n  end\nend\n\nclass Line\n  attr_reader :s, :t\n  def initialize(s, t=nil)\n    @s, @t = s, t if t\n    @s, @t = Point.new(s[0..1]), Point.new(s[2..3]) unless t\n  end\nend\n\ndef dot(a, b); a.x * b.x + a.y * b.y; end\ndef cross(a, b);  a.x * b.y - b.x * a.y; end\n\ndef is_intersected_ls(a, b)\n  cross(a.t - a.s, b.s - a.s) * cross(a.t - a.s, b.t - a.s) < EPS and\n    cross(b.t - b.s, a.s - b.s) * cross(b.t - b.s, a.t - b.s) < EPS\nend\n\ndef intersection_ls(a, b)\n  tmp = b.t - b.s\n\n  d1 = cross(tmp, a.s - b.s).abs\n  d2 = cross(tmp, a.t - b.s).abs\n  t = d1 / (d1 + d2)\n\n  a.s + (a.t - a.s) * t\nend\n\ndef area(points)\n  cross(points[0] - points[2], points[1] - points[2]).abs / 2\nend\n\ndef fortune(x)\n  case x\n  when 0; \"kyo\"\n  when 0..100000; \"syo-kichi\"\n  when 0..1000000; \"kichi\"\n  when 0..1900000; \"chu-kichi\"\n  else; \"dai-kichi\"\n  end\nend\n\nwhile input = gets.split.map(&:to_i) and input.count(0) != 4\n  l = [ Line.new(input) ]\n  2.times{ l << Line.new(gets.split.map(&:to_i)) }\n\n  res = nil\n  points = []\n  for i in 0..2\n    res = \"kyo\" unless is_intersected_ls(l[i], l[(i + 1) % 3])\n\n    points << intersection_ls(l[i], l[(i + 1) % 3]) unless res\n  end\n\n  res = fortune(area(points)) unless res\n\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nclass Point\n  attr_accessor :x, :y \n  def initialize p\n    @x = p[0]\n    @y = p[1]\n  end\nend\ndef cross(p1,p2,p3,p4)\n  a = (p4.y - p3.y)*(p4.x - p1.x) - (p4.x - p3.x)*(p4.y - p1.y)\n  b = (p2.x - p1.x)*(p4.y - p1.y) - (p2.y - p1.y)*(p4.x - p1.x)\n  c = (p2.x - p1.x)*(p4.y - p3.y) - (p2.y - p1.y)*(p4.x - p3.x)\n  return nil if c.abs < EPS\n  d = a / c\n  e = b / c\n  return nil if d < 0 || d > 1 || e < 0 || e > 1\n  Point.new([(p2.x - p1.x) * d + p1.x, (p2.y - p1.y) * d + p1.y])\nend\nwhile gets\n  break if $_.strip == \"0 0 0 0\"\n  l1 = $_.split.map(&:to_f)\n  l2 = gets.split.map(&:to_f)\n  l3 = gets.split.map(&:to_f)\n  p1 = Point.new(l1[0,2])\n  p2 = Point.new(l1[2,2])\n  p3 = Point.new(l2[0,2])\n  p4 = Point.new(l2[2,2])\n  p5 = Point.new(l3[0,2])\n  p6 = Point.new(l3[2,2])\n\n  c1 = cross(p1,p2,p3,p4)\n  c2 = cross(p3,p4,p5,p6)\n  c3 = cross(p5,p6,p1,p2)\n\n  if !c1 || !c2 || !c3 || (c2.x - c1.x).abs < EPS && (c2.y - c1.y).abs < EPS\n    puts \"kyo\"\n  else\n    s = ((c2.x - c1.x)*(c3.y - c1.y) - (c2.y - c1.y)*(c3.x - c1.x)).abs / 2\n    if s >= 1_900_000 then puts \"dai-kichi\"\n    elsif s >= 1_000_000 then puts \"chu-kichi\"\n    elsif s >= 100_000 then puts \"kichi\"\n    else puts \"syo-kichi\"\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nclass Point\n  attr_accessor :x, :y \n  def initialize p\n    @x = p[0]\n    @y = p[1]\n  end\nend\ndef cross(p1,p2,p3,p4)\n  a = (p4.y - p3.y)*(p4.x - p1.x) - (p4.x - p3.x)*(p4.y - p1.y)\n  b = (p2.x - p1.x)*(p4.y - p1.y) - (p2.y - p1.y)*(p4.x - p1.x)\n  c = (p2.x - p1.x)*(p4.y - p3.y) - (p2.y - p1.y)*(p4.x - p3.x)\n  return nil if c.abs < EPS\n  d = a / c\n  e = b / c\n  return nil if d < 0 || d > 1 || e < 0 || e > 1\n  Point.new([(p2.x - p1.x) * d + p1.x, (p2.y - p1.y) * d + p1.y])\nend\nwhile gets\n  break if $_.strip == \"0 0 0 0\"\n  l1 = $_.split.map(&:to_f)\n  l2 = gets.split.map(&:to_f)\n  l3 = gets.split.map(&:to_f)\n  p1 = Point.new(l1[0,2])\n  p2 = Point.new(l1[2,2])\n  p3 = Point.new(l2[0,2])\n  p4 = Point.new(l2[2,2])\n  p5 = Point.new(l3[0,2])\n  p6 = Point.new(l3[2,2])\n\n  c1 = cross(p1,p2,p3,p4)\n  c2 = cross(p3,p4,p5,p6)\n  c3 = cross(p5,p6,p1,p2)\n\n  unless c1 || c2 || c3\n    puts \"kyo\"\n  end\n  if (c2.x - c1.x).abs < EPS && (c2.y - c1.y).abs < EPS\n    puts \"kyo\"\n  else\n    s = ((c2.x - c1.x)*(c3.y - c1.y) - (c2.y - c1.y)*(c3.x - c1.x)).abs / 2\n    if s >= 1_900_000 then puts \"dai-kichi\"\n    elsif s >= 1_000_000 then puts \"chu-kichi\"\n    elsif s >= 100_000 then puts \"kichi\"\n    else puts \"syo-kichi\"\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\nEPS = 1e-9\n\nclass Point\n  attr_reader :x, :y\n  def initialize(x, y=nil)\n    @x, @y = x, y if y\n    @x, @y = x[0], x[1] unless y\n  end\n  def abs; (@x**2 + @y**2)**0.5; end\n  def +(other); Point.new(@x + other.x, @y + other.y); end\n  def -(other); Point.new(@x - other.x, @y - other.y); end\n  def *(other); Point.new(@x * other, @y * other); end\n  def /(other); Point.new(@x / other, @y / other); end\nend\n\nclass Line\n  attr_reader :s, :t\n  def initialize(s, t=nil)\n    @s, @t = s, t if t\n    @s, @t = Point.new(s[0..1]), Point.new(s[2..3]) unless t\n  end\n  def abs; (@t - @s).abs; end\nend\n\ndef dot(a, b); a.x * b.x + a.y * b.y; end\ndef cross(a, b);  a.x * b.y - b.x * a.y; end\n\ndef is_intersected_ls(a, b)\n  return false if ((a.t - a.s) / a.abs - (b.t - b.s) / b.abs).abs < EPS\n\n  cross(a.t - a.s, b.s - a.s) * cross(a.t - a.s, b.t - a.s) < EPS and\n    cross(b.t - b.s, a.s - b.s) * cross(b.t - b.s, a.t - b.s) < EPS\nend\n\ndef intersection_ls(a, b)\n  tmp = b.t - b.s\n\n  d1 = cross(tmp, a.s - b.s).abs\n  d2 = cross(tmp, a.t - b.s).abs\n\n  return nil if d1 + d2 == 0\n  t = d1 / (d1 + d2)\n\n  a.s + (a.t - a.s) * t\nend\n\ndef area(points)\n  cross(points[0] - points[2], points[1] - points[2]).abs / 2\nend\n\ndef fortune(x)\n  case x\n  when 0; \"kyo\"\n  when 0..100000; \"syo-kichi\"\n  when 0..1000000; \"kichi\"\n  when 0..1900000; \"chu-kichi\"\n  else; \"dai-kichi\"\n  end\nend\n\nwhile input = gets.split.map(&:to_i) and input.count(0) != 4\n  l = [ Line.new(input) ]\n  2.times{ l << Line.new(gets.split.map(&:to_i)) }\n\n  res = nil\n  points = []\n  for i in 0..2\n    res = \"kyo\" unless is_intersected_ls(l[i], l[(i + 1) % 3])\n\n    points << intersection_ls(l[i], l[(i + 1) % 3]) unless res\n    res = \"kyo\" unless points[i]\n  end\n\n  res = fortune(area(points)) unless res\n\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nclass Point\n  attr_accessor :x, :y \n  def initialize p\n    @x = p[0]\n    @y = p[1]\n  end\nend\ndef cross(p1,p2,p3,p4)\n  a = (p4.y - p3.y)*(p4.x - p1.x) - (p4.x - p3.x)*(p4.y - p1.y)\n  b = (p2.x - p1.x)*(p4.y - p1.y) - (p2.y - p1.y)*(p4.x - p1.x)\n  c = (p2.x - p1.x)*(p4.y - p3.y) - (p2.y - p1.y)*(p4.x - p3.x)\n  return nil if c.abs < EPS\n  d = a / c\n  e = b / c\n  return nil if d < 0 || d > 1 || e < 0 || e > 1\n  Point.new([(p2.x - p1.x) * d + p1.x, (p2.y - p1.y) * d + p1.y])\nend\nwhile gets\n  break if $_.strip == \"0 0 0 0\"\n  l1 = $_.split.map(&:to_f)\n  l2 = gets.split.map(&:to_f)\n  l3 = gets.split.map(&:to_f)\n  p1 = Point.new(l1[0,2])\n  p2 = Point.new(l1[2,2])\n  p3 = Point.new(l2[0,2])\n  p4 = Point.new(l2[2,2])\n  p5 = Point.new(l3[0,2])\n  p6 = Point.new(l3[2,2])\n\n  c1 = cross(p1,p2,p3,p4)\n  c2 = cross(p3,p4,p5,p6)\n  c3 = cross(p5,p6,p1,p2)\n\n  unless c1 || c2 || c3\n    puts \"kyo\"\n  else\n    if (c2.x - c1.x).abs < EPS && (c2.y - c1.y).abs < EPS\n      puts \"kyo\"\n    else\n      s = ((c2.x - c1.x)*(c3.y - c1.y) - (c2.y - c1.y)*(c3.x - c1.x)).abs / 2\n      if s >= 1_900_000 then puts \"dai-kichi\"\n      elsif s >= 1_000_000 then puts \"chu-kichi\"\n      elsif s >= 100_000 then puts \"kichi\"\n      else puts \"syo-kichi\"\n      end\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};0<s&&s<=1&&0<t&&t<=1&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs %w(dai-kichi chu-kichi kichi syo-kichi kyo)[q.all?&&(y=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5)>0&&[38,20,2,0].index{|i|i<=y}||4]end"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_i;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c))).abs>0&&(s,t=[b,c].map{|i|x v(b[0,2]+c[0,2]),v(i)}\n[s,d-s,t,d-t].all?{|i|d<0?i<=0:i>=0}&&[0,1].map{|i|b[i]+t*(b[i+2]-b[i])/d.to_f})}\nputs %w(dai-kichi chu-kichi kichi syo-kichi kyo)[q.all?&&(y=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5)>0&&[38,20,2,0].index{|i|1e-9>i-y}||4]end"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};0<s&&s<=1&&0<t&&t<=1&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs q.all? ? [\"dai-\",\"chu-\",\"\",\"syo-\"][[19,10,1,0].index{|i|i<=x(v(q[0]+q[1]),v(q[1]+q[2]))/1e5}]+\"kichi\":\"kyo\"end"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDELTA = 1.0e-8\n\n### subroutines\n\ndef cross(l1, l2)\n  x1, y1 = l1[0..1]\n  x2, y2 = l1[2..3]\n  x3, y3 = l2[0..1]\n  x4, y4 = l2[2..3]\n\n  d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n  return nil if d.abs < DELTA\n\n  k = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n  e = -(y2 - y1) * (x4 - x1) + (x2 - x1) * (y4 - y1)\n\n  s = k / d\n  t = e / d\n  return nil if s < 0 || s > 1 || t < 0 || t > 1\n\n  [(x2 - x1) * s + x1, (y2 - y1) * s + y1]\nend\n\ndef eqpt(p1, p2)\n  (p2[0] - p1[0]).abs < DELTA && (p2[1] - p1[1]).abs < DELTA\nend\n\n### main\n\nwhile true\n  line = gets.strip\n  break if line == '0 0 0 0'\n\n  l1 = line.split(' ').map{|s| s.to_f}\n  l2 = gets.split(' ').map{|s| s.to_f}\n  l3 = gets.split(' ').map{|s| s.to_f}\n\n  c1 = cross(l1, l2)\n  c2 = cross(l2, l3)\n  c3 = cross(l3, l1)\n\n  if c1.nil? || c2.nil? || c3.nil? ||\n      eqpt(c1, c2) || eqpt(c2, c3) || eqpt(c3, c1)\n    puts 'kyo'\n  else\n    v1 = [c2[0] - c1[0], c2[1] - c1[1]]\n    v2 = [c3[0] - c1[0], c3[1] - c1[1]]\n    s = (v1[0] * v2[1] - v1[1] * v2[0]).abs / 2\n\n    if s >= 1900000\n      puts 'dai-kichi'\n    elsif s >= 1000000\n      puts 'chu-kichi'\n    elsif s >= 100000\n      puts 'kichi'\n    else\n      puts 'syo-kichi'\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\nEPS = 1e-9\n\nclass Point\n  attr_reader :x, :y\n  def initialize(x, y=nil)\n    @x, @y = x, y if y\n    @x, @y = x[0], x[1] unless y\n  end\n  def abs; (@x**2 + @y**2)**0.5; end\n  def +(other); Point.new(@x + other.x, @y + other.y); end\n  def -(other); Point.new(@x - other.x, @y - other.y); end\n  def *(other); Point.new(@x * other, @y * other); end\n  def /(other); Point.new(@x / other, @y / other); end\nend\n\nclass Line\n  attr_reader :s, :t\n  def initialize(s, t=nil)\n    @s, @t = s, t if t\n    @s, @t = Point.new(s[0..1]), Point.new(s[2..3]) unless t\n  end\n  def abs; (@t - @s).abs; end\nend\n\ndef dot(a, b); a.x * b.x + a.y * b.y; end\ndef cross(a, b);  a.x * b.y - b.x * a.y; end\n\ndef is_intersected_ls(a, b)\n  return false if ((a.t - a.s) / a.abs - (b.t - b.s) / b.abs) < EPS\n\n  cross(a.t - a.s, b.s - a.s) * cross(a.t - a.s, b.t - a.s) < EPS and\n    cross(b.t - b.s, a.s - b.s) * cross(b.t - b.s, a.t - b.s) < EPS\nend\n\ndef intersection_ls(a, b)\n  tmp = b.t - b.s\n\n  d1 = cross(tmp, a.s - b.s).abs\n  d2 = cross(tmp, a.t - b.s).abs\n  t = d1 / (d1 + d2)\n\n  a.s + (a.t - a.s) * t\nend\n\ndef area(points)\n  cross(points[0] - points[2], points[1] - points[2]).abs / 2\nend\n\ndef fortune(x)\n  case x\n  when 0; \"kyo\"\n  when 0..100000; \"syo-kichi\"\n  when 0..1000000; \"kichi\"\n  when 0..1900000; \"chu-kichi\"\n  else; \"dai-kichi\"\n  end\nend\n\nwhile input = gets.split.map(&:to_i) and input.count(0) != 4\n  l = [ Line.new(input) ]\n  2.times{ l << Line.new(gets.split.map(&:to_i)) }\n\n  res = nil\n  points = []\n  for i in 0..2\n    res = \"kyo\" unless is_intersected_ls(l[i], l[(i + 1) % 3])\n\n    points << intersection_ls(l[i], l[(i + 1) % 3]) unless res\n  end\n\n  res = fortune(area(points)) unless res\n\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'zlib'\nrequire 'base64'\n$stderr.puts Base64.encode64(Zlib.deflate($<.read))"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};-1e-9<s&&s<=1+1e-9&&-1e-9<t&&t<=1+1e-9&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs %w(dai-kichi chu-kichi kichi syo-kichi kyo)[q.all?&&(y=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5)>0&&[38,20,2,0].index{|i|i-1e-9<=y}||4]end"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};0<s&&s<=1&&0<t&&t<=1&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs q.all? ? [\"dai-\",\"chu-\",\"\",\"syo-\"][[38,20,2,1e-9].index{|i|i<=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5}]+\"kichi\":\"kyo\"end"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\n\ndef cross(x1, y1, x2, y2, x3, y3, x4, y4)\n  a = Matrix[[x2 - x1, x3 - x4], [y2 - y1, y3 - y4]].lup.solve([x3 - x1, y3 - y1]) rescue nil\n  return false unless a\n  s, t = a[0], a[1]\n  f = ((0 <= s and s <= 1) and (0 <= t and t <= 1))\n  f ? Vector[x1 + s * (x2 - x1), y1 + s * (y2 - y1)] : false\nend\n\nuntil (given = $<.gets.split.map(&:to_i)) == [0] * 4\n  x, y = [], []\n  x[0], y[0], x[1], y[1] = given\n  x[2], y[2], x[3], y[3] = $<.gets.split.map(&:to_i)\n  x[4], y[4], x[5], y[5] = $<.gets.split.map(&:to_i)\n  p1 = cross(x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3]) \n  p2 = cross(x[2], y[2], x[3], y[3], x[4], y[4], x[5], y[5]) \n  p3 = cross(x[4], y[4], x[5], y[5], x[0], y[0], x[1], y[1])\n  str = \"kyo\"\n  if p1 and p2 and p3\n    v1 = p2 - p1\n    v2 = p3 - p1\n    s = Rational((v1[0] * v2[1] - v1[1] * v2[0]).abs, 2)\n    if s.nonzero?\n      idx = nil\n      [Float::INFINITY, 1_900_000, 1_000_000, 100_000, 0].each_cons(2).with_index do |a, i|\n        idx = i if a[1] <= s and s < a[0]\n      end\n      str = %w(dai-kichi chu-kichi kichi syo-kichi)[idx]\n    end\n  end\n  puts str\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nE=1e-9\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c))).abs>=E&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};[s,1-s,t,1-t].all?{|i|i>=E}&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs %w(dai-kichi chu-kichi kichi syo-kichi kyo)[q.all?&&(y=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5)>0&&[38,20,2,0].index{|i|E>i-y}||4]end"
  },
  {
    "language": "Ruby",
    "code": "\nEPS = 1e-9\n\ndef intersect?(line1, line2)\n  v1 = [line1[2]-line1[0], line1[3]-line1[1]]\n  p1 = [line2[0]-line1[0], line2[1]-line1[1]]\n  p2 = [line2[2]-line1[0], line2[3]-line1[1]]\n  v1p1 = v1[0]*p1[1] - v1[1]*p1[0]\n  v1p2 = v1[0]*p2[1] - v1[1]*p2[0]\n  v2 = [line2[2]-line2[0], line2[3]-line2[1]]\n  p1 = [line1[0]-line2[0], line1[1]-line2[1]]\n  p2 = [line1[2]-line2[0], line1[3]-line2[1]]\n  v2p1 = v2[0]*p1[1] - v2[1]*p1[0]\n  v2p2 = v2[0]*p2[1] - v2[1]*p2[0]\n  return false if ((v1p1 * v1p2 < 0) && (v2p1 * v2p2 < 0)) == false\n\n  a1 = (line1[3] - line1[1]) / (line1[2] - line1[0])\n  a3 = (line2[3] - line2[1]) / (line2[2] - line2[0])\n  x = (a1*line1[0] - line1[1] - a3 * line2[0] + line2[1]) / (a1 - a3)\n  y = (x - line1[0]) * (line1[3] - line1[1]) / (line1[2] - line1[0]) + line1[1]\n  [x, y]\nend\n\nwhile true do\n  line = Array.new {Array.new}\n  3.times do\n    exit if !line.push(gets.split.map(&:to_f)).last.find{|e| e != 0.0}\n  end\n  isTriangle = true\n  intersectingPoint = Array.new\n  3.times do |i|\n    isTriangle = false if !intersectingPoint.push(intersect?(line[i], line[(i + 1) % 3])).last\n  end\n  case isTriangle\n    when false\n      puts \"kyo\"\n    when true\n      t1 = [intersectingPoint[1][0] - intersectingPoint[0][0], intersectingPoint[1][1] - intersectingPoint[0][1]]\n      t2 = [intersectingPoint[2][0] - intersectingPoint[0][0], intersectingPoint[2][1] - intersectingPoint[0][1]]\n      area = (t1[0]*t2[1] - t1[1]*t2[0]).abs / 2.0\n      if area > 1900000 - EPS\n        puts \"dai-kichi\"\n      elsif area > 1000000 - EPS\n        puts \"chu-kichi\"\n      elsif area > 100000 - EPS\n        puts \"kichi\"\n      elsif area > EPS\n        puts \"syo-kichi\"\n      else\n        puts \"kyo\"\n      end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nclass Point\n  attr_accessor :x, :y \n  def initialize p\n    @x = p[0]\n    @y = p[1]\n  end\nend\ndef cross(p1,p2,p3,p4)\n  a = (p4.y - p3.y)*(p4.x - p1.x) - (p4.x - p3.x)*(p4.y - p1.y)\n  b = (p2.x - p1.x)*(p4.y - p1.y) - (p2.y - p1.y)*(p4.x - p1.x)\n  c = (p2.x - p1.x)*(p4.y - p3.y) - (p2.y - p1.y)*(p4.x - p3.x)\n  return nil if c.abs < EPS\n  d = a / c\n  e = b / c\n  return nil if d < 0 || d > 1 || e < 0 || e > 1\n  Point.new([(p2.x - p1.x) * d + p1.x, (p2.y - p1.y) * d + p1.y])\nend\nwhile gets\n  break if $_.strip == \"0 0 0 0\"\n  l1 = $_.split.map(&:to_f)\n  l2 = gets.split.map(&:to_f)\n  l3 = gets.split.map(&:to_f)\n  p1 = Point.new(l1[0,2])\n  p2 = Point.new(l1[2,2])\n  p3 = Point.new(l2[0,2])\n  p4 = Point.new(l2[2,2])\n  p5 = Point.new(l3[0,2])\n  p6 = Point.new(l3[2,2])\n\n  c1 = cross(p1,p2,p3,p4)\n  c2 = cross(p3,p4,p5,p6)\n  c3 = cross(p5,p6,p1,p2)\n\n  unless c1 && c2 && c3\n    puts \"kyo\"\n  else\n    s = ((c2.x - c1.x)*(c3.y - c1.y) - (c2.y - c1.y)*(c3.x - c1.x)).abs / 2\n    if (c2.x - c1.x).abs < EPS && (c2.y - c1.y).abs < EPS then puts \"kyo\"\n    elsif s >= 1_900_000 then puts \"dai-kichi\"\n    elsif s >= 1_000_000 then puts \"chu-kichi\"\n    elsif s >= 100_000 then puts \"kichi\"\n    else puts \"syo-kichi\"\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\nEPS = 1e-9\n\nclass Point\n  attr_reader :x, :y\n  def initialize(x, y=nil)\n    @x, @y = x, y if y\n    @x, @y = x[0], x[1] unless y\n  end\n  def abs; (@x**2 + @y**2)**0.5; end\n  def +(other); Point.new(@x + other.x, @y + other.y); end\n  def -(other); Point.new(@x - other.x, @y - other.y); end\n  def *(other); Point.new(@x * other, @y * other); end\n  def /(other); Point.new(@x / other, @y / other); end\nend\n\nclass Line\n  attr_reader :s, :t\n  def initialize(s, t=nil)\n    @s, @t = s, t if t\n    @s, @t = Point.new(s[0..1]), Point.new(s[2..3]) unless t\n  end\n  def abs; (@t - @s).abs; end\nend\n\ndef dot(a, b); a.x * b.x + a.y * b.y; end\ndef cross(a, b);  a.x * b.y - b.x * a.y; end\n\ndef is_intersected_ls(a, b)\n  return false if (a.t - a.s) / a.abs == (b.t - b.s) / b.abs\n\n  cross(a.t - a.s, b.s - a.s) * cross(a.t - a.s, b.t - a.s) < EPS and\n    cross(b.t - b.s, a.s - b.s) * cross(b.t - b.s, a.t - b.s) < EPS\nend\n\ndef intersection_ls(a, b)\n  tmp = b.t - b.s\n\n  d1 = cross(tmp, a.s - b.s).abs\n  d2 = cross(tmp, a.t - b.s).abs\n  t = d1 / (d1 + d2)\n\n  a.s + (a.t - a.s) * t\nend\n\ndef area(points)\n  cross(points[0] - points[2], points[1] - points[2]).abs / 2\nend\n\ndef fortune(x)\n  case x\n  when 0; \"kyo\"\n  when 0..100000; \"syo-kichi\"\n  when 0..1000000; \"kichi\"\n  when 0..1900000; \"chu-kichi\"\n  else; \"dai-kichi\"\n  end\nend\n\nwhile input = gets.split.map(&:to_i) and input.count(0) != 4\n  l = [ Line.new(input) ]\n  2.times{ l << Line.new(gets.split.map(&:to_i)) }\n\n  res = nil\n  points = []\n  for i in 0..2\n    res = \"kyo\" unless is_intersected_ls(l[i], l[(i + 1) % 3])\n\n    points << intersection_ls(l[i], l[(i + 1) % 3]) unless res\n  end\n\n  res = fortune(area(points)) unless res\n\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\nEPS = 1e-9\n\nclass Point\n  attr_reader :x, :y\n  def initialize(x, y=nil)\n    @x, @y = x, y if y\n    @x, @y = x[0], x[1] unless y\n  end\n  def abs; (@x**2 + @y**2)**0.5; end\n  def +(other); Point.new(@x + other.x, @y + other.y); end\n  def -(other); Point.new(@x - other.x, @y - other.y); end\n  def *(other); Point.new(@x * other, @y * other); end\n  def /(other); Point.new(@x / other, @y / other); end\nend\n\nclass Line\n  attr_reader :s, :t\n  def initialize(s, t=nil)\n    @s, @t = s, t if t\n    @s, @t = Point.new(s[0..1]), Point.new(s[2..3]) unless t\n  end\n  def abs; (@t - @s).abs; end\nend\n\ndef dot(a, b); a.x * b.x + a.y * b.y; end\ndef cross(a, b);  a.x * b.y - b.x * a.y; end\n\ndef is_intersected_ls(a, b)\n  return false if ((a.t - a.s) / a.abs - (b.t - b.s) / b.abs).abs < EPS\n\n  cross(a.t - a.s, b.s - a.s) * cross(a.t - a.s, b.t - a.s) < EPS and\n    cross(b.t - b.s, a.s - b.s) * cross(b.t - b.s, a.t - b.s) < EPS\nend\n\ndef intersection_ls(a, b)\n  tmp = b.t - b.s\n\n  d1 = cross(tmp, a.s - b.s).abs\n  d2 = cross(tmp, a.t - b.s).abs\n  t = d1 / (d1 + d2)\n\n  a.s + (a.t - a.s) * t\nend\n\ndef area(points)\n  cross(points[0] - points[2], points[1] - points[2]).abs / 2\nend\n\ndef fortune(x)\n  case x\n  when 0; \"kyo\"\n  when 0...100000; \"syo-kichi\"\n  when 0...1000000; \"kichi\"\n  when 0...1900000; \"chu-kichi\"\n  else; \"dai-kichi\"\n  end\nend\n\nwhile input = gets.split.map(&:to_i) and input.count(0) != 4\n  l = [ Line.new(input) ]\n  2.times{ l << Line.new(gets.split.map(&:to_i)) }\n\n  res = nil\n  points = []\n  for i in 0..2\n    res = \"kyo\" unless is_intersected_ls(l[i], l[(i + 1) % 3])\n\n    points << intersection_ls(l[i], l[(i + 1) % 3]) unless res\n  end\n\n  res = fortune(area(points)) unless res\n\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "## subroutines\n\ndef cross(l1, l2)\n  x1, y1 = l1[0..1]\n  x2, y2 = l1[2..3]\n  x3, y3 = l2[0..1]\n  x4, y4 = l2[2..3]\n\n  d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n  return nil if d == 0.0\n\n  k = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n  e = -(y2 - y1) * (x4 - x1) + (x2 - x1) * (y4 - y1)\n\n  s = k / d\n  t = e / d\n  return nil if s < 0 || s > 1 || t < 0 || t > 1\n\n  [(x2 - x1) * s + x1, (y2 - y1) * s + y1]\nend\n\n### main\n\nwhile true\n  line = gets.strip\n  break if line == '0 0 0 0'\n\n  l1 = line.split(' ').map{|s| s.to_f}\n  l2 = gets.split(' ').map{|s| s.to_f}\n  l3 = gets.split(' ').map{|s| s.to_f}\n\n  c1 = cross(l1, l2)\n  c2 = cross(l2, l3)\n  c3 = cross(l3, l1)\n\n  if c1.nil? || c2.nil? || c3.nil? || (c1 == c2 && c2 == c3)\n    puts 'kyo'\n  else\n    v1 = [c2[0] - c1[0], c2[1] - c1[1]]\n    v2 = [c3[0] - c1[0], c3[1] - c1[1]]\n    s = (v1[0] * v2[1] - v1[1] * v2[0]).abs / 2\n\n    if s >= 1900000\n      puts 'dai-kichi'\n    elsif s >= 1000000\n      puts 'chu-kichi'\n    elsif s >= 100000\n      puts 'kichi'\n    else\n      puts 'sho-kichi'\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDELTA = 1.0e-7\n\n### subroutines\n\ndef cross(l1, l2)\n  x1, y1 = l1[0..1]\n  x2, y2 = l1[2..3]\n  x3, y3 = l2[0..1]\n  x4, y4 = l2[2..3]\n\n  d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n  return nil if d == 0.0\n\n  k = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n  e = -(y2 - y1) * (x4 - x1) + (x2 - x1) * (y4 - y1)\n\n  s = k / d\n  t = e / d\n  return nil if s < 0 || s > 1 || t < 0 || t > 1\n\n  [(x2 - x1) * s + x1, (y2 - y1) * s + y1]\nend\n\ndef eqpt(p1, p2)\n  (p2[0] - p1[0]).abs < DELTA && (p2[1] - p1[1]).abs < DELTA\nend\n\n### main\n\nwhile true\n  line = gets.strip\n  break if line == '0 0 0 0'\n\n  l1 = line.split(' ').map{|s| s.to_f}\n  l2 = gets.split(' ').map{|s| s.to_f}\n  l3 = gets.split(' ').map{|s| s.to_f}\n\n  c1 = cross(l1, l2)\n  c2 = cross(l2, l3)\n  c3 = cross(l3, l1)\n\n  if c1.nil? || c2.nil? || c3.nil? || (eqpt(c1, c2) && eqpt(c1, c3))\n    puts 'kyo'\n  else\n    v1 = [c2[0] - c1[0], c2[1] - c1[1]]\n    v2 = [c3[0] - c1[0], c3[1] - c1[1]]\n    s = (v1[0] * v2[1] - v1[1] * v2[0]).abs / 2\n\n    if s >= 1900000\n      puts 'dai-kichi'\n    elsif s >= 1000000\n      puts 'chu-kichi'\n    elsif s >= 100000\n      puts 'kichi'\n    else\n      puts 'sho-kichi'\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nclass Point\n  attr_accessor :x, :y \n  def initialize p\n    @x = p[0]\n    @y = p[1]\n  end\nend\ndef cross(p1,p2,p3,p4)\n  a = (p4.y - p3.y)*(p4.x - p1.x) - (p4.x - p3.x)*(p4.y - p1.y)\n  b = (p2.x - p1.x)*(p4.y - p1.y) - (p2.y - p1.y)*(p4.x - p1.x)\n  c = (p2.x - p1.x)*(p4.y - p3.y) - (p2.y - p1.y)*(p4.x - p3.x)\n  return nil if c.abs < EPS\n  d = a / c\n  e = b / c\n  return nil if d < 0 || d > 1 || e < 0 || e > 1\n  Point.new([(p2.x - p1.x) * d + p1.x, (p2.y - p1.y) * d + p1.y])\nend\nwhile gets\n  break if $_.strip == \"0 0 0 0\"\n  l1 = $_.split.map(&:to_f)\n  l2 = gets.split.map(&:to_f)\n  l3 = gets.split.map(&:to_f)\n  p1 = Point.new(l1[0,2])\n  p2 = Point.new(l1[2,2])\n  p3 = Point.new(l2[0,2])\n  p4 = Point.new(l2[2,2])\n  p5 = Point.new(l3[0,2])\n  p6 = Point.new(l3[2,2])\n\n  c1 = cross(p1,p2,p3,p4)\n  c2 = cross(p3,p4,p5,p6)\n  c3 = cross(p5,p6,p1,p2)\n\n  unless c1 && c2 && c3\n    puts \"kyo\"\n  else\n    if (c2.x - c1.x).abs < EPS && (c2.y - c1.y).abs < EPS then puts \"kyo\"\n    s = ((c2.x - c1.x)*(c3.y - c1.y) - (c2.y - c1.y)*(c3.x - c1.x)).abs / 2\n    elsif s >= 1_900_000 then puts \"dai-kichi\"\n    elsif s >= 1_000_000 then puts \"chu-kichi\"\n    elsif s >= 100_000 then puts \"kichi\"\n    else puts \"syo-kichi\"\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_i;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c))).abs>0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))}\n[s,d-s,t,d-t].all?{|i|d<0?i<=0:i>=0}&&[0,1].map{|i|b[i]+t*(b[i+2]-b[i])/d.to_f})}\nputs %w(dai-kichi chu-kichi kichi syo-kichi kyo)[q.all?&&(y=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5)>0&&[38,20,2,0].index{|i|1e-9>i-y}||4]end"
  },
  {
    "language": "Ruby",
    "code": "$stderr.puts $<.read"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};0<s&&s<=1&&0<t&&t<=1&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs q.all? ? [\"dai-\",\"chu-\",\"\",\"syo-\"][[19,10,1,0].index{|i|i<=x(v(q[0]+q[1]),v(q[1]+q[2])).abs/1e5}]+\"kichi\":\"kyo\"end"
  },
  {
    "language": "Ruby",
    "code": "def z;gets.split.map &:to_f;end\ndef x a,b;a[0]*b[1]-b[0]*a[1]end\ndef v a;[a[2]-a[0],a[3]-a[1]]end\nwhile(n=z)!=[0]*4\na=[n,z,z]\nq=a.zip(a.rotate).map{|b,c|(d=x(v(b),v(c)))!=0&&(s,t=[b,c].map{|i|x(v(b[0,2]+c[0,2]),v(i))/d};0<s&&s<=1&&0<t&&t<=1&&[0,1].map{|i|b[i]+s*(b[i+2]-b[i])})}\nputs q.all? ? [\"dai-\",\"chu-\",\"\",\"syo-\"][[19e5,1e6,1e5,0].index{|i|i<=x(v(q[0]+q[1]),v(q[1]+q[2])).abs}]+\"kichi\":\"kyo\"end"
  },
  {
    "language": "Ruby",
    "code": "class Class\n  def ===(other)\n    self==other\n  end\nend\n\nclass Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x.to_f, y.to_f\n  end\n\n  def <=>(p)\n    @x != p.x ? @x <=> p.x : @y <=> p.y\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n\n  def times(f)\n    Point.new(@x*f, @y*f)\n  end\n  def dot(p)\n    @x*p.x + @y*p.y\n  end\n  def cross(p)\n    @x*p.y - @y*p.x\n  end\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def norm\n    @x**2 + @y**2\n  end\n  # 直線abと点pの位置関係を調べる\n  # 0: 線分上, -1: 時計回り, 1: 反時計回り, -2: a-b-p, 2: p-a-b\n  def ccw(b, p)\n    a = self\n    v1, v2 = b-a, p-a\n    return 1 if v1.cross(v2) > 0\n    return -1 if v1.cross(v2) < 0\n    return 2 if v1.dot(v2) < 0\n    return -2 if v1.norm < v2.norm\n    0\n  end\nend\n\nclass Line\n  EPS = 1e-12\n  attr_accessor :a, :b\n  def initialize(p1=Point.new, p2=Point.new)\n    @a, @b = p1, p2\n  end\n\n  # 直線abと点pの位置関係を調べる\n  # 0: 線分上, -1: 時計回り, 1: 反時計回り, -2: a-b-p, 2: p-a-b\n  def ccw(p)\n    v1, v2 = @b - @a, p - @a\n    return 1 if v1.cross(v2) > EPS\n    return -1 if v1.cross(v2) < -EPS\n    return 2 if v1.dot(v2) < -EPS\n    return -2 if v2.norm - v1.norm > EPS\n    0\n  end\n  # 交差判定\n  def intersect?(target)\n    case target.class\n      when Point\n        v1, v2 = @a-target, @b-target\n        return (v2.cross(v1)).abs == 0.0\n      when Segment\n        v1, v2, v3 = @b-@a, target.a-@a, target.b-@a\n        return v1.cross(v2) * v1.cross(v3) <= 0.0\n      when Line\n        v1, v2, v3 = @b-@a, target.b-target.a, target.a-@a\n        return v1.cross(v2).abs > 0.0 || v1.cross(v3).abs == 0.0\n    end\n  end\n  # 直線上に射影した点\n  def projection(p)\n    v1, v2 = p-a, a-b\n    a + v2.times(v1.dot(v2)/v2.norm)\n  end\n  # 直線に関して対象な点\n  def reflection(p)\n    p + (projection(p) - p).times(2.0)\n  end\n  # 距離\n  def distance(target)\n    case target.class\n      when Point\n        return (target - projection(target)).abs\n      when Segment\n        return intersect?(target) ? 0.0 : [distance(target.a), distance(target.b)].min\n      when Line\n        return intersect?(target) ? 0.0 : distance(target.a)\n    end\n  end\n  # 交点\n  def crosspoint(l)\n    v1, v2, v3 = @b-@a, l.b-l.a, @b-l.a\n    a, b = v1.cross(v2), v1.cross(v3)\n    return l.a if a.abs <= EPS && b.abs <= EPS\n    l.a + v2.times(b/a)\n  end\nend\n\nclass Segment < Line\n  # 交差判定\n  def intersect?(target)\n    case target.class\n      when Point\n        return (@a-target).abs + (@b-target).abs == (@b-@a).abs\n      when Segment\n        return target.ccw(@a) * target.ccw(@b) <= 0 && ccw(target.a) * ccw(target.b) <= 0\n      when Line\n        return target.intersect?(self)\n    end\n  end\n  # 距離\n  def distance(target)\n    case target.class\n      when Point\n        p = projection(target)\n        return intersect?(p) ? (p-target).abs : [(@a-target).abs, (@b-target).abs].min\n      when Segment\n        return intersect?(target) ? 0.0 : [distance(target.a), distance(target.b), target.distance(@a), target.distance(@b)].min\n      when Line\n        return target.distance(self)\n    end\n  end\nend\n\n#交点、同一直線上、一点で交わる　→　凶\nedge = Array.new\nuntil (x1,y1,x2,y2=gets.split.map(&:to_i)).all?(&:zero?) do\n  edge.push(Segment.new(Point.new(x1,y1), Point.new(x2,y2)))\n  next if edge.size < 3\n  point = Array.new\n  for i in 0...3 do\n    break unless edge[i].intersect?(edge[(i+1)%3])\n    break if edge[i].intersect?(edge[(i+1)%3].a) && edge[i].intersect?(edge[(i+1)%3].b)\n    point.push(edge[i].crosspoint(edge[(i+1)%3]))\n  end\n  s = 0\n  unless point.size<3 || point[0]==point[1] || point[1]==point[2] || point[2]==point[0]\n    x1 = point[1].x - point[0].x\n    y1 = point[1].y - point[0].y\n    x2 = point[2].x - point[0].x\n    y2 = point[2].y - point[0].y\n    s = (x1*y2 - x2*y1).abs/2.0\n  end\n  if s==0\n    puts \"kyo\"\n  elsif s<100000\n    puts \"sho-kichi\"\n  elsif s<1000000\n    puts \"kichi\"\n  elsif s<1900000\n    puts \"chu-kichi\"\n  else\n    puts \"dai-kichi\"\n  end\n  edge.clear\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\t\"os\"\n\t\"strings\"\n\t\"strconv\"\n\t\"fmt\"\n\t\"math\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\ntype Point struct {\n\tx, y float64\n}\nfunc main() {\n\tfor scanner.Scan() {\n\t\tbuf1 := strings.Split(scanner.Text(), \" \")\n\t\tline1 := make([]float64, len(buf1))\n\t\tfor i := range line1 {\n\t\t\tline1[i], _ = strconv.ParseFloat(buf1[i], 64)\n\t\t}\n\t\tif line1[0] == 0 && line1[1] == 0 &&\n\t\t\tline1[2] == 0 && line1[3] == 0 {\n\t\t\t\tbreak\n\t\t}\n\t\tscanner.Scan()\n\t\tbuf2 := strings.Split(scanner.Text(), \" \")\n\t\tline2 := make([]float64, len(buf2))\n\t\tfor i := range line2 {\n\t\t\tline2[i], _ = strconv.ParseFloat(buf2[i], 64)\n\t\t}\n\t\tscanner.Scan()\n\t\tbuf3 := strings.Split(scanner.Text(), \" \")\n\t\tline3 := make([]float64, len(buf3))\n\t\tfor i := range line2 {\n\t\t\tline3[i], _ = strconv.ParseFloat(buf3[i], 64)\n\t\t}\n\t\tif !intersect(line1[0], line1[1], line1[2], line1[3], line2[0], line2[1], line2[2], line2[3]) ||\n\t\t\t!intersect(line2[0], line2[1], line2[2], line2[3], line3[0], line3[1], line3[2], line3[3]) ||\n\t\t\t!intersect(line3[0], line3[1], line3[2], line3[3], line1[0], line1[1], line1[2], line1[3]) {\n\t\t\t\tfmt.Println(\"kyo\")\n\t\t} else {\n\t\t\tp1 := intersection(line1[0], line1[1], line1[2], line1[3], line2[0], line2[1], line2[2], line2[3])\n\t\t\tp2 := intersection(line2[0], line2[1], line2[2], line2[3], line3[0], line3[1], line3[2], line3[3])\n\t\t\tp3 := intersection(line3[0], line3[1], line3[2], line3[3], line1[0], line1[1], line1[2], line1[3])\n\t\t\tarea := math.Abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x))/2\n\t\t\tif area < 0.00000001 {\n\t\t\t\tfmt.Println(\"kyo\")\n\t\t\t} else if 1899999.99999999 < area {\n\t\t\t\tfmt.Println(\"dai-kichi\")\n\t\t\t} else if 999999.99999999 < area {\n\t\t\t\tfmt.Println(\"chu-kichi\")\n\t\t\t} else if 99999.99999999 < area {\n\t\t\t\tfmt.Println(\"kichi\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"syo-kichi\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc cross(x1, y1, x2, y2 float64) int {\n\tz :=  x1 * y2 - y1 * x2\n\tif 0 < z {\n\t\treturn 1\n\t} else if z < 0 {\n\t\treturn -1\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc intersect(x1, y1, x2, y2, x3, y3, x4, y4 float64) bool {\n\tif 0 <= cross(x2-x1, y2-y1, x3-x1, y3-y1) *\n\t\tcross(x2-x1, y2-y1, x4-x1, y4-y1) {\n\t\t\treturn false\n\t}\n\tif 0 <= cross(x4-x3, y4-y3, x1-x3, y1-y3) *\n\t\tcross(x4-x3, y4-y3, x2-x3, y2-y3) {\n\t\t\treturn false\n\t}\n\treturn true\n}\n\nfunc intersection(x1, y1, x2, y2, x3, y3, x4, y4 float64) Point {\n\tif x3 == x4 {\n\t\tx1, x3 = x3, x1\n\t\ty1, y3 = y3, y1\n\t\tx2, x4 = x4, x2\n\t\ty2, y4 = y4, y2\n\t}\n\tret := Point{}\n\tif x1 == x2 {\n\t\t// y軸に平行な直線の場合\n\t\tc := (y4 - y3) / (x4 - x3)\n\t\td := y3 - c * x3\n\t\tx := x1\n\t\ty := c * x + d\n\t\tret.x, ret.y = x, y\n\t} else {\n\t\ta := (y2 - y1) / (x2 - x1)\n\t\tb := y1 - a * x1\n\t\tc := (y4 - y3) / (x4 - x3)\n\t\td := y3 - c * x3\n\t\tx := (d - b) / (a - c)\n\t\ty := a * x + b\n\t\tret.x, ret.y = x, y\n\t}\n\treturn ret\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double y, x;\n    Point opBinary(string op)(in Point a) const {\n        static if (op == \"+\" || op == \"-\") {\n            return Point(mixin(\"y\" ~ op ~ \"a.y\"),\n                         mixin(\"x\" ~ op ~ \"a.x\"));\n        }\n    }\n    Point opBinary(string op)(double a) const {\n        static if (op == \"*\" || op == \"/\") {\n            return Point(mixin(\"y\" ~ op ~ \"a\"),\n                         mixin(\"x\" ~ op ~ \"a\"));\n        }\n    }\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\nint CCW(Point a, Point b, Point c) {\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;\n    if (cross(b, c) < EPS) return -1;\n    if (dot(b, c) < 0) return +2;\n    if (b.norm < c.norm) return -2;\n    return 0;\n}\n \nvoid main() {\n    Point[] segs = new Point[3];\n    Point[] segt = new Point[3];\n    bool input() {\n        auto ps = readln.chomp.split(\" \").map!(to!double).array;\n        if (ps.all!\"a == 0\") return false;\n        segs[0].x = ps[0]; segs[0].y = ps[1];\n        segt[0].x = ps[2]; segt[0].y = ps[3];\n        foreach (i; 1 .. 3) {\n            ps = readln.chomp.split(\" \").map!(to!double).array;\n            segs[i].x = ps[0]; segs[i].y = ps[1];\n            segt[i].x = ps[2]; segt[i].y = ps[3];\n        }\n        return true;\n    }\n\n    bool intersect(in Point s1, in Point t1,\n            in Point s2, in Point t2) {\n        return CCW(s1, t1, s2) * CCW(s1, t1, t2) <= 0 &&\n            CCW(s2, t2, s1) * CCW(s2, t2, t1) <= 0;\n    }\n\n    Point iPoint(in Point s1, in Point t1,\n            in Point s2, in Point t2) {\n        double d = cross(t1 - s1, t2 - s2);\n        return s1 + (t1 - s1) * (cross(t2 - s2, t2 - s1) / d);\n    }\n\n    void solve() {\n        foreach (i; 0 .. 3) {\n            if (!intersect(segs[i], segt[i], \n                        segs[(i + 1) % 3], segt[(i + 1) % 3])) {\n                writeln(\"kyo\"); return;\n            }\n        }\n        auto vs = new Point[3];\n        foreach (i; 0 .. 3) {\n            vs[i] = iPoint(segs[i], segt[i], \n                        segs[(i + 1) % 3], segt[(i + 1) % 3]);\n        }\n        foreach (i; 0 .. 3) {\n            if (vs[i] == vs[(i + 1) % 3]) {\n                writeln(\"kyo\"); return;\n            }\n        }\n        double area = cross(vs[2] - vs[0], vs[1] - vs[0]).abs / 2;\n        if (1_900_000 <= area) {\n            writeln(\"dai-kichi\");\n        } else if (1_000_000 <= area) {\n            writeln(\"chu-kichi\");\n        } else if (100_000 <= area) {\n            writeln(\"kichi\");\n        } else if (0 < area) {\n            writeln(\"syo-kichi\");\n        } else {\n            writeln(\"kyo\");\n        }\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double y, x;\n    Point opBinary(string op)(in Point a) const {\n        static if (op == \"+\" || op == \"-\") {\n            return Point(mixin(\"y\" ~ op ~ \"a.y\"),\n                         mixin(\"x\" ~ op ~ \"a.x\"));\n        }\n    }\n    Point opBinary(string op)(double a) const {\n        static if (op == \"*\" || op == \"/\") {\n            return Point(mixin(\"y\" ~ op ~ \"a\"),\n                         mixin(\"x\" ~ op ~ \"a\"));\n        }\n    }\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\nint CCW(Point a, Point b, Point c) {\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;\n    if (cross(b, c) < EPS) return -1;\n    if (dot(b, c) < 0) return +2;\n    if (b.norm < c.norm) return -2;\n    return 0;\n}\n \nvoid main() {\n    Point[] segs = new Point[3];\n    Point[] segt = new Point[3];\n    bool input() {\n        auto ps = readln.chomp.split(\" \").map!(to!double).array;\n        if (ps.all!\"a == 0\") return false;\n        segs[0].x = ps[0]; segs[0].y = ps[1];\n        segt[0].x = ps[2]; segt[0].y = ps[3];\n        foreach (i; 1 .. 3) {\n            ps = readln.chomp.split(\" \").map!(to!double).array;\n            segs[i].x = ps[0]; segs[i].y = ps[1];\n            segt[i].x = ps[2]; segt[i].y = ps[3];\n        }\n        return true;\n    }\n\n    bool intersect(in Point s1, in Point t1,\n            in Point s2, in Point t2) {\n        return CCW(s1, t1, s2) * CCW(s1, t1, t2) <= 0 &&\n            CCW(s2, t2, s1) * CCW(s2, t2, t1) <= 0;\n    }\n\n    Point iPoint(in Point s1, in Point t1,\n            in Point s2, in Point t2) {\n        double d = cross(t2 - s2, t1 - s1);\n        return s1 + (t1 - s1) * (cross(t2 - s2, t2 - s1) / d);\n    }\n\n    void solve() {\n        foreach (i; 0 .. 3) {\n            if (!intersect(segs[i], segt[i], \n                        segs[(i + 1) % 3], segt[(i + 1) % 3])) {\n                writeln(\"kyo\"); return;\n            }\n        }\n        auto vs = new Point[3];\n        foreach (i; 0 .. 3) {\n            vs[i] = iPoint(segs[i], segt[i], \n                        segs[(i + 1) % 3], segt[(i + 1) % 3]);\n        }\n        foreach (i; 0 .. 3) {\n            if (vs[i] == vs[(i + 1) % 3]) {\n                writeln(\"kyo\"); return;\n            }\n        }\n        double area = cross(vs[2] - vs[0], vs[1] - vs[0]).abs / 2;\n        if (1_900_000 <= area) {\n            writeln(\"dai-kichi\");\n        } else if (1_000_000 <= area) {\n            writeln(\"chu-kichi\");\n        } else if (100_000 <= area) {\n            writeln(\"kichi\");\n        } else if (0 < area) {\n            writeln(\"syo-kichi\");\n        } else {\n            writeln(\"kyo\");\n        }\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.typecons;\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double y, x;\n    Point opBinary(string op)(in Point a) const {\n        static if (op == \"+\" || op == \"-\") {\n            return Point(mixin(\"y\" ~ op ~ \"a.y\"),\n                         mixin(\"x\" ~ op ~ \"a.x\"));\n        }\n    }\n    Point opBinary(string op)(double a) const {\n        static if (op == \"*\" || op == \"/\") {\n            return Point(mixin(\"y\" ~ op ~ \"a\"),\n                         mixin(\"x\" ~ op ~ \"a\"));\n        }\n    }\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\nint CCW(Point a, Point b, Point c) {\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;\n    if (cross(b, c) < EPS) return -1;\n    if (dot(b, c) < 0) return +2;\n    if (b.norm < c.norm) return -2;\n    return 0;\n}\n \nvoid main() {\n    Point[] segs = new Point[3];\n    Point[] segt = new Point[3];\n    bool input() {\n        auto ps = readln.chomp.split(\" \").map!(to!double).array;\n        if (ps.all!((p) => p == 0)) return false;\n        segs[0].x = ps[0]; segs[0].y = ps[1];\n        segt[0].x = ps[2]; segt[0].y = ps[3];\n        foreach (i; 1 .. 3) {\n            ps = readln.chomp.split(\" \").map!(to!double).array;\n            segs[i].x = ps[0]; segs[i].y = ps[1];\n            segt[i].x = ps[2]; segt[i].y = ps[3];\n        }\n        return true;\n    }\n\n    bool intersect(in Point s1, in Point t1,\n            in Point s2, in Point t2) {\n        return CCW(s1, t1, s2) * CCW(s1, t1, t2) <= 0 &&\n            CCW(s2, t2, s1) * CCW(s2, t2, t1) <= 0;\n    }\n\n    Point iPoint(in Point s1, in Point t1,\n            in Point s2, in Point t2) {\n        double d = cross(t1 - s1, t2 - s2);\n        return s1 + (t1 - s1) * (cross(t2 - s2, t2 - s1) / d);\n    }\n\n    void solve() {\n        foreach (i; 0 .. 3) {\n            if (!intersect(segs[i], segt[i], \n                        segs[(i + 1) % 3], segt[(i + 1) % 3])) {\n                writeln(\"kyo\"); return;\n            }\n        }\n        auto vs = new Point[3];\n        foreach (i; 0 .. 3) {\n            vs[i] = iPoint(segs[i], segt[i], \n                        segs[(i + 1) % 3], segt[(i + 1) % 3]);\n        }\n        foreach (i; 0 .. 3) {\n            if (vs[i] == vs[(i + 1) % 3]) {\n                writeln(\"kyo\"); return;\n            }\n        }\n        double area = cross(vs[2] - vs[0], vs[1] - vs[0]).abs / 2;\n        if (1_900_000 <= area) {\n            writeln(\"dai-kichi\");\n        } else if (1_000_000 <= area) {\n            writeln(\"chu-kichi\");\n        } else if (100_000 <= area) {\n            writeln(\"kichi\");\n        } else if (0 < area) {\n            writeln(\"syo-kichi\");\n        } else {\n            writeln(\"kyo\");\n        }\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "def cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef outer(x0, y0, x1, y1):\n    return x0*y1 - x1*y0\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    if C0 == C1 == 0:\n        return 0\n    return C0 * C1 <= 0 and D0 * D1 <= 0\ndef cross_point(P0, Q0, P1, Q1):\n    x0, y0 = P0; x1, y1 = Q0\n    x2, y2 = P1; x3, y3 = Q1\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    if s == 0:\n        x = x0\n        y = y0\n    else:\n        x = x0 + s*dx0/sm\n        y = y0 + s*dy0/sm\n    return x, y\nwhile 1:\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 == y1 == x2 == y2 == 0:\n        break\n    P1 = (x1, y1); Q1 = (x2, y2)\n    x3, y3, x4, y4 = map(int, input().split())\n    P2 = (x3, y3); Q2 = (x4, y4)\n    x5, y5, x6, y6 = map(int, input().split())\n    P3 = (x5, y5); Q3 = (x6, y6)\n    if (not is_intersection(P1, Q1, P2, Q2)\n            or not is_intersection(P2, Q2, P3, Q3)\n            or not is_intersection(P3, Q3, P1, Q1)):\n        print(\"kyo\")\n        continue\n    p1, q1 = cross_point(P1, Q1, P2, Q2)\n    p2, q2 = cross_point(P2, Q2, P3, Q3)\n    p3, q3 = cross_point(P3, Q3, P1, Q1)\n    S = abs(outer(p2-p1, q2-q1, p3-p1, q3-q1)) / 2.\n    if S < 1e-9:\n        print(\"kyo\")\n    elif S < 100000:\n        print(\"syo-kichi\")\n    elif S < 1000000:\n        print(\"kichi\")\n    elif S < 1900000:\n        print(\"chu-kichi\")\n    else:\n        print(\"dai-kichi\")\n"
  },
  {
    "language": "Python",
    "code": "def isX(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx)\n    td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx)\n    return tc*td < 0\n    \ndef ip(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    dn = ((by-ay)*(dx-cx)-(bx-ax)*(dy-cy))*1.0\n    x = ((cy*dx-cx*dy)*(bx-ax)-(ay*bx-ax*by)*(dx-cx))/dn\n    y = ((cy*dx-cx*dy)*(by-ay)-(ay*bx-ax*by)*(dy-cy))/dn\n    return x,y\n\nwhile 1:\n    xy1 = map(int,raw_input().split())\n    if xy1.count(0) == 4: break\n    xy2 = map(int,raw_input().split())\n    xy3 = map(int,raw_input().split())\n    if isX(xy1,xy2) and isX(xy2,xy3) and isX(xy3,xy1):\n        x1,y1 = ip(xy1,xy2); x2,y2 = ip(xy2,xy3); x3,y3 = ip(xy3,xy1)\n        S = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\n        if   S >= 1900000*2: print \"dai-kichi\"\n        elif S >= 1000000*2: print \"chu-kichi\"\n        elif S >= 100000*2 : print \"kichi\"\n        else               : print \"syo-kichi\"\n    else:\n        print \"kyo\""
  },
  {
    "language": "Python",
    "code": "def denomi(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    return (by-ay)*(dx-cx)-(bx-ax)*(dy-cy)\n    \ndef getip(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    dn = denomi(xy1,xy2)*1.0\n    x = ((cy*dx-cx*dy)*(bx-ax)-(ay*bx-ax*by)*(dx-cx))/dn\n    y = ((cy*dx-cx*dy)*(by-ay)-(ay*bx-ax*by)*(dy-cy))/dn\n    return x,y\n \ndef ison(x,y,xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    if min(cx,dx) <= x <= max(cx,dx) and min(cy,dy) <= y <= max(cy,dy):\n            if min(ax,bx) <= x <= max(ax,bx) and min(ay,by) <= y <= max(ay,by):\n                return True\n    return False\n\nwhile 1:\n    xy1 = map(int,raw_input().split())\n    if xy1.count(0) == 4: break\n    xy2 = map(int,raw_input().split())\n    xy3 = map(int,raw_input().split())\n    if denomi(xy1,xy2) != 0 and denomi(xy2,xy3) != 0 and denomi(xy3,xy1) != 0:\n        x1,y1 = getip(xy1,xy2)\n        x2,y2 = getip(xy2,xy3)\n        x3,y3 = getip(xy3,xy1)\n    if ison(x1,y1,xy1,xy2) and ison(x2,y2,xy2,xy3) and ison(x3,y3,xy3,xy1):\n        S = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2.0\n        if   S >= 1900000: print \"dai-kichi\"\n        elif S >= 1000000: print \"chu-kichi\"\n        elif S >= 100000 : print \"kichi\"\n        else             : print \"syo-kichi\"\n    else:\n        print \"kyo\"\n    "
  },
  {
    "language": "Python",
    "code": "def denomi(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    return (by-ay)*(dx-cx)-(bx-ax)*(dy-cy)\n    \ndef getip(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    dn = denomi(xy1,xy2)*1.0\n    x = ((cy*dx-cx*dy)*(bx-ax)-(ay*bx-ax*by)*(dx-cx))/dn\n    y = ((cy*dx-cx*dy)*(by-ay)-(ay*bx-ax*by)*(dy-cy))/dn\n    return x,y\n \ndef ison(x,y,xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    if min(cx,dx) <= x <= max(cx,dx) and min(cy,dy) <= y <= max(cy,dy):\n            if min(ax,bx) <= x <= max(ax,bx) and min(ay,by) <= y <= max(ay,by):\n                return True\n    return False\n\nwhile 1:\n    xy1 = map(int,raw_input().split())\n    if xy1.count(0) == 4: break\n    xy2 = map(int,raw_input().split())\n    xy3 = map(int,raw_input().split())\n    if denomi(xy1,xy2) != 0 and denomi(xy2,xy3) != 0 and denomi(xy3,xy1) != 0:\n        x1,y1 = getip(xy1,xy2)\n        x2,y2 = getip(xy2,xy3)\n        x3,y3 = getip(xy3,xy1)\n        if ison(x1,y1,xy1,xy2) and ison(x2,y2,xy2,xy3) and ison(x3,y3,xy3,xy1):\n            S = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2.0\n            if   S >= 1900000: print \"dai-kichi\"\n            elif S >= 1000000: print \"chu-kichi\"\n            elif S >= 100000 : print \"kichi\"\n            else             : print \"syo-kichi\"\n        else:\n            print \"kyo\"\n    else:\n        print \"kyo\""
  },
  {
    "language": "Python",
    "code": "def iscross(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx)\n    td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx)\n    return tc*td < 0\n    \ndef getip(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    dn = ((by-ay)*(dx-cx)-(bx-ax)*(dy-cy))*1.0\n    x = ((cy*dx-cx*dy)*(bx-ax)-(ay*bx-ax*by)*(dx-cx))/dn\n    y = ((cy*dx-cx*dy)*(by-ay)-(ay*bx-ax*by)*(dy-cy))/dn\n    return x,y\n\nwhile 1:\n    xy1 = map(int,raw_input().split())\n    if xy1.count(0) == 4: break\n    xy2 = map(int,raw_input().split())\n    xy3 = map(int,raw_input().split())\n    if iscross(xy1,xy2) and iscross(xy2,xy3) and iscross(xy3,xy1):\n        x1,y1 = getip(xy1,xy2)\n        x2,y2 = getip(xy2,xy3)\n        x3,y3 = getip(xy3,xy1)\n        S = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2.0\n        if   S >= 1900000: print \"dai-kichi\"\n        elif S >= 1000000: print \"chu-kichi\"\n        elif S >= 100000 : print \"kichi\"\n        else             : print \"syo-kichi\"\n    else:\n        print \"kyo\""
  },
  {
    "language": "Python",
    "code": "def isX(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx)\n    td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx)\n    return tc*td < 0\n    \ndef ip(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    dn = ((by-ay)*(dx-cx)-(bx-ax)*(dy-cy))*1.0\n    x = ((cy*dx-cx*dy)*(bx-ax)-(ay*bx-ax*by)*(dx-cx))/dn\n    y = ((cy*dx-cx*dy)*(by-ay)-(ay*bx-ax*by)*(dy-cy))/dn\n    return x,y\n\nwhile 1:\n    xy1 = map(int,raw_input().split())\n    if xy1.count(0) == 4: break\n    xy2 = map(int,raw_input().split())\n    xy3 = map(int,raw_input().split())\n    if isX(xy1,xy2) and isX(xy2,xy3) and isX(xy3,xy1):\n        x1,y1 = ip(xy1,xy2); x2,y2 = ip(xy2,xy3); x3,y3 = ip(xy3,xy1)\n        S = abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2.0\n        if   S >= 1900000: print \"dai-kichi\"\n        elif S >= 1000000: print \"chu-kichi\"\n        elif S >= 100000 : print \"kichi\"\n        elif S > 0       : print \"syo-kichi\"\n        else             : print \"kyo\"\n    else:\n        print \"kyo\""
  },
  {
    "language": "Python",
    "code": "# Aizu Problem 0187: Stoning Fortune\n#\nimport sys, math, os, bisect\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\ndef on_segment(p, q, r):\n    # Given three colinear points p, q, r, the function checks if\n    # point q lies on line segment 'pr'\n    return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and \\\n           q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])\n\ndef orientation(p, q, r):\n    # To find orientation of ordered triplet (p, q, r).\n    # The function returns following values\n    #   0 --> p, q and r are colinear\n    #   1 --> Clockwise\n    #   2 --> Counterclockwise\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\n\ndef do_intersect(p1, q1, p2, q2):\n    # The main function that returns true if line segment 'p1q1'\n    # and 'p2q2' intersect.\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    #\n    # General case:\n    if o1 != o2 and o3 != o4:\n        return True\n    #\n    # Special Cases:\n    # \n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    # p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    #  p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    # Doesn't fall in any of the above cases:\n    return False\n\n\ndef ip(xy1,xy2):\n    ax,ay,bx,by = xy1; cx,cy,dx,dy = xy2\n    dn = ((by-ay)*(dx-cx)-(bx-ax)*(dy-cy))*1.0\n    x = ((cy*dx-cx*dy)*(bx-ax)-(ay*bx-ax*by)*(dx-cx))/dn\n    y = ((cy*dx-cx*dy)*(by-ay)-(ay*bx-ax*by)*(dy-cy))/dn\n    return x,y\n \ndef stoning_fortune(coord1, coord2, coord3):\n    p1, q1 = coord1[:2], coord1[2:]\n    p2, q2 = coord2[:2], coord2[2:]\n    p3, q3 = coord3[:2], coord3[2:]\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or \\\n       not do_intersect(p3, q3, p2, q2) :\n        return \"kyo\"\n    x1, y1 = ip(coord1, coord2)\n    x2, y2 = ip(coord2, coord3)\n    x3, y3 = ip(coord3, coord1)\n    area = abs(.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return \"dai-kichi\"\n    elif area >= 1000000:\n        return \"chu-kichi\"\n    elif area >= 100000:\n        return \"kichi\"\n    elif area > 0:\n        return \"syo-kichi\"\n    else:\n        return \"kyo\"\n    \n    \nwhile True:\n    coord1 = [int(_) for _ in input().split()]\n    if coord1 == [0, 0, 0, 0]:\n        break\n    coord2 = [int(_) for _ in input().split()]\n    coord3 = [int(_) for _ in input().split()]\n    print(stoning_fortune(coord1, coord2, coord3))"
  }
]