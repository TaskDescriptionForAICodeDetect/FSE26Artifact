[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n#define MAX_M 200005\n\nint parent[MAX_N];\nint rank[MAX_N];\nint weights[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    \n    if (rootX == rootY) return;\n    \n    if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n    } else if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n    } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &weights[i]);\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    typedef struct {\n        int u, v, w;\n    } Edge;\n    \n    Edge edges[MAX_M];\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        for (int j = i + 1; j < M; j++) {\n            if (edges[i].w > edges[j].w) {\n                Edge temp = edges[i];\n                edges[i] = edges[j];\n                edges[j] = temp;\n            }\n        }\n    }\n    \n    int removedEdges = 0;\n    \n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int w = edges[i].w;\n        \n        int rootU = find(u);\n        int rootV = find(v);\n        \n        int componentSum = 0;\n        for (int j = 1; j <= N; j++) {\n            if (find(j) == rootU || find(j) == rootV) {\n                componentSum += weights[j];\n            }\n        }\n        \n        if (componentSum < w) {\n            removedEdges++;\n        } else {\n            unionSet(u, v);\n        }\n    }\n    \n    printf(\"%d\\n\", removedEdges);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int u, v, y;\n} Edge;\n\nint parent[100001];\nlong long sum[100001];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nint compare(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeB->y - edgeA->y;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%lld\", &sum[i]);\n        parent[i] = i;\n    }\n\n    Edge edges[100001];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].y);\n    }\n\n    qsort(edges, M, sizeof(Edge), compare);\n\n    int removed = 0;\n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int y = edges[i].y;\n\n        int rootU = find(u);\n        int rootV = find(v);\n\n        if (rootU != rootV) {\n            if (sum[rootU] + sum[rootV] >= y) {\n                parent[rootV] = rootU;\n                sum[rootU] += sum[rootV];\n            } else {\n                removed++;\n            }\n        } else {\n            if (sum[rootU] < y) {\n                removed++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", removed);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int a, b;\n    long long y;\n    int index;\n};\n\nvector<int> parent;\nvector<long long> sum;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid unite(int u, int v, long long x) {\n    int root_u = find(u);\n    int root_v = find(v);\n    if (root_u != root_v) {\n        parent[root_v] = root_u;\n        sum[root_u] += sum[root_v];\n    }\n}\n\nbool compareEdges(const Edge &a, const Edge &b) {\n    return a.y > b.y;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<long long> X(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> X[i];\n    }\n    vector<Edge> edges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> edges[i].a >> edges[i].b >> edges[i].y;\n        edges[i].a--;\n        edges[i].b--;\n        edges[i].index = i;\n    }\n    sort(edges.begin(), edges.end(), compareEdges);\n\n    parent.resize(N);\n    sum.resize(N);\n    for (int i = 0; i < N; ++i) {\n        parent[i] = i;\n        sum[i] = X[i];\n    }\n\n    int removed = 0;\n    for (const Edge &e : edges) {\n        int root_a = find(e.a);\n        int root_b = find(e.b);\n        if (root_a == root_b) {\n            if (sum[root_a] < e.y) {\n                removed++;\n            }\n        } else {\n            if (sum[root_a] + sum[root_b] >= e.y) {\n                unite(e.a, e.b, 0);\n            } else {\n                removed++;\n            }\n        }\n    }\n\n    cout << removed << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass DSU {\n    private int[] parent;\n    private long[] sum;\n\n    public DSU(int n, long[] X) {\n        parent = new int[n + 1];\n        sum = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n            sum[i] = X[i - 1];\n        }\n    }\n\n    public int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    public void union(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU != rootV) {\n            parent[rootV] = rootU;\n            sum[rootU] += sum[rootV];\n        }\n    }\n\n    public long getSum(int u) {\n        return sum[find(u)];\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        long[] X = new long[N];\n        for (int i = 0; i < N; i++) {\n            X[i] = sc.nextLong();\n        }\n        List<int[]> edges = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt();\n            int B = sc.nextInt();\n            long Y = sc.nextLong();\n            edges.add(new int[]{A, B, (int) Y});\n        }\n        edges.sort((a, b) -> Integer.compare(b[2], a[2]));\n        DSU dsu = new DSU(N, X);\n        int removed = 0;\n        for (int[] edge : edges) {\n            int A = edge[0];\n            int B = edge[1];\n            int Y = edge[2];\n            if (dsu.getSum(A) < Y) {\n                removed++;\n            } else {\n                dsu.union(A, B);\n            }\n        }\n        System.out.println(removed);\n    }\n}",
    "timestamp": "2025-08-05 22:57:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Edge {\n        int u, v, weight;\n        Edge(int u, int v, int weight) {\n            this.u = u;\n            this.v = v;\n            this.weight = weight;\n        }\n    }\n\n    static int[] parent;\n    static int[] rank;\n\n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) return;\n        \n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n\n    public static int minimumEdgesToRemove(int N, int[] vertexWeights, Edge[] edges) {\n        parent = new int[N + 1];\n        rank = new int[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n\n        int edgesToRemove = 0;\n        for (Edge edge : edges) {\n            int u = edge.u, v = edge.v;\n            int rootU = find(u);\n            int rootV = find(v);\n            \n            int componentWeight = 0;\n            for (int vertex : new int[]{rootU, rootV}) {\n                componentWeight += vertexWeights[vertex];\n            }\n            \n            if (componentWeight < edge.weight) {\n                edgesToRemove++;\n            } else {\n                union(u, v);\n            }\n        }\n\n        return edgesToRemove;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int N = 4;\n        int[] vertexWeights = {0, 1, 2, 3, 4};  // 0-indexed, so first 0 is ignored\n        Edge[] edges = {\n            new Edge(1, 2, 3),\n            new Edge(2, 3, 4),\n            new Edge(3, 4, 5)\n        };\n        \n        System.out.println(minimumEdgesToRemove(N, vertexWeights, edges));\n    }\n}",
    "timestamp": "2025-08-05 22:57:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n    vector<long long> componentWeight;\n\npublic:\n    UnionFind(int n, vector<long long>& weights) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        componentWeight = weights;\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX == rootY) return false;\n\n        if (rank[rootX] < rank[rootY]) {\n            swap(rootX, rootY);\n        }\n        parent[rootY] = rootX;\n        componentWeight[rootX] += componentWeight[rootY];\n\n        if (rank[rootX] == rank[rootY]) {\n            rank[rootX]++;\n        }\n        return true;\n    }\n\n    long long getComponentWeight(int x) {\n        return componentWeight[find(x)];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M;\n    cin >> N >> M;\n\n    vector<long long> weights(N);\n    for (int i = 0; i < N; i++) {\n        cin >> weights[i];\n    }\n\n    vector<tuple<int, int, long long>> edges(M);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        long long y;\n        cin >> a >> b >> y;\n        a--; b--;\n        edges[i] = {a, b, y};\n    }\n\n    sort(edges.begin(), edges.end(), [](const auto& e1, const auto& e2) {\n        return get<2>(e1) < get<2>(e2);\n    });\n\n    int removedEdges = 0;\n    UnionFind uf(N, weights);\n\n    for (auto& [a, b, y] : edges) {\n        int rootA = uf.find(a);\n        int rootB = uf.find(b);\n\n        if (rootA != rootB) {\n            long long componentWeight = uf.getComponentWeight(a) + uf.getComponentWeight(b);\n            if (componentWeight >= y) {\n                uf.unite(a, b);\n            } else {\n                removedEdges++;\n            }\n        }\n    }\n\n    cout << removedEdges << '\\n';\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_edges_to_remove(N, M, vertex_weights, edges):\n    from collections import defaultdict\n\n    class UnionFind:\n        def __init__(self, n):\n            self.parent = list(range(n))\n            self.rank = [0] * n\n            self.component_sum = [0] * n\n\n        def find(self, u):\n            if self.parent[u] != u:\n                self.parent[u] = self.find(self.parent[u])\n            return self.parent[u]\n\n        def union(self, u, v):\n            root_u = self.find(u)\n            root_v = self.find(v)\n            if root_u != root_v:\n                if self.rank[root_u] > self.rank[root_v]:\n                    self.parent[root_v] = root_u\n                elif self.rank[root_u] < self.rank[root_v]:\n                    self.parent[root_u] = root_v\n                else:\n                    self.parent[root_v] = root_u\n                    self.rank[root_u] += 1\n\n        def add_vertex_weight(self, u, weight):\n            self.component_sum[self.find(u)] += weight\n\n        def sum_in_component(self, u):\n            return self.component_sum[self.find(u)]\n\n    uf = UnionFind(N)\n    for i in range(N):\n        uf.add_vertex_weight(i, vertex_weights[i])\n\n    edge_list = sorted(edges, key=lambda x: -x[2])\n    removed_edges = 0\n\n    for a, b, y in edge_list:\n        if uf.find(a) != uf.find(b):\n            if uf.sum_in_component(a) >= y and uf.sum_in_component(b) >= y:\n                uf.union(a, b)\n                uf.add_vertex_weight(a, vertex_weights[b])\n            else:\n                removed_edges += 1\n        else:\n            component_sum = uf.sum_in_component(a)\n            if component_sum < y:\n                removed_edges += 1\n\n    return removed_edges\n\n# Example usage:\nN, M = 5, 5\nvertex_weights = [10, 20, 30, 40, 50]\nedges = [\n    (0, 1, 25),\n    (1, 2, 35),\n    (2, 3, 45),\n    (3, 4, 55),\n    (0, 4, 15)\n]\n\nprint(min_edges_to_remove(N, M, vertex_weights, edges))",
    "timestamp": "2025-08-13 13:05:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphSolution {\n    static class Edge {\n        int from;\n        int to;\n        int weight;\n        \n        Edge(int from, int to, int weight) {\n            this.from = from;\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    public static int minEdgesToRemove(int N, int M, int[] vertexWeights, int[] edgeWeights, int[] edgeFrom, int[] edgeTo) {\n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            edges.add(new Edge(edgeFrom[i], edgeTo[i], edgeWeights[i]));\n        }\n        \n        edges.sort(Comparator.comparingInt(e -> -e.weight));\n        \n        UnionFind uf = new UnionFind(N, vertexWeights);\n        int removedEdges = 0;\n        \n        for (Edge edge : edges) {\n            int rootFrom = uf.find(edge.from);\n            int rootTo = uf.find(edge.to);\n            \n            if (rootFrom != rootTo) {\n                int sumWeights = uf.getComponentWeight(rootFrom) + uf.getComponentWeight(rootTo);\n                if (sumWeights >= edge.weight) {\n                    uf.union(edge.from, edge.to);\n                } else {\n                    removedEdges++;\n                }\n            }\n        }\n        \n        return removedEdges;\n    }\n\n    static class UnionFind {\n        private final int[] parent;\n        private final int[] componentWeight;\n        \n        UnionFind(int size, int[] vertexWeights) {\n            parent = new int[size];\n            componentWeight = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n                componentWeight[i] = vertexWeights[i];\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX != rootY) {\n                parent[rootY] = rootX;\n                componentWeight[rootX] += componentWeight[rootY];\n            }\n        }\n        \n        int getComponentWeight(int x) {\n            return componentWeight[find(x)];\n        }\n    }\n    \n    public static void main(String[] args) {\n        int N = 3; // Number of vertices\n        int M = 3; // Number of edges\n        int[] vertexWeights = {1, 2, 3};\n        int[] edgeWeights = {3, 2, 1};\n        int[] edgeFrom = {0, 0, 1};\n        int[] edgeTo = {1, 2, 2};\n\n        int result = minEdgesToRemove(N, M, vertexWeights, edgeWeights, edgeFrom, edgeTo);\n        System.out.println(\"Minimum edges to remove: \" + result);\n    }\n}",
    "timestamp": "2025-08-13 13:06:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXN 100010\n#define MAXM 200020\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nEdge edges[MAXM];\nint parent[MAXN], size[MAXN], vertex_weight[MAXN], component_weight[MAXN];\nbool to_remove[MAXM];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_sets(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a != b) {\n        if (size[a] < size[b]) {\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        parent[b] = a;\n        size[a] += size[b];\n        component_weight[a] += component_weight[b];\n    }\n}\n\nint edge_cmp(const void *a, const void *b) {\n    return ((Edge *)b)->w - ((Edge *)a)->w;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d\", &vertex_weight[i]);\n        parent[i] = i;\n        size[i] = 1;\n        component_weight[i] = vertex_weight[i];\n    }\n\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n        to_remove[i] = false;\n    }\n\n    qsort(edges, m, sizeof(Edge), edge_cmp);\n\n    for (int i = 0; i < m; ++i) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int w = edges[i].w;\n\n        int pu = find(u);\n        int pv = find(v);\n\n        if (pu != pv) {\n            if (component_weight[pu] + component_weight[pv] >= w) {\n                union_sets(pu, pv);\n            } else {\n                to_remove[i] = true;\n            }\n        } else {\n            if (component_weight[pu] < w) {\n                to_remove[i] = true;\n            }\n        }\n    }\n\n    int removed = 0;\n    for (int i = 0; i < m; ++i) {\n        if (to_remove[i]) {\n            ++removed;\n        }\n    }\n\n    printf(\"%d\\n\", removed);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:06:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n};\n\nstruct DSU {\n    vector<int> parent, size, sum;\n    DSU(int n, const vector<int>& X) : parent(n), size(n, 1), sum(X) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    int find(int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            if (size[x] < size[y]) swap(x, y);\n            parent[y] = x;\n            sum[x] += sum[y];\n            size[x] += size[y];\n        }\n    }\n    int componentSum(int x) {\n        return sum[find(x)];\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> X(N);\n    for (int i = 0; i < N; ++i) cin >> X[i];\n    vector<Edge> edges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].weight;\n        --edges[i].u;\n        --edges[i].v;\n    }\n\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n        return a.weight > b.weight;\n    });\n\n    DSU dsu(N, X);\n    int removed = 0;\n\n    for (const auto& edge : edges) {\n        if (dsu.find(edge.u) != dsu.find(edge.v)) {\n            if (dsu.componentSum(edge.u) >= edge.weight || dsu.componentSum(edge.v) >= edge.weight) {\n                dsu.unite(edge.u, edge.v);\n            } else {\n                removed++;\n            }\n        }\n    }\n\n    cout << removed << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 13:06:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_graph_edge_removal(N, M, X, edges):\n    # Initialize disjoint set data structure\n    parent = list(range(N))\n    rank = [0] * N\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return False\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n        return True\n\n    # Sort edges by weight\n    edges.sort(key=lambda e: e[2])\n\n    # Track removed edges\n    removed_edges = 0\n\n    # Track component weights\n    component_weights = X.copy()\n\n    for a, b, weight in edges:\n        # Find component roots\n        root_a = find(a)\n        root_b = find(b)\n\n        # If not in same component\n        if root_a != root_b:\n            # Check if component weights satisfy constraint\n            if component_weights[root_a] + component_weights[root_b] >= weight:\n                # Merge components\n                union(a, b)\n                # Update component weight\n                component_weights[find(a)] = component_weights[root_a] + component_weights[root_b]\n            else:\n                # Cannot merge, must remove edge\n                removed_edges += 1\n\n    return removed_edges",
    "timestamp": "2025-08-13 13:06:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom heapq import heappop, heappush\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, M = map(int, input[ptr:ptr+2])\n    ptr +=2\n    X = list(map(int, input[ptr:ptr+N]))\n    ptr +=N\n    \n    edges = []\n    for _ in range(M):\n        a, b, y = map(int, input[ptr:ptr+3])\n        a -=1\n        b -=1\n        edges.append((y, a, b))\n        ptr +=3\n    \n    edges.sort()\n    \n    parent = [i for i in range(N)]\n    size = [1]*N\n    sum_x = X.copy()\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    res = 0\n    for y, a, b in edges:\n        root_a = find(a)\n        root_b = find(b)\n        if root_a != root_b:\n            if sum_x[root_a] + sum_x[root_b] >= y:\n                parent[root_b] = root_a\n                sum_x[root_a] += sum_x[root_b]\n            else:\n                res +=1\n        else:\n            if sum_x[root_a] < y:\n                res +=1\n    print(res)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 13:06:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class UnionFind {\n    constructor(size) {\n        this.parent = Array.from({ length: size }, (_, i) => i);\n        this.size = Array(size).fill(1);\n        this.weightSum = Array(size).fill(0);\n    }\n    \n    find(x) {\n        if (this.parent[x] !== x) {\n            this.parent[x] = this.find(this.parent[x]);\n        }\n        return this.parent[x];\n    }\n    \n    union(x, y) {\n        const rootX = this.find(x);\n        const rootY = this.find(y);\n        \n        if (rootX !== rootY) {\n            if (this.size[rootX] < this.size[rootY]) {\n                this.parent[rootX] = rootY;\n                this.size[rootY] += this.size[rootX];\n                this.weightSum[rootY] += this.weightSum[rootX];\n            } else {\n                this.parent[rootY] = rootX;\n                this.size[rootX] += this.size[rootY];\n                this.weightSum[rootX] += this.weightSum[rootY];\n            }\n        }\n    }\n    \n    addWeight(vertex, weight) {\n        this.weightSum[this.find(vertex)] += weight;\n    }\n    \n    getComponentWeight(vertex) {\n        return this.weightSum[this.find(vertex)];\n    }\n}\n\nfunction minEdgesToRemove(N, M, vertexWeights, edges) {\n    const unionFind = new UnionFind(N);\n    for (let i = 0; i < N; i++) {\n        unionFind.addWeight(i, vertexWeights[i]);\n    }\n    \n    edges.sort((a, b) => b[2] - a[2]); // Sort edges by weight descending\n    let removeCount = 0;\n    \n    for (let i = 0; i < M; i++) {\n        const [A, B, Y] = edges[i];\n        \n        const rootA = unionFind.find(A);\n        const rootB = unionFind.find(B);\n        \n        if (rootA !== rootB) {\n            if (unionFind.getComponentWeight(rootA) >= Y || unionFind.getComponentWeight(rootB) >= Y) {\n                unionFind.union(A, B);\n            } else {\n                removeCount++;\n            }\n        }\n    }\n    \n    return removeCount;\n}\n\n// Example Usage:\nconst N = 5;\nconst M = 6;\nconst vertexWeights = [10, 20, 30, 40, 50];\nconst edges = [\n    [0, 1, 25],\n    [1, 2, 35],\n    [2, 3, 45],\n    [3, 4, 55],\n    [0, 2, 15],\n    [1, 3, 5]\n];\n\nconsole.log(minEdgesToRemove(N, M, vertexWeights, edges)); // Output: the minimum number of edges to remove",
    "timestamp": "2025-08-13 13:06:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minEdgesToRemove(N, M, vertexWeights, edges) {\n    const parent = new Array(N).fill(0).map((_, i) => i);\n    const rank = new Array(N).fill(0);\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function union(x, y) {\n        let rootX = find(x);\n        let rootY = find(y);\n        if (rootX === rootY) return false;\n        \n        if (rank[rootX] < rank[rootY]) {\n            [rootX, rootY] = [rootY, rootX];\n        }\n        parent[rootY] = rootX;\n        if (rank[rootX] === rank[rootY]) {\n            rank[rootX]++;\n        }\n        return true;\n    }\n\n    let removedEdges = 0;\n    edges.sort((a, b) => a[2] - b[2]);\n\n    for (let [u, v, w] of edges) {\n        let rootU = find(u);\n        let rootV = find(v);\n\n        let componentSum = 0;\n        for (let i = 0; i < N; i++) {\n            if (find(i) === rootU || find(i) === rootV) {\n                componentSum += vertexWeights[i];\n            }\n        }\n\n        if (componentSum < w) {\n            removedEdges++;\n        } else {\n            union(u, v);\n        }\n    }\n\n    return removedEdges;\n}",
    "timestamp": "2025-08-13 13:06:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class UnionFind {\n    constructor(size) {\n        this.parent = Array.from({ length: size }, (_, i) => i);\n        this.size = Array(size).fill(1);\n        this.sum = Array(size).fill(0);\n    }\n\n    find(u) {\n        if (this.parent[u] !== u) {\n            this.parent[u] = this.find(this.parent[u]);\n        }\n        return this.parent[u];\n    }\n\n    union(u, v) {\n        const rootU = this.find(u);\n        const rootV = this.find(v);\n        if (rootU === rootV) return;\n\n        if (this.size[rootU] > this.size[rootV]) {\n            this.parent[rootV] = rootU;\n            this.size[rootU] += this.size[rootV];\n            this.sum[rootU] += this.sum[rootV];\n        } else {\n            this.parent[rootU] = rootV;\n            this.size[rootV] += this.size[rootU];\n            this.sum[rootV] += this.sum[rootU];\n        }\n    }\n}\n\nfunction solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const X = input[1].split(' ').map(Number);\n    const edges = [];\n    for (let i = 0; i < M; i++) {\n        const [A, B, Y] = input[2 + i].split(' ').map(Number);\n        edges.push({ u: A - 1, v: B - 1, weight: Y });\n    }\n\n    edges.sort((a, b) => a.weight - b.weight);\n    const uf = new UnionFind(N);\n    for (let i = 0; i < N; i++) {\n        uf.sum[i] = X[i];\n    }\n\n    let removedEdges = 0;\n    for (const edge of edges) {\n        const { u, v, weight } = edge;\n        const rootU = uf.find(u);\n        const rootV = uf.find(v);\n        if (rootU === rootV) {\n            if (uf.sum[rootU] < weight) {\n                removedEdges++;\n            }\n        } else {\n            if (uf.sum[rootU] + uf.sum[rootV] >= weight) {\n                uf.union(u, v);\n            } else {\n                removedEdges++;\n            }\n        }\n    }\n\n    console.log(removedEdges);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:07:11"
  }
]