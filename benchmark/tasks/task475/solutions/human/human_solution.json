[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nclass mes {\npublic:\n\tvector<int> c;\n\tstring s;\n};\n\nvector<mes> M;\nvoid f(int idx, int cnt) {\n\trep(i, 0, cnt)cout << \".\";\n\tcout << M[idx].s << endl;\n\trep(i, 0, M[idx].c.size()) {\n\t\tf(M[idx].c[i], cnt + 1);\n\t}\n}\n\nsigned main() {\n\tint n; cin >> n;\n\tM = vector<mes>(n);\n\trep(i, 0, n) {\n\t\tint k;\n\t\tstring s;\n\t\tcin >> k >> s;\n\t\tk--;\n\n\t\tif (k >= 0)M[k].c.emplace_back(i);\n\t\tM[i].s = s;\n\t}\n\tf(0, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 500000\n\nint n, a, depth[MAX_N];\nvector<int>x[MAX_N];\nstring p[MAX_N];\n\nvoid print(int b) {\n\tfor (int i = 0; i < x[b].size(); i++) {\n\t\tfor (int j = 0; j < depth[x[b][i]]; j++) { cout << '.'; }\n\t\tcout << p[x[b][i]] << endl;\n\t\tprint(x[b][i]);\n\t}\n\treturn;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a >> p[i];\n\t\tif (a >= 1) { x[a].push_back(i); depth[i] = depth[a] + 1; }\n\t\telse { depth[i] = 0; }\n\t}\n\tcout << p[1] << endl;\n\tprint(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<string> s(n);\n  vector<vector<int>> ch(n);\n  for (int i = 0; i < n; ++i) {\n    int p;\n    cin >> p;\n    --p;\n    cin >> s[i];\n    if (p >= 0) {\n      ch[p].push_back(i);\n    }\n  }\n  vector<int> d(n);\n  for (int i = 0; i < n; ++i) {\n    for (int j : ch[i]) {\n      d[j] = d[i] + 1;\n    }\n  }\n  auto dfs = [&](auto&& self, int v) -> void {\n    cout << string(d[v], '.') << s[v] << '\\n';\n    for (int u : ch[v]) {\n      self(self, u);\n    }\n  };\n  dfs(dfs, 0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N=1010;\n\nint n,k; string ans;\nvector<int> G[MAX_N];\nint dep[MAX_N];\nstring M[MAX_N];\n\nvoid dfs(int v,int p,string now){\n    cout << now << M[v] << '\\n';\n    now+='.';\n    for (int u:G[v]){\n        if (u==p) continue;\n        dep[u]=dep[v]+1;\n        dfs(u,v,now);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    for (int i=0;i<n;++i){\n        cin >> k >> M[i];\n        if (i) G[--k].emplace_back(i);\n    }\n    dep[0]=0;\n    dfs(0,-1,\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  AOJ 2619\n  Title:Thread tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint N;\nstruct node_st \n{\n  char message[51];\n  int  link_ch;         \n  int  link_br;\n} node[1001];\n \nvoid write_thread(int node_no,int depth)\n{\n  int i;\n  for(i=0;i<depth;i++)\n    printf(\".\");\n  printf(\"%s\\n\",node[node_no].message);\n  if(node[node_no].link_ch>0)\n    write_thread(node[node_no].link_ch,depth+1);\n  if(node[node_no].link_br>0)\n    write_thread(node[node_no].link_br,depth);\n}\n \nvoid set_link(int x,int y)\n{\n  if(node[x].link_ch==0)\n    {\n      node[x].link_ch=y;\n    }\n  else\n    {\n      x=node[x].link_ch;\n      while(node[x].link_br>0)\n    {\n      x = node[x].link_br;\n    }\n      node[x].link_br=y;\n    }\n}\n \nmain()\n{\n  int i,re;\n   \n  scanf(\"%d\",&N);\n  for(i=1;i<=N;i++)\n    {\n      scanf(\"%d\",&re);\n      if(i>0)\n    set_link(re,i);\n      scanf(\"%s\",&(node[i].message[0]));\n    }\n  write_thread(1,0);\n   \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nvector<int> v[1000];\nstring str[1000];\nint n;\n\nvoid dfs(int a, int d){\n\trep(i,d) printf(\".\");\n\tcout << str[a] << endl;\n\trep(i,v[a].size()){\n\t\tdfs(v[a][i],d+1);\n\t}\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n){\n\t\tint k;\n\t\tcin >> k;\n\t\tk--;\n\t\tif(k >= 0) v[k].push_back(i);\n\t\tcin >> str[i];\n\t}\n\tdfs(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct tree {\n\tstring str;\n\tvector<tree*> to;\n\ttree(const string& s) : str(s) {}\n\t~tree() {\n\t\tfor (auto ne : to) {\n\t\t\tdelete ne;\n\t\t}\n\t}\n};\n\nvoid dfs(int depth, tree* t) {\n\tif (depth > 0) {\n\t\tcout << string(depth, '.');\n\t}\n\tcout << t->str << endl;\n\tfor (auto ne : t->to) {\n\t\tdfs(depth + 1, ne);\n\t}\n}\n\nint main()\n{\n\tint n, k;\n\tstring s;\n\tcin >> n;\n\tvector<tree*> pos;\n\tcin >> k >> s;\n\tpos.push_back(new tree(s));\n\tfor (int i = 1; i < n; i++) {\n\t\tcin >> k >> s;\n\t\tauto ite = new tree(s);\n\t\tpos.push_back(ite);\n\t\tpos[k - 1]->to.push_back(ite);\n\t}\n\tdfs(0, pos.front());\n\tdelete pos.front();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> ch[1000];\nstring s[1000];\nvoid dfs(int x,int d=0){\n\tcout << string(d,'.') << s[x] << endl;\n\tfor( auto e : ch[x]) dfs(e,d+1);\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint t;\n\t\tcin >> t;\n\t\t--t;\n\t\tif(i!=0) ch[t].push_back(i);\n\t\tcin >> s[i];\n\t}\n\tdfs(0);\n\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nVS vs;\nVVI vi;\nvoid dfs(int n, int d){\n  REP(i,d) cout << \".\";\n  cout << vs[n] << endl;\n  for(int i: vi[n])\n\tdfs(i, d+1);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vs.assign(N, \"\");\n  vi.assign(N, VI());\n  REP(i,N){\n\tint k; cin >> k;\n\tcin >> vs[i];\n\tif(i != 0)\n\t  vi[k-1].PB(i);\n  }\n\n  dfs(0, 0);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define INF (int)1e09\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\nusing std::vector;\n\ntemplate <typename T> using Vec = vector<T>; // c++11\n\nstruct POST {\n    int number;\n    int depth;\n    string name;\n    Vec<POST> reply;\n    POST() {}\n    POST(int new_number, int new_depth, string new_name) {\n        number = new_number;\n        depth = new_depth;\n        name = new_name;\n    }\n};\n\nvoid init_data (POST &data, string m, int k) {\n    data.number = 0;\n    data.depth = 0;\n    data.name = m;\n    return;\n}\n\nvoid history (Vec<int> &parent, Vec<int> &pursue_list, int k) {\n    int temp = k;\n    while (1) {\n        if (temp == 0) {\n            break;\n        }\n        temp = parent[temp];\n        pursue_list.push_back(temp);\n    }\n    return;\n}\n\nvoid pursue (POST &data, Vec<int> &pursue_list, int pursue_len, int now_depth, int k, string m, int i) {\n    if (now_depth == pursue_len - 1) {\n        string dot(data.depth + 1, '.');\n        POST new_data(i, data.depth + 1, dot + m);\n        data.reply.push_back(new_data);\n    } else {\n        int loop = 0;\n        while (1) {\n            if (data.reply[loop].number == pursue_list[pursue_len - now_depth - 2]) {\n                pursue(data.reply[loop], pursue_list, pursue_len, now_depth + 1, k, m, i);\n                break;\n            } else {\n                loop++;\n            }\n        }\n    }\n    return;\n}\n\nvoid output (POST& data) {\n    int rep_len = (int)data.reply.size();\n    for (int i = 0; i < rep_len; i++) {\n        cout << data.reply[i].name << endl;\n        output(data.reply[i]);\n    }\n    return;\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n    POST data;\n    Vec<int> parent;\n    parent.push_back(-1);\n\n    int k;\n    string m;\n    cin >> k >> m;\n    k--;\n    init_data(data, m, k);\n    cout << m << endl;\n\n    for (int i = 1; i < n; i++) {\n        cin >> k >> m;\n        k--;\n        parent.push_back(k);\n        Vec<int> pursue_list;\n        pursue_list.push_back(k);\n        history(parent, pursue_list, k);\n        int pursue_len = (int)pursue_list.size();\n        pursue (data, pursue_list, pursue_len, 0, k, m, i);\n    }\n\n    output(data);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nint k[55];\nstring s[55];\n\nvoid dfs(int d,int dd){\n\twhile(1){\n\t\tint ni=-1;\n\t\trep(i,n){\n\t\t\tif(k[i]==d){\n\t\t\t\tni=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ni==-1)return;\n\t\trep(i,dd)cout<<\".\";\n\t\tcout<<s[ni]<<endl;\n\t\tk[ni]=-1;\n\t\tdfs(ni+1,dd+1);\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n;\n\trep(i,n)cin>>k[i]>>s[i];\n\tdfs(0,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N;\nvint G[1111];\nstring S[1111];\nint dep[1111];\nvoid dfs(int v,int p,int d){\n    dep[v]=d;\n    rep(i,dep[v])cout<<\".\";\n    cout<<S[v]<<endl;\n    for(int to:G[v]){\n        if(to==p)continue;\n        dfs(to,v,d+1);\n    }\n}\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cin>>N;\n    rep(i,N){\n        int p;cin>>p;p--;\n        if(p>=0)G[p].pb(i);\n        cin>>S[i];\n    }\n\n    dfs(0,-1,0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nstring S[1111];\nvector<int> G[1111];\nbool used[1111];\n\nvoid view(int id,string cnt){\n  for(int i=0;i<(int)G[id].size();i++){\n    cout << cnt + S[G[id][i]] << endl;\n    view(G[id][i],cnt+\".\");\n  }\n}\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    int k; cin >> k;\n    cin >> S[i+1];\n    G[k].push_back( i+1 );\n  }\n  view(0,\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nvector<string> lis[10010];\nmap<string, int> msi;\n\nvoid solve(int num,int cnt) {\n\trep(i, lis[num].size()) {\n\t\trep(j, cnt)cout << \".\";\n\t\tcout << lis[num][i] << endl;\n\t\tsolve(msi[lis[num][i]], cnt + 1);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tint num;\n\t\tstring s;\n\t\tcin >> num >> s;\n\t\tlis[num].push_back(s);\n\t\tmsi[s] = i + 1;\n\t}\n\tsolve(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef struct d{\n  string s;\n  vector<int> v;\n}D;\n  \nD a[1001];\n\nvoid printd(int n)\n{\n  for(int i = 0; i < n; i++)\n    cout << '.';\n}\n\nvoid f(D d, int x)\n{\n  printd(x);\n  cout << d.s << endl;\n  for(int i = 0; i < (int)d.v.size(); i++){\n    f(a[d.v[i]],x+1);\n  }\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  int k;\n  cin >> k >> a[1].s;\n  for(int i = 2; i <= n; i++){\n    cin >> k >> a[i].s;\n    a[k].v.push_back(i);\n  }\n  f(a[1],0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<vector<int> > Graph;\n \nint N;\nvector<string> name;\nGraph G;\n \nvoid dfs(int v, int depth) {\n  cout << string(depth, '.') << name[v] << endl;\n  for(int i = 0; i < G[v].size(); ++i) {\n    dfs(G[v][i], depth+1);\n  }\n}\n \nint main() {\n  cin >> N;\n  name = vector<string>(N);\n  G = Graph(N);\n  for(int i = 0; i < N; ++i) {\n    int par; cin >> par; --par;\n    cin >> name[i];\n    if(par != -1) G[par].push_back(i);\n  }\n  dfs(0, 0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\n#define INF (int)1e09\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::setprecision;\nusing std::fixed;\nusing std::pair;\nusing std::make_pair;\nusing std::min;\nusing std::max;\nusing std::string;\nusing std::vector;\nusing std::list;\nusing std::map;\nusing std::set; // insert erase find count\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n\ntemplate <typename T> using Vec = vector<T>; // c++11\ntypedef pair<int, int> PII;\ntypedef pair<int, pair<int, int> > PIII;\n\nstruct POST {\n    int number;\n    int depth;\n    string name;\n    Vec<POST> reply;\n};\n\nvoid init_data (POST &data, string m, int k) {\n    data.number = 0;\n    data.depth = 0;\n    data.name = m;\n    return;\n}\n\nvoid history (Vec<int> &parent, Vec<int> &pursue_list, int k) {\n    int temp = k;\n    while (1) {\n        if (temp == 0) {\n            break;\n        }\n        temp = parent[temp];\n        pursue_list.push_back(temp);\n    }\n    return;\n}\n\nvoid pursue (POST &data, Vec<int> &pursue_list, int pursue_len, int now_depth, int k, string m, int i) {\n    if (now_depth == pursue_len - 1) {\n        // data.reply???POST??????push_back\n        POST new_data;\n        new_data.number = i;\n        new_data.depth = data.depth + 1;\n        string dot(new_data.depth, '.');\n        new_data.name = dot + m;\n        data.reply.push_back(new_data);\n    } else {\n        int loop = 0;\n        while (1) {\n            if (data.reply[loop].number == pursue_list[pursue_len - now_depth - 2]) {\n                // recursion\n                pursue(data.reply[loop], pursue_list, pursue_len, now_depth + 1, k, m, i);\n                break;\n            } else {\n                loop++;\n            }\n        }\n    }\n    return;\n}\n\nvoid dump(POST& data) {\n    cout << \"NUMBER = \" << data.number << endl;\n    cout << \"DEPTH = \" << data.depth << endl;\n    cout << \"NAME = \" << data.name << endl;\n    cout << \"REP = \" << (int)data.reply.size() << endl;\n    return;\n}\n\nvoid dfs (POST& data) {\n    int rep_len = (int)data.reply.size();\n    for (int i = 0; i < rep_len; i++) {\n        cout << data.reply[i].name << endl;\n        dfs(data.reply[i]);\n    }\n    return;\n}\n\nvoid output (POST& data) {\n    dfs(data);\n    return;\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n    POST data;\n    Vec<int> parent;\n    parent.push_back(-1);\n\n    int k;\n    string m;\n    cin >> k >> m;\n    k--;\n    init_data(data, m, k);\n    cout << m << endl;\n\n    for (int i = 1; i < n; i++) {\n        cin >> k >> m;\n        k--;\n        // make_data <- int k, string m, DATA\n        parent.push_back(k);\n        Vec<int> pursue_list;\n        pursue_list.push_back(k);\n        history(parent, pursue_list, k);\n        int pursue_len = (int)pursue_list.size();\n        pursue (data, pursue_list, pursue_len, 0, k, m, i);\n    }\n\n    output(data);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstring s[1001];\nbool visited[1001];\nvoid dfs(vector<vector<int> > &g, string *s, int depth, int node){\n  if(visited[node])return;\n  visited[node] = true;\n  for (int i = 0; i < depth; i++)\n    std::cout << \".\";\n\n  std::cout << s[node] << std::endl;\n  for (int i = 0; i < g[node].size(); i++) {\n    dfs(g, s, depth + 1, g[node][i]);\n  }\n  return;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  cin >> n;\n  vector<vector<int> > g;\n  g.resize(n + 1);\n  int k;\n  cin >> k >> s[0];\n  for (int i = 1; i < n; i++) {\n    cin >> k >> s[i];\n    g[k - 1].push_back(i);\n  }\n  dfs(g, s, 0, 0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nvector<pair<string, vector<int>>>data;\n\nvoid saiki(int now, int level)\n{\n\tfor (size_t i = 0; i < level; i++)\n\t{\n\t\tcout << \".\";\n\t}\n\tcout << data[now].first << endl;\n\tfor (auto x : data[now].second)\n\t{\n\t\tsaiki(x, level + 1);\n\t}\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tdata.resize(N+1);\n\tint a;\n\tfor (size_t i = 1; i <= N; i++)\n\t{\n\t\tcin >> a;\n\t\tdata[a].second.push_back(i);\n\t\tcin >> data[i].first;\n\t}\n\tfor (auto x : data[0].second)\n\t{\n\t\tsaiki(x, 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing P = pair<ll, ll>;\nusing P3 = pair<P,ll>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1 << 30;\nconstexpr ll MOD = ll(1e9)+7;\nconstexpr int di[] = {0, 1, 0, -1};\nconstexpr int dj[] = {1, 0, -1, 0};\nconstexpr double EPS = 1e-9;\n\nvector<string> m;\nvector<vector<int> > g;\nvector<bool> used;\n\nvoid dfs(int now, int depth=0){\n    used[now] = true;\n    for(int i=0;i<depth;i++) cout << '.';\n    cout << m[now] << endl;\n    for(auto nxt:g[now]){\n        dfs(nxt, depth+1);\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n    m.resize(n);\n    g.resize(n);\n    used.resize(n);\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k >> m[i];\n        if(k>0) g[k-1].push_back(i);\n    }\n    for(int i=0;i<n;i++){\n        if(!used[i]) dfs(i);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\nvoid func(vector<vector<int>>&edge, vector<string>&s, int num = 0, int node = 0) {\n\tfor (auto i : edge[node]) {\n\t\tcout << string(num, '.') + s[i] << endl;\n\t\tfunc(edge, s, num + 1, i);\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N + 1);\n\tvector<string>s(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> K;\n\t\tedge[K].push_back(i);\n\t\tcin >> s[i];\n\t}\n\tfunc(edge, s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint N;\nvector<int>G[1001];\nstring s[1000];\nvoid dfs(int u,int d)\n{\n\tif(u)\n\t{\n\t\tfor(int r=0;r<d;r++)cout<<'.';\n\t\tcout<<s[u-1]<<endl;\n\t}\n\tfor(int v:G[u])dfs(v,d+1);\n}\nmain()\n{\n\tcin>>N;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint a;cin>>a>>s[i];\n\t\tG[a].push_back(i+1);\n\t}\n\tdfs(0,-1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> vv;\nvector<pair<int, string>> v;\nvoid dfs(int n, int c){\n\tfor(int i=0; i< c; i++) cout << \".\";\n\tcout << v[n].second << endl;\n\tfor(int i=0; i < vv[n].size(); i++){\n\t\tdfs(vv[n][i], c+1);\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tv.push_back(make_pair(0, \"\"));\n\tfor(int i=0; i < n; i++){\n\t\tint a; string b;\n\t\tcin >> a >> b;\n\t\tv.push_back(make_pair(a, b));\n\t}\n\tfor(int i=0; i < v.size(); i++){\n\t\tvector<int> list;\n\t\tfor(int j=i+1; j < v.size(); j++){\n\t\t\tif(i == v[j].first) list.push_back(j);\n\t\t}\n\t\tvv.push_back(list);\n\t}\n\tdfs(vv[0][0], 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(i, (v).size()) { cout << v[i]; if (i != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct post {\n\tstring self;\n\tvector<post*> sub;\n\tpost(string s_) {\n\t\tself = s_;\n\t}\n\tpost() {};\n};\nvoid print(post p,int level) {\n\n\tREP(i, level)cout << '.';\n\tcout << p.self << endl;\n\tREP(i, p.sub.size()) {\n\t\tprint(*p.sub[i],level+1);\n\t}\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<post> v(n);\n\tint k;\n\tstring m;\n\tcin >> k >> m;\n\tv[0] = post(m);\n\tREP(i, n - 1) {\n\t\tcin >> k >> m;\n\t\tv[i + 1] = post(m);\n\t\tv[k-1].sub.push_back(&v[i+1]);\n\t}\n\tprint(v[0],0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nvi lnk[1024];\nstring res[1024];\n\nvoid dfs(int p,int d){\n  cout<<string(d,'.')<<res[p]<<endl;\n  REP(i,lnk[p].size()){\n    dfs(lnk[p][i],d+1);\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  int root = 0;\n  REP(i,n){\n    int k;\n    string m;\n    cin>>k>>m;\n    res[i] = m;\n    --k;\n    if(k==-1)root=i;\n    else{\n      lnk[k].push_back(i);\n    }\n  }\n  dfs(root,0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nvector<int> to[1010];\nvector<string> message[1010];\n\nvoid dfs(int v,int d){\n\trep(i,to[v].size()){\n\t\trep(i,d) cout << '.';\n\t\tcout << message[v][i] << endl;\n\t\tdfs(to[v][i],d+1);\n\t}\n\treturn;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;++i){\n\t\tint p;\n\t\tstring msg;\n\t\tcin >> p >> msg;\n\t\tto[p].pb(i);\n\t\tmessage[p].pb(msg);\n\t}\n\tdfs(0,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nvector<pair<int, string> > v;\n\nvoid dfs(int now, int deep){\n  for(int i = 0; i < v.size(); i++){\n    if(now == v[i].first){\n      cout << string(deep, '.') << v[i].second << \"\\n\";\n      dfs(i, deep + 1);\n    }\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  v.resize(n);\n  for(int i = 0; i < n; i++){\n    int root;\n    string str;\n    cin >> root;\n    cin >> str;\n    v[i] = make_pair(root - 1, str);\n  }\n  dfs(-1, 0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef struct{\n  int k;\n  char m[50];\n}res;\n\nint main(){\n  int n;\n  cin >> n;\n  res r[n];\n  int adj[n][n];\n  for(int i=0;i<n;++i)\n    for(int j=0;j<n;++j)\n      adj[i][j]=0;\n  for(int i=0;i<n;++i){\n    cin >> r[i].k >> r[i].m;\n    adj[i][r[i].k-1] = 1;\n  }\n  \n  printf(\"%s\\n\",r[0].m);\n  for(int i = 1;i<n;++i)\n    for(int j = 0;j<n;++j){\n      if(adj[i][j]==1){\n\tfor(int k=0;k<j+1;++k)\n\t  putchar('.');\n\tprintf(\"%s\\n\",r[i].m);\n      }\n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nvector< string > reply;\nvector< vector< int > > tree;\n\nvoid rec(int v, int d) {\n\tfor_(i,0,d) cout << \".\";\n\tcout << reply[v] << endl;\n\t\n\tint m = tree[v].size();\n\tfor_(i,0,m) rec(tree[v][i], d + 1);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\treply.assign(n, string());\n\ttree.assign(n, vector< int >());\n\t\n\tfor_(i,0,n) {\n\t\tint k;\n\t\tcin >> k >> reply[i];\n\t\t\n\t\t--k;\n\t\tif (k >= 0) tree[k].push_back(i);\n\t}\n\t\n\trec(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint n; int k; string m[1000];\nvector<int> G[1000]; int cnt = -1;\nvoid solve(int x) {\n\tcnt++;\n\trep(i, cnt) {\n\t\tcout << \".\";\n\t}\n\tcout << m[x] << endl;\n\tint len = G[x].size();\n\trep(i, len) {\n\t\tsolve(G[x][i]);\n\t}\n\tcnt--;\n\treturn;\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k >> m[i];\n\t\tk--;\n\t\tif (k >= 0) {\n\t\t\tG[k].push_back(i);\n\t\t}\n\t}\n\tsolve(0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstruct Point\n{\n  double x,y;\n  Point(){x=0;y=0;}\n  Point(double d_x,double d_y){x=d_x,y=d_y;}\n  double operator*(Point obj){return obj.x*x+obj.y*y;}\n  double operator%(Point obj){return obj.y*x-obj.x*y;}\n  Point operator*(double b){Point tmp;tmp.x=x*b;tmp.y=y*b;return tmp;}\n  Point operator/(double b){Point tmp;tmp.x=x/b;tmp.y=y/b;return tmp;}\n  Point operator+(Point obj){Point tmp;tmp.x=x+obj.x;tmp.y=y+obj.y;return tmp;}\n  Point operator-(){Point tmp;tmp.x=-x;tmp.y=-y;return tmp;}\n  Point operator-(Point obj){Point tmp;tmp.x=x-obj.x;tmp.y=y-obj.y;return tmp;}\n  Point operator-=(Point obj){x-=obj.x;y-=obj.y;return *this;}\n  Point operator+=(Point obj){x+=obj.x;y+=obj.y;return *this;}\n  Point operator/=(double b){x=x/b;y=y/b;return *this;}\n  Point operator*=(double b){x=x*b;y=y*b;return *this;}\n  double size(){return hypot(x,y);}\n  Point unit(){return Point(x/size(),y/size());}\n  Point normal(){return Point(y,-x);}\n  double atan(){return atan2(y,x);}\n};\n\nbool operator<(Point a,Point b){return a.x!=b.x?a.x<b.x:a.y<b.y;}\nbool operator>(Point a,Point b){return b<a;}\nbool operator<=(Point a,Point b){return !(b<a);}\nbool operator>=(Point a,Point b){return !(a<b);}\nbool operator==(Point a,Point b){return (a-b).size()<eps;}\nbool operator!=(Point a,Point b){return !(a==b);}\n\nbool equal(double a,double b){return abs(a-b)<eps;}\ndouble cross(Point a,Point b){return a%b;}\ndouble dot(Point a,Point b){return a*b;}\n\nint ccw(Point a,Point b,Point c)\n{\n  b=b-a;\n  c=c-a;\n  if(b%c>0) return +1;\n  else if(b%c<0)return -1;\n  else if(b*c<0) return +2;\n  else if(b.size()<c.size()) return -2;\n  else return 0;\n}\n\nstruct Tree\n{\n  int _d;\n  string _name;\n  vector<Tree*> _v;\n  Tree(string name,int d)\n  {\n    _name=name;\n    _d=d;\n  }\n  void add(Tree* t)\n  {\n    _v.push_back(t);\n  }\n  void print()\n  {\n    for(int i=0;i<_d;i++)\n      {\n\tcout << '.';\n      }\n    cout << _name << endl;\n    for(int i=0;i<_v.size();i++)\n      {\n\t_v[i]->print();\n      }\n  }\n};\n\nint main(int argc,char const* argv[])\n{\n  int n,k1,k;\n  string m1,m;\n  Tree* v[1005];\n  Tree *t,*root;\n  cin >> n >> k1 >> m1;\n  root=t=new Tree(m1,k1);\n  v[1]=t;\n  for(int i=2;i<n+1;i++)\n    {\n      cin >> k >> m;\n      t=new Tree(m,v[k]->_d+1);\n      v[k]->add(t);\n      v[i]=t;\n    }\n  root->print();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef struct T {\n\tstring op;\n\tvector<int> k;\n};\nint n, k;\nstring M;\nT t[1000];\n\nint rec(int d, T &tr) {\n\tfor (int i = 0; i < d; i++) {\n\t\tcout << \".\";\n\t}\n\tcout << tr.op << endl;\n\tfor (int i = 0; i < tr.k.size(); i++) {\n\t\trec(d + 1, t[tr.k[i]]);\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> k >> M;\n\t\tstring s(M);\n\t\tt[i].op = s;\n\t\tif (k > 0) {\n\t\t\tt[k - 1].k.push_back(i);\n\t\t}\n\t}\n\trec(0, t[0]);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstring s[1001];\nvector<int>G[1001];\nint n;\nvoid f(int i,int d)\n{\n\tcout<<string(d,'.')<<s[i]<<endl;\n\tfor(int j=0;j<G[i].size();j++)f(G[i][j],d+1);\n}\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i++<n;)\n\t{\n\t\tint k;cin>>k>>s[i];\n\t\tG[k].push_back(i);\n\t}\n\tf(1,0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\nstruct tr{\n    vector<tr*> children;\n    string name;\n    int depth;\n    void prt(){\n        for(int i=0;i<depth;i++){cout<<\".\";}\n        cout<<name<<endl;\n        for(auto i=children.begin();i!=children.end();i++){\n            (*i)->prt();\n        }\n    }        \n};\n\nint main(){\n    int n,i,p;\n    cin>>n;\n    vector<tr> t(n);\n    for(i=0;i<n;i++){\n        tr buf;\n        cin>>p;\n        cin>>buf.name;\n        if(!i){\n            buf.depth=0;\n            t[0]=buf;\n        }        \n        else{\n            buf.depth=t[p-1].depth+1;\n            t[i]=buf;\n            t[p-1].children.push_back(&t[i]);\n        }\n    }\n    t[0].prt();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\nusing namespace std;\nvvi in;\nvector<string>s;\nvoid f(int a,int c){\n\trep(i,c)cout<<'.';\n\tcout<<s[a]<<endl;;\t\n\trep(i,in[a].size())f(in[a][i],c+1);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tin=vvi(n);\n\ts=vector<string>(n);\n\trep(i,n){\n\t\tint a;\n\t\tcin>>a;\n\t\tcin>>s[i];\n\t\tif(a)in[a-1].pb(i);\n\t}\n\tf(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dfs(vector<int> &d, vector<string> &M, vector<vector<int>> &c, int v = 0){\n  for (int i = 0; i < d[v]; i++){\n    cout << '.';\n  }\n  cout << M[v];\n  cout << endl;\n  for (int w : c[v]){\n    d[w] = d[v] + 1;\n    dfs(d, M, c, w);\n  }\n}\nint main(){\n  int n;\n  cin >> n;\n  vector<int> k(n);\n  vector<string> M(n);\n  for (int i = 0; i < n; i++){\n    cin >> k[i] >> M[i];\n    k[i]--;\n  }\n  vector<vector<int>> c(n);\n  for (int i = 1; i < n; i++){\n    c[k[i]].push_back(i);\n  }\n  vector<int> d(n);\n  d[0] = 0;\n  dfs(d, M, c);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nstruct edge\n{\n    int to; string word;\n    edge(int to, string word) { this->to = to, this->word = word; }\n};\nvector<edge> G[1010];\nvoid dfs(int depth, int num)\n{\n    if(G[depth].size() == 0) return;\n    for(int u = 0; u < G[depth].size(); u++)\n    {\n        for(int i = 0; i < num; i++) cout << \".\";\n        cout << G[depth][u].word << endl;\n        if(G[depth][u].to != depth) dfs(G[depth][u].to, num + 1);\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    for(int i = 0; i < n; i++)\n    {\n        int k; cin >> k;\n        string word; cin >> word;\n        G[k].push_back(edge(i + 1, word));\n    }\n    dfs(0, 0);\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nvector<vector<int> > v(1100);\nvector<string> s(1100);\nvoid dfs(int i,int d)\n{\n\tfor (int j = 0; j < d; j++)\n\t{\n\t\tcout << \".\";\n\t}\n\tcout << s[i] << endl;\n\n\tfor (int j = 0; j < v[i].size(); j++)\n\t{\n\t\tdfs(v[i][j], d + 1);\n\t}\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\t\tcin >> s[i];\n\t\tif (k != 0)\n\t\t{\n\t\t\tv[k - 1].push_back(i);\n\t\t}\n\t}\n\tdfs(0, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nvector<int> to[1010];\nvector<string> message[1010];\n\nvoid dfs(int v,int d){\n\trep(i,to[v].size()){\n\t\trep(j,d) cout << '.';\n\t\tcout << message[v][i] << endl;\n\t\tdfs(to[v][i],d+1);\n\t}\n\treturn;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tfor(int i=1;i<=n;++i){\n\t\tint p;\n\t\tstring msg;\n\t\tcin >> p >> msg;\n\t\tto[p].pb(i);\n\t\tmessage[p].pb(msg);\n\t}\n\tdfs(0,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<vector<int>> v;\nvector<string> w;\nvoid foo(int a,int b){\n    cout<<string(a,'.')<<w[b]<<endl;\n    for(int x:v[b]){\n        foo(a+1,x);\n    }\n}\nint main(){\n    cin>>n;\n    v.resize(n);\n    w.resize(n);\n    for(int i=0;i<n;i++){\n        int t;\n        cin>>t>>w[i];\n        if(t) v[t-1].push_back(i);\n    }\n    foo(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nvi link[1024];\nstring res[1024];\n\nvoid dfs(int p,int d){\n  cout<<string(d,'.')<<res[p]<<endl;\n  REP(i,link[p].size()){\n    dfs(link[p][i],d+1);\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  int root = 0;\n  REP(i,n){\n    int k;\n    string m;\n    cin>>k>>m;\n    res[i] = m;\n    --k;\n    if(k==-1)root=i;\n    else{\n      link[k].push_back(i);\n    }\n  }\n  dfs(root,0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid print(int node, int d, vector<vector<int> > adjlist, vector<string> name){\n\n    for(int i = 0; i < d; i++) cout << '.';\n    cout << name[node] << endl;\n    for(int i = 0; i < adjlist[node].size(); i++){\n        print(adjlist[node][i], d + 1, adjlist, name);\n    }\n\n}\n\nint main(){\n\n    int n; cin >> n;\n    vector<string> name(n);\n    vector<vector<int> > adjlist(n);\n\n    for(int i = 0; i < n; i++){\n        int a; string s; cin >> a >> s;\n        \n        a--;\n        name[i] = s;\n        if(a == -1) continue;\n        adjlist[a].push_back(i);\n    }\n\n    print(0, 0, adjlist, name);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n;\nstring mark[1100];\nvector<int> arr[1100];\n\nvoid dfs(int cur,int depth) {\n  cout << string(depth,'.') << mark[cur] << endl;\n  rep(i,arr[cur].size()) dfs(arr[cur][i],depth+1);\n}\n\nint main(){\n  cin >> n;\n  rep(i,n) arr[i].clear();\n  rep(i,n){\n    int k;\n    cin >> k;\n    cin >> mark[i];\n    --k;\n    if( k < 0 ) continue;\n    arr[k].push_back(i);\n  }\n  dfs(0,0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define first fi;\n#define second se;\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nstring m[1010];\nvector<int> d[1010];\n\nvoid dfs(int id, int depth){\n    rep(i, 0, depth) cout << \".\";\n    cout << m[id] << endl;\n    rep(i, 0, d[id].size()){\n        dfs(d[id][i], depth + 1);\n    }\n}\n\nsigned main(){\n    cin >> n;\n    rep(i, 0, n){\n        int k;\n        cin >> k >> m[i];\n        if(k == 0) continue;\n        d[k - 1].push_back(i);\n    }\n    dfs(0, 0);\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nvi g[10000];\nvector<string> s(10000);\nvoid dfs(int now, int h){\n  int i;\n  rep(i,h)cout<<'.';\n  cout<<s[now]<<endl;\n  rep(i,g[now].size())\n    dfs(g[now][i],h+1);\n}\n\n\nint main(void) {\n  int i,j;\n  int n;\n  cin>>n;\n  rep(i,n){\n    int a;\n    cin>>a;\n    if(a)g[a-1].push_back(i);\n    cin>>s[i];\n  }\n  dfs(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n#define long long long\n\nvector<string> name;\nvector<vector<int> > refs;\n\nvoid solve(int i, int d){\n  rep(j,d) printf(\".\");\n  cout<<name[i]<<endl;\n  for(auto to : refs[i]){\n    solve(to, d+1);\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  name.resize(n);\n  refs.resize(n);\n  rep(i,n){\n    int d;\n    scanf(\"%d\", &d);\n    cin>>name[i];\n    if(d>0){\n      d--;\n      refs[d].pb(i);\n    }\n  }\n\n  solve(0, 0);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nvector<int> v[1000];\nvector<string> st(1000);\n\nvoid solve(int idx,int depth){\n    for(int i=0;i<depth;i++) cout<<\".\";\n    cout<<st[idx]<<endl;\n    for(int i=0;i<(int)v[idx].size();i++){\n        int next=v[idx][i];\n        solve(next,depth+1);\n    }\n    return ;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int n;cin>>n;\n    int k;\n    cin>>k>>st[0];\n    for(int i=1;i<n;i++){\n        cin>>k>>st[i];k--;\n        v[k].push_back(i);\n    }\n    solve(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector <pair<int,pair<int,string> > > v; //replyTo, (depth, M)\n\n\nvoid put_dots(int n){\n  for(int i = 0; i < n; i++){\n    cout << \".\";\n  }\n}\n\nvoid output(int n){\n  put_dots(v[n].second.first);\n\n  cout << v[n].second.second << endl;\n  for(int i = n; i < v.size(); i++){\n    if(v[i].first == n) output(i);\n  }\n}\n\nint main(){\n  int n, k;\n  string M;\n  pair<int, pair<int, string> > p;\n\n  cin >> n;\n  cin >> k >> M;\n  p = make_pair(-1, make_pair(0,M));\n  v.push_back(p);\n\n  for(int i = 1; i < n; i++){\n    int depth;\n    cin >> k >> M;\n    k--;\n    depth = v[k].second.first + 1;\n    p = make_pair(k, make_pair(depth, M));\n    v.push_back(p);\n  }\n\n  output(0);\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Node {\n    int idx;\n    string text;\n    vector<Node*> children;\n    Node(int idx,string text) :\n        idx(idx),text(text){}\n    ~Node() {\n        for(auto child : children) {\n            delete child;\n        }\n    }\n};\n\nNode* find(Node *node,int idx) {\n    if(node->idx==idx) return node;\n    for(auto child : node->children) {\n        return find(child, idx);\n    }\n\n    return nullptr;\n}\n\nvoid print(Node *node, int indent) {\n    cout<<string(indent,'.');\n    cout<<node->text<<endl;\n    for(auto child : node->children) {\n        print(child,indent+1);\n    }\n}\n\n\nint n;\nvoid solve() {\n    Node *root;\n    map<int,Node*> nodes;\n    rep(i,n) {\n        int k;\n        string m;\n        cin>>k>>m;\n        if(k==0) {\n            root=new Node(i,m);\n            nodes[0]=root;\n        }\n        else {\n            k--;\n            Node *node=nodes[k];\n            nodes[i]=new Node(i,m);\n            //cout<<node->text<<\", \"<<node->idx<<endl;\n            node->children.push_back(nodes[i]);\n        }\n    }\n    print(root,0);\n}\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x)*(x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nstruct Thread {\n    int id, children;\n    string s;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Thread> th;\n    vi indent(n+1);\n    FOR(id, 1, n+1) {\n        int k;\n        string s;\n        cin >> k >> s;\n\n        bool inserted = false;\n        REP(i, SZ(th)) {\n            Thread& t = th[i];\n            if (t.id == k) {\n                int level = t.children;\n                FOR(j, i+1, SZ(th)) {\n                    if (indent[th[j].id] <= indent[t.id]) break;\n                    level += th[j].children;\n                }\n\n                t.children++;\n                th.insert(th.begin()+i+1+level, {id, 0, s});\n                inserted = true;\n                break;\n            }\n        }\n        if (!inserted) {\n            th.push_back({id, 0, s});\n        }\n        if (k == 0) {\n            indent[id] = 0;\n        } else {\n            indent[id] = indent[k] + 1;\n        }\n//        for (auto t : th) {\n//            REP(i, indent[t.id]) {\n//                LOG(\".\");\n//            }\n//            LOG(\"%s (%d)\\n\", t.s.c_str(), t.children);\n//        }\n//        LOG(\"---------------\\n\");\n    }\n\n    for (auto t : th) {\n        REP(i, indent[t.id]) {\n            cout << \".\";\n        }\n        cout << t.s << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> node[1000];\nvector<string> M;\n\nvoid dfs(int i, int dots){\n    cout<<string(dots,'.')<<M[i]<<endl;\n    for(auto v:node[i]) dfs(v,dots+1);\n}\n\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        if(k>=0)node[k].push_back(i);\n        string s;\n        cin>>s;\n        M.push_back(s);\n    }\n    dfs(0,0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n  int p,l,r;\n  string str;\n};\n\nnode t[1001];\n\nvoid pr(int n,int d){\n  if(n<0) return;\n  for(int i=0;i<d;i++)cout<<\".\";\n  cout<<t[n].str<<endl;\n  pr(t[n].l,d+1);\n  pr(t[n].r,d);\n}\n\nint main(){\n  int n,u;\n  cin>>u;\n  for(int i=0;i<u;i++) t[i].l=-1,t[i].p=-1,t[i].r=-1;\n  string str;\n  int f[1001]={};\n\n  for(int i=0;i<u;i++){\n    cin>>n>>str;\n    t[i].str=str;\n    t[i].p=n-1;\n    if(f[n]==0)t[n-1].l=i;\n    else if(f[n]==1) t[t[n-1].l].r=i;\n    else if(f[n]>1){\n      int prev=t[n-1].l;\n      for(int j=0;j<f[n]-1;j++)prev=t[prev].r;\n      t[prev].r=i;\n    }\n    f[n]++;\n  }\n  pr(0,0);   \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, string> pis;\n\nint n, k[1010], r[1010];\nstring m[1010];\nvector<pis> G[1010];\n\nvoid dfs(int s, int d) {\n  for (int i = 0; i < d; i++) {\n    cout << \".\";\n  }\n  cout << m[s - 1] << endl;\n  for (int i = 0; i < G[s].size(); i++) {\n    dfs(G[s][i].first, d + 1);\n  }\n}\n\nint main(void) {\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> k[i] >> m[i];\n    G[k[i]].push_back(pis(i + 1, m[i]));\n  }\n\n  dfs(1, 0);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\nint n;\nvector<vector<int>> v;\nvector<string> w;\nvoid foo(int a,int b){\n    cout<<string(a,'.')<<w[b]<<endl;\n    for(int x:v[b]){\n        foo(a+1,x);\n    }\n}\nint main(){\n    cin>>n;\n    v.resize(n);\n    w.resize(n);\n    rep(i,n){\n        int t;\n        cin>>t;\n        cin>>w[i];\n        if(t==0) continue;\n        v[t-1].push_back(i);\n    }\n    foo(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\ntypedef pair<int, int> P;\n\nint main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\tcin >> n;\n\tvector<int> v[n+1];\n\tvector<string> w;\n\tw.push_back(\"\");\n\tfor(int i=1; i<=n; ++i){\n\t\tint k;\n\t\tcin >> k;\n\t\tv[k].push_back(i);\n\t\tstring s;\n\t\tcin >> s;\n\t\tw.push_back(s);\n\t}\n\tbool f[n+1] = {};\n//\tfor(int i=0; i<=n; ++i)\n//\t\tfor(int j=0; j<v[i].size(); ++j)\n//\t\t\tcout << v[i][j] << (j+1 == v[i].size() ? \"\\n\" : \" \");\n\tstack<P> st;\n\tst.push(P(1, 0));\n\twhile(!st.empty()){\n\t\tP t = st.top();\n\t\tst.pop();\n\t\tfor(int i=0; i<v[t.first].size(); ++i)\n\t\t\tst.push(P(v[t.first][v[t.first].size()-i-1], t.second+1));\n\t\tf[t.first] = true;\n\t\tfor(int i=0; i<t.second; ++i) cout << \".\";\n\t\tcout << w[t.first] << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct mes{\n    mes* pre;\n    vector<mes*> fol;\n    string m;\n};\nvector<mes>vec;\n\nvoid dfs(mes m, int d){\n    for(int i=0;i<d;i++)\n        cout<<\".\";\n    cout<<m.m<<endl;\n    for(int i=0;i<m.fol.size();i++)\n        dfs(*m.fol[i],d+1);\n}\nint main(){\n    int n, k;\n    string str;\n    cin>>n;\n    for(int i=0;i<=n;i++){\n        mes me;\n        vec.push_back(me);\n    }\n    for(int i=1;i<n;i++){\n        cin>>k>>str;\n        vec[i].pre = &vec[k];\n        vec[i].m = str;\n        vec[k].fol.push_back(&vec[i]);\n    }\n    dfs(vec[1],0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid dfs(int num,int depth);\n\nvector<int> tree[1001];\nstring m[1001];\n\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tfor(int i = 0;i < n;i++){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tif(tmp-1 >= 0){\n\t\t\ttree[tmp-1].push_back(i);\n\t\t}\n\t\tcin >> m[i];\n\t}\n\t\n\tdfs(0,0);\n\treturn 0;\n}\n\nvoid dfs(int num,int depth){\n\tfor(int i = 0;i < depth;i++){\n\t\tcout << \".\";\n\t}\n\tcout << m[num] << endl;\n\tfor(int i = 0;i < tree[num].size();i++){\n\t\tdfs(tree[num][i],depth+1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 1001\nusing namespace std;\nvoid func(int,int,int);\nint n,k[N];\nstring str[N];\n\nint main(){\n  cin>>n;\n  for(int i=1;i<=n;i++) cin>>k[i]>>str[i];\n  cout<<str[1]<<endl;\n  func(2,1,1);\n  return 0;\n}\n\nvoid func(int d,int q,int p){\n  if(d==n+1) return ;\n  if(q==k[d]){\n    for(int i=0;i<p;i++) cout<<'.';\n    cout<<str[d]<<endl;\n    func(d+1,d,p+1);\n  }\n  func(d+1,q,p);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI 3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S acm(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nvoid YN(bool b){cout<<(b?\"YES\":\"NO\")<<\"\\n\";}\nvoid Yn(bool b){cout<<(b?\"Yes\":\"No\")<<\"\\n\";}\nvoid yn(bool b){cout<<(b?\"yes\":\"no\")<<\"\\n\";}\n\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;} return os;}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tvvi vv(n+1);\n\tvs ss(n);\n\trep(i,n){\n\t\tint p;\n\t\tstring s;\n\t\tcin>>p>>s;\n\t\tss[i]=s;\n\t\tif(p!=0)vv[p-1].push_back(i);\n\t}\n\tstack<pii> stk;\n\tstk.push(pii(0,0));\n\twhile(!stk.empty()){\n\t\tpii t=stk.top();stk.pop();\n\t\trep(i,t.sc)cout<<'.';\n\t\tcout<<ss[t.fs]<<endl;\n\t\trrep(i,vv[t.fs].size()){\n\t\t\tstk.push(pii(vv[t.fs][i],t.sc+1));\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<int>E[10001];\nstring s[10001];\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\tint k; cin >> k >> s[i + 1];\n\t\tE[k].push_back(i + 1);\n\t}\n\tstack<P>que;\n\tque.push(P(0, -1));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tif (~p.second) {\n\t\t\trep(i, p.second)cout << '.';\n\t\t\tcout << s[p.first] << endl;\n\t\t}\n\t\tfor (int j = E[p.first].size() - 1; j >= 0; j--)\n\t\t\tque.push(P(E[p.first][j], p.second + 1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1005\n\nint n;\nint p[MAX_N];\nstring t[MAX_N];\nvector<int> G[MAX_N];\nmap<string,int> change;\n\nvoid solve(int pos,int depth){\n  for(int i=0;i<depth;i++)cout<<'.';\n  if(pos)cout<<t[pos]<<endl;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int w=G[pos][i];\n    solve(w,depth+1);\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=1;i<=n;i++){\n    cin>>p[i]>>t[i];\n    change[t[i]]=i;\n    G[p[i]].push_back(i);\n  }\n  solve(0,-1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define BITLE(n) (1LL<<((ll)n))\n#define SHIFT_LEFT(n) (1LL<<((ll)n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\n#define EPS 1e-15\nusing namespace std;\nvvi E(1100);\nvector<string>vs;\nvoid dfs(ll now,ll dep){\n  if(now != 0){\n    for(int i = 0;i<dep-1;i++){\n      cout<<\".\";\n    }\n    cout<<vs[now]<<endl;\n  }\n  for(auto e:E[now]){\n    dfs(e,dep+1);\n  }\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;cin>>n;\n  vs.pb(\"\");\n  for(int i=1;i<=n;i++){\n    ll k;cin>>k;\n    string s;cin>>s;\n    vs.pb(s);\n    E[k].pb(i);\n  }\n  dfs(0,0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nvector<vi> v;\nvs res;\n\nvoid solve(int i, int d)\n{\n\tREP(j, d) cout << '.';\n\tcout << res[i] << endl;\n\tREP(j, v[i].size()) solve(v[i][j], d + 1);\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tv.resize(n);\n\tres.resize(n);\n\tREP(i, n)\n\t{\n\t\tint k;\n\t\tcin >> k >> res[i];\n\t\tk--;\n\t\tif (k >= 0) v[k].push_back(i);\n\t}\n\n\tsolve(0, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct thread{\n  int to;\n  int val;\n  string s;\n};\n\nvoid print(struct thread t[],int index,int n){\n  for(int i=0;i<t[index].val;i++) cout<<\".\";\n  cout<<t[index].s<<endl;\n  for(int i=index+1;i<=n;i++){\n    if(t[i].to==index) print(t,i,n);\n  }\n}\n\nint main(){\n  struct thread t[1001];\n  t[0].val=-1;\n  int n;\n\n  cin>>n;\n  for(int i=1;i<=n;i++){\n    cin>>t[i].to>>t[i].s;\n    t[i].val=t[t[i].to].val+1;\n  }\n  print(t,1,n);\n}\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2619.cpp\n// Author: ymiyamoto\n//\n// Created on Sat Dec  2 21:02:56 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct tree_t {\n  string str;\n  vector<uint32_t> children;\n};\n\nvoid preorder(vector<tree_t> tree, uint32_t i, uint32_t depth)\n{\n  cout << string(depth, '.') << tree[i].str << endl;\n  for (uint32_t j = 0; j < tree[i].children.size(); j++) {\n    preorder(tree, tree[i].children[j], depth + 1);\n  }\n}\n\nint32_t main()\n{\n  uint32_t N;\n  cin >> N;\n\n  vector<tree_t> tree(N + 1);\n\n  for (uint32_t i = 1; i <= N; i++) {\n    uint32_t n;\n    string str;\n    cin >> n >> str;\n    tree[i].str = str;\n    tree[n].children.push_back(i);\n  }\n\n  preorder(tree, 1, 0);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> g[1024];\nchar s[1024][64];\n\nvoid show(int v, int depth)\n{\n\tfor (int i = 0; i < depth; i++) printf(\".\");\n\tprintf(\"%s\\n\", s[v]);\n\n\tfor (int i = 0; i < g[v].size(); i++) show(g[v][i], depth + 1);\n}\n\nint main()\n{\n\tint n;\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++){\n\t\tint par;\n\t\tscanf(\"%d\", &par);\n\t\tif (par) g[--par].push_back(i);\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tshow(0, 0);\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct node{\n\tstring post;\t\t\t//ポスト内容\n\tvector< int > chnode;\t//子ノードのインデックス\n\tbool flg;\n};\n\nvoid output( vector<node> *tree, int indx, int depth ) {\n\tstring s = \"\";\n\ts.append(depth, '.');\n\n\tif( tree -> at(indx).flg ) return;\n\tcout << s << tree->at(indx).post << endl;\n\n\ttree -> at(indx).flg = true;\n\n\tif( tree->at(indx).chnode.size() > 0 )\n\t\tfor(int i = 0; i < tree->at(indx).chnode.size(); i++)\n\t\t\toutput( tree, tree->at(indx).chnode[i], depth+1);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\t\n\tvector< node > nlist;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tint k;\n\t\tstring M;\n\t\tcin >> k >> M;\n\n\t\tnode newnode;\n\t\tnewnode.post = M;\n\t\tnewnode.flg = false;\n\n\t\tif( k > 0 )\n\t\t\tnlist[k - 1].chnode.push_back( i );\n\n\t\tnlist.push_back( newnode );\n\t}\n\toutput( &nlist, 0, 0 );\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Tree{\npublic:\n    string s;\n    vector<Tree*> children;\n    \n    Tree(string s, int idx);\n    void add(int k, string s, int idx);\n    void print(int depth);\n};\n\nmap<int, Tree*> nodes;\n\nTree::Tree(string s, int idx): s(s){\n    nodes[idx] = this;\n}\nvoid Tree::add(int k, string s, int idx){\n    Tree *tree = new Tree(s, idx);\n    nodes[k]->children.push_back(tree);\n}\nvoid Tree::print(int depth){\n    for(int i=0; i<depth; i++)\n        cout << \".\";\n    cout << s << endl;\n    \n    for(auto child: children){\n        child->print(depth+1);\n    }\n}\n\nint N;\n\nint main(){\n    cin >> N;\n    \n    int k;\n    string s;\n    \n    cin >> k >> s; k;\n    Tree tree(s, k);\n    \n    for(int i=0; i<N-1; i++){\n        cin >> k >> s; k--;\n        tree.add(k, s, i+1);\n    }\n    \n    tree.print(0);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\ntypedef struct{\n    int parent, left, right;\n} Node;\nNode t[1002];\n\nvoid dfs(map<int, string> m, int u, int d){\n    rep(i,d) cout << '.';\n    cout << m[u] << endl;\n\n    if(t[u].left != INF){\n        dfs(m, t[u].left, d + 1);\n    }\n    if(t[u].right != INF){\n        dfs(m, t[u].right, d);\n    }\n}\n\nint brotherNum(int u){\n    if(t[u].right == INF){\n        return u;\n    }else{\n        return brotherNum(t[u].right);\n    }\n}\n\nint main(){\n    rep(i,1002) t[i].parent = t[i].left = t[i].right = INF;\n    map<int, string> m;\n    int n;\n\n    cin >> n;\n    rep(i,n){\n        int inp;\n        string s;\n\n        cin >> inp >> s;\n        m[i + 1] = s;\n\n        t[i + 1].parent = inp;\n        if(t[inp].left == INF){\n            t[inp].left = i + 1;\n        }else{\n            t[brotherNum(t[inp].left)].right = i + 1;\n        }\n    }\n    //range(i,1,n + 1){ cout << t[i].parent << ' ' << t[i].left << ' ' << t[i].right << endl; }\n    dfs(m, 1, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct mes{\n    mes* pre;\n    vector<mes*> fol;\n    string m;\n};\nvector<mes>vec;\n\nvoid dfs(mes m, int d){\n    for(int i=0;i<d;i++)\n        cout<<\".\";\n    cout<<m.m<<endl;\n    for(int i=0;i<m.fol.size();i++)\n        dfs(*m.fol[i],d+1);\n}\nint main(){\n    int n, k;\n    string str;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        mes me;\n        vec.push_back(me);\n    }\n    for(int i=0;i<n;i++){\n        cin>>k>>str;\n        vec[i].pre = &vec[k-1];\n        vec[i].m = str;\n        vec[k-1].fol.push_back(&vec[i]);\n    }\n   // dfs(vec[0],0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> par[1000];\nstring s[1000];\n\nvoid dfs(int depth, int j){\n    for(int i = 0; i < depth; i++)  cout << \".\";\n    cout << s[j] << endl;\n\n    for(int i = 0; i < par[j].size(); i++){\n        dfs(depth+1, par[j][i]);\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    int k;\n    \n    cin >> k >> s[0];\n\n    if(n == 1){\n        cout << s[0] << endl;\n        return 0;\n    }\n\n    for(int i = 1; i < n; i++){\n        cin >> k >> s[i];\n        par[--k].push_back(i);\n    }\n\n    dfs(0, 0);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2619.cc: Thread Tree\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\n\n/* typedef */\n\ntypedef vector<int> vi;\n\n/* global variables */\n\nstring msgs[MAX_N];\nvi chlds[MAX_N];\n\n/* subroutines */\n\nvoid print_tree(int k, int idx) {\n  for (int i = 0; i < idx; i++) putchar('.');\n  cout << msgs[k] << endl;\n\n  for (vi::iterator vit = chlds[k].begin(); vit != chlds[k].end(); vit++)\n    print_tree(*vit, idx + 1);\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    int ki;\n    cin >> ki >> msgs[i];\n    ki--;\n    if (i > 0) chlds[ki].push_back(i);\n  }\n\n  print_tree(0, 0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\tint d; string s; cin >> d >> s;\n\t\trep(i, d)s = '.' + s;\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n    int u, v;\n\n    edge() { }\n    ~edge() { }\n\n    edge(int a, int b): u(a), v(b) { }\n};\n\nvoid rec(int ind, int depth, vector<edge>& ve, vector<string>& vm) {\n    for(int _ = 0; _ < depth; ++_) cout << '.';\n    cout << vm[ind] << endl;\n    for(edge& e: ve) {\n        if (e.u == ind) {\n            rec(e.v, depth + 1, ve, vm);\n        }\n    }\n}\n\n\nint main() {\n    int n;\n    vector<edge> ve;\n    vector<string> vm;\n    cin >> n;\n    for (int j = 0; j < n; ++j) {\n        int k;\n        string m;\n        cin >> k >> m;\n        ve.push_back(edge(k-1, j));\n        vm.push_back(m);\n    }\n    rec(0, 0, ve, vm);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nvector<pair<string, int>> lis[10010];\nmap<pair<string, int>, int> msi;\n\nvoid solve(int key,int cnt) {\n\trep(i, lis[key].size()) {\n\t\trep(j, cnt)cout << \".\";\n\t\tcout << lis[key][i].first << endl;\n\t\tint nkey = lis[key][i].second;\n\t\tsolve(nkey, cnt + 1);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tint num;\n\t\tstring s;\n\t\tcin >> num >> s;\n\t\tlis[num].push_back({ s,i + 1 });\n\t\tmsi[{s, i}] = i + 1;\n\t\t//if (s == \"I\")cout << msi[s] << endl;\n\t}\n\tsolve(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF (1e9+7)\n\nusing namespace std;\n\nstruct conv{\n  int time;\n  string content;\n  vector<int> child;\n  conv(int t, string c) : time(t), content(c) {}\n};\n\nvector<conv> posts;\n\nvoid dfs(int parent, int depth){\n  REP(i, depth) cout << \".\";\n  cout << posts[parent].content << endl;\n  REP(i, posts[parent].child.size()) dfs(posts[parent].child[i], depth+1);\n  return;\n}\n\nint main(){\n  int n; cin >> n;\n  REP(i, n){\n    int to; cin >> to;\n    string cont; cin >> cont;\n    posts.emplace_back(conv(i, cont));\n    if(to != 0) posts[to-1].child.push_back(i);\n  }\n  dfs(0, 0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef struct{\n\tstring name;\n\tvector<int> vec;\n}acount;\n\nacount a[1001];\n\nvoid print(int dot,int num){\n\tfor(int i = 0;i < dot;i++){\n\t\tcout << '.';\n\t}\n\tcout << a[num].name << endl;\n\tfor(int i = 0;i < a[num].vec.size();i++){\n\t\tprint(dot+1,a[num].vec[i]);\n\t}\n}\n\nint main(){\n\tint n,x;\n\tcin >> n;\n\tcin >> x >> a[1].name;\n\tfor(int i = 2;i <= n;i++){\n\t\tcin >> x >> a[i].name;\n\t\ta[x].vec.push_back(i);\n\t}\n\tprint(0,1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n  \nusing namespace std;\n\n#define pi 3.141592653589793\n\nstruct Thread {\n\tint num;\n\tstring node;\n\tint children[1001];\n\tint dotnum;\n};\n\ntypedef struct Thread th;\n\nvoid result(th m[], int cn[], int n)\n{\n\tfor(int i = 0; i < m[n].dotnum; i++){\n\t\tcout << \".\";\n\t}\n\tcout << m[n].node << endl;\n\tif(cn[n] == 0) return;\n\tfor(int i = 0; i < cn[n]; i++){\n\t\tresult(m, cn, m[n].children[i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint k[1001], children_num[1001] = {};\n\tth m[1001];\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> k[i] >> m[i].node;\n\t}\n\tm[0].dotnum = 0;\n\tfor(int i = 1; i < n; i++){\n\t\tint parent = k[i] - 1;\n\t\tm[i].num = i;\n\t\tm[k[i] - 1].children[children_num[parent]] = i;\n\t\tchildren_num[parent]++;\n\t\tm[i].dotnum = m[parent].dotnum + 1;\n\t}\n\tresult(m, children_num, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// * template\n\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntemplate<class T, class U> inline void fill_array(T &e, const U &v) { e = v; }\ntemplate<class T, class U, size_t s> inline void fill_array(T (&a)[s], const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U, size_t s> inline void fill_array(array<T, s> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U> inline void fill_array(vector<T> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\n\nstruct range {\n\ttypedef int Int;\n\tstruct iter {\n\t\tInt i;\n\t\tconst Int s;\n\t\tconstexpr iter(const Int &i_, const Int &s_):i(i_), s(s_) {}\n\t\tconstexpr bool operator!=(const iter &r) const { return s > 0 ? i < r.i : i > r.i; }\n\t\tconstexpr const Int &operator*() const { return i; }\n\t\titer &operator++() { i += s; return *this; }\n\t};\n\tconst Int f, l, s;\n\tconstexpr range(const Int &f_, const Int &l_, const Int &s_):f(f_), l(l_), s(s_) {}\n\tconstexpr range(const Int &f_, const Int &l_):f(f_), l(l_), s(1) {}\n\tconstexpr range(const Int &num):f(0), l(num), s(1) {}\n\tconstexpr iter begin() const { return iter(f, s); }\n\tconstexpr iter end() const { return iter(l, s); }\n};\n\n// * solve\n\nvoid output(int index, int depth, const vector<string> &s, const vector<vector<int>> &children) {\n\tcout << string(depth, '.') << s[index] << endl;\n\tfor(const auto &child : children[index]) {\n\t\toutput(child, depth + 1, s, children);\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> children(n);\n\tvector<string> s(n);\n\n\tfor(int i : range(n)) {\n\t\tint k;\n\t\tcin >> k >> s[i];\n\t\tif(i) children[k - 1].emplace_back(i);\n\t}\n\n\toutput(0, 0, s, children);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid print(int curr, int depth, vector<vector<int> >& list, vector<string>& res){\n    string dots = \"\";\n    for(int i=0; i<depth; i++){\n        dots += \".\";\n    }\n    cout << dots << res[curr] << endl;\n\n    for(int i=0; i<(int)list[curr].size(); i++){\n        print(list[curr][i], depth+1, list, res);\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<vector<int> > list(n+1);\n    vector<string> res(n+1);\n    for(int i=1; i<=n; i++){\n        int k;\n        cin >> k >> res[i];\n        list[k].push_back(i);\n    }\n\n    print(1, 0, list, res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\nint k[1001];\nstring str[1001];\nvector<int> G[1001];\n\nvoid dfs(int v,int d){\n\tfor(int i=0;i<d;i++){\n\t\tprintf(\".\");\n\t}\n\tcout << str[v] << endl;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tdfs(G[v][i],d+1);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&k[i]);\n\t\tG[k[i]].push_back(i);\n\t\tcin >> str[i];\n\t}\n\tdfs(1,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\ntypedef struct{\n  int p,l,r;\n  int num;\n  string s;\n}Tr;\nTr Thread[1001];\n\nvoid preorder(int n)\n{\n  if(n==-1)return;\n  for(int i=0;i<Thread[n].num;i++)cout<<'.';\n  cout<<Thread[n].s<<endl;\n  preorder(Thread[n].l);\n  preorder(Thread[n].r);\n}\nint main()\n{\n  int n,m,now;\n  cin>>n;\n  for(int i=0;i<n;i++)Thread[i].p=Thread[i].l=Thread[i].r=-1;\n  cin>>m>>Thread[0].s;\n  Thread[0].num=0;\n  for(int i=1;i<n;i++){\n    cin>>m>>Thread[i].s;\n    Thread[i].num=Thread[m-1].num+1;\n    if(Thread[m-1].l==-1)Thread[m-1].l=i;\n    else{\n      now=Thread[m-1].l;\n      while(1){\n        if(Thread[now].r==-1)break;\n\tnow=Thread[now].r;\n      }\n      Thread[now].r=i;\n    }\n  }\n  preorder(0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n    int n; cin >> n;\n    vector<string> M(n);\n    vector<vector<int>> reply(n + 1);\n    rep(i, n) {\n        int k; cin >> k >> M[i];\n        reply[k].push_back(i);\n    }\n    function<void(int, int)> dump = [&](int d, int k) {\n        if (k > n) return;\n        for (int& i : reply[k]) {\n            cout << string(d, '.') << M[i] << endl;\n            dump(d + 1, i + 1);\n        }\n    };\n    dump(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct mes{\n    mes* pre;\n    vector<mes*> fol;\n    string m;\n};\nvector<mes>vec;\n\nvoid dfs(mes m, int d){\n    for(int i=0;i<d;i++)\n        cout<<\".\";\n    cout<<m.m<<endl;\n    for(int i=0;i<m.fol.size();i++)\n        dfs(*m.fol[i],d+1);\n}\nint main(){\n    int n, k;\n    string str;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        mes me;\n        vec.push_back(me);\n    }\n    for(int i=0;i<n;i++){\n        cin>>k>>str;\n        vec[i].pre = &vec[k-1];\n        vec[i].m = str;\n        vec[k-1].fol.push_back(&vec[i]);\n    }\n    dfs(vec[0],0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for(int i=0;i<(n);i++)\nint N;\nvector<int>tree[1010];\nint K[1010];\nstring S[1010];\n\nvoid rec(int k,int p){\n    REP(i,p)cout<<'.';\n    cout<<S[k]<<endl;\n    \n    REP(i,tree[k].size()){\n        rec(tree[k][i],p+1);\n    }\n}\n\nint main(){\n    cin>>N;\n    REP(i,N){\n        cin>>K[i]>>S[i];\n        tree[K[i]-1].PB(i);\n    }\n    rec(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int N;\n    vector< vector<int> > V;\n    vector<string> M;\n    void input() {\n        cin >> N;\n        M.clear(); M.resize(N + 1);\n        V.clear(); V.resize(N + 1);\n        for (int i = 1; i <= N; i++) {\n            int k; string m;\n            cin >> k >> m;\n            V[k].push_back(i);\n            M[i] = m;\n        }\n    }\n\n    void print(int n, int level) {\n        for (int i = 0; i < level; i++) cout << '.';\n        cout << M[n] << endl;\n        for (int i = 0; i < V[n].size(); i++) {\n            int next = V[n][i];\n            print(next, level + 1);\n        }\n    }\n\n    void solve() {\n        print(1, 0);\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<string> m;\nvector<vector<int>> edge;\n\nvoid output(int v,int depth){\n    if(v!=0){\n        for(int i=0;i<depth-1;i++){\n            cout<<\".\";\n        }\n        cout<<m[v-1]<<endl;\n    }\n    for(int i=0;i<edge[v].size();i++){\n        output(edge[v][i],depth+1);\n    }\n    return;\n}\nint main(){    \n    int n;\n    cin>>n; \n    m.resize(n);\n    edge.resize(n+1);    \n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k>>m[i];\n        edge[k].push_back(i+1);\n    }\n    output(0,0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nvector<vi> v;\nvs res;\n\nvoid solve(int i, int d)\n{\n\tREP(i, d) cout << '.';\n\tcout << res[i] << endl;\n\tREP(j, v[i].size()) solve(v[i][j], d + 1);\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tv.resize(n);\n\tres.resize(n);\n\tREP(i, n)\n\t{\n\t\tint k;\n\t\tcin >> k >> res[i];\n\t\tk--;\n\t\tif (k >= 0) v[k].push_back(i);\n\t}\n\n\tsolve(0, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long int n;\nvector< pair< long long int, string > > v;\n\nint kansu( long long int k, long long int c ) {\n\n  for ( long long int i = 0; i < c; i++ ) {\n    cout << \".\";\n  }\n  cout << v[k].second << endl;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    if ( v[i].first == k + 1 ) {\n      kansu( i, c + 1 );\n    }\n\n  }\n\n  return 0;\n\n}\n\nint main() {\n\n  cin >> n;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    long long int in;\n    string s;\n    cin >> in >> s;\n    v.push_back( make_pair( in, s ) );\n\n  }\n\n  kansu( 0, 0 );\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstring M[1024];\nvector<int> G[1024];\n\nvoid dfs(int n, int d)\n{\n  rep(i, d) cout << \".\";\n  cout << M[n] << endl;\n  rep(i, G[n].size())\n    dfs(G[n][i], d+1);\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  rep(i, n){\n    int k;\n    cin >> k >> M[i]; k--;\n    G[k].push_back(i);\n  }\n  dfs(0, 0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Comment = tuple<string, vector<int>>;\n\nvoid print(int depth, int idx, vector<Comment> const & v) {\n  for (int i = 0; i < depth; ++i) {\n    cout << '.';\n  }\n  cout << get<0>(v[idx]) << endl;\n  for (int ch : get<1>(v[idx])) {\n    print(depth + 1, ch, v);\n  }\n}\n\nint main() {\n  int N;\n  cin >> N;\n  vector<Comment> v;\n  for (int i = 0; i < N; ++i) {\n    int K;\n    string S;\n    cin >> K >> S;\n    v.emplace_back(S, vector<int>());\n    if (--K >= 0) {\n      get<1>(v[K]).push_back(i);\n    }\n  }\n  print(0, 0, v);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nstring dir[1024];\nvector<int> subd[1024];\nvoid pr(int d,int n){\n  if(n!=0){\n    REP(i,n-1) cout << '.';\n    cout << dir[d] << endl;\n  }\n  REP(i,subd[d].size()){\n    pr(subd[d][i],n+1);\n  }\n}\nint main(void)\n{\n  int n;\n  cin >> n;\n  FOR(i,1,n+1){\n    int pa;\n    cin >> pa >> dir[i];\n    subd[pa].push_back(i);\n  }\n  pr(0,0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n string s[1010];\nvector<int> g[1010];\n\nvoid dfs(int x,int d){\n  for(int i=0;i<d;i++)cout<<\".\";\n  cout<<s[x]<<endl;\n  for(int i=0;i<g[x].size();i++){\n    dfs(g[x][i],d+1);\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  int k;\n  for(int i=1;i<=n;i++){\n    cin>>k>>s[i];\n    g[k].push_back(i);\n  }\n  dfs(1,0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1003,INF=1<<29;\nvector<int> tour;\nvector<int> G[MAX];\nint dis[MAX];\n\nvoid DFS(int u){\n    tour.push_back(u);\n    for(int to:G[u]){\n        dis[to]=dis[u]+1;\n        DFS(to);\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    vector<string> S(N);\n    \n    for(int i=0;i<N;i++){\n        int a;cin>>a;\n        a--;\n        cin>>S[i];\n        \n        if(a==-1) continue;\n        \n        G[a].push_back(i);\n    }\n    \n    dis[0]=0;\n    DFS(0);\n    \n    for(int a:tour){\n        for(int i=0;i<dis[a];i++) cout<<'.';\n        cout<<S[a]<<endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for(int i=(a);i>=(b);i--)\n#define RREP(i, n) RFOR(i, n, 0)\n#define MFOR(i, m) for(auto i=(m).begin();i!=(m).end();i++)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1 << 30;\n\ntemplate<typename T>\nvoid printv(vector<T> const& s) {\n  REP(i, SZ(s)) {\n    cout << s[i] << \" \";\n  }\n  cout << endl;\n}\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    // to, costで初期化\n    edge (int to, T cost) : src(-1), to(to), cost(cost) {}\n\n    // src, to, costで初期化\n    edge (int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    // toにxを代入？\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    \n    // edge()でtoを返す？\n    operator int() const {return to;}\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<Edges<int>>;\ntemplate<typename T>\nusing Matrix = vector<vector<T>>;\n\nint main () {\n  cin.tie(0);\n  cout << setprecision(10);\n\n  int n; cin >> n;\n  UnWeightedGraph graph(n+1);\n  vi depth(n+1);\n  depth[0] = -1;\n  vector<string> reply(n+1);\n  FOR(i, 1, n+1) {\n    int k; cin >> k;\n    string s; cin >> s;\n    depth[i] = depth[k]+1;\n    reply[i] = s;\n    graph[k].pb(edge<int> (k, i, -1));\n  }\n\n  stack<int> st;\n  st.push(1);\n  vector<bool> sel(n+1);\n  while(!st.empty()) {\n    int now = st.top(); st.pop();\n    if(sel[now]) continue;\n    sel[now] = true;\n    REP(i, depth[now]) {\n      cout << \".\";\n    }\n    cout << reply[now] << endl;\n    RREP(i, graph[now].size()-1) {\n      st.push(graph[now][i].to);\n    }\n    \n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n  int p,l,r;\n  string str;\n};\n\nnode t[1001];\n\nvoid pr(int n,int d){\n  if(n<0) return;\n  for(int i=0;i<d;i++)cout<<\".\";\n  cout<<t[n].str<<endl;\n  pr(t[n].l,d+1);\n  pr(t[n].r,d);\n}\n\nint main(){\n  int n,u;\n  cin>>u;\n  for(int i=0;i<u;i++) t[i].l=-1,t[i].p=-1,t[i].r=-1;\n  string str;\n  int f[1001]={};\n\n  for(int i=0;i<u;i++){\n    cin>>n>>str;\n    t[i].str=str;\n    t[i].p=n-1;\n    if(f[n]==0)f[n]=1,t[n-1].l=i;\n    else if(f[n]==1) t[t[n-1].l].r=i;\n  }\n  pr(0,0);   \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nint n;\nvector<string> a;\nmap<int, vector<int>> v;\n\nvoid func(int i, int d)\n{\n    cout<<string(d, '.')<<a[i]<<endl;\n    for(auto& e: v[i]) func(e, d+1);\n}\n\nint main()\n{\n    int k;\n    string m;\n    cin>>n>>k>>m;\n    a.push_back(m);\n    for(int i=1; i<n; ++i) {\n        cin>>k>>m;\n        v[k-1].push_back(a.size());\n        a.push_back(m);\n    }\n    func(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nvector<vector<string> > v;\nint n;\n\nvoid calc(int idx) {\n\tstring s(idx, '.');\n\tif (idx>= v.size() || v[idx].size() == 0)return;\n\tcout << s << v[idx][0] << endl;\n\tcalc(idx + 1);\n\tfor (int i = 1; i < v[idx].size(); i++) {\n\t\tcout << s << v[idx][i] << endl;\n\t}\n}\n \nint main() {\n\tint a, l;\n\tstring s;\n\tcin >> n;\n\tv = vector<vector<string> >(n+1);\n\trep(i, n) {\n\t\tcin >> a >> s;\n\t\tv[a].pb(s);\n\t}\n\tfor (auto it = v.begin(); it != v.end(); ++it) {\n\t\t//cout << it - v.begin() << endl;\n\t\tif ((*it).size() == 0) {\n\t\t\tit = v.erase(it);\n\t\t}\n\t\tif (it == v.end()) break;\n\t}\n\tcalc(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tstd::vector< std::pair<int,std::string> > th(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> th[i].first;\n\t\tcin >> th[i].second;\n\t}\n\tcout << th[0].second << endl;\n\n\tint now = 0;\n\tint d = 1;\n\tbool find = true;\n\tstd::vector<bool> check(n,false);\n\tstd::queue<int> q;\n\tstd::queue<int> deep;\n\tstd::queue<std::string> name;\n\tstd::string temp;\n\tfor (int i = 1; i < n; i++) {\n\t\td = 1;\n\t\tif ( !check[i] ) {\n\t\t\tfor (int k = 0; k < d; k++) {\n\t\t\t\tcout << \".\";\n\t\t\t}\n\t\t\tcout << th[i].second << endl;\n\t\t\tcheck[i] = true;\n\t\t}\n\n\t\tq.push(i+1);\n\t\tdeep.push(d);\n\t\tfind = true;\n\t\twhile ( !q.empty() ) {\n\t\t\tnow = q.front();\n\t\t\td = deep.front()+1;\n\t\t\tq.pop();\n\t\t\tdeep.pop();\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tif ( th[j].first == now && !check[j] ) {\n\t\t\t\t\ttemp = \"\";\n\t\t\t\t\tfor (int k = 0; k < d; k++) {\n\t\t\t\t\t\ttemp +=  \".\";\n\t\t\t\t\t}\n\t\t\t\t\ttemp += th[j].second;\n\t\t\t\t\tq.push(j+1);\n\t\t\t\t\tdeep.push(d);\n\t\t\t\t\tname.push(temp);\n\t\t\t\t\tcheck[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile ( !name.empty() ) {\n\t\t\tcout << name.front() << endl;\n\t\t\tname.pop();\n\t\t}\n\t}\n\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> ch[1000];\nstring s[1000];\nvoid dfs(int x,int d=0){\n\tcout << string(d,'.') << s[x] << endl;\n\tfor( auto e : ch[x]) dfs(e,d+1);\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint t;\n\t\tcin >> t;\n\t\t--t;\n\t\tif(i!=0) ch[t].push_back(i);\n\t\tcin >> s[i];\n\t}\n\tdfs(0);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nconst double EPS = 1e-9;\nFILE *fp;\n\n//#define MYLOCAL\n\nvoid init() {\n#ifdef MYLOCAL\n    fp = freopen(\"/Users/sekiya9311/Documents/comp_programming/comp_programming/in.txt\", \"r\", stdin);\n    if (fp == NULL) assert(false);\n#endif\n    \n}\n\nvoid last() {\n#ifdef MYLOCAL\n    fclose(fp);\n#endif\n    exit(0);\n}\n\nconst int MAX = 1010;\nint k[MAX];\nstring M[MAX];\nvector<int> graph[MAX];\nchar strbuf[55];\nvoid dfs(int now, int cnt) {\n    M[now] = string(cnt, '.') + M[now];\n    printf(\"%s\\n\", M[now].c_str());\n    for (auto &&e : graph[now]) {\n        dfs(e, cnt + 1);\n    }\n}\nvoid solve(int n) {\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", k + i);\n        k[i]--;\n        scanf(\"%s\", strbuf);\n        M[i] = strbuf;\n    }\n    for (int i = 0; i < n; i++) {\n        if (k[i] == -1) continue;\n        graph[k[i]].emplace_back(i);\n    }\n    dfs(0, 0);\n    last();\n}\n\nsigned main(void) {\n    LL n, m, p, a, b, c, x, y, z, q;\n    string s;\n    bool f = false;\n    init();\n    while (cin >> n, n) {\n        solve(n);\n        //return 0;\n    }\n    last();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct mes{\n    mes* pre;\n    vector<mes*> fol;\n    string m;\n};\nvector<mes>vec;\n\nvoid dfs(mes m, int d){\n    for(int i=0;i<d;i++)\n        cout<<\".\";\n    cout<<m.m<<endl;\n    for(int i=0;i<m.fol.size();i++)\n        dfs(*m.fol[i],d+1);\n}\nint main(){\n    int n, k;\n    string str;\n    cin>>n;\n    for(int i=0;i<=n;i++){\n        mes me;\n        vec.push_back(me);\n    }\n    for(int i=1;i<=n;i++){\n        cin>>k>>str;\n        vec[i].pre = &vec[k];\n        vec[i].m = str;\n        vec[k].fol.push_back(&vec[i]);\n    }\n    dfs(vec[1],0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N;\nvint G[1111];\nstring S[1111];\nint dep[1111];\nvoid dfs(int v,int p,int d){\n    dep[v]=d;\n    rep(i,dep[v])cout<<\".\";\n    cout<<S[v]<<endl;\n    for(int to:G[v]){\n        if(to==p)continue;\n        dfs(to,v,d+1);\n    }\n}\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cin>>N;\n    rep(i,N){\n        int p;cin>>p;p--;\n        if(p>=0)G[p].pb(i);\n        cin>>S[i];\n    }\n\n    dfs(0,-1,0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nbool visited[1001];\n\nvoid dfs(int current,\n         int depth,\n         const vector<int> edges[1001],\n         const vector<string>& messages){\n  for(int i = 0; i < depth; i++){\n    cout << \".\";\n  }\n  cout << messages[current] << endl;\n  for(int i = 0; i < edges[current].size(); i++){\n    int next = edges[current][i];\n    if(visited[next]) continue;\n    visited[next] = true;\n    dfs(next,depth+1,edges,messages);\n  }\n}\n\nint main(){\n  int num_of_posts;\n  while(~scanf(\"%d\",&num_of_posts)){\n    memset(visited,false,sizeof(visited));\n\n    vector<int> edges[1001];\n    vector<string> messages;\n    for(int post_i = 0; post_i < num_of_posts; post_i++){\n      string message;\n      int reply_to;\n      cin >> reply_to >> message;\n      messages.push_back(message);\n\n      if(reply_to - 1 >= 0){\n        edges[reply_to - 1].push_back(post_i);\n      }\n    }\n    dfs(0,0,edges,messages);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define REP(x,a,b) for(int x=a;x<=b;x++)\n#define rep(x,n) for(int x=0;x<n;x++)\n#define cint(x) int x;cin>>x;\n#define cins(x) string x;cin>>x;\n#define pb push_back\n#define repv(x,v) for(int x=0;x<v.size();x++)\ntypedef pair<int,int> P;\n\nvector<int>child[1001];\nmap<int,string>name;\nvoid dfs(int id, int depth){\n\tif(depth>=0){\n\t\trep(i,depth)cout<<\".\";\n\t\tcout<<name[id]<<endl;\n\t}\n\trepv(i,child[id]){\n\t\tdfs(child[id][i],depth+1);\n\t}\n}\n\nint main(){\n\t\n\tcint(n);\n\tREP(i,1,n){\n\t\tcint(t);\n\t\tcins(s);\n\t\tname[i]=s;\n\t\tchild[t].pb(i);\n\t}\n\tdfs(0,-1);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, string>P;\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tvector<P>v;\n\trep(i, n) {\n\t\tint k; string s; cin >> k >> s;\n\t\tv.push_back(P(k, s));\n\t}\n\tsort(v.begin(), v.end());\n\tfor (P p : v) {\n\t\trep(i, p.first)cout << '.';\n\t\tcout << p.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* main code starts from line 155. */\n\n/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<decltype((v).front())>())\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i <= (b); i++)\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); i--)\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T>\nT mypow(T b, T n) {\n    if (n == 0) return 1;\n    if (n == 1) return n;\n    if (n % 2 == 0) {\n        return mypow(sq(b), n / 2);\n    } else {\n        return mypow(b, n - 1) * b;\n    }\n}\n\n/* --------------------\ntemplate <typename T>\nT mypow(T b, T n) {\n    if (n == 0) return 1;\n    if (n == 1) return n % MOD;\n    if (n % 2 == 0) {\n        return mypow(sq(b) % MOD, n / 2);\n    } else {\n        return mypow(b, n - 1) * b % MOD;\n    }\n}\n-------------------- */\n\n#define fcout cout << fixed << setprecision(10)\n\n/* ----------- debug ---------- */\n\ntemplate <typename T, typename U>\nvoid testP2(T a, U b) {\n    cout << \"(\" << a << \", \" << b << \")\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV(T v) {\n    cout << \"[\";\n    for (auto i : v) {\n        cout << i << \", \";\n    }\n    cout << \"\\b\\b]\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV2(T v) {\n    for (auto sv : v) {\n        testV(sv);\n    }\n    cout << endl;\n    return;\n}\n\n#define GET_VAR_NAME(variable) #variable\n#define test(x) cout << GET_VAR_NAME(x) << \" = \" << x << endl;\n#define testP(p)                      \\\n    cout << GET_VAR_NAME(p) << \" = \"; \\\n    testP2(p.fst, p.snd);\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n// const ll dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const ll dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n/* ---------- Type Definition ----------- */\n\n\n/* ---------- Global Variance ----------- */\n\nV<V<ll>> child(1010);\nV<string> name(1010);\n\n/* ------------- Functions -------------- */\n\nvoid dfs(ll v, ll d) {\n    FOR(_, 1, d) {\n        cout << '.';\n    }\n    cout << name[v] << endl;\n\n    for (ll sv : child[v]) {\n        dfs(sv, d + 1);\n    }\n    return;\n}\n\n/* ----------- Main Function ------------ */\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N;\n    cin >> N;\n\n    FOR(i, 0, N - 1) {\n        ll k;\n        cin >> k;\n        if (k > 0) {\n            k--;\n            child[k].pb(i);\n        }\n        cin >> name[i];\n    }\n\n    dfs(0, 0);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\nmap<int, queue<pair<int, string>>> msgs;\n\nbool dfs(int tar, int depth){\n    if(msgs[tar].empty()) return false;\n\n    pair<int, string> cur_msg = msgs[tar].front();\n    msgs[tar].pop();\n\n    rep(i, depth) cout << \".\";\n    cout << cur_msg.S << endl;\n    \n    while(dfs(cur_msg.F, depth + 1));\n\n    return true;\n}\n\nint main(void){\n    for(int n; cin >> n;){\n        int idx = 0;\n        msgs.clear();\n\n        rep(i, n){\n            int k;\n            string m;\n            cin >> k >> m;\n\n            msgs[k].push(mp(++idx, m));\n        }\n\n        dfs(0, 0);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <stack>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tstd::vector< std::pair<int,std::string> > th(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> th[i].first;\n\t\tcin >> th[i].second;\n\t}\n\n\tint now = 0;\n\tint d = 1;\n\tstd::vector<bool> check(n,false);\n\tstd::stack<int> s;\n\tstd::stack<int> deep;\n\tstd::stack<std::string> name;\n\tstd::string temp;\n\ts.push(1);\n\tdeep.push(0);\n\tname.push(th[0].second);\n\twhile ( !s.empty() ) {\n\t\tcout << name.top() << endl;\n\t\td = deep.top()+1;\n\t\tnow = s.top();\n\t\tname.pop();\n\t\tdeep.pop();\n\t\ts.pop();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif ( th[n-1-i].first == now && !check[n-i-1] ) {\n\t\t\t\ttemp = \"\";\n\t\t\t\tfor (int k = 0; k < d; k++) {\n\t\t\t\t\ttemp += \".\";\n\t\t\t\t}\n\t\t\t\ttemp += th[n-1-i].second;\n\t\t\t\tname.push(temp);\n\t\t\t\tdeep.push(d);\n\t\t\t\ts.push(n-i);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\n//directed graph\nvector<int> G[1000];\n//hash\nstring name[1000];\n\nvoid dfs(int now, int d)\n{\n    rep(i,d) printf(\".\");\n    cout << name[now] << endl;\n\n    rep(i,G[now].size()) dfs(G[now][i],d+1);\n}\n\nint main()\n{\n    int n;\n    cin >>n;\n\n    int k;\n    string m;\n\n    //make root\n    cin >>k >>m;\n    name[0]=m;\n\n    //make tree\n    rep(i,n-1)\n    {\n        cin >>k >>m;\n        name[i+1]=m;\n        G[k-1].pb(i+1);\n    }\n\n    //answer\n    dfs(0,0);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\nint num[1000];\nstring stri[1000];\nint n;\n\nvoid fanc(int loc, int deep)\n{\n\tfor (int i = 0; i<n; ++i)\n\t{\n\t\tif (num[i] == loc)\n\t\t{\n\t\t\tcout << string(deep, '.') << stri[i] << \"\\n\";\n\t\t\tfanc(i+1, deep + 1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i<n; i++)\n\t{\n\t\tcin >> num[i];\n\t\tcin >> stri[i];\n\t}\n\n\tfanc(0, 0);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N; cin >> N;\n\n  vector<int> g[1001];\n  vector<string> msg(1001);\n\n  rep(i, N) {\n    int k; string m; cin >> k >> m;\n    g[k].emplace_back(i+1);\n    msg[i+1] = m;\n  }\n\n  std::function<void(int, int)> dfs = [&](int idx, int depth) {\n    if(depth + 1) {\n      rep(i, depth) cout << '.';\n      cout << msg[idx] << endl;\n    }\n    rep(i, g[idx].size()) {\n      dfs(g[idx][i], depth + 1);\n    }\n  };\n\n  dfs(0, -1);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) { ll d = euclid(b, a % b, y, x);\n        return y -= a/b * x, d; }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1) ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1); return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e) return Mod(1);\n        Mod r = *this ^ (e / 2); r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nvector<int> childs[1005];\nvector<string> msg(1005);\n\nvoid dfs(int x, int d) {\n    rep(i, 0, d) cout << '.';\n    cout << msg[x] << endl;\n    for (int h : childs[x]) dfs(h, d + 1);\n}\n\nint main() {\n    \n    \n    int n; cin >> n;\n    rep(i, 1, n + 1) {\n        int p; cin >> p;\n        childs[p].push_back(i);\n        cin >> msg[i];\n    }\n    dfs(1, 0);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef struct{\n  int k;\n  char m[50];\n}res;\n\nres r[1000];\nint adj[1000][1000] = {{0}};\nint n;\nvoid show(int num,int f){\n  f++;\n  for(int i=0;i<f;++i)\n    putchar('.');\n  printf(\"%s\\n\",r[num].m);\n\n  for(int i = num ;i<n;++i)\n    if(adj[i][num]){\n      show(i,f);\n    }\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;++i)\n    for(int j=0;j<n;++j)\n      adj[i][j]=0;\n  for(int i=0;i<n;++i){\n    cin >> r[i].k >> r[i].m;\n    adj[i][r[i].k-1] = 1;\n  }\n\n  show(0,-1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nvector<int> G[1001];\nstring s[1000];\nvoid dfs(int v,int d){\n\tif(v!=0){\n\t\tcout<<string(d,'.');\n\t\tcout<<s[v-1]<<endl;\n\t}\n\tfor(int u:G[v]) dfs(u,d+1);\n}\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,N){\n\t\tint a;\n\t\tcin>>a;\n\t\tG[a].pb(i+1);\n\t\tcin>>s[i];\n\t}\n\tdfs(0,-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tused = false;\n\t\tdepth = 0;\n\t}\n\tchar message[51];\n\tint depth;\n\tbool used;\n\tvector<int> children;\n};\n\nvoid recursive(Info info[],int id){\n\tfor(int i = 0; i < info[id].depth; i++)printf(\".\");\n\tprintf(\"%s\\n\",info[id].message);\n\tinfo[id].used = true;\n\tfor(int i = 0; i < info[id].children.size(); i++){\n\t\trecursive(info,info[id].children[i]);\n\t}\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\tInfo info[N+1];\n\n\tint k;\n\tscanf(\"%d\",&k);\n\tscanf(\"%s\",info[1].message);\n\n\tfor(int i = 2; i <= N; i++){\n\t\tscanf(\"%d\",&k);\n\t\tscanf(\"%s\",info[i].message);\n\t\tinfo[i].depth = info[k].depth+1;\n\t\tinfo[k].children.push_back(i);\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(info[i].used == false){\n\t\t\trecursive(info,i);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\nvector<vector<int64>> G;\nvector<string> v;\n\nvoid dfs(int64 u = 0, int64 level = -1) {\n  if (u != 0) {\n    REP(i, level) cout << \".\";\n    cout << v[u] << endl;\n  }\n  REP(i, G[u].size()) {\n    dfs(G[u][i], level+1);\n  }\n}\n\nint main(void) {\n  int64 n;\n  cin >> n;\n  G.resize(n+1);\n  v.resize(n+1);\n  REP(i, n) {\n    int64 k; string s;\n    cin >> k >> s;\n    G[k].push_back(i+1);\n    v[i+1] = s;\n  }\n  dfs(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> G(n);\n    vector<string> v(n);\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x >> v[i];\n        if(x){\n            G[x-1].emplace_back(i);\n            G[i].emplace_back(x-1);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        reverse(G[i].begin(),G[i].end());\n    }\n    stack<int> s;\n    vector<int> visited(n, 0), num(n);\n    s.emplace(0);\n    vector<int> dp(n);\n    while(!s.empty()){\n        int a = s.top(); s.pop();\n        visited[a]++;\n        cout << string(dp[a], '.') << v[a] << \"\\n\";\n        for (auto &&i : G[a]) {\n            if(!visited[i]) {\n                dp[i] = dp[a]+1;\n                s.emplace(i);\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n  \nusing namespace std;\n\n#define pi 3.141592653589793\n\nstruct Thread {\n\tstring node;\n\tint children[1001];\n\tint dotnum;\n};\n\ntypedef struct Thread th;\n\nvoid result(th m[], int cn[], int n)\n{\n\tfor(int i = 0; i < m[n].dotnum; i++){\n\t\tcout << \".\";\n\t}\n\tcout << m[n].node << endl;\n\tif(cn[n] == 0) return;\n\tfor(int i = 0; i < cn[n]; i++){\n\t\tresult(m, cn, m[n].children[i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tint k[1001], children_num[1001] = {};\n\tth m[1001];\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> k[i] >> m[i].node;\n\t}\n\tm[0].dotnum = 0;\n\tfor(int i = 1; i < n; i++){\n\t\tint parent = k[i] - 1;\n\t\tm[k[i] - 1].children[children_num[parent]] = i;\n\t\tchildren_num[parent]++;\n\t\tm[i].dotnum = m[parent].dotnum + 1;\n\t}\n\tresult(m, children_num, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nint n;\nvector<vector<int>> g;\nvector<string> vs;\nvoid dfs(int cur, int p) {\n\tfor (int i = 0; i < p; i++)cout << \".\";\n\tcout << vs[cur] << \"\\n\";\n\tfor (int i = 0; i < g[cur].size(); i++) {\n\t\tdfs(g[cur][i], p + 1);\n\t}\n}\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tint kkt = 1;\n\twhile (kkt--) {\n\t\tscanf(\"%d\", &n);\n\t\tg.resize(n);\n\t\tvs.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p; scanf(\"%d\", &p);\n\t\t\tcin >> vs[i];\n\t\t\tif (p != 0) {\n\t\t\t\tp--;\n\t\t\t\tg[p].push_back(i);\n\t\t\t}\n\t\t}\n\t\tdfs(0, 0);\n\t}\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nint n,x;\nvector<pair<int,string> > c[1001];\nvoid Put(int p,int len){\n\tfor(int i=0;i<c[p].size();i++){\n\t\tfor(int j=0;j<len;j++)cout<<\".\";\n\t\tcout<<c[p][i].second<<endl;\n\t\tPut(c[p][i].first,len+1);\n\t}\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tpair<int,string> s;\n\tfor(int i=0;i<n;i++){\n\t\ts.first=i+1;\n\t\tcin>>x>>s.second;\n\t\tc[x].push_back(s);\n\t}\n\tPut(0,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nint k[1111];\nstring s[1111];\n\nvoid dfs(int d,int dd){\n\twhile(1){\n\t\tint ni=-1;\n\t\trep(i,n){\n\t\t\tif(k[i]==d){\n\t\t\t\tni=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ni==-1)return;\n\t\trep(i,dd)cout<<\".\";\n\t\tcout<<s[ni]<<endl;\n\t\tk[ni]=-1;\n\t\tdfs(ni+1,dd+1);\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n;\n\trep(i,n)cin>>k[i]>>s[i];\n\tdfs(0,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <utility>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<string, int> psi;\n\nvoid print(vector<vector<psi>> &sl, int fst = 0, int depth = 0) {\n    REP (i, 0, sl[fst].size()) {\n        REP (j, 0, depth) cout << '.';\n        cout << sl[fst][i].first << endl;\n        print(sl, sl[fst][i].second, depth + 1);\n    }\n}\n\nint main () {\n    int n;\n    cin >> n;\n    vector<vector<psi>> slist(n + 1);\n    REP (i, 0, n) {\n        int k;\n        string s;\n        cin >> k >> s;\n        slist[k].push_back({s, i + 1});\n    }\n    print(slist);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nint n;\nvector<string> a;\nmap<string, vector<string>> v;\n\nvoid func(string& s, int d)\n{\n    cout<<string(d, '.')<<s<<endl;\n    for(auto& e: v[s]) func(e, d+1);\n}\n\nint main()\n{\n    int k;\n    string m;\n    cin>>n>>k>>m;\n    a.push_back(m);\n    for(int i=1; i<n; ++i) {\n        cin>>k>>m;\n        a.push_back(m);\n        v[a[k-1]].push_back(m);\n    }\n    func(a[0], 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<pair<string, vector<int> > > Tree;\n\nstring put_nchar(char c, int n)\n{\n    string S;\n    \n    for(int i = 0; i < n; i++)\n    {\n        S += c;\n    }\n    \n    return S;\n}\n\nvoid rec(int node, int depth)\n{\n    cout << put_nchar('.', depth) << Tree[node].first << endl;\n    \n    for(int i = 0; i < Tree[node].second.size(); i++)\n    {\n        rec(Tree[node].second[i], depth + 1);\n    }\n}\n\nint main()\n{\n    int n;\n    \n    string name; int parent;\n    \n    cin >> n;\n    \n    Tree = vector<pair<string, vector<int> > >(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> parent >> name;\n        \n        Tree[i].first = name;\n        \n        if(parent != 0)\n        {\n            Tree[parent - 1].second.push_back(i);\n        }\n    }\n    \n    rec(0, 0);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 1000\n \nstruct State{\n    string s;\n    int next,l;\n    State(string s,int next,int l) \n\t: s(s),next(next),l(l) {}\n};\n \nint idx[MAX_N],len[MAX_N];\nvector<State> G[MAX_N];\n \nvoid solve(int x){\n    if(len[x] == idx[x]){\n\treturn;\n    }\n    for(int i = 0 ; i < len[x] ; i++){\n\tcout << string(G[x][idx[x]].l,'.') + G[x][idx[x]].s << endl;\n\tsolve(G[x][idx[x]++].next);\n    }\n}\n \nint main(){\n    int N,K,size[MAX_N] = {0};\n    string start,in;\n    cin >> N >> size[0] >> start;\n    for(int i = 1 ; i < N ; i++){\n\tcin >> K >> in;\n\tsize[i] = size[K-1]+1;\n\tG[K-1].push_back(State(in,i,size[i]));\n    }\n    cout << start << endl;\n    for(int i = 0 ; i < N ; i++){\n\tlen[i] = G[i].size();\n    }\n    solve(0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 998244353\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nvector<vector<pair<int, string>>> g(1010);  \n\nvoid dfs(int v, int depth, int par){\n\n    string s = \"\";\n    for(int i=0; i<depth; i++) s += '.';\n    for(auto e: g[v]){\n        int u = e.first;\n        string t = e.second;\n        if(u == par) continue;\n        cout << s << t << endl;\n        dfs(u, depth+1, v);\n    }\n\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n\n    int n;\n    cin >> n;\n    \n    REP(i,n){\n        int par; cin >> par;\n        string s; cin >> s;\n        g[par].push_back({i+1, s});\n    }\n\n    dfs(0, 0, -1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef struct{\n  int k;\n  char m[50];\n}res;\n\nint main(){\n  int n;\n  cin >> n;\n  res r[n];\n  int adj[n][n];\n  for(int i=0;i<n;++i)\n    for(int j=0;j<n;++j)\n      adj[i][j]=0;\n  for(int i=0;i<n;++i){\n    cin >> r[i].k >> r[i].m;\n    adj[i][r[i].k-1] = 1;\n  }\n\n  for(int i=0;i<n;++i){\n    for(int j=0;j<n;j++)\n      printf(\"%d \",adj[i][j]);\n    putchar('\\n');\n  }\n  \n  printf(\"%s\\n\",r[0].m);\n  for(int i = 1;i<n;++i)\n    for(int j = 0;j<n;++j){\n      if(adj[i][j]==1){\n\tfor(int k=0;k<j+1;++k)\n\t  putchar('.');\n\tprintf(\"%s\\n\",r[i].m);\n      }\n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n  string name;\n  vector<int> child;\n};\n\nvoid print_tree(vector<Node> &tree, int dep, int v) {\n  for ( int i = 0; i < dep; i++ ) cout << '.';\n  cout << tree[v].name << endl;\n  for ( int i = 0; i < (int)tree[v].child.size(); i++ ) {\n    print_tree(tree, dep+1, tree[v].child[i]);    \n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  vector<Node> tree(n);\n  for ( int i = 0; i < n; i++ ) {\n    int dep;\n    string name;\n    cin >> dep >> name;\n    tree[i].name = name;\n    if ( dep ) tree[dep-1].child.push_back(i);\t       \n  }\n\n  print_tree(tree, 0, 0);  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nvector<string> lis[10010];\nmap<string, int> msi;\n\nvoid solve(int num,int cnt) {\n\trep(i, lis[num].size()) {\n\t\trep(j, cnt)cout << \".\";\n\t\tcout << lis[num][i] << endl;\n\t\tsolve(msi[lis[num][i]], cnt + 1);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tint num;\n\t\tstring s;\n\t\tcin >> num >> s;\n\t\tlis[num].push_back(s);\n\t\tmsi[s] = i + 1;\n\t}\n\tsolve(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvector<pair<int, string>> inputs[2000];\n\nvoid output(int now, int itr) {\n\tfor (auto x : inputs[now]) {\n\t\tREP(q, itr) {\n\t\t\tcout << \".\";\n\t\t}\n\t\tcout << x.second << endl;\n\t\toutput(x.first, itr + 1);\n\t}\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\tstring s;\n\t\tcin >> s;\n\t\tinputs[a].push_back(mp(i + 1, s));\n\t}\n\toutput(0, 0);\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\ntypedef pair <int,string> P;\nvector <int> rep[1001];\nstring str[1001];\nint n;\nvoid saiki(string ten, int ima) {\n  for(int i=0;i<rep[ima].size();i++) {\n    cout << ten << str[rep[ima][i]] << endl;\n    saiki(ten+'.',rep[ima][i]);\n  }\n}\nint main() {\n  cin >> n;\n  for(int i=1;i<=n;i++) {\n    int a;\n    cin >>a >> str[i];\n    rep[a].push_back(i);\n  }\n  saiki(\"\",0);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,string> P;\nint n;\n\nvoid Print(vector<queue<P> > &qs, int dot, int target) {\n    while(qs[target].size()) {\n        for(int i = 0; i < dot; i++) cout << \".\";\n        P p  = qs[target].front(); qs[target].pop();\n        cout << p.second << endl;\n        if(p.first < n)\n            Print(qs, dot + 1, p.first);\n    }\n}\n\nint main() {\n    cin >> n;\n    vector<int> k(n);\n    vector<string> m(n);\n    for(int i = 0; i < n; i++) {\n        cin >> k[i] >> m[i];\n    }\n\n    vector<queue<P> > ques(n);\n    for(int i = 0; i < n; i++) {\n        ques[k[i]].push(P(i + 1, m[i]));\n    }\n\n    Print(ques, 0, 0);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nstring s[1001];\nvector<int> v[1001];\nvoid dfs(int d,int p){\n  for(int i=0;i<d;i++)cout<<'.';\n  cout<<s[p]<<endl;\n  for(int i=0;i<v[p].size();i++)\n    dfs(d+1,v[p][i]);\n}\nint main(){\n  cin>>n;\n  for(int i=1;i<=n;i++){\n    cin>>k>>s[i];\n    v[k].push_back(i);\n  }\n  dfs(0,1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int>V[1000];\nstring S[1000];\nvoid DFS(int a, int b) {//??±?????????????????????\n\tfor (int c = 0; c < a; c++)printf(\".\");\n\tcout << S[b] << endl;\n\tfor (int c : V[b]) {\n\t\tDFS(a + 1, c);\n\t}\n}\nsigned main() {\n\tint a; scanf(\"%d\", &a);\n\tint b; scanf(\"%d\", &b); \n\tcin >> S[0];\n\tfor (int d = 1; d < a; d++) {\n\t\tscanf(\"%d\", &b); cin >> S[d];\n\t\tV[b - 1].push_back(d);\n\t}\n\tDFS(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nstruct Node {\n  string name;\n  vi children;\n\n  Node() {\n  }\n};\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<Node> nodes(n);\n  rep(i, n) {\n    int k;\n    string m;\n    cin >> k >> m;\n    k--;\n    nodes[i].name = m;\n    if (k >= 0) nodes[k].children.pb(i);\n  }\n  function<void(int, int)> dfs = [&](int p, int depth) {\n    cout << string(depth, '.') << nodes[p].name << endl;\n    for (int x : nodes[p].children) dfs(x, depth + 1);\n  };\n  dfs(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,a,n) for(int i=a;i<n;i++)\nint n,k[1919];\nstring s[1919];\nvector<int>v[1919];\nvoid dfs(int u,int d){\n\tr(i,0,d)cout<<'.';\n\tcout<<s[u]<<endl;\n\tr(i,0,v[u+1].size())dfs(v[u+1][i],d+1);\n}\nint main(){\n\tcin>>n;\n\tr(i,0,n){cin>>k[i]>>s[i];\n\t\tv[k[i]].push_back(i);\n\t}dfs(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nvector<int> ch[1010];\nstring com[1010];\nint n;\nbool flg[1010];\n\nvoid put(int k, int d){\n    rep(i,d) putchar('.');\n    cout << com[k] << endl;\n    flg[k] = true;\n    for(int i : ch[k]){\n        put(i,d+1);\n    }\n}\n\nint main(){\n    while(cin >> n){\n        rep(i,n) ch[i].clear(), flg[i] = false;\n        rep(i,n){\n            int k;\n            cin >> k >> com[i];\n            if(i!=0) ch[k-1].push_back(i);\n        }\n        rep(i,n){\n            if(!flg[i]) put(i,0);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (int)(N); i++)\n#define REP(i, init, N) for (int i = (init); i < (int)(N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nstruct T{\n    string s;\n    VI childs;\n};\n\nvoid dfs(vector<T> &ts, int x, int deep) {\n    if (x != 0) {\n        rep(i, deep - 1) {\n            cout << \".\";\n        }\n        cout << ts[x].s << endl;\n    }\n\n    for (auto c : ts[x].childs) {\n        dfs(ts, c, deep + 1);\n    }\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n    vector<T> ts(n + 1);\n    rep(i, n) {\n        string s;\n        int parent;\n        cin >> parent >> s;\n        ts[i + 1].s = s;\n        ts[parent].childs.PB(i + 1);\n    }\n\n    dfs(ts, 0, 0);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\nvector<string> name;\nvector<vector<int>> G;\nvoid rec(int n,int dep){\n    cout << string(dep,'.') << name[n] << endl;\n    for(auto next:G[n]){\n        rec(next,dep+1);\n    }\n}\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    name.resize(n);\n    G.resize(n);\n    for(int i = 0; i < n;i++){\n        int p; cin >> p;\n        string S; cin >> S;\n        name[i] = S;\n        if(p == 0) continue;\n        p--;\n        G[p].push_back(i);\n    }\n    rec(0,0);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\n\nstruct node{\n    int level;\n    string name;\n    int index;\n    vector<node> children;\n};\nvector<node> v;\n\nvoid dfs(int num,node& n){\n    if(n.level != -1){\n\tREP(i,n.level) cout << \".\";\n\tcout << n.name << endl;\n    }\n    REP(i,n.children.size()){\n\tnode next = v[n.children[i].index];\n\tdfs(next.index,next);\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n    v = vector<node>(n+1);\n    v[0] = (node){-1,\"\",-1,vector<node>()};\n    FOR(i,1,n+1){\n\tint k;\n\tstring m;\n\tcin >> k >> m;\n\tv[i] = (node){v[k].level+1,m,i,vector<node>()};\n\tv[k].children.PB(v[i]);\n    }\n\n    dfs(0,v[0]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nvector<vector<string> > v;\nint n;\n\nvoid calc(int idx) {\n\tstring s(idx, '.');\n\tif (idx>= v.size() || v[idx].size() == 0)return;\n\tcout << s << v[idx][0] << endl;\n\tcalc(idx + 1);\n\tfor (int i = 1; i < v[idx].size(); i++) {\n\t\tcout << s << v[idx][i] << endl;\n\t}\n}\n \nint main() {\n\tint a, l;\n\tstring s;\n\tcin >> n;\n\tv = vector<vector<string> >(n+1);\n\trep(i, n) {\n\t\tcin >> a >> s;\n\t\tv[a].pb(s);\n\t}\n\tfor (auto it = v.begin(); it != v.end(); ++it) {\n\t\t//cout << it - v.begin() << endl;\n\t\tif ((*it).size() == 0) {\n\t\t\tit = v.erase(it);\n\t\t}\n\t}\n\tcalc(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint n; \nmap<int, string> MAP;\nvector<int> G[1111];\nvoid dfs(int x, int par, int d) {\n  if(x != 0) {\n    cout << string(d, '.') << MAP[x] << endl;\n  }\n  for(auto to : G[x]) {\n    if(to != par) {\n      dfs(to, x, d + 1);\n    }\n  }\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  FOR(i,1,n+1) {\n    int k;\n    string s;\n    cin >> k >> s;\n    G[k].push_back(i);\n    MAP[i] = s;\n  }\n  dfs(0, -1, -1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n    int u, v;\n\n    edge() { }\n    ~edge() { }\n\n    edge(int a, int b): u(a), v(b) { }\n};\n\nvoid rec(int ind, int depth, vector<edge>& ve, vector<string>& vm) {\n    for(int _ = 0; _ < depth; ++_) cout << '.';\n    cout << vm[ind] << endl;\n    for(edge& e: ve) {\n        if (e.u == ind) {\n            rec(e.v, depth + 1, ve, vm);\n        }\n    }\n}\n\n\nint main() {\n    int n;\n    vector<edge> ve;\n    vector<string> vm;\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        ve.resize(0);\n        vm.resize(0);\n        for (int j = 0; j < n; ++j) {\n            int k;\n            string m;\n            cin >> k >> m;\n            ve.push_back(edge(k-1, j));\n            vm.push_back(m);\n        }\n        rec(0, 0, ve, vm);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef struct{\n  int k;\n  char m[50];\n}res;\n\nres r[1000];\nint adj[1000][1000] = {{0}};\nint n;\nvoid show(int num,int f){\n  f++;\n  for(int i=0;i<f;++i)\n    putchar('.');\n  printf(\"%s\\n\",r[num].m);\n\n  for(int i = num ;i<n;++i)\n    if(adj[i][num]){\n      show(i,f);\n    }\n}\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;++i){\n    cin >> r[i].k >> r[i].m;\n    adj[i][r[i].k-1] = 1;\n  }\n\n  show(0,-1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tstd::vector< std::pair<int,std::string> > th(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> th[i].first;\n\t\tcin >> th[i].second;\n\t}\n\tcout << th[0].second << endl;\n\n\tint now = 0;\n\tint d = 1;\n\tbool find = true;\n\tstd::vector<bool> check(n,false);\n\tstd::queue<int> q;\n\tfor (int i = 1; i < n; i++) {\n\t\td = 1;\n\t\tif ( !check[i] ) {\n\t\t\tfor (int k = 0; k < d; k++) {\n\t\t\t\tcout << \".\";\n\t\t\t}\n\t\t\tcout << th[i].second << endl;\n\t\t\tcheck[i] = true;\n\t\t}\n\n\t\tq.push(i+1);\n\t\tfind = true;\n\t\twhile ( !q.empty() ) {\n\t\t\tnow = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tif ( th[j].first == now && !check[j] ) {\n\t\t\t\t\td++;\n\t\t\t\t\tfor (int k = 0; k < d; k++) {\n\t\t\t\t\t\tcout << \".\";\n\t\t\t\t\t}\n\t\t\t\t\tq.push(j+1);\n\t\t\t\t\tcout << th[j].second << endl;\n\t\t\t\t\tcheck[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<vector<int> > Graph;\n\nint N;\nvector<string> name;\nGraph G;\n\nvoid dfs(int v, int depth) {\n  cout << string(depth, '.') << name[v] << endl;\n  for(int i = 0; i < G[v].size(); ++i) {\n    dfs(G[v][i], depth+1);\n  }\n}\n\nint main() {\n  cin >> N;\n  name = vector<string>(N);\n  G = Graph(N);\n  for(int i = 0; i < N; ++i) {\n    int par; cin >> par; --par;\n    cin >> name[i];\n    if(par != -1) G[par].push_back(i);\n  }\n  dfs(0, 0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nstruct Node {\n  string name;\n  vi children;\n\n  Node() {\n  }\n};\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<Node> nodes(n);\n  rep(i, n) {\n    int k;\n    string m;\n    cin >> k >> m;\n    k--;\n    nodes[i].name = m;\n    if (k >= 0) nodes[k].children.pb(i);\n  }\n  function<void(int, int)> dfs = [&](int p, int depth) {\n    cout << string(depth, '.') << nodes[p].name << endl;\n    for (int x : nodes[p].children) dfs(x, depth + 1);\n  };\n  dfs(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nvector <int> rep[1001];\nstring str[1001];\nint n;\nvoid saiki(string ten, int ima) {\n  for(int i=0;i<rep[ima].size();i++) {\n    cout << ten << str[rep[ima][i]] << endl;\n    saiki(ten+'.',rep[ima][i]);\n  }\n}\nint main() {\n  cin >> n;\n  for(int i=1;i<=n;i++) {\n    int a;\n    cin >>a >> str[i];\n    rep[a].push_back(i);\n  }\n  saiki(\"\",0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x)*(x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nstruct Thread {\n    int id, children;\n    string s;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Thread> th;\n    vi indent(n+1);\n    FOR(id, 1, n+1) {\n        int k;\n        string s;\n        cin >> k >> s;\n\n        bool inserted = false;\n        REP(i, SZ(th)) {\n            Thread& t = th[i];\n            if (t.id == k) {\n                int level = t.children;\n                FOR(j, i+1, SZ(th)) {\n                    if (indent[th[j].id] == indent[t.id]) break;\n                    level += th[j].children;\n                }\n\n                t.children++;\n                th.insert(th.begin()+i+1+level, {id, 0, s});\n                inserted = true;\n                break;\n            }\n        }\n        if (!inserted) {\n            th.push_back({id, 0, s});\n        }\n        if (k == 0) {\n            indent[id] = 0;\n        } else {\n            indent[id] = indent[k] + 1;\n        }\n//        for (auto t : th) {\n//            REP(i, indent[t.id]) {\n//                LOG(\".\");\n//            }\n//            LOG(\"%s (%d)\\n\", t.s.c_str(), t.children);\n//        }\n//        LOG(\"---------------\\n\");\n    }\n\n    for (auto t : th) {\n        REP(i, indent[t.id]) {\n            cout << \".\";\n        }\n        cout << t.s << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvector<vector<pair<int,string>>> wr;\nint n;\nvoid dfs(int id,int right) {\n\tREP(i, wr[id].size()) {\n\t\tREP(j, right)\n\t\t\tcout << \".\";\n\t\tcout << wr[id][i].second << endl;\n\t\tif (!wr[wr[id][i].first].empty()) {\n\t\t\tdfs(wr[id][i].first, right + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\twr.resize(n+1);\n\tREP(i, n) {\n\t\tint k;\n\t\tstring s;\n\t\tcin >> k >> s;\n\t\twr[k].push_back({i+1,s});\n\t}\n\tdfs(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\ntypedef long long ll;\n\nstruct Tree {\n    string s;\n    int index;\n    vector<Tree*> v;\n\n    Tree(string _s) {\n        s = _s;\n        index = 0;\n        v.clear();\n    }\n\n    Tree(string _s,int id) {\n        s = _s;\n        index = id;\n        v.clear();\n    }\n\n    void add(int id,int i,string s) {\n        find(i)->v.push_back(new Tree(s,id));\n    }\n\n    Tree* find(int id) {\n        if(this->index == id) return this;\n        \n         rep(i,v.size()) {\n             Tree *tree = this->v[i]->find(id);\n             if(tree != NULL) {\n                 return tree;\n             }\n         }\n\n         return NULL;\n    }\n\n    void print(int dep) {\n        \n        rep(i,dep) {\n            cout << \".\";\n        }\n        cout << this->s << endl;\n        \n        rep(i,this->v.size()) {\n            this->v[i]->print(dep+1);\n        }\n\n        return;\n    }\n\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    int dist;\n    string s;\n\n    cin >> dist >> s;\n\n    Tree *tree = new Tree(s,dist);\n\n    REP(i,1,n) {\n        cin >> dist >> s;\n        tree->add(i,dist-1,s);\n\n    }\n\n    tree->print(0);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nvector<vector<string> > v;\nint n;\n\nvoid calc(int idx) {\n\tstring s(idx, '.');\n\tif (idx>= v.size() || v[idx].size() == 0)return;\n\tcout << s << v[idx][0] << endl;\n\tcalc(idx + 1);\n\tfor (int i = 1; i < v[idx].size(); i++) {\n\t\tcout << s << v[idx][i] << endl;\n\t}\n}\n \nint main() {\n\tint a, l;\n\tstring s;\n\tcin >> n;\n\tv = vector<vector<string> >(n+1);\n\trep(i, n) {\n\t\tcin >> a >> s;\n\t\tv[a].pb(s);\n\t}\n\tfor (auto it = v.begin(); it != v.end(); ++it) {\n\t\t//cout << it - v.begin() << endl;\n\t\tif ((*it).size() == 0) {\n\t\t\tit = v.erase(it);\n\t\t}\n\t}\n\tcalc(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nvector<string> s;\n\nvoid dfs(int now, int depth, VVI e){\n    REP(i,depth) cout << \".\";\n    cout << s[now] << endl;\n    REP(i,e[now].size()){\n        dfs(e[now][i], depth+1, e);\n    }\n}\n\nint main() {\n    int n;\n\n    while (cin >> n && n) {\n        s.resize(n);\n        VVI e(n);\n        REP(i,n){\n            int x;\n            cin >> x >> s[i];\n            if (i > 0)\n                e[x-1].push_back(i);\n        }\n        dfs(0, 0, e);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector< int > graph[1001];\nstring M[1001];\n\nvoid rec(int idx, int depth)\n{\n  cout << string(depth, '.') << M[idx] << endl;\n  for(int to : graph[idx]) rec(to, depth + 1);\n}\n\nint main()\n{\n  cin >> N;\n  for(int i = 1; i <= N; i++) {\n    int k;\n    cin >> k >> M[i];\n    graph[k].push_back(i);\n  }\n  rec(1, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <math.h>\nusing namespace std;\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0) break;\n\t\tint a[n+1][2];\n\t\t//input??¨????????°\n\t\tstring s[n+1];\n\t\ta[0][1]=-1;\n\t\ta[1][1]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>a[i][0]>>s[i];\n\t\t\ta[i][1]=a[a[i][0]][1]+1;\n\t\t}\n\t\tfor(int i=3;i<=n;i++){\n\t\t\tint nowa1=a[i][1];\n\t\t\tstring nows=s[i];\n\t\t\tint nowa0=a[i][0],ireru;\n\t\t\tfor(int j=nowa0+1;j<=i-1;j++){\n\t\t\t\tif(a[j][1]<nowa1){\n\t\t\t\t\tfor(int k=i-1;k>=j;k--){\n\t\t\t\t\t\ta[k+1][0]=a[k][0];\n\t\t\t\t\t\ta[k+1][1]=a[k][1];\n\t\t\t\t\t\ts[k+1]=s[k];\n\t\t\t\t\t}\n\t\t\t\t\ta[j][0]=nowa0;\n\t\t\t\t\ta[j][1]=nowa1;\n\t\t\t\t\ts[j]=nows;\n\t\t\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\t\t\tif(a[k][0]>=j&&a[k][0]<=i-1){\n\t\t\t\t\t\t\ta[k][0]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(a[k][0]==i){\n\t\t\t\t\t\t\ta[k][0]=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=a[i][1];j++){\n\t\t\t\tcout<<\".\";\n\t\t\t}\n\t\t\tcout<<s[i]<<endl;\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n\tint n; cin >> n;\n\tvector<vector<int> > lis(n + 1);\n\tvector<string> m(n + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint k; cin >> k;\n\t\tcin >> m[i];\n\t\tlis[k].push_back(i);\n\t}\n\tstack<pair<int,int> > st;\n\tst.push(make_pair(1, 0));\n\twhile (!st.empty()) {\n\t\tauto now = st.top(); st.pop();\n\t\tfor (int i = 0; i < now.second; ++i) cout << \".\";\n\t\tcout << m[now.first] << endl;\n\t\tfor (int j = lis[now.first].size() - 1; j >= 0; --j)\n\t\t\tst.push(make_pair(lis[now.first][j], now.second + 1));\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2619\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 1100\n\nvector<int> tree[MAX];\nstring s[MAX];\nint n, k;\nstring M;\n\nvoid solve(int node, int depth){\n\t// cout<<node<<\" \"<<depth<<endl;\n\tfor(int i = 0; i < depth; i++){\n\t\tcout<<'.';\n\t}\n\t\n\tcout<<s[node]<<endl;\n\t\n\tfor(int i = 0; i < tree[node].size(); i++){\n\t\tsolve(tree[node][i], depth+1);\n\t}\n}\nsigned main(){\n\t// cin.tie(0);\n\t// ios::sync_with_stdio(false);\n\t// cout<<fixed<<setprecision(10);\n\t\n\tcin>>n;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tcin>>k>>M;\n\t\ttree[k].push_back(i);\n\t\ts[i] = M;\n\t}\n\t\n\tsolve(1,0);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct thread{\n  int th;\n  string message;\n  vector<thread> child;\n  thread(){}\n  thread(int th, string message):th(th), message(message){}\n};\n\nbool parse(thread &p, int k, string M, int ith)\n{\n  if(k == p.th){\n    p.child.push_back(thread(ith, M));\n    return true;\n  }\n  for(int i = 0; i < p.child.size(); i++){\n    if(parse(p.child[i], k, M, ith)) return true;\n  }\n  return false;\n}\n\nvoid print(thread &c, int r)\n{\n  for(int i = 0; i < r; i++) cout << \".\";\n  cout << c.message << endl;\n  for(int i = 0; i < c.child.size(); i++){\n    print(c.child[i], r + 1);\n  }\n  return;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  thread channel(0, \"\");\n  for(int i = 0; i < n; i++){\n    int k;\n    string M;\n    cin >> k >> M;\n    parse(channel, k, M, i + 1);\n  }\n  for(int i = 0; i < channel.child.size(); i++){\n    print(channel.child[i], 0);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n\t\t\tstring s[1100];\nvector<int> G[1100];\n\nvoid saiki(int r,int dep){\n\tfor(int i=0;i<dep;i++)cout<<\".\";\n\tcout<<s[r]<<endl;\n\tfor(auto v:G[r])saiki(v,dep+1);\n\t\n}\n\n     signed main(){\nint n;\n     \tcin>>n;\n     \t\n     \tfor(int i=1;i<=n;i++){\n     \t\tint y;\n     \t\tcin>>y;\n     \t\t\n     \t\tcin>>s[i];\n     \t\tif(i==1) continue;\n     \t\tG[y].pb(i);\n     \t}\n     \tsaiki(1,0);\n\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<pair<string, vector<int> > > Tree;\n\nstring put_nchar(char c, int n)\n{\n    string S;\n    \n    for(int i = 0; i < n; i++)\n    {\n        S += c;\n    }\n    \n    return S;\n}\n\nvoid rec(int node, int depth)\n{\n    cout << put_nchar('.', depth) << Tree[node].first << endl;\n    \n    for(int i = 0; i < Tree[node].second.size(); i++)\n    {\n        rec(Tree[node].second[i], depth + 1);\n    }\n}\n\nint main()\n{\n    int n;\n    \n    string name; int parent;\n    \n    cin >> n;\n    \n    Tree = vector<pair<string, vector<int> > >(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> name >> parent;\n        \n        if(parent != 0)\n        {\n            Tree[i].first = name;\n            \n            Tree[parent - 1].second.push_back(i);\n        }\n    }\n    \n    rec(0, 0);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nstring s[1001];\nvector<int> v[1001];\n\nvoid dfs(int i, int k) {\n  rep(j,k) cout << \".\";\n  pr(s[i]);\n  rep(j,v[i].size()) dfs(v[i][j],k+1);\n}\nint main() {\n  int n;\n  R n;\n  REP(i,1,n+1) {\n    int x;\n    cin >> x >> s[i];\n    v[x].pb(i);\n  }\n  dfs(1,0);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nstruct node{\n    string m;\n    vi to;\n};\n\nvector<node> t;\n\nvoid print(int i,int d){\n    rep(_,d)cout<<'.';\n    cout<<t[i].m<<endl;\n    for(int j:t[i].to){\n        print(j,d+1);\n    }\n}\n\nvoid run(){\n    int n;\n    cin>>n;\n    t.resize(n);\n    rep(i,n){\n        int k;\n        cin>>k>>t[i].m;\n        if(i){\n            k--;\n            t[k].to.pb(i);\n        }\n    }\n    print(0,0);\n}    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n \nvector<string> str(1001);\nvvi tag(1001);\n\nvoid print(int pos, int level);\n\nsigned main()\n{\n    Int(n);\n    Rep(i, n+1) {\n        int tmp;\n        cin >> tmp >> str[i];\n        tag[tmp].pb(i);\n    }\n    print(0, 0);\n    return 0;\n}\n\nvoid print(int pos, int level)\n{\n    rep(i, tag[pos].size()) {\n        rep(k, level) {\n            cout << '.';\n        }\n        cout << str[tag[pos][i]] << endl;\n        print(tag[pos][i], level+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <set>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\n\nint main() {\n    int n; cin >> n;\n    vector<string> m(n);\n    vector<vector<int> > children(n);\n    repeat (i, n) {\n        int k_i; cin >> k_i >> m[i]; -- k_i;\n        if (k_i != -1) {\n            children[k_i].push_back(i);\n        }\n    }\n    vector<bool> used(n);\n    function<void (int, int)> go = [&](int i, int depth) {\n        assert (not used[i]);\n        used[i] = true;\n        cout << string(depth, '.') << m[i] << endl;\n        for (int j : children[i]) {\n            go(j, depth + 1);\n        }\n    };\n    repeat (i, n) if (not used[i]) {\n        go(i, 0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n\n/*\n\t樹構造を作りたい\n\t深さと管理番号をインデックスとする\n\t→内容を示す\n*/\n\nstruct node{\n\tint indx;\t\t\t\t//管理番号\n\tstring post;\t\t\t//ポスト内容\n\tvector< int > chnode;\t//子ノードのインデックス\n\tint pnode;\t\t\t\t//親ノードのインデックス\n\tbool flg;\n};\n\nvoid output( vector<node> *tree, int indx, int depth ) {\n\tstring s = \"\";\n\tfor(int i = 0; i < depth; i++)\n\t\ts += \".\";\n\n\tif( !tree -> at(indx).flg )\n\t\tcout << s << tree->at(indx).post << endl;\n\n\ttree -> at(indx).flg = true;\n\n\tif( tree->at(indx).chnode.size() > 0 ) {\n\t\tfor(int i = 0; i < tree->at(indx).chnode.size(); i++) {\n\t\t\toutput( tree, tree->at(indx).chnode[i], depth+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\tint n;\n\tcin >> n;\n\t\n\tvector< node > nlist;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tint k;\n\t\tstring M;\n\t\tcin >> k >> M;\n\n\t\tnode newnode;\n\t\tnewnode.indx = i;\n\t\tnewnode.post = M;\n\t\tnewnode.pnode = k - 1;\n\t\tnewnode.flg = false;\n\n\t\tif( k > 0 )\n\t\t\tnlist[k - 1].chnode.push_back( i );\n\n\t\tnlist.push_back( newnode );\n\t}\n\n\toutput( &nlist, 0, 0 );\n\t//while(1){}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid print(int curr, int depth, vector<vector<int> > list, vector<string> res){\n    string dots = \"\";\n    for(int i=0; i<depth; i++){\n        dots += \".\";\n    }\n    cout << dots << res[curr] << endl;\n\n    for(int i=0; i<(int)list[curr].size(); i++){\n        print(list[curr][i], depth+1, list, res);\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<vector<int> > list(n+1);\n    vector<string> res(n+1);\n    for(int i=1; i<=n; i++){\n        int k;\n        cin >> k >> res[i];\n        list[k].push_back(i);\n    }\n\n    print(1, 0, list, res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\nvs a;\nvvi g;\n\nvoid dfs(int v,int d){\n\tcout<<string(d,'.')<<a[v]<<endl;\n\tfor(auto u:g[v]) dfs(u,d+1);\n\t\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tcin>>n;\n\t\tg=vvi(n);\n\t\ta=vs(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint v;\n\t\t\tcin>>v>>a[i];\n\t\t\tif(i) g[v-1].push_back(i);\n\t\t}\n\t\tdfs(0,0);\n\t\tbreak;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nvector<vector<string> > v;\nint n;\n\nvoid calc(int idx) {\n\tstring s(idx, '.');\n\tif (v[idx].size() == 0)return;\n\tcout << s << v[idx][0] << endl;\n\tcalc(idx + 1);\n\tfor (int i = 1; i < v[idx].size(); i++) {\n\t\tcout << s << v[idx][i] << endl;\n\t}\n}\n \nint main() {\n\tint a, l;\n\tstring s;\n\tcin >> n;\n\tv = vector<vector<string> >(n+1);\n\tmap<int, int> mp;\n\trep(i, n) {\n\t\tcin >> a >> s;\n\t\tif (mp[a] == 0) {\n\t\t\ta = mp.rbegin()->first + 1;\n\t\t}\n\t\tv[a].pb(s);\n\t}\n\tcalc(mp.begin()->first);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct mes{\n    mes* pre;\n    vector<mes*> fol;\n    string m;\n};\nvector<mes>vec;\n\nvoid dfs(mes m, int d){\n    for(int i=0;i<d;i++)\n        cout<<\".\";\n    cout<<m.m<<endl;\n    for(int i=0;i<m.fol.size();i++)\n        dfs(*m.fol[i],d+1);\n}\nint main(){\n    int n, k;\n    string str;\n    cin>>n;\n    for(int i=0;i<=n;i++){\n        mes me;\n        vec.push_back(me);\n    }\n    for(int i=0;i<n;i++){\n        cin>>k>>str;\n        vec[i].pre = &vec[k];\n        vec[i].m = str;\n        vec[k].fol.push_back(&vec[i]);\n    }\n    dfs(vec[1],0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n//#define FLOAT\n\nvoid dfs(int id,int depth,map<int,string>&id2name,map<int,deque<int> >&children){\n\tcout<<string(depth,'.')<<id2name[id]<<endl;\n\tfor(int i=0;i<children[id].size();i++){\n\t\tdfs(children[id][i],depth+1,id2name,children);\n\t}\n}\n\nint main(){\n\tmap<int,string>id2name;\n\tmap<int,int>parent;\n\tmap<int,deque<int> >children;\n\n\tint N,k;\n\tstring s;\n\tcin>>N;\n\tcin>>k>>s;\n\tparent[1]=0;\n\tid2name[1]=s;\n#ifdef FLOAT\n\tchildren[k].push_front(1);\n#else\n\tchildren[k].push_back(1);\n#endif\n\tfor(int post=2;post<=N;post++){\n\t\tcin>>k>>s;\n\t\tparent[post]=k;\n\t\tid2name[post]=s;\n\t\tfor(int cur=post;cur;cur=parent[cur]){\n\t\t\tchildren[parent[cur]].erase(remove(children[parent[cur]].begin(),children[parent[cur]].end(),cur),children[parent[cur]].end());\n#ifdef FLOAT\n\t\t\tchildren[parent[cur]].push_front(cur);\n#else\n\t\t\tchildren[parent[cur]].push_back(cur);\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\tdfs(1,0,id2name,children);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nclass State {\npublic:\n\tint id;\n\tstring str;\n\tint deep;\n\tvector<State> rep;\n\n\tvoid draw()\n\t{\n\t\trep(i, deep) {\n\t\t\tcout << '.';\n\t\t}\n\n\t\tcout << str << endl;\n\n\t\tfor (auto& r : rep) {\n\t\t\tr.draw();\n\t\t}\n\t}\n\n\tvoid add(State s, int i)\n\t{\n\t\tif (i == id) {\n\t\t\ts.deep = deep + 1;\n\t\t\trep.push_back(s);\n\t\t}\n\t\telse {\n\t\t\tfor (auto& r : rep) {\n\t\t\t\tr.add(s, i);\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main()\n{\n\tint n;\n\n\tcin >> n;\n\n\tState s;\n\ts.id = 1;\n\ts.deep = 0;\n\t\n\tcin >> s.str >> s.str;\n\n\trep(i, n - 1) {\n\t\tint r;\n\t\tState temp;\n\t\ttemp.id = i + 2;\n\n\t\tcin >> r >> temp.str;\n\n\t\ts.add(temp, r);\n\t}\n\n\ts.draw();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint n;\nint k[1010];\nstring s[1010];\nvector<int> g[1010];\n\nvoid dfs(int v, int d){\n  for(int i=0;i<d;i++)cout << \".\";\n  cout << s[v-1] << endl;\n  for(int i=0;i<g[v].size();i++){\n    dfs(g[v][i],d+1);\n  }\n}\n\nint main (void){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> k[i] >> s[i];\n    g[k[i]].push_back(i+1);\n  }\n  dfs(1,0);\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nvector<vector<string> > v;\nint n;\n\nvoid calc(int idx) {\n\tstring s(idx, '.');\n\tif (v[idx].size() == 0)return;\n\tcout << s << v[idx][0] << endl;\n\tcalc(idx + 1);\n\tfor (int i = 1; i < v[idx].size(); i++) {\n\t\tcout << s << v[idx][i] << endl;\n\t}\n}\n \nint main() {\n\tint a;\n\tstring s;\n\tcin >> n;\n\tv = vector<vector<string> >(n+1);\n\trep(i, n) {\n\t\tcin >> a >> s;\n\t\tv[a].pb(s);\n\t}\n\tcalc(0);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool cheak(ll x, ll y, ll xMax, ll yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline ll toInt(string s) { ll v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e9 + 9;\n\nvector<pair<int, string>> vs[1001];\nvoid dfs(int m,int c){\n\trep(i, vs[m].size()){\n\t\trep(j, c)cout << \".\";\n\t\tcout << vs[m][i].second << endl;\n\t\tdfs(vs[m][i].first,c+1);\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tFor(i,1, n+1){\n\t\tint t;\n\t\tstring s;\n\t\tcin >> t >> s;\n\t\tvs[t].push_back(make_pair(i, s));\n\t}\n\tdfs(0,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nVI g[1010];\nstring s[1010];\n\nint dfs(int m, int d) {\n\tREP(i, g[m].size()) {\n\t\tREP(j, d) cout << \".\";\n\t\tcout << s[g[m][i]] << endl;\n\t\tdfs(g[m][i], d+1);\n\t}\n}\n\nsigned main(void)\n{\n\tint n;\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\tg[a].PB(i+1);\n\t\tcin >> s[i+1];\n\t}\n\tcout << s[1] << endl;\n\tdfs(1, 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<string>sts;\nvector<vector<int>>edges;\n\nvoid dfs(const int now,const int depth) {\n\tfor (int i = 0; i < depth; ++i)cout << '.';\n\tcout << sts[now] << endl;\n\tfor (auto e : edges[now]) {\n\t\tdfs(e, depth + 1);\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tedges.resize(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint k; string st; cin >> k >> st;\n\t\tsts.emplace_back(st);\n\t\tif (k) {\n\t\t\tk--;\n\t\t\tedges[k].emplace_back(i);\n\t\t}\n\t}\n\tdfs(0,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nstruct tree{\n  vector <int> children;\n  string str;\n  int d;\n};\n\nvector <tree> ts;\nint v[1005]={};\nvoid saiki(int n){\n  if(v[n]==0){\n    string buf=\"\";\n    for(int i=0;i<ts[n].d;i++) buf+=\".\";\n    cout << buf << ts[n].str << endl;\n    v[n]=1;\n    for(int i=0;i<ts[n].children.size();i++){\n      saiki(ts[n].children[i]);\n    }\n  }\n}\nint main(){\n  int n;\n  int b;\n  string buf;\n  tree t;\n  \n  int i,j,k;\n  cin >> n;\n  cin >> k;\n  cin >> t.str;\n  t.d=0;\n  ts.push_back(t);\n  for(i=1;i<n;i++){\n    cin >> k;\n    k--;\n    cin >> t.str;\n    t.d=ts[k].d+1;\n    ts[k].children.push_back(i);\n    ts.push_back(t);\n  }\n  for(i=0;i<n;i++){\n    saiki(i);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint n;\n\nstruct Elem {\n    string name;\n    int idx;\n};\nvector< vector<Elem> > G;\n\nvoid dfs(int p, int cnt=0) {\n    //  printf(\"p = %lld\\n\", p);\n    for(size_t i=0; i<G[p].size(); i++) {\n        Elem to = G[p][i];\n        for(int x=0; x<cnt; x++) printf(\".\");\n        cout << to.name << endl;\n        dfs(to.idx, cnt+1); \n    }\n}\n\nsigned main() {\n    cin >> n;\n    G.resize(n+1);\n    int k; string s;\n    rep(i,0,n) {\n        cin >> k >> s;\n        G[k].push_back(Elem{s, i+1});\n    }\n    dfs(0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nint n,x;\nvector<pair<int,string>> c[1001];\nvoid Put(int p,int len){\n\tfor(int i=0;i<c[p].size();i++){\n\t\tfor(int j=0;j<len;j++)cout<<\".\";\n\t\tcout<<c[p][i].second<<endl;\n\t\tPut(c[p][i].first,len+1);\n\t}\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tpair<int,string> s;\n\tfor(int i=0;i<n;i++){\n\t\ts.first=i+1;\n\t\tcin>>x>>s.second;\n\t\tc[x].push_back(s);\n\t}\n\tPut(0,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nint N;\nvector<pair<int, string>> v;\n\nvoid dfs(int pre, int depth) {\n    rep2(i, pre, v.size()) {\n        if (v[i].first == pre) {\n            rep(j, depth) cout << '.';\n            cout << v[i].second << endl;\n            dfs(i + 1, depth + 1);\n        }\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> N;\n    rep(i, N) {\n        int k;\n        string s;\n        cin >> k >> s;\n        v.emplace_back(k, s);\n    }\n\n    dfs(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <math.h>\n#include <stack>\nusing namespace std;\ntypedef long long ll;\n\nvoid solve(int i,int d,vector<pair<string,vector<int>>>v){\n\tfor(int i=0;i<d;i++){\n\t\tcout << \".\";\n\t}\n\tcout << v[i].first << endl;\n\tfor(int t:v[i].second){\n\t\tsolve(t,d+1,v);\n\t}\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<pair<string,vector<int>>> v(n);\n\tfor(int i=0;i<n;i++){\n\t\tint k; cin >> k;\n\t\tcin >> v[i].first;\n\t\tif(k){\n\t\t\tv[k-1].second.push_back(i);\n\t\t}\n\t}\n\tsolve(0,0,v);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, k;\n  cin >> n;\n  string M[n];\n  int r[n];\n  vector< vector<int> > V(n);\n  for(int i = 0; i < n; ++i){\n    cin >> k >> M[i];\n    if(k) V[k-1].push_back(i);\n  }\n  stack< pair<int,int> > st;\n  st.push(make_pair(0,0));\n  while(!st.empty()){\n    int d = st.top().first, t = st.top().second;\n    st.pop();\n    cout << string(d,'.') + M[t] << endl;\n    ++d;\n    for(int i = V[t].size()-1; i >= 0; --i)\n      st.push(make_pair(d,V[t][i]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    \t((ll)1ll<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.141592653589793\n\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\n\nvoid print(vvi &c, vs &s, int p,int d){\n    string dot(d,'.');\n    cout<<dot<<s[p]<<endl;\n    for(auto i:c[p]){\n        print(c,s,i,d+1);\n    }\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\tint n;\n\tcin>>n;\n\tvector<vi> c(n);\n\tvector<string> s(n);\n\trep(i,n){\n\t    int p; string q;\n\t    cin>>p>>q;\n\t    s[i]=q;\n\t    if(p!=0)\n            c[p-1].push_back(i);\n\t}\n\tprint(c,s,0,0);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vector<string> name(n);\n    vvi g(n);\n    REP(i, n) {\n        int k; cin >> k; --k;\n        cin >> name[i];\n        if (k == -1) continue;\n        g[k].push_back(i);\n    }\n\n    function<void(int,int)> dfs = [&](int v, int d) {\n        REP(_, d) cout << '.';\n        cout << name[v] << endl;\n        for (int u : g[v]) {\n            dfs(u, d+1);\n        }\n    };\n\n    dfs(0, 0);\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,string> p1;\n\n//directed graph\nmap<string,vector<string>> G;\n\nvoid dfs(string now, int d)\n{\n    rep(i,d) printf(\".\");\n    cout << now << endl;\n\n    rep(i,G[now].size()) dfs(G[now][i],d+1);\n}\n\nint main()\n{\n    int n;\n    cin >>n;\n\n    vector<p1> v(n+1);\n    rep(i,n) cin >>v[i+1].fi >>v[i+1].se;\n\n    G[v[1].se]=vector<string>();\n    for(int i=2; i<=n; ++i)\n    {\n        string parent=v[v[i].fi].se;\n        if(G.find(parent)==G.end()) G[parent]=vector<string>();\n        G[parent].pb(v[i].se);\n    }\n\n    dfs(v[1].se,0);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nvector<vector<string> > v;\nint n;\n\nvoid calc(int idx) {\n\tstring s(idx, '.');\n\tif (v[idx].size() == 0)return;\n\tcout << s << v[idx][0] << endl;\n\tcalc(idx + 1);\n\tfor (int i = 1; i < v[idx].size(); i++) {\n\t\tcout << s << v[idx][i] << endl;\n\t}\n}\n \nint main() {\n\tint a, l;\n\tstring s;\n\tcin >> n;\n\tv = vector<vector<string> >(n+1);\n\tl = -1;\n\trep(i, n) {\n\t\tcin >> a >> s;\n\t\tif (l + 1 < a) {\n\t\t\ta = l + 1;\n\t\t}\n\t\tv[a].pb(s);\n\t\tl = a;\n\t}\n\tcalc(0);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Data{\n  \n  string name;\n  int reply;\n  int depth;\n  \n};\n\nvector<Data> v; \nint N;\n\nvoid print_dot(int n){\n  for(int i=0 ; i < n ; i++)cout <<\".\";\n}\n\nvoid out(int n){\n  \n  print_dot(v[n].depth);\n  cout <<v[n].name<<endl;\n  \n  for(int i=1 ; i <= v.size() ; i++){\n    if(v[i].reply ==  n){\n      out(i);\n    }\n  }\n  \n}\n\nint main(){\n  \n  cin >>N;\n  \n  v.push_back((Data){\"null\",-1,-1});\n  \n  int k;\n  string str;\n  \n  cin >>k;\n  cin >>str;\n  \n  v.push_back((Data){str,k,0});\n  \n  for(int i=0 ; i < N-1 ; i++){\n    cin >>k;\n    cin >>str;\n    v.push_back((Data){str,k,v[k].depth+1});\n  }\n\n  /*test*/\n  \n  //for(int i=0 ; i <= n ; i++){\n  // cout <<v[i].name<<\" \"<<v[i].reply<<\" \"<<v[i].depth<<endl;\n  //}\n\n  out(1);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[1001];\nstring str[1001];\n\nint n;\n\nvoid print(int v, int depth)\n{\n\tif (~depth){\n\t\tfor (int i = 0; i < depth; i++){\n\t\t\tprintf(\".\");\n\t\t}\n\t\tcout << str[v] << endl;\n\t}\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i];\n\t\tprint(to, depth + 1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++){\n\t\tint k;\n\t\tcin >> k >> str[i];\n\t\tg[k].push_back(i);\n\t}\n\t\n\tprint(0, -1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct mes{\n    mes* pre;\n    vector<mes*> fol;\n    string m;\n};\nvector<mes>vec;\n\nvoid dfs(mes m, int d){\n    for(int i=0;i<d;i++)\n        cout<<\".\";\n    cout<<m.m<<endl;\n    for(int i=0;i<m.fol.size();i++)\n        dfs(*m.fol[i],d+1);\n}\nint main(){\n    int n, k;\n    string str;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        mes me;\n        vec.push_back(me);\n    }\n    for(int i=0;i<n;i++){\n        cin>>k>>str;\n        vec[i].pre = &vec[k-1];\n        vec[i].m = str;\n        vec[k-1].fol.push_back(&vec[i]);\n    }\n    dfs(vec[0],0);\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nvector<vector<int>> next_v;\nvector<string> word;\nvoid dfs(int u, int d) {\n    if(u != 0) {\n        string s = string(d-1, '.') + word[u-1];\n        cout << s << endl;\n    }\n    for(int v : next_v[u]) {\n        dfs(v, d+1);\n    }\n\n}\nint main(){\n    iostream_init();\n    int N;\n    while(cin >> N) {\n        next_v.resize(N+1);\n        REP(i, N) {\n            int K;\n            cin >> K;\n            string s;\n            cin >> s;\n            word.push_back(s);\n            next_v[K].push_back(i+1);\n        }\n        dfs(0, 0);\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\nvector<string> lis[1001];\nmap<string, int> msi;\n\nvoid solve(int num,int cnt) {\n\trep(i, lis[num].size()) {\n\t\trep(j, cnt)cout << \".\";\n\t\tcout << lis[num][i] << endl;\n\t\tsolve(msi[lis[num][i]], cnt + 1);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tint num;\n\t\tstring s;\n\t\tcin >> num >> s;\n\t\tlis[num].push_back(s);\n\t\tmsi[s] = i + 1;\n\t}\n\tsolve(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n;i++)\nusing namespace std;\nint n;\nvector<string>s(1001);\nvector<int>edge[1001];\nvoid dfs(int v,int rank){\n    rep(i,rank)cout<<\".\";\n    cout<<s[v]<<endl;\n    for(int i=0;(long long)i<(long long)edge[v].size();i++)\n        dfs(edge[v][i],rank+1);\n    \n}\nint main(){\n    cin>>n;\n    rep(i,n){\n        int vertex; cin>>vertex;\n        string temp; cin>>temp;\n        s[i]=temp;\n        edge[vertex-1].push_back(i);\n    }\n    dfs(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Node {\n    int idx;\n    string text;\n    vector<Node*> children;\n    Node(int idx,string text) :\n        idx(idx),text(text){}\n    ~Node() {\n        for(auto child : children) {\n            delete child;\n        }\n    }\n};\n\nNode* find(Node *node,int idx) {\n    if(node->idx==idx) return node;\n    for(auto child : node->children) {\n        return find(child, idx);\n    }\n\n    return nullptr;\n}\n\nvoid print(Node *node, int indent) {\n    cout<<string(indent,'.');\n    cout<<node->text<<endl;\n    for(auto child : node->children) {\n        print(child,indent+1);\n    }\n}\n\n\nint n;\nvoid solve() {\n    Node *root;\n    rep(i,n) {\n        int k;\n        string m;\n        cin>>k>>m;\n        if(k==0) {\n            root=new Node(i,m);\n        }\n        else {\n            k--;\n            Node *node=find(root,k);\n            if(node == nullptr) while(1) {}\n            //cout<<node->text<<\", \"<<node->idx<<endl;\n            node->children.push_back(new Node(i,m));\n        }\n    }\n    print(root,0);\n}\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid print(int i, int d, vector<pair<string, vector<int>>> const& v) {\n    for(int j=0; j<d; ++j) {\n        cout << '.';\n    }\n    cout << v[i].first << endl;\n\n    for(int j=0; j<v[i].second.size(); ++j) {\n        print(v[i].second[j], d+1, v);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<string, vector<int>>> v(n);\n    for(int i=0; i<n; ++i) {\n        int k;\n        cin >> k;\n        cin >> v[i].first;\n        if(k != 0) {\n            v[k-1].second.push_back(i);\n        }\n    }\n    print(0, 0, v);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nchar str[1100][110];\nvector<int>g[1100];\nvoid dfs(int a,int b){\n\tfor(int i=0;i<b;i++)printf(\".\");\n\tprintf(\"%s\\n\",str[a]);\n\tfor(int i=0;i<g[a].size();i++)dfs(g[a][i],b+1);\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tint t;scanf(\"%d%s\",&t,str[i]);\n\t\tif(t){\n\t\t\tt--;\n\t\t\tg[t].push_back(i);\n\t\t}\n\t}\n\tdfs(0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nvector<vector<int>> ch;\nvector<string> s;\n\nvoid dfs(int x, int d){\n  rep(i,d){\n    cout << '.';\n  }\n  cout << s[x] << endl;\n  for(auto c:ch[x]){\n    dfs(c, d+1);\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  ch = vector<vector<int>>(n);\n  s = vector<string>(n);\n  int k;\n  rep(i,n){\n    cin >> k;\n    if(k>0){\n      ch[k-1].push_back(i);\n    }\n    cin >> s[i];\n  }\n  dfs(0, 0);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tv.clear(); char c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) inputs(int, __VA_ARGS__)\n#define LL(...) inputs(ll, __VA_ARGS__)\n#define STR(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nint main() {\n\tint n = in;\n\tVVI g(n);\n\tVS s(n);\n\trep(i, n) {\n\t\tint k; in(k, s[i]);\n\t\tif (k)g[k - 1].push_back(i);\n\t}\n\n\tVI per, depth;\n\tfunction<void(int, int)> dfs = [&](int v, int d) {\n\t\tper.push_back(v);\n\t\tdepth.push_back(d);\n\t\tfor (int e : g[v])dfs(e, d + 1);\n\t};\n\tdfs(0, 0);\n\n\trep(i, n) {\n\t\tout(string(depth[i], '.') + s[per[i]]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n// }}}\n\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\nbool opt_debug = false;\n\nclass Node {\n\tpublic:\n\t\tNode* parent;\n\t\tvector<Node*> children;\n\t\tstring comment;\n\t\tNode();\n};\nNode::Node() {\n}\n\nvoid print_recursive(Node* n, int depth) {\n\tcout << string(depth, '.') << n->comment << endl;\n\tEACH (n->children, child) {\n\t\tprint_recursive(*child, depth+1);\n\t}\n}\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// input(\"./inputs/1.txt\");\n\tint N; cin >> N;\n\tVI parent_indices;\n\tvector<Node> nodes;\n\tREP (i, N) {\n\t\tint k; string M; cin >> k >> M;\n\t\tparent_indices.PB(k-1);\n\t\tNode n;\n\t\tn.comment = M;\n\t\tn.parent = NULL;\n\t\tnodes.PB(n);\n\t}\n\tFOR (i, 1, N) {\n\t\tnodes[i].parent = &(nodes[parent_indices[i]]);\n\t\tnodes[i].parent->children.PB(&nodes[i]);\n\t}\n\n\tprint_recursive(&nodes[0], 0);\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct mes{\n    mes* pre;\n    vector<mes*> fol;\n    string m;\n};\n//vector<mes>vec;\n//\n//void dfs(mes m, int d){\n//    for(int i=0;i<d;i++)\n//        cout<<\".\";\n//    cout<<m.m<<endl;\n//    for(int i=0;i<m.fol.size();i++)\n//        dfs(*m.fol[i],d+1);\n//}\nint main(){\n//    int n, k;\n//    string str;\n//    cin>>n;\n//    for(int i=0;i<n;i++){\n        mes me;\n//        vec.push_back(me);\n//    }\n//    for(int i=0;i<n;i++){\n//        cin>>k>>str;\n//        vec[i].pre = &vec[k-1];\n//        vec[i].m = str;\n//        vec[k-1].fol.push_back(&vec[i]);\n//    }\n    //dfs(vec[0],0);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct node{\n\tstring post;\t\t\t//ポスト内容\n\tvector< int > chnode;\t//子ノードのインデックス\n\tbool flg;\n};\n\nvoid output( vector<node> *tree, int indx, int depth ) {\n\tstring s = \"\";\n\ts.append(depth, '.');\n\n\tif( tree -> at(indx).flg ) return;\n\tif( !tree -> at(indx).flg )\n\t\tcout << s << tree->at(indx).post << endl;\n\n\ttree -> at(indx).flg = true;\n\n\tif( tree->at(indx).chnode.size() > 0 )\n\t\tfor(int i = 0; i < tree->at(indx).chnode.size(); i++)\n\t\t\toutput( tree, tree->at(indx).chnode[i], depth+1);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\t\n\tvector< node > nlist;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tint k;\n\t\tstring M;\n\t\tcin >> k >> M;\n\n\t\tnode newnode;\n\t\tnewnode.post = M;\n\t\tnewnode.flg = false;\n\n\t\tif( k > 0 )\n\t\t\tnlist[k - 1].chnode.push_back( i );\n\n\t\tnlist.push_back( newnode );\n\t}\n\toutput( &nlist, 0, 0 );\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 1000\n\nstruct State{\n  string s;\n  int next,l;\n  State(string s,int next,int l) \n    : s(s),next(next),l(l) {}\n};\n\nint idx[MAX_N],len[MAX_N];\nvector<State> G[MAX_N];\n\nvoid solve(int x){\n  if(len[x] == idx[x]){\n    return;\n  }\n  for(int i = 0 ; i < len[x] ; i++){\n    cout << string(G[x][idx[x]].l,'.') + G[x][idx[x]].s << endl;\n    solve(G[x][idx[x]++].next);\n  }\n}\n\nint main(){\n  int N,K,size[MAX_N] = {0};\n  string start,in;\n  cin >> N >> size[0] >> start;\n  for(int i = 1 ; i < N ; i++){\n    cin >> K >> in;\n    size[i] = size[K-1]+1;\n    G[K-1].push_back(State(in,i,size[i]));\n  }\n  cout << start << endl;\n  for(int i = 0 ; i < N ; i++){\n    len[i] = G[i].size();\n  }\n  solve(0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nvoid dfs(vector< vector<int> >& G, vector<string>& name, int v, string pre) {\n\tcout << pre << name[v] << endl;\n\tEACH(to, G[v]) {\n\t\tdfs(G, name, to, pre+\".\");\n\t}\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N; cin >> N;\n\tvector<string> name(N);\n\tvector< vector<int> > G(N);\n\tREP(i, N) {\n\t\tint par; cin >> par; --par;\n\t\tif (par >= 0) {\n\t\t\tG[par].pb(i);\n\t\t}\n\t\tcin >> name[i];\n\t}\n\tdfs(G, name, 0, \"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(const T a, const T b){return a>=0 ? a/b : (a+1)/b-1;}\ntemplate<class T> T div_ceil(const T a, const T b){return a>=0 ? (a-1)/b+1 : a/b;}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 100010;\n\nstring s[1010];\nvector<int> G[1010];\n\nvoid dfs(int v, int dep){\n    if(v != 0){\n        rep(i, dep) printf(\"%c\", '.');\n        cout << s[v] << \"\\n\";\n    }\n    for(int nv: G[v]) dfs(nv, dep+1);\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    For(i, 1, n+1){\n        int K;\n        scanf(\"%d\", &K);\n        G[K].push_back(i);\n        cin >> s[i];\n    }\n    dfs(0, -1);\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\ncnv _ [] = []\ncnv m (n:t:r) = (m, n',t):(cnv (m+1) r)\n    where\n        n' = read n :: Int\n\nsrt :: (Int,Int,String) -> [(Int,Int,String)] -> [String]\nsrt d@(m,n,s) ds =\n    let cs= filter (\\ (_,n1,_) -> m == n1) ds\n        o = filter (\\ (_,n1,_) -> m /= n1) ds\n        a = map (\\ c -> srt c o) cs\n        r = map (\\ ss -> ('.':ss)) $ concat a\n    in\n        (s:r)\n\ncmp (m1,n1,s1) (m2,n2,s2) = if cn /= EQ then cn else cm\n    where\n        cn = compare n1 n2\n        cm = compare m1 m2\n\nans c =\n    let l = lines c\n        (d:ds) = sortBy cmp $ cnv 1 l\n        s = srt d ds\n    in\n        s\n\nmain = do\n    _ <- getLine\n    c <- getContents\n    let o = ans c\n    mapM_ putStrLn o \n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct post_t_tag {\n\tchar message[64];\n\tstruct post_t_tag* next;\n\tstruct post_t_tag* reply_begin;\n\tstruct post_t_tag* reply_end;\n} post_t;\n\nint n;\npost_t posts[2000];\n\nvoid print_data(const post_t* post, int level) {\n\tconst post_t* current;\n\tint i;\n\tfor (i = 0; i < level; i++) putchar('.');\n\tputs(post->message);\n\tfor (current = post->reply_begin; current != NULL; current = current->next) {\n\t\tprint_data(current, level + 1);\n\t}\n}\n\nint main(void) {\n\tint i;\n\tif (scanf(\"%d\", &n) != 1) return 1;\n\tfor (i = 0; i < n; i++) {\n\t\tint k;\n\t\tif (scanf(\"%d\", &k) != 1) return 1;\n\t\tif (scanf(\"%63s\", posts[i].message) != 1) return 1;\n\t\tposts[i].next = posts[i].reply_begin = posts[i].reply_end = NULL;\n\t\tif (k > 0) {\n\t\t\tk--;\n\t\t\tif (posts[k].reply_end == NULL) {\n\t\t\t\tposts[k].reply_begin = posts[k].reply_end = &posts[i];\n\t\t\t} else {\n\t\t\t\tposts[k].reply_end->next = &posts[i];\n\t\t\t\tposts[k].reply_end = &posts[i];\n\t\t\t}\n\t\t}\n\t}\n\tprint_data(&posts[0], 0);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,K,i,j,n[1005][1005];\nchar S[1005][55];\n\nvoid dfs(int p,int d)\n{\n\tint i;\n\tif(p!=0)\n\t{\n\t\tfor(i=0;i<d;i++)putchar('.');\n\t\tputs(S[p]);\n\t}\n\tfor(i=0;n[p][i]!=-1;i++)\n\t{\n\t\tdfs(n[p][i],d+1);\n\t}\n}\n\nint main()\n{\n\tmemset(n,-1,sizeof(n));\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d\\n\",&K);\n\t\tgets(S[i]);\n\t\tfor(j=0;n[K][j]!=-1;j++);\n\t\tn[K][j]=i;\n\t}\n\tdfs(0,-1);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2619: Thread Tree\n// 2017.11.26 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { int ko, nxt, end; char s[52]; } T;\nT node[1002];\n\nvoid dopr(int k, int level)\n{\n\tint w = level; while (w--) putchar('.');\n\tputs(node[k].s);\n\tif (node[k].ko >= 0) dopr(node[k].ko, level+1);\n\tif (node[k].nxt >= 0) dopr(node[k].nxt, level);\n}\n\nint main()\n{\n\tint n, i, k;\n\tT *p, *q;\n\n\tscanf(\"%d\", &n);\n\n\tp = node + 1;\n\tp->ko = p->nxt = p->end = -1;\n\tscanf(\"%d%s\", &k, p->s);\n\n\tfor (i = 2; i <= n; i++) {\n\t\tq = node + i;\n\t\tscanf(\"%d%s\", &k, q->s);\n\t\tp = node + k;\n\t\tq->ko = q->nxt = q->end = -1;\n\n\t\tif (p->ko < 0) p->ko = p->end = i;\n\t\telse {\n\t\t\tnode[p->end].nxt = i;\n\t\t\tp->end = i;\n\t\t}\n\t}\n\tdopr(1, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2619\n  Title:Thread tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint N;\nstruct node_st \n{\n  char message[51];\n  int  link_ch;         \n  int  link_br;\n} node[1001];\n\nvoid write_thread(int node_no,int depth)\n{\n  int i;\n  for(i=0;i<depth;i++)\n    printf(\".\");\n  printf(\"%s\\n\",node[node_no].message);\n  if(node[node_no].link_ch>0)\n    write_thread(node[node_no].link_ch,depth+1);\n  if(node[node_no].link_br>0)\n    write_thread(node[node_no].link_br,depth);\n}\n\nvoid set_link(int x,int y)\n{\n  if(node[x].link_ch==0)\n    {\n      node[x].link_ch=y;\n    }\n  else\n    {\n      x=node[x].link_ch;\n      while(node[x].link_br>0)\n\t{\n\t  x = node[x].link_br;\n\t}\n      node[x].link_br=y;\n    }\n}\n\nmain()\n{\n  int i,re;\n  \n  scanf(\"%d\",&N);\n  for(i=1;i<=N;i++)\n    {\n      scanf(\"%d\",&re);\n      if(i>0)\n\tset_link(re,i);\n      scanf(\"%s\",&(node[i].message[0]));\n    }\n  write_thread(1,0);\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2619\n  Title:Thread tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint N;\nstruct node_st \n{\n  char message[51];\n  char link_ch;         \n  int  link_br;\n} node[1001];\n\nvoid write_thread(int node_no,int depth)\n{\n  int i;\n  for(i=0;i<depth;i++)\n    printf(\".\");\n  printf(\"%s\\n\",node[node_no].message);\n  if(node[node_no].link_ch>0)\n    write_thread(node[node_no].link_ch,depth+1);\n  if(node[node_no].link_br>0)\n    write_thread(node[node_no].link_br,depth);\n}\n\nvoid set_link(int x,int y)\n{\n  if(node[x].link_ch==0)\n    {\n      node[x].link_ch=y;\n    }\n  else\n    {\n      x=node[x].link_ch;\n      while(node[x].link_br>0)\n\tx = node[x].link_br;\n      node[x].link_br=y;\n    }\n}\n\nmain()\n{\n  int i,re;\n  \n  scanf(\"%d\",&N);\n  for(i=1;i<=N;i++)\n    {\n      scanf(\"%d\",&re);\n      if(i>0)\n\tset_link(re,i);\n      scanf(\"%s\",&(node[i].message[0]));\n    }\n  write_thread(1,0);\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Thread Tree\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tPost[] posts = new Post[n + 1];\n\t\t\tposts[0] = main.new Post(0, \"\", -1);\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tint k = parseInt(br.readLine());\n\t\t\t\tString msg = br.readLine();\n\t\t\t\tposts[i] = main.new Post(i, msg, posts[k].depth + 1);\n\t\t\t\tposts[k].children.add(posts[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(posts[1].toString());\n\n\t\t} //end while\n\t} //end main\n\n\tclass Post {\n\t\tPost parent;\n\t\tint id;\n\t\tString msg;\n\t\tint depth;\n\t\tList<Post> children;\n\n\t\tPost(int id, String msg, int depth) {\n\t\t\tthis.id = id;\n\t\t\tthis.msg = msg;\n\t\t\tthis.depth = depth;\n\t\t\tchildren = new ArrayList<>();\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tStringBuilder ret = new StringBuilder();\n\t\t\tfor (int i = 0; i < depth; i++) {\n\t\t\t\tret.append('.');\n\t\t\t}\n\t\t\tret.append(msg).append('\\n');\n\t\t\tfor (Post c : children) {\n\t\t\t\tret.append(c.toString());\n\t\t\t}\n\t\t\treturn ret.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint[][] list;\n\tString[] message;\n\tpublic void run(){\n\t\tint n = sc.nextInt();\n\t\tcalc(n);\n\t}\n\tpublic void calc(int n){\n\t\tlist = new int[n+1][n+1];\n\t\tmessage = new String[n+1];\n\t\t\n\t\tfor(int i = 1; i < n+1; i++){\n\t\t\tint k = sc.nextInt();\n\t\t\tString s = sc.next();\n\t\t\t\n\t\t\tlist[k][i] = 1;\n\t\t\tmessage[i] = s;\n\t\t}\n\t\t\n\t\tprint(-1, 0, n);\n\t}\n\tpublic void print(int depth, int k, int n){\n\t\tif(k != 0){\n\t\t\tfor(int i = 0; i < depth; i++){\n\t\t\t\tSystem.out.print(\".\");\n\t\t\t}\n\t\t\tSystem.out.println(message[k]);\n\t\t}\n\t\tfor(int i = 0; i < n+1; i++){\n\t\t\tif(list[k][i] == 1){\n\t\t\t\tprint(depth+1, i, n);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Vector;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(br.readLine());\n\n\t\tSubmission array[] = new Submission[n];\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint reply = Integer.parseInt(br.readLine());\n\t\t\tString message = br.readLine();\n\n\t\t\tSubmission sub = new Submission(message);\n\n\t\t\tif(reply != 0){\n\t\t\t\tarray[reply - 1].child.add(sub);\n\t\t\t}\n\n\t\t\tarray[i] = sub;\n\t\t}\n\n\t\tprintThread(array, array[0], 0);\n\n\t}\n\n\tstatic void printThread(Submission[] array, Submission sub, int depth){\n\t\tfor(int i = 0; i < depth; i++){\n\t\t\tSystem.out.print('.');\n\t\t}\n\t\tSystem.out.println(sub.message);\n\n\t\tfor(int i = 0; i < sub.child.size() ; i++){\n\t\t\tSubmission tmp = sub.child.elementAt(i);\n\n\t\t\tprintThread(array, tmp, depth + 1);\n\t\t}\n\t}\n\n}\n\nclass Submission {\n\tVector<Submission> child = new Vector<Submission>();\n\tString message;\n\n\tpublic Submission(String message) {\n\t\tthis.message = message;\n\t}\n\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint id = sc.nextInt();\n\t\tNode root = new Node(++id, 0, sc.next());\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint targetId = sc.nextInt();\n\t\t\tNode parent = root.findNode(targetId);\n\t\t\tparent.children.add(new Node(++id, parent.depth + 1, sc.next()));\n\t\t}\n\t\troot.printContents();\n\t\tsc.close();\n\t}\n\n}\n\nclass Node {\n\tint id, depth;\n\tString contents;\n\tList<Node> children;\n\n\tNode(int i, int d, String c) {\n\t\tid = i;\n\t\tdepth = d;\n\t\tcontents = c;\n\t\tchildren = new ArrayList<Node>();\n\t}\n\n\tpublic Node findNode(int id) {\n\t\tif (id == this.id)\n\t\t\treturn this;\n\t\tfor (Node child : children) {\n\t\t\tNode target = child.findNode(id);\n\t\t\tif (target != null)\n\t\t\t\treturn target;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void printContents() {\n\t\tfor (int i = 0; i < depth; i++)\n\t\t\tSystem.out.print('.');\n\t\tSystem.out.println(contents);\n\t\tfor (Node child : children)\n\t\t\tchild.printContents();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\nimport javax.script.AbstractScriptEngine;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main{\n\t// public static Graph g;\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tHashMap<Integer, Node> map = new HashMap<Integer, Node>();\n\t\tNode root = null;\n\t\t\t\t\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint k = Integer.parseInt(br.readLine());\n\t\t\tString m = br.readLine();\n\t\t\tNode node = new Node(m);\n\t\t\t\n\t\t\t// 親を持つ場合その親の子に追加\n\t\t\tif(k != 0){\n\t\t\t\tNode parent = map.get(k);\n\t\t\t\tparent.addChild(node);\n\t\t\t\tnode.depth = parent.depth + 1;\n\t\t\t}else{\n\t\t\t\troot = node;\n\t\t\t\tnode.depth = 0;\n\t\t\t}\n\t\t\t\n\t\t\tmap.put(i, node);\n\t\t}\n\t\troot.print();\n\t}\n}\n\nclass Node{\n\tArrayList<Node> children = new ArrayList<Node>();\n\tString message;\n\tint depth;\n\tNode(String message){\n\t\tthis.message = message;\n\t}\n\tpublic void addChild(Node n){\n\t\tchildren.add(n);\n\t}\n\t// 再帰的print\n\tpublic void print(){\n\t\tStringBuffer buf = new StringBuffer();\n\t\tfor(int i = 0; i < depth; i++)\n\t\t\tbuf.append('.');\n\t\tbuf.append(message);\n\t\tSystem.out.println(buf.toString());\n\t\t\n\t\tfor(int i = 0; i < children.size(); i++)\n\t\t\tchildren.get(i).print();\n\t}\n}\n\n\n\n// --- ここから下はライブラリ ----------\n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyUtil {\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){\n\t\treturn Integer.parseInt(o.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Scanner stdIn = new Scanner(System.in);\n\tstatic Data[] list;\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tlist = new Data[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tlist[i] = new Data(sc.nextInt(),sc.next());\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(list[i].al) continue;\n\t\t\tdep(list[i]);\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic void dep(Data a) {\n\t\tif(a.al) return;\n\t\telse {\n\t\t\tout.println(makeDot(a.depth) + a.text);\n\t\t\ta.al = true;\n\t\t\tfor(int i = 0; i < a.repData.size(); i++) {\n\t\t\t\tdep(a.repData.get(i));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tstatic String makeDot(int a) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < a; i++) {\n\t\t\tsb.append(\".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic class Data {\n\t\tString text;\n\t\tboolean al = false;\n\t\tint depth = 0;\n\t\tArrayList<Data> repData = new ArrayList<Data>();\n\t\tData(int rep, String data) {\n\t\t\ttext = data;\n\t\t\tif(rep == 0) return;\n\t\t\tdepth = list[rep-1].depth+1;\n\t\t\tlist[rep-1].repData.add(this);\n\t\t}\n\t}\n}\n\n\n//-----------------Template------------------//\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t \n\tpublic int nextInt() {\n\t\t if (!hasNext()) throw new NoSuchElementException();\n\t\t int n = 0;\n\t\t boolean minus = false;\n\t\t int b = readByte();\n\t\t if (b == '-') {\n\t\t\t minus = true;\n\t\t\t b = readByte();\n\t\t }\n\t\t if (b < '0' || '9' < b) {\n\t\t\t throw new NumberFormatException();\n\t\t }\n\t\t while(true){\n\t\t\t if ('0' <= b && b <= '9') {\n\t\t\t\t n *= 10;\n\t\t\t\t n += b - '0';\n\t\t\t }else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t return minus ? -n : n;\n\t\t\t }else{\n\t\t\t\t throw new NumberFormatException();\n\t\t\t }\n\t\t\t b = readByte();\n\t\t }\n\t}\n\t \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\t \n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint n=ir.nextInt();\n\t\tint[] k=new int[n];\n\t\tString[] m=new String[n];\n\t\tGraph[] g=new Graph[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tg[i]=new Graph();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tk[i]=ir.nextInt()-1;\n\t\t\tm[i]=ir.next();\n\t\t\tif(i!=0){\n\t\t\t\tg[k[i]].add(i);\n\t\t\t}\n\t\t}\n\t\ttour(0,0,g,m);\n\t}\n\n\tstatic class Graph extends ArrayList<Integer>{}\n\n\tstatic void tour(int now,int depth,Graph[] g,String[] m){\n\t\tfor(int i=0;i<depth;i++)\n\t\t\tout.print(\".\");\n\t\tout.println(m[now]);\n\t\tfor(int i=0;i<g[now].size();i++){\n\t\t\ttour(g[now].get(i),depth+1,g,m);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Thread Tree\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tPost[] posts = new Post[n + 1];\n\t\t\tposts[0] = main.new Post(0, \"\", -1);\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tint k = parseInt(br.readLine());\n\t\t\t\tString msg = br.readLine();\n\t\t\t\tposts[i] = main.new Post(i, msg, posts[k].depth + 1);\n\t\t\t\tposts[k].children.add(posts[i]);\n\t\t\t}\n\n\t\t\tSystem.out.print(posts[1].toString());\n\n\t\t} //end while\n\t} //end main\n\n\tclass Post {\n\t\tPost parent;\n\t\tint id;\n\t\tString msg;\n\t\tint depth;\n\t\tList<Post> children;\n\n\t\tPost(int id, String msg, int depth) {\n\t\t\tthis.id = id;\n\t\t\tthis.msg = msg;\n\t\t\tthis.depth = depth;\n\t\t\tchildren = new ArrayList<>();\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tStringBuilder ret = new StringBuilder();\n\t\t\tfor (int i = 0; i < depth; i++) {\n\t\t\t\tret.append('.');\n\t\t\t}\n\t\t\tret.append(msg).append('\\n');\n\t\t\tfor (Post c : children) {\n\t\t\t\tret.append(c.toString());\n\t\t\t}\n\t\t\treturn ret.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int N = sc.nextInt();\n        Node[] nodes = new Node[N];\n        for (int i = 0; i < N; i++) {\n            int parent = sc.nextInt() - 1;\n            String v = sc.next();\n            nodes[i] = new Node(v);\n            if (i > 0) nodes[parent].children.add(nodes[i]);\n        }\n        nodes[0].print(0);\n    }\n\n    static class Node {\n        ArrayList<Node> children = new ArrayList<>();\n        String v;\n\n        public Node(String v) {\n            this.v = v;\n        }\n\n        void print(int depth) {\n            for (int i = 0; i < depth; i++) {\n                System.out.print(\".\");\n            }\n            System.out.println(v);\n            for (Node c : children) {\n                c.print(depth + 1);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[][] directedGraph(int n, int[] from, int[] to) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : from) cnt[i]++;\n\n\t\tint[][] g = new int[n][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]];\n\t\tfor (int i=0; i<from.length; i++) {\n\t\t\tint s = from[i];\n\t\t\tint t = to[i];\n\t\t\tg[s][--cnt[s]] = t;\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic int[][] g;\n\tstatic String[] s;\n\n\tstatic void rec(int cur, int d) {\n\t\tfor (int i=0; i<d; i++) out.print(\".\");\n\t\tout.println(s[cur]);\n\t\tfor (int i=g[cur].length-1; i>=0; i--) {\n\t\t\trec(g[cur][i], d+1);\n\t\t}\n\t}\n\n\tstatic void solve() {\n\t\tint n = in.nextInt();\n\n\t\ts = new String[n];\n\t\tint[] a = new int[n-1];\n\t\tint[] b = new int[n-1];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint k = in.nextInt() - 1;\n\t\t\ts[i] = in.next();\n\t\t\tif (k == -1) continue;\n\t\t\ta[i-1] = k;\n\t\t\tb[i-1] = i;\n\t\t}\n\n\t\tg = directedGraph(n, a, b);\n\t\trec(0, 0);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n    static final Reader sc = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out,false);\n    static ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n    static int n;\n    public static void main(String[] args) throws Exception {\n    \t\n    \tn = sc.nextInt();\n\t\tint[] k = new int[n];\n\t\tString[] m = new String[n];\n        for(int i=0;i<n;i++){\n            list.add(new ArrayList<Integer>());\n        }\n        for(int i=0;i<n;i++){\n\t\t\tk[i] = sc.nextInt();\n\t\t\tm[i] = sc.next();\n            ArrayList<Integer> l = list.get(k[i]);\n            l.add(i+1);\n        }\n        func(0,0,m);\n        sc.close();\n        out.close();\n    }\n\n    static void func(int count,int now,String[] m){\n        ArrayList<Integer> l = list.get(now);\n        for(int i=0;i<l.size();i++){\n            for(int j=0;j<count;j++){\n                out.print(\".\");\n            }\n            out.println(m[l.get(i)-1]);\n            if(l.get(i)<n){\n                ArrayList<Integer> ll = list.get(l.get(i));\n                if(ll.size()!=0){\n                    func(count+1,l.get(i),m);\n                }\n            }\n        }\n    }\n\n    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass Reader {\n\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public Reader() { this(System.in);}\n    public Reader(InputStream source) { this.in = source;}\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try{\n            buflen = in.read(buf);\n        }catch (IOException e) {e.printStackTrace();}\n        if (buflen <= 0) return false;\n        return true;\n    }\n\n    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n    public boolean hasNext() {skip(); return hasNextByte();}\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        boolean minus = false;\n        long num = readByte();\n\n        if(num == '-'){\n            num = 0;\n            minus = true;\n        }else if (num < '0' || '9' < num){\n            throw new NumberFormatException();\n        }else{\n            num -= '0';\n        }\n\n        while(true){\n            int b = readByte();\n            if('0' <= b && b <= '9')\n                num = num * 10 + (b - '0');\n            else if(b == -1 || !isPrintableChar(b))\n                return minus ? -num : num;\n            else\n                throw new NoSuchElementException();\n        }\n    }\n\n    public int nextInt() {\n        long num = nextLong();\n        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n            throw new NumberFormatException();\n        return (int)num;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return (char)readByte();\n    }\n\n    public String nextLine() {\n        while (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n        if (!hasNextByte()) throw new NoSuchElementException();\n\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (b != '\\n' && b != '\\r') {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n\n        return sb.toString();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i=0; i<n; i++) res[i] = nextInt();\n        return res;\n    }\n\n    public char[] nextCharArray(int n) {\n        char[] res = new char[n];\n        for (int i=0; i<n; i++) res[i] = nextChar();\n        return res;\n    }\n\n    public void close() {try{ in.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int p { get; set; }\n    public List<int> c { get; set; }\n}\n\npublic class Q\n{\n    public int d { get; set; }\n    public int id { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var d = new Dictionary<int, P>();\n        for (int i = 0; i < n; i++) d[i + 1] = new P { c = new List<int>() };\n        var dn = new string[n + 1];\n        Console.ReadLine();\n        dn[1] = Console.ReadLine().Trim();\n        for (int i = 2; i <= n; i++)\n        {\n            var k = int.Parse(Console.ReadLine().Trim());\n            var m = Console.ReadLine().Trim();\n            dn[i] = m;\n            d[k].c.Add(i);\n            d[i].p = k;\n        }\n        print(d, dn);\n    }\n    static void print (Dictionary<int,P> d, string[] dn)\n    {\n        var sb = new StringBuilder();\n        var st = new Stack<Q>();\n        st.Push(new Q { d = 0, id = 1 });\n        while (st.Count() > 0)\n        {\n            var w = st.Pop();\n            var d2 = new string('.', w.d);\n            sb.Append(d2 + dn[w.id] + \"\\n\");\n            var dc = d[w.id].c.Count();\n            if (dc > 0)\n            {\n                d[w.id].c.Reverse();\n                foreach (var x in d[w.id].c)\n                    st.Push(new Q { d = w.d + 1, id = x });\n            }\n        }\n        Console.Write(sb);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int p { get; set; }\n    public List<int> c { get; set; }\n}\n\npublic class Q\n{\n    public int d { get; set; }\n    public int id { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var d = new Dictionary<int, P>();\n        for (int i = 0; i < n; i++) d[i + 1] = new P { c = new List<int>() };\n        var dn = new string[n + 1];\n        Console.ReadLine();\n        dn[1] = Console.ReadLine().Trim();\n        for (int i = 2; i <= n; i++)\n        {\n            var k = int.Parse(Console.ReadLine().Trim());\n            var m = Console.ReadLine().Trim();\n            dn[i] = m;\n            d[k].c.Add(i);\n            d[i].p = k;\n        }\n        print(d, dn);\n    }\n    static void print (Dictionary<int,P> d, string[] dn)\n    {\n        var st = new Stack<Q>();\n        st.Push(new Q { d = 0, id = 1 });\n        while (st.Count() > 0)\n        {\n            var w = st.Pop();\n            var d2 = new string('.', w.d);\n            Console.WriteLine(d2 + dn[w.id]);\n            var dc = d[w.id].c.Count();\n            if (dc > 0)\n            {\n                d[w.id].c.Reverse();\n                foreach (var x in d[w.id].c)\n                    st.Push(new Q { d = w.d + 1, id = x });\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int d { get; set; }\n    public int id { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var d = new List<int>[n + 1];\n        for (int i = 1; i <= n; i++) d[i] = new List<int>();\n        var dn = new string[n + 1];\n        Console.ReadLine();\n        dn[1] = Console.ReadLine().Trim();\n        for (int i = 2; i <= n; i++)\n        {\n            var k = int.Parse(Console.ReadLine().Trim());\n            var m = Console.ReadLine().Trim();\n            dn[i] = m;\n            d[k].Add(i);\n        }\n        print(d, dn);\n    }\n    static void print(List<int>[] d, string[] dn)\n    {\n        var sb = new StringBuilder();\n        var st = new Stack<P>();\n        st.Push(new P { d = 0, id = 1 });\n        while (st.Count() > 0)\n        {\n            var w = st.Pop();\n            sb.Append(new string('.', w.d)  + dn[w.id] + \"\\n\");\n            var dc = d[w.id].Count();\n            if (dc > 0)\n            {\n                d[w.id].Reverse();\n                foreach (var x in d[w.id])\n                    st.Push(new P { d = w.d + 1, id = x });\n            }\n        }\n        Console.Write(sb);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int d { get; set; }\n    public int id { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var d = new List<int>[n + 1];\n        for (int i = 1; i <= n; i++) d[i] = new List<int>();\n        var dn = new string[n + 1];\n        Console.ReadLine();\n        dn[1] = Console.ReadLine().Trim();\n        for (int i = 2; i <= n; i++)\n        {\n            var k = int.Parse(Console.ReadLine().Trim());\n            var m = Console.ReadLine().Trim();\n            dn[i] = m;\n            d[k].Add(i);\n        }\n        print(d, dn);\n    }\n    static void print(List<int>[] d, string[] dn)\n    {\n        var sb = new StringBuilder();\n        var st = new Stack<P>();\n        st.Push(new P { d = 0, id = 1 });\n        while (st.Count() > 0)\n        {\n            var w = st.Pop();\n            sb.Append(new string('.', w.d));\n            sb.Append(dn[w.id]);\n            sb.Append(\"\\n\");\n            var dc = d[w.id].Count();\n            if (dc > 0)\n            {\n                d[w.id].Reverse();\n                foreach (var x in d[w.id])\n                    st.Push(new P { d = w.d + 1, id = x });\n            }\n        }\n        Console.Write(sb);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n    public int d { get; set; }\n    public int id { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var d = new List<int>[n + 1];\n        for (int i = 1; i <= n; i++) d[i] = new List<int>();\n        var dn = new string[n + 1];\n        Console.ReadLine();\n        dn[1] = Console.ReadLine().Trim();\n        for (int i = 2; i <= n; i++)\n        {\n            var k = int.Parse(Console.ReadLine().Trim());\n            var m = Console.ReadLine().Trim();\n            dn[i] = m;\n            d[k].Add(i);\n        }\n        print(d, dn);\n    }\n    static void print (List<int>[] d, string[] dn)\n    {\n        var sb = new StringBuilder();\n        var st = new Stack<P>();\n        st.Push(new P { d = 0, id = 1 });\n        while (st.Count() > 0)\n        {\n            var w = st.Pop();\n            var d2 = new string('.', w.d);\n            sb.Append(d2 + dn[w.id] + \"\\n\");\n            var dc = d[w.id].Count();\n            if (dc > 0)\n            {\n                d[w.id].Reverse();\n                foreach (var x in d[w.id])\n                    st.Push(new P { d = w.d + 1, id = x });\n            }\n        }\n        Console.Write(sb);\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n    def initialize\n        @children = []\n    end\n\n    def show(indent = 0)\n        puts ?. * indent + name\n        @children.each {|c| c.show(indent + 1)}\n    end\n    attr_accessor :children, :name\nend\n\nn = gets.to_i\na = (0..n).map{Tree.new}\n\n(1..n).each do |i|\n    a[gets.to_i].children << a[i]\n    a[i].name = gets.chomp\nend\n\na[1].show"
  },
  {
    "language": "Ruby",
    "code": "def search(depth, cur)\n  @n.times do |i|\n    next if @used[i]\n    if @sendto[i] == cur\n      @used[i] = true\n      puts '.' * (depth + 1) + @msg[i]\n      search(depth + 1, i)\n    end\n  end\nend\n\n@n = gets.to_i\n@msg = @n.times.map{ '' }\n@sendto = [-1] * @n\n@n.times do |i|\n  @sendto[i] = gets.to_i - 1\n  @msg[i] = gets.chomp\nend\n\n@used = [false] * @n\n\nputs @msg[0]\n@used[0] = true\nsearch(0, 0)"
  },
  {
    "language": "Ruby",
    "code": "def dfs(rel,node,level)\n    n = 0\n    c = rel[n]\n    while c.size > 0\n        n = c.shift\n        print \".\" * level[n]\n        puts node[n]\n        next if !rel[n]\n        c = rel[n] + c\n    end\nend\nn = gets.to_i\nnode = Array.new\nlevel = Array.new(n,-1)\nchild = Array.new(n).map{Array.new}\nn.times do |i|\n    k = gets.to_i\n    m = gets.chomp\n    node[i+1] = m\n    level[i+1] = level[k] + 1\n    child[k].push(i+1)\nend\ndfs(child,node,level)"
  },
  {
    "language": "Python",
    "code": "def dfs(i, z):\n    print \".\" * z + name[i]\n    for j in child[i]:\n        dfs(j, z + 1)\n\nn = int(raw_input())\nname = []\nchild = [[] for i in xrange(n)]\nfor i in xrange(n):\n    k = int(raw_input())\n    m = raw_input()\n    name.append(m)\n    if k == 0: continue\n    child[k - 1].append(i)\n\ndfs(0, 0)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = []\nfor i in range(N):\n    k = int(input())\n    s = input()\n    src.append((s,[]))\n    if i == 0: continue\n    src[k-1][1].append(i)\n\ndef dfs(i,depth):\n    s,ch = src[i]\n    print('.'*depth + s)\n    for c in ch:\n        dfs(c,depth+1)\n\ndfs(0,0)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef dfs(name, z):\n    ans.append(\".\" * z + name)\n    for c in child[name]:\n        dfs(c, z + 1)\n\nn = int(raw_input())\nref = {}\nchild = defaultdict(list)\nfor loop in xrange(n):\n    k = int(raw_input())\n    m = raw_input()\n    ref[loop + 1] = m\n    if k == 0: continue\n    child[ref[k]].append(m)\n\nans = []\ndfs(ref[1], 0)\nfor a in ans:\n    print a"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1010)\n\nN = int(input())\nsrc = []\nfor i in range(N):\n    k = int(input())\n    s = input()\n    src.append((s,[]))\n    if i == 0: continue\n    src[k-1][1].append(i)\n\ndef dfs(i,depth):\n    s,ch = src[i]\n    print('.'*depth + s)\n    for c in ch:\n        dfs(c,depth+1)\n\ndfs(0,0)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef dfs(name, z):\n    res = [\".\" * z + name]\n    for c in child[name]:\n        res += dfs(c, z + 1)\n    return res\n\nn = int(raw_input())\nref = {}\nchild = defaultdict(list)\nfor loop in xrange(n):\n    k = int(raw_input())\n    m = raw_input()\n    ref[loop + 1] = m\n    if k == 0: continue\n    child[ref[k]].append(m)\n\n\nans = dfs(ref[1], 0)\nfor a in ans:\n    print a"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\nn=int(input())\na=[]\nb=[[]for _ in [0]*n]\n\ndef f(i,x):\n    print('.'*x+a[i])\n    for j in b[i]:\n        f(j,x+1)\n\nfor i in range(n):\n    c=int(input())\n    a+=[input()]\n    if c!=0:b[c-1]+=[i]\nf(0,0)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimi(9999)\ndef dfs(i, z):\n    print \".\" * z + name[i]\n    for j in child[i]:\n        dfs(j, z + 1)\n\nn = int(raw_input())\nname = []\nchild = [[] for i in xrange(n)]\nfor i in xrange(n):\n    k = int(raw_input())\n    m = raw_input()\n    name.append(m)\n    if k == 0: continue\n    child[k - 1].append(i)\n\ndfs(0, 0)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(9999)\ndef dfs(i, z):\n    print \".\" * z + name[i]\n    for j in child[i]:\n        dfs(j, z + 1)\n\nn = int(raw_input())\nname = []\nchild = [[] for i in xrange(n)]\nfor i in xrange(n):\n    k = int(raw_input())\n    m = raw_input()\n    name.append(m)\n    if k == 0: continue\n    child[k - 1].append(i)\n\ndfs(0, 0)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n,h,w = LI()\n    x = LI()\n    t = [0 for i in range(w*n+1)]\n    for i in range(n):\n        if not i%2:\n            t[i*w+x[i]] += 1\n            t[(i+1)*w+x[i]] -= 1\n        else:\n            t[i*w-x[i]] += 1\n            t[(i+1)*w-x[i]] -= 1\n    for i in range(w*n):\n        t[i+1] += t[i]\n    ans = 0\n    for i in t[:-1]:\n        if i == 0:\n            ans += h\n    print(ans)\n    return\n\n#B\ndef B():\n    def dfs(d,x):\n        for i in range(d):\n            print(\".\",end = \"\")\n        print(lis[x])\n        for y in v[x]:\n            dfs(d+1,y)\n\n    n = I()\n    v = [[] for i in range(n)]\n    lis = [None for i in range(n)]\n    for i in range(n):\n        k = I()\n        lis[i] = input()\n        if k > 0:\n            v[k-1].append(i)\n    dfs(0,0)\n    return\n\n#C\ndef C():\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    B()\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    while True:\n        n = I()\n        a = []\n        e = collections.defaultdict(list)\n        for i in range(n):\n            k = I()\n            l = S()\n            e[k].append(i+1)\n            a.append(l)\n        f = [None] * n\n        def ff(i,d):\n            f[i-1] = 1\n            r = ['.' * d + a[i-1]]\n            for j in e[i]:\n                r += ff(j,d+1)\n            return r\n        for i in range(n):\n            if f[i]:\n                continue\n            rr += ff(i+1,0)\n\n        break\n\n\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  }
]