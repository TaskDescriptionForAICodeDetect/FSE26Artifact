[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nvector<string> board(4);\nvector<vector<int> > memo;\n\nint solve(int y, int x, bitset<16> bs, string& word)\n{\n    if(memo[y*4+x][bs.to_ulong()] != -1)\n        return memo[y*4+x][bs.to_ulong()];\n\n    if(board[y][x] != word[bs.count()])\n        return 0;\n\n    bs[y*4+x] = true;\n    if(word.size() == bs.count())\n        return 1;\n\n    int ret = 0;\n    for(int i=0; i<9; ++i){\n        int y2 = y + i / 3 - 1;\n        int x2 = x + i % 3 - 1;\n        if(y2 < 0 || y2 >= 4 || x2 < 0 || x2 >= 4)\n            continue;\n        if(!bs[y2*4+x2])\n            ret += solve(y2, x2, bs, word);\n    }\n\n    bs[y*4+x] = false;\n    return memo[y*4+x][bs.to_ulong()] = ret;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<string> word(n);\n    vector<int> score(n);\n    for(int i=0; i<n; ++i)\n        cin >> word[i] >> score[i];\n    for(int i=0; i<4; ++i)\n        cin >> board[i];\n    int t;\n    cin >> t;\n\n    vector<vector<int> > x(9);\n    for(int i=0; i<n; ++i){\n        memo.assign(16, vector<int>(1<<16, -1));\n        int ret = 0;\n        for(int y=0; y<4; ++y){\n            for(int x=0; x<4; ++x){\n                ret += solve(y, x, 0, word[i]);\n            }\n        }\n\n        vector<int> v(ret, score[i]);\n        x[word[i].size()].insert(x[word[i].size()].end(), v.begin(), v.end());\n    }\n\n    for(int i=1; i<=8; ++i)\n        sort(x[i].rbegin(), x[i].rend());\n\n    vector<int> dp(t+1, 0);\n    for(int i=1; i<=8; ++i){\n        for(int j=t; j>=0; --j){\n            int sum = 0;\n            for(unsigned k=0; k<x[i].size(); ++k){\n                sum += x[i][k];\n                int j2 = j + i * (k + 1);\n                if(j2 > t)\n                    break;\n                dp[j2] = max(dp[j2], dp[j] + sum);\n            }\n        }\n    }\n    cout << dp[t] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b;}\n\nconstexpr int SIZE = 4;\nconstexpr int MAX_N = 100;\nconstexpr int MAX_LEN = 8;\n\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nunordered_map<string, int> word_idx;\n\nstring board[SIZE];\nint scores[MAX_N];\nint cnt[MAX_N];\nint len[MAX_N];\nbool visited[SIZE][SIZE];\n\nvoid dfs(int x, int y, string s = \"\") {\n\ts += board[y][x];\n\tif(word_idx.count(s)) ++cnt[word_idx[s]];\n\tif(s.size() >= MAX_LEN) return;\n\n\tvisited[y][x] = true;\n\n\tfor(int i = 0; i < 8; ++i) {\n\t\tconst int nx = x + dx[i];\n\t\tconst int ny = y + dy[i];\n\n\t\tif(nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE || visited[ny][nx])\n\t\t\tcontinue;\n\n\t\tdfs(nx, ny, s);\n\t}\n\n\tvisited[y][x] = false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tstring word;\n\t\tcin >> word >> scores[i];\n\t\tword_idx[word] = i;\n\t\tlen[i] = (int)word.size();\n\t}\n\n\tfor(int i = 0; i < SIZE; ++i) {\n\t\tcin >> board[i];\n\t}\n\n\tint t;\n\tcin >> t;\n\n\tmemset(visited, false, sizeof(visited));\n\tfor(int i = 0; i < SIZE; ++i) {\n\t\tfor(int j = 0; j < SIZE; ++j) {\n\t\t\tdfs(j, i);\n\t\t}\n\t}\n\n\tvector<int> dp(t + 1, 0);\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < cnt[i]; ++j) {\n\t\t\tfor(int k = t - len[i]; k >= 0; --k) {\n\t\t\t\tchmax(dp[k + len[i]], dp[k] + scores[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << *max_element(dp.begin(), dp.end()) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  if(__builtin_popcount((bits & mask)) >= 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    string next = str;\n    next.push_back(stage[dy][dx]);\n    dfs(dx,dy,next,bits | (1<<idx),stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> idx2keyword;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      idx2keyword.push_back(word);\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = ((1<<(y*4+x)) << 16);\n\tstring str = \"\";\n\tstr.push_back(stage[y][x]);\n\tdfs(x,y,str,bits | (1<<(y*4+x)),stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int idx=0;idx<N;idx++){\n      string key = idx2keyword[idx];\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tint next[10001];\n\tmemset(next,0,sizeof(next));\n\tfor(int next_time=0;next_time<=time_limit;next_time++){\n\t  int from_time = next_time - cost;\n\t  if(from_time < 0) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score_table[key],max(dp[next_time],next[next_time]));\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nint dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nstring line[4];\nset<string> dict;\nmap<string, int> cnt;\nbool used[4][4];\nvoid dfs(int x, int y, string s){\n    if(dict.count(s)){\n        cnt[s]++;\n    }\n    if(s.size() == 8) return;\n\n    REP(r, 8){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && !used[ny][nx]){\n            used[ny][nx] = true;\n            dfs(nx, ny, s + line[ny][nx]);\n            used[ny][nx] = false;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N){\n        cnt.clear();\n\n        vector<string> words(N);\n        vector<int> scores(N);\n        REP(i, N) cin >> words[i] >> scores[i];\n        REP(i, N) dict.insert(words[i]);\n        REP(i, 4) cin >> line[i];\n        REP(y, 4) REP(x, 4){\n            used[y][x] = true;\n            dfs(x, y, string(1, line[y][x]));\n            used[y][x] = false;\n        }\n\n        int T;\n        cin >> T;\n        int dp[10001] = {};\n        for(int i = 0; i < N; i++){\n            int w = words[i].size();\n            int s = scores[i];\n            int rest = cnt[words[i]];\n            cout << words[i] << \" \" << rest << endl;\n            for(int mul = 1; rest > 0; mul <<= 1){\n                int use = min(mul, rest);\n                rest -= use;\n                for(int j = T; j >= use * w; j--){\n                    dp[j] = max(dp[j], dp[j - use * w] + use * s);\n                }\n            }\n        }\n        cout << dp[T] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\nusing namespace std;\n\nmap<string,int> num;\nmap<string,int> pt;\nchar table[6][6];\n\nchar word[10];\n\nint used[6][6];\n\nint dx[]={-1,0,1,0,-1,-1,1,1};\nint dy[]={0,1,0,-1,-1,1,-1,1};\n\nint dfs(int x,int y,int p){\n\tif( p >= 8 || used[x][y] || table[x][y] == 0 ) return 0;\n\tused[x][y]=1;\n\tword[p]=table[y][x];\n\tword[p+1]=0;\n\tif( pt.count(string(word)) ){\n\t\tnum[string(word)]++;\n\t}\n\tfor(int i = 0 ; i < 8 ; i++)\n\t\tdfs(x+dx[i],y+dy[i],p+1);\n\tused[x][y]=0;\n}\nint dp[10010];\nint main(){\n\tint N;\n\tcin >> N;\n\twhile(N--){\n\t\tstring name;\n\t\tint p;\n\t\tcin >> name >> p;\n\t\tpt[name]=p;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tcin >> (table[i+1]+1);\n\tfor(int i = 1 ; i <= 4 ; i++){\n\t\tfor(int j = 1 ; j <= 4 ; j++){\n\t\t\t//cout << table[i][j];\n\t\t\tdfs(i,j,0);\n\t\t}\n\t}\n\tvector< pair<int,int> > item; // wei cost\n\tfor( map<string,int>::iterator it = num.begin(); it != num.end(); ++it){\n\t\tstring name = it->first;\n\t\tint cnt = it->second;\n\t\tint c = 1;\n\t\twhile(cnt-c>=0){\n\t\t\titem.push_back(make_pair(c*name.size(),c*pt[name]));\n\t\t\tcnt-=c;\n\t\t\tc*=2;\n\t\t}\n\t\tif(cnt){\n\t\t\titem.push_back(make_pair(cnt*name.size(),cnt*pt[name]));\n\t\t}\n\t}\n\tint T;\n\tcin >> T;\n\tfor(int i = 0 ; i < item.size() ; i++){\n\t\tfor(int j = T ; j >= item[i].first ; j--){\n\t\t\tdp[j]=max(dp[j-item[i].first]+item[i].second,dp[j]);\n\t\t}\n\t}\n\tcout << *max_element(dp,dp+10010) << endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  if(__builtin_popcount((bits & mask)) > 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    string next = str;\n    next.push_back(stage[dy][dx]);\n    dfs(dx,dy,next,bits | (1<<idx),stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> idx2keyword;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      idx2keyword.push_back(word);\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = ((1<<(y*4+x)) << 16);\n\tstring str = \"\";\n\tstr.push_back(stage[y][x]);\n\tdfs(x,y,str,bits | (1<<(y*4+x)),stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int idx=0;idx<N;idx++){\n      string key = idx2keyword[idx];\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tint next[10001];\n\tmemcpy(next,dp,sizeof(int)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score_table[key],\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      int next[10001];\n      int cost = key.length();\n      int score = score_table[key];\n\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\n\tmemcpy(next,dp,sizeof(int)*10001);\n\tfor(int from_time=0;from_time + cost<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score,\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  if(__builtin_popcount((bits & mask)) >= 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    string next = str;\n    next.push_back(stage[dy][dx]);\n    dfs(dx,dy,next,bits | (1<<idx),stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> idx2keyword;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      idx2keyword.push_back(word);\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = ((1<<(y*4+x)) << 16);\n\tstring str = \"\";\n\tstr.push_back(stage[y][x]);\n\tdfs(x,y,str,bits | (1<<(y*4+x)),stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int idx=0;idx<N;idx++){\n      string key = idx2keyword[idx];\n\n      int next[10001];\n      memset(next,0,sizeof(next));\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tfor(int next_time=0;next_time<=time_limit;next_time++){\n\t  int from_time = next_time - cost;\n\t  if(from_time < 0) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score_table[key],dp[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Node{\n\tint children[26],finish_id;\n};\n\nstruct Data{\n\tvoid set(int arg_row,int arg_col,int arg_parent,int arg_node_id){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tparent = arg_parent;\n\t\tnode_id = arg_node_id;\n\t}\n\tint row,col,parent,node_id;\n\tbool check[4][4];\n};\n\nint score[101],num[101],len[101];\nint N,index_table[26];\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\nNode nodes[26][800];\n\nchar base_map[4][5];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 3 && col >= 0 && col <= 3)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(Data data){\n\n\tint adj_row,adj_col,next_node;\n\tfor(int i = 0; i < 8; i++){\n\t\tadj_row = data.row+diff_row[i];\n\t\tadj_col = data.col+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || data.check[adj_row][adj_col] == true)continue;\n\n\t\tnext_node = base_map[adj_row][adj_col]-'A';\n\t\tif(nodes[data.parent][data.node_id].children[next_node] == -1)continue;\n\n\t\tData new_data;\n\t\tnew_data.set(adj_row,adj_col,data.parent,nodes[data.parent][data.node_id].children[next_node]);\n\t\tif(nodes[new_data.parent][new_data.node_id].finish_id != -1){\n\t\t\tnum[nodes[new_data.parent][new_data.node_id].finish_id]++;\n\t\t}\n\t\tfor(int a = 0; a < 4; a++){\n\t\t\tfor(int b = 0; b < 4; b++)new_data.check[a][b] = data.check[a][b];\n\t\t}\n\t\tnew_data.check[adj_row][adj_col] = true;\n\t\trecursive(new_data);\n\t}\n}\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 1; i <= N; i++)num[i] = 0;\n\n\tfor(int i = 0; i < 26; i++)index_table[i] = 1;\n\tfor(int i = 0; i < 26; i++){\n\t\tfor(int k = 0; k < 800; k++){\n\t\t\tnodes[i][k].finish_id = -1;\n\t\t\tfor(int p = 0; p < 26; p++){\n\t\t\t\tnodes[i][k].children[p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tchar  buf[9];\n\tint parent,tmp_index,node_id,length;\n\tbool FLG;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%s %d\",buf,&score[i]);\n\t\tfor(length = 0; buf[length] != '\\0';length++);\n\t\tlen[i]\t= length;\n\t\tparent = buf[0]-'A';\n\t\ttmp_index = 1;\n\t\tnode_id = 0;\n\t\twhile(buf[tmp_index] != '\\0'){\n\t\t\tif(nodes[parent][node_id].children[buf[tmp_index]-'A'] == -1){\n\t\t\t\tnodes[parent][node_id].children[buf[tmp_index]-'A'] = index_table[parent]++;\n\t\t\t\tnode_id = nodes[parent][node_id].children[buf[tmp_index]-'A'];\n\t\t\t}else{\n\t\t\t\tnode_id = nodes[parent][node_id].children[buf[tmp_index]-'A'];\n\t\t\t}\n\t\t\ttmp_index++;\n\t\t}\n\t\tnodes[parent][node_id].finish_id = i;\n\t}\n\n\tfor(int row = 0; row < 4; row++)scanf(\"%s\",base_map[row]);\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tfor(int row = 0; row < 4; row++){\n\t\tfor(int col = 0; col < 4; col++){\n\t\t\tData new_data;\n\t\t\tnew_data.set(row,col,base_map[row][col]-'A',0);\n\t\t\tif(nodes[base_map[row][col]-'A'][0].finish_id != -1){\n\t\t\t\tnum[nodes[base_map[row][col]-'A'][0].finish_id]++;\n\t\t\t}\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tfor(int b = 0; b < 4; b++)new_data.check[a][b] = false;\n\t\t\t}\n\t\t\tnew_data.check[row][col] = true;\n\t\t\trecursive(new_data);\n\t\t}\n\t}\n\n\n\tint dp[T+1],next_dp[T+1];\n\tdp[0] = 0;\n\tnext_dp[0] = 0;\n\tfor(int i = 1; i <= T; i++){\n\t\tdp[i] = -1;\n\t\tnext_dp[i] = -1;\n\t}\n\n\tfor(int word = 1; word <= N; word++){\n\t\tif(num[word] == 0)continue;\n\n\t\tfor(int i = 1; i <= num[word]; i++){\n\t\t\tfor(int k = T; k-i*len[word] >= 0; k--){\n\t\t\t\tif(dp[k-i*len[word]] >= 0){\n\t\t\t\t\tnext_dp[k] = max(next_dp[k],dp[k-i*len[word]]+i*score[word]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= T; i++)dp[i] = next_dp[i];\n\t}\n\n\tint maximum = -1;\n\tfor(int i = 0; i <= T; i++)maximum = max(maximum,dp[i]);\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nstruct State { int x[4][4]; };\nchar F[4][4]; vector<pair<int, int>>v; string U[100]; int V[100], dp[10009];\nint solve(string S, int depth, int cx, int cy, State Y) {\n\tif (depth == S.size())return 1;\n\tint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\n\tint cnt = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ey < 0 || ex >= 4 || ey >= 4)continue;\n\t\tif (Y.x[ex][ey] == 0 && F[ex][ey] == S[depth]) {\n\t\t\tState Z = Y; Z.x[ex][ey] = 1;\n\t\t\tcnt += solve(S, depth + 1, ex, ey, Z);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> U[i] >> V[i]; }\n\tfor (int i = 0; i < 16; i++)cin >> F[i / 4][i % 4];\n\tfor (int i = 0; i < n; i++) { \n\t\tint c = 0;\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (F[j / 4][j % 4] != U[i][0])continue;\n\t\t\tState R; for (int k = 0; k < 16; k++)R.x[k / 4][k % 4] = 0; R.x[j / 4][j % 4] = 1;\n\t\t\tc += solve(U[i], 1, j / 4, j % 4, R);\n\t\t}\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tif (c >= (1 << j)) { v.push_back(make_pair(V[i] * (1 << j), U[i].size()*(1 << j))); c -= (1 << j); }\n\t\t\telse { v.push_back(make_pair(V[i] * c, U[i].size()*c)); break; }\n\t\t}\n\t}\n\tint T; cin >> T; int maxn = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = T; j >= v[i].second; j--) {\n\t\t\tdp[j] = max(dp[j], dp[j - v[i].second] + v[i].first); maxn = max(maxn, dp[j]);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\nusing namespace std;\nint dx[] = {-1,0,1,-1,1,-1,0,1};\nint dy[] = {1,1,1,0,0,-1,-1,-1};\n\nint knapsack(vector<int> &w, vector<int> &v, int t){\n\tint n = w.size();\n\tint cur = 0;\n\tint nxt = 1;\n\tvector<vector<int>> dp(2, vector<int>(t+1,-1));\n\tdp[0][0] = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= t; j++){\n\t\t\tif(dp[cur][j] == -1) continue;\n\t\t\tdp[nxt][j] = max(dp[nxt][j], dp[cur][j]);\n\t\t\tif(j + w[i] <= t) dp[nxt][j + w[i]] = max(dp[nxt][j + w[i]], dp[cur][j] + v[i]);\n\t\t}\n\n\t\tswap(cur, nxt);\n\t}\n\t\n\tint ret = 0;\n\tfor(auto x : dp[cur]) ret = max(ret, x);\n\treturn ret;\n}\n\nvoid dfs_imp(vector<vector<char>> &m, map<string, int> &cnt, int i, int j, vector<vector<bool>> &visited, string &str){\n\tvisited[i][j] = true;\n\tstr.push_back(m[i][j]);\n//\tcerr << str << endl;\n\tif(cnt.find(str) != cnt.end()) cnt[str]++;\n\tif(str.size() >= 8){\n\t\tvisited[i][j] = false;\n\t\tstr.pop_back();\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 8; k++){\n\t\tint nextx = i+dx[k], nexty = j+dy[k];\n\t\tif(nextx < 0 || 4 <= nextx || nexty < 0 || 4 <= nexty)continue;\n\t\tif(!visited[nextx][nexty]){\n\t\t\tdfs_imp(m, cnt, i+dx[k], j+dy[k], visited, str);\n\n\t\t}\n\t}\n\tvisited[i][j] = false;\n\tstr.pop_back();\n}\n\nvoid dfs(vector<vector<char>> &m, map<string, int> &cnt, int i, int j){\n\tvector<vector<bool>> visited(4, vector<bool>(4,false));\n\tvisited[i][j] = true;\n\tstring str;\n\tstr.push_back(m[i][j]);\n\tif(cnt.find(str) != cnt.end()) cnt[str]++;\n\tfor(int k = 0; k < 8; k++){\n\t\tint nextx = i+dx[k], nexty = j+dy[k];\n\t\tif(nextx < 0 || 4 <= nextx || nexty < 0 || 4 <= nexty)continue;\n\t\tdfs_imp(m, cnt, nextx, nexty, visited, str);\n\t}\n\tvisited[i][j] = false;\n}\n\nsigned main(){\n\t\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tmap<string, int> words;\n\tfor(int i = 0; i < n; i++){\n\t\tstring w; cin >> w;\n\t\tint s; cin >> s;\n\t\twords[w] = s;\n\t}\n\tvector<vector<char>> m(4, vector<char>(4));\n\tfor(auto &a : m)for(auto &e : a)cin >> e;\n\tint t; cin >> t;\n\n\tmap<string, int> cnt;\n\tfor(auto e : words)cnt[e.first] = 0;\n\tfor(int i = 0; i < 4; i++)for(int j = 0; j < 4; j++){\n\t\tdfs(m, cnt, i, j);\n\t}\n//\tfor(auto e : cnt)cerr << e.first << \":\" << e.second << endl;\n\n\tvector<int> v,w;\n\tfor(auto e : words){\n\t\tif(cnt[e.first] == 0)continue;\n        int sum = 0;\n\t\tfor(int i = 1;; i *= 2){\n\t\t\tif(sum + i < cnt[e.first]){\n                w.push_back(i * e.first.size());\n\t\t\t    v.push_back(i * e.second);\n            }else{\n                i = cnt[e.first] - sum;\n                w.push_back(i * e.first.size());\n                v.push_back(i * e.second);\n                break;\n            }\n\t\t    sum += i;\n        }\n\t}\n\tcout << knapsack(w,v, t) << endl;\n\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b;}\n\nconstexpr int SIZE = 4;\nconstexpr int MAX_N = 100;\nconstexpr int MAX_LEN = 8;\n\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nunordered_map<string, int> word_idx;\n\nstring board[SIZE];\nint scores[MAX_N];\nint cnt[MAX_N];\nint len[MAX_N];\nbool visited[SIZE][SIZE];\n\nvoid dfs(int x, int y, string s = \"\") {\n\ts += board[y][x];\n\tif(word_idx.count(s)) ++cnt[word_idx[s]];\n\tif(s.size() >= MAX_LEN) return;\n\n\tvisited[y][x] = true;\n\n\tfor(int i = 0; i < 8; ++i) {\n\t\tconst int nx = x + dx[i];\n\t\tconst int ny = y + dy[i];\n\n\t\tif(nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE || visited[ny][nx])\n\t\t\tcontinue;\n\n\t\tdfs(nx, ny, s);\n\t}\n\n\tvisited[y][x] = false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tstring word;\n\t\tcin >> word >> scores[i];\n\t\tword_idx[word] = i;\n\t\tlen[i] = (int)word.size();\n\t}\n\n\tfor(int i = 0; i < SIZE; ++i) {\n\t\tcin >> board[i];\n\t}\n\n\tint t;\n\tcin >> t;\n\n\tmemset(visited, false, sizeof(visited));\n\tfor(int i = 0; i < SIZE; ++i) {\n\t\tfor(int j = 0; j < SIZE; ++j) {\n\t\t\tdfs(j, i);\n\t\t}\n\t}\n\n\tunordered_map<int, int> dp;\n\tdp[0] = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < cnt[i]; ++j) {\n\t\t\tunordered_map<int, int> tmp(dp);\n\t\t\tfor(const auto& e : tmp) {\n\t\t\t\tconst int next_time = get<0>(e) + len[i];\n\t\t\t\tif(next_time > t)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tchmax(dp[next_time], get<1>(e) + scores[i]);\n\t\t\t}\n\t\t}\n\t}\n\n/*\n\tvector<int> dp(t + 1, 0);\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < cnt[i]; ++j) {\n\t\t\tfor(int k = t - len[i]; k >= 0; --k) {\n\t\t\t\tchmax(dp[k + len[i]], dp[k] + scores[i]);\n\t\t\t}\n\t\t}\n\t}\n*/\n\tint ans = 0;\n\tfor(const auto& e : dp) {\n\t\tchmax(ans, get<1>(e));\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  if(__builtin_popcount((bits & mask)) > 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    string next = str;\n    next.push_back(stage[dy][dx]);\n    dfs(dx,dy,next,bits | (1<<idx),stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> idx2keyword;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      idx2keyword.push_back(word);\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = ((1<<(y*4+x)) << 16);\n\tstring str = \"\";\n\tstr.push_back(stage[y][x]);\n\tdfs(x,y,str,bits | (1<<(y*4+x)),stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int idx=0;idx<N;idx++){\n      string key = idx2keyword[idx];\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tint next[10001];\n\tmemset(next,0,sizeof(next));\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score_table[key],\n\t\t\t\tdp[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n\nconst int dx[]={1,1,1,0,0,-1,-1,-1};\nconst int dy[]={-1,0,1,-1,1,-1,0,1};\ninline bool in(int x, int y){ return 0<=x&&x<4&&0<=y&&y<4; }\nint n;\nchar board[4][5];\nvector<int> v,w,point;\nvector<string> word;\nbool used[4][4];\nint dp[10001];\n\nvoid dfs(int i,int x,int y,int si){\n    const string& s=word[si];\n    if(s[i]!=board[y][x]) return;\n    used[y][x]=1;\n    if(i==(int)s.size()-1){\n        v.pb(point[si]);\n        w.pb(s.size());\n    } else {\n        rep(d,8){\n            int nx=x+dx[d], ny=y+dy[d];\n            if(in(nx,ny) && !used[ny][nx])\n                dfs(i+1,nx,ny,si);\n        }\n    }\n    used[y][x]=0;\n}\n\nint main(){\n    memset(used,0,sizeof(used));\n    memset(dp,0,sizeof(dp));\n    cin>>n;\n    word.resize(n);\n    point.resize(n);\n    rep(i,n){\n        cin>>word[i];\n        cin>>point[i];\n    }\n    rep(i,4) cin>>board[i];\n    rep(si,n)rep(y,4)rep(x,4){\n        dfs(0,x,y,si);\n    }\n    int sum;cin>>sum;\n    rep(i,v.size()){\n        for(int j=sum; j>=0; j--){\n            if(j-w[i]>=0) dp[j]=max(dp[j],dp[j-w[i]]+v[i]);\n        }\n    }\n    cout<<dp[sum]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b;}\n\nconstexpr int SIZE = 4;\nconstexpr int MAX_N = 100;\nconstexpr int MAX_LEN = 8;\n\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nunordered_map<string, int> word_idx;\n\nstring board[SIZE];\nint scores[MAX_N];\nint cnt[MAX_N];\nint len[MAX_N];\nbool visited[SIZE][SIZE];\n\nvoid dfs(int x, int y, string s = \"\") {\n\ts += board[y][x];\n\tif(word_idx.count(s)) ++cnt[word_idx[s]];\n\tif(s.size() >= MAX_LEN) return;\n\n\tvisited[y][x] = true;\n\n\tfor(int i = 0; i < 8; ++i) {\n\t\tconst int nx = x + dx[i];\n\t\tconst int ny = y + dy[i];\n\n\t\tif(nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE || visited[ny][nx])\n\t\t\tcontinue;\n\n\t\tdfs(nx, ny, s);\n\t}\n\n\tvisited[y][x] = false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tstring word;\n\t\tcin >> word >> scores[i];\n\t\tword_idx[word] = i;\n\t\tlen[i] = (int)word.size();\n\t}\n\n\tfor(int i = 0; i < SIZE; ++i) {\n\t\tcin >> board[i];\n\t}\n\n\tint t;\n\tcin >> t;\n\n\tmemset(visited, false, sizeof(visited));\n\tfor(int i = 0; i < SIZE; ++i) {\n\t\tfor(int j = 0; j < SIZE; ++j) {\n\t\t\tdfs(j, i);\n\t\t}\n\t}\n\n\tvector<int> dp(t + 1, 0);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint num = cnt[i];\n\t\tfor(int j = 1; num > 0; j <<= 1) {\n\t\t\tconst int mul = min(j, num);\n\t\t\tconst int sum_len = len[i] * mul;\n\t\t\tconst int sum_score = scores[i] * mul;\n\t\t\tfor(int k = t - sum_len; k >= 0; --k) {\n\t\t\t\tchmax(dp[k + sum_len], dp[k] + sum_score);\n\t\t\t}\n\t\t\tnum -= mul;\n\t\t}\n\t}\n\n\tcout << *max_element(dp.begin(), dp.end()) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class K, class V> ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<string> ws;\n    vector<int> ss;\n    int T;\n    vector<string> F;\n    void input() {\n        cin >> N;\n        ws.clear(); ws.resize(N);\n        ss.clear(); ss.resize(N);\n        for (int i = 0; i < N; i++) cin >> ws[i] >> ss[i];\n        F.clear(); F.resize(4);\n        cin >> F;\n        cin >> T;\n    }\n\n    vector<pair<int, int>> pats;\n\n    void dfs(int i, int j, int y, int x, int used) {\n        if (j == ws[i].size()) {\n            pats.emplace_back(ws[i].size(), ss[i]);\n            return;\n        }\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int ny = y + dy;\n                int nx = x + dx;\n                if (ny < 0 || ny >= 4 || nx < 0 || nx >= 4) continue;\n                if (F[ny][nx] != ws[i][j]) continue;\n                if (used & (1 << (4*ny+nx))) continue;\n                dfs(i, j + 1, ny, nx, used | (1<<4*ny+nx));\n            }\n        }\n    }\n\n    const int INF = 1<<28;\n\n    void solve() {\n        pats.clear();\n        for (int i = 0; i < N; i++) {\n            for (int y = 0; y < 4; y++) {\n                for (int x = 0; x < 4; x++) {\n                    if (F[y][x] == ws[i][0]) {\n                        dfs(i, 1, y, x, 1<<(4*y+x));\n                    }\n                }\n            }\n        }\n        const int M = pats.size();\n        auto dp = vector<int>(T + 1, -INF);\n        dp[0] = 0;\n        for (int i = 1; i <= M; i++) {\n            for (int t = T; t >= 0; t--) {\n                int x = pats[i - 1].first;\n                if (t - x >= 0 && dp[t - x] > -INF) {\n                    dp[t] = max(dp[t], dp[t - x] + pats[i - 1].second);\n                }\n            }\n        }\n        int ans = 0;\n        for (int t = 0; t <= T; t++) {\n            ans = max(ans, dp[t]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nstruct State { int x[4][4]; };\nchar F[4][4]; vector<pair<int, int>>v, w; string U[100]; int V[100], dp[10009];\nint solve(string S, int depth, int cx, int cy, State Y) {\n\tif (depth == S.size())return 1;\n\tint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\n\tint cnt = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ey < 0 || ex >= 4 || ey >= 4)continue;\n\t\tif (Y.x[ex][ey] == 0 && F[ex][ey] == S[depth]) {\n\t\t\tState Z = Y; Z.x[ex][ey] = 1;\n\t\t\tcnt += solve(S, depth + 1, ex, ey, Z);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> U[i] >> V[i]; }\n\tfor (int i = 0; i < 16; i++)cin >> F[i / 4][i % 4];\n\tfor (int i = 0; i < n; i++) { \n\t\tint c = 0;\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (F[j / 4][j % 4] != U[i][0])continue;\n\t\t\tState R; for (int k = 0; k < 16; k++)R.x[k / 4][k % 4] = 0; R.x[j / 4][j % 4] = 1;\n\t\t\tc += solve(U[i], 1, j / 4, j % 4, R);\n\t\t}\n\t\tfor (int j = 0; j < c; j++)v.push_back(make_pair(V[i], U[i].size()));\n\t}\n\tint T; cin >> T; int maxn = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = T; j >= v[i].second; j--) {\n\t\t\tdp[j] = max(dp[j], dp[j - v[i].second] + v[i].first); maxn = max(maxn, dp[j]);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      int cost = key.length();\n      int score = score_table[key];\n\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\n\tfor(int next_time=time_limit;next_time - cost>=0;next_time--){\n\t  int from_time = next_time - cost;\n\t  if(dp[from_time] == -1) continue;\n\t  dp[next_time] = max(dp[from_time] + score,\n\t\t\t      dp[next_time]);\n\t}\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n;\nmap<string,int> s, ct;\n\nstring f[4];\n\nbool vis[4][4]={};\nvoid dfs(int d, int y, int x, string now){\n    if(s.count(now)) ++ct[now];\n    if(d==8) return;\n\n    for(int dy=-1; dy<=1; ++dy)for(int dx=-1; dx<=1; ++dx){\n        int ny = y+dy , nx = x+dx;\n        if(0<=ny && ny<4 && 0<=nx && nx<4 && !vis[ny][nx]){\n            vis[ny][nx] = true;\n            dfs(d+1,ny,nx,now+f[ny][nx]);\n            vis[ny][nx] = false;\n        }\n    }\n}\n\nconst int N = 10001;\n\nvector<int> v[9];\nint dp[N]={};\n\nint main(){\n    cin >>n;\n    rep(i,n){\n        string w;\n        int score;\n        cin >>w >>score;\n        s[w] = score;\n    }\n\n    rep(i,4) cin >>f[i];\n\n    rep(i,4)rep(j,4){\n        vis[i][j] = true;\n        dfs(1,i,j,string(1,f[i][j]));\n        vis[i][j] = false;\n    }\n\n    for(const auto &p:ct){\n        int sz = p.fi.size();\n        rep(i,p.se) v[sz].pb(s[p.fi]);\n    }\n\n    int T;\n    cin >>T;\n\n    for(int i=1; i<=8; ++i){\n        vector<int> x = v[i];\n        sort(all(x),greater<int>());\n\n        int X = x.size();\n        if(X>10000/i) x.resize(10000/i);\n        X = x.size();\n\n        rep(j,X){\n            for(int k=T-i; k>=0; --k){\n                dp[k+i] = max(dp[k+i], dp[k]+x[j]);\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,T+1) ans = max(ans,dp[i]);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <utility>\n#include <tuple>\nusing namespace std;\n\nconst int H = 4, W = 4;\nchar board[H][W];\n\nint dp[110][10010];\nconst int dx[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int dy[] = {0, 0, 1, -1, 1, 1, -1, -1};\n\nint main() {\n  int N; cin >> N;\n  map<string, int> point_map, cnt_map;\n  for(int i=0; i<N; i++) {\n    string pat; int point;\n    cin >> pat >> point;\n    point_map[pat] = point;\n    cnt_map[pat] = 0;\n  }\n\n  for(int i=0; i<H; i++) {\n    for(int j=0; j<W; j++) {\n      cin >> board[i][j];\n    }\n  }\n\n  fill(dp[0], dp[N+1], -1);\n  dp[0][0] = 0;\n\n  // pos, bit, string\n  queue< tuple<int, int, string> > que;\n  for(int i=0; i<H; i++) {\n    for(int j=0; j<W; j++) {\n      int idx = i * W + j;\n      int bit = (1 << idx);\n      que.push(make_tuple(idx, bit, string(1, board[i][j])));\n    }\n  }\n\n  while(que.size()) {\n    auto tup = que.front(); que.pop();\n    int pos, bit; string str; tie(pos, bit, str) = tup;\n\n    if(cnt_map.count(str)) {\n      cnt_map[str]++;\n    }\n\n    if(str.size() == 8) continue;\n    int x = pos / W, y = pos % W;\n    for(int k=0; k<8; k++) {\n      int nx = x + dx[k], ny = y + dy[k];\n      if(nx < 0 or nx >= H or ny < 0 or ny >= W) continue;\n      int idx = nx * W + ny;\n      if(bit >> idx & 1) continue;\n      int nbit = bit | (1 << idx);\n      string nstr = str + board[nx][ny];\n      que.push(make_tuple(idx, nbit, nstr));\n    }\n  }\n\n  int time_limit; cin >> time_limit;\n\n  /*\n  for(auto e : cnt_map) {\n    cerr << e.first << \", \" << e.second << endl;\n  }\n  */\n\n  int i = 0;\n  for(auto e : cnt_map) {\n    int cost = e.first.size(), score = point_map[e.first];\n    int num = e.second;\n\n    for(int j=0; j<=time_limit; j++) {\n      dp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n    }\n    \n    for(int k=0; num; k++) {\n      int take = min(num, 1 << k);\n      int take_time = cost * take;\n      int take_point = score * take;\n      // fprintf(stderr, \"i = %d, k = %d, take = %d\\n\", i, k, take);\n      for(int j=time_limit - take_time; j>=0; j--) {\n        if(dp[i][j] >= 0) {\n          dp[i+1][j + take_time] = max(dp[i+1][j + take_time], dp[i][j] + take_point);\n        }\n        if(dp[i+1][j] >= 0) {\n          dp[i+1][j + take_time] = max(dp[i+1][j + take_time], dp[i+1][j] + take_point);\n        }\n      }\n      num -= take;\n    }\n    for(int j=0; j<=time_limit; j++) {\n      if(dp[i+1][j] < 0) continue;\n      // fprintf(stderr, \"dp[%d][%d] = %d\\n\", i+1, j, dp[i+1][j]);\n    }\n    i++;\n  }\n    \n  int ans = 0;\n  for(int i=0; i<=time_limit; i++) {\n    ans = max(ans, dp[N][i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n\nconst int dx[]={1,1,1,0,0,-1,-1,-1};\nconst int dy[]={-1,0,1,-1,1,-1,0,1};\ninline bool in(int x, int y){ return 0<=x&&x<4&&0<=y&&y<4; }\nint n;\nchar board[4][5];\nvector<int> v,w,point;\nvector<string> word;\nbool used[4][4];\nint dp[1024];\n\nvoid dfs(int i,int x,int y,int si){\n    const string& s=word[si];\n    if(s[i]!=board[y][x]) return;\n    used[y][x]=1;\n    if(i==(int)s.size()-1){\n        v.pb(point[si]);\n        w.pb(s.size());\n    } else {\n        rep(d,8){\n            int nx=x+dx[d], ny=y+dy[d];\n            if(in(nx,ny) && !used[ny][nx])\n                dfs(i+1,nx,ny,si);\n        }\n    }\n    used[y][x]=0;\n}\n\nint main(){\n    memset(used,0,sizeof(used));\n    memset(dp,0,sizeof(dp));\n    cin>>n;\n    word.resize(n);\n    point.resize(n);\n    rep(i,n){\n        cin>>word[i];\n        cin>>point[i];\n    }\n    rep(i,4) cin>>board[i];\n    rep(si,n)rep(y,4)rep(x,4){\n        dfs(0,x,y,si);\n    }\n    int sum;cin>>sum;\n    rep(i,v.size()){\n        for(int j=sum; j>=0; j--){\n            if(j-w[i]>=0) dp[j]=max(dp[j],dp[j-w[i]]+v[i]);\n        }\n    }\n    cout<<dp[sum]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\nconst int MAX = 10001;\nconst int SIZE = 4;\nint dp[MAX], N, T;\nchar grid[SIZE][SIZE];\nvector<P> word;\n//vector<int> able;\nmap<string, int> able;\nint dh[] = {1,0,-1,0,1,1,-1,-1};\nint dw[] = {0,1,0,-1,1,-1,1,-1};\n\nvoid input(){\n  cin >> N;\n  word.resize(N);\n  for(int i = 0; i < N; i++) cin >> word[i].first >> word[i].second;\n  for(int i = 0; i < SIZE; i++) for(int j = 0; j < SIZE; j++) cin >> grid[i][j];\n  cin >> T;\n}\n\nvoid rec(int h, int w, const string& s, int used){\n  able[s]++;\n  if(s.length() == 8) return;\n  for(int i = 0; i < 8; i++){\n    int nh = h+dh[i], nw = w+dw[i];\n    if(nh < 0 || nh >= SIZE || nw < 0 || nw >= SIZE) continue;\n    if(used & (1 << (4*nh+nw))) continue;\n    rec(nh, nw, s+grid[nh][nw], used | (1<<(4*nh+nw)));\n  }\n}\n\nvoid find(){\n  for(int h = 0; h < SIZE; h++)\n    for(int w = 0; w < SIZE; w++)\n      rec(h,w,string(1,grid[h][w]),(1<<(4*h+w)));\n}\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int t = T; t >= 0; t--)\n      if(dp[t] != -1)\n\tfor(int q = 1; q <= able[word[i].first]; q++)\n\t  if(t+q*(int)word[i].first.length() <= T) dp[t+q*word[i].first.length()] = max(dp[t+q*word[i].first.length()], dp[t]+q*word[i].second);\n\t  else break;\n\n  int res = 0;\n  for(int i = 0; i <= T; i++) res = max(res, dp[i]);\n  cout << res << endl;\n}\nint main(){\n  input();\n  find();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class K, class V> ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<string> ws;\n    vector<int> ss;\n    int T;\n    vector<string> F;\n    void input() {\n        cin >> N;\n        ws.clear(); ws.resize(N);\n        ss.clear(); ss.resize(N);\n        for (int i = 0; i < N; i++) cin >> ws[i] >> ss[i];\n        F.clear(); F.resize(4);\n        cin >> F;\n        cin >> T;\n    }\n\n    vector<pair<int, int>> pats;\n\n    void dfs(int i, int j, int y, int x, int used) {\n        if (j == ws[i].size()) {\n            pats.emplace_back(ws[i].size(), ss[i]);\n            return;\n        }\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int ny = y + dy;\n                int nx = x + dx;\n                if (ny < 0 || ny >= 4 || nx < 0 || nx >= 4) continue;\n                if (F[ny][nx] != ws[i][j]) continue;\n                if (used & (1 << (4*ny+nx))) continue;\n                dfs(i, j + 1, ny, nx, used | (1<<4*ny+nx));\n            }\n        }\n    }\n\n    const int INF = 1<<28;\n\n    void solve() {\n        pats.clear();\n        for (int i = 0; i < N; i++) {\n            for (int y = 0; y < 4; y++) {\n                for (int x = 0; x < 4; x++) {\n                    if (F[y][x] == ws[i][0]) {\n                        dfs(i, 1, y, x, 1<<(4*y+x));\n                    }\n                }\n            }\n        }\n        const int M = pats.size();\n        auto dp = vector<int>(T + 1, -INF);\n        dp[0] = 0;\n        for (int i = 1; i <= M; i++) {\n            for (int t = T; t >= 0; t--) {\n                int x = pats[i - 1].first;\n                if (t - x >= 0 && dp[t - x] > -INF) {\n                    dp[t] = max(dp[t], dp[t - x] + pats[i - 1].second);\n                }\n            }\n        }\n        int ans = 0;\n        for (int t = 0; t <= T; t++) {\n            ans = max(ans, dp[T]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define long long long // for codeforces\n\nint node[1000][26];\nint point[1000][26];\nint nodes = 0;\n\nstring word[100];\nint score[100];\n\nchar m[6][6];\nbool visited[6][6];\n\ninline int init_node(){\n  rep(i,26) node[nodes][i] = -1;\n  return nodes++;\n}\n\nvoid build_trie(int idx, int l, int node_id){\n  if(word[idx].size() == l+1){\n    point[node_id][word[idx].back()-'A'] = score[idx];\n    return;\n  }\n  int c = word[idx][l] - 'A';\n  // dbg(idx,l,node_id,word[idx]);\n  assert(0<=c && c<26);\n  if(node[node_id][c] == -1) node[node_id][c] = init_node();\n  build_trie(idx, l+1, node[node_id][c]);\n}\n\nvector<pair<int,int>> vec;\n// time, score\nvoid dfs(int x, int y, int node_id, int dep){\n  int c = m[x][y] - 'A';\n  if(point[node_id][c]) vec.pb(mp(dep, point[node_id][c]));\n\n  visited[x][y] = true;\n  int nid = node[node_id][c];\n  if(nid>=0){\n    rep(dx,-1,2) rep(dy,-1,2){\n      int nx = x + dx, ny = y + dy;\n      if(visited[nx][ny] || m[nx][ny]=='\\0') continue;\n      if(nid>=0) dfs(nx, ny, nid, dep+1);\n    }\n  }\n  visited[x][y] = false;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n) cin>>word[i]>>score[i];\n\n  fill(point[0], point[n], 0);\n  init_node();\n  rep(i,n) build_trie(i,0,0);\n\n  fill(m[0], m[6], '\\0');\n  fill(visited[0], visited[6], false);\n  rep(i,4) scanf(\"%s\", &m[i+1][1]);\n\n  rep(i,1,5)rep(j,1,5) dfs(i,j,0,1);\n// dbg(vec);\n  int t;\n  cin>>t;\n  vector<long> dp(t+1, 0);\n  for(auto &p : vec){\n    int c = p.first;\n    int v = p.second;\n    for(int i = t-c; i>=0; i--){\n      dp[i+c] = max(dp[i+c], dp[i]+v);\n    }\n  }\n\n  cout << *max_element(all(dp)) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class K, class V> ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<string> ws;\n    vector<int> ss;\n    int T;\n    vector<string> F;\n    void input() {\n        cin >> N;\n        ws.clear(); ws.resize(N);\n        ss.clear(); ss.resize(N);\n        for (int i = 0; i < N; i++) cin >> ws[i] >> ss[i];\n        F.clear(); F.resize(4);\n        cin >> F;\n        cin >> T;\n    }\n\n    vector<pair<int, int>> pats;\n\n    void dfs(int i, int j, int y, int x, int used) {\n        if (j == ws[i].size()) {\n            pats.emplace_back(ws[i].size(), ss[i]);\n            return;\n        }\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int ny = y + dy;\n                int nx = x + dx;\n                if (ny < 0 || ny >= 4 || nx < 0 || nx >= 4) continue;\n                if (F[ny][nx] != ws[i][j]) continue;\n                if (used & (1 << (4*ny+nx))) continue;\n                dfs(i, j + 1, ny, nx, used | (1<<4*ny+nx));\n            }\n        }\n    }\n\n    const int INF = 1<<28;\n\n    void solve() {\n        pats.clear();\n        for (int i = 0; i < N; i++) {\n            for (int y = 0; y < 4; y++) {\n                for (int x = 0; x < 4; x++) {\n                    if (F[y][x] == ws[i][0]) {\n                        dfs(i, 1, y, x, 1<<(4*y+x));\n                    }\n                }\n            }\n        }\n        const int M = pats.size();\n        auto dp = vector<vector<int>>(M + 1, vector<int>(T + 1, 0));\n        for (int i = 1; i <= M; i++) {\n            for (int t = 0; t <= T; t++) {\n                dp[i][t] = max(dp[i][t], dp[i - 1][t]);\n                dp[i][t] = max(dp[i][t], dp[i][t - 1]);\n                int x = pats[i - 1].first;\n                if (t - x >= 0) {\n                    dp[i][t] = max(dp[i][t], dp[i - 1][t - x] + pats[i - 1].second);\n                }\n            }\n        }\n        cout << dp[M][T] << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n\nconst int dx[]={1,1,1,0,0,-1,-1,-1};\nconst int dy[]={-1,0,1,-1,1,-1,0,1};\ninline bool in(int x, int y){ return 0<=x&&x<4&&0<=y&&y<4; }\nint n;\nchar board[4][5];\nvector<int> v,w,point;\nvector<string> word;\nbool used[4][4];\nint dp[10001];\n\nvoid dfs(int i,int x,int y,int si){\n    const string& s=word[si];\n    used[y][x]=1;\n    if(i==(int)s.size()-1){\n        v.pb(point[si]);\n        w.pb(s.size());\n    } else {\n        rep(d,8){\n            int nx=x+dx[d], ny=y+dy[d];\n            if(in(nx,ny) && s[i+1]==board[ny][nx] && !used[ny][nx])\n                dfs(i+1,nx,ny,si);\n        }\n    }\n    used[y][x]=0;\n}\n\nint main(){\n    memset(used,0,sizeof(used));\n    memset(dp,0,sizeof(dp));\n    cin>>n;\n    word.resize(n);\n    point.resize(n);\n    rep(i,n){\n        cin>>word[i];\n        cin>>point[i];\n    }\n    rep(i,4) cin>>board[i];\n    rep(si,n)rep(y,4)rep(x,4){\n        if(word[si][0]==board[y][x]) dfs(0,x,y,si);\n    }\n    int sum;cin>>sum;\n    rep(i,v.size()){\n        for(int j=sum; j>=0; j--){\n            if(j-w[i]>=0) dp[j]=max(dp[j],dp[j-w[i]]+v[i]);\n        }\n    }\n    cout<<dp[sum]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Node{\n\tint children[26],finish_id;\n};\n\nstruct Data{\n\tvoid set(int arg_row,int arg_col,int arg_parent,int arg_node_id){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tparent = arg_parent;\n\t\tnode_id = arg_node_id;\n\t}\n\tint row,col,parent,node_id;\n\tbool check[4][4];\n};\n\nint score[101],num[101],len[101];\nint N,index_table[26];\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\nbool is_palindrome[101];\nNode nodes[26][800];\n\nchar base_map[4][5];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 3 && col >= 0 && col <= 3)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(Data data){\n\n\tint adj_row,adj_col,next_node;\n\tfor(int i = 0; i < 8; i++){\n\t\tadj_row = data.row+diff_row[i];\n\t\tadj_col = data.col+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || data.check[adj_row][adj_col] == true)continue;\n\n\t\tnext_node = base_map[adj_row][adj_col]-'A';\n\t\tif(nodes[data.parent][data.node_id].children[next_node] == -1)continue;\n\n\t\tData new_data;\n\t\tnew_data.set(adj_row,adj_col,data.parent,nodes[data.parent][data.node_id].children[next_node]);\n\t\tif(nodes[new_data.parent][new_data.node_id].finish_id != -1){\n\t\t\tnum[nodes[new_data.parent][new_data.node_id].finish_id]++;\n\t\t}\n\t\tfor(int a = 0; a < 4; a++){\n\t\t\tfor(int b = 0; b < 4; b++)new_data.check[a][b] = data.check[a][b];\n\t\t}\n\t\tnew_data.check[adj_row][adj_col] = true;\n\t\trecursive(new_data);\n\t}\n}\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 1; i <= N; i++)num[i] = 0;\n\n\tfor(int i = 0; i < 26; i++)index_table[i] = 1;\n\tfor(int i = 0; i < 26; i++){\n\t\tfor(int k = 0; k < 800; k++){\n\t\t\tnodes[i][k].finish_id = -1;\n\t\t\tfor(int p = 0; p < 26; p++){\n\t\t\t\tnodes[i][k].children[p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tchar  buf[9];\n\tint parent,tmp_index,node_id,length;\n\tbool FLG;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%s %d\",buf,&score[i]);\n\t\tfor(length = 0; buf[length] != '\\0';length++);\n\t\tlen[i]\t= length;\n\t\tFLG = true;\n\t\tfor(int k = 0; k < length/2; k++){\n\t\t\tif(buf[k] != buf[length-1-k]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tis_palindrome[i] = FLG;\n\t\tparent = buf[0]-'A';\n\t\ttmp_index = 1;\n\t\tnode_id = 0;\n\t\twhile(buf[tmp_index] != '\\0'){\n\t\t\tif(nodes[parent][node_id].children[buf[tmp_index]-'A'] == -1){\n\t\t\t\tnodes[parent][node_id].children[buf[tmp_index]-'A'] = index_table[parent]++;\n\t\t\t\tnode_id = nodes[parent][node_id].children[buf[tmp_index]-'A'];\n\t\t\t}else{\n\t\t\t\tnode_id = nodes[parent][node_id].children[buf[tmp_index]-'A'];\n\t\t\t}\n\t\t\ttmp_index++;\n\t\t}\n\t\tnodes[parent][node_id].finish_id = i;\n\t}\n\n\tfor(int i = 0; i < 26; i++){\n\t\tif(nodes[i][0].finish_id != -1){\n\t\t\tnum[nodes[i][0].finish_id]++;\n\t\t}\n\t}\n\n\tfor(int row = 0; row < 4; row++)scanf(\"%s\",base_map[row]);\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tfor(int row = 0; row < 4; row++){\n\t\tfor(int col = 0; col < 4; col++){\n\t\t\tData new_data;\n\t\t\tnew_data.set(row,col,base_map[row][col]-'A',0);\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tfor(int b = 0; b < 4; b++)new_data.check[a][b] = false;\n\t\t\t}\n\t\t\tnew_data.check[row][col] = true;\n\t\t\trecursive(new_data);\n\t\t}\n\t}\n\n\n\tint dp[T+1],next_dp[T+1];\n\tdp[0] = 0;\n\tnext_dp[0] = 0;\n\tfor(int i = 1; i <= T; i++){\n\t\tdp[i] = -1;\n\t\tnext_dp[i] = -1;\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(is_palindrome[i])num[i] /= 2;\n\t}\n\n\tfor(int word = 1; word <= N; word++){\n\t\tif(num[word] == 0)continue;\n\n\t\tfor(int i = 1; i <= num[word]; i++){\n\t\t\tfor(int k = T; k-i*len[word] >= 0; k--){\n\t\t\t\tif(dp[k-i*len[word]] >= 0){\n\t\t\t\t\tnext_dp[k] = max(next_dp[k],dp[k-i*len[word]]+i*score[word]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= T; i++)dp[i] = next_dp[i];\n\t}\n\n\tint maximum = -1;\n\tfor(int i = 0; i <= T; i++)maximum = max(maximum,dp[i]);\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for (int i=(a);i<(b);++i)\n\nint N, score[111], T, memo[4][4][1 << 16], id, num[111], dp[100010];\nstring word[111], grid[4];\n\nint dx[8] = {-1,-1,-1,0,1,1,1,0};\nint dy[8] = {1,0,-1,-1,-1,0,1,1};\n\ninline int gridId(int x, int y) { return (y << 2) + x; }\n\nint rec(int x, int y, int bit) {\n\tint s = __builtin_popcount(bit);\n\t\n\tif (s >= (int)word[id].size()) return 1;\n\tif (memo[y][x][bit] >= 0) return memo[y][x][bit];\n\t\n\tint& res = memo[y][x][bit];\n\tres = 0;\n\t\n\tfor_(d,0,8) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) continue;\n\t\tif (bit >> gridId(nx, ny) & 1) continue;\n\t\tif (grid[ny][nx] == word[id][s]) res += rec(nx, ny, bit | (1 << gridId(nx, ny)));\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tmemset(num, 0, sizeof(num));\n\t\t\n\tfor_(i,0,N) {\n\t\tid = i;\n\t\tmemset(memo, -1, sizeof(memo));\n\t\t\n\t\tfor_(y,0,4) for_(x,0,4)\t{\n\t\t\tif (grid[y][x] != word[i][0]) continue;\n\t\t\tnum[i] += rec(x, y, 1 << gridId(x, y));\n\t\t}\n\t}\n\t\n\tmemset(dp, 0, sizeof(dp));\n\t\n\tfor_(i,0,N) {\n\t\tint m = num[i], len = word[i].size();\n\t\t\n\t\tfor (int k = 1; m > 0; k <<= 1) {\n\t\t\tint mul = min(k, m);\n\t\t\tfor (int j = T; j >= len * mul; --j) {\n\t\t\t\tdp[j] = max(dp[j], dp[j - len * mul] + score[i] * mul);\n\t\t\t}\n\t\t\tm -= mul;\n\t\t}\n\t}\n\t\n\tcout << dp[T] << endl;\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> word[i] >> score[i];\n\tfor_(i,0,4) cin >> grid[i];\n\tcin >> T;\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n#include <set>\n#include <map>\n#include <utility>\n#include <functional>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int, int>;\nstring word[100];\nint score[100];\nstring line[4];\nset<string> words;\nmap<string, int> cnt;\nbool vis[4][4];\nvector<P> v[10];\nll sum[10];\nll sum_v[10][10001];\nll dp[10][10001];\nint N, T;\nvoid dfs(int x, int y, int d, string &s) {\n\tif (words.count(s) > 0) {\n\t\tcnt[s]++;\n\t}\n\tif (d > 8) return;\n\tfor (int dx = -1; dx <= 1; dx++) {\n\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\tif(dx==0 && dy==0) continue;\n\t\t\tint nx = x + dx;\n\t\t\tint ny = y + dy;\n\t\t\tif (0 > nx || nx >= 4 || 0 > ny || ny >= 4 || vis[ny][nx]) continue;\n\t\t\tvis[ny][nx] = 1;\n\t\t\ts.push_back(line[ny][nx]);\n\t\t\tdfs(nx, ny, d + 1, s);\n\t\t\tvis[ny][nx] = 0;\n\t\t\ts.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> word[i] >> score[i];\n\t\twords.insert(word[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) cin >> line[i];\n\tcin >> T;\n\tstring s = \"\";\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\ts.push_back(line[i][j]);\n\t\t\tvis[i][j] = 1;\n\t\t\tdfs(j, i, 1, s);\n\t\t\tvis[i][j] = 0;\n\t\t\ts.pop_back();\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (cnt.count(word[i])>0) {\n\t\t\tv[word[i].size()].emplace_back(score[i], cnt[word[i]]);\n\t\t\tsum[word[i].size()] += cnt[word[i]];\n\t\t}\n\t}\n\tfor (int i = 1; i <= 8; i++) {\n\t\tsort(v[i].begin(), v[i].end(), greater<P>());\n\t}\n\tfor (int i = 1; i <= 8; i++) {\n\t\tint idx = 0, k = 0;\n\t\tfor (int j = 1; j <= min(sum[i], 10000LL); j++) {\n\t\t\tsum_v[i][j] = sum_v[i][j - 1] + v[i][idx].first;\n\t\t\tk++;\n\t\t\tif (v[i][idx].second <= k) {\n\t\t\t\tidx++;\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= 8; i++) {\n\t\tfor (int j = 0; j <= T; j++) {\n\t\t\tfor (int k = 0; k <= min((ll)(j / i), min(sum[i], 10000LL)); k++) {\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j - i*k] + sum_v[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= T; i++) {\n\t\tans = max(ans, dp[8][i]);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for (int i=(a);i<(b);++i)\n\nint N, score[111], T, memo[4][4][1 << 16], id, num[111], dp[100010];\nstring word[111], grid[4];\n\nint dx[8] = {-1,-1,-1,0,1,1,1,0};\nint dy[8] = {1,0,-1,-1,-1,0,1,1};\n\ninline int gridId(int x, int y) { return (y << 2) + x; }\n\nint rec(int x, int y, int bit) {\n\tint s = __builtin_popcount(bit);\n\t\n\tif (s >= (int)word[id].size()) return 1;\n\tif (memo[y][x][bit] >= 0) return memo[y][x][bit];\n\t\n\tint& res = memo[y][x][bit];\n\tres = 0;\n\t\n\tfor_(d,0,8) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (nx < 0 || 4 <= nx || ny < 0 || 4 <= ny) continue;\n\t\tif (bit >> gridId(nx, ny) & 1) continue;\n\t\tif (grid[ny][nx] == word[id][s]) res += rec(nx, ny, bit | (1 << gridId(nx, ny)));\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tmemset(num, 0, sizeof(num));\n\t\t\n\tfor_(i,0,N) {\n\t\tid = i;\n\t\tmemset(memo, -1, sizeof(memo));\n\t\t\n\t\tfor_(y,0,4) for_(x,0,4)\t{\n\t\t\tif (grid[y][x] != word[i][0]) continue;\n\t\t\tnum[i] += rec(x, y, 1 << gridId(x, y));\n\t\t}\n\t}\n\t\n\tmemset(dp, 0, sizeof(dp));\n\t\n\tfor_(i,0,N) {\n\t\tint m = num[i], len = word[i].size();\n\t\t\n\t\tfor (int k = 1; m > 0; k <<= 1) {\n\t\t\tint mul = min(k, m);\n\t\t\tfor (int j = T; j >= len * mul; --j) {\n\t\t\t\tdp[j] = max(dp[j], dp[j - len * mul] + score[i] * mul);\n\t\t\t}\n\t\t\tm -= mul;\n\t\t}\n\t}\n\t\n\tcout << dp[T] << endl;\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> word[i] >> score[i];\n\tfor_(i,0,4) cin >> grid[i];\n\tcin >> T;\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\nconst int MAX = 10001;\nconst int SIZE = 4;\nint dp[MAX], N, T;\nchar grid[SIZE][SIZE];\nvector<P> word;\nvector<int> able;\nint dh[] = {1,0,-1,0,1,1,-1,-1};\nint dw[] = {0,1,0,-1,1,-1,1,-1};\n\nvoid input(){\n  cin >> N;\n  word.resize(N);\n  for(int i = 0; i < N; i++) cin >> word[i].first >> word[i].second;\n  for(int i = 0; i < SIZE; i++) for(int j = 0; j < SIZE; j++) cin >> grid[i][j];\n  cin >> T;\n}\n\nint rec(int h, int w, const string& s, int used){\n  if(s == \"\") return 1;\n\n  int res = 0;\n  for(int i = 0; i < 8; i++){\n    int nh = h+dh[i], nw = w+dw[i];\n    if(nh < 0 || nh >= SIZE || nw < 0 || nw >= SIZE) continue;\n    if(grid[nh][nw] != s[0]) continue;\n    if(used & (1 << (4*nh+nw))) continue;\n    res += rec(nh, nw, s.substr(1), used|(1<<(4*nh+nw)));\n  }\n  return res;\n}\n\nvoid find(){\n  able = vector<int>(N,0);\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int h = 0; h < SIZE; h++)\n      for(int w = 0; w < SIZE; w++)\n\tif(grid[h][w] == word[i].first[0]) able[i] += rec(h,w,word[i].first.substr(1), (1<<(4*h+w)));\n}\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int t = T; t >= 0; t--)\n      if(dp[t] != -1)\n\tfor(int q = 1; q <= able[i]; q++)\n\t  if(t+q*(int)word[i].first.length() <= T) dp[t+q*word[i].first.length()] = max(dp[t+q*word[i].first.length()], dp[t]+q*word[i].second);\n\n  int res = 0;\n  for(int i = 0; i <= T; i++) res = max(res, dp[i]);\n  cout << res << endl;\n}\nint main(){\n  input();\n  find();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class K, class V> ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<string> ws;\n    vector<int> ss;\n    int T;\n    vector<string> F;\n    void input() {\n        cin >> N;\n        ws.clear(); ws.resize(N);\n        ss.clear(); ss.resize(N);\n        for (int i = 0; i < N; i++) cin >> ws[i] >> ss[i];\n        F.clear(); F.resize(4);\n        cin >> F;\n        cin >> T;\n    }\n\n    vector<pair<int, int>> pats;\n\n    void dfs(int i, int j, int y, int x, int used) {\n        if (j == ws[i].size()) {\n            pats.emplace_back(ws[i].size(), ss[i]);\n            return;\n        }\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int ny = y + dy;\n                int nx = x + dx;\n                if (ny < 0 || ny >= 4 || nx < 0 || nx >= 4) continue;\n                if (F[ny][nx] != ws[i][j]) continue;\n                if (used & (1 << (4*ny+nx))) continue;\n                dfs(i, j + 1, ny, nx, used | (1<<4*ny+nx));\n            }\n        }\n    }\n\n    const int INF = 1<<28;\n\n    void solve() {\n        pats.clear();\n        for (int i = 0; i < N; i++) {\n            for (int y = 0; y < 4; y++) {\n                for (int x = 0; x < 4; x++) {\n                    if (F[y][x] == ws[i][0]) {\n                        dfs(i, 1, y, x, 1<<(4*y+x));\n                    }\n                }\n            }\n        }\n        const int M = pats.size();\n        auto dp = vector<int>(T + 1, -INF);\n        dp[0] = 0;\n        for (int i = 1; i <= M; i++) {\n            for (int t = T; t >= 0; t--) {\n                int x = pats[i - 1].first;\n                if (t - x >= 0) {\n                    dp[t] = max(dp[t], dp[t - x] + pats[i - 1].second);\n                }\n            }\n        }\n        int ans = 0;\n        for (int t = 0; t <= T; t++) {\n            ans = max(ans, dp[T]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  if(__builtin_popcount((bits & mask)) > 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    string next = str;\n    next.push_back(stage[dy][dx]);\n    dfs(dx,dy,next,bits | (1<<idx),stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = ((1<<(y*4+x)) << 16);\n\tstring str = \"\";\n\tstr.push_back(stage[y][x]);\n\tdfs(x,y,str,bits | (1<<(y*4+x)),stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tint next[10001];\n\tmemcpy(next,dp,sizeof(int)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score_table[key],\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    ll dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\tint cost = key.length();\n\n\tll next[10001];\n\tmemcpy(next,dp,sizeof(ll)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + (ll)score_table[key],\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(ll)*10001);\n      }\n    }\n\n    ll max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%lld\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> keywords_v;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n      keywords_v.push_back(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int key_idx=0;key_idx < keywords_v.size();key_idx++){\n      const string& key = keywords_v[key_idx];\n      int cost = key.length();\n      int score = score_table[key];\n\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\n\tfor(int next_time=time_limit;next_time - cost>=0;next_time--){\n\t  int from_time = next_time - cost;\n\t  if(dp[from_time] == -1) continue;\n\t  dp[next_time] = max(dp[from_time] + score,\n\t\t\t      dp[next_time]);\n\t}\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_N = 101;\nconst int IINF = INT_MAX;\n\nint N,T;\nstring s[MAX_N];\nint score[MAX_N],cnt[MAX_N];\nchar a[6][6];\nbool used[6][6];\nint dp[10010];\n\nvoid dfs(int x,int y,int depth,int limit,int index){\n  if( depth >= limit ) {\n    ++cnt[index];\n    return;\n  }\n  REP(dx,-1,2){\n    REP(dy,-1,2){\n      if( dx == 0 && dy == 0 ) continue;\n      int nx = x + dx, ny = y + dy;\n      if( !( 0 <= nx && nx < 4 && 0 <= ny && ny < 4 ) ) continue;\n      if( used[ny][nx] || a[ny][nx] != s[index][depth] ) continue;\n      used[ny][nx] = true;\n      dfs(nx,ny,depth+1,limit,index);\n      used[ny][nx] = false;\n    }\n  }\n}\n\nvoid compute(){\n  rep(i,N) rep(y,4) rep(x,4) if( a[y][x] == s[i][0] ) {\n    used[y][x] = true;\n    dfs(x,y,1,(int)s[i].size(),i);\n    used[y][x] = false;\n  }\n\n  rep(i,T+1) dp[i] = -IINF;\n  dp[0] = 0;\n  int maxi = 0;\n  rep(i,N){\n    int len = (int)s[i].size();\n    for(int t=T;t>=0;t--) if( dp[t] != -IINF ) {\n      for(int use=0;t+use*len<=T&&use<=cnt[i];use++){\n        dp[t+use*len] = max(dp[t+use*len],dp[t]+use*score[i]);\n        maxi = max(maxi,dp[t+use*len]);\n      }\n    }\n  }\n  cout << maxi << endl;\n}\n\nint main(){\n  cin >> N;\n  rep(i,N) cin >> s[i] >> score[i];\n  rep(i,4) {\n    string line;\n    cin >> line;\n    rep(j,4) a[i][j] = line[j];\n  }\n  cin >> T;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      int next[10001];\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\tint cost = key.length();\n\tint score = score_table[key];\n\n\tmemcpy(next,dp,sizeof(int)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score,\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\nconst int MAX = 10001;\nconst int SIZE = 4;\nint dp[MAX], N, T;\nchar grid[SIZE][SIZE];\nvector<P> word;\nmap<string, int> able;\nint dh[] = {1,0,-1,0,1,1,-1,-1};\nint dw[] = {0,1,0,-1,1,-1,1,-1};\n\nvoid input(){\n  cin >> N;\n  word.resize(N);\n  for(int i = 0; i < N; i++){\n    cin >> word[i].first >> word[i].second;\n    able[word[i].first] = 0;\n  }\n  for(int i = 0; i < SIZE; i++) for(int j = 0; j < SIZE; j++) cin >> grid[i][j];\n  cin >> T;\n}\n\nvoid rec(const int& h, const int& w, const string& s, const int& used){\n  if(able.count(s)) able[s]++;\n  if(s.length() == 8) return;\n  for(int i = 0; i < 8; i++){\n    int nh = h+dh[i], nw = w+dw[i];\n    if(nh < 0 || nh >= SIZE || nw < 0 || nw >= SIZE) continue;\n    if(used & (1 << (4*nh+nw))) continue;\n    rec(nh, nw, s+grid[nh][nw], used | (1<<(4*nh+nw)));\n  }\n}\n\nvoid find(){\n  for(int h = 0; h < SIZE; h++)\n    for(int w = 0; w < SIZE; w++)\n      rec(h,w,string(1,grid[h][w]),(1<<(4*h+w)));\n}\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int t = T; t >= 0; t--)\n      if(dp[t] != -1){\n\tint lim = able[word[i].first];\n\tfor(int q = 1; q <= lim; q++)\n\t  if(t+q*(int)word[i].first.length() <= T) dp[t+q*word[i].first.length()] = max(dp[t+q*word[i].first.length()], dp[t]+q*word[i].second);\n\t  else break;\n      }\n\n  int res = 0;\n  for(int i = 0; i <= T; i++) res = max(res, dp[i]);\n  cout << res << endl;\n}\nint main(){\n  input();\n  find();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include <set>\n\nstruct Coordinate {\n\tint x, y;\n\tstd::vector<Coordinate> neighbors() const {\n\t\treturn std::vector<Coordinate> {\n\t\t\tCoordinate{ x - 1, y },\n\t\t\t\tCoordinate{ x + 1, y },\n\t\t\t\tCoordinate{ x, y - 1 },\n\t\t\t\tCoordinate{ x, y + 1 },\n\t\t\t\tCoordinate{ x - 1, y - 1 },\n\t\t\t\tCoordinate{ x - 1, y + 1 },\n\t\t\t\tCoordinate{ x + 1, y - 1 },\n\t\t\t\tCoordinate{ x + 1, y + 1 }\n\t\t};\n\t}\n};\nint count(const std::vector<std::string>& state, const std::string& word, const Coordinate current, int position = 0, int used = 0) {\n\tif (current.x < 0 || state.size() <= current.x || current.y < 0 || state[current.x].size() <= current.y) return 0;\n\tif ((used & (1 << (current.x * 4 + current.y))) != 0) return 0;\n\tif (state[current.x][current.y] != word[position]) return 0;\n\tif (position + 1 == word.size()) return 1;\n\tused |= 1 << (current.x * 4 + current.y);\n\tint result = 0;\n\tfor (const auto next : current.neighbors()) {\n\t\tresult += count(state, word, next, position + 1, used);\n\t}\n\treturn result;\n}\nint main() {\n\tint n; std::cin >> n;\n\tstd::vector<std::pair<std::string, long long int>> words(n);\n\tfor (auto& pair : words) std::cin >> pair.first >> pair.second;\n\tstd::vector<std::string> state(4); for (auto& line : state) std::cin >> line;\n\tstd::vector<int> pattern(n, 0);\n\tfor (auto i = 0; i < words.size(); ++i) {\n\t\tfor (auto x = 0; x < 4; ++x) for (auto y = 0; y < 4; ++y) {\n\t\t\tpattern[i] += count(state, words[i].first, Coordinate{ x, y });\n\t\t}\n\t}\n\tint t; std::cin >> t;\n\tstd::vector<long long int> memo(t + 1, 0);\n\tfor (auto i = 0; i < words.size(); ++i) {\n\t\tint pat = pattern[i];\n\t\tfor (auto j = 0; pat >= (1 << j); ++j) {\n\t\t\tpat -= 1 << j;\n\t\t\tfor (auto k = t; k >= (words[i].first.size() << j); --k) {\n\t\t\t\tmemo[k] = std::max(memo[k], memo[k - (words[i].first.size() << j)] + (words[i].second << j));\n\t\t\t}\n\t\t}\n\t\tif (pat != 0) for (auto k = t; k >= pat * words[i].first.size(); --k) {\n\t\t\tmemo[k] = std::max(memo[k], memo[k - pat * words[i].first.size()] + pat * words[i].second);\n\t\t}\n\t}\n\tstd::cout << memo.back() << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class K, class V> ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<string> ws;\n    vector<int> ss;\n    int T;\n    vector<string> F;\n    void input() {\n        cin >> N;\n        ws.clear(); ws.resize(N);\n        ss.clear(); ss.resize(N);\n        for (int i = 0; i < N; i++) cin >> ws[i] >> ss[i];\n        F.clear(); F.resize(4);\n        cin >> F;\n        cin >> T;\n    }\n\n    vector<pair<int, int>> pats;\n\n    void dfs(int i, int j, int y, int x, int used) {\n        if (j == ws[i].size()) {\n            pats.emplace_back(ws[i].size(), ss[i]);\n            return;\n        }\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int ny = y + dy;\n                int nx = x + dx;\n                if (ny < 0 || ny >= 4 || nx < 0 || nx >= 4) continue;\n                if (F[ny][nx] != ws[i][j]) continue;\n                if (used & (1 << (4*ny+nx))) continue;\n                dfs(i, j + 1, ny, nx, used | (1<<4*ny+nx));\n            }\n        }\n    }\n\n    const int INF = 1<<28;\n\n    void solve() {\n        pats.clear();\n        for (int i = 0; i < N; i++) {\n            for (int y = 0; y < 4; y++) {\n                for (int x = 0; x < 4; x++) {\n                    if (F[y][x] == ws[i][0]) {\n                        dfs(i, 1, y, x, 1<<(4*y+x));\n                    }\n                }\n            }\n        }\n        const int M = pats.size();\n        auto dp = vector<int>(T + 1, -INF);\n        dp[0] = 0;\n        for (int i = 1; i <= M; i++) {\n            for (int t = T; t >= 0; t--) {\n                int x = pats[i - 1].first;\n                if (t - x >= 0) {\n                    dp[t] = max(dp[t], dp[t - x] + pats[i - 1].second);\n                }\n            }\n        }\n        cout << dp[T] << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, T, a[107], c[107], used[4][4]; string s[107], m[4];\nint rec(int x, int y, int d, int v) {\n\tif (d == s[v].size()) return 1;\n\tint ret = 0;\n\tfor (int i = -1; i <= 1; i++) {\n\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\tint tx = x + j, ty = y + i;\n\t\t\tif (0 <= tx && tx <= 3 && 0 <= ty && ty <= 3 && !used[ty][tx] && m[ty][tx] == s[v][d]) {\n\t\t\t\tused[ty][tx] = 1;\n\t\t\t\tret += rec(tx, ty, d + 1, v);\n\t\t\t\tused[ty][tx] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) cin >> s[i] >> a[i];\n\tfor (int i = 0; i < 4; i++) cin >> m[i];\n\tcin >> T;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tif (m[j][k] == s[i][0]) {\n\t\t\t\t\tused[j][k] = 1;\n\t\t\t\t\tc[i] += rec(k, j, 1, i);\n\t\t\t\t\tused[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dp[10009] = { 0 };\n\tfor (int i = 0; i < N; i++) {\n\t\tint x = c[i];\n\t\tfor (int j = 1; x > 0; j <<= 1) {\n\t\t\tint mul = min(j, x);\n\t\t\tfor (int k = T; k >= s[i].size() * mul; k--) dp[k] = max(dp[k], dp[k - s[i].size() * mul] + a[i] * mul);\n\t\t\tx -= mul;\n\t\t}\n\t}\n\tcout << dp[T] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Node{\n\tint children[26],finish_id;\n};\n\nstruct Data{\n\tvoid set(int arg_row,int arg_col,int arg_parent,int arg_node_id){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tparent = arg_parent;\n\t\tnode_id = arg_node_id;\n\t}\n\tint row,col,parent,node_id;\n\tbool check[4][4];\n};\n\nint score[101],num[101],len[101];\nint N,index_table[26];\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\nNode nodes[26][800]; //???????????\n\nchar base_map[4][5];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 3 && col >= 0 && col <= 3)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(Data data){\n\n\tint adj_row,adj_col,next_node;\n\tfor(int i = 0; i < 8; i++){\n\t\tadj_row = data.row+diff_row[i];\n\t\tadj_col = data.col+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || data.check[adj_row][adj_col] == true)continue;\n\n\t\tnext_node = base_map[adj_row][adj_col]-'A';\n\t\tif(nodes[data.parent][data.node_id].children[next_node] == -1)continue;\n\n\t\tData new_data;\n\t\tnew_data.set(adj_row,adj_col,data.parent,nodes[data.parent][data.node_id].children[next_node]);\n\t\tif(nodes[new_data.parent][new_data.node_id].finish_id != -1){\n\t\t\tnum[nodes[new_data.parent][new_data.node_id].finish_id]++;\n\t\t}\n\t\tfor(int a = 0; a < 4; a++){\n\t\t\tfor(int b = 0; b < 4; b++)new_data.check[a][b] = data.check[a][b];\n\t\t}\n\t\tnew_data.check[adj_row][adj_col] = true;\n\t\trecursive(new_data);\n\t}\n}\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 1; i <= N; i++)num[i] = 0;\n\n\tfor(int i = 0; i < 26; i++)index_table[i] = 1;\n\tfor(int i = 0; i < 26; i++){\n\t\tfor(int k = 0; k < 800; k++){\n\t\t\tnodes[i][k].finish_id = -1;\n\t\t\tfor(int p = 0; p < 26; p++){\n\t\t\t\tnodes[i][k].children[p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tchar  buf[9];\n\tint parent,tmp_index,node_id,length;\n\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%s %d\",buf,&score[i]);\n\t\tfor(length = 0; buf[length] != '\\0';length++);\n\t\tlen[i]\t= length;\n\t\tparent = buf[0]-'A';\n\t\ttmp_index = 1;\n\t\tnode_id = 0;\n\t\twhile(buf[tmp_index] != '\\0'){\n\t\t\tif(nodes[parent][node_id].children[buf[tmp_index]-'A'] == -1){\n\t\t\t\tnodes[parent][node_id].children[buf[tmp_index]-'A'] = index_table[parent]++;\n\t\t\t\tnode_id = nodes[parent][node_id].children[buf[tmp_index]-'A'];\n\t\t\t}else{\n\t\t\t\tnode_id = nodes[parent][node_id].children[buf[tmp_index]-'A'];\n\t\t\t}\n\t\t\ttmp_index++;\n\t\t}\n\t\tnodes[parent][node_id].finish_id = i;\n\t}\n\n\tfor(int i = 0; i < 26; i++){\n\t\tif(nodes[i][0].finish_id != -1){\n\t\t\tnum[nodes[i][0].finish_id]++;\n\t\t}\n\t}\n\n\tfor(int row = 0; row < 4; row++)scanf(\"%s\",base_map[row]);\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tfor(int row = 0; row < 4; row++){\n\t\tfor(int col = 0; col < 4; col++){\n\t\t\tData new_data;\n\t\t\tnew_data.set(row,col,base_map[row][col]-'A',0);\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tfor(int b = 0; b < 4; b++)new_data.check[a][b] = false;\n\t\t\t}\n\t\t\tnew_data.check[row][col] = true;\n\t\t\trecursive(new_data);\n\t\t}\n\t}\n\n\n\tint dp[T+1],next_dp[T+1];\n\tdp[0] = 0;\n\tnext_dp[0] = 0;\n\tfor(int i = 1; i <= T; i++){\n\t\tdp[i] = -1;\n\t\tnext_dp[i] = -1;\n\t}\n\n\tfor(int word = 1; word <= N; word++){\n\t\tif(num[word] == 0)continue;\n\n\t\tfor(int i = 1; i <= num[word]; i++){\n\t\t\tfor(int k = T; k-i*len[word] >= 0; k--){\n\t\t\t\tif(dp[k-i*len[word]] >= 0){\n\t\t\t\t\tnext_dp[k] = max(next_dp[k],dp[k-i*len[word]]+i*score[word]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= T; i++)dp[i] = next_dp[i];\n\t}\n\n\tint maximum = -1;\n\tfor(int i = 0; i <= T; i++)maximum = max(maximum,dp[i]);\n\n\tprintf(\"%d\\n\",maximum);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint trie[1000][26];\nint id[1000];\nint total;\nvoid insert(const string &s, int idd) {\n  int pos = 0;\n  FOR(it, s) {\n    int k = *it - 'A';\n    if (!trie[pos][k]) {\n      total++;\n      trie[pos][k] = total;\n    }\n    pos = trie[pos][k];\n  }\n  id[pos] = idd;\n}\n\nchar c[4][4];\nmap<string,int> mp;\nint score[100];\nint len[100];\nll num[100];\ntypedef pair<pii,int> P;\n\nbool trace[4][4];\n\nvoid check(int i, int j, int h, int pos) {\n  int k = c[i][j]-'A';\n  if (!trie[pos][k]) return;\n  pos = trie[pos][k];\n  if (id[pos] >= 0) {\n    num[id[pos]]++;\n  }\n  if (h == 7) return;\n  trace[i][j] = 1;  \n  for (int ii=i-1;ii<=i+1; ++ii) {\n    for (int jj=j-1; jj<=j+1; ++jj) {\n      if (ii==i&&jj==j) continue;\n      if (valid(ii,jj,4,4) && !trace[ii][jj]) {\n        check(ii,jj,h+1,pos);\n      }\n    }\n  }\n  trace[i][j] = 0;\n}\n\nll dp[10001];\nint deq[100000];\nll deqv[100000];\n\nint main() {\n  int n;\n  while(cin>>n) {\n    total = 0;\n    memset(trie,0,sizeof(trie));\n    memset(id,-1,sizeof(id));\n    REP(i,n) {\n      string s;\n      int w;\n      cin >> s >> w;\n      insert(s,i);\n      score[i] = w;\n      len[i] = s.size();\n      num[i] = 0;\n    }\n    REP(i,4) {\n      REP(j,4)\n        cin >> c[i][j];\n    }\n    REP(i,4)REP(j,4)check(i,j,0,0);\n    // REP(i,n) {\n    //   cout << len[i] << \" \" << score[i] << \" \" << num[i] << endl;\n    // }\n    int T;\n    cin >> T;\n    memset(dp,0,sizeof(dp));\n    REP(i,n) {\n      REP(a,len[i]) {\n        int s = 0, t = 0;\n        for (int j=0; j*len[i]+a <= T; ++j) {\n          ll val = dp[j*len[i]+a] - j*score[i];\n          while(s<t && deqv[t-1] <= val) t--;\n          deq[t] = j;\n          deqv[t++] = val;\n          dp[j*len[i]+a] = deqv[s] + j*score[i];\n          if (deq[s] == j-num[i])\n            s++;\n        }\n      }\n    }\n    cout << dp[T] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(__builtin_popcount((visited)) > 8) return;\n  \n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    ll dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\tint cost = key.length();\n\n\tll next[10001];\n\tmemcpy(next,dp,sizeof(ll)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + (ll)score_table[key],\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(ll)*10001);\n      }\n    }\n\n    ll max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%lld\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class K, class V> ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<string> ws;\n    vector<int> ss;\n    int T;\n    vector<string> F;\n    void input() {\n        cin >> N;\n        ws.clear(); ws.resize(N);\n        ss.clear(); ss.resize(N);\n        for (int i = 0; i < N; i++) cin >> ws[i] >> ss[i];\n        F.clear(); F.resize(4);\n        cin >> F;\n        cin >> T;\n    }\n\n    vector<int> count;\n\n    void dfs(int i, int j, int y, int x, int used) {\n        if (j == ws[i].size()) {\n            count[i]++;\n            return;\n        }\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int ny = y + dy;\n                int nx = x + dx;\n                if (ny < 0 || ny >= 4 || nx < 0 || nx >= 4) continue;\n                if (F[ny][nx] != ws[i][j]) continue;\n                if (used & (1 << (4*ny+nx))) continue;\n                dfs(i, j + 1, ny, nx, used | (1<<4*ny+nx));\n            }\n        }\n    }\n\n    const int INF = 1<<28;\n\n    void solve() {\n        count.clear(); count.resize(N, 0);\n        map<char, bool> found;\n        for (int y = 0; y < 4; y++) {\n            for (int x = 0; x < 4; x++) {\n                found[F[y][x]] = true;\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < ws[i].size(); j++) {\n                if (not found[ws[i][j]]) {\n                    goto next;\n                }\n            }\n            for (int y = 0; y < 4; y++) {\n                for (int x = 0; x < 4; x++) {\n                    if (F[y][x] == ws[i][0]) {\n                        dfs(i, 1, y, x, 1<<(4*y+x));\n                    }\n                }\n            }\n            next:;\n        }\n        auto dp = vector<vector<int>>(2, vector<int>(T + 1, -INF));\n        dp[0][0] = 0;\n        for (int i = 1; i <= N; i++) {\n            int l = ws[i - 1].size();\n            for (int t = 0; t <= T; t++) {\n                if (dp[0][t] >= 0) {\n                    for (int k = 0; k <= count[i - 1]; k++) {\n                        int x = t + k * l;\n                        if (x > T) break;\n                        dp[1][x] = max(dp[1][x], dp[0][t] + k * ss[i - 1]);\n                    }\n                }\n            }\n            swap(dp[0], dp[1]);\n        }\n        int ans = 0;\n        for (int t = 0; t <= T; t++) {\n            ans = max(ans, dp[0][t]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  bits |= (1<<(4*y+x));\n  if(__builtin_popcount((bits & mask)) > 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    dfs(dx,dy,str,bits,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    ll dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = (1<<(y*4+x));\n\tbits <<= 16;\n\tdfs(x,y,\"\",bits,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tll next[10001];\n\tmemcpy(next,dp,sizeof(ll)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + (ll)score_table[key],\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(ll)*10001);\n      }\n    }\n\n    ll max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%lld\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n;\nmap<string,int> s, ct;\n\nstring f[4];\n\nbool vis[4][4]={};\nvoid dfs(int d, int y, int x, string now){\n    if(s.count(now)) ++ct[now];\n    if(d==8) return;\n\n    for(int dy=-1; dy<=1; ++dy)for(int dx=-1; dx<=1; ++dx){\n        int ny = y+dy , nx = x+dx;\n        if(0<=ny && ny<4 && 0<=nx && nx<4 && !vis[ny][nx]){\n            vis[ny][nx] = true;\n            dfs(d+1,ny,nx,now+f[ny][nx]);\n            vis[ny][nx] = false;\n        }\n    }\n}\n\nconst int N = 10001;\n\nvector<int> v[9];\nint dp[N]={};\n\nint main(){\n    cin >>n;\n    rep(i,n){\n        string w;\n        int score;\n        cin >>w >>score;\n        s[w] = score;\n    }\n\n    rep(i,4) cin >>f[i];\n\n    rep(i,4)rep(j,4){\n        vis[i][j] = true;\n        dfs(1,i,j,string(1,f[i][j]));\n        vis[i][j] = false;\n    }\n\n    for(const auto &p:ct){\n        int sz = p.fi.size();\n        rep(i,p.se) v[sz].pb(s[p.fi]);\n    }\n\n    int T;\n    cin >>T;\n\n    for(int i=1; i<=8; ++i){\n        vector<int> x = v[i];\n        sort(all(x));\n\n        int X = x.size();\n        if(X>10000/i) x.resize(10000/i);\n        X = x.size();\n\n        rep(j,X){\n            for(int k=T-i; k>=0; --k){\n                dp[k+i] = max(dp[k+i], dp[k]+x[j]);\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,T+1) ans = max(ans,dp[i]);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\nconst int MAX = 10001;\nconst int SIZE = 4;\nint dp[MAX], N, T;\nchar grid[SIZE][SIZE];\nvector<P> word;\nvector<int> able;\nint dh[] = {1,0,-1,0,1,1,-1,-1};\nint dw[] = {0,1,0,-1,1,-1,1,-1};\n\nvoid input(){\n  cin >> N;\n  word.resize(N);\n  for(int i = 0; i < N; i++) cin >> word[i].first >> word[i].second;\n  for(int i = 0; i < SIZE; i++) for(int j = 0; j < SIZE; j++) cin >> grid[i][j];\n  cin >> T;\n}\n\nint rec(const int& h, const int& w, const string& s, const int& used){\n  int res = 0;\n  for(int i = 0; i < 8; i++){\n    int nh = h+dh[i], nw = w+dw[i];\n    if(nh < 0 || nh >= SIZE || nw < 0 || nw >= SIZE) continue;\n    if(grid[nh][nw] != s[0]) continue;\n    if(used & (1 << (4*nh+nw))) continue;\n    res += (s.length()==1?1:rec(nh, nw, s.substr(1), used|(1<<(4*nh+nw))));\n  }\n  return res;\n}\n\nvoid find(){\n  able = vector<int>(N,0);\n  for(int i = 0; i < (int)word.size(); i++)\n    for(int h = 0; h < SIZE; h++)\n      for(int w = 0; w < SIZE; w++)\n\tif(grid[h][w] == word[i].first[0]) able[i] += rec(h,w,word[i].first.substr(1), (1<<(4*h+w)));\n}\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  \n  for(int i = 0; i < N; i++)\n    for(int t = T; t >= 0; t--)\n      if(dp[t] != -1)\n\tfor(int q = 1; q <= able[i]; q++)\n\t  if(t+q*(int)word[i].first.length() <= T) dp[t+q*word[i].first.length()] = max(dp[t+q*word[i].first.length()], dp[t]+q*word[i].second);\n\t  else break;\n\n  int res = 0;\n  for(int i = 0; i <= T; i++) res = max(res, dp[i]);\n  cout << res << endl;\n}\nint main(){\n  input();\n  find();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nint dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nstring line[4];\nset<string> dict;\nmap<string, int> cnt;\nbool used[4][4];\nvoid dfs(int x, int y, string s){\n    if(dict.count(s)){\n        cnt[s]++;\n    }\n    if(s.size() == 8) return;\n\n    REP(r, 8){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && !used[ny][nx]){\n            used[ny][nx] = true;\n            dfs(nx, ny, s + line[ny][nx]);\n            used[ny][nx] = false;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N){\n        cnt.clear();\n\n        vector<string> words(N);\n        vector<int> scores(N);\n        REP(i, N) cin >> words[i] >> scores[i];\n        REP(i, N) dict.insert(words[i]);\n        REP(i, 4) cin >> line[i];\n        REP(y, 4) REP(x, 4){\n            used[y][x] = true;\n            dfs(x, y, string(1, line[y][x]));\n            used[y][x] = false;\n        }\n\n        int T;\n        cin >> T;\n        int dp[10001] = {};\n        for(int i = 0; i < N; i++){\n            int w = words[i].size();\n            int s = scores[i];\n            int rest = cnt[words[i]];\n            for(int mul = 1; rest > 0; mul <<= 1){\n                int use = min(mul, rest);\n                rest -= use;\n                for(int j = T; j >= use * w; j--){\n                    dp[j] = max(dp[j], dp[j - use * w] + use * s);\n                }\n            }\n        }\n        cout << dp[T] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  bits |= (1<<(4*y+x));\n  if(__builtin_popcount((bits & mask)) > 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    dfs(dx,dy,str,bits,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    ll dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = (1<<(y*4+x));\n\tbits <<= 16;\n\tdfs(x,y,\"\",bits,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tll next[10001];\n\tmemcpy(next,dp,sizeof(int)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + (ll)score_table[key],\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    ll max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%lld\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b;}\n\nconstexpr int SIZE = 4;\nconstexpr int MAX_N = 100;\nconstexpr int MAX_LEN = 8;\n\nconst int dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\nunordered_map<string, int> word_idx;\n\nstring board[SIZE];\nint scores[MAX_N];\nint cnt[MAX_N];\nint len[MAX_N];\nbool visited[SIZE][SIZE];\n\nvoid dfs(int x, int y, string s = \"\") {\n\ts += board[y][x];\n\tif(word_idx.count(s)) ++cnt[word_idx[s]];\n\tif(s.size() >= MAX_LEN) return;\n\n\tvisited[y][x] = true;\n\n\tfor(int i = 0; i < 8; ++i) {\n\t\tconst int nx = x + dx[i];\n\t\tconst int ny = y + dy[i];\n\n\t\tif(nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE || visited[ny][nx])\n\t\t\tcontinue;\n\n\t\tdfs(nx, ny, s);\n\t}\n\n\tvisited[y][x] = false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tstring word;\n\t\tcin >> word >> scores[i];\n\t\tword_idx[word] = i;\n\t\tlen[i] = (int)word.size();\n\t}\n\n\tfor(int i = 0; i < SIZE; ++i) {\n\t\tcin >> board[i];\n\t}\n\n\tint t;\n\tcin >> t;\n\n\tmemset(visited, false, sizeof(visited));\n\tfor(int i = 0; i < SIZE; ++i) {\n\t\tfor(int j = 0; j < SIZE; ++j) {\n\t\t\tdfs(j, i);\n\t\t}\n\t}\n\n\tvector<int> dp(t + 1, 0);\n\tint mx = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < cnt[i]; ++j) {\n\t\t\tfor(int k = min(mx, t - len[i]); k >= 0; --k) {\n\t\t\t\tchmax(dp[k + len[i]], dp[k] + scores[i]);\n\t\t\t}\n\t\t\tmx += len[i];\n\t\t}\n\t}\n\n\tcout << *max_element(dp.begin(), dp.end()) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      int next[10001];\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\tint cost = key.length();\n\tint score = score_table[key];\n\n\tmemcpy(next,dp,sizeof(int)*10001);\n\tfor(int from_time=0;from_time + cost<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score,\n\t\t\t\tnext[next_time]);\n\t}\n\t// memcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  if(__builtin_popcount((bits & mask)) >= 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    string next = str;\n    next.push_back(stage[dy][dx]);\n    dfs(dx,dy,next,bits | (1<<idx),stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> idx2keyword;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      idx2keyword.push_back(word);\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = ((1<<(y*4+x)) << 16);\n\tstring str = \"\";\n\tstr.push_back(stage[y][x]);\n\tdfs(x,y,str,bits | (1<<(y*4+x)),stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int idx=0;idx<N;idx++){\n      string key = idx2keyword[idx];\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tint next[10001];\n\tmemset(next,0,sizeof(next));\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score_table[key],\n\t\t\t\tdp[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[8] = { 1,0,-1,-1,-1,0,1,1 };\n\nchar mp[4][4];\nbool used[4][4];\n\nvector<string> v;\nstring cur;\n\n\nvoid dfs(int x,int y) {\n\tv.push_back(cur);\n\tif (cur.length() == 8)return;\n\trep(k, 8) {\n\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\tif (nx < 0 || ny < 0 || nx >= 4 || ny >= 4)continue;\n\t\tif (used[nx][ny])continue;\n\t\tcur.push_back(mp[nx][ny]);\n\t\tused[nx][ny] = true;\n\t\tdfs(nx, ny);\n\t\tused[nx][ny] = false;\n\t\tcur.pop_back();\n\t}\n}\n\nint dp[10001];\n\nvoid solve() {\n\tsort(v.begin(), v.end());\n\tint n; cin >> n;\n\tvector<string> s(n); vector<int> c(n);\n\trep(i, n) {\n\t\tcin >> s[i] >> c[i];\n\t}\n\trep(i, 4) {\n\t\trep(j, 4)cin >> mp[i][j];\n\t}\n\trep(i, 4) {\n\t\trep(j, 4) {\n\t\t\tcur.push_back(mp[i][j]);\n\t\t\tused[i][j] = true;\n\t\t\tdfs(i, j);\n\t\t\tused[i][j] = false;\n\t\t\tcur.pop_back();\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint t; cin >> t;\n\trep(i, n) {\n\t\tint num = upper_bound(v.begin(), v.end(), s[i]) - lower_bound(v.begin(), v.end(), s[i]);\n\t\tint len = s[i].length();\n\t\tper(k, t + 1) {\n\t\t\t\n\t\t\trep1(j, num) {\n\t\t\t\tint ni = k + j * len;\n\t\t\t\tif (ni > t)break;\n\t\t\t\tdp[ni] = max(dp[ni], dp[k] + j * c[i]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, t + 1)ans = max(ans, dp[i]);\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  if(__builtin_popcount((bits & mask)) >= 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    string next = str;\n    next.push_back(stage[dy][dx]);\n    dfs(dx,dy,next,bits | (1<<idx),stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> idx2keyword;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      idx2keyword.push_back(word);\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = ((1<<(y*4+x)) << 16);\n\tstring str = \"\";\n\tstr.push_back(stage[y][x]);\n\tdfs(x,y,str,bits | (1<<(y*4+x)),stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int idx=0;idx<N;idx++){\n      string key = idx2keyword[idx];\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tint tmp[10001];\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(int next_time=0;next_time<=time_limit;next_time++){\n\t  int from_time = next_time - cost;\n\t  if(from_time < 0) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  tmp[next_time] = max(dp[from_time] + score_table[key],dp[next_time]);\n\t}\n\tmemcpy(dp,tmp,sizeof(int)*10000);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define long long long // for codeforces\n\nint node[1000][26];\nint type[1000][26];\nint nodes = 0;\n\nstring word[100];\nint score[100];\n\nchar m[6][6];\nbool visited[6][6];\n\ninline int init_node(){\n  rep(i,26) node[nodes][i] = -1;\n  rep(i,26) type[nodes][i] = -1;\n  return nodes++;\n}\n\nvoid build_trie(int idx, int l, int node_id){\n  if(word[idx].size() == l+1){\n    type[node_id][word[idx].back()-'A'] = idx;\n    return;\n  }\n  int c = word[idx][l] - 'A';\n  // dbg(idx,l,node_id,word[idx]);\n  assert(0<=c && c<26);\n  if(node[node_id][c] == -1) node[node_id][c] = init_node();\n  build_trie(idx, l+1, node[node_id][c]);\n}\n\nint cnt[111];\n\nvoid dfs(int x, int y, int node_id, int dep){\n  int c = m[x][y] - 'A';\n  if(type[node_id][c]>=0) cnt[type[node_id][c]]++;\n\n  visited[x][y] = true;\n  int nid = node[node_id][c];\n  if(nid>=0){\n    rep(dx,-1,2) rep(dy,-1,2){\n      int nx = x + dx, ny = y + dy;\n      if(visited[nx][ny] || m[nx][ny]=='\\0') continue;\n      if(nid>=0) dfs(nx, ny, nid, dep+1);\n    }\n  }\n  visited[x][y] = false;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n) cin>>word[i]>>score[i];\n\n  init_node();\n  rep(i,n) build_trie(i,0,0);\n\n  fill(m[0], m[6], '\\0');\n  fill(visited[0], visited[6], false);\n  rep(i,4) scanf(\"%s\", &m[i+1][1]);\n\n  fill(cnt, cnt+n, 0);\n  rep(i,1,5)rep(j,1,5) dfs(i,j,0,1);\n\n  int t;\n  cin>>t;\n  vector<int> dp(t+1, 0);\n  rep(i,n){\n    vector<int> nxt(dp);\n    int sz = word[i].size();\n    for(int j=1; sz*j<=t && j<=cnt[i]; j++){\n      int c = sz*j;\n      int v = score[i]*j;\n      for(int k = t-c; k>=0; k--){\n        nxt[k+c] = max(nxt[k+c], dp[k]+v);\n      }\n    }\n    swap(dp, nxt);\n  }\n\n  cout << *max_element(all(dp)) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <array>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n\nconst int dx[]={1,1,1,0,0,-1,-1,-1};\nconst int dy[]={-1,0,1,-1,1,-1,0,1};\ninline bool in(int x, int y){ return 0<=x&&x<4&&0<=y&&y<4; }\nint n;\nchar board[4][5];\narray<int,100> v,w,c;\narray<string,100> word;\narray<array<bool,4>,4> used;\narray<int,10001> dp;\n\nvoid dfs(int i,int x,int y,int si){\n    const string& s=word[si];\n    used[y][x]=1;\n    if(i==(int)s.size()-1){\n        c[si]++;\n    } else {\n        rep(d,8){\n            int nx=x+dx[d], ny=y+dy[d];\n            if(in(nx,ny) && s[i+1]==board[ny][nx] && !used[ny][nx])\n                dfs(i+1,nx,ny,si);\n        }\n    }\n    used[y][x]=0;\n}\n\nint main(){\n    cin>>n;\n    rep(i,n){\n        cin>>word[i];\n        cin>>v[i];\n        w[i]=word[i].size();\n    }\n    rep(i,4) cin>>board[i];\n    rep(si,n)rep(y,4)rep(x,4){\n        if(word[si][0]==board[y][x]) dfs(0,x,y,si);\n    }\n    int sum;cin>>sum;\n    rep(i,n){\n        if(c[i]==0) continue;\n        for(int j=sum; j>=0; j--){\n            for(int k=1; k<=c[i] && j-w[i]*k>=0; k++){\n                dp[j]=max(dp[j],dp[j-w[i]*k]+v[i]*k);\n            }\n        }\n    }\n    cout<<dp[sum]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class K, class V> ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<string> ws;\n    vector<int> ss;\n    int T;\n    vector<string> F;\n    void input() {\n        cin >> N;\n        ws.clear(); ws.resize(N);\n        ss.clear(); ss.resize(N);\n        for (int i = 0; i < N; i++) cin >> ws[i] >> ss[i];\n        F.clear(); F.resize(4);\n        cin >> F;\n        cin >> T;\n    }\n\n    vector<int> count;\n\n    void dfs(int i, int j, int y, int x, int used) {\n        if (j == ws[i].size()) {\n            count[i]++;\n            return;\n        }\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int ny = y + dy;\n                int nx = x + dx;\n                if (ny < 0 || ny >= 4 || nx < 0 || nx >= 4) continue;\n                if (F[ny][nx] != ws[i][j]) continue;\n                if (used & (1 << (4*ny+nx))) continue;\n                dfs(i, j + 1, ny, nx, used | (1<<4*ny+nx));\n            }\n        }\n    }\n\n    const int INF = 1<<28;\n\n    void solve() {\n        count.clear(); count.resize(N, 0);\n        for (int i = 0; i < N; i++) {\n            for (int y = 0; y < 4; y++) {\n                for (int x = 0; x < 4; x++) {\n                    if (F[y][x] == ws[i][0]) {\n                        dfs(i, 1, y, x, 1<<(4*y+x));\n                    }\n                }\n            }\n        }\n        auto dp = vector<vector<int>>(2, vector<int>(T + 1, -INF));\n        dp[0][0] = 0;\n        for (int i = 1; i <= N; i++) {\n            int l = ws[i - 1].size();\n            for (int t = 0; t <= T; t++) {\n                if (dp[0][t] >= 0) {\n                    for (int k = 0; k <= count[i - 1]; k++) {\n                        int x = t + k * l;\n                        if (x <= T) {\n                            dp[1][x] = max(dp[1][x], dp[0][t] + k * ss[i - 1]);\n                        }\n                    }\n                }\n            }\n            swap(dp[0], dp[1]);\n        }\n        int ans = 0;\n        for (int t = 0; t <= T; t++) {\n            ans = max(ans, dp[0][t]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\nconst int MAX = 10001;\nconst int SIZE = 4;\nint dp[MAX], N, T;\nchar grid[SIZE][SIZE];\nvector<P> word;\nvector<int> able;\nint dh[] = {1,0,-1,0,1,1,-1,-1};\nint dw[] = {0,1,0,-1,1,-1,1,-1};\n\nvoid input(){\n  cin >> N;\n  word.resize(N);\n  for(int i = 0; i < N; i++) cin >> word[i].first >> word[i].second;\n  for(int i = 0; i < SIZE; i++) for(int j = 0; j < SIZE; j++) cin >> grid[i][j];\n  cin >> T;\n}\n\nint rec(int h, int w, const string& s){\n  if(s == \"\") return 1;\n\n  int res = 0;\n  for(int i = 0; i < 8; i++){\n    int nh = h+dh[i], nw = w+dw[i];\n    if(nh < 0 || nh >= SIZE || nw < 0 || nw >= SIZE) continue;\n    if(grid[nh][nw] != s[0]) continue;\n    res += rec(nh, nw, s.substr(1));\n  }\n  return res;\n}\n\nvoid find(){\n  able = vector<int>(N,0);\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int h = 0; h < SIZE; h++)\n      for(int w = 0; w < SIZE; w++)\n\tif(grid[h][w] == word[i].first[0]) able[i] += rec(h,w,word[i].first.substr(1));\n}\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int t = T; t >= 0; t--)\n      if(dp[t] != -1)\n\tfor(int q = 1; q <= able[i]; q++)\n\t  if(t+q*(int)word[i].first.length() <= T) dp[t+q*word[i].first.length()] = max(dp[t+q*word[i].first.length()], dp[t]+q*word[i].second);\n\n  int res = 0;\n  for(int i = 0; i <= T; i++) res = max(res, dp[i]);\n  cout << res << endl;\n}\nint main(){\n  input();\n  find();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  if(__builtin_popcount((bits & mask)) >= 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    string next = str;\n    next.push_back(stage[dy][dx]);\n    dfs(dx,dy,next,bits | (1<<idx),stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> idx2keyword;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      idx2keyword.push_back(word);\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = ((1<<(y*4+x)) << 16);\n\tstring str = \"\";\n\tstr.push_back(stage[y][x]);\n\tdfs(x,y,str,bits | (1<<(y*4+x)),stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int idx=0;idx<N;idx++){\n      string key = idx2keyword[idx];\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tint tmp[10001];\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(int next_time=0;next_time<=time_limit;next_time++){\n\t  int from_time = next_time - cost;\n\t  if(from_time < 0) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  tmp[next_time] = max(dp[from_time] + score_table[key],dp[next_time]);\n\t}\n\tmemcpy(dp,tmp,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(__builtin_popcount((visited)) > 8) return;\n  \n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    ll dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\tint cost = key.length();\n\n\tll next[10001];\n\tmemcpy(next,dp,sizeof(ll)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + (ll)score_table[key],\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(ll)*10001);\n      }\n    }\n\n    ll max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%lld\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nmap<string,int> id;\nll n,s[100],t,num[100],maxlen;\nll dp[10001];\nstring w[100],g[4];\nbool vis[4][4];\nint deq[10001], deqv[10001];\nconst int dy[] = {-1,-1,0,1,1,1,0,-1}, dx[] = {0,1,1,1,0,-1,-1,-1};\n\nvoid dfs(int y,int x,string txt){\n  txt += g[y][x];\n  if(txt.size()>maxlen)return;\n  if(id.find(txt) != id.end())num[id[txt]]++;\n\n  rep(i,8){\n    int ny = y+dy[i], nx = x+dx[i];\n    if(ny<0 || nx<0 || ny>=4 || nx>=4)continue;\n    if(vis[ny][nx])continue;\n    vis[ny][nx] = true;\n    dfs(ny,nx,txt);\n    vis[ny][nx] = false;\n  }\n}\n\nint main(){\n  cin >> n;\n  maxlen = 0;\n  rep(i,n){\n    cin >> w[i] >> s[i];\n    id[w[i]] = i;\n    maxlen = max(maxlen,(ll)w[i].size());\n  }\n\n  rep(i,4)cin >> g[i];\n  cin >> t;\n  memset(vis,0,sizeof(vis));\n\n\n  rep(i,4){\n    rep(j,4){\n      vis[i][j] = true;\n      dfs(i,j,\"\");\n      vis[i][j] = false;\n    }\n  }\n\n  memset(dp,0,sizeof(dp));\n\n  rep(i,n){\n    rep(a,w[i].size()){\n      int st = 0, en = 0;\n      for(int j=0;j*w[i].size() + a <= t;j++){\n\tint val = dp[j*w[i].size() + a] - j * s[i];\n\twhile(st<en && deqv[en-1] <= val)en--;\n\tdeq[en] = j;\n\tdeqv[en++] = val;\n\tdp[j*w[i].size() + a] = deqv[st] + j * s[i];\n\tif(deq[st] == j - num[i])st++;\n      }\n    }\n  }\n  cout << dp[t] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nconst int mask = (1<<16) - 1;\n\nmap<string,set<int> > route;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int bits,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  bits |= (1<<(4*y+x));\n  if(__builtin_popcount((bits & mask)) > 8) return;\n  \n  if(keywords.count(str) > 0\n     && route[str].count(bits) == 0){\n    route[str].insert(bits);\n  }\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(bits & (1<<idx)) continue;\n    dfs(dx,dy,str,bits,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    route.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tint bits = (1<<(y*4+x));\n\tbits <<= 16;\n\tdfs(x,y,\"\",bits,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      for(int route_idx=0,size=route[key].size();\n\t  route_idx < size;\n\t  route_idx++){\n\tint cost = key.length();\n\n\tint next[10001];\n\tmemcpy(next,dp,sizeof(int)*10001);\n\tfor(int from_time=0;from_time<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(from_time >= time_limit) continue;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score_table[key],\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\nconst int MAX = 10001;\nconst int SIZE = 4;\nint dp[MAX], N, T;\nchar grid[SIZE][SIZE];\nvector<P> word;\nmap<string, int> able;\nint dh[] = {1,0,-1,0,1,1,-1,-1};\nint dw[] = {0,1,0,-1,1,-1,1,-1};\n\nvoid input(){\n  cin >> N;\n  word.resize(N);\n  for(int i = 0; i < N; i++){\n    cin >> word[i].first >> word[i].second;\n    able[word[i].first] = 0;\n  }\n  for(int i = 0; i < SIZE; i++) for(int j = 0; j < SIZE; j++) cin >> grid[i][j];\n  cin >> T;\n}\n\nvoid rec(const int& h, const int& w, const string& s, const int& used){\n  if(able.count(s)) able[s]++;\n  if(s.length() == 8) return;\n  for(int i = 0; i < 8; i++){\n    int nh = h+dh[i], nw = w+dw[i];\n    if(nh < 0 || nh >= SIZE || nw < 0 || nw >= SIZE) continue;\n    if(used & (1 << (4*nh+nw))) continue;\n    rec(nh, nw, s+grid[nh][nw], used | (1<<(4*nh+nw)));\n  }\n}\n\nvoid find(){\n  for(int h = 0; h < SIZE; h++)\n    for(int w = 0; w < SIZE; w++)\n      rec(h,w,string(1,grid[h][w]),(1<<(4*h+w)));\n}\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int t = T; t >= 0; t--)\n      if(dp[t] != -1)\n\tfor(int q = 1; q <= able[word[i].first]; q++)\n\t  if(t+q*(int)word[i].first.length() <= T) dp[t+q*word[i].first.length()] = max(dp[t+q*word[i].first.length()], dp[t]+q*word[i].second);\n\t  else break;\n\n  int res = 0;\n  for(int i = 0; i <= T; i++) res = max(res, dp[i]);\n  cout << res << endl;\n}\nint main(){\n  input();\n  find();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      int next[10001];\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\tint cost = key.length();\n\tint score = score_table[key];\n\n\tmemcpy(next,dp,sizeof(int)*10001);\n\tfor(int from_time=0;from_time + cost<=time_limit;from_time++){\n\t  int next_time = from_time + cost;\n\t  if(dp[from_time] == -1) continue;\n\t  next[next_time] = max(dp[from_time] + score,\n\t\t\t\tnext[next_time]);\n\t}\n\tmemcpy(dp,next,sizeof(int)*10001);\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nstruct State { int x[4][4]; };\nchar F[4][4]; vector<pair<int, int>>v; string U[100]; int V[100], dp[10009];\nint solve(string S, int depth, int cx, int cy, State Y) {\n\tif (depth == S.size())return 1;\n\tint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\n\tint cnt = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ey < 0 || ex >= 4 || ey >= 4)continue;\n\t\tif (Y.x[ex][ey] == 0 && F[ex][ey] == S[depth]) {\n\t\t\tState Z = Y; Z.x[ex][ey] = 1;\n\t\t\tcnt += solve(S, depth + 1, ex, ey, Z);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> U[i] >> V[i]; }\n\tfor (int i = 0; i < 16; i++)cin >> F[i / 4][i % 4];\n\tfor (int i = 0; i < n; i++) { \n\t\tint c = 0;\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (F[j / 4][j % 4] != U[i][0])continue;\n\t\t\tState R; for (int k = 0; k < 16; k++)R.x[k / 4][k % 4] = 0; R.x[j / 4][j % 4] = 1;\n\t\t\tc += solve(U[i], 1, j / 4, j % 4, R);\n\t\t}\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tif (c >= (1 << j)) { v.push_back(make_pair(V[i] * (1 << j), U[i].size()*(1 << j))); c -= (1 << j); }\n\t\t\telse { v.push_back(make_pair(V[i] * c, U[i].size()*c)); break; }\n\t\t}\n\t}\n\tint T; cin >> T; int maxn = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = T; j >= v[i].second; j--) {\n\t\t\tdp[j] = max(dp[j], dp[j - v[i].second] + v[i].first); maxn = max(maxn, dp[j]);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\nconst int MAX = 10001;\nconst int SIZE = 4;\nint dp[MAX], N, T;\nchar grid[SIZE][SIZE];\nvector<P> word;\nvector<int> able;\nint dh[] = {1,0,-1,0,1,1,-1,-1};\nint dw[] = {0,1,0,-1,1,-1,1,-1};\n\nvoid input(){\n  cin >> N;\n  word.resize(N);\n  for(int i = 0; i < N; i++) cin >> word[i].first >> word[i].second;\n  for(int i = 0; i < SIZE; i++) for(int j = 0; j < SIZE; j++) cin >> grid[i][j];\n  cin >> T;\n}\n\nint rec(int h, int w, const string& s, int used){\n  if(s == \"\") return 1;\n\n  int res = 0;\n  for(int i = 0; i < 8; i++){\n    int nh = h+dh[i], nw = w+dw[i];\n    if(nh < 0 || nh >= SIZE || nw < 0 || nw >= SIZE) continue;\n    if(grid[nh][nw] != s[0]) continue;\n    if(used & (1 << (4*nh+nw))) continue;\n    res += rec(nh, nw, s.substr(1), used|(1<<(4*nh+nw)));\n  }\n  return res;\n}\n\nvoid find(){\n  able = vector<int>(N,0);\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int h = 0; h < SIZE; h++)\n      for(int w = 0; w < SIZE; w++)\n\tif(grid[h][w] == word[i].first[0]) able[i] += rec(h,w,word[i].first.substr(1), (1<<(4*h+w)));\n}\n\nvoid solve(){\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  \n  for(int i = 0; i < (int)word.size(); i++)\n    for(int t = T; t >= 0; t--)\n      if(dp[t] != -1)\n\tfor(int q = 1; q <= able[i]; q++)\n\t  if(t+q*(int)word[i].first.length() <= T) dp[t+q*word[i].first.length()] = max(dp[t+q*word[i].first.length()], dp[t]+q*word[i].second);\n\t  else break;\n\n  int res = 0;\n  for(int i = 0; i <= T; i++) res = max(res, dp[i]);\n  cout << res << endl;\n}\nint main(){\n  input();\n  find();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2519.cc: English\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int H = 4, W = 4;\nconst int MAX_T = 10000;\n\nconst int dxs[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst int dys[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\n/* typedef */\n\n/* global variables */\n\nstring words[MAX_N], flds[H];\nint scs[MAX_N], wns[MAX_N], dp[2][MAX_T + 1];\nbool used[H][W];\n\n/* subroutines */\n\nint rec(string &s, int k, int ux, int uy) {\n  int sn = s.size();\n  if (k >= sn - 1) return 1;\n\n  int cnt = 0;\n  used[uy][ux] = true;\n\n  for (int di = 0; di < 8; di++) {\n    int vx = ux + dxs[di], vy = uy + dys[di];\n    if (vx >= 0 && vx < W && vy >= 0 && vy < H &&\n\tflds[vy][vx] == s[k + 1] && ! used[vy][vx])\n      cnt += rec(s, k + 1, vx, vy);\n  }\n\n  used[uy][ux] = false;\n  return cnt;\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++) cin >> words[i] >> scs[i];\n  for (int i = 0; i < H; i++) cin >> flds[i];\n\n  int t;\n  cin >> t;\n\n  for (int i = 0; i < n; i++) {\n    string &wdi = words[i];\n    wns[i] = 0;\n    for (int y = 0; y < H; y++)\n      for (int x = 0; x < W; x++)\n\tif (flds[y][x] == wdi[0]) wns[i] += rec(wdi, 0, x, y);\n    //printf(\"wns[%d] = %d\\n\", i, wns[i]);\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[0][0] = 0;\n  int cur = 0, nxt = 1;\n\n  for (int i = 0; i < n; i++) {\n    int &wn = wns[i];\n    int &si = scs[i], s = si;\n    int wi = words[i].size(), w = wi;\n\n    memcpy(dp[nxt], dp[cur], sizeof(dp[0]));\n\n    for (int k = 0; k < wn && w <= t; k++, s += si, w += wi) {\n      int maxj = t - w;\n      for (int j = 0; j <= maxj; j++)\n\tif (dp[cur][j] >= 0) {\n\t  int d = dp[cur][j] + s;\n\t  if (dp[nxt][j + w] < d) dp[nxt][j + w] = d;\n\t}\n    }\n    cur ^= 1, nxt ^= 1;\n  }\n\n  int maxdp = 0;\n  for (int i = 0; i <= t; i++)\n    if (maxdp < dp[cur][i]) maxdp = dp[cur][i];\n  printf(\"%d\\n\", maxdp);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nstruct State { int x[4][4]; };\nchar F[4][4]; vector<pair<int, int>>v, w; string U[100]; int V[100], dp[10009];\nint solve(string S, int depth, int cx, int cy, State Y) {\n\tif (depth == S.size())return 1;\n\tint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\n\tint cnt = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ey < 0 || ex >= 4 || ey >= 4)continue;\n\t\tif (Y.x[ex][ey] == 0 && F[ex][ey] == S[depth]) {\n\t\t\tState Z = Y; Z.x[ex][ey] = 1;\n\t\t\tcnt += solve(S, depth + 1, ex, ey, Z);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) { cin >> U[i] >> V[i]; }\n\tfor (int i = 0; i < 16; i++)cin >> F[i / 4][i % 4];\n\tfor (int i = 0; i < n; i++) { \n\t\tint c = 0;\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (F[j / 4][j % 4] != U[i][0])continue;\n\t\t\tState R; for (int k = 0; k < 16; k++)R.x[k / 4][k % 4] = 0; R.x[j / 4][j % 4] = 1;\n\t\t\tc += solve(U[i], 1, j / 4, j % 4, R);\n\t\t}\n\t\tfor (int j = 0; j < c; j++)v.push_back(make_pair(V[i], U[i].size()));\n\t}\n\tint T; cin >> T; int maxn = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfor (int j = T; j >= v[i].second; j--) {\n\t\t\tdp[j] = max(dp[j], dp[j - v[i].second] + v[i].first); maxn = max(maxn, dp[j]);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    int max_score = 0;\n    dp[0] = 0;\n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      const string key = *it;\n\n      int cost = key.length();\n      int score = score_table[key];\n\n      for(int freq_idx=0,size=freq[key];\n\t  freq_idx < size;\n\t  freq_idx++){\n\n\tfor(int next_time=time_limit;next_time - cost>=0;next_time--){\n\t  int from_time = next_time - cost;\n\t  if(dp[from_time] == -1) continue;\n\t  dp[next_time] = max(dp[from_time] + score,\n\t\t\t      dp[next_time]);\n\t  max_score = max(dp[next_time],max_score);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {+0,+1,+1,+1,+0,-1,-1,-1};\nint ty[] = {-1,-1,+0,+1,+1,+1,+0,-1};\n\nmap<string,int> freq;\n\nvoid dfs(int x,int y,\n\t string str,\n\t int visited,\n\t char stage[4][4],\n\t const set<string>& keywords){\n  str += stage[y][x];\n  visited |= (1<<(4*y+x));\n  if(keywords.count(str) > 0){\n    freq[str]++;\n  }\n\n  if(__builtin_popcount((visited)) >= 8) return;\n\n  for(int i=0;i<8;i++){\n    int dx = x + tx[i];\n    int dy = y + ty[i];\n    if(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n    int idx = dy * 4 + dx;\n    if(visited & (1<<idx)) continue;\n    dfs(dx,dy,str,visited,stage,keywords);\n  }\n}\n\n\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    freq.clear();\n    char stage[4][4];\n\n    set<string> keywords;\n    vector<string> keywords_v;\n    map<string,int> score_table;\n    int dp[10001];\n\n    for(int i=0;i<N;i++){\n      string word;\n      int score;\n      cin >> word >> score;\n      score_table[word] = score;\n      keywords.insert(word);\n      keywords_v.push_back(word);\n    }\n    for(int y=0;y<4;y++){\n      string line;\n      cin >> line;\n      for(int x=0;x<4;x++){\n\tstage[y][x] = line[x];\n      }\n    }\n\n    int time_limit;\n    scanf(\"%d\",&time_limit);\n    memset(dp,-1,sizeof(dp));\n    for(int y=0;y<4;y++){\n      for(int x=0;x<4;x++){\n\tdfs(x,y,\"\",0,stage,keywords);\n      }\n    }\n\n    dp[0] = 0;\n    for(int key_idx=0;key_idx < keywords_v.size();key_idx++){\n      const string& key = keywords_v[key_idx];\n      int cost = key.length();\n      int score = score_table[key];\n\n      int scalar = 1;\n      int capacity = freq[key];\n      for(;\n\t  scalar <= capacity;\n\t  capacity -= scalar,scalar *= 2){\n\n\tfor(int next_time=time_limit;next_time - cost * scalar>=0;next_time--){\n\t  int from_time = next_time - cost * scalar;\n\t  if(dp[from_time] == -1) continue;\n\t  dp[next_time] = max(dp[from_time] + score * scalar,\n\t\t\t      dp[next_time]);\n\t}\n      }\n\n      if(capacity){\n\tfor(int next_time=time_limit;next_time - cost * capacity>=0;next_time--){\n\t  int from_time = next_time - cost * capacity;\n\t  if(dp[from_time] == -1) continue;\n\t  dp[next_time] = max(dp[from_time] + score * capacity,\n\t\t\t      dp[next_time]);\n\t}\n      }\n    }\n\n    int max_score = 0;\n    for(int time = time_limit; time >=0; time--){\n      max_score = max(dp[time],max_score);\n    }\n    printf(\"%d\\n\",max_score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, T, a[107], c[107], l[107], used[4][4], dp[10009]; string s[107], m[4];\nint rec(int x, int y, int d, int v) {\n\tif (d == l[v]) return 1;\n\tint ret = 0;\n\tfor (int i = -1; i <= 1; i++) {\n\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\tint tx = x + j, ty = y + i;\n\t\t\tif (0 <= tx && tx <= 3 && 0 <= ty && ty <= 3 && !used[ty][tx] && m[ty][tx] == s[v][d]) {\n\t\t\t\tused[ty][tx] = 1;\n\t\t\t\tret += rec(tx, ty, d + 1, v);\n\t\t\t\tused[ty][tx] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) cin >> s[i] >> a[i], l[i] = s[i].size();\n\tfor (int i = 0; i < 4; i++) cin >> m[i];\n\tcin >> T;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tif (m[j][k] == s[i][0]) {\n\t\t\t\t\tused[j][k] = 1;\n\t\t\t\t\tc[i] += rec(k, j, 1, i);\n\t\t\t\t\tused[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tint x = c[i];\n\t\tfor (int j = 1; x > 0; j <<= 1) {\n\t\t\tint mul = min(j, x);\n\t\t\tfor (int k = T; k >= l[i] * mul; k--) dp[k] = max(dp[k], dp[k - l[i] * mul] + a[i] * mul);\n\t\t\tx -= mul;\n\t\t}\n\t}\n\tcout << dp[T] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <array>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n\nconst int dx[]={1,1,1,0,0,-1,-1,-1};\nconst int dy[]={-1,0,1,-1,1,-1,0,1};\ninline bool in(int x, int y){ return 0<=x&&x<4&&0<=y&&y<4; }\nint n;\nchar board[4][5];\nint v[100],w[100],c[100]={};\nstring word[100];\nbool used[4][4]={};\nint dp[10001]={};\n\nvoid dfs(int i,int x,int y,int si){\n    const string& s=word[si];\n    if(i==(int)s.size()-1){\n        c[si]++;\n    } else {\n        used[y][x]=1;\n        rep(d,8){\n            int nx=x+dx[d], ny=y+dy[d];\n            if(in(nx,ny) && s[i+1]==board[ny][nx] && !used[ny][nx])\n                dfs(i+1,nx,ny,si);\n        }\n        used[y][x]=0;\n    }\n}\n\nint main(){\n    cin>>n;\n    rep(i,n){\n        cin>>word[i];\n        cin>>v[i];\n        w[i]=word[i].size();\n    }\n    rep(i,4) cin>>board[i];\n    rep(si,n)rep(y,4)rep(x,4){\n        if(word[si][0]==board[y][x]) dfs(0,x,y,si);\n    }\n    int sum;cin>>sum;\n    rep(i,n){\n        if(c[i]==0) continue;\n        for(int j=sum; j>=0; j--){\n            for(int k=1; k<=c[i] && j-w[i]*k>=0; k++){\n                dp[j]=max(dp[j],dp[j-w[i]*k]+v[i]*k);\n            }\n        }\n    }\n    cout<<dp[sum]<<endl;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2519\n  Title:Eglish\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define myabs(x) (((x)>0)?(x):(-(x)))\nint N,T;\nchar word[100][9];\nchar length[100];\nint score[100];\nint  hist[100];\nchar line[4][4];\nchar alpha_pos[26][16][2];\nchar count[26];\nint dp[10001];\nint dp2[10001];\n\nint search_word2(char word[],int y,int x,int len,short flag)\n{\n  int i,x1,y1,ret;\n  char c;\n\n  //printf(\"[%s] %d %d [%d]\\n\",word,y,x,len);\n\n  if(flag & (1<<(4*y+x)))\n    return(0);\n  if(len==0)\n    return(1);\n  flag |= 1<<(4*y+x);\n\n  c=word[0]-'A';\n  for(i=ret=0;i<count[c];i++)\n    {\n      y1=alpha_pos[c][i][0];\n      x1=alpha_pos[c][i][1];\n      if(myabs(x1-x)<2 && myabs(y1-y)<2 && !(x==x1 && y==y1))\n\tret+=search_word2(word+1,y1,x1,len-1,flag);\n    }\n  return(ret);\n}\n\nint search_word(char word[],int len)\n{\n  int i,x,y,ret;\n  short flag=0;\n  char c;\n\n  c=word[0]-'A';\n  for(i=ret=0;i<count[c];i++)\n    {\n      y=alpha_pos[c][i][0];\n      x=alpha_pos[c][i][1];\n      //printf(\"[%s][%d] %d %d\",word,i,y,x);\n      ret+=search_word2(word+1,y,x,len-1,flag);\n    }\n  return(ret);\n}\n\n\nvoid search_word_all()\n{\n  int i,len;\n  char *p;\n  \n\n  for(i=0;i<N;i++)\n    {\n      p=&word[i][0];\n      len=strlen(p);\n      hist[i]=search_word(p,len);\n    }\n}\n\ndump()\n{\n  int i,j;\n  for(i=0;i<26;i++)\n    if(count[i])\n    {\n      printf(\"%c|\",i+'A');\n      for(j=0;j<count[i];j++)\n\tprintf(\"%d %d|\",alpha_pos[i][j][0],alpha_pos[i][j][1]);\n      printf(\"\\n\");\n    }\n}\ndump2()\n{\n  int i;\n\n  for(i=0;i<N;i++)\n    printf(\"%d) %s [%d] %d\\n\",i,&word[i][0],length[i],hist[i]);\n}\nsolve()\n{\n  int i,j,k,pos,ret;\n  \n  for(i=0;i<N;i++)\n    {\n      memcpy(dp2,dp,sizeof(int)*(1+T));\n      for(j=0;j<=T;j++)\n\tif(j==0||dp2[j])\n\t  for(k=1;k<=hist[i];k++)\n\t    {\n\t      pos=j+k*length[i];\n\t      if(pos>T)\n\t\tbreak;\n\t      dp[pos] = max(dp[pos],dp2[j]+k*score[i]);\n\t    }\n    }\n  for(i=T,ret=0;i>=1;i--)\n    ret=max(ret,dp[i]);\n  return(ret);\n}\nmain()\n{\n  int i,j,ret;\n  char c;\n\n  scanf(\"%d\",&N);\n\n  for(i=0;i<N;i++)\n    {\n      scanf(\"%s %d\",&word[i][0],&score[i]);\n      length[i]=strlen(&word[i][0]);\n    }\n  for(i=0;i<4;i++)\n    {\n      scanf(\"%s\",&line[i][0]);\n      for(j=0;j<4;j++)\n\t{\n\t  c=line[i][j]-'A';\n\t  alpha_pos[c][count[c]][0]=i;\n\t  alpha_pos[c][count[c]][1]=j;\n\t  count[c]++;\n\t}\n    }\n  //dump();\n  //printf(\"%d\\n\",search_word(\"abcd\",4));\n  scanf(\"%d\",&T);\n  search_word_all();\n  //dump2();\n  ret=solve();\n  printf(\"%d\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static final int SIZE = 4;\n\tpublic static final int LEN  = 8;\n\t\n\tpublic static boolean is_ok(int x, int y){\n\t\tif(x < 0 || y < 0 || x >= SIZE || y >= SIZE){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class Trie {\n\t\tint score;\n\t\tTrie[] next;\n\t\t\n\t\tprivate Trie(){\n\t\t\tthis.score = -1;\n\t\t\tnext = new Trie[26];\n\t\t}\n\t\t\n\t\tpublic void register_word(int deep, char[] word, int score){\n\t\t\tif(word.length == deep){\n\t\t\t\tthis.score = score;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tfinal int index = word[deep] - 'A';\n\t\t\t\t\n\t\t\t\tif(next[index] == null){\n\t\t\t\t\tnext[index] = new Trie();\n\t\t\t\t}\n\t\t\t\tnext[index].register_word(deep + 1, word, score);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void register(Trie root, String word, int score){\n\t\t\troot.register_word(0, word.toCharArray(), score);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\tif(score >= 0){\n\t\t\t\tsb.append(score + \" \");\n\t\t\t}\n\t\t\t\n\t\t\tfor(int index = 0; index < 26; index++){\n\t\t\t\tif(next[index] == null){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tsb.append(\"[ \" + (char)(index + 'A') + \" : \" + next[index].toString() + \" ], \");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}\n\t\t\n\t\tpublic boolean hasNext(char c){\n\t\t\treturn next[(int)(c - 'A')] != null;\n\t\t}\n\t\t\n\t\tpublic boolean isWord(){\n\t\t\treturn score >= 0;\n\t\t}\n\t\t\n\t\tpublic Trie getNext(char c){\n\t\t\treturn next[(int)(c - 'A')];\n\t\t}\n\t}\n\t\n\tpublic static void dfs(final int x, final int y, int bit, char[][] inputs, Trie dict, ArrayList<Integer> times, ArrayList<Integer> scores){\n\t\tfinal int addr = y * SIZE + x;\n\t\tif(!is_ok(x, y)){\n\t\t\treturn;\n\t\t}else if((bit & (1 << addr)) != 0){\n\t\t\treturn;\n\t\t}else if(!dict.hasNext(inputs[y][x])){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdict = dict.getNext(inputs[y][x]);\n\t\tbit |= 1 << addr;\n\t\t\n\t\t//System.out.println(bit);\n\t\t\n\t\tif(dict.isWord()){\n\t\t\ttimes.add(Integer.bitCount(bit));\n\t\t\tscores.add(dict.score);\n\t\t\t//benefit[bit] = Math.max(benefit[bit], dict.score);\n\t\t}\n\t\t\n\t\t//System.out.println(y + \" \"  + x);\n\t\t\n\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\tif(dx == 0 && dy == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int nx = x + dx;\n\t\t\t\tfinal int ny = y + dy;\n\t\t\t\t\n\t\t\t\tdfs(nx, ny, bit, inputs, dict, times, scores);\n\t\t\t}\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tTrie dict = new Trie();\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tfinal String word = sc.next();\n    \t\tfinal int score = sc.nextInt();\n    \t\t\n    \t\tTrie.register(dict, word, score);\n    \t\t\n    \t\t//System.out.println(word);\n    \t\t//System.out.println(dict);\n    \t}\n    \t//System.out.println(dict);\n    \t\n    \tchar[][] inputs = new char[SIZE][SIZE];\n    \tfor(int i = 0; i < SIZE; i++){\n    \t\tinputs[i] = sc.next().toCharArray();\n    \t\t//System.out.println(i);\n    \t}\n    \t\n    \tfinal int T = sc.nextInt();\n    \t\n    \t/*\n    \tfinal int MAX_BIT = 1 << (SIZE * SIZE);\n    \tint[] benefits = new int[MAX_BIT];\n    \tArrays.fill(benefits, -1);\n    \t*/\n    \t\n    \tArrayList<Integer> times  = new ArrayList<Integer>();\n    \tArrayList<Integer> scores = new ArrayList<Integer>();\n    \tfor(int y = 0; y < SIZE; y++){\n    \t\tfor(int x = 0; x < SIZE; x++){\n    \t\t\tdfs(x, y, 0, inputs, dict, times, scores);\n    \t\t}\n    \t}\n    \t\n    \t//System.out.println(times + \" \" + scores);\n    \t\n    \t/*\n    \t//System.out.println(count);\n    \tint[] bits   = new int[count];\n    \tint[] scores = new int[count];\n    \tint cur = 0;\n    \tfor(int bit = 0; bit < MAX_BIT; bit++){\n    \t\tif(benefits[bit] >= 0){\n    \t\t\tbits[cur]   = bit;\n    \t\t\tscores[cur] = benefits[bit];\n    \t\t\tcur++;\n    \t\t}\n    \t}\n    \t*/\n    \t//System.out.println(Arrays.toString(scores));\n    \t\n    \tint[] DP_score = new int[T + 1];\n    \tArrays.fill(DP_score, -1);\n    \tDP_score[0] = 0;\n    \t\n    \tint max = 0;\n    \tfor(int index = 0; index < scores.size(); index++){\n    \t\tfor(int time = T; time >= 0; time--){\n    \t\t\tif(DP_score[time] < 0){\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\tfinal int next_score = DP_score[time] + scores.get(index);\n    \t\t\tfinal int next_time  = time + times.get(index);\n    \t\t\t\n    \t\t\tif(next_time > T){\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(DP_score[next_time] < next_score){\n    \t\t\t\tDP_score[next_time] = next_score;\n    \t\t\t\tmax = Math.max(max, DP_score[next_time]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \t\n    \tSystem.out.println(max);\n    \t\n    \t//System.out.println(Arrays.toString(benefit));\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 1, 1, 0, -1, -1, -1, 0 };\n\tstatic int[] DC = { -1, 0, 1, 1, 1, 0, -1, -1 };\n\tstatic char[][] f;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tString[] dic = new String[N];\n\t\tint[] v = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdic[i] = sc.next();\n\t\t\tv[i] = sc.nextInt();\n\t\t}\n\t\tf = new char[4][];\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tf[i] = sc.next().toCharArray();\n\t\t}\n\t\tArrayList<ArrayList<Integer>> score = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i <= 8; ++i) {\n\t\t\tscore.add(new ArrayList<Integer>());\n\t\t}\n\t\tboolean[][] visited = new boolean[4][4];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tif (f[j][k] == dic[i].charAt(0)) {\n\t\t\t\t\t\tint c = find(dic[i], 0, j, k, visited);\n\t\t\t\t\t\tfor (int l = 0; l < c; ++l) {\n\t\t\t\t\t\t\tscore.get(dic[i].length()).add(v[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint T = sc.nextInt();\n\t\tint[] dp = new int[T + 1];\n\t\tArrays.fill(dp, -1);\n\t\tdp[T] = 0;\n\t\tfor (int i = 1; i < score.size(); ++i) {\n\t\t\tfor (int j : score.get(i)) {\n\t\t\t\tfor (int k = 0; k + i <= T; ++k) {\n\t\t\t\t\tif (dp[k + i] < 0) continue;\n\t\t\t\t\tdp[k] = Math.max(dp[k], dp[k + i] + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i <= T; ++i) {\n\t\t\tans = Math.max(ans, dp[i]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int find(String word, int p, int r, int c, boolean[][] visited) {\n\t\tif (p == word.length() - 1) return 1;\n\t\tvisited[r][c] = true;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tint nr = r + DR[i];\n\t\t\tint nc = c + DC[i];\n\t\t\tif (nr < 0 || 3 < nr || nc < 0 || 3 < nc) continue;\n\t\t\tif (visited[nr][nc]) continue;\n\t\t\tif (f[nr][nc] != word.charAt(p + 1)) continue;\n\t\t\tret += find(word, p + 1, nr, nc, visited);\n\t\t}\n\t\tvisited[r][c] = false;\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static final int SIZE = 4;\n\tpublic static final int LEN  = 8;\n\t\n\tpublic static boolean is_ok(int x, int y){\n\t\tif(x < 0 || y < 0 || x >= SIZE || y >= SIZE){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class Trie {\n\t\tint score;\n\t\tTrie[] next;\n\t\tint id;\n\t\t\n\t\tprivate Trie(){\n\t\t\tthis.score = -1;\n\t\t\tnext = new Trie[26];\n\t\t}\n\t\t\n\t\tpublic void register_word(int deep, int id, char[] word_ch, int score){\n\t\t\tif(word_ch.length == deep){\n\t\t\t\tthis.score = score;\n\t\t\t\tthis.id = id;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tfinal int index = word_ch[deep] - 'A';\n\t\t\t\t\n\t\t\t\tif(next[index] == null){\n\t\t\t\t\tnext[index] = new Trie();\n\t\t\t\t}\n\t\t\t\tnext[index].register_word(deep + 1, id, word_ch, score);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void register(Trie root, int id, String word, int score){\n\t\t\troot.register_word(0, id, word.toCharArray(), score);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\tif(score >= 0){\n\t\t\t\tsb.append(score + \" \");\n\t\t\t}\n\t\t\t\n\t\t\tfor(int index = 0; index < 26; index++){\n\t\t\t\tif(next[index] == null){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tsb.append(\"[ \" + (char)(index + 'A') + \" : \" + next[index].toString() + \" ], \");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}\n\t\t\n\t\tpublic boolean hasNext(char c){\n\t\t\treturn next[(int)(c - 'A')] != null;\n\t\t}\n\t\t\n\t\tpublic boolean isWord(){\n\t\t\treturn score >= 0;\n\t\t}\n\t\t\n\t\tpublic Trie getNext(char c){\n\t\t\treturn next[(int)(c - 'A')];\n\t\t}\n\t}\n\t\n\tpublic static void dfs(final int x, final int y, int bit, char[][] inputs, Trie dict, int[] counts){\n\t\t//System.out.println(bit);\n\t\t//System.out.println(dict);\n\t\tif(dict.isWord()){\n\t\t\tcounts[dict.id]++;\n\t\t\t//benefit[bit] = Math.max(benefit[bit], dict.score);\n\t\t}\n\t\t\n\t\t//System.out.println(y + \" \"  + x);\n\t\t\n\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\tif(dx == 0 && dy == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int nx = x + dx;\n\t\t\t\tfinal int ny = y + dy;\n\t\t\t\t\n\t\t\t\tfinal int next_addr = ny * SIZE + nx;\n\t\t\t\tif(!is_ok(nx, ny)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if((bit & (1 << next_addr)) != 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(!dict.hasNext(inputs[ny][nx])){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdfs(nx, ny, bit | (1 << next_addr), inputs, dict.getNext(inputs[ny][nx]), counts);\n\t\t\t}\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tTrie dict = new Trie();\n    \t\n    \tint[] times  = new int[N];\n    \tint[] scores = new int[N];\n    \tint[] counts = new int[N];\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tfinal String word = sc.next();\n    \t\tfinal int score = sc.nextInt();\n    \t\t\n    \t\ttimes[i] = word.length();\n    \t\tscores[i] = score;\n    \t\tTrie.register(dict, i, word, score);\n    \t\t\n    \t\t//System.out.println(word);\n    \t\t//System.out.println(dict);\n    \t}\n    \t//System.out.println(dict);\n    \t\n    \tchar[][] inputs = new char[SIZE][SIZE];\n    \tfor(int i = 0; i < SIZE; i++){\n    \t\tinputs[i] = sc.next().toCharArray();\n    \t\t//System.out.println(i);\n    \t}\n    \t\n    \tfinal int T = sc.nextInt();\n    \t\n    \t/*\n    \tfinal int MAX_BIT = 1 << (SIZE * SIZE);\n    \tint[] benefits = new int[MAX_BIT];\n    \tArrays.fill(benefits, -1);\n    \t*/\n    \t//System.out.println(\"T\");\n    \t\n    \tfor(int y = 0; y < SIZE; y++){\n    \t\tfor(int x = 0; x < SIZE; x++){\n    \t\t\tif(!dict.hasNext(inputs[y][x])){\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\t//System.out.println(x + \" : \" + y);\n    \t\t\tfinal int addr = y * SIZE + x;\n    \t\t\tdfs(x, y, 1 << addr, inputs, dict.getNext(inputs[y][x]), counts);\n    \t\t\t//System.out.println(x + \" : \" + y);\n    \t\t}\n    \t}\n    \t//System.out.println(\"B\");\n    \t\n    \t//System.err.println(times + \" \" + scores);\n    \t\n    \t//System.out.println(scores);\n    \t\n    \tint[] DP = new int[T + 1];\n    \tArrays.fill(DP, -1);\n    \tDP[0] = 0;\n    \t\n    \tint max = 0;\n    \tfor(int index = 0; index < counts.length; index++){\n    \t\tif(counts[index] == 0){\n    \t\t\tcontinue;\n    \t\t}\n    \t\t//System.out.println(counts[index]);\n    \t\t\n    \t\tfor(int exp = 1; counts[index] > 0; exp *= 2){\n    \t\t\tfinal int mul = Math.min(exp, counts[index]);\n    \t\t\t\n    \t\t\tfor(int time = T; time >= 0; time--){\n    \t\t\t\tif(DP[time] < 0){\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}\n    \t\t\t\n    \t\t\t\tfinal int next_score = DP[time] + (scores[index] * mul);\n    \t\t\t\tfinal int next_time  = time + (times[index] * mul);\n    \t\t\t\n    \t\t\t\tif(next_time > T){\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}\n    \t\t\t\n    \t\t\t\tif(DP[next_time] < next_score){\n    \t\t\t\t\tDP[next_time] = next_score;\n    \t\t\t\t\tmax = Math.max(max, DP[next_time]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tcounts[index] -= mul;\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(max);\n    \t\n    \t//System.out.println(Arrays.toString(DP));\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 1, 1, 0, -1, -1, -1, 0 };\n\tstatic int[] DC = { -1, 0, 1, 1, 1, 0, -1, -1 };\n\tstatic char[][] f;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tString[] dic = new String[N];\n\t\tint[] v = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdic[i] = sc.next();\n\t\t\tv[i] = sc.nextInt();\n\t\t}\n\t\tf = new char[4][];\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tf[i] = sc.next().toCharArray();\n\t\t}\n\t\tint[][] count = new int[9][101];\n\t\tboolean[][] visited = new boolean[4][4];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tif (f[j][k] == dic[i].charAt(0)) {\n\t\t\t\t\t\tcount[dic[i].length()][v[i]] += find(dic[i], 0, j, k, visited);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint T = sc.nextInt();\n\t\tint[] dp = new int[T + 1];\n\t\tArrays.fill(dp, -1);\n\t\tdp[T] = 0;\n\t\tfor (int i = 1; i <= 8; ++i) {\n\t\t\tfor (int j = 1; j <= 100; ++j) {\n\t\t\t\tif (count[i][j] == 0) continue;\n\t\t\t\tfor (int k = 0; k <= T; ++k) {\n\t\t\t\t\tif (dp[k] < 0) continue;\n\t\t\t\t\tint n = k - i;\n\t\t\t\t\tfor (int l = 1; l <= count[i][j] && n >= 0; ++l, n -= i) {\n\t\t\t\t\t\tdp[n] = Math.max(dp[n], dp[k] + l * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i <= T; ++i) {\n\t\t\tans = Math.max(ans, dp[i]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int find(String word, int p, int r, int c, boolean[][] visited) {\n\t\tif (p == word.length() - 1) return 1;\n\t\tvisited[r][c] = true;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tint nr = r + DR[i];\n\t\t\tint nc = c + DC[i];\n\t\t\tif (nr < 0 || 3 < nr || nc < 0 || 3 < nc) continue;\n\t\t\tif (visited[nr][nc]) continue;\n\t\t\tif (f[nr][nc] != word.charAt(p + 1)) continue;\n\t\t\tret += find(word, p + 1, nr, nc, visited);\n\t\t}\n\t\tvisited[r][c] = false;\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// English\n// 2013/09/21\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint n;\n\tString[] words;\n\tint[] scores;\n\tint m=4;\n\tchar[][] cs;\n\tint maxT;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\twords=new String[n];\n\t\tscores=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\twords[i]=sc.next();\n\t\t\tscores[i]=sc.nextInt();\n\t\t}\n\t\tcs=new char[m][];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcs[i]=sc.next().toCharArray();\n\t\t}\n\t\tmaxT=sc.nextInt();\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tvisited=new boolean[m][m];\n\t\tlong[] dp=new long[maxT+1];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tint num=0;\n\t\t\tfor(int y=0; y<m; y++){\n\t\t\t\tfor(int x=0; x<m; x++){\n\t\t\t\t\tnum+=dfs(x, y, words[j], 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint weight=words[j].length(), value=scores[j];\n\t\t\tfor(int k=1; num>0; k<<=1){\n\t\t\t\tint mul=min(k, num);\n\t\t\t\tfor(int i=maxT; i-weight*mul>=0; i--){\n\t\t\t\t\tdp[i]=max(dp[i], dp[i-weight*mul]+value*mul);\n\t\t\t\t}\n\t\t\t\tnum-=mul;\n\t\t\t}\n\t\t}\n\t\tprintln(dp[maxT]+\"\");\n\t}\n\n\tboolean[][] visited;\n\n\tint dfs(int x, int y, String word, int at){\n\t\tif(x<0||x>=m||y<0||y>=m||cs[y][x]!=word.charAt(at)||visited[y][x]){\n\t\t\treturn 0;\n\t\t}\n\t\tif(at==word.length()-1){\n\t\t\treturn 1;\n\t\t}\n\t\tvisited[y][x]=true;\n\t\tint sum=0;\n\t\tfor(int i=-1; i<=1; i++){\n\t\t\tfor(int j=-1; j<=1; j++){\n\t\t\t\tsum+=dfs(x+i, y+j, word, at+1);\n\t\t\t}\n\t\t}\n\t\tvisited[y][x]=false;\n\t\treturn sum;\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 1, 1, 0, -1, -1, -1, 0 };\n\tstatic int[] DC = { -1, 0, 1, 1, 1, 0, -1, -1 };\n\tstatic char[][] f;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tString[] dic = new String[N];\n\t\tint[] v = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdic[i] = sc.next();\n\t\t\tv[i] = sc.nextInt();\n\t\t}\n\t\tf = new char[4][];\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tf[i] = sc.next().toCharArray();\n\t\t}\n\t\tArrayList<ArrayList<Integer>> score = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i <= 8; ++i) {\n\t\t\tscore.add(new ArrayList<Integer>());\n\t\t}\n\t\tboolean[][] visited = new boolean[4][4];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tif (f[j][k] == dic[i].charAt(0)) {\n\t\t\t\t\t\tint c = find(dic[i], 0, j, k, visited);\n\t\t\t\t\t\tfor (int l = 0; l < c; ++l) {\n\t\t\t\t\t\t\tscore.get(dic[i].length()).add(v[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint T = sc.nextInt();\n\t\tint[] dp = new int[T + 1];\n\t\tArrays.fill(dp, -1);\n\t\tdp[T] = 0;\n\t\tfor (int i = 1; i < score.size(); ++i) {\n\t\t\tfor (int j : score.get(i)) {\n\t\t\t\tfor (int k = 0; k + i <= T; ++k) {\n\t\t\t\t\tif (dp[k + i] < 0) continue;\n\t\t\t\t\tdp[k] = Math.max(dp[k], dp[k + i] + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i <= T; ++i) {\n\t\t\tans = Math.max(ans, dp[i]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int find(String word, int p, int r, int c, boolean[][] visited) {\n\t\tif (p == word.length() - 1) return 1;\n\t\tvisited[r][c] = true;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tint nr = r + DR[i];\n\t\t\tint nc = c + DC[i];\n\t\t\tif (nr < 0 || 3 < nr || nc < 0 || 3 < nc) continue;\n\t\t\tif (f[nr][nc] != word.charAt(p + 1)) continue;\n\t\t\tret += find(word, p + 1, nr, nc, visited);\n\t\t}\n\t\tvisited[r][c] = false;\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static final int SIZE = 4;\n\tpublic static final int LEN  = 8;\n\t\n\tpublic static boolean is_ok(int x, int y){\n\t\tif(x < 0 || y < 0 || x >= SIZE || y >= SIZE){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class Trie {\n\t\tint score;\n\t\tTrie[] next;\n\t\t\n\t\tprivate Trie(){\n\t\t\tthis.score = -1;\n\t\t\tnext = new Trie[26];\n\t\t}\n\t\t\n\t\tpublic void register_word(int deep, char[] word, int score){\n\t\t\tif(word.length == deep){\n\t\t\t\tthis.score = score;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tfinal int index = word[deep] - 'A';\n\t\t\t\t\n\t\t\t\tif(next[index] == null){\n\t\t\t\t\tnext[index] = new Trie();\n\t\t\t\t}\n\t\t\t\tnext[index].register_word(deep + 1, word, score);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void register(Trie root, String word, int score){\n\t\t\troot.register_word(0, word.toCharArray(), score);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\tif(score >= 0){\n\t\t\t\tsb.append(score + \" \");\n\t\t\t}\n\t\t\t\n\t\t\tfor(int index = 0; index < 26; index++){\n\t\t\t\tif(next[index] == null){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tsb.append(\"[ \" + (char)(index + 'A') + \" : \" + next[index].toString() + \" ], \");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}\n\t\t\n\t\tpublic boolean hasNext(char c){\n\t\t\treturn next[(int)(c - 'A')] != null;\n\t\t}\n\t\t\n\t\tpublic boolean isWord(){\n\t\t\treturn score >= 0;\n\t\t}\n\t\t\n\t\tpublic Trie getNext(char c){\n\t\t\treturn next[(int)(c - 'A')];\n\t\t}\n\t}\n\t\n\tpublic static void dfs(final int x, final int y, int bit, char[][] inputs, Trie dict, ArrayList<Integer> times, ArrayList<Integer> scores){\n\t\t//System.out.println(bit);\n\t\t//System.out.println(dict);\n\t\tif(dict.isWord()){\n\t\t\ttimes.add(Integer.bitCount(bit));\n\t\t\tscores.add(dict.score);\n\t\t\t//benefit[bit] = Math.max(benefit[bit], dict.score);\n\t\t}\n\t\t\n\t\t//System.out.println(y + \" \"  + x);\n\t\t\n\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\tif(dx == 0 && dy == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int nx = x + dx;\n\t\t\t\tfinal int ny = y + dy;\n\t\t\t\t\n\t\t\t\tfinal int next_addr = ny * SIZE + nx;\n\t\t\t\tif(!is_ok(nx, ny)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if((bit & (1 << next_addr)) != 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(!dict.hasNext(inputs[ny][nx])){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdfs(nx, ny, bit | (1 << next_addr), inputs, dict.getNext(inputs[ny][nx]), times, scores);\n\t\t\t}\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tTrie dict = new Trie();\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tfinal String word = sc.next();\n    \t\tfinal int score = sc.nextInt();\n    \t\t\n    \t\tTrie.register(dict, word, score);\n    \t\t\n    \t\t//System.out.println(word);\n    \t\t//System.out.println(dict);\n    \t}\n    \t//System.out.println(dict);\n    \t\n    \tchar[][] inputs = new char[SIZE][SIZE];\n    \tfor(int i = 0; i < SIZE; i++){\n    \t\tinputs[i] = sc.next().toCharArray();\n    \t\t//System.out.println(i);\n    \t}\n    \t\n    \tfinal int T = sc.nextInt();\n    \t\n    \t/*\n    \tfinal int MAX_BIT = 1 << (SIZE * SIZE);\n    \tint[] benefits = new int[MAX_BIT];\n    \tArrays.fill(benefits, -1);\n    \t*/\n    \t//System.out.println(\"T\");\n    \tArrayList<Integer> times  = new ArrayList<Integer>();\n    \tArrayList<Integer> scores = new ArrayList<Integer>();\n    \tfor(int y = 0; y < SIZE; y++){\n    \t\tfor(int x = 0; x < SIZE; x++){\n    \t\t\tif(!dict.hasNext(inputs[y][x])){\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\t//System.out.println(x + \" : \" + y);\n    \t\t\tfinal int addr = y * SIZE + x;\n    \t\t\tdfs(x, y, 1 << addr, inputs, dict.getNext(inputs[y][x]), times, scores);\n    \t\t\t//System.out.println(x + \" : \" + y);\n    \t\t}\n    \t}\n    \t//System.out.println(\"B\");\n    \t\n    \t//System.err.println(times + \" \" + scores);\n    \t\n    \t//System.out.println(scores);\n    \t\n    \tint[] DP_score = new int[T + 1];\n    \tArrays.fill(DP_score, -1);\n    \tDP_score[0] = 0;\n    \t\n    \tint max = 0;\n    \tfor(int index = 0; index < scores.size(); index++){\n    \t\tfor(int time = T; time >= 0; time--){\n    \t\t\tif(DP_score[time] < 0){\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\tfinal int next_score = DP_score[time] + scores.get(index);\n    \t\t\tfinal int next_time  = time + times.get(index);\n    \t\t\t\n    \t\t\tif(next_time > T){\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(DP_score[next_time] < next_score){\n    \t\t\t\tDP_score[next_time] = next_score;\n    \t\t\t\tmax = Math.max(max, DP_score[next_time]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(max);\n    \t\n    \t//System.out.println(Arrays.toString(benefit));\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static final int SIZE = 4;\n\tpublic static final int LEN  = 8;\n\t\n\tpublic static boolean is_ok(int x, int y){\n\t\tif(x < 0 || y < 0 || x >= SIZE || y >= SIZE){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class Trie {\n\t\tint score;\n\t\tTrie[] next;\n\t\t\n\t\tprivate Trie(){\n\t\t\tthis.score = -1;\n\t\t\tnext = new Trie[26];\n\t\t}\n\t\t\n\t\tpublic void register_word(int deep, char[] word, int score){\n\t\t\tif(word.length == deep){\n\t\t\t\tthis.score = score;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tfinal int index = word[deep] - 'A';\n\t\t\t\t\n\t\t\t\tif(next[index] == null){\n\t\t\t\t\tnext[index] = new Trie();\n\t\t\t\t}\n\t\t\t\tnext[index].register_word(deep + 1, word, score);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void register(Trie root, String word, int score){\n\t\t\troot.register_word(0, word.toCharArray(), score);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\tif(score >= 0){\n\t\t\t\tsb.append(score + \" \");\n\t\t\t}\n\t\t\t\n\t\t\tfor(int index = 0; index < 26; index++){\n\t\t\t\tif(next[index] == null){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tsb.append(\"[ \" + (char)(index + 'A') + \" : \" + next[index].toString() + \" ], \");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}\n\t\t\n\t\tpublic boolean hasNext(char c){\n\t\t\treturn next[(int)(c - 'A')] != null;\n\t\t}\n\t\t\n\t\tpublic boolean isWord(){\n\t\t\treturn score >= 0;\n\t\t}\n\t\t\n\t\tpublic Trie getNext(char c){\n\t\t\treturn next[(int)(c - 'A')];\n\t\t}\n\t}\n\t\n\tpublic static void dfs(final int x, final int y, int bit, char[][] inputs, Trie dict, ArrayList<Integer> times, ArrayList<Integer> scores){\n\t\tfinal int addr = y * SIZE + x;\n\t\tif(!is_ok(x, y)){\n\t\t\treturn;\n\t\t}else if((bit & (1 << addr)) != 0){\n\t\t\treturn;\n\t\t}else if(!dict.hasNext(inputs[y][x])){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdict = dict.getNext(inputs[y][x]);\n\t\tbit |= 1 << addr;\n\t\t\n\t\t//System.out.println(bit);\n\t\t\n\t\tif(dict.isWord()){\n\t\t\ttimes.add(Integer.bitCount(bit));\n\t\t\tscores.add(dict.score);\n\t\t\t//benefit[bit] = Math.max(benefit[bit], dict.score);\n\t\t}\n\t\t\n\t\t//System.out.println(y + \" \"  + x);\n\t\t\n\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\tif(dx == 0 && dy == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int nx = x + dx;\n\t\t\t\tfinal int ny = y + dy;\n\t\t\t\t\n\t\t\t\tdfs(nx, ny, bit, inputs, dict, times, scores);\n\t\t\t}\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tTrie dict = new Trie();\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tfinal String word = sc.next();\n    \t\tfinal int score = sc.nextInt();\n    \t\t\n    \t\tTrie.register(dict, word, score);\n    \t\t\n    \t\t//System.out.println(word);\n    \t\t//System.out.println(dict);\n    \t}\n    \t//System.out.println(dict);\n    \t\n    \tchar[][] inputs = new char[SIZE][SIZE];\n    \tfor(int i = 0; i < SIZE; i++){\n    \t\tinputs[i] = sc.next().toCharArray();\n    \t\t//System.out.println(i);\n    \t}\n    \t\n    \tfinal int T = sc.nextInt();\n    \t\n    \t/*\n    \tfinal int MAX_BIT = 1 << (SIZE * SIZE);\n    \tint[] benefits = new int[MAX_BIT];\n    \tArrays.fill(benefits, -1);\n    \t*/\n    \t\n    \tArrayList<Integer> times  = new ArrayList<Integer>();\n    \tArrayList<Integer> scores = new ArrayList<Integer>();\n    \tfor(int y = 0; y < SIZE; y++){\n    \t\tfor(int x = 0; x < SIZE; x++){\n    \t\t\tdfs(x, y, 0, inputs, dict, times, scores);\n    \t\t}\n    \t}\n    \t\n    \tSystem.err.println(times.size() + \" \" + scores.size());\n    \t\n    \t/*\n    \t//System.out.println(count);\n    \tint[] bits   = new int[count];\n    \tint[] scores = new int[count];\n    \tint cur = 0;\n    \tfor(int bit = 0; bit < MAX_BIT; bit++){\n    \t\tif(benefits[bit] >= 0){\n    \t\t\tbits[cur]   = bit;\n    \t\t\tscores[cur] = benefits[bit];\n    \t\t\tcur++;\n    \t\t}\n    \t}\n    \t*/\n    \t//System.out.println(Arrays.toString(scores));\n    \t\n    \tint[] DP_score = new int[T + 1];\n    \tArrays.fill(DP_score, -1);\n    \tDP_score[0] = 0;\n    \t\n    \tint max = 0;\n    \tfor(int index = 0; index < scores.size(); index++){\n    \t\tfor(int time = T; time >= 0; time--){\n    \t\t\tif(DP_score[time] < 0){\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\tfinal int next_score = DP_score[time] + scores.get(index);\n    \t\t\tfinal int next_time  = time + times.get(index);\n    \t\t\t\n    \t\t\tif(next_time > T){\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(DP_score[next_time] < next_score){\n    \t\t\t\tDP_score[next_time] = next_score;\n    \t\t\t\tmax = Math.max(max, DP_score[next_time]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \t\n    \tSystem.out.println(max);\n    \t\n    \t//System.out.println(Arrays.toString(benefit));\n    \t\n    }\n     \n}"
  },
  {
    "language": "Python",
    "code": "def main():\n  n = int(input())\n  lst = []\n  for _ in range(n):\n    word, score = input().split()\n    lst.append((word, int(score)))\n  mp = [\"#\" * 6] + [\"#\" + input() + \"#\" for _ in range(4)] + [\"#\" * 6]\n  t = int(input())\n  \n  def search(word):\n    used = [[False] * 6 for _ in range(6)]\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1))\n    \n    def _search(word, pos, x, y):\n      if pos == len(word) - 1:return 1\n      used[y][x] = True\n      ret = 0\n      for dx, dy in vec:\n        nx, ny = x + dx, y + dy\n        if not used[ny][nx] and mp[ny][nx] == word[pos + 1]:\n          ret += _search(word, pos + 1, nx, ny)\n      used[y][x] = False\n      return ret\n    \n    ret = 0\n    for y in range(1, 5):\n      for x in range(1, 5):\n        if mp[y][x] == word[0]:ret += _search(word, 0, x, y)  \n    return ret\n  \n  items = []\n  for word, score in lst:\n    cnt = search(word)\n    acc = 1\n    weight = len(word)\n    while cnt >= acc:\n      cnt -= acc\n      items.append((score * acc, weight * acc))\n      acc *= 2\n    if cnt:\n      items.append((score * cnt, weight * cnt))\n  \n  dp = [0] * (t + 1)\n  for v, w in items:\n    for x in range(t - w, -1, -1):\n      if dp[x + w] < dp[x] + v:dp[x + w] = dp[x] + v\n  print(max(dp)) \n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n = int(input())\n  words = []\n  scores = []\n  for _ in range(n):\n    word, score = input().split()\n    words.append(word)\n    scores.append(int(score))\n  mp = [\"#\" * 6] + [\"#\" + input() + \"#\" for _ in range(4)] + [\"#\" * 6]\n  t = int(input())\n  \n  def search(word):\n    used = [[False] * 6 for _ in range(6)]\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1))\n    \n    def _search(word, pos, x, y):\n      if pos == len(word) - 1:return 1\n      used[y][x] = True\n      ret = 0\n      for dx, dy in vec:\n        nx, ny = x + dx, y + dy\n        if not used[ny][nx] and mp[ny][nx] == word[pos + 1]:\n          ret += _search(word, pos + 1, nx, ny)\n      used[y][x] = False\n      return ret\n    \n    ret = 0\n    for y in range(1, 5):\n      for x in range(1, 5):\n        if mp[y][x] == word[0]:ret += _search(word, 0, x, y)  \n    return ret\n  \n  values = []\n  weights = []\n  for word, score in zip(words, scores):\n    cnt = search(word)\n    acc = 1\n    while cnt >= acc:\n      cnt -= acc\n      values.append(score * acc)\n      weights.append(len(word) * acc)\n      acc *= 2\n    if cnt:\n      values.append(score * cnt)\n      weights.append(len(word) * cnt)\n  \n  dp = [0] * (t + 1)\n  for v, w in zip(values, weights):\n    for x in range(max(-1, t - w), -1, -1):\n      dp[x + w] = max(dp[x + w], dp[x] + v)\n  print(max(dp)) \n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict,deque\ndef dfs(d,f,y,x):\n    if d == len(w):\n        m[k] += 1\n    else:\n        for dy,dx in move:\n            y_ = y+dy\n            x_ = x+dx\n            if 0 <= y_ < 4 and 0 <= x_ < 4:\n                if f[y_][x_]:\n                    if s[y_][x_] == w[d]:\n                        f[y_][x_] = 0\n                        dfs(d+1,f,y_,x_)\n                        f[y_][x_]= 1\nmove = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]\nn = int(sys.stdin.readline())\nword = [sys.stdin.readline().split() for i in range(n)]\ns = [sys.stdin.readline()[:-1] for i in range(4)]\nW = int(sys.stdin.readline())\nm = [0]*n\nq = deque()\nk = 0\nfor w,p in word:\n    for b in range(4):\n        for a in range(4):\n            if s[b][a] == w[0]:\n                f = [[1]*4 for i in range(4)]\n                f[b][a] = 0\n                dfs(1,f,b,a)\n    k += 1\n\nw = [len(word[i][0]) for i in range(n)]\nv = [int(word[i][1]) for i in range(n)]\ndp = [0]*(W+1)\ndeq = [0]*(W+1)\ndeqv = [0]*(W+1)\nfor i in range(n):\n    for a in range(w[i]):\n        s = 0\n        t = 0\n        j = 0\n        while j*w[i]+a <= W:\n            val = dp[j*w[i]+a]-j*v[i]\n            while s < t and deqv[t-1] <= val:t -= 1\n            deq[t] = j\n            deqv[t] = val\n            t += 1\n            dp[j*w[i]+a] = deqv[s]+j*v[i]\n            if deq[s] == j-m[i]:\n                s += 1\n            j += 1\nprint(dp[W])\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n = int(input())\n  words = []\n  scores = []\n  for _ in range(n):\n    word, score = input().split()\n    words.append(word)\n    scores.append(int(score))\n  mp = [\"#\" * 6] + [\"#\" + input() + \"#\" for _ in range(4)] + [\"#\" * 6]\n  t = int(input())\n  \n  def search(word):\n    used = [[False] * 6 for _ in range(6)]\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1))\n    \n    def _search(word, pos, x, y):\n      if pos == len(word) - 1:return 1\n      used[y][x] = True\n      ret = 0\n      for dx, dy in vec:\n        nx, ny = x + dx, y + dy\n        if not used[ny][nx] and mp[ny][nx] == word[pos + 1]:\n          ret += _search(word, pos + 1, nx, ny)\n      used[y][x] = False\n      return ret\n    \n    ret = 0\n    for y in range(1, 5):\n      for x in range(1, 5):\n        if mp[y][x] == word[0]:ret += _search(word, 0, x, y)  \n    return ret\n  \n  values = []\n  weights = []\n  for word, score in zip(words, scores):\n    cnt = search(word)\n    for _ in range(cnt):\n      values.append(score)\n      weights.append(len(word))\n  \n  dp = [0] * (t + 1)\n  for v, w in zip(values, weights):\n    for x in range(max(-1, t - w), -1, -1):\n      dp[x + w] = max(dp[x + w], dp[x] + v)\n  print(max(dp)) \n\nmain()\n"
  }
]