[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_WORDS 100000\n#define MAX_LEN 20\n#define GRID_SIZE 4\n\ntypedef struct {\n    char word[MAX_LEN];\n    int score;\n} WordEntry;\n\nWordEntry dictionary[MAX_WORDS];\nint wordCount = 0;\nchar grid[GRID_SIZE][GRID_SIZE];\nbool visited[GRID_SIZE][GRID_SIZE];\nint maxScore = 0;\nint T;\n\nint calculateScore(char *word) {\n    int len = strlen(word);\n    if (len <= 2) return 0;\n    if (len <= 4) return 1;\n    if (len == 5) return 2;\n    if (len == 6) return 3;\n    if (len == 7) return 5;\n    return 11;\n}\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && !visited[x][y];\n}\n\nbool searchWord(int x, int y, char *word, int index) {\n    if (word[index] == '\\0') return true;\n    if (!isValid(x, y) || grid[x][y] != word[index]) return false;\n\n    visited[x][y] = true;\n    for (int dx = -1; dx <= 1; dx++) {\n        for (int dy = -1; dy <= 1; dy++) {\n            if (dx == 0 && dy == 0) continue;\n            if (searchWord(x + dx, y + dy, word, index + 1)) {\n                visited[x][y] = false;\n                return true;\n            }\n        }\n    }\n    visited[x][y] = false;\n    return false;\n}\n\nbool canFormWord(char *word) {\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (grid[i][j] == word[0]) {\n                memset(visited, 0, sizeof(visited));\n                if (searchWord(i, j, word, 0)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nvoid findMaxScore(int index, int currentScore, int remainingTime) {\n    if (remainingTime <= 0 || index >= wordCount) {\n        if (currentScore > maxScore) {\n            maxScore = currentScore;\n        }\n        return;\n    }\n\n    if (canFormWord(dictionary[index].word)) {\n        int timeUsed = strlen(dictionary[index].word);\n        if (remainingTime >= timeUsed) {\n            findMaxScore(index + 1, currentScore + dictionary[index].score, remainingTime - timeUsed);\n        }\n    }\n    findMaxScore(index + 1, currentScore, remainingTime);\n}\n\nint main() {\n    scanf(\"%d\", &T);\n    for (int i = 0; i < GRID_SIZE; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    char word[MAX_LEN];\n    while (scanf(\"%s\", word) != EOF) {\n        strcpy(dictionary[wordCount].word, word);\n        dictionary[wordCount].score = calculateScore(word);\n        wordCount++;\n    }\n\n    findMaxScore(0, 0, T);\n    printf(\"%d\\n\", maxScore);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:36:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct TrieNode {\n    unordered_map<char, TrieNode*> children;\n    bool isEnd = false;\n    int score = 0;\n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n    Trie() {\n        root = new TrieNode();\n    }\n    void insert(const string& word, int score) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        node->isEnd = true;\n        node->score = score;\n    }\n};\n\nint maxScore = 0;\nunordered_set<string> foundWords;\nvector<pair<string, int>> validWords;\n\nvoid dfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited, TrieNode* node, string& currentWord, int T, int timeUsed) {\n    if (timeUsed > T) return;\n    if (node->isEnd && foundWords.find(currentWord) == foundWords.end()) {\n        foundWords.insert(currentWord);\n        maxScore += node->score;\n        validWords.emplace_back(currentWord, node->score);\n    }\n    for (int di = -1; di <= 1; ++di) {\n        for (int dj = -1; dj <= 1; ++dj) {\n            if (di == 0 && dj == 0) continue;\n            int ni = i + di, nj = j + dj;\n            if (ni >= 0 && ni < 4 && nj >= 0 && nj < 4 && !visited[ni][nj]) {\n                char c = grid[ni][nj];\n                if (node->children.find(c) != node->children.end()) {\n                    visited[ni][nj] = true;\n                    currentWord.push_back(c);\n                    dfs(ni, nj, grid, visited, node->children[c], currentWord, T, timeUsed + 1);\n                    currentWord.pop_back();\n                    visited[ni][nj] = false;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    vector<vector<char>> grid(4, vector<char>(4));\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    int W;\n    cin >> W;\n    Trie trie;\n    for (int i = 0; i < W; ++i) {\n        string word;\n        int score;\n        cin >> word >> score;\n        trie.insert(word, score);\n    }\n    int T;\n    cin >> T;\n    maxScore = 0;\n    foundWords.clear();\n    validWords.clear();\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            char c = grid[i][j];\n            if (trie.root->children.find(c) != trie.root->children.end()) {\n                vector<vector<bool>> visited(4, vector<bool>(4, false));\n                visited[i][j] = true;\n                string currentWord(1, c);\n                dfs(i, j, grid, visited, trie.root->children[c], currentWord, T, 1);\n            }\n        }\n    }\n    cout << maxScore << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isWord = false;\n    int score = 0;\n}\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    private TrieNode root = new TrieNode();\n    private int maxScore = 0;\n\n    public int maxScore(char[][] grid, String[] dictionary, int timeLimit) {\n        buildTrie(dictionary);\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                boolean[][] visited = new boolean[4][4];\n                dfs(grid, i, j, visited, root, 0, timeLimit);\n            }\n        }\n        return maxScore;\n    }\n\n    private void buildTrie(String[] dictionary) {\n        for (String word : dictionary) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                int idx = c - 'A';\n                if (node.children[idx] == null) {\n                    node.children[idx] = new TrieNode();\n                }\n                node = node.children[idx];\n            }\n            node.isWord = true;\n            node.score = word.length(); // Assuming score is word length for simplicity\n        }\n    }\n\n    private void dfs(char[][] grid, int i, int j, boolean[][] visited, TrieNode node, int currentScore, int remainingTime) {\n        if (i < 0 || i >= 4 || j < 0 || j >= 4 || visited[i][j] || remainingTime <= 0) {\n            return;\n        }\n        char c = grid[i][j];\n        TrieNode nextNode = node.children[c - 'A'];\n        if (nextNode == null) {\n            return;\n        }\n        visited[i][j] = true;\n        if (nextNode.isWord) {\n            int newScore = currentScore + nextNode.score;\n            maxScore = Math.max(maxScore, newScore);\n            nextNode.isWord = false; // Mark as used to avoid duplicate counting\n        }\n        for (int[] dir : DIRECTIONS) {\n            int ni = i + dir[0];\n            int nj = j + dir[1];\n            dfs(grid, ni, nj, visited, nextNode, currentScore, remainingTime - 1);\n        }\n        visited[i][j] = false;\n    }\n}",
    "timestamp": "2025-08-05 21:37:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass WordSearchGame {\n    private static final int[][] DIRECTIONS = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    \n    public static int maxScoreWordSearch(char[][] grid, Map<String, Integer> dictionary, int timeLimit) {\n        Set<String> usedWords = new HashSet<>();\n        long startTime = System.currentTimeMillis();\n        int maxScore = 0;\n        \n        for (int r = 0; r < 4; r++) {\n            for (int c = 0; c < 4; c++) {\n                maxScore = Math.max(maxScore, dfs(grid, r, c, new boolean[4][4], \"\", dictionary, usedWords, startTime, timeLimit));\n            }\n        }\n        \n        return maxScore;\n    }\n    \n    private static int dfs(char[][] grid, int r, int c, boolean[][] visited, \n                            String current, Map<String, Integer> dictionary, \n                            Set<String> usedWords, long startTime, int timeLimit) {\n        if (System.currentTimeMillis() - startTime > timeLimit) {\n            return 0;\n        }\n        \n        if (r < 0 || r >= 4 || c < 0 || c >= 4 || visited[r][c]) {\n            return 0;\n        }\n        \n        current += grid[r][c];\n        \n        int score = 0;\n        if (dictionary.containsKey(current) && !usedWords.contains(current)) {\n            score = dictionary.get(current);\n            usedWords.add(current);\n        }\n        \n        visited[r][c] = true;\n        int maxScore = score;\n        \n        for (int[] dir : DIRECTIONS) {\n            int newR = r + dir[0];\n            int newC = c + dir[1];\n            int subScore = dfs(grid, newR, newC, visited, current, dictionary, usedWords, startTime, timeLimit);\n            maxScore = Math.max(maxScore, score + subScore);\n        }\n        \n        visited[r][c] = false;\n        return maxScore;\n    }\n    \n    public static void main(String[] args) {\n        char[][] grid = {\n            {'A', 'B', 'C', 'D'},\n            {'E', 'F', 'G', 'H'},\n            {'I', 'J', 'K', 'L'},\n            {'M', 'N', 'O', 'P'}\n        };\n        \n        Map<String, Integer> dictionary = new HashMap<>();\n        dictionary.put(\"ABC\", 5);\n        dictionary.put(\"ABCF\", 10);\n        dictionary.put(\"EFG\", 7);\n        \n        int timeLimit = 1000; // 1 second\n        int maxScore = maxScoreWordSearch(grid, dictionary, timeLimit);\n        System.out.println(\"Maximum Score: \" + maxScore);\n    }\n}",
    "timestamp": "2025-08-05 21:37:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <time.h>\n\n#define GRID_SIZE 4\n#define MAX_WORDS 1000\n#define MAX_WORD_LENGTH 20\n#define MAX_DICTIONARY_SIZE 10000\n\n// Global variables\nchar grid[GRID_SIZE][GRID_SIZE];\nchar dictionary[MAX_DICTIONARY_SIZE][MAX_WORD_LENGTH];\nint dictionary_size = 0;\nbool used_words[MAX_DICTIONARY_SIZE];\nint word_scores[MAX_DICTIONARY_SIZE];\n\n// Possible movement directions\nint dx[] = {-1, 1, 0, 0, -1, -1, 1, 1};\nint dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nbool is_valid_position(int x, int y) {\n    return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;\n}\n\nbool dfs_word_search(int x, int y, const char* word, int index, bool visited[GRID_SIZE][GRID_SIZE]) {\n    if (index == strlen(word)) return true;\n    \n    if (!is_valid_position(x, y) || visited[x][y] || grid[x][y] != word[index]) \n        return false;\n    \n    visited[x][y] = true;\n    \n    for (int k = 0; k < 8; k++) {\n        int new_x = x + dx[k];\n        int new_y = y + dy[k];\n        \n        if (dfs_word_search(new_x, new_y, word, index + 1, visited)) {\n            visited[x][y] = false;\n            return true;\n        }\n    }\n    \n    visited[x][y] = false;\n    return false;\n}\n\nbool is_word_in_grid(const char* word) {\n    bool visited[GRID_SIZE][GRID_SIZE] = {false};\n    \n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (dfs_word_search(i, j, word, 0, visited)) \n                return true;\n        }\n    }\n    \n    return false;\n}\n\nint solve_word_game(double time_limit) {\n    int total_score = 0;\n    time_t start_time = time(NULL);\n    \n    memset(used_words, 0, sizeof(used_words));\n    \n    for (int i = 0; i < dictionary_size; i++) {\n        double elapsed_time = difftime(time(NULL), start_time);\n        \n        if (elapsed_time >= time_limit) \n            break;\n        \n        if (!used_words[i] && is_word_in_grid(dictionary[i])) {\n            total_score += word_scores[i];\n            used_words[i] = true;\n        }\n    }\n    \n    return total_score;\n}\n\nint main() {\n    // Input grid\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            scanf(\" %c\", &grid[i][j]);\n        }\n    }\n    \n    // Input dictionary and scores\n    scanf(\"%d\", &dictionary_size);\n    for (int i = 0; i < dictionary_size; i++) {\n        scanf(\"%s %d\", dictionary[i], &word_scores[i]);\n    }\n    \n    // Input time limit\n    double time_limit;\n    scanf(\"%lf\", &time_limit);\n    \n    // Solve and print result\n    int max_score = solve_word_game(time_limit);\n    printf(\"%d\\n\", max_score);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:38:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass WordGame {\nprivate:\n    vector<vector<char>> grid;\n    unordered_set<string> dictionary;\n    unordered_map<string, int> wordScores;\n    unordered_set<string> usedWords;\n    int maxTime;\n    int totalScore;\n\n    bool isValidMove(int x, int y, vector<vector<bool>>& visited) {\n        return x >= 0 && x < 4 && y >= 0 && y < 4 && !visited[x][y];\n    }\n\n    void backtrack(int x, int y, string current, vector<vector<bool>>& visited, int timeSpent) {\n        if (timeSpent > maxTime) return;\n\n        if (dictionary.count(current) && !usedWords.count(current)) {\n            totalScore += wordScores[current];\n            usedWords.insert(current);\n        }\n\n        int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1};\n        int dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n        for (int i = 0; i < 8; i++) {\n            int newX = x + dx[i];\n            int newY = y + dy[i];\n\n            if (isValidMove(newX, newY, visited)) {\n                visited[newX][newY] = true;\n                backtrack(newX, newY, current + grid[newX][newY], visited, timeSpent + 1);\n                visited[newX][newY] = false;\n            }\n        }\n    }\n\npublic:\n    WordGame(vector<vector<char>> g, unordered_set<string> dict, unordered_map<string, int> scores, int time)\n        : grid(g), dictionary(dict), wordScores(scores), maxTime(time), totalScore(0) {}\n\n    int findMaxScore() {\n        vector<vector<bool>> visited(4, vector<bool>(4, false));\n\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                visited[i][j] = true;\n                backtrack(i, j, string(1, grid[i][j]), visited, 1);\n                visited[i][j] = false;\n            }\n        }\n\n        return totalScore;\n    }\n};\n\nint main() {\n    vector<vector<char>> grid = {\n        {'A', 'B', 'C', 'D'},\n        {'E', 'F', 'G', 'H'},\n        {'I', 'J', 'K', 'L'},\n        {'M', 'N', 'O', 'P'}\n    };\n\n    unordered_set<string> dictionary = {\"ABC\", \"DEF\", \"GHI\", \"JKL\"};\n    unordered_map<string, int> wordScores = {\n        {\"ABC\", 10},\n        {\"DEF\", 15},\n        {\"GHI\", 20},\n        {\"JKL\", 25}\n    };\n\n    int timeLimit = 10;\n\n    WordGame game(grid, dictionary, wordScores, timeLimit);\n    int maxScore = game.findMaxScore();\n\n    cout << \"Maximum Score: \" << maxScore << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:38:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef word_score(word, dictionary_scores):\n    return dictionary_scores.get(word, 0)\n\ndef find_words_in_grid(grid, x, y, dictionary, prefix, visited, found_words):\n    if prefix in dictionary:\n        found_words.add(prefix)\n\n    if not (0 <= x < 4 and 0 <= y < 4) or (x, y) in visited:\n        return\n    \n    visited.add((x, y))\n    for dx, dy in itertools.product([-1, 0, 1], repeat=2):\n        if dx != 0 or dy != 0:\n            next_x, next_y = x + dx, y + dy\n            if 0 <= next_x < 4 and 0 <= next_y < 4:\n                find_words_in_grid(grid, next_x, next_y, dictionary, prefix + grid[next_x][next_y], visited, found_words)\n    visited.remove((x, y))\n\ndef max_score(grid, dictionary_scores, time_limit):\n    letters_grid = [list(row) for row in grid]\n    dictionary = set(dictionary_scores.keys())\n    all_found_words = set()\n\n    for i in range(4):\n        for j in range(4):\n            find_words_in_grid(letters_grid, i, j, dictionary, letters_grid[i][j], set(), all_found_words)\n\n    max_possible_score = sum(word_score(word, dictionary_scores) for word in all_found_words)\n\n    return max_possible_score\n\n# Example usage:\ngrid = [\n    \"ABCD\",\n    \"EFGH\",\n    \"IJKL\",\n    \"MNOP\"\n]\n\ndictionary_scores = {\n    \"ABE\": 5, \"ABEF\": 10, \"ABED\": 7, \"CIGH\": 8, \"NOPL\": 6\n}\n\nprint(max_score(grid, dictionary_scores, T=60))",
    "timestamp": "2025-08-13 07:15:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class WordGame {\n\n    private static final int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};\n    private static final int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};\n    private static final int GRID_SIZE = 4;\n    private static long startTime;\n    private static long timeLimit;\n    \n    private static boolean isInGrid(int x, int y) {\n        return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;\n    }\n    \n    private static void findWords(char[][] grid, Set<String> dictionary, Map<String, Integer> wordScores, boolean[][] visited, String word, int x, int y, Set<String> foundWords) {\n        if (dictionary.contains(word)) {\n            foundWords.add(word);\n        }\n        \n        if (System.currentTimeMillis() - startTime > timeLimit) {\n            return;\n        }\n\n        for (int dir = 0; dir < 8; dir++) {\n            int newX = x + dx[dir];\n            int newY = y + dy[dir];\n            if (isInGrid(newX, newY) && !visited[newX][newY]) {\n                visited[newX][newY] = true;\n                findWords(grid, dictionary, wordScores, visited, word + grid[newX][newY], newX, newY, foundWords);\n                visited[newX][newY] = false;\n            }\n        }\n    }\n\n    public static int getMaximumScore(char[][] grid, Set<String> dictionary, Map<String, Integer> wordScores, long timeLimitMillis) {\n        timeLimit = timeLimitMillis;\n        startTime = System.currentTimeMillis();\n        Set<String> foundWords = new HashSet<>();\n        boolean[][] visited = new boolean[GRID_SIZE][GRID_SIZE];\n        \n        for (int x = 0; x < GRID_SIZE; x++) {\n            for (int y = 0; y < GRID_SIZE; y++) {\n                visited[x][y] = true;\n                findWords(grid, dictionary, wordScores, visited, String.valueOf(grid[x][y]), x, y, foundWords);\n                visited[x][y] = false;\n            }\n        }\n        \n        int maxScore = 0;\n        for (String word : foundWords) {\n            maxScore += wordScores.getOrDefault(word, 0);\n        }\n        \n        return maxScore;\n    }\n\n    public static void main(String[] args) {\n        char[][] grid = {\n            {'A', 'B', 'C', 'D'},\n            {'E', 'F', 'G', 'H'},\n            {'I', 'J', 'K', 'L'},\n            {'M', 'N', 'O', 'P'}\n        };\n        \n        Set<String> dictionary = new HashSet<>(Arrays.asList(\"ABCD\", \"ABFG\", \"IJGL\", \"EFGH\"));\n        Map<String, Integer> wordScores = Map.of(\"ABCD\", 10, \"ABFG\", 5, \"IJGL\", 8, \"EFGH\", 7);\n        long timeLimitMillis = 2000; // 2 seconds\n        \n        System.out.println(\"Maximum Score: \" + getMaximumScore(grid, dictionary, wordScores, timeLimitMillis));\n    }\n}",
    "timestamp": "2025-08-13 07:15:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <time.h>\n\n#define GRID_SIZE 4\n#define DICT_SIZE 100\n#define WORD_MAX_LEN 16\n\ntypedef struct {\n    char word[WORD_MAX_LEN];\n    int score;\n} DictionaryEntry;\n\nchar grid[GRID_SIZE][GRID_SIZE];\nDictionaryEntry dictionary[DICT_SIZE];\nbool visited[GRID_SIZE][GRID_SIZE];\nint nEntries; // Number of dictionary entries\nint maxScore = 0;\ntime_t startTime;\nint timeLimit;\n\nint dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nint dy[] = {0, 1, 0, -1, -1, 1, -1, 1};\n\nbool isInsideGrid(int x, int y) {\n    return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;\n}\n\nbool isInDictionary(char *word) {\n    for (int i = 0; i < nEntries; ++i) {\n        if (strcmp(dictionary[i].word, word) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint wordScore(char *word) {\n    for (int i = 0; i < nEntries; ++i) {\n        if (strcmp(dictionary[i].word, word) == 0) {\n            return dictionary[i].score;\n        }\n    }\n    return 0;\n}\n\nvoid findWords(int x, int y, char *currentWord, int currentLen) {\n    if (difftime(time(NULL), startTime) >= timeLimit) {\n        return;\n    }\n\n    if (isInDictionary(currentWord)) {\n        int currentScore = wordScore(currentWord);\n        if (currentScore > maxScore) {\n            maxScore = currentScore;\n        }\n    }\n\n    if (currentLen >= WORD_MAX_LEN - 1) {\n        return;\n    }\n\n    visited[x][y] = true;\n\n    for (int dir = 0; dir < 8; ++dir) {\n        int newX = x + dx[dir];\n        int newY = y + dy[dir];\n\n        if (isInsideGrid(newX, newY) && !visited[newX][newY]) {\n            currentWord[currentLen] = grid[newX][newY];\n            currentWord[currentLen + 1] = '\\0';\n            findWords(newX, newY, currentWord, currentLen + 1);\n        }\n    }\n\n    visited[x][y] = false;\n}\n\nint main() {\n    // Initialization and input handling. This would normally contain\n    // reading the grid and dictionary. We're skipping direct inputs for brevity.\n    \n    // Example grid (for testing purposes), should be initialized through input\n    strcpy(grid[0], \"ABCD\");\n    strcpy(grid[1], \"EFGH\");\n    strcpy(grid[2], \"IJKL\");\n    strcpy(grid[3], \"MNOP\");\n\n    // Example dictionary entries (for testing purposes), should be initialized through input\n    nEntries = 3;\n    strcpy(dictionary[0].word, \"ABCD\");\n    dictionary[0].score = 10;\n    strcpy(dictionary[1].word, \"EFG\");\n    dictionary[1].score = 5;\n    strcpy(dictionary[2].word, \"IJKL\");\n    dictionary[2].score = 8;\n\n    timeLimit = 5; // 5-second time limit, should be set through input\n    startTime = time(NULL);\n\n    char currentWord[WORD_MAX_LEN];\n\n    for (int i = 0; i < GRID_SIZE; ++i) {\n        for (int j = 0; j < GRID_SIZE; ++j) {\n            currentWord[0] = grid[i][j];\n            currentWord[1] = '\\0';\n            findWords(i, j, currentWord, 1);\n        }\n    }\n\n    printf(\"Maximum Score: %d\\n\", maxScore);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:16:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Dict, Set\nimport time\n\ndef is_valid_move(grid: List[List[str]], visited: Set[tuple], x: int, y: int, rows: int, cols: int) -> bool:\n    return (0 <= x < rows and 0 <= y < cols and (x, y) not in visited)\n\ndef dfs_word_search(grid: List[List[str]], x: int, y: int, word: str, index: int, \n                    visited: Set[tuple], rows: int, cols: int) -> bool:\n    if index == len(word):\n        return True\n    \n    if not is_valid_move(grid, visited, x, y, rows, cols) or grid[x][y] != word[index]:\n        return False\n    \n    visited.add((x, y))\n    \n    directions = [(0,1), (0,-1), (1,0), (-1,0), (1,1), (1,-1), (-1,1), (-1,-1)]\n    \n    for dx, dy in directions:\n        new_x, new_y = x + dx, y + dy\n        if dfs_word_search(grid, new_x, new_y, word, index + 1, visited.copy(), rows, cols):\n            return True\n    \n    return False\n\ndef find_max_score_words(grid: List[List[str]], dictionary: Dict[str, int], time_limit: float) -> int:\n    rows, cols = len(grid), len(grid[0])\n    start_time = time.time()\n    max_score = 0\n    used_words = set()\n    \n    for word, score in dictionary.items():\n        if time.time() - start_time > time_limit:\n            break\n        \n        if word in used_words:\n            continue\n        \n        found = False\n        for x in range(rows):\n            for y in range(cols):\n                if dfs_word_search(grid, x, y, word, 0, set(), rows, cols):\n                    found = True\n                    break\n            if found:\n                break\n        \n        if found:\n            max_score += score\n            used_words.add(word)\n    \n    return max_score\n\n# Example usage\ngrid = [\n    ['A', 'B', 'C', 'D'],\n    ['E', 'F', 'G', 'H'],\n    ['I', 'J', 'K', 'L'],\n    ['M', 'N', 'O', 'P']\n]\n\ndictionary = {\n    'ABCD': 10,\n    'EFGH': 15,\n    'IJKL': 20,\n    'MNOP': 25,\n    'AEIM': 30\n}\n\ntime_limit = 2.0  # 2 seconds\nresult = find_max_score_words(grid, dictionary, time_limit)\nprint(result)",
    "timestamp": "2025-08-13 07:16:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    W = int(sys.stdin.readline())\n    dictionary = defaultdict(int)\n    for _ in range(W):\n        word = sys.stdin.readline().strip().upper()\n        score = len(word) - 2\n        if score <= 0:\n            score = 0\n        dictionary[word] = score\n    sys.stdin.readline()  # skip blank line\n    \n    B = int(sys.stdin.readline())\n    for _ in range(B):\n        grid = [sys.stdin.readline().strip().upper() for _ in range(4)]\n        if _ < B - 1:\n            sys.stdin.readline()  # skip blank line except last\n        \n        # Preprocess grid positions\n        pos = defaultdict(list)\n        for i in range(4):\n            for j in range(4):\n                pos[grid[i][j]].append((i, j))\n        \n        found_words = set()\n        max_score = 0\n        \n        # Directions: 8 possible\n        directions = [(-1, -1), (-1, 0), (-1, 1),\n                      (0, -1),          (0, 1),\n                      (1, -1),  (1, 0), (1, 1)]\n        \n        def dfs(i, j, path, visited, current_word):\n            nonlocal max_score\n            current_word += grid[i][j]\n            if current_word in dictionary and current_word not in found_words:\n                found_words.add(current_word)\n                max_score += dictionary[current_word]\n            \n            if len(current_word) == 8:  # max word length in Boggle\n                return\n            \n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < 4 and 0 <= nj < 4 and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    dfs(ni, nj, path + [(ni, nj)], visited, current_word)\n                    visited.remove((ni, nj))\n        \n        for i in range(4):\n            for j in range(4):\n                visited = set()\n                visited.add((i, j))\n                dfs(i, j, [(i, j)], visited, \"\")\n        \n        print(max_score)\n\nsolve()",
    "timestamp": "2025-08-13 07:16:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define N 4\n\nclass WordFinder {\npublic:\n    WordFinder(const vector<string>& grid, const unordered_map<string, int>& dictionary, int timeLimit)\n        : grid(grid), dictionary(dictionary), timeLimit(timeLimit) {\n    }\n\n    int findMaxScore() {\n        set<string> usedWords;\n        int maxScore = 0;\n\n        // Try to find each word in the dictionary\n        for (const auto& dictEntry : dictionary) {\n            const string& word = dictEntry.first;\n            int score = dictEntry.second;\n            if (usedWords.find(word) == usedWords.end() && canFormWord(word)) {\n                maxScore += score;\n                usedWords.insert(word);\n            }\n        }\n\n        return maxScore;\n    }\n\nprivate:\n    vector<string> grid;\n    unordered_map<string, int> dictionary;\n    int timeLimit;\n    bool visited[N][N];\n    int dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\n    int dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n    bool isValid(int x, int y) {\n        return x >= 0 && y >= 0 && x < N && y < N && !visited[x][y];\n    }\n\n    bool canFormWordUtil(int x, int y, string& word, int index) {\n        if (index == word.size()) {\n            return true;\n        }\n\n        visited[x][y] = true;\n\n        for (int dir = 0; dir < 8; ++dir) {\n            int nx = x + dx[dir], ny = y + dy[dir];\n            if (isValid(nx, ny) && grid[nx][ny] == word[index]) {\n                if (canFormWordUtil(nx, ny, word, index + 1)) {\n                    visited[x][y] = false;\n                    return true;\n                }\n            }\n        }\n\n        visited[x][y] = false;\n        return false;\n    }\n\n    bool canFormWord(const string& word) {\n        memset(visited, false, sizeof(visited));\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (grid[i][j] == word[0]) {\n                    if (canFormWordUtil(i, j, word, 1)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    vector<string> grid = {\n        \"TRAP\",\n        \"XYZO\",\n        \"NKPI\",\n        \"LOMS\"\n    };\n\n    unordered_map<string, int> dictionary = {\n        {\"TRAP\", 5},\n        {\"XYLO\", 8},\n        {\"PINS\", 7},\n        {\"LOOMS\", 10}\n    };\n\n    int timeLimit = 60; // arbitrary time limit for this example\n\n    WordFinder wf(grid, dictionary, timeLimit);\n    int maxScore = wf.findMaxScore();\n    cout << \"Maximum Score: \" << maxScore << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:36:59"
  }
]