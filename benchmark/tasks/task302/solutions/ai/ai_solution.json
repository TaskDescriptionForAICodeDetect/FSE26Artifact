[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool isSingleStroke(const char *password) {\n    if (strlen(password) == 0) return false;\n    \n    bool used[10] = {false};\n    int prev = password[0] - '0';\n    if (prev < 0 || prev > 9) return false;\n    used[prev] = true;\n    \n    for (int i = 1; password[i] != '\\0'; i++) {\n        int current = password[i] - '0';\n        if (current < 0 || current > 9) return false;\n        if (used[current]) return false;\n        \n        int row_prev = prev / 3;\n        int col_prev = prev % 3;\n        int row_current = current / 3;\n        int col_current = current % 3;\n        \n        if (abs(row_prev - row_current) > 1 || abs(col_prev - col_current) > 1) {\n            int mid_row = (row_prev + row_current) / 2;\n            int mid_col = (col_prev + col_current) / 2;\n            int mid = mid_row * 3 + mid_col;\n            \n            if ((row_prev + row_current) % 2 == 0 && (col_prev + col_current) % 2 == 0) {\n                if (!used[mid]) return false;\n            }\n        }\n        \n        used[current] = true;\n        prev = current;\n    }\n    \n    return true;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    char password[1001];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", password);\n        if (isSingleStroke(password)) {\n            printf(\"%s\\n\", password);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nbool isSingleStroke(const string &s) {\n    unordered_set<char> seen;\n    for (char c : s) {\n        if (seen.count(c)) {\n            return false;\n        }\n        seen.insert(c);\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> passwords(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> passwords[i];\n    }\n    \n    vector<string> validPasswords;\n    for (const string &s : passwords) {\n        if (isSingleStroke(s)) {\n            validPasswords.push_back(s);\n        }\n    }\n    \n    for (const string &s : validPasswords) {\n        cout << s << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SingleStrokePasswords {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine(); // Consume newline\n        List<String> passwords = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            passwords.add(scanner.nextLine());\n        }\n        \n        for (String password : passwords) {\n            if (isSingleStroke(password)) {\n                System.out.println(password);\n            }\n        }\n    }\n    \n    private static boolean isSingleStroke(String s) {\n        if (s.isEmpty()) return false;\n        Set<Character> used = new HashSet<>();\n        char prev = s.charAt(0);\n        used.add(prev);\n        \n        for (int i = 1; i < s.length(); i++) {\n            char current = s.charAt(i);\n            if (used.contains(current)) {\n                return false;\n            }\n            if (!isAdjacent(prev, current)) {\n                return false;\n            }\n            used.add(current);\n            prev = current;\n        }\n        return true;\n    }\n    \n    private static boolean isAdjacent(char a, char b) {\n        int aRow = (a - '0' - 1) / 3;\n        int aCol = (a - '0' - 1) % 3;\n        int bRow = (b - '0' - 1) / 3;\n        int bCol = (b - '0' - 1) % 3;\n        \n        // Handle '0' separately\n        if (a == '0') {\n            aRow = 3;\n            aCol = 1;\n        }\n        if (b == '0') {\n            bRow = 3;\n            bCol = 1;\n        }\n        \n        int rowDiff = Math.abs(aRow - bRow);\n        int colDiff = Math.abs(aCol - bCol);\n        return rowDiff <= 1 && colDiff <= 1;\n    }\n}",
    "timestamp": "2025-08-05 20:59:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SingleStrokePasswords {\n    public static List<String> findSingleStrokePasswords(List<String> passwords) {\n        String[] singleStrokePatterns = {\n            \"qwertyuiop\", \n            \"asdfghjkl\", \n            \"zxcvbnm\"\n        };\n        \n        List<String> singleStrokePasswords = new ArrayList<>();\n        \n        for (String password : passwords) {\n            if (isSingleStroke(password.toLowerCase(), singleStrokePatterns)) {\n                singleStrokePasswords.add(password);\n            }\n        }\n        \n        return singleStrokePasswords;\n    }\n    \n    private static boolean isSingleStroke(String password, String[] patterns) {\n        for (String pattern : patterns) {\n            boolean singleStroke = true;\n            for (char c : password.toCharArray()) {\n                if (pattern.indexOf(c) == -1) {\n                    singleStroke = false;\n                    break;\n                }\n            }\n            if (singleStroke) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        List<String> passwords = Arrays.asList(\"qwerty\", \"asdf\", \"zxcv\", \"hello\", \"world\");\n        List<String> result = findSingleStrokePasswords(passwords);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 20:59:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n// Single stroke keyboard layout\nchar keyboard[3][10] = {\n    \"qwertyuiop\",\n    \"asdfghjkl\",\n    \"zxcvbnm\"\n};\n\nbool is_single_stroke(char* password) {\n    int row = -1;\n    \n    // Find the row of the first character\n    for (int r = 0; r < 3; r++) {\n        if (strchr(keyboard[r], password[0]) != NULL) {\n            row = r;\n            break;\n        }\n    }\n    \n    // If first character not found, return false\n    if (row == -1) return false;\n    \n    // Check if all characters are in the same row\n    for (int i = 1; password[i] != '\\0'; i++) {\n        if (strchr(keyboard[row], password[i]) == NULL) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    char passwords[1000][21];\n    int valid_count = 0;\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", passwords[i]);\n        \n        if (is_single_stroke(passwords[i])) {\n            strcpy(passwords[valid_count], passwords[i]);\n            valid_count++;\n        }\n    }\n    \n    printf(\"%d\\n\", valid_count);\n    \n    for (int i = 0; i < valid_count; i++) {\n        printf(\"%s\\n\", passwords[i]);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool isSingleStroke(const std::string& password) {\n    std::unordered_set<char> strokeChars = {\n        'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',\n        'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l',\n        'z', 'x', 'c', 'v', 'b', 'n', 'm'\n    };\n\n    std::unordered_set<char> uniqueChars;\n    std::string keyboardRows[] = {\n        \"qwertyuiop\",\n        \"asdfghjkl\",\n        \"zxcvbnm\"\n    };\n\n    for (const std::string& row : keyboardRows) {\n        uniqueChars.clear();\n        bool foundInRow = false;\n\n        for (char c : password) {\n            if (strokeChars.count(std::tolower(c)) == 0) return false;\n            if (row.find(std::tolower(c)) != std::string::npos) {\n                uniqueChars.insert(std::tolower(c));\n                foundInRow = true;\n            }\n        }\n\n        if (foundInRow && uniqueChars.size() == password.length()) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<std::string> passwords(n);\n    std::vector<std::string> singleStrokePasswords;\n\n    for (int i = 0; i < n; ++i) {\n        std::cin >> passwords[i];\n        if (isSingleStroke(passwords[i])) {\n            singleStrokePasswords.push_back(passwords[i]);\n        }\n    }\n\n    std::cout << singleStrokePasswords.size() << std::endl;\n    for (const std::string& pwd : singleStrokePasswords) {\n        std::cout << pwd << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:00:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_single_stroke(password):\n    keypad = [\n        ['1', '2', '3'],\n        ['4', '5', '6'],\n        ['7', '8', '9'],\n        ['*', '0', '#']\n    ]\n\n    directions = {\n        (0, 0): [(0, 1), (1, 0)],  # 1\n        (0, 1): [(0, -1), (0, 1), (1, 0)],  # 2\n        (0, 2): [(0, -1), (1, 0)],  # 3\n        (1, 0): [(-1, 0), (0, 1), (1, 0)],  # 4\n        (1, 1): [(0, -1), (0, 1), (-1, 0), (1, 0)],  # 5\n        (1, 2): [(0, -1), (-1, 0), (1, 0)],  # 6\n        (2, 0): [(-1, 0), (0, 1)],  # 7\n        (2, 1): [(0, -1), (0, 1), (-1, 0)],  # 8\n        (2, 2): [(0, -1), (-1, 0)],  # 9\n        (3, 1): [(0, 1), (0, -1), (-1, 0)],  # 0\n    }\n\n    pos = {keypad[i][j]: (i, j) for i in range(4) for j in range(3)}\n\n    if not password:\n        return False\n\n    current = pos[password[0]]\n    for char in password[1:]:\n        if char not in pos:\n            return False\n\n        next_pos = pos[char]\n        if current == next_pos:\n            return False\n\n        delta = (next_pos[0] - current[0], next_pos[1] - current[1])\n        if delta not in directions[current]:\n            return False\n\n        current = next_pos\n\n    return True\n\ndef extract_single_stroke_passwords(candidates):\n    return [password for password in candidates if is_single_stroke(password)]\n\n# Example usage:\ncandidate_passwords = [\n    \"123\", \"456\", \"789\", \"159\", \"258\", \"321\", \"654\", \"987\", \"852\", \"741\", \n    \"147\", \"2580\", \"369\", \"1590\", \"147852\", \"753\", \"159753\", \"1234567890\"\n]\n\nresult = extract_single_stroke_passwords(candidate_passwords)\nresult",
    "timestamp": "2025-08-13 04:28:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SingleStrokePasswords {\n    private static final String[] SINGLE_STROKE_SEQUENCES = {\n        \"123\", \"321\", \"147\", \"741\", \"159\", \"951\", \"258\", \"852\", \n        \"369\", \"963\", \"456\", \"654\", \"789\", \"987\", \"753\", \"357\"\n    };\n\n    private static boolean isSingleStroke(String password) {\n        for (String sequence : SINGLE_STROKE_SEQUENCES) {\n            if (password.equals(sequence)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static List<String> filterSingleStrokePasswords(List<String> passwords) {\n        List<String> validPasswords = new ArrayList<>();\n        for (String password : passwords) {\n            if (isSingleStroke(password)) {\n                validPasswords.add(password);\n            }\n        }\n        return validPasswords;\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        List<String> passwords = new ArrayList<>();\n        // Add 1000 passwords to the list\n        passwords.add(\"123\");\n        passwords.add(\"321\");\n        passwords.add(\"147\");\n        passwords.add(\"777\");\n        passwords.add(\"159\");\n        passwords.add(\"951\");\n        \n        List<String> validPasswords = filterSingleStrokePasswords(passwords);\n        for (String password : validPasswords) {\n            System.out.println(password);\n        }\n    }\n}",
    "timestamp": "2025-08-13 04:28:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_PASSWORDS 1000\n#define PASSWORD_LENGTH 100\n\nint is_single_stroke(const char* password) {\n    int len = strlen(password);\n    if (len < 2) return 1; // trivially single stroke\n\n    // Check for single stroke pattern\n    for (int i = 1; i < len - 1; i++) {\n        if ((password[i] == password[i - 1] || password[i] == password[i + 1]) &&\n            (password[i - 1] == password[i + 1])) {\n            continue;\n        } else {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char passwords[MAX_PASSWORDS][PASSWORD_LENGTH];\n    char input_file[] = \"passwords.txt\"; // Assumed input file\n    char output_file[] = \"single_stroke_passwords.txt\";\n\n    FILE* file_in = fopen(input_file, \"r\");\n    FILE* file_out = fopen(output_file, \"w\");\n\n    if (!file_in || !file_out) return 1;\n    \n    int count = 0;\n    while (count < MAX_PASSWORDS && fscanf(file_in, \"%s\", passwords[count]) == 1) {\n        count++;\n    }\n    \n    fclose(file_in);\n    \n    for (int i = 0; i < count; i++) {\n        if (is_single_stroke(passwords[i])) {\n            fprintf(file_out, \"%s\\n\", passwords[i]);\n        }\n    }\n    \n    fclose(file_out);\n    return 0;\n}",
    "timestamp": "2025-08-13 04:28:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_single_stroke(password):\n    # Define the keyboard layout\n    keyboard = [\n        \"qwertyuiop\",\n        \"asdfghjkl\",\n        \"zxcvbnm\"\n    ]\n    \n    # Check if all characters are in the same row\n    for row in keyboard:\n        if all(char in row for char in password.lower()):\n            return True\n    \n    return False\n\n# Read number of passwords\nn = int(input())\n\n# Store single-stroke passwords\nsingle_stroke_passwords = []\n\n# Process each password\nfor _ in range(n):\n    password = input().strip()\n    if is_single_stroke(password):\n        single_stroke_passwords.append(password)\n\n# Output results\nprint(len(single_stroke_passwords))\nfor password in single_stroke_passwords:\n    print(password)",
    "timestamp": "2025-08-13 04:28:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_single_stroke(password):\n    if len(password) == 1:\n        return True\n    strokes = {\n        '0': {'1', '2', '3', '5', '4', '6', '7', '8', '9', '0'},\n        '1': {'1', '2', '4', '5', '0'},\n        '2': {'1', '2', '3', '5', '6', '0'},\n        '3': {'2', '3', '6', '5', '9', '0'},\n        '4': {'1', '4', '5', '7', '8', '0'},\n        '5': {'1', '2', '4', '5', '6', '8', '3', '0'},\n        '6': {'2', '3', '5', '6', '9', '8', '0'},\n        '7': {'4', '7', '8', '0'},\n        '8': {'4', '5', '7', '8', '9', '6', '0'},\n        '9': {'3', '6', '8', '9', '0'}\n    }\n    for i in range(len(password) - 1):\n        current = password[i]\n        next_char = password[i + 1]\n        if next_char not in strokes.get(current, set()):\n            return False\n    return True\n\ndef extract_single_stroke_passwords(passwords):\n    return [pwd for pwd in passwords if is_single_stroke(pwd)]\n\n# Example usage:\n# passwords = [\"123\", \"159\", \"1236\", \"1230\", \"12\", \"13\", \"15\", \"19\", \"147\", \"258\", \"369\", \"1590\", \"12369\", \"1478\", \"2580\", \"3690\"]\n# print(extract_single_stroke_passwords(passwords))",
    "timestamp": "2025-08-13 04:28:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nbool isSingleStrokePassword(const std::string& password) {\n    if (password.empty()) return false;\n    \n    std::vector<bool> seen(26, false);\n    char lastChar = password[0];\n    seen[lastChar - 'a'] = true;\n\n    for (size_t i = 1; i < password.size(); ++i) {\n        char currentChar = password[i];\n        if (currentChar != lastChar) {\n            if (seen[currentChar - 'a']) {\n                return false;\n            }\n            seen[currentChar - 'a'] = true;\n            lastChar = currentChar;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int n = 1000; // number of passwords\n    std::vector<std::string> passwords(n);\n\n    // Assuming passwords are provided somehow, e.g., reading from input\n    for (int i = 0; i < n; ++i) {\n        std::cin >> passwords[i];\n    }\n\n    std::vector<std::string> singleStrokePasswords;\n\n    for (const std::string& password : passwords) {\n        if (isSingleStrokePassword(password)) {\n            singleStrokePasswords.push_back(password);\n        }\n    }\n\n    // Output the single-stroke passwords or further processing\n    for (const std::string& password : singleStrokePasswords) {\n        std::cout << password << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:19:47"
  }
]