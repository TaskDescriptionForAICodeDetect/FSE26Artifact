[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005, P = 1000000007;\nint n, sum[N], dp[N], fst[N];\nvector<int> pos[3];\nchar s[N];\n\nint main() {\n\tscanf(\"%s\", s + 1), n = strlen(s + 1);\n\tbool flag = true;\n\tfor (int i = 2; i <= n; ++i)\n\t\tflag &= s[i] != s[i - 1];\n\tif (flag) return puts(\"1\"), 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tsum[i] = (sum[i - 1] + (s[i] == 'a' ? 1 : 2)) % 3;\n\t\tpos[sum[i]].push_back(i);\n\t}\n\tfst[n] = n + 1;\n\tfor (int i = n - 1; i; --i)\n\t\tif (s[i] == s[i + 1]) fst[i] = i;\n\t\telse fst[i] = fst[i + 1];\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tdp[i + 1] = (dp[i + 1] + dp[i]) % P;\n\t\tchar x = 'a' + 'b' - s[i + 1];\n\t\tif (fst[i + 1] <= n) {\n\t\t\tconst auto &v = pos[(sum[i] + (x == 'a' ? 1 : 2)) % 3];\n\t\t\tint t = lower_bound(v.begin(), v.end(), fst[i + 1]) - v.begin();\n\t\t\tif (t != v.size())\n\t\t\t\tdp[v[t]] = (dp[v[t]] + dp[i]) % P;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (sum[i] == sum[n]) ans = (ans + dp[i]) % P;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e6 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, ans;\n\nchar s[maxn];\n\nll f[maxn] = {1}, sum, last = n + 1, nex[maxn][2], flag;\n\nset <ll> pos[3];\n\nsigned main()\n{\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tflag = 1;\n\trep(i, 2, n) flag &= s[i] != s[i - 1];\n\tif(flag) return puts(\"1\"), 0;\n\tpos[0].insert(n);\n\tper(i, n - 1, 0)\n\t{\n\t\t(sum += s[i + 1] == 'a' ? 1 : 2) %= 3;\n\t\tif(s[i + 1] == s[i + 2]) last = i + 2;\n\t\tpos[sum].insert(i);\n\t\tif(s[i + 1] == 'a') nex[i][0] = i + 1;\n\t\telse nex[i][1] = i + 1;\n\t\tif(s[i + 1] == 'b')\n\t\t{\n\t\t\tauto pre = pos[(sum + 2) % 3].lb(last);\n\t\t\tif(pre == pos[(sum + 2) % 3].end()) nex[i][0] = n + 1;\n\t\t\telse nex[i][0] = *pre;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto pre = pos[(sum + 1) % 3].lb(last);\n\t\t\tif(pre == pos[(sum + 1) % 3].end()) nex[i][1] = n + 1;\n\t\t\telse nex[i][1] = *pre;\n\t\t}\n\t}\n\t// rep(i, 0, n - 1) printf(\"%lld : %lld %lld\\n\", i, nex[i][0], nex[i][1]);\n\trep(i, 0, n - 1)\n\t{\n\t\tif(nex[i][0] != n + 1) (f[nex[i][0]] += f[i]) %= mod;\n\t\tif(nex[i][1] != n + 1) (f[nex[i][1]] += f[i]) %= mod;\n\t}\n\t// rep(i, 0, n) printf(\"f : %lld\\n\", f[i]);\n\tsum = 0, ans = f[n];\n\tper(i, n - 1, 1)\n\t{\n\t\t(sum += s[i + 1] == 'a' ? 1 : 2) %= 3;\n\t\tif(!sum) (ans += f[i]) %= mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst int INF = 2147483600;\n\nint nxt[MAXN+1][3];\nLL f[MAXN+1]; char str[MAXN+1];\nint a[MAXN+1];\nLL sum;\n\ninline int Tns(int x){\n\treturn (x==2?1:2);\n} int N; \nconst int Mod = 1000000007LL;\nLL s[MAXN+1]; int To[MAXN+1];\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tscanf(\"%s\",str+1); bool pt=0; f[0]=1; N=strlen(str+1);\n\tfor(int i=1;i<=N;i++) a[i]=(int)(str[i]-'a')+1,s[i]=s[i-1]+a[i]; \n\tfor(int i=N;i>=1;i--){\n\t\tnxt[i][1]=nxt[i+1][(1-a[i]+3)%3];\n\t\tnxt[i][2]=nxt[i+1][(2-a[i]+3)%3];\n\t\tnxt[i][0]=nxt[i+1][(3-a[i])%3];\n\t\tnxt[i][a[i]]=i; To[i]=To[i+1]; if(a[i]==a[i+1]) To[i]=i+1,pt=1;\n\t} if(!pt){\n\t\tputs(\"1\"); return 0;\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\t(f[i]+=f[i-1])%=Mod; sum+=a[i];\n\t\tint d=(3+Tns(a[i])-(s[To[i]]-s[i-1])%3)%3;\n\t\tif(To[i]&&(nxt[To[i]+1][d]||!d)) \n\t\t\t(f[(!d?To[i]:nxt[To[i]+1][d])]+=f[i-1])%=Mod;\n\t} LL ans=0; bool vis=0; sum=0;\n\tfor(int i=N;i>=1;i--){\n\t\tif(!(sum%3)) (ans+=f[i])%=Mod;\n\t\tsum+=a[i];\n\t} printf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nconst int N = 233333,mo=1e9+7;\nchar S[N];int n,f[N],s[N],qz[N],b[N],res,ok[N];vector<int> a[3];\nvoid add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\n\nint main(){\n\tscanf(\"%s\",S+1);n=strlen(S+1);rep(i,1,n)s[i]=S[i]-'a'+1;\n\trep(i,1,n)qz[i]=(qz[i-1]+s[i])%3,a[qz[i]].push_back(i);f[0]=1;\n\tfor(int i=n,j=n+1;i>=0;i--){if(s[i]==s[i+1])j=i+1;b[i]=j;}\n\trep(i,1,n)ok[i]=b[i]<=n&&(qz[n]-qz[i-1])%3;ok[n]=1;\n\tres=ok[1];\n\trep(i,0,n-1)rep(j,1,2){\n\t\tif(s[i+1]==j)add(f[i+1],f[i]),add(res,f[i]*(ok[i+2]||b[i+1]<n&&(qz[n-1]-qz[i])%3));\n\t\telse if(SZ(a[(qz[i]+j)%3])&&b[i+1]<=a[(qz[i]+j)%3].back()){//RE\n\t\t\tint k=*lower_bound(a[(qz[i]+j)%3].begin(),a[(qz[i]+j)%3].end(),b[i+1]);\n\t\t\tif(k<=n)add(f[k],f[i]),add(res,f[i]*(ok[k+1]|(qz[n-1]-qz[i])%3==j));\n\t\t}\n\t}\n//\trep(i,0,n)printf(\"%d:%d\\n\",i,f[i]);\n//\tint res=0;rep(i,0,n-1)if(b[i+1]<=n&&(qz[n]-qz[i])%3||i&&(qz[n-1]-qz[i])%3==0)add(res,f[i]);\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MOD = int(1e9) + 7;\n\nchar S[100500];\nint P[100500];\n\nint nxt[100500][3];\nint ways[100500];\n\nint main()\n{\n\tint Test=1; while (Test--){\n    scanf(\"%s\", S+1);\n    int N = strlen(S+1);\n\n    // 1. XYXYXY.. 또는 YXYXYX.. 꼴이면 답 무조건 1\n    bool is_alternating = true;\n    for(int i = 1; i <= N; i++) {\n      if(S[i] == S[i-1]) {\n        is_alternating = false;\n      }\n    }\n    if(is_alternating) {\n      puts(\"1\");\n      continue;\n    }\n\n    int prv[3] = {0, -1, -1};\n    for(int i = 1; i <= N; i++) {\n      P[i] = (P[i-1] + \"12\"[S[i] - 'a'] - '0') % 3;\n      for(int j = prv[P[i]]+1; j <= i; j++) {\n        nxt[j][P[i]] = i;\n      }\n      prv[P[i]] = i;\n    }\n\n    for(int p = 0; p < 3; p++) {\n      for(int j = prv[p]+1; j <= N; j++) {\n        nxt[j][p] = N+1;\n      }\n    }\n\n    for(int i = 0; i <= N; i++) ways[i] = 0;\n    ways[0] = 1;\n    for(int i = 0; i <= N; i++) {\n      for(int p = 0; p < 3; p++) {\n        if(p != P[i]) (ways[nxt[i][p]] += ways[i]) %= MOD;\n      }\n    }\n\n    int ans = 0;\n    for(int i = 1; i <= N; i++) {\n      if((P[N] - P[i] + 3) % 3 == 0) {\n        (ans += ways[i]) %= MOD;\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100000 +117;\nconst int MM=100000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nint a[NN]={};\nint xt[NN][3]={};\nchar in[NN]={};\nLL dp[NN]={};\nconst int mod=1e9+7;\ninline LL upd(LL &x,LL y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\nint main(){\n\t//open();\n\tscanf(\"%s\",in+1);\n\tn=strlen(in+1);\n\tbool fl=0;\n\tfor(int i=1;i<=n;++i){\n\t\ta[i]=(in[i]=='a'?1:2);\n\t\tif(a[i]==a[i-1])fl=1;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\t(a[i]+=a[i-1])%=3;\n\t}\n\tif(!fl){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\txt[n][0]=n+1;\n\txt[n][1]=n+1;\n\txt[n][2]=n+1;\n\tfor(int i=n-1;i>=0;--i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\txt[i][j]=xt[i+1][j];\n\t\t}\n\t\txt[i][a[i+1]]=i+1;\n\t}\n\tdp[0]=1;\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<3;++j){\n\t\t\tif(j!=a[i]){\n\t\t\t\tupd(dp[xt[i][j]],dp[i]);\n\t\t\t}\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i]==a[n])upd(ans,dp[i]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n    }\n    int nx[2][100010];\n    int p[3][100010];\n    for(int j=0; j<3; j++) p[j][n]=n;\n    int mn[100010];\n    mn[n]=n+1;\n    for(int i=n-1; i>=0; i--){\n        for(int j=0; j<3; j++) p[j][i]=p[j][i+1];\n        p[c[i]][i]=i;\n        mn[i]=mn[i+1];\n        if(i<n-1 && s[i]==s[i+1]) mn[i]=i+2;\n        if(s[i]=='a'){\n            nx[0][i]=i+1;\n            if(mn[i]<=n) nx[1][i]=p[(c[i]+2)%3][mn[i]];\n            else nx[1][i]=n+1;\n        }else{\n            nx[1][i]=i+1;\n            if(mn[i]<=n) nx[0][i]=p[(c[i]+1)%3][mn[i]];\n            else nx[0][i]=n+1;\n        }\n    }\n    ll dp[2][100010]={};\n    dp[0][0]=1;\n    ll ans=0;\n    for(int i=0; i<n; i++){\n        //cout<<nx[0][i]<<\" \"<<nx[1][i]<<endl;\n        int x=(c[n]-c[i]+3)%3;\n      if(x!=0) (ans+=dp[1][i])%=MOD;\n      if(x!=0 && (i==n-1 || mn[i]<=n)) (ans+=dp[0][i])%=MOD;\n      else if(x!=0 && i>0 && s[i]==s[i-1] && x==(s[i]-'a'+1)%3) (ans+=(n-i)/2)%=MOD;\n      //cerr<<mn[i]<<endl;\n      //cerr<<dp[0][i]<<endl;\n        if(nx[0][i]<n){\n          if(nx[0][i]==i+1){\n            (dp[0][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }\n        }\n        if(nx[1][i]<n){\n          if(nx[1][i]==i+1){\n            (dp[0][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n\ntemplate<typename T> class BIT {\nprivate:\n\tint n;\n\tvector<T> bit;\npublic:\n\t// 0_indexed で i 番目の要素に x を加える\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile(i < n){\n\t\t\tbit[i] += x, i += i & -i;\n\t\t}\n\t}\n\t// 0_indexed で [0,i] の要素の和(両閉区間！！)\n\tT sum(int i){\n\t\ti++;\n\t\tT s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i], i -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tBIT(){}\n\t//初期値がすべて0の場合\n\tBIT(int sz) : n(sz+1), bit(n, 0){}\n\tBIT(vector<T>& v) : n((int)v.size()+1), bit(n, 0){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tadd(i,v[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcout<<sum(i)-sum(i-1)<< \" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t//-1スタート\n\tvoid print_sum(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout<<sum(i-1)<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<mod>dp(n+1);\n    vector<int>a[3];\n    vector<int>b(n+1);\n    int c = 0;\n    rep(i,n){\n        b[i] = c;\n        c += s[i]-'a'+1;\n        c %= 3;\n        a[c].push_back(i+1);\n    }\n    a[0].push_back(n);\n    a[1].push_back(n);\n    a[2].push_back(n);\n    b[n] = c;\n    BIT<int> bit(n);\n    rep(i,n-1){\n        if(s[i]==s[i+1]){\n            bit.add(i,1);\n        }\n    } \n    dp[0] = 1;\n    rep(i,n){\n        for(int j=1;j<3;j++){\n            int ca = (b[i]+j)%3;\n            int id = i;\n            while(1){\n                int x = *upper_bound(a[ca].begin(),a[ca].end(),id);\n                id = x;\n                if(x==n)break;\n                if(x==i+1){\n                    dp[x] += dp[i];\n                    break;\n                }else{\n                    if(bit.sum(x-1)-bit.sum(i-2)!=0){\n                        dp[x] += dp[i];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    mod res = 0;\n    rep(i,n){\n        int k = (3+b[n]-b[i])%3;\n        if(k==0)continue;\n        if(i==n-1){\n            res += dp[i];\n        }else if(bit.sum(n-1)-bit.sum(i-2)!=0){\n            res += dp[i];\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\nchar s[101010];\nint n,suma[101010],sumb[101010],lasa[3],lasb[3]/*,nxta[101010],nxtb[101010]*/;\nll dp[101010];\nvector<int> e[101010];\nsigned main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool flag=0;\n\tfor (int i=1;i<n;i++){\n\t\tif (s[i]==s[i+1]){\n\t\t\tflag=1;break;\n\t\t}\n\t}\n\tif (!flag){\n\t\tputs(\"1\");return 0;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tsuma[i]=suma[i-1],sumb[i]=sumb[i-1];\n\t\tif (s[i]=='a') suma[i]++;\n\t\telse sumb[i]++;\n\t}\n\tmemset(lasa,-1,sizeof lasa);\n\tmemset(lasb,-1,sizeof lasb);\n\tint i;\n\tfor (i=n;~i;i--){\n\t\tint aa=(2+i+suma[i])%3,bb=(2+i+sumb[i])%3;\n\t\tif (~lasa[aa]) \n\t\t\te[lasa[aa]].push_back(i);\n\t\tif (~lasb[bb]) \n\t\t\te[lasb[bb]].push_back(i);\n\t\tlasa[(i+suma[i])%3]=i,lasb[(i+sumb[i])%3]=i;\n\t}\n\tdp[0]=1;\n\tfor (i=1;i<=n;i++){\n\t\tfor (int j:e[i]) \n\t\t\tdp[i]=(dp[i]+dp[j])%ljc;\n\t}\n\tll _=0;\n\tfor (i=1;i<=n;i++){\n\t\tif (!((n+suma[n]-(suma[i]+i)%3)%3)) _=(_+dp[i])%ljc;\n\t}\n\tcout<<_;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define add(a,b) a=((a)+(b))%1000000007\n#define mod 1000000007\n#define ll long long\n//#define file\nusing namespace std;\n\nint b[100001],c[100001],n,i,j,k,l;\nchar a[100002];\nll f[100001],g[100001];\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc027e.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%s\",a+1),n=strlen(a+1);\n\tfo(i,1,n) b[i]=(b[i-1]+((a[i]=='a')?1:-1)+3)%3,c[i]=c[i-1]+(a[i]!=a[i+1]);\n\t\n\tfo(i,1,n)\n\t{\n\t\tfd(j,i-1,1)\n\t\tif ((b[j]+1)%3==b[i] && (c[i-1]-c[j]!=i-j-1 || j+1==i))\n\t\t{add(f[i],g[j]);break;}\n\t\tif (b[i]==1 && (c[i-1]!=i-1 || i==1)) add(f[i],1);\n\t\t\n\t\tfd(j,i-1,1)\n\t\tif ((b[j]+2)%3==b[i] && (c[i-1]-c[j]!=i-j-1 || j+1==i))\n\t\t{add(f[i],g[j]);break;}\n\t\tif (b[i]==2 && (c[i-1]!=i-1 || i==1)) add(f[i],1);\n\t\t\n\t\tif (c[i-1]==i-1) g[i]=(i+1)/2; else g[i]=f[i];\n\t}\n\tprintf(\"%lld\\n\",f[n]);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int Mod = 1000000007;\nconst int MN = 100005;\n\nint N, Sum; char s[MN];\nint nx[MN][2], f[MN];\n\nint main() {\n\tscanf(\"%s\", s + 1), N = strlen(s + 1);\n\tint flag = 1;\n\tfor (int i = 1; i < N; ++i) if (s[i] == s[i + 1]) flag = 0;\n\tif (flag) return puts(\"1\"), 0;\n\tf[N + 1] = 1, nx[N + 1][0] = nx[N + 1][1] = nx[N + 2][0] = nx[N + 2][1] = N + 2;\n\tfor (int i = N; i >= 1; --i) {\n\t\t(Sum += s[i] == 'a' ? 1 : 2) %= 3;\n\t\tnx[i][0] = s[i] == 'a' ? i + 1 : s[i + 1] == 'b' ? i + 2 : nx[i + 2][0];\n\t\tnx[i][1] = s[i] == 'b' ? i + 1 : s[i + 1] == 'a' ? i + 2 : nx[i + 2][1];\n\t\tf[i] = (f[nx[i][0]] + f[nx[i][1]] + (Sum == 0)) % Mod;\n\t}\n\tprintf(\"%d\\n\", (f[1] - (Sum == 0) + Mod) % Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=1e5+5,mod=1e9+7;\nint n,tr[N][3],f[N],sum[N];char s[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\n/*\n  s可以变成t当且仅当\n  - t可以在s上分段表示出来(每个t中字符和s的每一段mod3同余,且s最后一段不匹配的mod3=0)\n  - s存在两个相邻字符相同\n  分段表示可以考虑贪心,用最短的去匹配(不算重)\n */\n  \nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tint flg=0;\n\tREP(i,2,n)if(s[i]==s[i-1])flg=1;\n\tif(!flg)return puts(\"1\"),0;\n\tREP(i,1,n)sum[i]=(sum[i-1]+(s[i]=='a'?1:2))%3;\n\tREP(i,0,2)tr[n][i]=n+1;\n\tDREP(i,n-1,0){\n\t\tREP(j,0,2)tr[i][j]=tr[i+1][j];\n\t\ttr[i][sum[i+1]]=i+1;\n\t}\n\tf[0]=1;int ans=0;\n\tREP(i,0,n){\n\t\tREP(j,1,2)inc(f[tr[i][(sum[i]+j)%3]],f[i]);\n\t\tif(sum[i]==sum[n]&&i)inc(ans,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair <int, int>\n#define iiii pair <int, pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i, x) for(int (i) = 0; (i) < (x); (i)++)\ninline int getint() {\n\tint x = 0, p = 1; char c = getchar();\t\n\twhile (c <= 32) c = getchar();\n\tif (c == 45) p = -p, c = getchar();\n\twhile (c > 32) x = x * 10 + c - 48, c = getchar();\n\treturn x * p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N = 1e5 + 5;\nchar s[N];\nint n, pre[N], nxt[N][3], dp[N];\n//\ninline void add(int &x, int y) {\n\tx += y; if (x >= MOD) x -= MOD;\n}\nbool is1() {\n\tfor (int i = 2; i <= n; i++) if (s[i] == s[i - 1]) return false;\n\treturn true;\n}\nint main() {\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tif (is1()) return !printf(\"%d\\n\", 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tpre[i] = (pre[i - 1] + s[i] - 'a' + 1) % 3;\n\t}\n\trep(i, 3) nxt[n][i] = n + 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\trep(j, 3) nxt[i][j] = nxt[i + 1][j];\n\t\tnxt[i][pre[i + 1]] = i + 1;\n\t}\n\tdp[0] = 1;\n\trep(i, n) {\n\t\tint x = pre[i];\n\t\trep(j, 3) if(j) add(dp[nxt[i][(j + x) % 3]], dp[i]);\n\t}\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++) if (pre[i] == pre[n]) {\n\t\tadd(res, dp[i]);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005,p=1000000007;\nint read(){\n\tint f=1,g=0;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,fl,f[N],cur[3];\nvoid check(int &x,int y){if ((x+=y)>=p) x-=p;}\nchar ch[N];\nint main(){\n\tscanf(\"%s\",ch+1);\n\tn=strlen(ch+1);fl=0;\n\tfor (int i=1;i<n;i++)\n\tif (ch[i]==ch[i+1]) fl=1;\n\tif (!fl){puts(\"1\");return 0;}\n\tf[0]=1;cur[0]=0;cur[1]=cur[2]=-1;\n\tint s=0;\n\tfor (int i=1;i<=n;i++){\n\t\ts=(s+ch[i]-'a'+1)%3;\n\t\tcur[s]=i;\n\t\tif ((!s)&(i<n)) f[i]=1;\n\t\tif (cur[(s+1)%3]>=0) check(f[i],f[cur[(s+1)%3]]);\n\t\tif (cur[(s+2)%3]>=0) check(f[i],f[cur[(s+2)%3]]);\n\t}\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5+5;\nconst ll q = 1e9+7;\n\nint p[MAXN], f[MAXN][3], n, g[MAXN][3];\nll dp[MAXN];\nvector<int> v[MAXN];\nstring s;\nset<int> done[3];\nint ok[MAXN], ok2[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> s;\n\tn = s.length();\n\tp[0] = 0;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tp[i+1] = (p[i]+1+(s[i]=='b'))%3;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (i == 0)\n\t\t\t\tf[i][j] = 1;\n\t\t\telse\n\t\t\t\tf[i][j] = max(f[i-1][j], i+1);\n\t\t\twhile (true) {\n\t\t\t\tif (f[i][j] == n+1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (p[f[i][j]] != j)\n\t\t\t\t\tf[i][j]++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint t = p[i+1];\n\t\tint r = 3-p[i]-t;\n\t\tint pos = f[i][r];\n\t\tv[i+1].push_back(i);\n\t\tif (pos != n+1)\n\t\t\tv[pos].push_back(i);\n\t}\n\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int u : v[i])\n\t\t\tdp[i] = (dp[i] + dp[u])%q;\n\t\t// cout << dp[i] << endl;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint t = p[i+1];\n\t\tint r = 3-p[i]-t;\n\t\tint pos = f[i][r];\n\t\tint pos2 = f[pos][t];\n\t\tif (pos == n+1)\n\t\t\tpos2 = n+1;\n\t\tif (p[i] == p[n])\n\t\t\tcontinue;\n\t\tif (p[n] == r) {\n\t\t\tif (n >= pos)\n\t\t\t\tok[i] = 1;\n\t\t} if (p[n] == t) {\n\t\t\tif (n >= pos2)\n\t\t\t\tok[i] = 1;\n\t\t}\n\t}\n\tok[n-1] = 1;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint t = p[i+1];\n\t\tint r = 3-p[i]-t;\n\t\tint pos = f[i][r];\n\t\tint pos2 = f[pos][t];\n\t\tif (pos == n+1)\n\t\t\tpos2 = n+1;\n\t\tint g[3];\n\t\tg[t] = pos2, g[r] = pos;\n\t\tif (pos == n+1)\n\t\t\tpos2 = n+1;\n\t\tif (!ok[i+1]) {\n\t\t\tif (p[i+1] == p[n-1]) {\n\t\t\t\tif (g[p[n-1]] <= n-1)\n\t\t\t\t\tok2[i] = 1;\n\t\t\t}\n\t\t} if (pos != n+1 && !ok[pos]) {\n\t\t\tif (p[pos] == p[n-1]) {\n\t\t\t\tif (g[p[n-1]] <= n-1)\n\t\t\t\t\tok2[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tans = (ans + (ok[i]+ok2[i])*dp[i])%q;\n\t}\n\tans = (ans + dp[n-1])%q;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 1e5 + 20 , mod = 1e9 + 7 ;\nint n , dp[N] , sum[N] , nxt[N][2] , last[3] , tlast[3] ;\nstring s ;\n\ninline void add (int &a , int b) {\n\ta += b ;\n\tif (a >= mod) a -= mod ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> s ;\n\tn = _sz(s) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tif (i == n - 1) return cout << \"1\\n\" , 0 ;\n\t\tif (s[i] == s[i + 1]) break ;\n\t}\n\n\tlast[0] = last[1] = last[2] = n + 2 ;\n\ttlast[0] = n ;\n\n\tfor (int i = n - 1 ; i >= 0 ; i --) {\n\t\tsum[i] = (sum[i + 1] + (s[i] - 'a' + 1)) % 3 ;\n\n\t\tnxt[i][0] = last[(sum[i] + 2) % 3] ;\n\t\tnxt[i][1] = last[(sum[i] + 1) % 3] ;\n\n\t\tif (s[i] == 'a') nxt[i][0] = i + 1 ;\n\t\tif (s[i] == 'b') nxt[i][1] = i + 1 ;\n\n\t\tif (i && s[i - 1] == s[i]) {\n\t\t\tfor (int j = 0 ; j < 3 ; j ++) last[j] = tlast[j] ;\n\t\t}\n\t\t\n\t\ttlast[sum[i]] = i ;\n\t}\n\n\tdp[0] = 1 ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tadd(dp[nxt[i][0]] , dp[i]) ;\n\t\tadd(dp[nxt[i][1]] , dp[i]) ;\n\t}\n\n\tint ans = 0 ;\n\tfor (int i = 1 ; i <= n ; i ++) \n\t\tif (sum[i] == 0) add(ans , dp[i]) ;\n\n\tcout << ans << '\\n' ;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#pragma G++ optimize (2)\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define mod 1000000007\n#define MAX 100005\nusing namespace std;\n//char nc()\n//{\n//\tstatic char buf[100000],*p1=buf,*p2=buf;\n//\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\nchar nc(){return getchar();}\nint read()\n{\n\tint x=0,y=1;\n\tchar c=nc();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')y=-1;\n\t\tc=nc();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=nc();\n\t}\n\treturn x*y;\n}\nint n,lst[3],sm[MAX];\nchar s[MAX];\nlong long f[MAX];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool flag=false;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i>1&&s[i]==s[i-1]) flag=true;\n\t\tsm[i]=(sm[i-1]+(s[i]-96))%3;\n\t}\n\tif(!flag) return puts(\"0\"),0;  //abababa....\n\tfor(int i=1;i<=n;i++)  //我们如果倒序考虑s,那么除了第一个串以外(即除最短划分外,额外包含一个sm%3==0的前缀),其余一定是最短划分 \n\t{\n\t\tf[i]=(f[lst[(sm[i]+1)%3]]+f[lst[(sm[i]+2)%3]]+(sm[i]?1:0))%mod; //新增a,新增b,成为一个新的串\n\t\tlst[sm[i]]=i;  //对于lst,abababa...出现一定早于余数相同的a/b,因此合法 \n\t}\n\tprintf(\"%lld\",f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#define MOD 1000000007\nchar str[100005];\nint dp[100005], nxt[100005][5], pre[100005];\nint main()\n{\n\t// freopen(\"AGC027-E.in\", \"r\", stdin);\n\tscanf(\"%s\", str);\n\tint n = strlen(str);\n\tbool flg = true;\n\tfor (int i = 1; i < n; i++)\n\t\tflg &= str[i] != str[i - 1];\n\tif (flg)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tpre[i] = ((i ? pre[i - 1] : 0) + (str[i] - 'a') + 1) % 3;\n\tnxt[n][0] = nxt[n][1] = nxt[n][2] = n;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tmemcpy(nxt[i], nxt[i + 1], sizeof(nxt[i]));\n\t\tnxt[i][pre[i]] = i;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x = i ? pre[i - 1] : 0, pos = nxt[i][(x + 1) % 3];\n\t\tif (pos < n)\n\t\t\t(dp[pos + 1] += dp[i]) %= MOD;\n\t\tpos = nxt[i][(x + 2) % 3];\n\t\tif (pos < n)\n\t\t\t(dp[pos + 1] += dp[i]) %= MOD;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (pre[i] == pre[n - 1])\n\t\t\t(ans += dp[i + 1]) %= MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\nstring s;\n\nvoid add(long long &a, long long b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nint main() {\n    cin >> s;\n    int n = (int)s.size();\n    \n    // 累積和\n    vector<int> sum(n+1, 0);\n    for (int i = 0; i < n; ++i) {\n        int par = (s[i] == 'a' ? 1 : 2);\n        sum[i+1] = (sum[i] + par) % 3;\n    }\n    \n    // 次の累積和が「０」「１」「２」になる瞬間の切れ目\n    vector<vector<int> > next(n+1, vector<int>(3, n+1));\n    for (int i = n-1; i >= 0; --i) {\n        next[i][sum[i+1]] = i+1;\n        for (int j = 0; j < 3; ++j) next[i][j] = min(next[i][j], next[i+1][j]);\n    }\n    \n    // 次の「同じ文字 2 連続」を含む切れ目\n    vector<int> next2(n+1, n);\n    for (int i = n-2; i >= 0; --i) {\n        if (s[i] == s[i+1]) next2[i] = i+1;\n        else next2[i] = min(next2[i], next2[i+1]);\n    }\n    \n    // DP\n    vector<long long> dp(n+1, 0);\n    dp[0] = 1;\n    for (int i = 0; i <= n; ++i) {\n        add(dp[i+1], dp[i]);\n        int wa;\n        if (s[i] == 'a') wa = 2;\n        else wa = 1;\n        int ne = next[next2[i]][(sum[i]+(s[i]=='a'?2:1))%3];\n        if (ne <= n) add(dp[ne], dp[i]);\n    }\n    \n    // res\n    long long res = 0;\n    if (next2[0] == n) res = 1;\n    else {\n        for (int i = 1; i <= n; ++i) {\n            if (sum[i] == sum[n]) add(res, dp[i]);\n        }\n    }\n    \n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int N = 200010, P = 1e9 + 7;\nchar s[N];\nint num[N], f[N][3], n, tag[N], pre[N], ans;\nset <int> mp[3];\nint main(){\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tscanf(\"\\n%s\", s + 1);\n\tn = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++) num[i] = s[i] - 'a' + 1;\n\tfor (int i = n; i >= 1; i--) tag[i] = tag[i + 1] | (num[i] == num[i - 1]); \n\tfor (int i = 1; i <= n; i++){\n\t\tpre[i] = (pre[i - 1] + num[i]) % 3;\n\t\tmp[pre[i]].insert(i);\n\t}\n\tmp[0].insert(n + 1), mp[1].insert(n + 1), mp[2].insert(n + 1);\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++){\n\t\tint cnt = ((f[i][0] + f[i][1]) % P + f[i][2]) % P;\n\t\tint j = *mp[(pre[i] + 1) % 3].upper_bound(i);\n\t\tif (j <= n){\n\t\t\tif (j > i + 1 || num[j] == num[j - 1]) f[j][0] = (f[j][0] + cnt) % P;\n\t\t\t\telse f[j][1] = (f[j][1] + cnt) % P;\n\t\t}\n\t\tj = *mp[(pre[i] + 2) % 3].upper_bound(i);\n\t\tif (j <= n){\n\t\t\tif (j > i + 1 || num[j] == num[j - 1]) f[j][0] = (f[j][0] + cnt) % P;\n\t\t\t\telse f[j][2] = (f[j][2] + cnt) % P;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (pre[n] - pre[i] == 0){\n\t\t\tif (tag[i + 1] == 1 || i == n) ans = (ans + f[i][1] + f[i][2]) % P;\n\t\t\tans = (ans + f[i][0]) % P;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5+5;\nconst ll p = 1e9+7;\nconst ll inf = (1<<30);\n\nstring s;\nll v[MAXN], dp[MAXN][3], part[MAXN][3][3], r[MAXN][3], n;\nvector<int> pos[3];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> s;\n\tn = s.length();\n\tv[0] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tv[i] = (v[i-1] + 1 + (s[i-1] == 'b'))%3;\n\tn++;\n\tfor (int i = 0; i < n; ++i)\n\t\tpos[v[i]].push_back(i);\n\n\tfor (int i = n-1; i >= 0; --i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tr[i][j] = i;\n\t\t\telse\n\t\t\t\tr[i][j] = max(i+1LL, r[i+1][j]);\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tif (v[i] != k && v[i-1] == j)\n\t\t\t\t\tpart[i][j][k] = (part[i-1][j][k] + dp[i-1][j])%p;\n\t\t\t\telse\n\t\t\t\t\tpart[i][j][k] = part[i-1][j][k];\n\t\t\t}\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tcontinue;\n\t\t\t//find the range of j that \"project\" onto i\n\t\t\tint k = 3-v[i]-j;\n\t\t\t//j -> k -> v[i]\n\t\t\tint lo = 0, hi = pos[j].size();\n\t\t\t//find first guy who is >= i;\n\t\t\tif (pos[j].size() == 0)\n\t\t\t\tcontinue;\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] >= i) {\n\t\t\t\t\thi = mid;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] >= i)\n\t\t\t\t\thi = mid;\n\t\t\t\telse\n\t\t\t\t\tlo = mid+1;\n\t\t\t}\n\t\t\tif (lo == pos[j].size())\n\t\t\t\tcontinue;\n\t\t\tint val1 = pos[j][lo];\n\t\t\tlo = -1, hi = pos[j].size()-1;\n\t\t\t//find last guy who is <= i\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi+1)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] > i) {\n\t\t\t\t\thi = mid-1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] > i)\n\t\t\t\t\thi = mid-1;\n\t\t\t\telse\n\t\t\t\t\tlo = mid;\n\t\t\t}\n\t\t\tif (lo == -1)\n\t\t\t\tcontinue;\n\t\t\tint val2 = pos[j][lo];\n\t\t\tif (val1 > val2)\n\t\t\t\tcontinue;\n\t\t\tdp[i][v[i]] = (dp[i][v[i]] + part[val2+1][j][v[i]] + p - part[val1][j][v[i]])%p;\n\t\t}\n\t\tdp[i][v[i]] = (dp[i][v[i]] + dp[i-1][v[i-1]])%p;\n\t}\n\n\tll ans = 0;\n\tint g = -1;\n\tfor (int i = n-3; i >= 0; --i)\n\t\tif (v[i] + v[n-1] + v[n-2] == 3) {\n\t\t\tg = i;\n\t\t\tbreak;\n\t\t}\n\tif (g == -1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n-1; ++i)\n\t\tif (v[i] != v[n-1])\n\t\t\tans = (ans + dp[i][v[i]])%p;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 1e5 + 10;\nconst int MOD = 1e9 + 7;\n\nchar s[N];\nint a[N], n, f[N], nxt[3];\n\nint main() {\n\tscanf(\"%s\", s);\n\tfor (; s[n]; ++n) a[n+1] = (a[n] + s[n] - 'a' + 1) % 3;\n\tint flag = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (s[i] == s[i-1]) flag = 1;\n\t\t// printf(\"%d\\n\", a[i]);\n\t}\n\tif (!flag) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[n] = 1;\n\tfor (int i = 0; i < 3; ++i) nxt[i] = i == a[n] ? n : n + 1;\n\tfor (int i = n-1; i >= 0; --i) {\n\t\tf[i] = i && a[i] == a[n];\n\t\tfor (int c = 1; c <= 2; ++c) {\n\t\t\t(f[i] += f[nxt[(a[i]+c)%3]]) %= MOD;\n\t\t}\n\t\tnxt[a[i]] = i;\n \t}\n \tprintf(\"%d\\n\", f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100010\n#define mod 1000000007\nusing namespace std;\nchar s[maxn];\nint pre[maxn], nxt[maxn][3], able[maxn][3], f[maxn];\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tpre[i] = pre[i - 1];\n\t\tif (s[i] == 'a') pre[i] = (pre[i] + 1) % 3;\n\t\telse pre[i] = (pre[i] + 2) % 3;\n\t}\n\tint flag = 0;\n\tfor (int i = 1; i <= n - 1; i++)\n\t\tif (s[i] == s[i + 1]) flag = 1;\n\tif (flag == 0) {puts(\"1\"); return 0;}\n\tfor (int i = 0; i <= 2; i++)\n\t\tnxt[n + 1][i] = able[n + 1][i] = n + 1;\n\tfor (int i = n; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j <= 2; j++)\n\t\t{\n\t\t\tnxt[i][j] = nxt[i + 1][j];\n\t\t\table[i][j] = able[i + 1][j];\n\t\t}\n\t\tif (i)\n\t\t{\n\t\t\tnxt[i][pre[i]] = i;\n\t\t\table[i][pre[i]] = i;\n\t\t}\n\t\tfor (int j = 0; j <= 2; j++)\n\t\t\tif (i != n && i != 0 && s[i] == s[i + 1]) able[i][j] = min(able[i][j], nxt[i + 1][j]);\n\t}\n\tf[0] = 1;\n\tfor (int i = 0; i <= n - 1; i++)\n\t\tfor (int j = 1; j <= 2; j++)\n\t\t{\n\t\t\tint tmp = able[i][(j + pre[i]) % 3];\n\t\t\tf[tmp] = (f[tmp] + f[i]) % mod;\n\t\t}\n\tint res = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (pre[n] == pre[i]) res = (res + f[i]) % mod;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nchar s[101010];\nint sum[101010],ne[101010][3];\nint dp[101010];\nint main()\n{\n\tbool jud=true;\n\tint n,ans=0;\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=2;i<=n;i++)\n\t\tif(s[i]==s[i-1])\n\t\t\tjud=false;\n\tif(jud)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tsum[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=(sum[i-1]+s[i]-'a'+1)%3;\n\tne[n+1][0]=ne[n+1][1]=ne[n+1][2]=n+1;\n\tfor(int i=n;i>=0;i--)\n\t{\n\t\tfor(int j=0;j<3;j++)\n\t\t\tne[i][j]=ne[i+1][j];\n\t\tne[i][sum[i]]=i;\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tdp[0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\t(dp[ne[i][(sum[i]+1)%3]]+=dp[i])%=mod;\n\t\t(dp[ne[i][(sum[i]+2)%3]]+=dp[i])%=mod;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(sum[i]==sum[n])\n\t\t\t(ans+=dp[i])%=mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=100007,P=1000000007;\nchar str[N];int a[N],f[N],las[3];\nint main()\n{\n    scanf(\"%s\",str+1);int n=strlen(str+1),flg=0;\n    for(int i=1;i<=n;++i) if(a[i]=(a[i-1]+str[i]-'a'+1)%3,str[i]==str[i-1]) flg=1;\n    if(!flg) return puts(\"1\"),0;;\n    for(int i=1;i<=n;++i) f[i]=(1ll*f[las[0]]+f[las[1]]+f[las[2]]+(a[i]>=1)-f[las[a[i]]]+P)%P,las[a[i]]=i;\n    printf(\"%d\",f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 100010\n#define mod 1000000007\nusing namespace std;\nint n;\nchar s[maxn];\nint a[maxn];\nint sum[maxn];\nint pos[maxn][3];\nint nxt[maxn];\nvoid add(int &x,int y)\n{\n    x+=y;\n    if(x>=mod)  x-=mod;\n}\nint f[maxn];\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);  \n    for(int i=1;i<=n;i++)\n    {\n        if(s[i]=='a')  a[i]=1;\n        if(s[i]=='b')  a[i]=2;\n    }\n    for(int i=1;i<=n;i++)  sum[i]=(sum[i-1]+a[i])%3;\n    int p=n+1;\n    for(int i=n;i>=1;i--)\n    {\n        nxt[i]=p;\n        if(a[i]==a[i-1])  p=i;\n        memcpy(pos[i],pos[i+1],sizeof(pos[i+1]));\n        pos[i][sum[i]]=i;       \n    }\n    if(p==n+1)\n    {\n        puts(\"1\");\n        return 0;\n    }\n    f[0]=1;\n    for(int i=0;i<n;i++)\n    {\n        int x=nxt[i+1];\n        int y=pos[x][(sum[i]+1)%3],z=pos[x][(sum[i]+2)%3];\n        if(y&&a[i+1]!=1)  add(f[y],f[i]);\n        if(z&&a[i+1]!=2)  add(f[z],f[i]);\n        add(f[i+1],f[i]);\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        if((sum[n]-sum[i]+3)%3==0)  add(ans,f[i]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= int(n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\nconst int N = 3e5 + 2333;\nconst int mo = 1e9 + 7;\ninline void U(int &x, int y) { x += y; if (x >= mo) x -= mo; }\n\nchar str[N];\nint n, sum[N], la[3], nxt[N][3], same[N], dp[N];\n\nint main(void) {\n\tscanf(\"%s\", str + 1); \n\tn = strlen(str + 1);\n\trep (i, n) {\n\t\tstr[i] = str[i] == 'b' ? 2 : 1;\n\t\tsum[i] = (sum[i - 1] + str[i]) % 3;\n\t}\n\tla[0] = la[1] = la[2] = n + 1; same[n + 1] = n + 1;\n\tfor (int i = n; i >= 1; i--) {\n\t\tfor (int k = 0; k < 3; k++) nxt[i][k] = la[k];\n\t\tla[sum[i]] = i;\n\t\tif (str[i] == str[i + 1]) same[i] = i + 1;\n\t\telse same[i] = same[i + 1];\n\t}\n\tif (same[1] > n) return puts(\"1\"), 0;\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tU(dp[i + 1], dp[i]);\n\t\tint v = 3 - str[i + 1];\n\t\tint val = (v + sum[i]) % 3;\n\t\tint nxtpos = nxt[i][val];\n\t\tint lb = same[i + 1];\n\t\tif (nxtpos <= n) {\n\t\t\tif (nxtpos < lb) nxtpos = nxt[lb - 1][val];\n\t\t\tif (nxtpos <= n) U(dp[nxtpos], dp[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\trep (i, n) if (sum[i] == sum[n]) U(ans, dp[i]);\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define FoR(i,x,y,z) for(int i=(x);i<=(y);i+=(z))\n#define RoF(i,x,y,z) for(int i=(x);i>=(y);i-=(z))\n#define Edge(x) for(int i=head[x],to=e[i].v;i;i=e[i].nxt,to=e[i].v)\ntypedef long long ll;\nconst int N=100005;\nconst int mod=1e9+7;\nusing namespace std;\nchar s[N];\nint pre[N],f[N],pos[3],hve[N];\nvoid add(int &x,int y){ x+y>=mod?x=x+y-mod:x=x+y; }\nint main(){\n\tscanf(\"%s\",s+1); int n=strlen(s+1);\n\tFor(i,1,n){\n\t\tpre[i]=(pre[i-1]+s[i]-'a'+1)%3;\n\t\tif(i!=n) hve[i]=(s[i]==s[i+1]);\n\t}\n\tFor(i,1,n) hve[i]+=hve[i-1];\n\tif(!hve[n]) return puts(\"1\"),0;\n\tf[0]=1;pos[0]=0,pos[1]=pos[2]=-1;\n\tFor(i,1,n){\n\t\tif(!pre[i] && i!=n) add(f[i],1);\n\t\tadd(f[i],f[i-1]);\n\t\tint fr=pos[(pre[i]+s[i]-'a'+1)%3];\n\t\tif(~fr && hve[i-1]-hve[fr]) add(f[i],f[fr]);\n\t\tpos[pre[i]]=i;\t\t\n\t}\n\tprintf(\"%d\\n\",f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nchar s[100005];\nint n,f[100005],nx[100005][2],sum=0;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tf[n+1]=1;nx[n+1][0]=nx[n+1][1]=nx[n+2][0]=nx[n+2][1]=n+2;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tsum=(sum+(s[i]-'a'+1))%3;\n\t\tnx[i][0]=(s[i]=='a')?i+1:((s[i+1]=='b')?i+2:nx[i+2][0]);\n\t\tnx[i][1]=(s[i]=='b')?i+1:((s[i+1]=='a')?i+2:nx[i+2][1]);\n\t\tf[i]=(f[nx[i][0]]+f[nx[i][1]]+(sum==0))%mod;\n\t}\n\tprintf(\"%d\\n\",(f[1]-(sum==0)+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\nstring s;\n\nvoid add(long long &a, long long b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nint main() {\n    cin >> s;\n    int n = (int)s.size();\n    \n    // 累積和\n    vector<int> sum(n+1, 0);\n    for (int i = 0; i < n; ++i) {\n        int par = (s[i] == 'a' ? 1 : 2);\n        sum[i+1] = (sum[i] + par) % 3;\n    }\n    \n    // 次の累積和が「０」「１」「２」になる瞬間の切れ目\n    vector<vector<int> > next(n+1, vector<int>(3, n+1));\n    for (int i = n-1; i >= 0; --i) {\n        next[i][sum[i+1]] = i+1;\n        for (int j = 0; j < 3; ++j) next[i][j] = min(next[i][j], next[i+1][j]);\n    }\n    \n    // 次の「同じ文字 2 連続」を含む切れ目\n    vector<int> next2(n+1, n);\n    for (int i = n-2; i >= 0; --i) {\n        if (s[i] == s[i+1]) next2[i] = i+1;\n        else next2[i] = min(next2[i], next2[i+1]);\n    }\n    \n    // DP\n    vector<long long> dp(n+1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        add(dp[i+1], dp[i]);\n        int ne = next[next2[i]][(sum[i]+(s[i]=='a'?2:1))%3];\n        if (ne <= n) add(dp[ne], dp[i]);\n    }\n    \n    // res\n    long long res = 0;\n    if (next2[0] == n) res = 1;\n    else {\n        for (int i = 1; i <= n; ++i) {\n            if (sum[i] == sum[n]) add(res, dp[i]);\n        }\n    }\n    \n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (register int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter putchar('\\n')\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 5e3 + 100 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T = int> T read()\n{\n\tT f = 1, a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\treturn a * f ;\n}\n\nll n, ans;\n\nchar s[maxn];\n\nll f[maxn] = {1}, sum, last = n + 1, nex[maxn][2], flag;\n\nset <ll> pos[3];\n\nsigned main()\n{\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tflag = 1;\n\trep(i, 2, n) flag &= s[i] != s[i - 1];\n\tif(flag) return puts(\"1\"), 0;\n\tpos[0].insert(n);\n\tper(i, n - 1, 0)\n\t{\n\t\t(sum += s[i + 1] == 'a' ? 1 : 2) %= 3;\n\t\tif(s[i + 1] == s[i + 2]) last = i + 2;\n\t\tpos[sum].insert(i);\n\t\tif(s[i + 1] == 'a') nex[i][0] = i + 1;\n\t\telse nex[i][1] = i + 1;\n\t\tif(s[i + 1] == 'b')\n\t\t{\n\t\t\tauto pre = pos[(sum + 2) % 3].lb(last);\n\t\t\tif(pre == pos[(sum + 2) % 3].end()) nex[i][0] = n + 1;\n\t\t\telse nex[i][0] = *pre;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto pre = pos[(sum + 1) % 3].lb(last);\n\t\t\tif(pre == pos[(sum + 1) % 3].end()) nex[i][1] = n + 1;\n\t\t\telse nex[i][1] = *pre;\n\t\t}\n\t}\n\trep(i, 0, n - 1)\n\t{\n\t\tif(nex[i][0] != n + 1) (f[nex[i][0]] += f[i]) %= mod;\n\t\tif(nex[i][1] != n + 1) (f[nex[i][1]] += f[i]) %= mod;\n\t}\n\tsum = 0, ans = f[n];\n\tper(i, n - 1, 0)\n\t{\n\t\t(sum += s[i + 1] == 'a' ? 1 : 2) %= 3;\n\t\tif(!sum) (ans += f[i]) %= mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n   int b,ck=0,dk=5;\n    string s;\n    cin>>s;\n    b= s.length();\n\n\n    for(int i=0;i<b;i++){\n        if(s[i]=='a' && s[i+1]=='a'){\n          ck++;\n          dk=0;\n          s[i] = 'b';\n          s.erase(i+1,1);\n        //  cout<<s<<endl;\n          if(s[i]!=s[i+1]){\n            ck=ck+s.length()-1;\n          }\n\n\n\n      //  cout<<ck<<endl;\n        }\n        if(s[i]=='b' && s[i+1]=='b') {\n            ck++;\n            dk=0;\n            s[i]='a';\n            s.erase(i+1,1);\n            if(s[i]!=s[i+1]){\n            ck=ck+s.length()-1;\n          }\n          //  cout<<s<<endl;\n        }\n      if(dk!=0){\n        dk=1;\n      }\n    }\n    if(dk==1){\n        cout<<dk<<endl;\n    }\n    else cout<<ck+1<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nconst int p=1e9+7;\nchar s[N];\nlong long dp[N];\nint last[3];\n#define DP(x) (~(x)?dp[(x)]:0)\nint main(){\n\tscanf(\"%s\",s); int len=strlen(s);\n\tbool flag=0;\n\tfor(int i=1; i<len; ++i)if(s[i]==s[i-1])flag=1;\n\tif(!flag)return puts(\"1\"),0;\n\tdp[0]=1; int tmp=0; last[1]=last[2]=-1;\n\tfor(int i=1; i<=len; ++i){\n\t\t(tmp+=(s[i-1]=='a'?1:2))%=3;\n\t\tif(tmp==0&&i<len)dp[i]=1;\n\t\t(dp[i]+=DP(last[0])+DP(last[1])+DP(last[2])-DP(last[tmp]))%=p;\n\t\tlast[tmp]=i;\n\t}\n\tprintf(\"%lld\",dp[len]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt acum[108000];\nInt dp[108000];\nvector<Int> pos[3];\nstring s;\nvector<Int> rep;\nint main(){\n  cin >> s;\n  for(int i = 0;i < s.size();i++){\n    if(s[i] == 'a')acum[i+1] = acum[i] + 1;\n    else acum[i+1] = acum[i] + 2;\n    acum[i+1]%=3;\n    pos[acum[i+1]].push_back(i);\n    if(i && s[i] == s[i-1])rep.push_back(i);\n  }\n  if(rep.empty()){\n    cout << 1 << endl;\n    return 0;\n  }\n  dp[0] = 1;\n  for(int i = 0;i < s.size();i++){\n    dp[i+1] = (dp[i+1] + dp[i]) % MOD;\n    auto nxtrep = upper_bound(rep.begin(), rep.end(), i);\n    if(nxtrep == rep.end())continue;\n    int k = *nxtrep;\n    for(int j = 1;j <= 2;j++){\n      if(s[i] == 'a' && j == 1)continue;\n      if(s[i] == 'b' && j == 2)continue;\n      int to = (acum[i] + j) % 3;\n      auto nxtpos = lower_bound(pos[to].begin(), pos[to].end(), k);\n      if(nxtpos == pos[to].end())continue;\n      dp[*nxtpos+1] = (dp[*nxtpos+1] + dp[i]) % MOD;\n    }\n  }\n  Int res = 0;\n  for(int i:pos[acum[s.size()]]){\n    res = (res + dp[i+1]) %MOD;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 1e5 + 10;\nconst LL mod = 1e9 + 7;\n\nint n;\nchar s[N];\n\nLL f[N];\n\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tbool flag = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tif (s[i] == s[i - 1]) flag = 1;\n\tif (!flag) return printf(\"1\\n\"), 0;\n\tf[0] = 1;\n\tfor (int i = 1, sum = 0, pre[3] = { 0, - 1, - 1 }; i <= n; ++ i)\n\t{\n\t\t(sum += 1 + (s[i] != 'a')) %= 3;\n\t\tif (!sum && i < n) f[i] = 1;\n\t\t(++ sum) %= 3;\n\t\tif (pre[sum] != - 1) (f[i] += f[pre[sum]]) %= mod;\n\t\t(++ sum) %= 3;\n\t\tif (pre[sum] != - 1) (f[i] += f[pre[sum]]) %= mod;\n\t\t(++ sum) %= 3;\n\t\tpre[sum] = i;\n\t}\n\tprintf(\"%lld\\n\", f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: E.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nchar s[100005];\nint f[100005];\nint a[3],b[3];\nint nx[100005][3];\nint dp[100005];\nconst int p=1000000007;\nint &add(int &a,int b){return (a+=b)>=p?a-=p:a;}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint n;\n\tread(s+1);\n\tn=strlen(s+1);\n\tif(n==1)return write(\"1\\n\");\n\tbool chk=s[1]!=s[2];\n\tfor(int i=3;i<=n;++i)if(s[i]!=s[i-2])chk=0;\n\tif(chk)return write(\"1\\n\");\n\tfor(int i=1;i<=n;++i)f[i]=(f[i-1]+s[i]-'a'+1)%3;\n\ta[0]=a[1]=a[2]=b[0]=b[1]=b[2]=n+1;\n\tfor(int i=n;~i;--i){\n\t\tif(s[i]==s[i+1]){\n\t\t\tfor(int j=0;j<3;++j)b[j]=a[j];\n\t\t}\n\t\tfor(int j=0;j<3;++j)nx[i][j]=b[j];\n\t\tnx[i][f[i+1]]=i+1;\n\t\ta[f[i]]=i;\n\t\tnx[i][f[i]]=n+1;\n\t}\n//\tfor(int i=0;i<=n;++i)for(int j=0;j<3;++j)write(nx[i][j],j==2?'\\n':' ');\n\tdp[0]=1;\n\tint ans=0;\n\tfor(int i=0;i<=n;++i){\n\t\tif(i && f[i]==f[n])(ans+=dp[i])>=p?ans-=p:ans;\n\t\tadd(dp[nx[i][0]],dp[i]);\n\t\tadd(dp[nx[i][1]],dp[i]);\n\t\tadd(dp[nx[i][2]],dp[i]);\n\t}\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5+5;\nconst ll p = 1e9+7;\nconst ll inf = (1<<30);\n\nstring s;\nll v[MAXN], dp[MAXN][3], part[MAXN][3][3], r[MAXN][3], n;\nvector<int> pos[3];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> s;\n\tn = s.length();\n\tv[0] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tv[i] = (v[i-1] + 1 + (s[i-1] == 'b'))%3;\n\tn++;\n\tfor (int i = 0; i < n; ++i)\n\t\tpos[v[i]].push_back(i);\n\n\tfor (int i = n-1; i >= 0; --i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tr[i][j] = i;\n\t\t\telse\n\t\t\t\tr[i][j] = max(i+1LL, r[i+1][j]);\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tif (v[i] != k && v[i-1] == j)\n\t\t\t\t\tpart[i][j][k] = (part[i-1][j][k] + dp[i-1][j])%p;\n\t\t\t\telse\n\t\t\t\t\tpart[i][j][k] = part[i-1][j][k];\n\t\t\t}\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tcontinue;\n\t\t\t//find the range of j that \"project\" onto i\n\t\t\tint k = 3-v[i]-j;\n\t\t\t//j -> k -> v[i]\n\t\t\tint lo = 0, hi = pos[j].size();\n\t\t\t//find first guy who is >= i;\n\t\t\tif (pos[j].size() == 0)\n\t\t\t\tcontinue;\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] >= i) {\n\t\t\t\t\thi = mid;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] >= i)\n\t\t\t\t\thi = mid;\n\t\t\t\telse\n\t\t\t\t\tlo = mid+1;\n\t\t\t}\n\t\t\tif (lo == pos[j].size())\n\t\t\t\tcontinue;\n\t\t\tint val1 = pos[j][lo];\n\t\t\tlo = -1, hi = pos[j].size()-1;\n\t\t\t//find last guy who is <= i\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi+1)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] > i) {\n\t\t\t\t\thi = mid-1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] > i)\n\t\t\t\t\thi = mid-1;\n\t\t\t\telse\n\t\t\t\t\tlo = mid;\n\t\t\t}\n\t\t\tif (lo == -1)\n\t\t\t\tcontinue;\n\t\t\tint val2 = pos[j][lo];\n\t\t\t// cout << i << ' ' << j << ' ' << val1 << ' ' << val2 << endl;\n\t\t\tif (val1 > val2)\n\t\t\t\tcontinue;\n\t\t\tdp[i][v[i]] = (dp[i][v[i]] + part[val2+1][j][v[i]] + p - part[val1][j][v[i]])%p;\n\t\t}\n\t\tdp[i][v[i]] = (dp[i][v[i]] + dp[i-1][v[i-1]])%p;\n\t\t// cout << dp[i][v[i]] << endl;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n-2; ++i) {\n\t\tif (v[i] == v[n-1])\n\t\t\tcontinue;\n\t\tint k = 3-v[i]-v[n-1];\n\t\tif (r[i][k] >= n)\n\t\t\tcontinue;\n\t\tif (r[r[i][k]][v[n-1]] >= n)\n\t\t\tcontinue;\n\t\tans = (ans + dp[i][v[i]])%p;\n\t}\n\tans = (ans + dp[n-2][v[n-2]])%p;\n\tint g = -1;\n\tfor (int i = n-1; i >= -1; --i) {\n\t\tif (i == -1)\n\t\t\tg = -1;\n\t\tif (v[i] == v[n-2])\n\t\t\tg = i;\n\t\tif (v[i] == 3-v[n-2]-v[n-1])\n\t\t\tbreak;\n\t}\n\tif (g != -1) {\n\t\tfor (int k = g; k < n-2; k += 2)\n\t\t\tans = (ans + dp[g][v[g]])%p;\n\t\tif (g != n-2 && v[g-1] == v[n-1])\n\t\t\tfor (int k = g; k < n-2; k += 2)\n\t\t\t\tans = (ans + p - dp[g-1][v[g-1]])%p;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int N = 200010, P = 1e9 + 7;\nchar s[N];\nint num[N], f[N][3], n, tag[N], pre[N], ans, sam[N];\nset <int> mp[3];\nint main(){\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tscanf(\"\\n%s\", s + 1);\n\tn = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++) num[i] = s[i] - 'a' + 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (sam[i - 1] >= i) sam[i] = sam[i - 1];\n\t\telse {\n\t\t\tsam[i] = n;\n\t\t\tfor (int j = i; j < n; j++)\n\t\t\t\tif (num[j] == num[j + 1]){\n\t\t\t\t\tsam[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; i--) tag[i] = tag[i + 1] | (num[i] == num[i - 1]); \n\tfor (int i = 1; i <= n; i++){\n\t\tpre[i] = (pre[i - 1] + num[i]) % 3;\n\t\tmp[pre[i]].insert(i);\n\t}\n\tmp[0].insert(n + 1), mp[1].insert(n + 1), mp[2].insert(n + 1);\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++){\n\t\tint cnt = ((f[i][0] + f[i][1]) % P + f[i][2]) % P;\n\t\tint j = *mp[(pre[i] + 1) % 3].upper_bound(sam[i + 1]);\n\t\tif (num[i + 1] == 1) j = i + 1;\n\t\tif (j <= n){\n\t\t\tif (j > i + 1 || num[j] == num[j - 1]) f[j][0] = (f[j][0] + cnt) % P;\n\t\t\t\telse f[j][1] = (f[j][1] + cnt) % P;\n\t\t}\n\t\tj = *mp[(pre[i] + 2) % 3].upper_bound(sam[i + 1]);\n\t\tif (num[i + 1] == 2) j = i + 1;\n\t\tif (j <= n){\n\t\t\tif (j > i + 1 || num[j] == num[j - 1]) f[j][0] = (f[j][0] + cnt) % P;\n\t\t\t\telse f[j][2] = (f[j][2] + cnt) % P;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (pre[n] - pre[i] == 0){\n\t\t\tif (tag[i + 1] == 1 || i == n) ans = (ans + f[i][1] + f[i][2]) % P;\n\t\t\tans = (ans + f[i][0]) % P;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9)+7>;\n\nconst int MAXN = 2e5;\nint N;\nint A[MAXN];\n\nint main() {\n\tstring S;\n\tcin >> S;\n\tN = int(S.size());\n\tbool alternating = true;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (S[i] == S[i-1]) alternating = false;\n\t}\n\tif (alternating) {\n\t\tcout << 1 << '\\n';\n\t\treturn 0;\n\t}\n\tA[0] = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tchar c = S[size_t(i)];\n\t\tassert(c == 'a' || c == 'b');\n\t\tA[i+1] = A[i] + (c - 'a' + 1);\n\t\tA[i+1] %= 3;\n\t}\n\n\tnum dp[3][3];\n\tmemset(dp, 0, sizeof(dp));\n\tassert(A[0] == 0);\n\tdp[0][1] = dp[0][2] = 1;\n\tnum res = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tint a = A[i];\n\t\tint x = (A[i] + 1) % 3, y = (A[i] + 2) % 3;\n\n\t\tnum n = dp[x][a] + dp[y][a];\n\t\tdp[x][a] = 0;\n\t\tdp[y][a] = 0;\n\t\tif (a == A[N]) res += n;\n\t\tdp[a][x] += n;\n\t\tdp[a][y] += n;\n\t}\n\n\tcout << res << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define oo 0x7fffffff\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar jp=getchar();\n\twhile ((jp>'9'||jp<'0')&&jp!='-')\n\t\tjp=getchar();\n\tif (jp=='-')\n\t\t{\n\t\t\tfh=-1;\n\t\t\tjp=getchar();\n\t\t}\n\twhile (jp>='0'&&jp<='9')\n\t\t{\n\t\t\tout=out*10+jp-'0';\n\t\t\tjp=getchar();\n\t\t}\n\treturn out*fh;\n}\nconst int MAXN=1e5+10;\nconst int P=1e9+7;\ninline int add(int a,int b)\n{\n\treturn (a + b) % P;\n}\ninline int mul(int a,int b)\n{\n\treturn 1ll * a * b  % P;\n}\nchar s[MAXN];\nint pre[MAXN],f[MAXN],nx[3];\nint n;\nint main()\n{\n\t//freopen(\"composer.in\",\"r\",stdin);\n\t//freopen(\"composer.out\",\"w\",stdout);\n\tscanf(\"%s\",s);\n\tint flag=0;\n\tfor(; s[n]; ++n)\n\t\t{\n\t\t\tpre[n+1]=pre[n]+(s[n]=='a'? 1:2 );\n\t\t\tpre[n+1]%=3;\n\t\t}\n\tfor(rg int i=1; i<n; ++i)\n\t\tif(s[i]==s[i-1])\n\t\t\tflag=1;\n\tif(flag==0)\n\t\t{\n\t\t\tputchar('1');\n\t\t\treturn 0;\n\t\t}\n\tf[n]=1;\n\tfor(rg int i=0; i<3; ++i)\n\t\tnx[i]=i==pre[n]?n:n+1;\n\tfor(rg int i=n-1; i; --i)\n\t\t{\n\t\t\tf[i]= pre[i]==pre[n];\n\t\t\tfor(rg int c=1; c<=2; ++c)\n\t\t\t\tf[i]=add(f[i],f[nx[(pre[i]+c)%3]]);\n\t\t\tnx[pre[i]]=i;\n\t\t}\n\tcout<<add(f[nx[1]],f[nx[2]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define oo 0x7fffffff\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar jp=getchar();\n\twhile ((jp>'9'||jp<'0')&&jp!='-')\n\t\tjp=getchar();\n\tif (jp=='-')\n\t\t{\n\t\t\tfh=-1;\n\t\t\tjp=getchar();\n\t\t}\n\twhile (jp>='0'&&jp<='9')\n\t\t{\n\t\t\tout=out*10+jp-'0';\n\t\t\tjp=getchar();\n\t\t}\n\treturn out*fh;\n}\nconst int MAXN=1e6+10;\nconst int P=1e9+7;\ninline int add(int a,int b)\n{\n\treturn (a + b) % P;\n}\ninline int mul(int a,int b)\n{\n\treturn 1ll * a * b  % P;\n}\nchar s[MAXN];\nint pre[MAXN],f[MAXN],nx[3];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tscanf(\"%s\",s);\n\tint n;\n\tint flag=0;\n\tfor(;s[n];++n)\n\t\t{\n\t\t\tpre[n+1]=pre[n]+(s[n]=='a'? 1:2 );\n\t\t\tpre[n+1]%=3;\n\t\t}\n\tfor(rg int i=1;i<n;++i)\n\t\tif(s[i]==s[i-1])\n\t\t\tflag=1;\n\tif(flag==0)\n\t\t{\n\t\t\tputchar('1');\n\t\t\texit(1);\n\t\t}\n\tf[n]=1;\n\tfor(rg int i=0;i<3;++i)\n\t\tnx[i]=i==pre[n]?n:n+1;\n\tfor(rg int i=n-1;i;--i)\n\t\t{\n\t\t\tf[i]= pre[i]==pre[n];\n\t\t\tfor(rg int c=1;c<=2;++c)\n\t\t\t\tf[i]=add(f[i],f[nx[(pre[i]+c)%3]]);\n\t\t\tnx[pre[i]]=i;\n\t\t}\n\tcout<<add(f[nx[1]],f[nx[2]]);\n\t//fclose(stdin);\n\t//fclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5+5;\nconst ll q = 1e9+7;\n\nint p[MAXN], f[MAXN][3], n, g[MAXN][3];\nll dp[MAXN];\nvector<int> v[MAXN];\nstring s;\nset<int> done[3];\nint ok[MAXN], ok2[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> s;\n\tn = s.length();\n\tp[0] = 0;\n\n\tfor (int i = 0; i < n; ++i)\n\t\tp[i+1] = (p[i]+1+(s[i]=='b'))%3;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (i == 0)\n\t\t\t\tf[i][j] = 1;\n\t\t\telse\n\t\t\t\tf[i][j] = max(f[i-1][j], i+1);\n\t\t\twhile (true) {\n\t\t\t\tif (f[i][j] == n+1)\n\t\t\t\t\tbreak;\n\t\t\t\tif (p[f[i][j]] != j)\n\t\t\t\t\tf[i][j]++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint t = p[i+1];\n\t\tint r = 3-p[i]-t;\n\t\tint pos = f[i][r];\n\t\tv[i+1].push_back(i);\n\t\tif (pos != n+1)\n\t\t\tv[pos].push_back(i);\n\t}\n\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int u : v[i])\n\t\t\tdp[i] = (dp[i] + dp[u])%q;\n\t\t// cout << dp[i] << endl;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint t = p[i+1];\n\t\tint r = 3-p[i]-t;\n\t\tint pos = f[i][r];\n\t\tint pos2 = f[pos][t];\n\t\tif (pos == n+1)\n\t\t\tpos2 = n+1;\n\t\tif (p[i] == p[n])\n\t\t\tcontinue;\n\t\tif (p[n] == r) {\n\t\t\tif (n >= pos)\n\t\t\t\tok[i] = 1;\n\t\t} if (p[n] == t) {\n\t\t\tif (n >= pos2)\n\t\t\t\tok[i] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint t = p[i+1];\n\t\tint r = 3-p[i]-t;\n\t\tint pos = f[i][r];\n\t\tint pos2 = f[pos][t];\n\t\tif (pos == n+1)\n\t\t\tpos2 = n+1;\n\t\tint g[3];\n\t\tg[t] = pos2, g[r] = pos;\n\t\tif (pos == n+1)\n\t\t\tpos2 = n+1;\n\t\tif (!ok[i+1] && i+1 != n-1) {\n\t\t\tif (p[i+1] == p[n-1]) {\n\t\t\t\tif (g[p[n-1]] <= n-1)\n\t\t\t\t\tok2[i] = 1;\n\t\t\t}\n\t\t} if (pos != n+1 && !ok[pos] && pos != n-1) {\n\t\t\tif (p[pos] == p[n-1]) {\n\t\t\t\tif (g[p[n-1]] <= n-1)\n\t\t\t\t\tok2[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tans = (ans + (ok[i]+ok2[i])*dp[i])%q;\n\t}\n\tans = (ans + dp[n-1])%q;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nchar s[100050];\nint mo=1e9+7;\nint pre[4],dp[100050],flag,tmp,cnt,ans;\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tfor (int i=1;i<n;i++)if (s[i]==s[i+1]){flag=1;break;}\n\tif (!flag){printf(\"1\\n\");return 0;}\n\tdp[0]=1;\n\tpre[0]=0,pre[1]=pre[2]=-1;\n\tfor (int i=1;i<=n;i++){\n\t\ttmp=(tmp+s[i]-'a'+1)%3;\n\t\tif (!tmp&&i<n)dp[i]=1;\n\t\tfor (int j=1;j<=2;j++)if (pre[(tmp+j)%3]!=-1)dp[i]=(dp[i]+dp[pre[(tmp+j)%3]])%mo;\n\t\tpre[tmp]=i;\n\t}\n\t/*for (int i=1;i<=n;i++){\n\t\tcnt=(cnt+s[i]-'a'+1)%3;\n\t\tif (cnt==tmp)ans=(ans+dp[i])%mo;\n\t}*/\n\tprintf(\"%d\",dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define foreach(i, n) for (__typeof(n.begin()) i = n.begin(); i != n.end(); ++i)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define MP make_pair\n#define PB push_back\n#define SZ(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define inf 0x3f3f3f3f\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst double eps = 1e-8;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\n#define se(x) cout<<#x<<\" = \"<<x<<endl\n\n#ifdef CHEN_PC\n\t#define debug(...) printf(__VA_ARGS__)\n#else \n\t#define debug(...)\n#endif\n\nconst int N = 100010;\nconst int mod = 1000000007; // 10^9+7\nint dp[N];\nint val[N];\nint pnt[N];\n\nint trans(char a) {\n\treturn  a == 'a' ? 1 : 2;\n}\n\nint solve(char *s, int n) {\n\tbool flag = true;\n\tforab (i, 1, n) {\n\t\tif (s[i] == s[i - 1]) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t} \n\t}\n\tif (flag) {\n\t\treturn 1;\n\t}\n\tval[n] = 0;\n\tint z[3];\n\tz[0] = n;\n\tz[1] = z[2] = pnt[n+1] = n+1;\n\tford (i, n) {\n\t\tval[i] = val[i + 1] + trans(s[i]);\n\t\tval[i] %= 3;\n\t\tpnt[i] = z[val[i]];\n\t\tz[val[i]] = i;\n\t}\n\n\t// debug(\"%s\\n\", s);\n\t// forn (i, n) {\n\t// \tdebug(\"%d\", val[i]);\n\t// }\n\t// puts(\"\");\n\t// forn (i, n) {\n\t// \tdebug(\"%d\", pnt[i]);\n\t// }\n\t// puts(\"\");\n\t// debug(\"%d,%d,%d\\n\", z[0], z[1], z[2]);\n\n\tclr(dp, 0);\n\tdp[0] = 1;\n\tforn (i, n) {\n\t\tdp[i + 1] += dp[i];\n\t\tdp[i + 1] %= mod;\n\t\tint tag = val[i] - (3 - trans(s[i]));\n\t\ttag = (tag % 3 + 3) % 3;\n\t\tdp[z[tag]] += dp[i];\n\t\tdp[z[tag]] %= mod;\n\t\tz[val[i]] = pnt[i];\n\t\t// debug(\"-- %d, %d, dp[%d] = %d, dp[%d] = %d\\n\", tag, z[tag], i, dp[i], z[tag], dp[z[tag]]);\n\t}\n\tint ret = 0;\n\tforab (i, 1, n+1) {\n\t\t// debug(\"%d %d %d\\n\", i, val[i], dp[i]);\n\t\tif (val[i] == 0) {\n\t\t\tret += dp[i];\n\t\t\tret %= mod;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(int argc, char *argv[]) {\n#ifdef CHEN_PC\n\tfreopen(\"E.in\", \"r\", stdin);\n#endif\n\n\tchar str[N];\n\twhile (scanf(\"%s\", str) != EOF) {\n\t\tint n = strlen(str);\n\t\tint ret = solve(str, n);\n\t\tprintf(\"%d\\n\", ret);\n\t\t// debug(\"=====\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e5+10 , mod = 1e9+7;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n;\nint f[N] , lst[N] , a[N];\nchar s[N];\nint main()\n{\n\tscanf(\"%s\" , s);\n\tfor( ; s[n] ; ++n) a[n+1] = (a[n] + s[n] - 'a' + 1) % 3;\n\tint flag = 0;\n\tfor(int i = 1 ; i < n ; ++i) if(s[i] == s[i - 1]) { flag = 1; break; }\n\tif(!flag) return puts(\"1\") , 0;\n//\tfor(int i = 0 ; i < n ; ++i) a[i+1] = (a[i] + s[i] - 'a' + 1) % mod;\n\tfor(int i = 0 ; i <= 2 ; ++i) lst[i] = i == a[n] ? n : n + 1;\n\tf[n] = 1;\n\tfor(int i = n - 1 ; i ; --i)\n\t{\n\t\tf[i] = a[i] == a[n];\n\t\tfor(int j = 1 ; j <= 2 ; ++j) (f[i] += f[lst[(a[i] + j) % 3]]) %= mod;\n\t\tlst[a[i]] = i;\n\t}\n\tcout << (f[lst[1]] + f[lst[2]]) % mod << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define add(a,b) a=((a)+(b))%1000000007\n#define mod 1000000007\n#define ll long long\n//#define file\nusing namespace std;\n\nint b[100001],c[100001],n,i,j,k,l,ls;\nchar a[100002];\nll f[100001],g[100001],F[100001][3];\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc027e.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%s\",a+1),n=strlen(a+1);\n\tfo(i,1,n) b[i]=(b[i-1]+((a[i]=='a')?1:-1)+3)%3,c[i]=c[i-1]+(a[i]!=a[i+1]);\n\t\n\tls=0;\n\tfo(i,1,n)\n\t{\n\t\tfo(j,0,2) F[i][j]=F[i-1][j];\n\t\tif (a[i-1]==a[i]) ls=i-1;\n\t\t\n\t\tif (i>1 && (b[i-1]+1)%3==b[i]) add(f[i],g[i-1]);\n\t\telse\n\t\tadd(f[i],F[ls][(b[i]+2)%3]);\n\t\tif (b[i]==1 && (c[i-1]!=i-1 || i==1)) add(f[i],1);\n\t\t\n\t\tif (i>1 && (b[i-1]+2)%3==b[i]) add(f[i],g[i-1]);\n\t\telse\n\t\tadd(f[i],F[ls][(b[i]+1)%3]);\n\t\tif (b[i]==2 && (c[i-1]!=i-1 || i==1)) add(f[i],1);\n\t\t\n\t\tif (c[i-1]==i-1) g[i]=(i+1)/2,f[i]=1; else g[i]=f[i];\n\t\tF[i][b[i]]=g[i];\n\t}\n\tprintf(\"%lld\\n\",f[n]);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint change_time = 0;\nchar maked_word[10000][100001] = {{'\\0'}};\nint temp = 0;\n\nchar* change(int t,char *s,char sw)\n{\n\tchar ret[100001];\n\tfor(int i =0;i<t;i++)\n\t{\n\t\tret[i] = s[i];\n\t}\n\tret[t] = sw;\n\tfor(int i=t+1;s[i+1] != '\\0';i++)\n\t{\n\t\tret[i] = s[i+1];\n\t}\n\n\treturn ret;\n}\n\n\nvoid saiki(char *s)\n{\n\t//printf(\"%s\\n\",s);\n\tfor(int i =0;i<change_time;i++)\n\t{\n\t\tif(strcmp(maked_word[i],s) == 0)\n\t\t{\n\t\t\tchange_time -=1;\n\t\t\tbreak;\n\t\t}else\n\t\t{\n\t\t\tstrcpy(maked_word[change_time],s);\n\t\t}\n\t}\n\tchange_time++;\n\tint num=0;\n\tfor(int i=0;s[i] != '\\0';i++)\n\t{\n\t\tnum++;\n\t}\n\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tif(s[i] == 'a' && s[i+1] == 'a')\n\t\t{\n\t\t\tchar *ss = change(i,s,'b');\n\t\t\tsaiki(ss);\n\t\t}\n\t\tif(s[i] == 'b' && s[i+1] == 'b')\n\t\t{\n\t\t\tchar *ss =change(i,s,'a');\n\t\t\tsaiki(ss);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tchar s[100001];\n\tscanf(\"%s\",s);\n\tsaiki(s);\n\tprintf(\"%d\\n\",change_time);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005,M=1e9+7;\nint sum[N],dp[N],nxt[N][3];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tint flag=0;\n\tfor (int i=1;i<n;i++)\n\t\tif (s[i]==s[i+1])flag=1;\n\tif (!flag){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)sum[i]=(sum[i-1]+s[i]-'a'+1)%3;\n\tfor (int i=0;i<3;i++)nxt[n+1][i]=n+1;\n\tfor (int i=n;i;i--)\n\t\tfor (int j=0;j<3;j++)\n\t\t\tif (j==sum[i])nxt[i][j]=i;\n\t\t\telse nxt[i][j]=nxt[i+1][j];\n\tdp[0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=1;j<3;j++)\n\t\t\t(dp[nxt[i+1][(j+sum[i])%3]]+=dp[i])%=M;\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (sum[i]==sum[n])(ans+=dp[i])%=M;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100100\n#define mo 1000000007\nusing namespace std;\nint n,ap[17][N],t[N],pr[N],f[N],a[N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=2;i<=n;++i)t[i]=t[i-1]+(s[i]==s[i-1]);\n\tfor(int i=1;i<=n;++i){\n\t\tpr[i]=(pr[i-1]+(a[i]=s[i]-96))%3;\n\t\tap[0][i]=1<<pr[i];\n\t}\n\tfor(int j=1;j<=16;++j)for(int i=1,_E_=n+1-(1<<j);i<=_E_;++i)ap[j][i]=ap[j-1][i]|ap[j-1][i+(1<<j-1)];\n\tf[0]=1;\n\tfor(int i=0;i<n;++i){\n\t\tf[i+1]=(f[i+1]+f[i])%mo;\n\t\tint l=i+1,r=n,m,s=n+1;\n\t\twhile(l<=r)if(t[m=l+r>>1]!=t[i+1])r=m-1,s=m;else l=m+1;\n\t\tif(s>n)continue;\n\t\tfor(int j=16;j+1;--j)if(s+(1<<j)<=n+1&&!(ap[j][s]&1<<(3+pr[i]-a[i+1])%3))s+=1<<j;\n\t\tif(s>n)continue;\n\t\tf[s]=(f[s]+f[i])%mo;\n\t}int ans=f[n]%mo;\n\tif(t[n])for(int i=n-1;i;--i)if(pr[n]==pr[i])ans=(ans+f[i])%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint del(int x) { return x>=P?x-P:x; }\nvoid add(int &x,int y) { x=del(x+y); }\nvoid add3(int &x,int y) { x+=y; x=x>=3?x-3:x; }\nint f[N],pre[3]={0,-1,-1};\nchar s[N];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tscanf (\"%s\",s+1);\n\tint n=strlen (s+1); bool fg=0;\n\tfor (int i=1; i< n; i++)\n\t\tif (s[i]==s[i+1]) { fg=1; break; }\n\tif (!fg) return pr(1),0;\n\tf[0]=1;\n\tfor (int i=1,x=0; i<=n; i++)\n\t{\n\t\tadd3(x,1+(s[i]=='b'));\n\t\tif (!x&&i< n) f[i]=1;\n\t\tadd3(x,1); if (pre[x]!=-1) add(f[i],f[pre[x]]);\n\t\tadd3(x,1); if (pre[x]!=-1) add(f[i],f[pre[x]]);\n\t\tadd3(x,1),pre[x]=i;\n\t}\n\tpr(f[n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nstring S;\n\nint m[111111];\n\nint dp[111111];\n\nsigned main(){\n    cin>>S;\n    \n    \n    bool flag=true;\n    for(int i=0;i+1<S.size();i++)if(S[i]==S[i+1])flag=false;\n    \n    if(flag){\n        cout<<1<<endl;\n        return 0;\n    }\n    \n    rep(i,S.size()){\n        if(S[i]=='a')m[i+1]=(m[i]+1)%3;\n        else m[i+1]=(m[i]+2)%3;\n    }\n\n    dp[0]=1;\n\n    queue<int>que[3];\n    rep(i,S.size())que[m[i+1]].push(i+1);\n\n    rep(i,S.size()){\n        for(int j=1;j<=2;j++){\n            if(que[(m[i]+j)%3].size()==0)continue;\n            int k=que[(m[i]+j)%3].front();\n            add(dp[k],dp[i]);\n        }\n        que[m[i+1]].pop();\n    }\n\n    \n    int ans=0;\n    for(int i=1;i<=S.size();i++){\n        if(m[i]==m[S.size()])add(ans,dp[i]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nconst int N = 233333,mo=1e9+7;\nchar S[N];int n,f[N],s[N],qz[N],b[N],res,ok[N];vector<int> a[3];\nvoid add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\n\nint main(){\n\tscanf(\"%s\",S+1);n=strlen(S+1);rep(i,1,n)s[i]=S[i]-'a'+1;\n\trep(i,1,n)qz[i]=(qz[i-1]+s[i])%3,a[qz[i]].push_back(i);f[0]=1;\n\tfor(int i=n,j=n+1;i>=0;i--){if(s[i]==s[i+1])j=i+1;b[i]=j;}\n\trep(i,1,n)ok[i]=b[i]<=n&&(qz[n]-qz[i-1])%3;ok[n]=1;\n\tif(b[1]>n){puts(\"1\");return 0;}\n\trep(i,0,n-1)rep(j,1,2){\n\t\tif(s[i+1]==j)add(f[i+1],f[i]);\n\t\telse if(SZ(a[(qz[i]+j)%3])&&b[i+1]<=a[(qz[i]+j)%3].back()){//RE\n\t\t\tint k=*lower_bound(a[(qz[i]+j)%3].begin(),a[(qz[i]+j)%3].end(),b[i+1]);\n\t\t\tif(k<=n)add(f[k],f[i]);\n\t\t}\n\t}\n//\trep(i,0,n)printf(\"%d:%d\\n\",i,f[i]);\n\tres=0;rep(i,1,n)if((qz[n]-qz[i])%3==0)add(res,f[i]);\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n\n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n\n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n\n#define INF ((1ll<<60)-233)\n#define sqr(x) ((x)*(x))\n#define debug puts(\"wzpkking\")\nusing namespace std;\n\nconst int mo=1000000007;\nconst int N=100005;\nint a[N],nxt[N][3];\nint ans,f[N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1),fl=0;\n\tFor(i,1,n-1) if (s[i]==s[i+1]) fl=1;\n\tif (!fl) return puts(\"1\"),0;\n\tFor(i,1,n) a[i]='c'-s[i];\n\tFor(i,1,n+1) a[i]+=a[i-1],a[i]%=3;\n\tFor(i,0,2) nxt[n+1][i]=n+1;\n\tRep(i,n,0){\n\t\tFor(j,0,2) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][a[i]]=i;\n\t}\n\tf[1]=1;\n\tFor(i,1,n+1){\n\t\tif (nxt[i][(a[i-1]+1)%3]!=n+1)\n\t\t\t(f[nxt[i][(a[i-1]+1)%3]+1]+=f[i])%=mo;\n\t\tif (nxt[i][(a[i-1]+2)%3]!=n+1)\n\t\t\t(f[nxt[i][(a[i-1]+2)%3]+1]+=f[i])%=mo;\n\t\tif (a[i-1]==a[n]&&i!=1) (ans+=f[i])%=mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nsigned main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tvvel lis(3);\n\tvel sum(n + 1);\n\tbool fl = true;\n\trep(i, n) {\n\t\tlis[sum[i]].push_back(i);\n\t\tsum[i + 1] = sum[i] + (s[i] - 'a') + 1; sum[i + 1] %= 3;\n\t\tif (i % 2 == 0 xor s[i] == s[0]) { fl = false; }\n\t}\n\tif (fl) { cout << 1 << endl; return 0; }\n\tvel dp(n);\n\tdp[0] = 1;\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (sum[i] != sum[n]) { ans += dp[i]; }\n\t\tint pla = (sum[i] + 1) % 3;\n\t\tauto itr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; dp[*itr] %= p; }\n\t\tpla++; pla %= 3;\n\t\titr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; dp[*itr] %= p; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define next dskjf\n\nusing namespace std;\n\nconst int mo=1e9+7;\n\nint f[100001],next[100001][3],sum[100001],ans=0;\nchar s[100001];\n\nint main()\n{\n\tscanf(\"%s\",s+1);int len=strlen(s+1);\n\tbool bo=false;\n\tsum[0]=0;sum[1]=(s[1]=='a')?1:2;\n\tfor(int i=2;i<=len;i++) \n\t{\n\t\tsum[i]=(sum[i-1]+((s[i]=='a')?1:2))%3;\n\t\tif(s[i]==s[i-1]) bo=true;\n\t}\n\tif(!bo) {cout<<1<<endl;return 0;}\n\tmemset(next,-1,sizeof(next));\n\tfor(int i=len;i>=0;i--)\n\t{\n\t\tfor(int j=0;j<=2;j++) next[i][j]=next[i+1][j];\n\t\tif(i<len) next[i][sum[i+1]]=i+1;\n\t}\n\tf[0]=1;\n\tfor(int i=0;i<=len;i++)\n\t{\n\t\tfor(int j=1;j<=2;j++)\n\t\t{\n\t\t\tint yu=next[i][(sum[i]+j)%3]; \n\t\t\tif(yu!=-1) f[yu]=(f[yu]+f[i])%mo;\n\t\t}\n\t\tif((i>0)&&(sum[i]==sum[len])) ans=(ans+f[i])%mo;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint nxt[N][10],s[N];\nll dp[N];\nint solve(VI c) {\n\tbool ss=0;\n\trep(i,0,SZ(c)-1)  if (c[i]==c[i+1]) ss=1;\n\tif (!ss) return 1;\n\tint n=SZ(c);\n\trep(i,0,n) s[i+1]=(s[i]+(c[i]?1:2))%3;\n\trep(j,0,3) nxt[n][j]=n+1;\n\tper(i,0,n) {\n\t\trep(j,0,3) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][s[i+1]]=i+1;\n\t}\n\tdp[0]=1;\n\tll ans=0;\n\trep(i,1,n+1) dp[i]=0;\n\trep(i,0,n+1) {\n\t\trep(j,1,3) {\n\t\t\tint p=nxt[i][(s[i]+j)%3];\n\t\t\tif (p<=n) {\n\t\t\t\tdp[p]=(dp[p]+dp[i])%mod;\n\t\t\t}\n\t\t}\n\t\tif (i>0&&s[i]==s[n]) ans=(ans+dp[i])%mod;\n\t}\n//\tprintf(\"%lld\\n\",ans);\n\treturn ans;\n}\n\nchar ss[N];\n//int M=10;\nint main() {\n\tscanf(\"%s\",ss);\n\tint n=strlen(ss);\n\tVI c;\n\trep(i,0,n) c.pb(ss[i]-'a');\n\tprintf(\"%d\\n\",solve(c));\n/*\n\trep(S,0,(1<<M)) {\n\t\tVI c;\n\t\trep(i,0,M) c.pb((S>>i)&1);\n\t\tset<VI> w;\n\t\tqueue<VI> q;\n\t\tq.push(c);\n\t\tw.insert(c);\n\t\twhile (!q.empty()) {\n\t\t\tVI cc=q.front(); q.pop();\n\t\t\trep(i,0,SZ(cc)-1) if (cc[i]==cc[i+1]) {\n\t\t\t\tVI dd=cc; dd.erase(dd.begin()+i);\n\t\t\t\tdd[i]^=1;\n\t\t\t\tif (!w.count(dd)) w.insert(dd),q.push(dd);\n\t\t\t}\n\t\t}\n\t\trep(i,0,M) printf(\"%c\",'a'+c[i]); printf(\" %d\\n\",SZ(w));\n\t\tassert(SZ(w)==solve(c));\n\t}*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e5+50, mod=1e9+7;\ninline void add(int &x,int y) {x=(x+y>=mod) ? (x+y-mod) : (x+y);}\n\nchar t[N]; \nint n,ans,s[N],f[N],pre[N][3],fir[N];\n\nint main() {\n\tscanf(\"%s\",t+1); n=strlen(t+1);\n\tfor(int i=1;i<=n;i++) s[i]=(s[i-1]+t[i]-'a'+1)%3;\n\tpre[0][0]=pre[0][1]=pre[0][2]=-1;\n\tfor(int i=1;i<=n;i++) {\n\t\tpre[i][0]=pre[i-1][0];\n\t\tpre[i][1]=pre[i-1][1];\n\t\tpre[i][2]=pre[i-1][2];\n\t\tpre[i][s[i-1]]=i-1;\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfir[i]=fir[i-1];\n\t\tif(t[i]==t[i-1]) fir[i]=i;\n\t}\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tint pos=fir[i]-1;\n\t\tf[i]=f[i-1];\n\t\tint val=(t[i]=='a') ? 2 : 1;\n\t\tif(~pos) {\n\t\t\tpos=pre[pos][(s[i]-val+3)%3];\n\t\t\tif(~pos) add(f[i],f[pos]);\n\t\t}\n\t\tif(!s[i] && i!=n) add(f[i],1);\n\t} cout<<f[n]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 100005;\nconst int MOD = 1e9 + 7;;\n \ntemplate <typename T> inline void read(T &AKNOI) {\n    T x = 0, flag = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') flag = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch)) {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    AKNOI = flag * x;\n}\n \nnamespace ModCalculator {\n\tinline void Inc(int &x, int y) {\n\t\tx += y; if (x >= MOD) x -= MOD;\n\t}\n\tinline void Dec(int &x, int y) {\n\t\tx -= y; if (x < 0) x += MOD;\n\t}\n\tinline int Add(int x, int y) {\n\t\tInc(x, y); return x;\n\t}\n\tinline int Sub(int x, int y) {\n\t\tDec(x, y); return x;\n\t}\n\tinline int Mul(int x, int y) {\n\t\treturn 1LL * x * y % MOD;\n\t}\n}\nusing namespace ModCalculator;\n\nchar s[MAXN];\nint n, sum[MAXN], nxt[MAXN][3];\nint dp[MAXN], ans;\n\nvoid init() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n}\n\nvoid solve() {\n\tbool flag = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (s[i] == s[i + 1]) {\n\t\t\tflag = 0; break;\n\t\t}\n\t}\n\tif (flag) {\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tsum[i] = (sum[i - 1] + (s[i] - 'a' + 1)) % 3;\n\t}\n\tnxt[n][0] = nxt[n][1] = nxt[n][2] = n + 1;\n\tfor (int i = n; i >= 0; --i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tnxt[i][j] = nxt[i + 1][j];\t\n\t\t}\n\t\tnxt[i][sum[i + 1]] = i + 1;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tif (i && sum[i] == sum[n]) {\n\t\t\tInc(ans, dp[i]);\n\t\t}\n\t\tfor (int j = 1; j < 3; ++j) {\n\t\t\tInc(dp[nxt[i][(sum[i] + j) % 3]], dp[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\nconst ll M = 1000000007;\n\nint main(){\n  string s;\n  cin >> s;\n  ll dp[3] = {};\n    dp[1] = dp[2] = 1;\n    ll ret[3] = {};\n  int cnt = 100002;\n  for(int i = 0 ; i < s.size() ; i ++){\n    if(s[i] == 'a')cnt ++;\n    else cnt --;\n      ret[cnt%3] += dp[cnt%3];\n    for(int k = 0 ; k < 3 ; k ++){\n        if(k == cnt%3)continue;\n      dp[k] += dp[cnt%3];\n      if(dp[k] >= M)dp[k] -= M;\n    }\n      dp[cnt%3] = 0;\n  }\n  for(int i = 0 ; i+1 < s.size() ; i ++){\n    if(s[i] == s[i+1]){\n      cout << ret[cnt%3]%M << endl;\n      return 0;\n    }\n  }\n  cout << 1 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n  if(abs(a) < eps && abs(b) < eps) return 0;\n  else if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n  if(a < b) return -1;\n  return 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n  if(a < b) return -1;\n  if(a == b) return 0;\n  return 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n  if(na == 0) return 0;\n  int be = 0, en = na - 1;\n  if(*a <= *(a + na - 1)){\n    if(f_lb == 0) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != 1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != -1) en = mid;\n      else be = mid + 1;\n    }\n    if(f_small && jud(*(a + be), val) == 1) be--;\n    if(!f_small && jud(*(a + be), val) == -1) be++;\n  } else {\n    if(f_lb) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != -1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != 1) en = mid;\n      else be = mid + 1;\n    }\n    if(!f_small && jud(*(a + be), val) == -1) be--;\n    if(f_small && jud(*(a + be), val) == 1) be++;\n  }\n  return be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n  if(m < 0) return 0;\n  long long ans = 1;\n  long long k = n;\n  while(m){\n    if(m & 1) {\n      ans *= k;\n      if(mod) ans %= mod;\n    }\n    k *= k;\n    if(mod) k %= mod;\n    m >>= 1;\n  }\n  return ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n  if(mod == -1) mod = MOD;\n  a += b;\n  while(a >= mod) a -= mod;\n  while(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    cerr << arr[i] << ' ';\n  cerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    output1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 100100;\nconst int mod = MOD;\nchar orig[maxn];\nint sum_mod[maxn], nxt[maxn][4];\nint dp[maxn];\n\nint main() {\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n  ios_base::sync_with_stdio(0);\n  #ifdef DEBUG //......................................................................................................\n  freopen(\"input.txt\", \"r\", stdin);\n  #endif //...........................................................................................................\n\n  scanf(\"%s\", orig);\n  int n = strlen(orig);\n  nxt[n][0] = n;\n  nxt[n][1] = nxt[n][2] = nxt[n][3] = -1;\n  for (int i = n - 1; i >= 0; i--) {\n    memcpy(nxt[i], nxt[i + 1], sizeof(nxt[i]));\n    sum_mod[i] = sum_mod[i + 1] + (orig[i] == 'a' ? 2 : 1);\n    sum_mod[i] %= 3;\n    nxt[i][sum_mod[i]] = i;\n    if (orig[i] == orig[i + 1]) nxt[i][3] = i + 2;\n  }\n\n  dp[0] = 1;\n  ll ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (nxt[i][3] == -1) {\n      add(ans, dp[i]);\n      continue;\n    }\n    add(dp[i + 1], dp[i]);\n    int cate = (sum_mod[i] + 1) % 3;\n    if (orig[i] == 'a') cate = (sum_mod[i] + 2) % 3;\n    int nxt_loc = nxt[nxt[i][3]][cate];\n    if (nxt_loc != -1) {\n      add(dp[nxt_loc], dp[i]);\n      if (nxt[nxt_loc][3] == -1) {\n        int cnt = n - nxt_loc;\n        if (orig[i] == orig[nxt_loc]) cnt = (n - nxt_loc) / 2;\n        else {\n          if (nxt[i + 1][3] != -1) {\n            cnt = (n - nxt_loc) / 2;\n          }\n        }\n        add(ans, 1ll * cnt * dp[i]);\n        if (sum_mod[i])\n          add(ans, mod - dp[i]);\n      }\n    }\n    if (sum_mod[i]) {\n      add(ans, dp[i]);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nstring s;\nint N;\n\nbool alternate(){\n\trep(i,N-1) if(s[i]==s[i+1]) return false;\n\treturn true;\n}\n\nvector<int> acm;\nvector<int> a2vs[3];\nvector<mint> dp;\n\nint main(){\n\tcin>>s;\n\tN = s.size();\n\tif(alternate()){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tint X = 0;\n\trep(i,N-1) if(s[i] != s[i+1]) X = i+1;\n\n\tacm.resize(N+1);\n\trep(i,N) acm[i+1] = acm[i] + (s[i]=='a' ? 1 : 2);\n\trep(i,N+1) acm[i] %= 3;\n\trep(i,N+1) a2vs[acm[i]].pb(i);\n\n\tdp.resize(N+1);\n\tdp[0] = 1;\n\trep(i,N){\n\t\trep(c,2){\t//a,b\n\t\t\tint tar = (acm[i] + 1 + c)%3;\n\t\t\tint id = lower_bound(all(a2vs[tar]),i) - a2vs[tar].begin();\n\t\t\tif(id == a2vs[tar].size()) continue;\n\t\t\tint ni = a2vs[tar][id];\n\t\t\tdp[ni] += dp[i];\n\t\t}\n\t}\n\tmint ans = 0;\n\trep1(consume,N){\n\t\tif(acm[N] != acm[consume]) continue;\n\t\tans += dp[consume];\n\t}\n\tcout<<ans<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstatic const int INF=10e9+7;\ntypedef struct\n{vector<int> vec;int size;}Node;\n\n\nint main(void)\n{\n\tstring S;\n\t\tcin >> S;\n\tvector<int > SF;\n\tfor(int i=0;i<S.size();i++)\n\t{\n\t\tif(S[i]=='a')\n\t\t\tSF.push_back(-1);\n\t\telse\n\t\t\tSF.push_back(1);\n\t}\n\tNode SE;\n\tSE.vec=SF;\n\tSE.size=S.size();\n\t\n\tvector<Node> V;\n\tV.push_back(SE);\n\tint g=0;\n\twhile(V.size()>=g)\n\t{\n\t\tNode F=V[g];\n\t\tg++;\n\t\tfor(int i=0;i<F.size-1;i++)\n\t\t{\n\t\t\tif(F.vec[i]*F.vec[i+1]>0)\n\t\t\t{\n\t\t\t\tvector<int > IN;\n\t\t\t\tIN=F.vec;\n\t\t\t\tIN.erase(IN.begin()+i);\n\t\t\t\tIN[i]*=-1;\n\t\t\t\tNode INT;\n\t\t\t\tINT.vec=IN;\n\t\t\t\tINT.size=F.size-1;\n\t\t\t\tV.push_back(INT);\n\t\t\t}\n\t\t}\n\t}\t\n\tvector <vector<int> > ANS;\n\tfor(unsigned int i=0;i<V.size();i++)\n\t\tANS.push_back(V[i].vec);\n\tsort(ANS.begin(),ANS.end());\n\tANS.erase(unique(ANS.begin(),ANS.end()),ANS.end());\n\tcout << ANS.size()%INF << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=100005;\nconst int mo=1000000007;\nint n,ans;\nchar s[N];\nint las[N],S[N];\nint suf[N][3],f[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool fl=0;\n\tFor(i,1,n-1) if (s[i]==s[i+1]) fl=1;\n\tif (!fl) return puts(\"1\"),0;\n\tFor(i,1,n) S[i]=(S[i-1]+s[i]-'a'+1)%3;\n\tFor(i,0,2) suf[n+1][i]=n+1;\n\tRep(i,n,1){\n\t\tFor(j,0,2)\n\t\t\tsuf[i][j]=suf[i+1][j];\n\t\tsuf[i][S[i]]=i;\n\t}\n\tf[0]=1;\n\tFor(i,1,n+1){\n\t\tif (S[i-1]==S[n]&&i!=1) ans=(ans+f[i-1])%mo;\n\t\tint nx=suf[i+1][3-S[i-1]-S[i]];\n\t\tf[i]=(f[i]+f[i-1])%mo;\n\t\tf[nx]=(f[nx]+f[i-1])%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n/*\nbabba\nbaaa\nbba\naa\nb\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nint n,ok,ans;\nconst int N=100010,mod=1e9+7;\nint sum[N],f[N],nt[N][3];\nchar s[N];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n    for(int i=1;i<=n-1;++i)\n    \tif(s[i]==s[i+1]){ok=1;break;}\n    if(!ok)return puts(\"1\")==2333;\n    \n    for(int i=1;i<=n;++i)sum[i]=(sum[i-1]+(s[i]=='a'?1:2))%3;\n\tfor(int i=0;i<=2;++i)nt[n][i]=n+1;\n\tfor(int i=n-1;i>=0;--i)\n\t{\n\t\tfor(int j=0;j<=2;++j)nt[i][j]=nt[i+1][j];\n\t\tnt[i][sum[i+1]]=i+1;\n\t}\n\tf[0]=1;\n\tfor(int i=0;i<=n;++i)\n\t{\n\t\tfor(int j=1;j<=2;++j)(f[nt[i][(sum[i]+j)%3]]+=f[i])%=mod;\n\t\tif(i&&sum[i]==sum[n])(ans+=f[i])%=mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n\ntemplate<typename T> class BIT {\nprivate:\n\tint n;\n\tvector<T> bit;\npublic:\n\t// 0_indexed で i 番目の要素に x を加える\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile(i < n){\n\t\t\tbit[i] += x, i += i & -i;\n\t\t}\n\t}\n\t// 0_indexed で [0,i] の要素の和(両閉区間！！)\n\tT sum(int i){\n        if(i<0)return 0;\n\t\ti++;\n\t\tT s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i], i -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tBIT(){}\n\t//初期値がすべて0の場合\n\tBIT(int sz) : n(sz+1), bit(n, 0){}\n\tBIT(vector<T>& v) : n((int)v.size()+1), bit(n, 0){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tadd(i,v[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcout<<sum(i)-sum(i-1)<< \" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t//-1スタート\n\tvoid print_sum(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout<<sum(i-1)<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<mod>dp(n+1);\n    vector<int>a[3];\n    vector<int>b(n+1);\n    int c = 0;\n    rep(i,n){\n        b[i] = c;\n        c += s[i]-'a'+1;\n        c %= 3;\n        a[c].push_back(i+1);\n    }\n    a[0].push_back(n+1);\n    a[1].push_back(n+1);\n    a[2].push_back(n+1);\n    b[n] = c;\n    BIT<int> bit(n+1);\n    rep(i,n-1){\n        if(s[i]==s[i+1]){\n            bit.add(i,1);\n        }\n    } \n    dp[0] = 1;\n    rep(i,n){\n        for(int j=1;j<3;j++){\n            int ca = (b[i]+j)%3;\n            int id = i;\n            while(1){\n                int x = *upper_bound(a[ca].begin(),a[ca].end(),id);\n                id = x;\n                if(x==n+1)break;\n                if(x==i+1){\n                    dp[x] += dp[i];\n                    break;\n                }else{\n                    if(bit.sum(x-1)-bit.sum(i-2)!=0){\n                        dp[x] += dp[i];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    mod res = 0;\n    rep(i,n+1){\n        int k = (3+b[n]-b[i])%3;\n        if(k==0){\n            if(i==n){\n                res += dp[i];\n            }else{\n                if((i>=2&&s[i-1]==s[i-2])||(i>=1&&bit.sum(n-1)-bit.sum(i-2)!=0)){\n                    res += dp[i];\n                }\n            }\n        }\n        // cerr << i << \" \" << dp[i] << \" \"  << res << endl;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"1\"),0;\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,a[N],l[N],dp[N],sum[N];\nchar str[N];\ninline void add(int &x,int k){\n\tx+=k;x-=(x>=mod)?mod:0;\n}\nsigned main(){\n\tscanf(\"%s\",str+1);n=strlen(str+1);\n\tF(i,1,n) a[i]=(str[i]=='a')?1:2;\n\tint pd=0;\n\tF(i,1,n-2) pd|=(a[i]==a[i+1]);\n\tif (!pd) ret;\n\tl[1]=l[2]=-1;dp[0]=1;\n\tF(i,1,n){\n\t\tsum[i]=sum[i-1]+a[i];\n\t\tif (sum[i]%3==0&&i<n) dp[i]=1;\n\t\tF(j,1,2){\n\t\t\tif (l[(sum[i]+3-j)%3]!=-1) add(dp[i],dp[l[(sum[i]+3-j)%3]]);\n\t\t}\n\t\tl[sum[i]%3]=i;\n\t}\n\twrn(dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5+5;\nconst ll p = 1e9+7;\nconst ll inf = (1<<30);\n\nstring s;\nll v[MAXN], dp[MAXN][3], part[MAXN][3][3], r[MAXN][3], n;\nvector<int> pos[3];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> s;\n\tn = s.length();\n\tv[0] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tv[i] = (v[i-1] + 1 + (s[i-1] == 'b'))%3;\n\tn++;\n\tfor (int i = 0; i < n; ++i)\n\t\tpos[v[i]].push_back(i);\n\n\tfor (int i = n-1; i >= 0; --i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tr[i][j] = i;\n\t\t\telse\n\t\t\t\tr[i][j] = max(i+1LL, r[i+1][j]);\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tif (v[i] != k && v[i-1] == j)\n\t\t\t\t\tpart[i][j][k] = (part[i-1][j][k] + dp[i-1][j])%p;\n\t\t\t\telse\n\t\t\t\t\tpart[i][j][k] = part[i-1][j][k];\n\t\t\t}\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tcontinue;\n\t\t\t//find the range of j that \"project\" onto i\n\t\t\tint k = 3-v[i]-j;\n\t\t\t//j -> k -> v[i]\n\t\t\tint lo = 0, hi = pos[j].size();\n\t\t\t//find first guy who is >= i;\n\t\t\tif (pos[j].size() == 0)\n\t\t\t\tcontinue;\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] >= i) {\n\t\t\t\t\thi = mid;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] >= i)\n\t\t\t\t\thi = mid;\n\t\t\t\telse\n\t\t\t\t\tlo = mid+1;\n\t\t\t}\n\t\t\tif (lo == pos[j].size())\n\t\t\t\tcontinue;\n\t\t\tint val1 = pos[j][lo];\n\t\t\tlo = -1, hi = pos[j].size()-1;\n\t\t\t//find last guy who is <= i\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi+1)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] > i) {\n\t\t\t\t\thi = mid-1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] > i)\n\t\t\t\t\thi = mid-1;\n\t\t\t\telse\n\t\t\t\t\tlo = mid;\n\t\t\t}\n\t\t\tif (lo == -1)\n\t\t\t\tcontinue;\n\t\t\tint val2 = pos[j][lo];\n\t\t\tif (val1 > val2)\n\t\t\t\tcontinue;\n\t\t\tdp[i][v[i]] = (dp[i][v[i]] + part[val2+1][j][v[i]] + p - part[val1][j][v[i]])%p;\n\t\t}\n\t\tdp[i][v[i]] = (dp[i][v[i]] + dp[i-1][v[i-1]])%p;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n-2; ++i) {\n\t\tif (v[i] == v[n-1])\n\t\t\tcontinue;\n\t\tint k = 3-v[i]-v[n-1];\n\t\tif (r[i][k] >= n)\n\t\t\tcontinue;\n\t\tif (r[r[i][k]][v[n-1]] >= n)\n\t\t\tcontinue;\n\t\tans = (ans + dp[i][v[i]])%p;\n\t}\n\tans = (ans + dp[n-2][v[n-2]])%p;\n\tint g = -1;\n\tfor (int i = n-1; i >= -1; --i) {\n\t\tif (i == -1)\n\t\t\tg = -1;\n\t\tif (v[i] == v[n-2])\n\t\t\tg = i;\n\t\tif (v[i] == 3-v[n-2]-v[n-1])\n\t\t\tbreak;\n\t}\n\tif (g != -1) {\n\t\tfor (int k = g; k < n-2; k += 2)\n\t\t\tans = (ans + dp[k][v[k]])%p;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nchar s[100001];\nint r[100001][3][2];\nint sum[100001];\nint dp[100001];\n\nint main() {\n    int n, i, j, k;\n    long long ans = 0;\n    \n    scanf(\"%s\", s);\n    n = strlen(s);\n    \n    for (i = 0; i + 1 < n; i++) {\n        if (s[i] == s[i + 1]) break;\n    }\n    \n    if (i + 1 == n) {\n        puts(\"1\");\n        return 0;\n    }\n    \n    for (i = 0; i < 3; i++) {\n        for (j = 0; j < 2; j++) {\n            r[n][i][j] = -1;\n        }\n    }\n    \n    for (i = n - 1; i >= 0; i--) {\n        int c;\n        \n        if (s[i] == 'a') {\n            c = 1;\n        } else {\n            c = 2;\n        }\n        \n        sum[i] = (sum[i + 1] + c) % 3;\n        \n        for (j = 0; j < 3; j++) {\n            for (k = 0; k < 2; k++) {\n                r[i][(j + c) % 3][k] = r[i + 1][j][k];\n            }\n        }\n        r[i][c][0] = i;\n        \n        if (s[i] == s[i + 1]) {\n            for (j = 0; j < 3; j++) r[i][(j + c) % 3][1] = r[i + 1][j][0];\n        }\n    }\n    \n    dp[0] = 1;\n    \n    for (i = 0; i < n; i++) {\n        int p;\n        \n        dp[i + 1] += dp[i];\n        if (dp[i + 1] >= mod) dp[i + 1] -= mod;\n        \n        if (s[i] == 'a') {\n            p = r[i][2][1];\n        } else {\n            p = r[i][1][1];\n        }\n        \n        if (p >= 0) {\n            dp[p + 1] += dp[i];\n            if (dp[p + 1] >= mod) dp[p + 1] -= mod;\n        }\n    }\n    \n    for (i = 1; i <= n; i++) {\n        if (sum[i] == 0) ans += dp[i];\n    }\n    \n    printf(\"%lld\\n\", ans % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define Mod 1000000007\nusing namespace std;\nvoid add(int& x,int y)\n{\n\tx+=y;\n\tif(x>=Mod)x-=Mod;\n\treturn ;\n}\nint n;\nchar s[100010];\nint f[100010];\nvector<int>vec[3],pos;\nint dp[100010];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tf[i]=(f[i-1]+s[i]-'a'+1)%3;\n\tfor(int i=1;i<n;i++)\n\t\tif(s[i]==s[i+1])pos.push_back(i);\n\tpos.push_back(n);\n\tif(pos.size()==1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tvec[f[i]].push_back(i);\n\tvec[0].push_back(n+1);\n\tvec[1].push_back(n+1);\n\tvec[2].push_back(n+1);\n\tdp[0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadd(dp[i+1],dp[i]);\n\t\tint x=(*lower_bound(pos.begin(),pos.end(),i+1))+1;\n\t\tint c=((3-s[i+1]+'a'-1)%3+f[i])%3;\n\t\tx=*lower_bound(vec[c].begin(),vec[c].end(),x);\n\t\tif(x>n)continue;\n\t\tadd(dp[x],dp[i]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[n]==f[i])add(ans,dp[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define lf ('\\n')\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 100007 , mo = 1000000007;\n\nint n,val[_],las[3]={0,-1,-1};\nlint f[_]={0};\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\t\n\tn=ts(val+1);\n\tfor(int i=1;i<=n;i++)val[i]-='a'-1;\n\t\n\tint able=0;\n\tfor(int i=1;i<n;i++)if(val[i]==val[i+1])able=1;\n\tif(!able){cout<<1<<lf;return 0;}\n\n\tf[0]=1;\n\tfor(int i=1,now=0;i<=n;i++)\n\t{\n\t\tnow=(now+val[i])%3;\n\t\tif(now==0 && i<n)f[i]=1;\n\t\tnow=(now+1)%3;if(las[now]>=0)f[i]=(f[i]+f[las[now]])%mo;\n\t\tnow=(now+1)%3;if(las[now]>=0)f[i]=(f[i]+f[las[now]])%mo;\n\t\tnow=(now+1)%3,las[now]=i;\n\t}\n\tcout<<f[n]<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define foreach(i, n) for (__typeof(n.begin()) i = n.begin(); i != n.end(); ++i)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define MP make_pair\n#define PB push_back\n#define SZ(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define inf 0x3f3f3f3f\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst double eps = 1e-8;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\n#define se(x) cout<<#x<<\" = \"<<x<<endl\n\n#ifdef CHEN_PC\n\t#define debug(...) printf(__VA_ARGS__)\n#else \n\t#define debug(...)\n#endif\n\nconst int N = 100010;\nconst int mod = 1000000007; // 10^9+7\n\n// Mod int\nstruct mint {\n\tll x;\n\tmint():x(0){}\n\tmint(ll x):x((x%mod+mod)%mod){}\n\tmint& fix() { x = (x%mod+mod)%mod; return *this;}\n\tmint operator-() const { return mint(0) - *this;}\n\tmint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n\tmint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n\tmint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n\tmint operator+(const mint& a)const{ return mint(*this) += a;}\n\tmint operator-(const mint& a)const{ return mint(*this) -= a;}\n\tmint operator*(const mint& a)const{ return mint(*this) *= a;}\n\tbool operator<(const mint& a)const{ return x < a.x;}\n\tbool operator==(const mint& a)const{ return x == a.x;}\n    mint pow(ll n) const {\n        mint x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n};\ntypedef vector<mint> vm;\n\nmint dp[N];\nint sum[N];\nint nxt[N][3];\n\nint trans(char c) {\n\treturn c == 'a' ? 1 : 2;\n}\n\nint solve(char *s, int n) {\n\tbool flag = true;\n\tforn (i, n-1) {\n\t\tif (s[i] == s[i+1]) {\n\t\t\tflag = false;\n\t\t}\n\t}\n\tif (flag) {\n\t\treturn 1;\n\t}\n\n\tsum[n] = 0;\n\tnxt[n][0] = nxt[n][1] = nxt[n][2] = n + 5;\n\tford (i, n) {\n\t\tsum[i] = sum[i + 1] + trans(s[i]);\n\t\tsum[i] %= 3;\n\t\tforn (j, 3) {\n\t\t\tnxt[i][j] = nxt[i + 1][j];\n\t\t}\n\t\tnxt[i][sum[i + 1]] = i + 1;\n\t}\n\tclr(dp, 0);\n\tdp[0] = 1;\n\tforn (i, n) {\n\t\tdp[i + 1] += dp[i];\n\t\tint tag = 3 - trans(s[i]);\n\t\ttag = sum[i] - tag;\n\t\ttag = (tag % 3 + 3) % 3;\n\t\tdp[nxt[i][tag]] += dp[i];\n\t}\n\tmint ret = 0;\n\tforab (i, 1, n+1) {\n\t\tif (sum[i] == 0) {\n\t\t\tret += dp[i];\n\t\t}\n\t}\n\treturn ret.x;\n}\n\nint main(int argc, char *argv[]) {\n#ifdef CHEN_PC\n\tfreopen(\"E.in\", \"r\", stdin);\n#endif\n\n\tchar str[N];\n\tint n;\n\twhile (scanf(\"%s\", str) != EOF) {\n\t\tn = strlen(str);\n\t\tint ret = solve(str, n);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\t\t#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100,mod=1e9+7;\nll nxt[N];\nll b[N][3];\nll d[N][3];\nll a[N];\nll dp[N];\nll par[N];\nint32_t main(){\n    string s;\n    cin >> s;\n    ll n=s.size();\n    for (int i=0;i<s.size();i++){\n        a[i+1]=s[i]-'a'+1;\n    }\n    ll p1=0;\n    for (int i=1;i<n;i++) if (a[i]==a[i+1]) p1=1;\n    if (!p1) kill(1);\n    nxt[n]=n+1;\n    for (int i=n-1;i;i--){\n        if (a[i+1]==a[i]) nxt[i]=i+1;\n        else nxt[i]=nxt[i+1];\n    }\n    b[n+1][0]=n+1;\n    b[n+1][1]=n+1;\n    b[n+1][2]=n+1;\n    b[n+2][0]=n+2;\n    b[n+2][1]=n+2;\n    b[n+2][2]=n+2;\n    d[n+1][0]=n+1;\n    d[n+1][1]=n+1;\n    d[n+1][2]=n+1;\n    d[n+2][0]=n+2;\n    d[n+2][1]=n+2;\n    d[n+2][2]=n+2;\n    for (int i=n;i;i--){\n        if (a[i]==1){\n            b[i][1]=i;\n            ll z=nxt[i];\n            z--;\n            ll y=(z-i+2)/2+((z-i+1)/2)*2;\n            y%=3;\n            if (y==2){\n                b[i][2]=d[z+1][0];\n            }\n            if (y==0){\n                b[i][2]=b[z+1][2];\n            }\n            if (y==1){\n                b[i][2]=b[z+1][1];\n            }\n        }\n        else if (a[i]==2){\n            b[i][2]=i;\n            ll z=nxt[i];\n            z--;\n            ll y=((z-i+2)/2)*2+(z-i+1)/2;\n            y%=3;\n            if (y==1){\n                b[i][1]=d[z+1][0];\n            }\n            if (y==0){\n                b[i][1]=b[z+1][1];\n            }\n            if (y==2){\n                b[i][1]=b[z+1][2];\n            }\n        }\n        for (int j=0;j<3;j++){\n            if (j==a[i]){\n                d[i][j]=i;\n                continue;\n            }\n            ll z=j+a[i];\n            z%=3;\n            d[i][j]=d[i+1][z];\n        }\n        for (int j=0;j<3;j++){\n            if (b[i][j]>n || b[i][j]==0) b[i][j]=n+1;\n            if (d[i][j]>n || d[i][j]==0) d[i][j]=n+1;\n        }\n\n    }\n    for (int i=n;i;i--) par[i]=a[i]+par[i+1],par[i]%=3;\n    //dp[n+1]=1;\n   // dp[n]=1;\n    for (int i=n;i;i--){\n     //   cout << i << \" \" << par[i] << \" \" << nxt[i] << \" \" << b[i][1] << \" \" << b[i][2] << endl;\n        if (par[i]) dp[i]++;\n        dp[i]+=dp[b[i][1]+1];\n        dp[i]+=dp[b[i][2]+1];\n        dp[i]%=mod;\n    }\n    cout << dp[1] << endl;\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=100007,P=1000000007;\nchar str[N];int a[N],f[N],las[3];\nint main()\n{\n    scanf(\"%s\",str+1);int n=strlen(str+1),flg=0;\n    for(int i=1;i<=n;++i) if(a[i]=(a[i-1]+str[i]-'a'+1)%3,str[i]==str[i-1]) flg=1;\n    if(!flg) return puts(\"1\"),0;;\n    for(int i=1;i<=n;++i) f[i]=(1ll*f[las[0]]+f[las[1]]+f[las[2]]+(a[i]>=1)-f[las[a[i]]]+P)%P,las[a[i]]=i;\n    printf(\"%d\",f[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define DIM 100005\n#define mod 1000000007\nusing namespace std;\nint n, i, j, x, sol, ok;\nchar s[DIM];\nint sum[DIM], prv[DIM][3], d[DIM];\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    prv[0][0] = prv[0][1] = prv[0][2] = -1;\n    for(i = 1; i <= n; i++){\n        sum[i] = (sum[i - 1] + s[i] - 'a' + 1) % 3;\n        if(s[i] == s[i - 1]){\n            ok = 1;\n        }\n        prv[i][0] = prv[i - 1][0];\n        prv[i][1] = prv[i - 1][1];\n        prv[i][2] = prv[i - 1][2];\n        prv[i][ sum[i - 1] ] = i - 1;\n    }\n    if(ok == 0){\n        cout<< 1;\n        return 0;\n    }\n    d[0] = 1;\n    for(i = 1; i <= n; i++){\n        for(j = 1; j <= 2; j++){\n            x = (sum[i] - j + 3) % 3;\n            if(prv[i][x] != -1){\n                d[i] = (d[i] + d[ prv[i][x] ]) % mod;\n            }\n        }\n        if(sum[i] == sum[n]){\n            d[i] = (d[i] + 1) % mod;\n        }\n    }\n    cout<< (d[n] - 1 + mod) % mod;;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nint nex[101010][2];\nint F[101010];\nint tmp[3];\nll dp[101010];\nll mo=1000000007;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S;\n\tN=S.size();\n\tFOR(i,N-1) if(S[i]==S[i+1]) break;\n\tif(i==N-1) return _P(\"1\\n\");\n\t\n\tFOR(i,N) {\n\t\tS[i]-='a'-1;\n\t\tF[i+1]=(F[i]+S[i])%3;\n\t}\n\tnex[N][0]=nex[N][1]=N+1;\n\ttmp[0]=tmp[1]=tmp[2]=N+1;\n\tint pn=N;\n\tfor(i=N-1;i>=0;i--) {\n\t\tif(i<N-1 && S[i]==S[i+1]) {\n\t\t\twhile(pn>i) tmp[F[pn]]=pn, pn--;\n\t\t}\n\t\tif(S[i]==1) {\n\t\t\tnex[i][0]=i+1;\n\t\t\tnex[i][1]=tmp[(F[i]+2)%3];\n\t\t}\n\t\telse {\n\t\t\tnex[i][1]=i+1;\n\t\t\tnex[i][0]=tmp[(F[i]+1)%3];\n\t\t}\n\t}\n\tdp[0]=1;\n\tFOR(i,N) {\n\t\tif(nex[i][0]<=N) (dp[nex[i][0]]+=dp[i])%=mo;\n\t\tif(nex[i][1]<=N) (dp[nex[i][1]]+=dp[i])%=mo;\n\t}\n\tll ret=0;\n\tfor(i=1;i<=N;i++) if(F[i]==F[N]) ret+=dp[i];\n\tcout<<ret%mo<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst ll MOD = 1e9 + 7;\n\nstring s;\nint sm[210000];\nint nx[3];\nint go[210000][3];\nll dp[210000];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tint fl = 0;\n\tcin >> s;\n\tfor (int i = 0; i + 1 < s.size(); ++i) {\n\t\tif (s[i] == s[i + 1]) {\n\t\t\tfl = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!fl) {\n\t\tcout << 1 << \"\\n\";\n\t\treturn 0;\n\t}\n\tint n = s.size();\n\tsm[n] = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif (s[i] == 'a')\n\t\t\tsm[i] = sm[i + 1] + 1;\n\t\telse\n\t\t\tsm[i] = sm[i + 1] - 1;\n\t\tsm[i] = (sm[i] + 3) % 3;\n\t}\n\tfor (int i = 0; i < 3; ++i)\n\t\tnx[i] = -1;\n\tint lst = n;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif (lst > i + 1 && s[i + 1] == s[i]) {\n\t\t\twhile (lst > i + 1) {\n\t\t\t\tnx[sm[lst]] = lst;\n\t\t\t\t--lst;\n\t\t\t}\n\t\t}\n\t\tif (s[i] == 'a') {\n\t\t\tgo[i][0] = i + 1;\n\t\t\tgo[i][1] = nx[(sm[i] + 1) % 3];\n\t\t}\n\t\telse {\n\t\t\tgo[i][1] = i + 1;\n\t\t\tgo[i][0] = nx[(sm[i] + 2) % 3];\n\t\t}\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tif (go[i][j] != -1)\n\t\t\t\tdp[go[i][j]] = (dp[go[i][j]] + dp[i]) % MOD;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (sm[i] == 0)\n\t\t\tans = (ans + dp[i]) % MOD;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=1e5+5;\nchar s[N];int a[N],f[N],las[N],n,fl;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfp(i,1,n)if(a[i]=(a[i-1]+s[i]-'a'+1)%3,s[i]==s[i-1])fl=1;\n\tif(!fl)return puts(\"1\"),0;\n\tfp(i,1,n)f[i]=(0ll+f[las[0]]+f[las[1]]+f[las[2]]+(a[i]>=1)-f[las[a[i]]])%P,las[a[i]]=i;\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//problem:agc027_e\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mk make_pair\n#define lob lower_bound\n#define upb upper_bound\n#define fst first\n#define scd second\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ninline int read(){\n\tint f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll readll(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN=1e5+5,MOD=1e9+7;\ninline int mod(int x){return x<MOD?x:x-MOD;}\nset<int>st[3];\nint n,nxt[MAXN],f[MAXN];\nchar s[MAXN];\nint main() {\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=1;i<=n;++i){\n\t\tbool flag=(s[1]!=s[2]);\n\t\tif(flag)for(int i=3;i<=n;i+=2)if(s[i]!=s[1]){flag=0;break;}\n\t\tif(flag)for(int i=4;i<=n;i+=2)if(s[i]!=s[2]){flag=0;break;}\n\t\tif(flag)return puts(\"1\"),0;\n\t}\n\tfor(int i=1,sum=0;i<=n;++i){if(s[i]=='a')sum=(sum+1)%3;else sum=(sum+2)%3;st[sum].insert(i);}\n\tnxt[n]=n+1;for(int i=n-1,p=n+1;i>=1;--i){if(s[i]==s[i+1])p=i+1;nxt[i]=p;}\n\t//for(int i=1;i<=n;++i)cout<<nxt[i]<<\" \";cout<<endl;\n\tf[0]=1;\n\tfor(int i=0,sum=0;i<n;(sum+=((s[++i]=='a')?1:2))%=3){\n\t\t//下一位是a\n\t\tif(s[i+1]=='a')f[i+1]=mod(f[i+1]+f[i]);\n\t\telse{\n\t\t\tint t=(sum+1)%3;\n\t\t\tset<int>::iterator it=st[t].lob(nxt[i+1]);\n\t\t\tif(it!=st[t].end())f[*it]=mod(f[*it]+f[i]);\n\t\t}\n\t\t//下一位是b\n\t\tif(s[i+1]=='b')f[i+1]=mod(f[i+1]+f[i]);\n\t\telse{\n\t\t\tint t=(sum+2)%3;\n\t\t\tset<int>::iterator it=st[t].lob(nxt[i+1]);\n\t\t\tif(it!=st[t].end())f[*it]=mod(f[*it]+f[i]);\n\t\t}\n\t}\n\t//for(int i=1;i<=n;++i)cout<<f[i]<<\" \";cout<<endl;\n\tint ans=f[n];\n\tfor(int i=n,sum=0;i>1;--i){\n\t\t(sum+=((s[i]=='a')?1:2))%=3;\n\t\tif(sum==0)ans=mod(ans+f[i-1]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (2)\n#pragma G++ optimize (2)\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define mod 1000000007\n#define MAX 100005\nusing namespace std;\n//char nc()\n//{\n//\tstatic char buf[100000],*p1=buf,*p2=buf;\n//\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\nchar nc(){return getchar();}\nint read()\n{\n\tint x=0,y=1;\n\tchar c=nc();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')y=-1;\n\t\tc=nc();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=nc();\n\t}\n\treturn x*y;\n}\nint n,lst[3],sm[MAX];\nchar s[MAX];\nlong long f[MAX];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool flag=false;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i>1&&s[i]==s[i-1]) flag=true;\n\t\tsm[i]=(sm[i-1]+(s[i]-96))%3;\n\t}\n\tif(!flag) return puts(\"1\"),0;  //abababa....\n\tfor(int i=1;i<=n;i++)  //我们如果倒序考虑s,那么除了第一个串以外(即除最短划分外,额外包含一个sm%3==0的前缀),其余一定是最短划分 \n\t{\n\t\tf[i]=(f[lst[(sm[i]+1)%3]]+f[lst[(sm[i]+2)%3]]+(sm[i]?1:0))%mod; //新增a,新增b,成为一个新的串\n\t\tlst[sm[i]]=i;  //对于lst,abababa...出现一定早于余数相同的a/b,因此合法 \n\t}\n\tprintf(\"%lld\",f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500005\nconst int mod = 1e9+7;\nusing namespace std;\nchar s[N];\nint n, a[N], nxt[3], f[N];\ninline void solve() {\n  for (int i = 0; i < 3; i++)\n    if (i == a[n]) nxt[i] = n;\n    else nxt[i] = n+1;\n  f[n] = 1;\n  for (int i = n-1; i; i--) {\n    f[i] = (a[i] == a[n]);\n    for (int c = 1; c <= 2; c++) {\n      f[i] = (f[i] + f[nxt[(a[i]+c)%3]])%mod;\n    }\n    nxt[a[i]] = i;\n  }\n  printf(\"%d\\n\", (f[nxt[1]] + f[nxt[2]]) % mod);\n}\nint main() {\n  scanf(\"%s\",s+1);\n  n = strlen(s+1);\n  for (int i = 1; i <= n; i++) \n    a[i] = (a[i-1]+s[i]-'a'+1)%3;\n  for (int i = 2; i <= n; i++)\n    if (s[i] == s[i-1]) {\n      solve();\n      return 0;\n    }\n  puts(\"1\");\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=1e5+10,mod=1e9+7;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nvoid ad(int &x,int y){x+=y,x-=x>=mod?mod:0;}\nchar cc[N];\nint n,k,f[N],c[3];\n\nint main()\n{\n/////////ghdhdjfjhfjkghjgk\n\tscanf(\"%s\",cc+1),n=strlen(cc+1);\n\tbool fg=1;\n\tfor(int i=1;i<n;++i) fg&=cc[i]!=cc[i+1];\n\tif(fg){puts(\"1\");exit(0);}\n\tf[0]=1;\n\tc[1]=c[2]=-1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tk+=cc[i]-'a'+1,k%=3;\n\t\tif(!k&&i<n) f[i]=1;\n\t\tif(c[(k+1)%3]>=0) ad(f[i],f[c[(k+1)%3]]);\n\t\tif(c[(k+2)%3]>=0) ad(f[i],f[c[(k+2)%3]]);\n\t\tc[k]=i;\n\t}\n\t/*c[1]=c[2]=-1,f[0]=f[1]=1,s[0]=0,s[1]=cc[1]=='a'?1:2;\n\tk=1;\n\twhile(k<n&&cc[k]!=cc[k+1]) ++k;\n\tfor(int i=2,j=-1;i<=n;++i)\n\t{\n\t\tif(i<=k){f[i]=1;continue;}\n\t\tf[i]=f[i-1];\n\t\ts[i]=(s[i-1]+(cc[i]=='a'?1:2))%3;\n\t\tif(cc[i-1]==cc[i])\n\t\t\twhile(j+1<i-1) ++j,itt(j);\n\t\tif(cc[i]=='a')\n\t\t\tif(c[(s[i]-2+3)%3]>=0) ad(f[i],g[c[(s[i]-2+3)%3]]);\n\t\tif(cc[i]=='b')\n\t\t\tif(c[(s[i]-1+3)%3]>=0) ad(f[i],g[c[(s[i]-1+3)%3]]);\n\t\tad(f[i],z[(s[i]-1+3)%3]),ad(f[i],z[(s[i]-2+3)%3]);\n\t\tif(cc[i-1]==cc[i])\n\t\t\twhile(j<i-1) ++j,itt(j);\n\t\tif(i>k+1&&j==k&&(bool)((s[i]-s[k]+3)%3)) ad(f[i],mod-f[k]);\n\t\tg[i]=f[i];\n\t}*/\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e5+50, mod=1e9+7;\ninline void add(int &x,int y) {x=(x+y>=mod) ? (x+y-mod) : (x+y);}\n\nchar t[N]; \nint n,ans,s[N],f[N],pre[N][3],fir[N];\n\nint main() {\n\tscanf(\"%s\",t+1); n=strlen(t+1);\n\tfor(int i=1;i<=n;i++) s[i]=(s[i-1]+t[i]-'a'+1)%3;\n\tpre[0][0]=pre[0][1]=pre[0][2]=-1;\n\tfor(int i=1;i<=n;i++) {\n\t\tpre[i][0]=pre[i-1][0];\n\t\tpre[i][1]=pre[i-1][1];\n\t\tpre[i][2]=pre[i-1][2];\n\t\tpre[i][s[i-1]]=i-1;\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfir[i]=fir[i-1];\n\t\tif(t[i]==t[i-1]) fir[i]=i;\n\t}\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tint pos=fir[i]-1;\n\t\tf[i]=f[i-1];\n\t\tint val=(t[i]=='a') ? 2 : 1;\n\t\tif(~pos) {\n\t\t\tpos=pre[pos][(s[i]-val+3)%3];\n\t\t\tif(~pos) add(f[i],f[pos]);\n\t\t}\n\t\tif(!s[i] && i!=n) add(f[i],1);\n\t} \n\tif(!fir[n]) for(int i=1;i<n;i++) if(!s[i]) add(f[n],mod-1);\n\tcout<<f[n]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 1000000007\nusing namespace std;\nchar s[101010];\nint n,suma[101010],sumb[101010],lasa[3],lasb[3]/*,nxta[101010],nxtb[101010]*/;\nll dp[101010];\nvector<int> e[101010];\nsigned main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool flag=0;\n\tfor (int i=1;i<n;i++){\n\t\tif (s[i]==s[i+1]){\n\t\t\tflag=1;break;\n\t\t}\n\t}\n\tif (!flag){\n\t\tputs(\"1\");return 0;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tsuma[i]=suma[i-1],sumb[i]=sumb[i-1];\n\t\tif (s[i]=='a') suma[i]++;\n\t\telse sumb[i]++;\n\t}\n\tmemset(lasa,-1,sizeof lasa);\n\tmemset(lasb,-1,sizeof lasb);\n\tint i;\n\tfor (i=n;~i;i--){\n\t\tint aa=(2+i+suma[i])%3,bb=(2+i+sumb[i])%3;\n\t\tif (~lasa[aa]) e[lasa[aa]].push_back(i);\n\t\tif (~lasb[bb]) e[lasb[bb]].push_back(i);\n\t\tlasa[(i+suma[i])%3]=i,lasb[(i+sumb[i])%3]=i;\n\t}\n\tdp[0]=1;\n\tfor (i=1;i<=n;i++){\n\t\tfor (int j:e[i]) dp[i]=(dp[i]+dp[j])%ljc;\n\t}\n\tll _=0;\n\tfor (i=1;i<=n;i++){\n\t\tif (!((n+suma[n]-(suma[i]+i)%3)%3)) _=(_+dp[i])%ljc;\n\t}\n\tcout<<_;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5+5;\nconst ll p = 1e9+7;\nconst ll inf = (1<<30);\n\nstring s;\nll v[MAXN], dp[MAXN][3], part[MAXN][3][3], r[MAXN][3], n;\nvector<int> pos[3];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> s;\n\tn = s.length();\n\tv[0] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tv[i] = (v[i-1] + 1 + (s[i-1] == 'b'))%3;\n\tn++;\n\tfor (int i = 0; i < n; ++i)\n\t\tpos[v[i]].push_back(i);\n\n\tfor (int i = n-1; i >= 0; --i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tr[i][j] = i;\n\t\t\telse\n\t\t\t\tr[i][j] = max(i+1LL, r[i+1][j]);\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tif (v[i] != k && v[i-1] == j)\n\t\t\t\t\tpart[i][j][k] = (part[i-1][j][k] + dp[i-1][j])%p;\n\t\t\t\telse\n\t\t\t\t\tpart[i][j][k] = part[i-1][j][k];\n\t\t\t}\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tcontinue;\n\t\t\t//find the range of j that \"project\" onto i\n\t\t\tint k = 3-v[i]-j;\n\t\t\t//j -> k -> v[i]\n\t\t\tint lo = 0, hi = pos[j].size();\n\t\t\t//find first guy who is >= i;\n\t\t\tif (pos[j].size() == 0)\n\t\t\t\tcontinue;\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] >= i) {\n\t\t\t\t\thi = mid;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] >= i)\n\t\t\t\t\thi = mid;\n\t\t\t\telse\n\t\t\t\t\tlo = mid+1;\n\t\t\t}\n\t\t\tif (lo == pos[j].size())\n\t\t\t\tcontinue;\n\t\t\tint val1 = pos[j][lo];\n\t\t\tlo = -1, hi = pos[j].size()-1;\n\t\t\t//find last guy who is <= i\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi+1)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] > i) {\n\t\t\t\t\thi = mid-1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] > i)\n\t\t\t\t\thi = mid-1;\n\t\t\t\telse\n\t\t\t\t\tlo = mid;\n\t\t\t}\n\t\t\tif (lo == -1)\n\t\t\t\tcontinue;\n\t\t\tint val2 = pos[j][lo];\n\t\t\t// cout << i << ' ' << j << ' ' << val1 << ' ' << val2 << endl;\n\t\t\tif (val1 > val2)\n\t\t\t\tcontinue;\n\t\t\tdp[i][v[i]] = (dp[i][v[i]] + part[val2+1][j][v[i]] + p - part[val1][j][v[i]])%p;\n\t\t}\n\t\tdp[i][v[i]] = (dp[i][v[i]] + dp[i-1][v[i-1]])%p;\n\t\t// cout << dp[i][v[i]] << endl;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n-2; ++i) {\n\t\tif (v[i] == v[n-1])\n\t\t\tcontinue;\n\t\tint k = 3-v[i]-v[n-1];\n\t\tif (r[i][k] >= n)\n\t\t\tcontinue;\n\t\tif (r[r[i][k]][v[n-1]] >= n)\n\t\t\tcontinue;\n\t\tans = (ans + dp[i][v[i]])%p;\n\t}\n\tans = (ans + dp[n-2][v[n-2]])%p;\n\tint g = -1;\n\tfor (int i = n-1; i >= -1; --i) {\n\t\tif (i == -1)\n\t\t\tg = -1;\n\t\tif (v[i] == v[n-2])\n\t\t\tg = i;\n\t\tif (v[i] == 3-v[n-2]-v[n-1])\n\t\t\tbreak;\n\t}\n\tif (g != -1 && g != n-2)\n\t\tans = (ans + dp[g][v[g]])%p;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\n\nint n, f[101000], las[3];\nchar s[101000];\n\nint main(){\n    cin>>s+1; n=strlen(s+1);\n    for (int i=2;;++i){\n        if (i>n) return puts(\"1\"), 0;\n        if (s[i]==s[i-1]) break;\n    }\n    las[0]=n+1; las[1]=las[2]=n+2;\n    int sum=0; f[n+1]=1;\n    for (int i=n;i>=1;--i){\n        sum=(sum+1+(s[i]=='b'))%3;\n        f[i]=f[i+1];\n        int aim=(sum-1-(s[i]=='a')+3)%3;\n        f[i]=(f[i]+f[las[aim]])%mod;\n        las[sum]=i;\n        if (!sum&&i>1) f[i]=(f[i]+1)%mod;\n    }\n    cout<<f[1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = int(1e9) + 7;\n\nchar S[100500];\nint P[100500];\n\nint nxt[100500][3];\nint ways[100500];\n\nint main()\n{\n    scanf(\"%s\", S+1);\n    int N = strlen(S+1);\n\n    // 1. XYXYXY.. 또는 YXYXYX.. 꼴이면 답 무조건 1\n    bool is_alternating = true;\n    for(int i = 1; i <= N; i++) {\n      if(S[i] == S[i-1]) {\n        is_alternating = false;\n      }\n    }\n    if(is_alternating) {\n      puts(\"1\");\n      continue;\n    }\n\n    int prv[3] = {0, -1, -1};\n    for(int i = 1; i <= N; i++) {\n      P[i] = (P[i-1] + \"12\"[S[i] - 'a'] - '0') % 3;\n      for(int j = prv[P[i]]+1; j <= i; j++) {\n        nxt[j][P[i]] = i;\n      }\n      prv[P[i]] = i;\n    }\n\n    for(int p = 0; p < 3; p++) {\n      for(int j = prv[p]+1; j <= N; j++) {\n        nxt[j][p] = N+1;\n      }\n    }\n\n    for(int i = 0; i <= N; i++) ways[i] = 0;\n    ways[0] = 1;\n    for(int i = 0; i <= N; i++) {\n      for(int p = 0; p < 3; p++) {\n        if(p != P[i]) (ways[nxt[i][p]] += ways[i]) %= MOD;\n      }\n    }\n\n    int ans = 0;\n    for(int i = 1; i <= N; i++) {\n      if((P[N] - P[i] + 3) % 3 == 0) {\n        (ans += ways[i]) %= MOD;\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst int mod = 1e9 + 7;\n\nint n;\nstring s;\nint f[N], sum[N];\nint nxt[N][3], eq[N];\n\nvoid add(int &x,int y) {\n\tx += y; if (x >= mod) x -= mod;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> s; n = s.size(); s = '~' + s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tsum[i] = (sum[i - 1] + (s[i] == 'a' ? 1 : 2)) % 3;\n\t}\n\tfor (int i = 0; i < 3; ++i) nxt[n + 1][i] = n + 1;\n\tfor (int i = n; i >= 1; --i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tnxt[i][j] = nxt[i + 1][j];\n\t\t}\n\t\tnxt[i][sum[i]] = i;\n\t} \n\teq[n] = n;\n\tfor (int i = n - 1; i >= 1; --i) {\n\t\tif (s[i] == s[i + 1]) eq[i] = i;\n\t\telse eq[i] = eq[i + 1];\n\t}\n\tif (eq[1] == n) return cout << 1 << '\\n',0;\n\tf[0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int t = 1; t <= 2; ++t) {\n\t\t\tint want = (sum[i] + t) % 3;\n\t\t\tif (sum[i + 1] == want) add(f[i + 1], f[i]);\n\t\t\telse {\n\t\t\t\tint pos = nxt[eq[i] + 1][want];\n\t\t\t\tif (pos <= n) add(f[pos], f[i]);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 1; i <= n; ++i) if (sum[i] == sum[n]) add(res, f[i]);\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nsigned main(){\n\tstring s;\n\tcin>>s;\n\tint n=s.size(),MOD=1000000007;\n\t\n\tbool h=true;\n\trep(i,n-1)if(s[i]==s[i+1])h=false;\n\tif(h){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\t\n\tvi c(n+1);\n\trep(i,n)c[i+1]=s[i]-'a'+1;\n\trep(i,n)(c[i+1]+=c[i])%=3;\n\t\n\tvi dp(n+1);\n\tdp[0]=1;\n\trep(i,n)if(dp[i]){\n\t\trep(q,2){\n\t\t\tif(s[i]-'a'==q){\n\t\t\t\t(dp[i+1]+=dp[i])%=MOD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\th=false;\n\t\t\tloop(j,i+1,n+1){\n\t\t\t\tif(j-i-1&&s[j-1]==s[j-2])h=true;\n\t\t\t\tif(h&&q+1==(c[j]+3-c[i])%3){\n\t\t\t\t\t(dp[j]+=dp[i])%=MOD;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint out=0;\n\trep(i,n)if((c[n]+3-c[i+1])%3==0)(out+=dp[i+1])%=MOD;\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nchar str[MAXN];\nint sum[MAXN],dp[MAXN];\nvector<int> pos[3],rep;\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nint main()\n{\n    scanf(\"%s\",str+1);\n    n=strlen(str+1);\n    for(int i=1;i<=n;i++)\n    {\n        if(str[i]=='a') sum[i]=(sum[i-1]+1)%3; else sum[i]=(sum[i-1]+2)%3;\n        pos[sum[i]].push_back(i);\n        if(i<n&&str[i]==str[i+1]) rep.push_back(i);\n    }\n    if(!rep.size())\n    {\n        puts(\"1\");\n        return 0;\n    }\n    dp[0]=1;\n    for(int i=0;i<n;i++)\n    {\n        add(dp[i+1],dp[i]);\n        auto it=lower_bound(rep.begin(),rep.end(),i+1);\n        if(it==rep.end()) continue;\n        int p=*it+1;\n        for(int k=1;k<=2;k++)\n        {\n            if(k==1&&str[i+1]=='a') continue;\n            if(k==2&&str[i+1]=='b') continue;\n            int s=(sum[i]+k)%3;\n            it=lower_bound(pos[s].begin(),pos[s].end(),p);\n            if(it==pos[s].end()) continue;\n            add(dp[*it],dp[i]);\n        }\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++) if(sum[i]==sum[n]) add(ans,dp[i]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 100000\n#define MOD 1000000007\nchar s[MN+5];\nint S[MN+5],t[MN+5][3],f[MN+5];\ninline void rw(int&x,int y){if((x+=y)>=MOD)x-=MOD;}\nint main()\n{\n\tint n,i,j,ans=0;\n\tscanf(\"%s\",s+1);n=strlen(s+1); \n\tfor(i=1;i<=n;++i)S[i]=(S[i-1]+s[i]-'a'+1)%3;\n\tfor(j=0;j<3;++j)t[n+1][j]=n+1;\n\tfor(i=n;i;t[i][S[i]]=i,--i)for(j=0;j<3;++j)t[i][j]=t[i+1][j];\n\tfor(f[0]=i=1;i<=n;(S[n]-S[i])%3?0:(rw(ans,f[i]),0),++i)\n\t\tfor(j=1;j<3;++j)rw(f[t[i][(S[i-1]+j)%3]],f[i-1]);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 1e5+233;\nconst int mod = 1e9+7;\nvoid add(int &x,int v){\n\tx+=v;\n\tif(x>=mod) x-=mod;\n}\nchar t[maxn]; \nint n,ans,s[maxn],dp[maxn],nxt[maxn][3];\nint main() {\n\tscanf(\"%s\",t+1);n=strlen(t+1);\n\tbool flag=0;\n\tRep(i,1,n-1) if (t[i]==t[i+1]) flag=1;\n\tif (!flag) return puts(\"1\"),0;\n\tRep(i,1,n) s[i]=t[i]-'a'+1;\n\tRep(i,1,n+1) s[i]=(s[i]+s[i-1])%3;\n\tRep(i,0,2) nxt[n+1][i]=n+1;\n\tDep(i,n,1){\n\t\tRep(j,0,2) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][s[i]]=i;\n\t}\n\tdp[1]=1;\n\tRep(i,1,n+1){\n\t\tRep(k,1,2)\n\t\t\tif(nxt[i][(s[i-1]+k)%3] != n+1)\n\t\t\t\tadd(dp[nxt[i][(s[i-1]+k)%3]+1],dp[i]);\n\t\tif(s[i-1]==s[n]&&i!=1) add(ans,dp[i]);\n\t}\n\twriteln(ans);\n}\n\n//0 1 2 3 4 5 \n//0 1 2 0 1 X\n"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int N = 200010, P = 1e9 + 7;\nchar s[N];\nint num[N], f[N][3][2], n, tag[N], pre[N], ans, sam[N];\nset <int> mp[3];\nint main(){\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n//\tfreopen(\"e.in\", \"r\", stdin);\n//\tfreopen(\"e.out\", \"w\", stdout);\n\tscanf(\"\\n%s\", s + 1);\n\tn = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++) num[i] = s[i] - 'a' + 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (sam[i - 1] >= i) sam[i] = sam[i - 1];\n\t\telse {\n\t\t\tsam[i] = n;\n\t\t\tfor (int j = i; j < n; j++)\n\t\t\t\tif (num[j] == num[j + 1]){\n\t\t\t\t\tsam[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; i--) tag[i] = tag[i + 1] | (num[i] == num[i - 1]); \n\tfor (int i = 1; i <= n; i++){\n\t\tpre[i] = (pre[i - 1] + num[i]) % 3;\n\t\tmp[pre[i]].insert(i);\n\t}\n\tmp[0].insert(n + 1), mp[1].insert(n + 1), mp[2].insert(n + 1);\n\t\n\tint cnt = 1;\n\tint j = *mp[1].upper_bound(sam[1]);\n\tif (num[1] == 1) j = 1;\n\tif (j <= n){\n\t\tif (j > 1) f[j][1][0] = (f[j][1][0] + cnt) % P;\n\t\t\telse f[j][1][1] = (f[j][1][1] + cnt) % P;\n\t}\n\tj = *mp[2].upper_bound(sam[1]);\n\tif (num[1] == 2) j = 1;\n\tif (j <= n){\n\t\tif (j > 1) f[j][2][0] = (f[j][2][0] + cnt) % P;\n\t\t\telse f[j][2][1] = (f[j][2][1] + cnt) % P;\n\t}\n\t\n\tfor (int i = 1; i < n; i++){\n\t\tfor (int j = 1; j <= 2; j++){\n\t\t\tint cnt = (f[i][j][0] + f[i][j][1]) % P;\n\t\t\tint k = *mp[(pre[i] + 1) % 3].upper_bound(sam[i + 1]);\n\t\t\tif (num[i + 1] == 1) k = i + 1;\n\t\t\tif (k <= n){\n\t\t\t\tif (k > i + 1 || j == 1) f[k][1][0] = (f[k][1][0] + cnt) % P;\n\t\t\t\t\telse f[k][1][1] = (f[k][1][1] + cnt) % P;\n\t\t\t}\n\t\t\tk = *mp[(pre[i] + 2) % 3].upper_bound(sam[i + 1]);\n\t\t\tif (num[i + 1] == 2) k = i + 1;\n\t\t\tif (k <= n){\n\t\t\t\tif (k > i + 1 || j == 2) f[k][2][0] = (f[k][2][0] + cnt) % P;\n\t\t\t\t\telse f[k][2][1] = (f[k][2][1] + cnt) % P;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tif (pre[n] - pre[i] == 0){\n\t\t\tans = ((ans + f[i][1][1]) % P + f[i][2][1]) % P;\n\t\t\tans = ((ans + f[i][1][0]) % P + f[i][2][0]) % P;\n\t\t}\n\tif (sam[1] == n)\n\t\tprintf(\"%d\\n\", 1);\n\t\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <map>\n#include <set>\n#include <list>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define mp make_pair\n#define MOD (ll)(1e9+7)\n\nchar s[101010];\nll dp[101010][2];\nll i, j, k,o;\n\nint main(){\n    scanf(\"%s\",s);\n    for (i = 1; s[i];i++){\n        if(s[i]==s[i-1]){\n            break;\n        }\n    }\n    if(s[i]=='\\0'){\n        printf(\"1\");\n        return 0;\n    }\n    \n    for (i = 0; s[i];i++){\n        ll ab = (s[i] - 'a');\n        dp[i + 1][ab] = (dp[i][ab] + dp[i][!ab]) % MOD;\n        dp[i + 1][!ab] = (dp[i][ab]) % MOD;\n        if(o==0){\n            dp[i + 1][ab]++;\n            dp[i + 1][ab] %= MOD;\n        }\n        o = (o + ab + 1) % 3;\n    }\n    printf(\"%lld\", (dp[i][0]+dp[i][1])%MOD);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint change_time = 0;\nchar maked_word[1000][100001] = {{'\\0'}};\nint temp = 0;\n\nchar* change(int t,char *s,char sw)\n{\n\tchar ret[100001];\n\tfor(int i =0;i<t;i++)\n\t{\n\t\tret[i] = s[i];\n\t}\n\tret[t] = sw;\n\tfor(int i=t+1;s[i+1] != '\\0';i++)\n\t{\n\t\tret[i] = s[i+1];\n\t}\n\n\treturn ret;\n}\n\n\nvoid saiki(char *s)\n{\n\t//printf(\"%s\\n\",s);\n\tfor(int i =0;i<change_time;i++)\n\t{\n\t\tif(strcmp(maked_word[i],s) == 0)\n\t\t{\n\t\t\tchange_time -=1;\n\t\t\treturn;\n\t\t\tbreak;\n\t\t}else\n\t\t{\n\t\t\tstrcpy(maked_word[change_time],s);\n\t\t}\n\t}\n\tchange_time++;\n\tint num=0;\n\tfor(int i=0;s[i] != '\\0';i++)\n\t{\n\t\tnum++;\n\t}\n\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tif(s[i] == 'a' && s[i+1] == 'a')\n\t\t{\n\t\t\tchar *ss = change(i,s,'b');\n\t\t\tsaiki(ss);\n\t\t}\n\t\tif(s[i] == 'b' && s[i+1] == 'b')\n\t\t{\n\t\t\tchar *ss =change(i,s,'a');\n\t\t\tsaiki(ss);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tchar s[100001];\n\tscanf(\"%s\",s);\n\tsaiki(s);\n\tprintf(\"%d\\n\",change_time);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (100010)\n#define P (1000000007)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nchar s[N]; int n,f[N];\nint main(){\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tbool fl=0; for(int i=1;i<=n;i++)if(s[i]==s[i-1])fl=1;\n\tif(!fl){puts(\"1\");return 0;}\n\tint S=0,p[3]={0,-1,-1}; f[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\t(S+=s[i]-'a'+1)%=3;\n\t\tif(S==0&&i<n)f[i]++;\n\t\tif(p[(S+1)%3]!=-1)(f[i]+=f[p[(S+1)%3]])%=P;\n\t\tif(p[(S+2)%3]!=-1)(f[i]+=f[p[(S+2)%3]])%=P;\n\t\tp[S]=i;\n\t}\n\tprintf(\"%d\\n\",f[n]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nconstexpr int md = (int)1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nconst int N = 100010;\n\nint n;\nint tmp[3];\nint sum[N], lst[N], nxt[N][3];\nchar s[N];\nMint dp[N][3];\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> (s + 1);\n  n = strlen(s + 1);\n  for (int i = 1; i <= n; ++i) s[i] = s[i] - 'a' + 1;\n\n  for (int i = 1; i <= n; ++i) sum[i] = (sum[i - 1] + s[i]) % 3;\n  dp[1][s[1]] = 1;\n  memset(tmp, -1, sizeof(tmp));\n  for (int i = n; i; --i) {\n    tmp[sum[i]] = i;\n    memcpy(nxt[i], tmp, sizeof(tmp));\n  }\n  lst[n] = -1;\n  for (int i = n - 1; i; --i)\n    lst[i] = s[i] == s[i + 1] ? i + 1 : lst[i + 1];\n  if (lst[1] != -1 && nxt[lst[1]][3 - s[1]] != -1)\n    dp[nxt[lst[1]][3 - s[1]]][3 - s[1]] = 1;\n  for (int i = 1; i < n; ++i)\n    for (int j = 1; j < 3; ++j) {\n      dp[i + 1][s[i + 1]] += dp[i][j];\n      int ns = (sum[i] + (3 - s[i + 1])) % 3;\n      if (lst[i + 1] != -1 && nxt[lst[i + 1]][ns] != -1)\n        dp[nxt[lst[i + 1]][ns]][3 - s[i + 1]] += dp[i][j];\n    }\n  int dif = n;\n  while (dif > 1 && s[dif] != s[dif - 1]) --dif;\n  Mint ans = 0;\n  int sm = 1;\n  while (sm < n && s[sm] != s[sm + 1]) ++sm;\n  for (int i = 1; i <= n; ++i) {\n    if (i != n) {\n      if (sum[i] != sum[n]) continue;\n      if (i <= sm && i >= dif) continue;\n    }\n    ans += dp[i][1] + dp[i][2];\n  }\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod=1e9+7;\nint f[N],s[N],nxt[N][3]; char c[N];\nint main()\n{\tscanf(\"%s\",c+1); int n=strlen(c+1),ans=0,tag=1;\n\tfor(rint i=1;i<=n;i++) s[i]=(s[i-1]+1+(c[i]=='b'))%3,tag&=(c[i]!=c[i+1]);\n\tif(tag) return !printf(\"1\");\n\tfor(rint i=n;i>=1;i--)\n\tmemcpy(nxt[i],nxt[i+1],sizeof(nxt[i])),nxt[i][s[i]]=i;\n\tf[nxt[1][1]]=f[nxt[1][2]]=1;\n\tfor(rint i=1;i<=n;i++)\n\t{\tfor(rint j=1;j<=2;j++)\n\t\tif(nxt[i+1][(s[i]+j)%3]) (f[nxt[i+1][(s[i]+j)%3]]+=f[i])%=mod;\n\t\tif(s[n]==s[i]) (ans+=f[i])%=mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=1e5+5,mod=1e9+7;\nint n,tr[N][3],f[N],sum[N];char s[N];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\n/*\n  s可以变成t当且仅当\n  - t可以在s上分段表示出来(每个t中字符和s的每一段mod3同余,且s最后一段不匹配的mod3=0)\n  - s存在两个相邻字符相同\n  分段表示可以考虑贪心,用最短的去匹配(不算重)\n */\n  \nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tint flg=0;\n\tREP(i,2,n)if(s[i]==s[i-1])flg=1;\n\tif(!flg)return puts(\"1\"),0;\n\tREP(i,1,n)sum[i]=(sum[i-1]+(s[i]=='a'?1:2))%3;\n\tREP(i,0,2)tr[n][i]=n+1;\n\tDREP(i,n-1,0){\n\t\tREP(j,0,2)tr[i][j]=tr[i+1][j];\n\t\ttr[i][sum[i+1]]=i+1;\n\t}\n\tf[0]=1;int ans=0;\n\tREP(i,0,n){\n\t\tREP(j,1,2)inc(f[tr[i][(sum[i]+j)%3]],f[i]);\n\t\tif(sum[i]==sum[n]&&i)inc(ans,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int maxn = int(1e5) + 7, mod = int(1e9) + 7;\nnamespace Solve {\n\tint next[maxn][3], f[maxn], sum[maxn], n, ans;\n\tchar str[maxn];\n\tint main() {\n\t\tscanf(\"%s\", str);\n\t\tn = int(strlen(str));\n\t\tbool flag = true;\n\t\tfor (int i = 1; str[i]; i++) flag &= str[i] != str[i - 1];\n\t\tif (flag) return 0 * puts(\"1\");\n\t\tfor (int i = 0; i < n; i++) sum[i + 1] = (sum[i] + 1 + (str[i] == 'b')) % 3;\n\t\tnext[n][0] = next[n][1] = next[n][2] = n + 1;\n\t\tfor (int i = n - 1; ~i; i--) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tnext[i][j] = next[i + 1][j];\n\t\t\t}\n\t\t\tnext[i][sum[i + 1]] = i + 1;\n\t\t}\n\t\tf[0] = 1;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= 2; j++) {\n\t\t\t\tif (next[i][(sum[i] + j) % 3] <= n) {\n\t\t\t\t\tf[next[i][(sum[i] + j) % 3]] = (f[i] + f[next[i][(sum[i] + j) % 3]]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 0 && sum[i] == sum[n]) ans = (ans + f[i]) % mod;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n}\nint main() {\n#ifdef AC\n\tfreopen(\"../in\", \"r\", stdin);\n#endif\n\treturn Solve::main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nconst int MAXN = 1e5+5;\nconst ll p = 1e9+7;\nconst ll inf = (1<<30);\n \nstring s;\nll v[MAXN], dp[MAXN][3], part[MAXN][3][3], r[MAXN][3], n;\nvector<int> pos[3];\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> s;\n\tn = s.length();\n\tv[0] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tv[i] = (v[i-1] + 1 + (s[i-1] == 'b'))%3;\n\tn++;\n\tfor (int i = 0; i < n; ++i)\n\t\tpos[v[i]].push_back(i);\n \n\tfor (int i = n-1; i >= 0; --i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tr[i][j] = i;\n\t\t\telse\n\t\t\t\tr[i][j] = max(i+1LL, r[i+1][j]);\n\t\t}\n\t}\n \n\tdp[0][0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tif (v[i] != k && v[i-1] == j)\n\t\t\t\t\tpart[i][j][k] = (part[i-1][j][k] + dp[i-1][j])%p;\n\t\t\t\telse\n\t\t\t\t\tpart[i][j][k] = part[i-1][j][k];\n\t\t\t}\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tcontinue;\n\t\t\t//find the range of j that \"project\" onto i\n\t\t\tint k = 3-v[i]-j;\n\t\t\t//j -> k -> v[i]\n\t\t\tint lo = 0, hi = pos[j].size();\n\t\t\t//find first guy who is >= i;\n\t\t\tif (pos[j].size() == 0)\n\t\t\t\tcontinue;\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] >= i) {\n\t\t\t\t\thi = mid;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] >= i)\n\t\t\t\t\thi = mid;\n\t\t\t\telse\n\t\t\t\t\tlo = mid+1;\n\t\t\t}\n\t\t\tif (lo == pos[j].size())\n\t\t\t\tcontinue;\n\t\t\tint val1 = pos[j][lo];\n\t\t\tlo = -1, hi = pos[j].size()-1;\n\t\t\t//find last guy who is <= i\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi+1)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] > i) {\n\t\t\t\t\thi = mid-1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] > i)\n\t\t\t\t\thi = mid-1;\n\t\t\t\telse\n\t\t\t\t\tlo = mid;\n\t\t\t}\n\t\t\tif (lo == -1)\n\t\t\t\tcontinue;\n\t\t\tint val2 = pos[j][lo];\n\t\t\tif (val1 > val2)\n\t\t\t\tcontinue;\n\t\t\tdp[i][v[i]] = (dp[i][v[i]] + part[val2+1][j][v[i]] + p - part[val1][j][v[i]])%p;\n\t\t}\n\t\tdp[i][v[i]] = (dp[i][v[i]] + dp[i-1][v[i-1]])%p;\n\t}\n \n\tll ans = 0;\n\tint g = -1;\n\tfor (int i = n-3; i >= 0; --i)\n\t\tif (v[i] + v[n-1] + v[n-2] == 3) {\n\t\t\tg = i;\n\t\t\tbreak;\n\t\t}\n\tif (g == -1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tif (v[i] == v[n-1])\n\t\t\tans = (ans + dp[i][v[i]])%p;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n    }\n    int nx[2][100010];\n    int p[3][100010];\n    for(int j=0; j<3; j++) p[j][n]=n;\n    int mn[100010];\n    mn[n]=n+1;\n    for(int i=n-1; i>=0; i--){\n        for(int j=0; j<3; j++) p[j][i]=p[j][i+1];\n        p[c[i]][i]=i;\n        mn[i]=mn[i+1];\n        if(i<n-1 && s[i]==s[i+1]) mn[i]=i+2;\n        if(s[i]=='a'){\n            nx[0][i]=i+1;\n            if(mn[i]<=n) nx[1][i]=p[(c[i]+2)%3][mn[i]];\n            else nx[1][i]=n+1;\n        }else{\n            nx[1][i]=i+1;\n            if(mn[i]<=n) nx[0][i]=p[(c[i]+1)%3][mn[i]];\n            else nx[0][i]=n+1;\n        }\n    }\n    ll dp[2][100010]={};\n    dp[0][0]=1;\n    ll ans=0;\n    for(int i=0; i<n; i++){\n        //cout<<nx[0][i]<<\" \"<<nx[1][i]<<endl;\n        int x=(c[n]-c[i]+3)%3;\n      if(x!=0) (ans+=dp[1][i])%=MOD;\n      if(x!=0 && (i==n-1 || mn[i]<=n || (i>0 && s[i]==s[i-1] && x==(s[i]-'a'+1)%3))) (ans+=dp[0][i])%=MOD;\n      //cerr<<mn[i]<<endl;\n      //cerr<<dp[0][i]<<endl;\n        if(nx[0][i]<n){\n          if(nx[0][i]==i+1){\n            (dp[0][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }\n        }\n        if(nx[1][i]<n){\n          if(nx[1][i]==i+1){\n            (dp[0][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define mod 1000000007\nusing namespace std;\nchar s[1000006];\nint f[1000006], last[3];\nint main(){\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1), c = 0;\n\tbool flag = false;\n\tfor (int i = 2; i <= n; ++ i)\n\t\tif (s[i] == s[i - 1]){\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\tif (! flag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tlast[1] = n + 1, last[2] = n + 1;\n\tf[0] = 1;\n\tfor (int i = 1; i <= n; ++ i){\n\t\t(c += s[i] == 'a' ? 1 : 2) %= 3;\n\t\tif (c == 0 && i < n)\n\t\t\tf[i] = 1;\n\t\t(f[i] += f[last[(c + 1) % 3]]) %= mod;\n\t\t(f[i] += f[last[(c + 2) % 3]]) %= mod;\n\t\tlast[c] = i;\n\t}\n\tcout << f[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int mod=1000000007;\nchar s[100010];\nint n,a[100010],f[100010],nxt[3];\nint main(){\n\tscanf(\"%s\",s);\n\twhile(s[n])a[n+1]=(a[n]+s[n]-'a'+1)%3,n++;\n\tbool fl=1;\n\tfor(int i=1;i<n;i++)if(s[i]==s[i-1])fl=0;\n\tif(fl)return puts(\"1\"),0;\n\tf[n]=1;\n\tfor(int i=0;i<3;i++)nxt[i]=i==a[n]?n:n+1;\n\tfor(int i=n;i--;){\n\t\tf[i]=i&&a[i]==a[n];\n\t\tfor(int c=0;c<2;c++)(f[i]+=f[nxt[(a[i]+c+1)%3]])%=mod;\n\t\tnxt[a[i]]=i;\n\t}\n\tprintf(\"%d\\n\",*f);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n#include <set>\n#include <map>\n \nusing namespace std;\n \ntypedef long long ll;\n \nconst ll MODULO = 1e9 + 7;\n \nmap<vector<int>, ll> ans;\nll Solve(int at, int sum, int want, int len, int was, const vector<int>& a) {\n  if (at == a.size()) {\n    if (sum == want) return 1;\n    return 0;\n  }\n \n  vector<int> state = {at, sum, want, len, was};\n  if (ans.count(state)) return ans[state];\n \n  ll& result = ans[state];\n  \n  result = 0;\n  \n  if (sum == want && want != 0 && (len == 1 || was)) {\n    for (int w = 0; w < 3; ++w) result = (result + Solve(at, 0, w, 0, 0, a)) % MODULO;\n    return result;\n  }\n \n  int newLen = min(len + 1, 2);\n  int newWas = was;\n  if (len != 0) newWas |= (a[at] == a[at - 1]);\n  int newSum = (sum + a[at]) % 3;\n \n  result = (result + Solve(at + 1, newSum, want, newLen, newWas, a)) % MODULO;\n \n  return result;\n}\n \nint main()\n{\n  string s;\n  cin >> s;\n  int n = s.size();\n  bool found = false;\n  for (int i = 0; i < n - 1; ++i) if (s[i] == s[i + 1]) found = true;\n  if (!found) {\n    cout << 1 << endl;\n    return 0;\n  }\n  vector<int> a(n, 1);\n  for (int i = 0; i < n; ++ i) if (s[i] == 'b') a[i] = 2;\n  ll result = (Solve(0, 0, 1, 0, 0, a) + Solve(0, 0, 2, 0, 0, a)) % MODULO;\n  cout << result << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nconst int N=1e5+5,P=1e9+7;\nchar s[N];int n,m,p[N],g[N][3],f[N];\nint main(){\n\tint x,c;\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfor(x=1;x<n;x++)if(s[x]!=s[x+1])break;\n\tif(x<n){\n\t\tfor(x=1;x<=n;x++)p[x]=(p[x-1]+(s[x]=='b')+1)%3;\n\t\tfor(x=n;x>=0;x--)g[x][0]=g[x+1][0],g[x][1]=g[x+1][1],g[x][2]=g[x+1][2],g[x][p[x]]=x;\n\t\tf[0]=1;\n\t\tfor(x=0;x<n;x++)if(f[x])for(c=0;c<3;c++)if(c!=p[x]&&g[x+1][c])f[g[x+1][c]]=(f[g[x+1][c]]+f[x])%P;\n\t\tfor(x=1;x<=n;x++)if(p[x]==p[n])m=(m+f[x])%P;\n\t}else m=1;\n\tprintf(\"%d\\n\",m);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define foreach(c,it) for (__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\nusing namespace std;\nconst int mod=1e9+7;\nint n,m,i,j,s[200005],lst[3],f[200005];\nstring st;\nint main(){\n\tcin>>st;\n\tn=st.size();st=\" \"+st;\n\trep(i,n){\n\t\tif(st[i]-1!=((st[1]-1)^((i-1)&1))) break;\n\t}\n\tif(i>n){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\trep(i,n){\n\t\ts[i]=(s[i-1]+(st[i]&1)+1)%3;\n\t}\n\tf[0]=1;\n\tlst[0]=lst[1]=lst[2]=n+1;\n\trep(i,n){\n\t\tif(s[i]) f[i]=1;\n\t\tfor(j=0;j<3;j++)if(s[i]!=j){\n\t\t\tf[i]=(f[i]+f[lst[j]])%mod;\n\t\t}\n\t\tlst[s[i]]=i;\n\t}\n\tprintf(\"%d\\n\",f[lst[s[n]]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define file(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool chkmin(T &a,T b){return (a>b)?a=b,1:0;}\n\ninline int read() {\n int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\nint n;\nchar s[1000005];\nint sum[1000005];\nint dp[1000005];\nint nxt[10];\nconst int mod=1e9+7;\nint main () {\n#ifndef ONLINE_JUDGE\n//file(\"agc27e\");\n#endif\n    scanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tF(i,1,n)sum[i]=(sum[i-1]+s[i]-'a'+1)%3;\n\tdp[n]=1;\n\tF(i,0,2)nxt[i]=i==sum[n]?n:n+1;\n\tf(i,n-1,1){\n\t  dp[i]=sum[i]==sum[n];\n\t  F(j,1,2){\n\t     dp[i]=(dp[i]+dp[nxt[(sum[i]+j)%3]])%mod;\n\t  }\n\t  nxt[sum[i]]=i;\n\t}\n    printf(\"%d\\n\",(dp[nxt[1]]+dp[nxt[2]])%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nsigned main(){\n\tstring s;\n\tcin>>s;\n\tint n=s.size(),MOD=1000000007;\n\t\n\tbool h=true;\n\trep(i,n-1)if(s[i]==s[i+1])h=false;\n\tif(h){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\ts+=s.back();\n\tvi c(n+1),ren(n,inf);\n\trep(i,n)c[i+1]=s[i]-'a'+1;\n\trep(i,n)if(s[i]==s[i+1])ren[i]=i;\n\trep(i,n-1)cmin(ren[n-i-2],ren[n-i-1]);\n\trep(i,n)(c[i+1]+=c[i])%=3;\n\n\tvvi next(n+1,vi(3,n));\n\tfor(int i=n-1;i>=0;i--){\n\t\trep(j,3)next[i][j]=next[i+1][(j+3-(s[i]-'a'+1))%3];\n\t\tnext[i][s[i]-'a'+1]=i;\n\t}\n\tvi dp(n+1);\n\tdp[0]=1;\n\trep(i,n)if(dp[i]){\n\t\trep(q,2){\n\t\t\tif(s[i]-'a'==q){\n\t\t\t\t(dp[i+1]+=dp[i])%=MOD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to=ren[i]+1;\n\t\t\tto=next[to][(q+1-c[to]+c[i]+3)%3];\n\t\t\tif(to==n)continue;\n\t\t\t(dp[to+1]+=dp[i])%=MOD;\n\t\t}\n\t}\n\tint out=0;\n\trep(i,n)if((c[n]+3-c[i+1])%3==0)(out+=dp[i+1])%=MOD;\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 1e5 + 5, mod = 1e9 + 7;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nchar s[N];\nint n, sum, a[N], f[N], last[5];\nsigned main() {\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tint flag = 1;\n\tfor(int i = 1; i < n; ++ i) if(s[i] == s[i + 1]) flag = 0;\n\tif(flag) return puts(\"1\"), 0;\n\tfor(int i = 1; i <= n; ++ i) a[i] = (a[i - 1] + (s[i] == 'a' ? 1 : 2)) % 3;\n\tfor(int i = 1; i <= n; ++ i) f[i] = (f[last[0]] + f[last[1]] + f[last[2]] + (a[i] >= 1) - f[last[a[i]]] + mod) % mod, last[a[i]] = i;\n\tprintf(\"%d\\n\", f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nusing namespace std;\nchar s[131072];\nint num[4],num2[4];\nint main()\n{\n\tscanf(\"%s\",s);\n\tint n=strlen(s);\n\tbool ok=false;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(s[i]==s[i-1])\n\t\t{\n\t\t\tok=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!ok)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tnum2[1]=1;\n\tnum2[2]=1;\n\tint now=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(s[i]=='a')\n\t\t{\n\t\t\tnow++;\n\t\t\tif(now>=3)\n\t\t\t{\n\t\t\t\tnow-=3;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnow--;\n\t\t\tif(now<0)\n\t\t\t{\n\t\t\t\tnow+=3;\n\t\t\t}\n\t\t}\n\t\tnum[now]+=num2[now];\n\t\tif(num[now]>=1000000007)\n\t\t{\n\t\t\tnum[now]-=1000000007;\n\t\t}\n\t\tfor(int j=0;j<3;j++)\n\t\t{\n\t\t\tif(j!=now)\n\t\t\t{\n\t\t\t\tnum2[j]+=num2[now];\n\t\t\t\tif(num2[j]>=1000000007)\n\t\t\t\t{\n\t\t\t\t\tnum2[j]-=1000000007;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnum2[now]=0;\n\t}\n\tprintf(\"%d\\n\",num[now]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5, mod = 1e9 + 7;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nchar s[maxn];\nint n, sum, flg, nxt[2][maxn], f[maxn];\n\nint main()\n{\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tflg = 0;\n\tfor (int i = 1; i < n; ++i) flg += s[i] == s[i + 1];\n\tif (!flg) return puts(\"1\"), 0;\n\tf[n + 1] = 1; nxt[0][n + 1] = nxt[1][n + 1] = nxt[0][n + 2] = nxt[1][n + 2] = n + 2;\n\tfor (int i = n; i; --i) {\n\t\t(sum += s[i] - 'a' + 1) %= 3;\n\t\tnxt[0][i] = s[i] == 'a' ? i + 1 : nxt[1][i + 1];\n\t\tnxt[1][i] = s[i] == 'b' ? i + 1 : nxt[0][i + 1];\n\t\tf[i] = sum == 0;\n\t\tinc(f[i], f[nxt[0][i]]);\n\t\tinc(f[i], f[nxt[1][i]]);\n\t}\n\tprintf(\"%d\\n\", f[1] - (sum == 0));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// by newbiechd\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n// DELETE the debugging information!\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\n\nint read() {\n  int f = 0;\n  char ch;\n  while (!isdigit(ch = getchar()));\n  do f = 10 * f + (ch ^ '0');\n  while (isdigit(ch = getchar()));\n  return f;\n}\n\nconst int N_MAX = 100003, mod = 1e9 + 7;\nchar s[N_MAX];\nint dp[N_MAX];\n\nint main() {\n  scanf(\"%s\", s + 1);\n  int n = strlen(s + 1), lst = n + 1, sum = 0;\n  dp[n + 1] = 1;\n  for (int i = n; i > 0; --i) {\n    sum = (sum + s[i] - 'a' + 1) % 3;\n    if (s[i] == s[i + 1])\n      lst = i + 1;\n    dp[i] = (dp[i + 1] + dp[lst + 1] + (sum == 0)) % mod;\n  }\n  printf(\"%d\\n\", lst <= n ? (dp[1] - (sum == 0) + mod) % mod : 1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005,mod=1e9+7;\nint f[N],s[N],nxt[N],las[N][3],sum[N][3];\nint n,flag,ans=1;\nchar st[N];\n\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\n\nint main(){\n\tscanf(\"%s\",st+1);\n\tn=strlen(st+1);\n\trep(i,1,n){\n\t\ts[i]=(s[i-1]+1+(st[i]=='b'))%3;\n\t}\n\tper(i,n,1){\n\t\tif(st[i]==st[i+1])nxt[i]=i+1;\n\t\telse nxt[i]=nxt[i+1];\n\t\tREP(t,3) las[i][t]=las[i+1][t];\n\t\tlas[i][s[i]]=i;\n\t}\n\tf[0]=1;\n\trep(i,1,n){\n\t\tadd(f[i],f[i-1]);\n\t\tint p=nxt[i];\n\t\tif(p){\n\t\t\tadd(sum[p][s[i-1]],f[i-1]);\n\t\t\tp=las[p][(2*s[i-1]+3-s[i])%3];\n\t\t\tadd(f[p],f[i-1]);\n\t\t}\n\t\tREP(t,3){\n\t\t\tadd(sum[i][t],sum[i-1][t]);\n\t\t\tint tmp=(s[i]-t+3)%3;\n\t\t\tif(tmp&&tmp!=(s[i]-s[i-1]+3)%3){\n\t\t\t\tadd(ans,sum[i][t]);\n\t\t\t\t//printf(\"%d %d   %d\\n\",i,t,sum[i][t]);\n\t\t\t}\n\t\t}\n\t\tif(!flag&&st[i]==st[i-1])\n\t\t\tflag=1,ans+=(i-2)/2;\n\t\tif(!s[i-1]&&flag)ans++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F(i, a, b) for (int i = a; i <= b; i ++)\n#define G(i, a, b) for (int i = a; i >= b; i --)\n#define out4(x, y, z, w) { if (debug) printf(#x\" = \"),W(x),printf(\" \"#y\" = \"),W(y),printf(\" \"#z\" = \"),W(z),printf(\" \"#w\" = \"),W(w),putc('\\n'); }\n#define out3(x, y, z) { if (debug) printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), printf(\" \"#z\" = \"), W(z), putc('\\n'); }\n#define out2(x, y) { if (debug) printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), putc('\\n'); }\n#define out1(x) { if (debug) printf(#x\" = \"), W(x), putc('\\n'); }\n#define outline(x) { if (debug) puts(\"-------------------------------------------\"#x\"----------------------------------------\"); }\n#define outarr(a, L, R) { if (debug) { printf(#a\"[%d..%d] = \", L, R); F(i, L, R) W(a[i]), putc(' '); putc('\\n'); } }\n#define Assert(x) { if ((debug) && (!(x))) { puts(\"Wrong Answer\"); exit(0); } }\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define mem(a, b) memset(a, b, sizeof a)\n#define mec(a, b) memcpy(a, b, sizeof a)\n#define mx(a, b) ((a) = max(a, b))\n#define mn(a, b) ((a) = min(a, b))\n#define lowbit(x) ((x) & (-(x)))\n#define abs(x) ((max(x, - (x))))\n#define get getchar()\n#define pb push_back\n#define putc putchar\n#define inf 2e9\n\ntemplate <typename Int>\nvoid R(Int &x) {\n\tchar c = get; x = 0; Int t = 1;\n\tfor (; !isdigit(c); c = get) t = (c == '-' ? - 1 : t);\n\tfor (; isdigit(c); x = (x << 3) + (x << 1) + c - '0', c = get); x *= t;\n}\ntemplate <typename Int>\nvoid W(Int x) {\n\tif (x < 0) { putc('-'); x = - x ; }\n\tif (x > 9) W(x / 10); putc(x % 10 + '0');\n}\n\n#define debug (1)\n\nusing namespace std;\n\nconst int mo = 1e9 + 7;\nconst int N = 5e5 + 10;\nchar ch[N]; int a[N], f[N], s[N];\n\nvoid add(int &x, int y) { x = (x + y) % mo; }\n\nint main() {\n//\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%s\", ch + 1);\n\tint n = strlen(ch + 1);\n\tF(i, 1, n) a[i] = ch[i] - 'a' + 1, s[i] = s[i - 1] + a[i];\n\tint sum = 0;\n\tF(i, 1, n - 1) sum += a[i] == a[i + 1];\n\tif (!sum) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tint Ans = 0, top = 1, bz = 0;\n\tf[0] = 1;\n\tF(i, 0, n - 1) {\n\t\tadd(f[i + 1], f[i]);\n\t\tint v = 3 - a[i + 1];\n\t\tif (top <= i + 1) bz = 0;\n\t\twhile (!bz && top < n)\n\t\t\tbz = a[top] == a[top + 1], top ++;\n\t\tif (bz) {\n\t\t\tF(j, top, n)\n\t\t\t\tif ((s[j] - s[i]) % 3 == v) {\n\t\t\t\t\tadd(f[j], f[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif ((s[n] - s[i + 1]) % 3 == 0)\n\t\t\tadd(Ans, f[i + 1]);\n\t}\n\n\tW(Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 1e5 + 5;\nvoid regl(int &x) { if(x>=Mod) x-=Mod; }\n\nint n, i, j, ans, dp[Nmax], nxt[Nmax][3], s[Nmax];\nchar a[Nmax];\n\nint main()\n{\n ///   freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    cin >> (a+1);\n    n = strlen(a+1);\n\n    bool ok = 0;\n    for(i=1; i<=n; ++i)\n    {\n        ok |= (i<n && a[i] == a[i+1]);\n        a[i] -= 'a' - 1;\n        s[i] = (s[i-1] + a[i]) % 3;\n    }\n\n    if(!ok)\n    {\n        cout << \"1\\n\";\n        return 0;\n    }\n\n    nxt[n+1][0] = nxt[n+1][1] = nxt[n+1][2] = n+1;\n    for(i=n; i>=0; --i)\n        memcpy(nxt[i], nxt[i+1], sizeof(nxt[i])), nxt[i][s[i]] = i;\n\n    dp[0] = 1;\n    for(i=0; i<=n; ++i)\n    {\n        dp[nxt[i][ (s[i]+1)%3 ]] += dp[i];\n        regl(dp[nxt[i][ (s[i]+1)%3 ]]);\n\n        dp[nxt[i][ (s[i]+2)%3 ]] += dp[i];\n        regl(dp[nxt[i][ (s[i]+2)%3 ]]);\n\n        if(s[i] == s[n] && i) ans += dp[i], regl(ans);\n    }\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = (int)(1e9 + 7);\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nconst int N = 100010;\nint n, dp[N], val[N], lim = -1, cur[3], rec[N][2];\nvector<int> vec[3];\nchar str[N];\nint main() {\n  scanf(\"%s\", str + 1);\n  n = strlen(str + 1);\n  int key = 0;\n  rep (i, 1, n-1) if (str[i] == str[i+1])\n    key = 1;\n  if (!key) {\n    puts(\"1\");\n    return 0;\n  }\n  dp[0] = 1;\n  vec[0].push_back(0);\n  cur[0] = cur[1] = cur[2] = -1;\n  rep (i, 1, n) {\n    if (i >= 2 && str[i] == str[i-1]) lim = i-2;\n    rep (j, 0, 2) {\n      while (cur[j]+1 < (int)vec[j].size() && vec[j][cur[j]+1] <= lim)\n\t++ cur[j];\n    }\n    val[i] = (val[i-1] + (str[i] - 'a' + 1)) % 3;\n    // Add(dp[i], dp[i-1]);\n    rec[i+1][0] = i;\n    int tmp = str[i] - 'a' + 1;\n    if (tmp == 1) tmp = 2;\n    else tmp = 1;\n    tmp = val[i] - tmp;\n    if (tmp < 0) tmp += 3;\n    if (cur[tmp] >= 0 && vec[tmp][cur[tmp]] <= lim) {\n      // Add(dp[i], dp[vec[tmp][cur[tmp]]]);\n      rec[i+1][1] = vec[tmp][cur[tmp]]+1;\n    }\n    vec[val[i]].push_back(i);\n    // cerr << dp[i] << endl;\n    // cerr << rec[i+1][0] << ' ' << rec[i+1][1] << endl;\n  }\n  dp[n+1] = 1;\n  rrp (i, n+1, 2) {\n    Add(dp[rec[i][0]], dp[i]);\n    Add(dp[rec[i][1]], dp[i]);\n  }\n  // rep (i, 1, n) {\n  //   cerr << dp[i] << endl;\n  // }\n  int ans = 0;\n  rep (i, 0, n-1)\n    if (val[i] == 0) Add(ans, dp[i+1]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstring>\n#include<map>\n#include<bitset>\n#include<stack>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define bomb exit(1)\n#define INF 1000000000\n#define LINF 1000000000000000000ll\n#define pprint(x) print(x),putchar(' ')\n#define fprint(x) print(x),putchar('\\n')\n#define EE(x); struct edge { int nxt,to,w; }e[M << 1]; int head[N],cnt = x ^ 1;\\\n\tvoid add(int u,int v,int w = 0) { e[++cnt].w = w,e[cnt].to = v,e[cnt].nxt = head[u];head[u] = cnt; }\\\n\tvoid add_edge(int u,int v,int w = 0) { add(u,v,w),add(v,u,w * x); }\n#define Mod(x) ((x) >= mod ? x - mod : x)\n#define eps 0.0000000001\n#define sqr(x) ((x) * (x))\n#define iter iterator\n#define fi first\n#define se second\n#define ll long long\n//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)\n//char BB[1 << 15],*SS = BB,*TT = BB;\ninline ll read()\n{\n\tll x = 0;int f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar()) if(ch == '-') f = -1;\n\tfor(;isdigit(ch);ch = getchar()) x = x * 10 + (ch ^ 48);\n\treturn x * f;\n}\nvoid print(ll x)\n{\n\tif(x < 0) putchar('-'),x = -x;\n\tif(x > 9) print(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int mod = 1000000007,N = 100005;\nint n,sum;\nchar s[N];\nint nxt[N][2];\nll f[N];\n\nint main()\n{\n\tscanf(\"%s\",s + 1),n = strlen(s + 1);\n\tbool fl = 1;\n\tfor(int i = 1;i < n;i++) if(s[i] == s[i + 1]) fl = 0;\n\tif(fl) { puts(\"1\");return 0; }\n\tf[n + 1] = 1,nxt[n + 1][0] = nxt[n + 1][1] = nxt[n + 2][0] = nxt[n + 2][1] = n + 2;\n\tfor(int i = n;i;i--)\n\t{\n\t\t(sum += s[i] - 'a' + 1) %= 3;\n\t\tnxt[i][0] = s[i] == 'a' ? i + 1 : s[i + 1] == 'b' ? i + 2 : nxt[i + 2][0];\n\t\tnxt[i][1] = s[i] == 'b' ? i + 1 : s[i + 1] == 'a' ? i + 2 : nxt[i + 2][1];\n\t\tf[i] = (f[nxt[i][0]] + f[nxt[i][1]] + (sum == 0)) % mod;\n\t}\n\tfprint((f[1] - (sum == 0) + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// by newbiechd\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n// DELETE the debugging information!\n#define debug(x) std::cerr << #x << \" = \" << (x) << std::endl\n\nint read() {\n  int f = 0;\n  char ch;\n  while (!isdigit(ch = getchar()));\n  do f = 10 * f + (ch ^ '0');\n  while (isdigit(ch = getchar()));\n  return f;\n}\n\nconst int N_MAX = 100003, mod = 1e9 + 7;\nchar s[N_MAX];\nint dp[N_MAX];\nvoid add(int &x, const int &y) {\n  x += y - mod;\n  x += x >> 31 & mod;\n}\n\nint main() {\n  scanf(\"%s\", s + 1);\n  int n = strlen(s + 1), lst = n + 1, sum = 0;\n  dp[n + 1] = 1;\n  for (int i = n; i > 0; --i) {\n    sum = (sum + s[i] - 'a' + 1) % 3;\n    if (s[i] == s[i + 1])\n      lst = i + 1;\n    dp[i] = (dp[i + 1] + dp[lst + 1] + (sum == 0)) % mod;\n  }\n  printf(\"%d\\n\", lst <= n ? (dp[1] - (sum == 0) + mod) % mod : 1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n\ntemplate<typename T> class BIT {\nprivate:\n\tint n;\n\tvector<T> bit;\npublic:\n\t// 0_indexed で i 番目の要素に x を加える\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile(i < n){\n\t\t\tbit[i] += x, i += i & -i;\n\t\t}\n\t}\n\t// 0_indexed で [0,i] の要素の和(両閉区間！！)\n\tT sum(int i){\n\t\ti++;\n\t\tT s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i], i -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tBIT(){}\n\t//初期値がすべて0の場合\n\tBIT(int sz) : n(sz+1), bit(n, 0){}\n\tBIT(vector<T>& v) : n((int)v.size()+1), bit(n, 0){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tadd(i,v[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcout<<sum(i)-sum(i-1)<< \" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t//-1スタート\n\tvoid print_sum(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout<<sum(i-1)<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<mod>dp(n+1);\n    vector<int>a[3];\n    vector<int>b(n+1);\n    int c = 0;\n    rep(i,n){\n        b[i] = c;\n        c += s[i]-'a'+1;\n        c %= 3;\n        a[c].push_back(i+1);\n    }\n    a[0].push_back(n);\n    a[1].push_back(n);\n    a[2].push_back(n);\n    b[n] = c;\n    BIT<int> bit(n);\n    rep(i,n-1){\n        if(s[i]==s[i+1]){\n            bit.add(i,1);\n        }\n    } \n    dp[0] = 1;\n    rep(i,n){\n        for(int j=1;j<3;j++){\n            int ca = (b[i]+j)%3;\n            int id = i;\n            while(1){\n                int x = *upper_bound(a[ca].begin(),a[ca].end(),id);\n                id = x;\n                if(x==n)break;\n                if(x==i+1){\n                    dp[x] += dp[i];\n                    break;\n                }else{\n                    if(bit.sum(x-1)-bit.sum(i-1)!=0){\n                        dp[x] += dp[i];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    mod res = 0;\n    rep(i,n){\n        int k = (3+b[n]-b[i])%3;\n        if(k==0)continue;\n        if(i==n-1){\n            res += dp[i];\n        }else if(bit.sum(n-1)-bit.sum(i-2)!=0){\n            res += dp[i];\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN], pref[MAXN], cnts[MAXN];\nint lst[3];\nint dp[MAXN];\nint ans;\nset<int> num[3];\n\nint rsum(int L, int R)\n{\n\treturn (pref[R + 1] - pref[L] + 3) % 3;\n}\nbool bad(int L, int R)\n{\n\treturn ((R > L) && (cnts[R + 1] - cnts[L] == 0));\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tstring temps;\n\tcin >> temps;\n\tN = temps.length();\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tarr[i] = ((temps[i] == 'a') ? 1 : 2);\n\t\tpref[i + 1] = pref[i] + arr[i]; nmod(pref[i + 1], 3);\n\t\tcnts[i + 1] = cnts[i] + ((i != 0 && arr[i] == arr[i - 1]) ? 1 : 0);\n\t}\n\tif (bad(0, N - 1))\n\t{\n\t\tcout << \"1\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= N; i++)\n\t{\n\t\tnum[pref[i]].insert(i);\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i <= N; i++)\n\t{\n\t\tnum[pref[i]].erase(i);\n\t\tif (!num[(pref[i] + 1) % 3].empty())\n\t\t{\n\t\t\tint idx = *num[(pref[i] + 1) % 3].begin();\n\t\t\tif (!bad(i, idx - 1))\n\t\t\t{\n\t\t\t\tdp[idx] += dp[i];\n\t\t\t\tnmod(dp[idx], INF);\n\t\t\t}\n\t\t}\n\t\tif (!num[(pref[i] + 2) % 3].empty())\n\t\t{\n\t\t\tint idx = *num[(pref[i] + 2) % 3].begin();\n\t\t\tif (!bad(i, idx - 1))\n\t\t\t{\n\t\t\t\tdp[idx] += dp[i];\n\t\t\t\tnmod(dp[idx], INF);\n\t\t\t}\n\t\t}\n\t\tif (i != 0 && rsum(i, N - 1) == 0)\n\t\t{\n\t\t\tans += dp[i];\n\t\t\t// cerr << \"add \" << i << ' ' << dp[i] << endl;\n\t\t\tnmod(ans, INF);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1e9 + 7;\n\nint add(int x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n  return x;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  string s;\n  cin >> s;\n  int n = s.length();\n  bool flag = true;\n  for (int i = 1; i < n; ++i) {\n    flag &= s[i] != s[i - 1];\n  }\n  if (flag) {\n    puts(\"1\");\n    return 0;\n  }\n  vector<int> sum(n + 1);\n  for (int i = 0; i < n; ++i) {\n    sum[i + 1] = (sum[i] + (s[i] == 'a') + 1) % 3;\n  }\n  vector<vector<int>> next(n + 1, vector<int> (3, n + 1));\n  for (int i = n - 1; ~i; --i) {\n    for (int j = 0; j < 3; ++j) {\n      next[i][j] = next[i + 1][j];\n    }\n    next[i][sum[i + 1]] = i + 1;\n  }\n  vector<int> f(n + 1);\n  int answer = 0;\n  f[0] = 1;\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 1; j <= 2; ++j) {\n      if (next[i][(sum[i] + j) % 3] <= n) {\n        f[next[i][(sum[i] + j) % 3]] = add(f[next[i][(sum[i] + j) % 3]], f[i]);\n      }\n    }\n    if (i && sum[i] == sum[n]) {\n      answer = add(answer, f[i]);\n    }\n  }\n  printf(\"%d\\n\", answer);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int Mod = 1e9 + 7;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nint mul(int a, int b){ return 1ll * a * b % Mod; }\nvoid Add(int &a, int b){ a = add(a,b); }\nvoid Mul(int &a, int b){ a = mul(a,b); }\nvoid Dec(int &a, int b){ a = dec(a,b); }\nint ksm(int a, int b){ int as=1; for(;b;b>>=1,Mul(a,a)) if(b&1) Mul(as,a); return as; }\ncs int N = 1e5 + 50;\nint n; char S[N];\nint dp[N], trs[N][2];\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%s\",S+1); n=strlen(S+1); bool ok=true;\n\tfor(int i=1; i<n; i++) if(S[i]==S[i+1]) ok=false;\n\tif(ok) return puts(\"1\"),0; int k=0; dp[n+1]=1;\n\ttrs[n+1][0]=trs[n+1][1]=trs[n+2][0]=trs[n+2][1]=1;\n\tfor(int i=n,c; i>=1; i--){\n\t\tc=S[i]-'a'+1; k=(k+c)%3;\n\t\ttrs[i][0]=S[i]=='a'?i+1:(S[i+1]=='b'?i+2:trs[i+2][0]);\n\t\ttrs[i][1]=S[i]=='b'?i+1:(S[i+1]=='a'?i+2:trs[i+2][1]);\n\t\tdp[i]=add(dp[trs[i][0]],dp[trs[i][1]])+(k==0);\n\t} cout<<dec(dp[1],k==0); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <map>\n#include <set>\n#include <list>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n\nusing namespace std;\n\nint i,j,k,l,m,n;\n/////////////////////////////////////////////////////\n#define mp make_pair\n#define MOD (ll)10e9+7\n\nchar s[101010];\nll leng;\nvector<ll> point[101010];\nll dp[2][101010][2];\nll ref;\n\nint main(){\n    scanf(\"%s\",s);\n    for(leng=0;s[leng]!='\\0';leng++);\n\n\n    dp[0][0][s[i]-'a']=1;\n\n    for(i=1;i<leng;i++){\n        for(j=0;j<i;j++){\n            dp[i%2][j][!(s[i]-'a')]+=dp[(i+1)%2][j][s[i]-'a'];\n            dp[i%2][j][!(s[i]-'a')]%=MOD;\n            dp[i%2][j+1][s[i]-'a']+=dp[(i+1)%2][j][0]+dp[(i+1)%2][j][1];\n            dp[i%2][j+1][s[i]-'a']%=MOD;\n            dp[(i+1)%2][j][0]=0;\n            dp[(i+1)%2][j][1]=0;\n            //printf(\"%lld_%lld \",dp[i%2][j][!(s[i]-'a')],dp[i%2][j+1][s[i]-'a']);\n        }\n        printf(\"\\n\");\n    }\n    for(i=0;i<leng;i++){\n        ref+=dp[(leng+1)%2][i][0]+dp[(leng+1)%2][i][1];\n        ref%=MOD;\n    }\n    printf(\"%lld\",ref);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1e9 + 7;\n\nint add(int x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n  return x;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  string s;\n  cin >> s;\n  int n = s.length();\n  bool flag = true;\n  for (int i = 1; i < n; ++i) {\n    flag &= s[i] != s[i - 1];\n  }\n  if (flag) {\n    puts(\"1\");\n    return 0;\n  }\n  vector<int> sum(n + 1);\n  for (int i = 0; i < n; ++i) {\n    sum[i + 1] = (sum[i] + (s[i] == 'a') + 1) % 3;\n  }\n  vector<vector<int>> next(n + 1, vector<int> (3, n + 1));\n  for (int i = n - 1; ~i; --i) {\n    for (int j = 0; j < 3; ++j) {\n      next[i][j] = next[i + 1][j];\n    }\n    next[i][sum[i + 1]] = i + 1;\n  }\n  vector<int> f(n + 1);\n  int answer = 0;\n  f[0] = 1;\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 1; j <= 2; ++j) {\n      if (next[i][(sum[i] + j) % 3] <= n) {\n        f[next[i][(sum[i] + j) % 3]] = add(f[next[i][(sum[i] + j) % 3]], f[i]);\n      }\n    }\n    if (i && sum[i] == sum[n]) {\n      answer = add(answer, f[i]);\n    }\n  }\n  printf(\"%d\\n\", answer);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\n\n#define M 100005\n#define mod 1000000007\nint n;\nint f[M];\nchar a[M];\ninline void inc(int &x,int y) {x+=y,x-=x>=mod?mod:0;}\n\nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1);\n\tbool t=0;\n\tfor1(1,n-1,i) if(a[i]==a[i+1]) {t=1;break;}\n\tif(!t) return puts(\"1\"),0;\n\tint ans=0;\n\tint s=0,pre[3]={0,-1,-1};\n\tf[0]=1;\n\tfor1(1,n,i) {\n\t\ts=(s+2-(a[i]=='a'))%3;\n\t\t//if(!s&&i<n) f[i]=1;\n\t\t++s,s%=3;\n\t\tif(pre[s]!=-1) inc(f[i],f[pre[s]]);\n\t\t++s,s%=3;\n\t\tif(pre[s]!=-1) inc(f[i],f[pre[s]]);\n\t\t++s,s%=3;\n\t\tpre[s]=i;\n\t}\n\tcout<<f[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100100\n#define mo 1000000007\nusing namespace std;\nint n,ap[17][N],t[N],pr[N],f[N],a[N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=2;i<=n;++i)t[i]=t[i-1]+(s[i]==s[i-1]);\n\tfor(int i=1;i<=n;++i){\n\t\tpr[i]=(pr[i-1]+(a[i]=s[i]-96))%3;\n\t\tap[0][i]=1<<pr[i];\n\t}\n\tfor(int j=1;j<=16;++j)for(int i=1,_E_=n+1-(1<<j);i<=_E_;++i)ap[j][i]=ap[j-1][i]|ap[j-1][i+(1<<j-1)];\n\tf[0]=1;\n\tfor(int i=0;i<n;++i){\n\t\tf[i+1]=(f[i+1]+f[i])%mo;\n\t\tint l=i+1,r=n,m,s=n+1;\n\t\twhile(l<=r)if(t[m=l+r>>1]!=t[i+1])r=m-1,s=m;else l=m+1;\n\t\tif(s>n)continue;\n\t\tfor(int j=16;j+1;--j)if(s+(1<<j)<=n+1&&!(ap[j][s]&1<<(3+pr[i]-a[i+1])%3))s+=1<<j;\n\t\tif(s>n)continue;\n\t\tf[s]=(f[s]+f[i])%mo;\n\t}int ans=f[n];\n\tfor(int i=n-1;i;--i)if(pr[n]==pr[i])ans=(ans+f[i])%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint change_time = 0;\nchar maked_word[100000][100001] = {{'\\0'}};\nint temp = 0;\n\nchar* change(int t,char *s,char sw)\n{\n\tchar ret[100001];\n\tfor(int i =0;i<t;i++)\n\t{\n\t\tret[i] = s[i];\n\t}\n\tret[t] = sw;\n\tfor(int i=t+1;s[i+1] != '\\0';i++)\n\t{\n\t\tret[i] = s[i+1];\n\t}\n\n\treturn ret;\n}\n\n\nvoid saiki(char *s)\n{\n\t//printf(\"%s\\n\",s);\n\tstrcpy(maked_word[change_time],s);\n\tfor(int i =0;i<change_time;i++)\n\t{\n\t\tif(strcmp(maked_word[i],s) == 0)\n\t\t{\n\t\t\tchange_time -=1;\n\t\t}\n\t}\n\tchange_time++;\n\tint num=0;\n\tfor(int i=0;s[i] != '\\0';i++)\n\t{\n\t\tnum++;\n\t}\n\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tif(s[i] == 'a' && s[i+1] == 'a')\n\t\t{\n\t\t\tchar *ss = change(i,s,'b');\n\t\t\tsaiki(ss);\n\t\t}\n\t\tif(s[i] == 'b' && s[i+1] == 'b')\n\t\t{\n\t\t\tchar *ss =change(i,s,'a');\n\t\t\tsaiki(ss);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tchar s[100001];\n\tscanf(\"%s\",s);\n\tsaiki(s);\n\tprintf(\"%d\\n\",change_time);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000005\n#define Mod 1000000007\nusing namespace std;\nchar s[N];int sum[N],last[N],dp[N],nxt[N][3];\ninline int gt(char ch){if(ch=='a')return 1;return 2;}\nint main(){\n\tscanf(\"%s\",s+1);int n=strlen(s+1);\n\tbool flag=1;\n\tfor (int i=1;i<=n;i++){\n\t\tif (s[i]==s[i-1]) flag=0;\n\t\tsum[i]=sum[i-1]+gt(s[i]);\n\t\tsum[i]%=3;\n\t}\n\tif (flag) return puts(\"-1\"),0;\n\tfor (int i=0;i<3;i++) last[i]=n+1;\n\tfor (int i=n;~i;i--){\n\t\tfor (int j=0;j<3;j++) nxt[i][j]=last[j];\n\t\tlast[sum[i]]=i;\n\t}\n\tint ans=0;dp[0]=1;\n\tfor (int i=0;i<=n;i++){\n\t\tfor (int j=1;j<=2;j++)\n\t\t\tif (nxt[i][(sum[i]+j)%3]<=n) dp[nxt[i][(sum[i]+j)%3]]=1ll*(dp[nxt[i][(sum[i]+j)%3]]+dp[i])%Mod;\n\t\tif (i&&sum[i]==sum[n]) ans=1ll*(ans+dp[i])%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\nint N;\nchar S[100005];\nint Next[100005], P[100005], DP[100005];\nconst int MOD = 1000000007;\nvector <int> V[3];\nint ind[3];\nvoid Read()\n{\n    cin.getline(S + 1, 100005);\n    N = strlen(S + 1);\n    //V[P[0]].push_back(0);\n    for(int i = 1; i <= N; i++)\n    {\n        P[i] = P[i - 1] + S[i] - 'a' + 1;\n        while(P[i] >= 3)\n            P[i] -= 3;\n        V[P[i]].push_back(i);\n    }\n}\ninline void Add(int& x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\nvoid Solve()\n{\n    int next = 1;\n    DP[1] = 1;\n    int ans = 0;\n    for(int i = 1; i <= N; i++)\n    {\n        if(next <= i)\n        {\n            while(next <= N && (S[next] != S[next - 1] || next <= i))\n            {\n                ind[P[next]]++;\n                ++next;\n            }\n        }\n        Add(DP[i + 1], DP[i]);\n        for(int j = 0; j < 3; j++)\n        {\n            if(P[i - 1] == j || ((j - P[i - 1] + 3) % 3) == S[i] - 'a' + 1)\n                continue;\n            if(ind[j] == V[j].size())\n                continue;\n            Add(DP[V[j][ind[j]] + 1], DP[i]);\n        }\n        if(P[N] == P[i - 1] && i > 1)\n            Add(ans, DP[i]);\n    }\n    Add(ans, DP[N + 1]);\n    /*for(int i = N - 1; i > 1; i--)\n    {\n        if(S[i] == S[i + 1])\n            break;\n        if(P[N] == P[i - 1] && S[i - 1] != S[i])\n            Add(ans, MOD - 1);\n    }*/\n    cout << ans << '\\n';\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e5 + 10;\n\nint n, last[3] = {0,-1,-1}, dp[N];\nstring s;\n\nint main() {\n    cin >> s;\n    int n = s.size();\n    s = ' ' + s;\n    bool rep = 0;\n    for (int i = 0; i < (int) s.size()-1; i++) rep |= s[i] == s[i+1];\n    if (!rep) return cout << 1, 0;\n\n    dp[0] = 1;\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        int x = s[i]-'a'+1;\n        sum += x;\n        if (sum >= 3) sum -= 3;\n\n        dp[i] = 0;\n        for (int c = 1; c <= 2; c++) {\n            int j = last[(sum+3-c)%3];\n            if (j >= 0) {\n                dp[i] += dp[j];\n                if (dp[i] >= MOD) dp[i] -= MOD;\n            }\n        }\n        if (sum == 0) {\n            ++dp[i];\n            if (dp[i] >= MOD) dp[i] -= MOD;\n        }\n        last[sum] = i;\n    }\n    cout << (dp[n] + MOD- (sum == 0)) % MOD << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#include<iostream>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\n#define VI vector<int>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=100005;\nconst int mod=1e9+7;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nchar ch[MAXN];\nint val[MAXN],pres[MAXN],pos[5];\nint f[MAXN],S[4][MAXN],R[MAXN],L[MAXN];\nint li[MAXN],hd,tl;\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\t#ifdef Rose\n\t\tdouble BeginJudgeTime=clock();\n\t#endif\n\tscanf(\"%s\",ch+1);int len=strlen(ch+1);\n\tfor(int i=1;i<=len;i++)val[i]=ch[i]-'a'+1;\n\tmemset(pos,-1,sizeof(pos));pos[0]=0;\n\tfor(int i=1,S=0,v=0;i<=len;i++)\n\t{\n\t\twhile(S>1)S-=(val[v]==val[v+1]),++v;\n\t\twhile(S==1&&val[v]!=val[v+1])++v;\n\t\tR[i]=v-1;S+=(val[i+1]==val[i]);\n\t\tpres[i]=(pres[i-1]+val[i])%3;\n\t\tL[i]=pos[pres[i]]+1;pos[pres[i]]=i;\n\t}\n\tif(R[len]==-1)return pr2(1),0;\n\tf[0]=S[0][0]=S[3][0]=1;\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(R[i]>=L[i]-1)f[i]=(S[3][R[i]]-S[3][L[i]-1]+mod)%mod;\n\t\tad(f[i],f[i-1]);\n\t\tfor(int j=0;j<=3;j++)S[j][i]=S[j][i-1];\n\t\tad(S[pres[i]][i],f[i]);ad(S[3][i],f[i]);\n\t}int ans=0;\n\tfor(int i=1;i<=len;i++)if(pres[len]==pres[i])ad(ans,f[i]);\n\tpr2(ans);\n//\tpr2(f[len]);\n\t#ifdef Rose\n\t\tdouble EndJudgeTime=clock();\n\t\tcerr<<\"JudgeTime is\"<<\" \";\n\t\tcerr<<(EndJudgeTime-BeginJudgeTime)/CLOCKS_PER_SEC<<endl;\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nint p = 1000000007;\n#define vel vector<int>\n#define rep(i,n) for(long long i=0;i<n;i++)\nint main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tvector<vel> lis(3);\n\tvel sum(n + 1);\n\tbool fl = true;\n\trep(i, n) {\n\t\tlis[sum[i]].push_back(i);\n\t\tsum[i + 1] = sum[i] + (s[i] - 'a') + 1; sum[i + 1] %= 3;\n\t\tif (i % 2 == 0 xor s[i] == s[0]) { fl = false; }\n\t}\n\tif (fl) { cout << 1 << endl; return 0; }\n\tvel dp(n);\n\tdp[0] = 1;\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (sum[i] != sum[n]) { ans += dp[i]; }\n\t\tint pla = (sum[i] + 1) % 3;\n\t\tauto itr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; dp[*itr] %= p; }\n\t\tpla++; pla %= 3;\n\t\titr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; dp[*itr] %= p; }\n\t}\n\tcout << ans % p << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10,mod=1e9+7;\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\ninline void Dec(int &x,int y) { x-=y; if(x<0) x+=mod; }\nchar S[N];\nint s[N],f[N],sum[N],n;\nint lb[N],rb[N];\nint main() {\n\tscanf(\"%s\",S+1); n=strlen(S+1);\n\tint flg=0;\n\tfor(int i=1;i<n;++i) flg|=S[i]==S[i+1];\n\tif(!flg) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i) s[i]=s[i-1]+(S[i]-'a'+1);\n\tint last[3]={0,-1,-1};\n\tint lst=-1;\n\tfor(int i=1;i<=n;++i) {\n\t\tif(i>1&&S[i-1]==S[i]) lst=i-2;\n\t\trb[i]=lst;\n\t\tlb[i]=last[s[i]%3];\n\t\tlast[s[i]%3]=i;\n//\t\tcout<<i<<':'<<lb[i]<<' '<<rb[i]<<endl;\n\t}\n\tf[0]=sum[0]=1;\n\tfor(int i=1;i<=n;++i) {\n\t\tAdd(f[i],f[i-1]);\n\t\tif(lb[i]<rb[i]) {\n\t\t\tAdd(f[i],sum[rb[i]]);\n\t\t\tif(lb[i]>-1) Dec(f[i],sum[lb[i]]);\n\t\t}\n\t\tsum[i]=(sum[i-1]+f[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i) if((s[n]-s[i])%3==0) Add(ans,f[i]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n\ntypedef unsigned long long lu;\ntypedef vector<int> Poly;\n\nconst int mod = 1e9 + 7;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x = Sub(x - y); }\ninline int Mul(int x, int y) { return (lu)x * y % mod; }\ninline int Mul(int x, int y, int z) { return (lu)x * y % mod * z % mod; }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\nint Inv(int x) { return Pow(x, mod - 2); }\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\n\nint n;\nchar ori[maxn + 1];\nint sum[maxn + 1];\nint fir_s[maxn + 1][3];\nint fir_c[maxn + 1];\nbool suf[maxn + 1];\n\nint dp[maxn + 1];\nint pat;\n\nint FindFirst(int begin, int s) {\n  if (ori[begin] == 'a' + s - 1) return begin + 1;\n  int tar = (sum[begin] + s) % 3;\n  int i = fir_c[begin];\n  if (i == n + 1) return n + 1;\n  return fir_s[i + 2][tar];\n}\n\nint Solve(void) {\n  FILL(dp, n + 1, 0);\n  dp[0] = 1;\n\n  for (int L = 0; L < n; ++L) {\n    // to the end\n    if (suf[L]) {\n      Add(dp[n], dp[L]);\n    }\n\n    // to the mid\n    for (int x = 1; x <= 2; ++x) {\n      int R = FindFirst(L, x);\n      if (R < n) {\n        Add(dp[R], dp[L]);\n      }\n    }\n  }\n\n  return dp[n];\n}\n\nint main(void) {\n  scanf(\"%s\", ori);\n  n = strlen(ori);\n\n  pat = 0;\n  for (int i = n - 2; i >= 0; --i) {\n    if (ori[i] == ori[i + 1]) {\n      pat = i + 1;\n      break;\n    }\n  }\n\n  if (pat == 0) {\n    puts(\"1\");\n    return 0;\n  }\n\n  sum[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    sum[i + 1] = (sum[i] + (ori[i] - 'a' + 1)) % 3;\n  }\n\n  fir_s[n][0] = fir_s[n][1] = fir_s[n][2] = n + 1;\n  for (int i = n - 1; i >= 0; --i) {\n    COPY(fir_s[i + 1], 3, fir_s[i]);\n    fir_s[i][sum[i]] = i;\n  }\n\n  fir_c[n] = n + 1;\n  for (int i = n - 1; i >= 0; --i) {\n    fir_c[i] = fir_c[i + 1];\n    if (i + 1 < n && ori[i] == ori[i + 1]) {\n      fir_c[i] = i;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    suf[i] = (i == n - 1) || (fir_c[i] != n + 1 && sum[n] - sum[i] != 0) ||\n      ((n - i & 1) && i >= pat);\n  }\n\n  int ans = Solve();\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define che\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define MK make_pair\n#define PB push_back\n#define fi first\n#define se second\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int N=3e5 +10 ;\nconst LL MOD = 1e9+7;\nint pre[N], n, nxt[3];\nLL f[N]; char s[N];\n\n\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tscanf(\"%s\", s); n=strlen(s);\n\tfor (int i=0; i<n; ++i) pre[i+1] =( pre[i] + (s[i]-'a'+1))%3;\n\t\n\tbool flag= false;\n\tfor (int i=0; i+1 < n; ++i)\n\t\tif ( s[i] ==s[i+1] ) flag= true;\n\tif ( !flag){\n\t\tputs(\"1\"); return 0;\n\t}\n\tfor (int i=0; i<3; ++i) nxt[i] = i==pre[n] ? n: n+1;\n\tf[n] = 1;\n\tfor (int i=n; i--; ){\n\t\tf[i] = i&&pre[i] == pre[n];\n\t\tfor (int c=0; c<2; ++c)\n\t\t\tf[i] =(f[i] + f[ nxt[(pre[i]+c+1)%3] ])%MOD;\n\t\tnxt[ pre[i]] = i;\n\t}\n\tcout<<f[0]<<endl;\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=100050;\nvoid add(int &x, int y){ x+=y;if(x>=mod) x-=mod;}\nchar s[N];\nint dp[N],nxa[N],nxb[N],lst[3],pre[N];\nint main()\n{\n\tint n,i;\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tint ok=0;\n\tfor(i=1;i<n;i++) if(s[i]==s[i+1]) ok=1;\n\tif(!ok) return 0*printf(\"1\\n\");\n\tfor(i=1;i<=n;i++) pre[i]=(pre[i-1]+s[i]-'a'+1)%3;\n\tfor(i=n;i>=0;i--) nxa[i]=lst[(pre[i]+1)%3],nxb[i]=lst[(pre[i]+2)%3],lst[pre[i]]=i;\n\tdp[0]=1;\n\tfor(i=0;i<n;i++) add(dp[nxa[i]],dp[i]),add(dp[nxb[i]],dp[i]);\n\tint sum=0;\n\tfor(i=1;i<=n;i++) if(pre[i]==pre[n]) add(sum,dp[i]);\n\tprintf(\"%i\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define For(i, a, b) for(register int i = a; i <= b; ++i)\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int mod = 1e9 + 7;\nchar s[maxn];\nint dp[maxn], sum[maxn], n, flag, trans[3] = {0, -1, -1};\n \nvoid Add(int & a, const int &b) {\n\ta += b;if(a >= mod) a -= mod;\n}\n \nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1), dp[0] = 1;\n\tFor(i, 1, n) sum[i] = (sum[i - 1] + (s[i] - 'a' + 1)) % 3;\n\tFor(i, 2, n)\n\t\tif(s[i] == s[i - 1]) \n\t\t\t{flag = 1; break;}\n\tif(!flag) return printf(\"1\"), 0;\n\tint from; dp[0] = 1;\n\tFor(i, 1, n) {\n\t\tif(!sum[i] && i < n) dp[i] = 1;\n\t\tAdd(dp[i], dp[i - 1]);\n\t\tfrom = trans[(sum[i] + (s[i] == 'a' ? 1 : 2)) % 3];\n\t\tif(~from) Add(dp[i], dp[from]);\n\t\ttrans[sum[i]] = i;\n\t}\n\tprintf(\"%d\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5, mod = 1e9 + 7;\nint n, dp[N], r[N], prefSum[N], lst[N][3], Lst[3], ans;\nstring s;\n\nvoid add (int &_a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> s; n = s.size(); s = '!' + s;\n\n    bool diff = 1;\n    for (int i = 1; i < n; ++i) if (s[i] == s[i + 1]) diff = 0;\n    if (diff) return cout << 1, 0;\n\n    int R = n + 1;\n    for (int i = n; i >= 0; --i) {\n        r[i] = R;\n        if (s[i] == s[i + 1]) R = i + 1;\n    }\n\n    for (int i = 1; i <= n; ++i) prefSum[i] = (prefSum[i - 1] + (s[i] == 'a' ? 1 : 2) ) % 3;\n\n    Lst[0] = Lst[1] = Lst[2] = n + 1;\n    for (int i = n; i > 0; --i) {\n        Lst[ prefSum[i] ] = i;\n        for (int j = 0; j < 3; ++j) lst[i][j] = Lst[j];\n    }\n\n    dp[0] = 1;\n    for (int i = 0; i <= n; ++i) {\n        add(dp[i + 1], dp[i]);\n        if (r[i] <= n) {\n            for (int j = 0; j < 3; ++j) {\n                int tmp = (prefSum[ lst[ r[i] ][j] ] - prefSum[i] + 3) % 3;\n                if (s[i + 1] == 'a' && tmp == 2) add(dp[ lst[ r[i] ][j] ], dp[i]);\n                if (s[i + 1] == 'b' && tmp == 1) add(dp[ lst[ r[i] ][j] ], dp[i]);\n            }\n        }\n    }\n\n    for (int i = n; i > 0; --i) if (prefSum[i] == prefSum[n]) add(ans, dp[i]);\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nint read(){char c=getchar();int d=0,f=1;for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;for(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());return d*f;}\nchar Read(){char c=getchar();while(c<'0'||c>'9')c=getchar();return c;}\ntypedef pair<int,int>PII;\ntypedef long long LL;\nconst int N=100000;\nconst int mod=1e9+7;\nint n,dp[N+1],a[N+1],t[N+1][3],tt[N+1],p[10];\nchar s[N+1];\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tref(i,1,n)a[i]=(s[i]=='a'?1:2);\n\tref(i,1,n)(a[i]+=a[i-1])%=3;\n\tdef(i,n,1){\n\t\tref(j,0,2)t[i][j]=t[i+1][j]; t[i][a[i]]=i;\n\t\ttt[i]=tt[i+1]; if(i<n&&(a[i-1]+a[i+1]-2*a[i])%3==0)tt[i]=i+1;\n\t}\n\tdp[0]=1;\n\tref(i,0,n-1)if(dp[i]){\n\t\tp[0]=0;\n\t\tp[++p[0]]=i+1;\n\t\tif(i&&i!=n-1&&!tt[i+1]&&(i%2!=n%2))p[++p[0]]=n;\n\t\tif(tt[i+1])ref(j,0,2)if(j!=a[i]&&j!=a[i+1])p[++p[0]]=t[tt[i+1]][j];\n\t\tif(tt[i+1]&&a[n]!=a[i]){\n\t\t\tp[++p[0]]=n;\n\t\t\tref(j,1,p[0]-1)if(p[j]==n)p[0]--;\n\t\t}\n\t\tref(j,1,p[0])(dp[p[j]]+=dp[i])%=mod;\n\t\t//ref(j,1,p[0])cout<<p[j]<<\" \";cout<<endl;\n\t}\n\tcout<<dp[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MODULO = 1e9 + 7;\n\nmap<vector<int>, ll> ans;\nll Solve(int at, int sum, int want, int len, int was, const vector<int>& a) {\n  if (at == a.size()) {\n    if (sum == want) return 1;\n    return 0;\n  }\n\n  vector<int> state = {at, sum, want, len, was};\n  if (ans.count(state)) return ans[state];\n\n  ll& result = ans[state];\n  \n  result = 0;\n  \n  if (sum == want && want != 0 && (len == 1 || was)) {\n    for (int w = 0; w < 3; ++w) result = (result + Solve(at, 0, w, 0, 0, a)) % MODULO;\n    return result;\n  }\n\n  int newLen = min(len + 1, 2);\n  int newWas = was;\n  if (len != 0) newWas |= (a[at] == a[at - 1]);\n  int newSum = (sum + a[at]) % 3;\n\n  result = (result + Solve(at + 1, newSum, want, newLen, newWas, a)) % MODULO;\n\n  return result;\n}\n\nint main()\n{\n  string s;\n  cin >> s;\n  int n = s.size();\n  vector<int> a(n, 1);\n  for (int i = 0; i < n; ++ i) if (s[i] == 'b') a[i] = 2;\n  ll result = (Solve(0, 0, 1, 0, 0, a) + Solve(0, 0, 2, 0, 0, a)) % MODULO;\n  cout << result << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\nint arr[MAXN], pref[MAXN], cnts[MAXN];\nint lst[3];\nint dp[MAXN];\nint ans;\nset<int> num[3];\n\nint rsum(int L, int R)\n{\n\treturn (pref[R + 1] - pref[L] + 3) % 3;\n}\nbool bad(int L, int R)\n{\n\treturn ((R > L) && (cnts[R + 1] - cnts[L] == 0));\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tstring temps;\n\tcin >> temps;\n\tN = temps.length();\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tarr[i] = ((temps[i] == 'a') ? 1 : 2);\n\t\tpref[i + 1] = pref[i] + arr[i]; nmod(pref[i + 1], 3);\n\t\tcnts[i + 1] = cnts[i] + ((i != 0 && arr[i] == arr[i - 1]) ? 1 : 0);\n\t}\n\tif (bad(0, N - 1))\n\t{\n\t\tcout << \"1\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i <= N; i++)\n\t{\n\t\tnum[pref[i]].insert(i);\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i <= N; i++)\n\t{\n\t\tnum[pref[i]].erase(i);\n\t\tif (!num[(pref[i] + 1) % 3].empty())\n\t\t{\n\t\t\tint idx = *num[(pref[i] + 1) % 3].begin();\n\t\t\tif (!bad(i, idx - 1)) dp[idx] += dp[i];\n\t\t}\n\t\tif (!num[(pref[i] + 2) % 3].empty())\n\t\t{\n\t\t\tint idx = *num[(pref[i] + 2) % 3].begin();\n\t\t\tif (!bad(i, idx - 1)) dp[idx] += dp[i];\n\t\t}\n\t\tif (i != 0 && rsum(i, N - 1) == 0)\n\t\t{\n\t\t\tans += dp[i];\n\t\t\t// cerr << \"add \" << i << ' ' << dp[i] << endl;\n\t\t\tnmod(ans, INF);\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=1e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N][3],last[3];\nsigned main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  string s;\n  int n,i,j,k,l=0;\n  cin>>s;\n  n=s.size();\n  s=\" \"+s;\n  dp[0]=1;\n  sum[0][0]=1;\n  last[1]=-1;\n  last[2]=-1;\n  bool cac=true;\n  for(i=1;i<=n;i++){\n    if(s[i]==s[i-1]){\n      cac=false;\n    }\n    if(s[i]=='a'){\n      l++;\n    }\n    else{\n      l+=2;\n    }\n    if(l>=3){\n      l-=3;\n    }\n    for(j=0;j<3;j++){\n      sum[i][j]=sum[i-1][j];\n      dp[i]+=sum[i][j];\n        if(last[l]>-1){\n          dp[i]-=sum[last[l]][j];\n        }\n    }\n  \tdp[i]-=sum[i][l];\n    if(last[l]>-1){\n      dp[i]+=sum[last[l]][l];\n    }\n    dp[i]=(dp[i]%mod+mod)%mod;\n    last[l]=i;\n    sum[i][l]+=dp[i];\n    sum[i][l]%=mod;\n    //cout<<dp[i]<<endl;\n  }\n  if(cac){\n    cout<<1;\n    return 0;\n  }\n  if(!l){\n    sum[n][l]=(sum[n][l]-1+mod)%mod;\n  }\n  cout<<sum[n][l];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int maxn = int(1e5) + 7, mod = int(1e9) + 7;\nint next[maxn][3], f[maxn] = {1}, sum[maxn], ans;\nchar str[maxn];\nint main() {\n    scanf(\"%s\", str);\n    int n = int(strlen(str));\n    bool flag = true;\n    for (int i = 1; str[i]; i++) flag &= str[i] != str[i - 1];\n    if (flag) return 0 * puts(\"1\");\n    for (int i = 0; i < n; i++) sum[i + 1] = (sum[i] + 1 + (str[i] == 'b')) % 3;\n    for (int i = 0; i < 3; i++) next[n][i] = n + 1;\n    for (int i = n - 1; ~i; i--) for (int j = 0; j < 3; j++) next[i][j] = j == sum[i + 1] ? i + 1 : next[i + 1][j];\n    for (int i = 0; i <= n; i++) {\n        for (int j = 1; j <= 2; j++) if (next[i][(sum[i] + j) % 3] <= n) f[next[i][(sum[i] + j) % 3]] = (f[i] + f[next[i][(sum[i] + j) % 3]]) % mod;\n        if (i > 0 && sum[i] == sum[n]) ans = (ans + f[i]) % mod;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <map>\n#include <set>\n#include <list>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n\nusing namespace std;\n\nint i,j,k,l,m,n;\n/////////////////////////////////////////////////////\n#define mp make_pair\n#define MOD (ll)10e9+7\n\nchar s[101010];\nll leng;\nll dp[2][101010][2];\nll ref;\n\nint main(){\n    scanf(\"%s\",s);\n    for(leng=0;s[leng]!='\\0';leng++);\n\n    dp[0][0][s[i]-'a']=1;\n\n    for(i=1;i<leng;i++){\n        for(j=0;j<i;j++){\n            dp[i%2][j][!(s[i]-'a')]+=dp[(i+1)%2][j][s[i]-'a'];\n            dp[i%2][j][!(s[i]-'a')]%=MOD;\n            dp[i%2][j+1][s[i]-'a']+=dp[(i+1)%2][j][s[i]-'a'];\n        }\n    }\n    for(i=0;i<leng;i++){\n        ref+=dp[(leng+1)%2][i][0]+dp[(leng+1)%2][i][1];\n        ref%=MOD;\n    }\n    printf(\"%lld\",ref);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define INF 1061109567\n#define bp __builtin_popcountll\n#define pb push_back\n#define in(s) freopen(s,\"r\",stdin);\n#define out(s) freopen(s,\"w\",stdout);\n#define fi first\n#define se second\n#define bw(i,r,l) for (int i=r-1;i>=l;i--)\n#define fw(i,l,r) for (int i=l;i<r;i++)\n#define fa(i,x) for (auto i:x)\nusing namespace std;\nconst int N = 1e5 + 5;\nstring s;\nint n, dp[N], f[N][3], sum[N];\nbool bad = 1;\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= MOD) x -= MOD;\n}\nsigned main() {\n\t#ifdef BLU\n\tin(\"blu.inp\");\n\t#endif\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> s;\n\tint n = s.length();\n\t/*\n\tWe can see greedily that always picking the earliest possible spots to create an a or b is good\n\tenough.\n\tdp[i]: Number of different substrings we can create from the first i characters of s\n\tThen pass onto 2 positions j1 and j2, so that i + 1 -> j1 can create 'a', and to j2 create 'b'.\n\tFor a, psum[j1] - psum[i] must mod 3 remainder 1. So we can know the remainder psum[j1] should\n\thave, and this can be easily found by a supporting array.\n\t*/\n\ts = \" \" + s;\n\tmemset(sum, 0, sizeof sum);\n\tfw (i, 1, n + 1) sum[i] = sum[i - 1] + (s[i] == 'a' ? 1 : 2);\n\tmemset(f, -1, sizeof f);\n\t/*\n\tf[i][j]: The first index k that considering the segment from i + 1 -> k, its sum MOD 3 is equal to\n\tj. Also, there are at least 2 adjancent characters that are equal (or the length is 1)\n\t*/\n\tfw (i, 1, n) if (s[i] == s[i + 1]) bad = 0;\n\tif (bad) {\n\t\tcout << \"1\";\n\t\treturn 0;\n\t}\n\tbw (i, n + 1, 0) {\n\t\tfw (j, 0, 3) f[i][j] = f[i + 1][j];\n\t\tif (i) f[i][sum[i] % 3] = i;\n\t}\n\tmemset(dp, 0, sizeof dp);\n\tdp[0] = 1;\n\tfw (i, 0, n + 1) {\n\t\tfw (j, 1, 3) {\n\t\t\tint k = (j + sum[i]) % 3;\n\t\t\tk = f[i][k];\n\t\t\tif (k != -1) add(dp[k], dp[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfw (i, 1, n + 1) {\n\t\tif (sum[i] % 3 == sum[n] % 3) add(ans, dp[i]);\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define For(i, a, b) for(register int i = a; i <= b; ++i)\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int mod = 1e9 + 7;\nchar s[maxn];\nint dp[maxn], sum[maxn], n, flag;\nint trans[maxn][3];\nint frt[maxn];\n \nvoid Add(int & a, const int &b) {\n\ta += b;if(a >= mod) a -= mod;\n}\n \nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1), dp[0] = 1;\n\ttrans[0][0] = 0, trans[0][1] = -1, trans[0][2] = -1;\n\tFor(i, 1, n) sum[i] = (sum[i - 1] + (s[i] - 'a' + 1)) % 3;\n\tfrt[1] = 1;\n\tFor(i, 2, n)\n\t\tif(s[i] != s[i - 1]) frt[i] = frt[i - 1];\n\t\telse frt[i] = i;\n\tint from; dp[0] = 1;\n\tFor(i, 1, n) {\n\t\tAdd(dp[i], dp[i - 1]);\n\t\tif(frt[i] - 1 == 0) continue;\n\t\tif(!sum[i] && i < n) dp[i] += 1;\n\t\t//枚举最后填a或填b \n\t\tfrom = trans[frt[i] - 1][(sum[i] - (s[i] == 'a' ? 2 : 1) + 3) % 3];\n\t\tif(~from) Add(dp[i], dp[from]);\n\t\ttrans[i][0] = trans[i - 1][0];\n\t\ttrans[i][1] = trans[i - 1][1];\n\t\ttrans[i][2] = trans[i - 1][2];\n\t\ttrans[i][sum[i]] = i;\n\t}\n\tprintf(\"%d\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007,N=100100;\nchar s[N];\nint a[N],g[N],ans,f[N],h[3],cnt[3],n;\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>(s+1);n=strlen(s+1);\n\tf[0]=1;\n\tfor(int i=n;i;--i){a[i]=s[i]-'`';g[i]=(g[i+1]+a[i])%3;}\n\th[0]=h[1]=h[2]=2;++n;\n\tfor(int i=1;i<=n;++i){\n\t\tif(a[i]==a[i-1])--cnt[0],--cnt[1],--cnt[2];\n\t\tfor(int j=0;j<3;++j)\n\t\t\tfor(;h[j]<=n&&(!cnt[j]||g[h[j]]!=j);++h[j])\n\t\t\t\tcnt[j]+=a[h[j]-1]==a[h[j]];\n\t\tif(i==1&&h[0]>n&&h[1]>n&&h[2]>n){cout<<1<<'\\n';return 0;}\n\t\tf[i]=(f[i]+f[i-1])%mod;int t=(g[i]+a[i])%3;\n\t\tif(h[t]<=n)f[h[t]-1]=(f[h[t]-1]+f[i-1])%mod;\n\t\tif(i>1&&!g[i])ans=(ans+f[i-1])%mod;\n\t}\n\tcout<<ans<<'\\n';\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nstring s;\nvi a,S,b[3],g[2];\n\nint main(){\n\tcin>>s;\n\tn=s.size();\n\ta=vi(n);S=vi(n+1);\n\tb[0]=b[1]=b[2]=g[0]=g[1]=vi(n+1,-1);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='a') a[i]=2;\n\t\telse a[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++) S[i]=S[i-1]+a[i-1];\n\tfor(int i=n-1;i>=0;i--){\n\t\tb[a[i]][i]=i+1;\n\t\tfor(int j=0;j<3;j++) if(j!=a[i]){\n\t\t\tb[j][i]=b[(j-a[j]+3)%3][i+1];\n\t\t}\n\t}\n\tint I=-1;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i!=n-1&&s[i]==s[i+1]) I=i+2;\n//\t\tcout<<I<<endl;\n\t\tif(s[i]=='a'){\n\t\t\tg[0][i]=i+1;\n\t\t\tif(I==-1) continue;\n\t\t\tint t=(4-S[I]+S[i])%3;\n\t\t\tif(!t) g[1][i]=I;\n\t\t\telse g[1][i]=b[(4-S[I]+S[i])%3][I];\n\t\t}\n\t\telse{\n\t\t\tg[1][i]=i+1;\n\t\t\tif(I==-1) continue;\n\t\t\tint t=(5-S[I]+S[i])%3;\n\t\t\tif(!t) g[0][i]=I;\n\t\t\telse g[0][i]=b[(5-S[I]+S[i])%3][I];\n\t\t}\n\t}\n\tint J=-1;\n\tfor(int i=n-2;i>=0;i--) if(s[i]==s[i+1]){\n\t\tJ=i+2;\n\t\tbreak;\n\t}\n\tif(J==-1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tvi dp(n+1);\n\tdp[0]++;\n\tint res=0;\n\tfor(int i=0;i<n;i++) for(int j=0;j<2;j++) if(g[j][i]!=-1){\n\t\tI=g[j][i];\n\t\t(dp[I]+=dp[i])%=mod;\n\t\tif((S[n]-S[I]+3)%3==0&&(I!=i+1||i+1>=I))(res+=dp[i])%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n    }\n    int nx[2][100010];\n    int p[3][100010];\n    for(int j=0; j<3; j++) p[j][n]=n;\n    int mn[100010];\n    mn[n]=n+1;\n    for(int i=n-1; i>=0; i--){\n        for(int j=0; j<3; j++) p[j][i]=p[j][i+1];\n        p[c[i]][i]=i;\n        mn[i]=mn[i+1];\n        if(i<n-1 && s[i]==s[i+1]) mn[i]=i+2;\n        if(s[i]=='a'){\n            nx[0][i]=i+1;\n            if(mn[i]<=n) nx[1][i]=p[(c[i]+2)%3][mn[i]];\n            else nx[1][i]=n+1;\n        }else{\n            nx[1][i]=i+1;\n            if(mn[i]<=n) nx[0][i]=p[(c[i]+1)%3][mn[i]];\n            else nx[0][i]=n+1;\n        }\n    }\n    ll dp[2][100010]={};\n    dp[0][0]=1;\n    ll ans=0;\n    for(int i=0; i<n; i++){\n        //cout<<nx[0][i]<<\" \"<<nx[1][i]<<endl;\n        int x=(c[n]-c[i]+3)%3;\n      if(x!=0) (ans+=dp[1][i])%=MOD;\n      if(x!=0 && (i==n-1 || mn[i]<=n)) (ans+=dp[0][i])%=MOD;\n      else if(i>0 && s[i]==s[i-1]) (ans+=(n-i-1)/2)%=MOD;\n      //cerr<<mn[i]<<endl;\n      //cerr<<dp[0][i]<<endl;\n        if(nx[0][i]<n){\n          if(nx[0][i]==i+1){\n            (dp[0][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }\n        }\n        if(nx[1][i]<n){\n          if(nx[1][i]==i+1){\n            (dp[0][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\nint N;\nchar S[100005];\nint Next[100005], P[100005], DP[100005];\nconst int MOD = 1000000007;\nvector <int> V[3];\nint ind[3];\nvoid Read()\n{\n    cin.getline(S + 1, 100005);\n    N = strlen(S + 1);\n    //V[P[0]].push_back(0);\n    for(int i = 1; i <= N; i++)\n    {\n        P[i] = P[i - 1] + S[i] - 'a' + 1;\n        while(P[i] >= 3)\n            P[i] -= 3;\n        V[P[i]].push_back(i);\n    }\n}\ninline void Add(int& x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\nvoid Solve()\n{\n    int next = 1;\n    DP[1] = 1;\n    int ans = 0;\n    for(int i = 1; i <= N; i++)\n    {\n        if(next <= i)\n        {\n            while(next <= N && (S[next] != S[next - 1] || next <= i))\n            {\n                ind[P[next]]++;\n                ++next;\n            }\n        }\n        Add(DP[i + 1], DP[i]);\n        for(int j = 0; j < 3; j++)\n        {\n            if(P[i - 1] == j || ((j - P[i - 1] + 3) % 3) == S[i] - 'a' + 1)\n                continue;\n            if(ind[j] == V[j].size())\n                continue;\n            Add(DP[V[j][ind[j]] + 1], DP[i]);\n        }\n        if(P[N] == P[i - 1] && i > 1)\n            Add(ans, DP[i]);\n    }\n    Add(ans, DP[N + 1]);\n    /*for(int i = N - 1; i > 1; i--)\n    {\n        if(S[i] == S[i + 1])\n            break;\n        if(P[N] == P[i - 1] && S[i - 1] != S[i])\n            Add(ans, MOD - 1);\n    }*/\n    cout << ans << '\\n';\n}\nint main()\n{\n    Read();\n    bool ok = 0;\n    for(int i = 2; i <= N; i++)\n        if(S[i] == S[i - 1])\n        {\n            ok = 1;\n            break;\n        }\n    if(ok == 0)\n    {\n        cout << \"1\\n\";\n        return 0;\n    }\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\nconst int mod = 1e9+7,base=3;\ninline int read(){char ch=gc;int w=1,s=0;while(!isdigit(ch)){if(ch=='-') w=-1;ch=gc;};while(isdigit(ch)){s=s*10+ch-'0';ch=gc;} return w*s;}\nint Sum[1000100],A[1000010],n,nxt[1000100][3];\nint f[1000010];\nchar ch[1000010]; \ninline int add(int a,int b){a+=b;if(a>=mod) a-=mod;return a;}\nint main()\n{\n\tscanf(\"%s\",ch+1);n=strlen(ch+1);\n\tint fl=0;\n\tfor(rint i=1;i<=n;++i) A[i]=ch[i]=='a'?1:2;\n//\tfor(rint i=1;i<=n;++i) cout<<A[i]<<\"\\n\";\n\tfor(rint i=1;i<=n;++i) Sum[i]=(Sum[i-1]+A[i])%base;\n\tfor(rint i=1;i<n;++i) if(A[i]==A[i+1]) fl=1;\n\tif(!fl)\n\t{\n\t//\tcout<<1<<\"\\n\";\n\t\tcout<<\"1\";return 0;\n\t}\n\tfor(rint i=n;i;--i) memcpy(nxt[i],nxt[i+1],sizeof(nxt[i+1])),nxt[i][Sum[i]]=i;\n\tf[0]=1;\n\tfor(rint i=0;i<n;++i)\n\t{\n\t\tfor(rint j=0;j<base;++j)\n\t\t{\n\t\t\tif(j!=Sum[i])\n\t\t\t{\n\t\t\t\tint tmp=nxt[i+1][j];\n\t\t\t\tif(tmp) f[tmp]=add(f[i],f[tmp]);\n\t\t\t}\n\t\t}\n\t}int res=0;\n\tfor(rint i=1;i<=n;++i) if(Sum[i]==Sum[n]) res=add(res,f[i]);\n\tcout<<res<<\"\\n\";\n\treturn 0;\n}\n/*\nby was_n\n2018.9.17\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in\",\"r\",stdin);\n\tfreopen(\"out\",\"w\",stdout);\n#endif\n}\nint n;\nchar s[N];\nvoid input()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n}\nint sum[N],nex[N][3];\nconst int mo=1e9+7;\nvoid add(int &x,int y)\n{\n\tx+=y;x-=(x>=mo?mo:0);\n}\nint dp[N],ans;\nvoid work()\n{\n\tint flag=0;\n\tFor(i,2,n)if(s[i]==s[i-1])flag=1;\n\tif(!flag){puts(\"1\");return;}\n\tFor(i,1,n)sum[i]=sum[i-1]+(s[i]-'a'+1);\n\tFor(i,0,2)nex[n+1][i]=n+1;\n\tFordown(i,n,1)\n\t{\n\t\tFor(j,0,2)nex[i][j]=nex[i+1][j];\n\t\tnex[i][sum[i]%3]=i;\n\t}\n\tdp[0]=1;\n\tFor(i,0,n)\n\t{\n\t\tFor(j,1,2)\n\t\t{\n\t\t\tadd(dp[nex[i+1][(sum[i]+j)%3]],dp[i]);\n\t\t\t//cout<<i<<' '<<nex[i+1][(sum[i]+j)%3]<<endl;\n\t\t}\n\t\tif(i&&sum[i]%3==sum[n]%3)add(ans,dp[i]);\n\t}\n\twrite(ans,'\\n');\n}\nint main()\n{\n//\tfile();\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define ll long long\n#define db double\n#define ull unsigned long long\n#define uint unsigned int\n#define FIO \"\"\n#define dbug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename Y> inline bool updmin(Y &a, Y b){if (a > b) {a = b; return 1;} return 0;}\ntemplate <typename Y> inline bool updmax(Y &a, Y b){if (a < b) {a = b; return 1;} return 0;}\ntemplate <typename Y> inline Y abs(Y a){if (a < 0) a = -a; return a;}\ntemplate <typename Y> inline Y sqr(Y a){return a * a;}\n\ntypedef std::pair<int, int> par;\n#define fx first\n#define fy second\n#define mpar std::make_pair\n#define pb push_back\n\nint read() {\n  int w = 1, q = 0, ch = ' ';\n  for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) q = q * 10 + ch - 48;\n  return q * w;\n}\n\ninline void FileIO(){freopen(FIO\".in\", \"r\", stdin); freopen(FIO\".out\", \"w\", stdout);}\n\n#include <cstring>\nconst int N = 100010, mod = 998244353;\nchar s[N];\nint g[N], f0[N], f1[N], n, sum[N];\n\nint main() {\n  scanf(\"%s\", s + 1);\n  n = (int)strlen(s + 1);\n  g[n + 1] = n + 1;\n  sum[n + 1] = 0;\n  for (int i = n; i; i--) {\n    g[i] = s[i] == s[i + 1] ? i + 1 : g[i + 1];\n    sum[i] = (sum[i + 1] + s[i] - 'a' + 1) % 3;\n  }\n  f0[0] = 1;\n  int ans = 0;\n  for (int i = 0; i <= n; i++) {\n    if ((i && sum[i + 1] == 0 && g[1] != n + 1) || i == n) {\n      ans = (ans + f0[i]) % mod;\n    }\n    if (i && sum[i + 1] == 0) {\n      ans = (ans + f1[i]) % mod;\n    }\n    int f = (f0[i] + f1[i]) % mod;\n    f0[i + 1] = (f0[i + 1] + f) % mod;\n    f1[g[i + 1]] = (f1[g[i + 1]] + f) % mod;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int N = 200010, P = 1e9 + 7;\nchar s[N];\nint num[N], f[N][3], n, tag[N], pre[N], ans, sam[N];\nset <int> mp[3];\nint main(){\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tscanf(\"\\n%s\", s + 1);\n\tn = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++) num[i] = s[i] - 'a' + 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (sam[i - 1] >= i) sam[i] = sam[i - 1];\n\t\telse {\n\t\t\tsam[i] = n;\n\t\t\tfor (int j = i; j < n; j++){\n\t\t\t\tif (num[j] == num[j + 1]){\n\t\t\t\t\tsam[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) if (num[i] == num[i + 1])\n\tfor (int i = n; i >= 1; i--) tag[i] = tag[i + 1] | (num[i] == num[i - 1]); \n\tfor (int i = 1; i <= n; i++){\n\t\tpre[i] = (pre[i - 1] + num[i]) % 3;\n\t\tmp[pre[i]].insert(i);\n\t}\n\tmp[0].insert(n + 1), mp[1].insert(n + 1), mp[2].insert(n + 1);\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++){\n\t\tint cnt = ((f[i][0] + f[i][1]) % P + f[i][2]) % P;\n\t\tint j = *mp[(pre[i] + 1) % 3].upper_bound(sam[i + 1]);\n\t\tif (num[i + 1] == 1) j = i + 1;\n\t\tif (j <= n){\n\t\t\tif (j > i + 1 || num[j] == num[j - 1]) f[j][0] = (f[j][0] + cnt) % P;\n\t\t\t\telse f[j][1] = (f[j][1] + cnt) % P;\n\t\t}\n\t\tj = *mp[(pre[i] + 2) % 3].upper_bound(sam[i + 1]);\n\t\tif (num[i + 1] == 2) j = i + 1;\n\t\tif (j <= n){\n\t\t\tif (j > i + 1 || num[j] == num[j - 1]) f[j][0] = (f[j][0] + cnt) % P;\n\t\t\t\telse f[j][2] = (f[j][2] + cnt) % P;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (pre[n] - pre[i] == 0){\n\t\t\tif (tag[i + 1] == 1 || i == n) ans = (ans + f[i][1] + f[i][2]) % P;\n\t\t\tans = (ans + f[i][0]) % P;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nconst int inf = 1e7;\nconst long long mod = 1e9 + 7;\nint main() {\n        string s;\n        cin >> s;\n        int n = (int) s.size();\n        bool unko = true;\n        rep(i, n - 1) unko = unko && s[i] != s[i + 1];\n        if (unko) {\n                cout << 1 << endl;\n                return 0;\n        }\n        vector<int> acc(n + 1);\n        rep(i, n) {\n                int a = (s[i] == 'a' ? 1 : 2);\n                acc[i + 1] = (acc[i] + a) % 3;\n        }\n        // rep(i, n + 1) cerr << acc[i] << ' '; cerr << endl;\n        vector<vector<int>> app(n + 2, vector<int> (3));\n        rep(i, 3) app[n + 1][i] = inf;\n        for (int i = n; i >= 0; i --) {\n                rep(j, 3) {\n                        app[i][j] = (acc[i] == j ? i : app[i + 1][j]);\n                }\n        }\n        /*\n        rep(i, n + 2) {\n                rep(j, 3) cerr << app[i][j] << ' '; cerr << endl;\n        }\n        */\n        cerr << \"OK\" << endl;\n        long long ans = 0;\n        vector<int> add(n + 1);\n        add[0] = 1;\n        rep(i, n + 1) {\n                if (acc[n] == acc[i]) (ans += add[i]) %= mod; // cut last part (== 0 (mod 3))\n                for (int put = 1; put <= 2; put ++) {\n                        int pos = app[i + 1][(put + acc[i]) % 3];\n                        if (pos != inf) (add[pos] += add[i]) %= mod;\n                }\n        }\n        cout << ans << endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst int N=1e5+5,P=1e9+7;\n\nint n;\nchar s[N];\nint app_a[N],app_b[N];//在当前状态下加一个a后转移到的状态\nint nex[N][3];//下一个，前缀和%3=i的位置（不算当前的位置）\nint nex_xx[N];//下一个连续相同字符的位置， nex_xx[i] 和nex_xx[i]+1相同\nLL f[N];\n\nint main(){\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    FOR(i,1,n)s[i]=s[i]=='a'?1:2;\n    FOR(i,2,n)s[i]+=s[i-1];\n    nex[n][0]=nex[n][1]=nex[n][2]=n+1;\n    nex[n+1][0]=nex[n+1][1]=nex[n+1][2]=n+1;\n    ROF(i,n-1,0){\n        FOR(j,0,2)nex[i][j]=s[i+1]%3==j?i+1:nex[i+1][j];\n    }\n    //FOR(i,0,n)printf(\"%d%c\",nex[i][0],\" \\n\"[i==n]);\n    //FOR(i,0,n)printf(\"%d%c\",nex[i][1],\" \\n\"[i==n]);\n    //FOR(i,0,n)printf(\"%d%c\",nex[i][2],\" \\n\"[i==n]);\n    nex_xx[n]=nex_xx[n+1]=n+1;\n    ROF(i,n-1,0){\n        nex_xx[i]=s[i+1]-s[i]==s[i+2]-s[i+1]?i+1:nex_xx[i+1];\n    }\n    //FOR(i,0,n)printf(\"%d%c\",nex_xx[i],\" \\n\"[i==n]);\n    FOR(i,0,n){\n        app_a[i]=s[i+1]-s[i]==1?i+1:nex[nex_xx[i]][(s[i]+1)%3];\n        app_b[i]=s[i+1]-s[i]==2?i+1:nex[nex_xx[i]][(s[i]+2)%3];\n    }\n    //FOR(i,0,n)printf(\"%d%c\",app_a[i],\" \\n\"[i==n]);\n    //FOR(i,0,n)printf(\"%d%c\",app_b[i],\" \\n\"[i==n]);\n    f[0]=1;\n    FOR(i,0,n){\n        f[app_a[i]]=(f[app_a[i]]+f[i])%P;\n        f[app_b[i]]=(f[app_b[i]]+f[i])%P;\n    }\n    LL ans=0;\n    FOR(i,1,n)if(s[i]%3==s[n]%3)ans=(ans+f[i])%P;\n    if(nex_xx[0]==n+1)puts(\"1\");\n    else printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int N=1e5+5;\nconst int mod=1e9+7;\nint n,fg,sum[N],nxt[N][3],f[N],ans;\nchar str[N];\nvoid Inc(int &x,int y){\n\tx+=y;x>=mod?x-=mod:x;\n}\nint main(){\n\tscanf(\"%s\",str+1);n=strlen(str+1);\n\tfor(int i=1;i<n;++i)fg|=(str[i]==str[i+1]);\n\tif(!fg)return puts(\"1\"),0;\n\tfor(int i=1;i<=n;++i)sum[i]=(sum[i-1]+(str[i]=='a'?1:2))%3;\n\tfor(int i=n-1;~i;--i){\n\t\tfor(int j=0;j<3;++j)nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][sum[i+1]]=i+1;\n\t}\n\tf[0]=1;\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=1;j<3;++j)\n\t\t\tif(nxt[i][(sum[i]+j)%3])\n\t\t\t\tInc(f[nxt[i][(sum[i]+j)%3]],f[i]);\n\tfor(int i=1;i<=n;++i)\n\t\tif(sum[i]==sum[n])\n\t\t\tInc(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5, mod = 1e9 + 7;\nint n, a[maxn + 3], pos[maxn + 3][3], dp[maxn + 3], lst[maxn + 3];\nchar s[maxn + 3];\n\nvoid upd(int &x, int y) {\n\tx += y, x < mod ? 0 : x -= mod;\n}\n\nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tbool flag = true;\n\tfor (int i = 1; i < n; i++) {\n\t\tflag &= s[i] != s[i + 1];\n\t}\n\tif (flag) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = s[i] == 'a' ? 1 : 2;\n\t\ta[i] = (a[i] + a[i - 1]) % 3;\n\t}\n\tfor (int i = n; i; i--) {\n\t\tlst[a[i]] = i;\n\t\tfor (int j = 1; j <= 2; j++) {\n\t\t\tpos[i][j] = lst[(a[i - 1] + j) % 3];\n\t\t}\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 1; j <= 2; j++) {\n\t\t\tif (pos[i + 1][j]) {\n\t\t\t\tupd(dp[pos[i + 1][j]], dp[i]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif ((a[n] - a[i] + 3) % 3 == 0) {\n\t\t\tupd(ans, dp[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n\ntemplate<typename T> class BIT {\nprivate:\n\tint n;\n\tvector<T> bit;\npublic:\n\t// 0_indexed で i 番目の要素に x を加える\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile(i < n){\n\t\t\tbit[i] += x, i += i & -i;\n\t\t}\n\t}\n\t// 0_indexed で [0,i] の要素の和(両閉区間！！)\n\tT sum(int i){\n        if(i<0)return 0;\n\t\ti++;\n\t\tT s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i], i -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tBIT(){}\n\t//初期値がすべて0の場合\n\tBIT(int sz) : n(sz+1), bit(n, 0){}\n\tBIT(vector<T>& v) : n((int)v.size()+1), bit(n, 0){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tadd(i,v[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcout<<sum(i)-sum(i-1)<< \" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t//-1スタート\n\tvoid print_sum(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout<<sum(i-1)<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<mod>dp(n+1);\n    vector<int>a[3];\n    vector<int>b(n+1);\n    int c = 0;\n    rep(i,n){\n        b[i] = c;\n        c += s[i]-'a'+1;\n        c %= 3;\n        a[c].push_back(i+1);\n    }\n    a[0].push_back(n+1);\n    a[1].push_back(n+1);\n    a[2].push_back(n+1);\n    b[n] = c;\n    BIT<int> bit(n+1);\n    rep(i,n-1){\n        if(s[i]==s[i+1]){\n            bit.add(i,1);\n        }\n    } \n    dp[0] = 1;\n    rep(i,n){\n        for(int j=1;j<3;j++){\n            int ca = (b[i]+j)%3;\n            int id = i;\n            while(1){\n                int x = *upper_bound(a[ca].begin(),a[ca].end(),id);\n                id = x;\n                if(x==n+1)break;\n                if(x==i+1){\n                    dp[x] += dp[i];\n                    break;\n                }else{\n                    if(bit.sum(x-1)-bit.sum(i-2)!=0){\n                        dp[x] += dp[i];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    mod res = 0;\n    rep(i,n+1){\n        int k = (3+b[n]-b[i])%3;\n        if(k==0){\n            if(i==0)continue;    \n            res += dp[i];\n        }\n        // cerr << i << \" \" << dp[i] << \" \"  << res << endl;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 1e5 + 7 , MOD = 1e9 + 7;\nchar str[_]; int L , dp[_] , pos[_][3] , sum[_];\n\nvoid inc(int &a , int b){a = a + b >= MOD ? a + b - MOD : a + b;}\n\nint main(){\n\tscanf(\"%s\" , str + 1); L = strlen(str + 1); bool flg = 1;\n\tfor(int i = 1 ; i <= L ; ++i) sum[i] = (sum[i - 1] + str[i] - 'a' + 1) % 3;\n\tfor(int i = 2 ; i <= L ; ++i) flg &= str[i] != str[i - 1];\n\tif(flg){puts(\"1\"); return 0;}\n\tpos[L + 1][0] = pos[L + 1][1] = pos[L + 1][2] = L + 1;\n\tfor(int i = L ; i ; --i){\n\t\tfor(int j = 0 ; j < 3 ; ++j) pos[i][(j + str[i] - 'a' + 1) % 3] = pos[i + 1][j];\n\t\tpos[i][str[i] - 'a' + 1] = i;\n\t}\n\tint p = dp[0] = 1 , ans = 0;\n\tfor(int i = 0 ; i < L ; ++i){\n\t\tinc(dp[i + 1] , dp[i]);\n\t\twhile(p <= L && (p == i + 1 || str[p] != str[p - 1])) ++p;\n\t\tinc(dp[pos[p][(!(str[i + 1] - 'a') + 4 - (sum[p - 1] - sum[i])) % 3]] , dp[i]);\n\t}\n\tfor(int i = 1 ; i <= L ; ++i) inc(ans , (sum[i] == sum[L]) * dp[i]);\n\tcout << ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nsigned main(){\n\tstring s;\n\tcin>>s;\n\tint n=s.size(),MOD=1000000007;\n\t\n\tbool h=true;\n\trep(i,n-1)if(s[i]==s[i+1])h=false;\n\tif(h){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\t\n\tvi c(n+1);\n\trep(i,n)c[i+1]=s[i]-'a'+1;\n\trep(i,n)(c[i+1]+=c[i])%=3;\n\tvi w(n,inf);\n\trep(i,n-1)w[i+1]=s[i]==s[i+1];\n\tfor(int i=n-2;i>=0;i--)cmin(w[i],w[i+1]);\n\t\n\tvi dp(n+1);\n\tdp[0]=1;\n\trep(i,n)if(dp[i]){\n\t\trep(q,2){\n\t\t\tif(s[i]-'a'==q){\n\t\t\t\t(dp[i+1]+=dp[i])%=MOD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\th=false;\n\t\t\tint l=w[i+1];\n\t\t\tif(l==inf)l=i;\n\t\t\tloop(j,l+1,n+1){\n\t\t\t\tif(j-i-1&&s[j-1]==s[j-2])h=true;\n\t\t\t\tif(h&&q+1==(c[j]+3-c[i])%3){\n\t\t\t\t\t(dp[j]+=dp[i])%=MOD;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint out=0;\n\trep(i,n)if((c[n]+3-c[i+1])%3==0)(out+=dp[i+1])%=MOD;\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nchar s[100050];\nint mo=1e9+7;\nint pre[4],dp[100050],flag,tmp,cnt,ans;\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tfor (int i=1;i<n;i++)if (s[i]==s[i+1]){flag=1;break;}\n\tif (!flag){printf(\"1\\n\");return 0;}\n\tdp[0]=1;\n\tpre[0]=0,pre[1]=pre[2]=-1;\n\tfor (int i=1;i<=n;i++){\n\t\ttmp=(tmp+s[i]-'a'+1)%3;\n\t\tfor (int j=1;j<=2;j++)if (pre[(tmp+j)%3]!=-1)dp[i]=(dp[i]+dp[pre[(tmp+j)%3]])%mo;\n\t\tpre[tmp]=i;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tcnt=(cnt+s[i]-'a'+1)%3;\n\t\tif (cnt==tmp)ans=(ans+dp[i])%mo;\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nchar in[110000];\nlong long dp[110000];\nvector<int>v[3];\nint sum[110000];\nint main(){\n\tscanf(\"%s\",in);\n\tint n=strlen(in);\n\tbool ok=true;\n\tfor(int i=1;i<n;i++){\n\t\tif(in[i]==in[i-1]){\n\t\t\tok=false;\n\t\t\tsum[i+1]++;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tsum[i+1]+=sum[i];\n\t\t// printf(\"%d %d\\n\",i,sum[i]);\n\t}\n\tif(ok){\n\t\tprintf(\"1\\n\");return 0;\n\t}\n\tint t=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(in[i]=='a')t++;\n\t\telse t+=2;\n\t\tv[t%3].push_back(i+1);\n\t}\n\n\tdp[0]=1;\n\tint now=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i]==0)continue;\n\t\t// printf(\"%d: %lld\\n\",i,dp[i]);\n\t\tint left,right;\n\t\tleft=-1;\n\t\tright=v[(now+1)%3].size();\n\t\twhile(left+1<right){\n\t\t\tint M=(left+right)/2;\n\t\t\tint to=v[(now+1)%3][M];\n\t\t\tbool dame=false;\n\t\t\tif(to<=i)dame=true;\n\t\t\tif(to-i>1&&sum[to]-sum[i+1]==0)dame=true;\n\t\t\tif(dame){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\t// printf(\"%d \",v[(now+1)%3][right]);\n\t\tif(right<v[(now+1)%3].size()){\n\t\t\tdp[v[(now+1)%3][right]]=(dp[v[(now+1)%3][right]]+dp[i])%mod;\n\t\t}\n\t\tleft=-1;\n\t\tright=v[(now+2)%3].size();\n\t\twhile(left+1<right){\n\t\t\tint M=(left+right)/2;\n\t\t\tint to=v[(now+2)%3][M];\n\t\t\tbool dame=false;\n\t\t\tif(to<=i)dame=true;\n\t\t\tif(to-i>1&&sum[to]-sum[i+1]==0)dame=true;\n\t\t\tif(dame){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tif(right<v[(now+2)%3].size()){\n\t\t\tdp[v[(now+2)%3][right]]=(dp[v[(now+2)%3][right]]+dp[i])%mod;\n\t\t}\n\t\t// printf(\"%d\\n\",v[(now+2)%3][right]);\n\t\tif(in[i]=='a')now++;\n\t\telse now+=2;\n\t}\n\tint s=0;\n\tlong long ret=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(in[i-1]=='a')s++;\n\t\telse s+=2;\n\t\tif(t%3==s%3){\n\t\t\tret=(ret+dp[i])%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nmodint dp[1 << 17];\n\nint col[1 << 17];\nvoid solve() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\trep(i, n) {\n\t\tcol[i + 1] = col[i];\n\t\tif (s[i] == 'a')col[i + 1]--;\n\t\telse col[i + 1]++;\n\t\tcol[i + 1] = (col[i + 1] % 3 + 3) % 3;\n\t}\n\n\n\tvector<int> nex(n);\n\tint las = n;\n\tper(i, n) {\n\t\tif (i + 1 < n && s[i] == s[i + 1])las = i;\n\t\tnex[i] = las;\n\t}\n\n\tmodint ans = 0;\n\tdp[0] = 1;\n\trep(i, n) {\n\t\tif (nex[i] < n && col[n] != col[i]) {\n\t\t\tans += dp[i];\n\t\t}\n\t\tdp[i + 1] += dp[i];\n\t\tif (nex[i] + 2 < n) {\n\t\t\tdp[nex[i] + 2] += dp[i];\n\t\t}\n\t}\n\tans += dp[n];\n\tper(i, n - 1)if (s[i] == s[i + 1]) {\n\t\tfor (int j = i + 2; j < n; j++) {\n\t\t\tif (col[j] == col[i+1]) {\n\t\t\t\tans += dp[i];\n\t\t\t}\n\t\t}\n\t\t break;\n\t}\n\tcout << ans << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0 , f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e5 + 5 , mod = 1e9 + 7;\nchar s[N];\nint ch[N][2] , f[N];\nint main()\n{\n\tscanf(\"%s\",s + 1); int n = strlen(s + 1);\n\tint flag = 0 , sum = 0;\n\tfor(int i = 2;i <= n;i ++) flag += (s[i] == s[i - 1]);\n\tif(!flag) return puts(\"1\") , 0;\n\tf[n + 1] = 1;\n\tfor(int i = 1;i <= 2;i ++) for(int j = 0;j < 2;j ++) ch[n + i][j] = n + 2;\n\tfor(int i = n;i >= 1;i --)\n\t{\n\t\tsum = (sum + (s[i] == 'a' ? 1 : 2)) % 3;\n\t\tch[i][0] = s[i] == 'a' ? i + 1 : s[i + 1] == 'b' ? i + 2 : ch[i + 2][0];\n\t\tch[i][1] = s[i] == 'b' ? i + 1 : s[i + 1] == 'a' ? i + 2 : ch[i + 2][1];\n\t\tf[i] = (f[ch[i][0]] + f[ch[i][1]] + (sum == 0)) % mod;\n\t}\n\tprintf(\"%d\\n\",(f[1] - (sum == 0) + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100054, mod = 1000000007;\n\nint n;\nint f[N], S[N];\nchar s[N];\n\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\n\nint main() {\n\tint i, B[3] = {1}; bool flag = false;\n\tscanf(\"%s\", s), n = strlen(s);\n\tfor (i = 1; i < n && s[i] != s[i - 1]; ++i);\n\tif (i == n) return puts(\"1\"), 0;\n\tfor (*f = i = 1; i <= n; ++i)\n\t\tS[i] = (S[i - 1] + s[i - 1]) % 3, f[i] = f[i - 1] + !S[i],\n\t\tadd(f[i], B[S[i] ^ S[i - 1] ^ 3]), B[S[i]] = f[i];\n\tif (!S[n]) add(f[n], mod - 1);\n\tprintf(\"%d\\n\", f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst int INF = 2147483600;\n\nint nxt[MAXN+1][3];\nLL f[MAXN+1]; char str[MAXN+1];\nint a[MAXN+1];\nLL sum;\n\ninline int Tns(int x){\n\treturn (x==2?1:2);\n} int N; \nconst int Mod = 1000000007LL;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tscanf(\"%s\",str+1); f[0]=1; N=strlen(str+1);\n\tfor(int i=1;i<=N;i++) a[i]=(int)(str[i]-'a')+1; \n\tfor(int i=N;i>=1;i--){\n\t\tnxt[i][1]=nxt[i+1][(1-a[i]+3)%3];\n\t\tnxt[i][2]=nxt[i+1][(2-a[i]+3)%3];\n\t\tnxt[i][0]=nxt[i+1][(3-a[i])%3];\n\t\tnxt[i][a[i]]=i;\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\t(f[i]+=f[i-1])%=Mod; \n\t\tif(nxt[i][Tns(a[i])]) \n\t\t\t(f[nxt[i][Tns(a[i])]]+=f[i-1])%=Mod;\n\t} LL ans=0;\n\tfor(int i=N;i>=1;i--){ \n\t\tif(!(sum%3)) (ans+=f[i])%=Mod;\n\t\tsum+=a[i];\n\t} printf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <string>\n#include <set>\n#include <map>\n#define SIZE 100005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar str[SIZE];\nint nxt[SIZE][3];\nint dp[SIZE];\nint memo[3];\n\nll solve(vector <int> vec)\n{\n\tint n=vec.size();\n\tmemset(memo,-1,sizeof(memo));\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tmemo[vec[i]]=i;\n\t\tfor(int t=0;t<3;t++) nxt[i][t]=memo[t];\n\t}\n\tfor(int i=0;i<=n;i++) dp[i]=0;\n\t//for(int i=0;i<=n;i++) printf(\"%d %d %d\\n\",nxt[i][0],nxt[i][1],nxt[i][2]);\n\tdp[0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int t=0;t<3;t++)\n\t\t{\n\t\t\tif(t==vec[i]) continue;\n\t\t\tif(nxt[i][t]!=-1)\n\t\t\t{\n\t\t\t\tdp[nxt[i][t]]+=dp[i];\n\t\t\t\tif(dp[nxt[i][t]]>=MOD) dp[nxt[i][t]]-=MOD;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",dp[i]);\n\t}\n\tll ret=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(vec[i]==vec[n-1])\n\t\t{\n\t\t\tret+=dp[i];\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%s\",&str);\n\tint n=strlen(str);\n\tint sum=0;\n\tvector <int> vec;\n\tvec.push_back(0);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(str[i]=='a') sum+=2;\n\t\telse sum++;\n\t\tsum%=3;\n\t\tvec.push_back(sum);\n\t}\n\t//for(int i=0;i<vec.size();i++) printf(\"%d \",vec[i]);puts(\"\");\n\tll ret=1;\n\tvector <int> now;\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tif(now.size()>=1&&now[now.size()-1]==vec[i])\n\t\t{\n\t\t\tret=ret*solve(now);\n\t\t\tret%=MOD;\n\t\t\tnow.clear();\n\t\t}\n\t\tnow.push_back(vec[i]);\n\t}\n\tret=ret*solve(now);\n\tret%=MOD;\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint add(int x,int y){return x+y<3?x+y:x+y-3;}\nconst int mod=1e9+7;\nint n;\nchar s[100100];\nint a[100100];\n\nint sum[100100];\nint nd[100100];\nint nxt[100100][3];\nint dp[100100];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=s[i]-'a'+1;\n\t\tsum[i]=add(sum[i-1],a[i]);\n\t}\n\ta[n+2]=4;\n\tnxt[n][0]=nxt[n][1]=nxt[n][2]=n+1;\n\tnxt[n+1][0]=nxt[n+1][1]=nxt[n+1][2]=n+1;\n\tnd[n+1]=n+1;\n\tfor(int i=n;i>=0;--i)\n\t{\n\t\tmemcpy(nxt[i],nxt[i+1],sizeof(nxt[i+1]));\n\t\tnxt[i][sum[i]]=i;\n\t\tnd[i]=nd[i+1];\n\t\tif(a[i+1]==a[i+2])nd[i]=i+2;\n\t}\n\tif(nd[1]==n+1&&a[1]!=a[2])\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0]=1;\n\tint p1,p2;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tp1=nxt[nd[i]][add(sum[i],1)];\n\t\tp2=nxt[nd[i]][add(sum[i],2)];\n\t\tif(a[i+1]!=1)dp[p1]=(dp[p1]+dp[i])%mod;\n\t\tif(a[i+1]!=2)dp[p2]=(dp[p2]+dp[i])%mod;\n\t\tdp[i+1]=(dp[i+1]+dp[i])%mod;\n\t}\n\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(add(sum[n],3-sum[i])==0)\n\t\t\t(ans+=dp[i])%=mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tstring S;\n\tcin >> S;\n\tint N = S.length();\n\tvector<int> next_eq(N, N);\n\tfor(int i = N-2; i >= 0; i--) {\n\t\tif(S[i] == S[i+1]) next_eq[i] = i+1;\n\t\telse next_eq[i] = next_eq[i+1];\n\t}\n\tvector<int> dif(N+1, 0);\n\tfor(int i = 0; i < N; i++) {\n\t\tif(S[i] == 'a') dif[i+1] = (dif[i]+1) % 3;\n\t\telse dif[i+1] = (dif[i]+2) % 3;\n\t}\n\tvector<int> dif_occ[3];\n\tfor(int i = 0; i <= N; i++) dif_occ[dif[i]].push_back(i);\n\tcat mod = 1000000007;\n\tvector<cat> dp(N+1, 0);\n\tdp[0] = 1;\n\tfor(int i = 0; i < N; i++) {\n\t\tdp[i+1] += dp[i];\n\t\tif(dp[i+1] >= mod) dp[i+1] -= mod;\n\t\tif(next_eq[i] == N) continue;\n\t\tint d = (S[i] == 'a') ? (dif[i]+2)%3 : (dif[i]+1)%3;\n\t\tauto it = lower_bound(begin(dif_occ[d]), end(dif_occ[d]), next_eq[i]+1);\n\t\tif(it == end(dif_occ[d])) continue;\n\t\tdp[*it] += dp[i];\n\t\tif(dp[*it] >= mod) dp[*it] -= mod;\n\t}\n\tcat ans = dp[N];\n\tfor(int i = 0; i < N; i++) if(next_eq[i] < N) {\n\t\tif(next_eq[i+1] == N) {\n\t\t\tauto it = lower_bound(begin(dif_occ[dif[i+1]]), end(dif_occ[dif[i+1]]), i+1);\n\t\t\tans = (ans + dp[i] * (end(dif_occ[dif[i+1]])-1-it)) % mod;\n\t\t}\n\t\tint d = (S[i] == 'a') ? (dif[i]+2)%3 : (dif[i]+1)%3;\n\t\tauto it = lower_bound(begin(dif_occ[d]), end(dif_occ[d]), next_eq[i]+1);\n\t\tif(it == end(dif_occ[d])) continue;\n\t\tif(next_eq[*it] < N) continue;\n\t\tans = (ans + dp[i] * (end(dif_occ[d])-1-it)) % mod;\n\t}\n\tfor(int i = 1; i < N; i++) if(next_eq[i] < N && dif[i] == dif[N]) {\n\t\tans += dp[i];\n\t\tif(ans >= mod) ans -= mod;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 200000;\nconst int mo = 1e9 + 7;\n\nint n;\nchar st[N + 5];\nint f[N + 5], lst[3];\n\nbool chk() {\n    for(int i = 1; i < n; ++i) {\n        if(st[i] == st[i + 1]) return false;\n    }\n    return true;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    scanf(\"%s\", st + 1);\n    n = strlen(st + 1);\n\n    if(chk()) return !puts(\"1\");\n\n    f[0] = 1;\n    lst[0] = 0;\n    lst[1] = lst[2] = -1;\n\n    int c = 0, all = 0;\n    for(int i = 1; i <= n; ++i) all = (all + st[i] - 'a' + 1) % 3;\n    for(int i = 1; i <= n; ++i) {\n        c = (c + st[i] - 'a' + 1) % 3;\n        for(int j = 1; j < 3; ++j) if(lst[(c-j+3)%3] >= 0) {\n            f[i] = (f[i] + f[lst[(c - j + 3) % 3]]) % mo;\n        }\n        lst[c] = i;\n\n        if(c == 0 && i < n) { f[i] = (f[i] + 1) % mo; }\n    }\n    printf(\"%d\\n\", f[n]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nint n,nxt[100005];\nchar s[100005];\nll f[100005],ans;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=(int)strlen(s+1);\n\tnxt[n]=n+1;\n\tfor(int i=n;i>=1;i--)nxt[i-1]=s[i]==s[i+1]?i+1:nxt[i];\n\tf[0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tf[i]%=MOD;\n\t\tf[i+1]+=f[i];\n\t\tf[nxt[i]]+=f[i];\n\t}\n\tint now=0;\n\tbool flag=0;\n\tfor(int i=n;i>=0;i--)\n\t{\n\t\tflag|=s[i]==s[i+1];\n\t\tif((now&&flag)||i==n-1)ans+=f[i];\n\t\tnow=(now+s[i]-'a'+1)%3;\n\t}\n\tprintf(\"%lld\\n\",ans%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define MOD 1000000007\n\nint n;\n\nchar s[100005];\nint psum[100005];\nint nxt[100005][2];\nint f[100005];\n\nint main()\n{\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    bool hassame = false;\n    for (int i = 1; i < n; i++) {\n        if (s[i] == s[i+1]) hassame = true;\n    }\n    if (!hassame) {\n        printf(\"1\"); return 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        psum[i] = psum[i-1] + (s[i] == 'a' ? 1 : 2);\n        psum[i] %= 3;\n    }\n    int tmp[3]; /* next acceptable with this psum */\n    tmp[0] = tmp[1] = tmp[2] = n + 1;\n    int tmp2[3]; /* next with this psum */\n    tmp2[0] = tmp2[1] = tmp2[2] = n + 1;\n    for (int i = n; i >= 1; i--) {\n        if (i != n && s[i] == s[i+1]) {\n            for (int j = 0; j < 3; j++) tmp[j] = tmp2[j];\n        }\n        nxt[i][0] = tmp[(psum[i-1] + 1) % 3];\n        nxt[i][1] = tmp[(psum[i-1] + 2) % 3];\n        if (s[i] == 'a') {\n            nxt[i][0] = i;\n        } else {\n            nxt[i][1] = i;\n        }\n        tmp2[psum[i]] = i;\n    }\n    f[0] = 1;\n    for (int i = 0; i < n; i++) {\n        if (nxt[i+1][0] <= n) {\n            f[nxt[i+1][0]] += f[i];\n            if (f[nxt[i+1][0]] >= MOD) f[nxt[i+1][0]] -= MOD;\n        }\n        if (nxt[i+1][1] <= n) {\n            f[nxt[i+1][1]] += f[i];\n            if (f[nxt[i+1][1]] >= MOD) f[nxt[i+1][1]] -= MOD;\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        if ((psum[n] - psum[i] + 3) % 3 == 0) {\n            ans += f[i];\n            if (ans >= MOD) ans -= MOD;\n        }\n    }\n    printf(\"%d\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5+5;\nconst ll p = 1e9+7;\nconst ll inf = (1<<30);\n\nstring s;\nll v[MAXN], dp[MAXN][3], part[MAXN][3][3], r[MAXN][3], n;\nvector<int> pos[3];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> s;\n\tn = s.length();\n\tv[0] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tv[i] = (v[i-1] + 1 + (s[i-1] == 'b'))%3;\n\tn++;\n\tfor (int i = 0; i < n; ++i)\n\t\tpos[v[i]].push_back(i);\n\n\tfor (int i = n-1; i >= 0; --i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tr[i][j] = i;\n\t\t\telse\n\t\t\t\tr[i][j] = max(i+1LL, r[i+1][j]);\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tif (v[i] != k && v[i-1] == j)\n\t\t\t\t\tpart[i][j][k] = (part[i-1][j][k] + dp[i-1][j])%p;\n\t\t\t\telse\n\t\t\t\t\tpart[i][j][k] = part[i-1][j][k];\n\t\t\t}\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (v[i] == j)\n\t\t\t\tcontinue;\n\t\t\t//find the range of j that \"project\" onto i\n\t\t\tint k = 3-v[i]-j;\n\t\t\t//j -> k -> v[i]\n\t\t\tint lo = 0, hi = pos[j].size();\n\t\t\t//find first guy who is >= i;\n\t\t\tif (pos[j].size() == 0)\n\t\t\t\tcontinue;\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] >= i) {\n\t\t\t\t\thi = mid;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] >= i)\n\t\t\t\t\thi = mid;\n\t\t\t\telse\n\t\t\t\t\tlo = mid+1;\n\t\t\t}\n\t\t\tif (lo == pos[j].size())\n\t\t\t\tcontinue;\n\t\t\tint val1 = pos[j][lo];\n\t\t\tlo = -1, hi = pos[j].size()-1;\n\t\t\t//find last guy who is <= i\n\t\t\twhile (lo != hi) {\n\t\t\t\tint mid = (lo+hi+1)/2;\n\t\t\t\tint x = pos[j][mid];\n\t\t\t\tif (r[x][k] > i) {\n\t\t\t\t\thi = mid-1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (r[r[x][k]][v[i]] > i)\n\t\t\t\t\thi = mid-1;\n\t\t\t\telse\n\t\t\t\t\tlo = mid;\n\t\t\t}\n\t\t\tif (lo == -1)\n\t\t\t\tcontinue;\n\t\t\tint val2 = pos[j][lo];\n\t\t\t// cout << i << ' ' << j << ' ' << val1 << ' ' << val2 << endl;\n\t\t\tif (val1 > val2)\n\t\t\t\tcontinue;\n\t\t\tdp[i][v[i]] = (dp[i][v[i]] + part[val2+1][j][v[i]] + p - part[val1][j][v[i]])%p;\n\t\t}\n\t\tdp[i][v[i]] = (dp[i][v[i]] + dp[i-1][v[i-1]])%p;\n\t\t// cout << dp[i][v[i]] << endl;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < n-2; ++i) {\n\t\tif (v[i] == v[n-1])\n\t\t\tcontinue;\n\t\tint k = 3-v[i]-v[n-1];\n\t\tif (r[i][k] >= n)\n\t\t\tcontinue;\n\t\tif (r[r[i][k]][v[n-1]] >= n)\n\t\t\tcontinue;\n\t\tans = (ans + dp[i][v[i]])%p;\n\t}\n\tans = (ans + dp[n-2][v[n-2]])%p;\n\tint g = -1;\n\tfor (int i = n-1; i >= -1; --i) {\n\t\tif (i == -1)\n\t\t\tg = -1;\n\t\tif (v[i] == v[n-2])\n\t\t\tg = i;\n\t\tif (v[i] == 3-v[n-2]-v[n-1])\n\t\t\tbreak;\n\t}\n\tif (g != -1) {\n\t\tfor (int k = g; k < n-2; k += 2)\n\t\t\tans = (ans + dp[g][v[g]])%p;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n    }\n    int nx[2][100010];\n    int p[3][100010];\n    for(int j=0; j<3; j++) p[j][n]=n;\n    int mn[100010];\n    mn[n]=n+1;\n    for(int i=n-1; i>=0; i--){\n        for(int j=0; j<3; j++) p[j][i]=p[j][i+1];\n        p[c[i]][i]=i;\n        mn[i]=mn[i+1];\n        if(i<n-1 && s[i]==s[i+1]) mn[i]=i+2;\n        if(s[i]=='a'){\n            nx[0][i]=i+1;\n            if(mn[i]<=n) nx[1][i]=p[(c[i]+2)%3][mn[i]];\n            else nx[1][i]=n+1;\n        }else{\n            nx[1][i]=i+1;\n            if(mn[i]<=n) nx[0][i]=p[(c[i]+1)%3][mn[i]];\n            else nx[0][i]=n+1;\n        }\n    }\n    ll dp[2][100010]={};\n    dp[0][0]=1;\n    ll ans=0;\n    for(int i=0; i<n; i++){\n        //cout<<nx[0][i]<<\" \"<<nx[1][i]<<endl;\n        int x=(c[n]-c[i]+3)%3;\n      if(x!=0) (ans+=dp[1][i])%=MOD;\n      if(x!=0 && (i==n-1 || mn[i]<=n || (i>0 && mn[i-1]<=n))) (ans+=dp[0][i])%=MOD;\n      //cerr<<mn[i]<<endl;\n      //cerr<<dp[0][i]<<endl;\n        if(nx[0][i]<n){\n          if(nx[0][i]==i+1){\n            (dp[0][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }\n        }\n        if(nx[1][i]<n){\n          if(nx[1][i]==i+1){\n            (dp[0][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n   int b,ck=0,dk=5;\n    string s;\n    cin>>s;\n    b= s.length();\n\n\n    for(int i=0;i<b;i++){\n        if(s[i]=='a' && s[i+1]=='a'){\n          ck++;\n          dk=0;\n          s[i] = 'b';\n          s.erase(i+1,1);\n        //  cout<<s<<endl;\n          if(s[i]!=s[i+1]){\n            ck=ck+s.length()-1;\n          }\n\n\n\n      //  cout<<ck<<endl;\n        }\n        if(s[i]=='b' && s[i+1]=='b') {\n            ck++;\n            dk=0;\n            s[i]='a';\n            s.erase(i+1,1);\n            if(s[i]!=s[i+1]){\n            ck=ck+s.length()-1;\n          }\n          //  cout<<s<<endl;\n        }\n      if(dk!=0){\n        dk=1;\n      }\n    }\n    if(dk==1){\n        cout<<dk<<endl;\n    }\n    else cout<<ck+1<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MODULO = 1e9 + 7;\n\nmap<vector<int>, ll> ans;\nll Solve(int at, int sum, int want, int len, int was, const vector<int>& a) {\n  if (at == a.size()) {\n    if (sum == want) return 1;\n    return 0;\n  }\n\n  vector<int> state = {at, sum, want, len, was};\n  for (int x : state) cerr << x << \" \"; cerr << endl;\n  if (ans.count(state)) return ans[state];\n\n  ll& result = ans[state];\n  \n  result = 0;\n  \n  if (sum == want && want != 0 && (len == 1 || was)) {\n    for (int w = 0; w < 3; ++w) result = (result + Solve(at, 0, w, 0, 0, a)) % MODULO;\n    return result;\n  }\n\n  int newLen = min(len + 1, 2);\n  int newWas = was;\n  if (len != 0) newWas |= (a[at] == a[at - 1]);\n  int newSum = (sum + a[at]) % 3;\n\n  result = (result + Solve(at + 1, newSum, want, newLen, newWas, a)) % MODULO;\n\n  return result;\n}\n\nint main()\n{\n  string s;\n  cin >> s;\n  int n = s.size();\n  bool found = false;\n  for (int i = 0; i < n - 1; ++i) if (s[i] == s[i + 1]) found = true;\n  if (!found) {\n    cout << 1 << endl;\n    return 0;\n  }\n  vector<int> a(n, 1);\n  for (int i = 0; i < n; ++ i) if (s[i] == 'b') a[i] = 2;\n  ll result = (Solve(0, 0, 1, 0, 0, a) + Solve(0, 0, 2, 0, 0, a)) % MODULO;\n  cout << result << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nmodint dp[1 << 17];\n\nint col[1 << 17];\nvoid solve() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\trep(i, n) {\n\t\tcol[i + 1] = col[i];\n\t\tif (s[i] == 'a')col[i + 1]--;\n\t\telse col[i + 1]++;\n\t\tcol[i + 1] = (col[i + 1] % 3 + 3) % 3;\n\t}\n\n\n\tvector<int> nex(n);\n\tint las = n;\n\tper(i, n) {\n\t\tif (i + 1 < n && s[i] == s[i + 1])las = i;\n\t\tnex[i] = las;\n\t}\n\n\tmodint ans = 0;\n\tdp[0] = 1;\n\trep(i, n) {\n\t\tif (nex[i] < n && col[n] != col[i]) {\n\t\t\tans += dp[i];\n\t\t}\n\t\tdp[i + 1] += dp[i];\n\t\tif (nex[i] + 2 < n) {\n\t\t\tdp[nex[i] + 2] += dp[i];\n\t\t}\n\t}\n\tans += dp[n];\n\tper(i, n - 1)if (s[i] == s[i + 1]) {\n\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\tif (col[j] == col[i+1]) {\n\t\t\t\tans += dp[i];\n\t\t\t}\n\t\t}\n\t\t break;\n\t}\n\tcout << ans << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    string s; cin >> s;\n    int N = SZ(s);\n\n    bool same = false;\n    REP(i, N - 1) if(s[i] == s[i + 1]) same = true;\n    if(!same){\n        Return(1);\n    }\n\n    vec S(N + 1, 0);\n    vec suc;\n    REP(i, N){\n        S[i + 1] = (S[i] + s[i] - 'a' + 1) % 3;\n        if(i < N - 1 && s[i] == s[i + 1]) suc.pb(i + 1);\n    }\n    suc.pb(INF);\n\n    mat ls(3);\n    REP(i, N + 1) ls[S[i]].pb(i);\n    REP(j, 3) ls[j].pb(INF);\n\n    mvec dp(N + 1, 0);\n    dp[0] = 1;\n\n    REP(i, N){\n\n        int x = (S[i + 1] - S[i] + 3) % 3, y = 3 - x;\n        int y2 = (S[i] + y) % 3;\n        bool f = false;\n\n        dp[i + 1] += dp[i];\n        if(i + 1 == N) f = true;\n\n        int j0 = Lower_bound(suc, i + 1);\n        if(suc[j0] < INF){\n            int j1 = Lower_bound(ls[y2], suc[j0] + 1);\n            if(ls[y2][j1] < INF){\n                dp[ls[y2][j1]] += dp[i];\n                if(ls[y2][j1] == N) f = true;\n            }\n        }\n        if(!f && S[i] == S[N]) dp[N] += dp[i];\n    }\n    mint ans = dp[N];\n    if(S[N] == S[0]) ans -= 1;\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nconst int N = 233333,mo=1e9+7;\nchar S[N];int n,f[N],s[N],qz[N],b[N];vector<int> a[3];\nvoid add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\n\nint main(){\n\tscanf(\"%s\",S+1);n=strlen(S+1);rep(i,1,n)s[i]=S[i]-'a'+1;\n\trep(i,1,n)qz[i]=(qz[i-1]+s[i])%3,a[qz[i]].push_back(i);f[0]=1;\n\tfor(int i=n,j=n+1;i>=0;i--){if(s[i]==s[i+1])j=i+1;b[i]=j;}\n\trep(i,0,n-1)rep(j,1,2){\n\t\tif(s[i+1]==j)add(f[i+1],f[i]);\n\t\telse if(SZ(a[(qz[i]+j)%3])&&b[i+1]<=a[(qz[i]+j)%3].back()){//RE\n\t\t\tint k=*lower_bound(a[(qz[i]+j)%3].begin(),a[(qz[i]+j)%3].end(),b[i+1]);\n\t\t\tif(k<=n)add(f[k],f[i]);\n\t\t}\n\t}\n//\trep(i,0,n)printf(\"%d:%d\\n\",i,f[i]);\n\tint res=0;rep(i,0,n-1)if(b[i+1]<=n&&(qz[n]-qz[i])%3||i==n-1)add(res,f[i]);\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    string s; cin >> s;\n    int N = SZ(s);\n    assert(N == 1 || s[N - 2] == s[N - 1]);\n\n    vec S(N + 1, 0);\n    vec suc;\n    REP(i, N){\n        S[i + 1] = (S[i] + s[i] - 'a' + 1) % 3;\n        if(i < N - 1 && s[i] == s[i + 1]) suc.pb(i + 1);\n    }\n    suc.pb(INF);\n\n    mat ls(3);\n    REP(i, N + 1) ls[S[i]].pb(i);\n    REP(j, 3) ls[j].pb(INF);\n\n    //vdebug(suc); vdebug(S); mdebug(ls);\n\n    mvec dp(N + 1, 0);\n    dp[0] = 1;\n    REP(i, N){\n        int x = (S[i + 1] - S[i] + 3) % 3, y = 3 - x;\n        int y2 = (S[i] + y) % 3;\n        bool f = false;\n\n        dp[i + 1] += dp[i];\n        if(i + 1 == N) f = true;\n\n        int j0 = Lower_bound(suc, i + 1);\n        if(suc[j0] < INF){\n            int j1 = Lower_bound(ls[y2], suc[j0] + 1);\n            if(ls[y2][j1] < INF){\n                dp[ls[y2][j1]] += dp[i];\n                if(ls[y2][j1] == N) f = true;\n            }\n\n            if(!f && suc[j0] + 1 <= N){\n                int z = (S[N] - S[i] + 3) % 3;\n                if(z != 0) dp[N] += dp[i];\n            }\n\n        }\n\n        //vdebug(dp);\n    }\n    Out(dp[N]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define oo 0x7fffffff\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar jp=getchar();\n\twhile ((jp>'9'||jp<'0')&&jp!='-')\n\t\tjp=getchar();\n\tif (jp=='-')\n\t\t{\n\t\t\tfh=-1;\n\t\t\tjp=getchar();\n\t\t}\n\twhile (jp>='0'&&jp<='9')\n\t\t{\n\t\t\tout=out*10+jp-'0';\n\t\t\tjp=getchar();\n\t\t}\n\treturn out*fh;\n}\nconst int MAXN=1e5+10;\nconst int P=1e9+7;\ninline int add(int a,int b)\n{\n\treturn (a + b) % P;\n}\ninline int mul(int a,int b)\n{\n\treturn 1ll * a * b  % P;\n}\nchar s[MAXN];\nint pre[MAXN],f[MAXN],nx[3];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tscanf(\"%s\",s);\n\tint n;\n\tint flag=0;\n\tfor(;s[n];++n)\n\t\t{\n\t\t\tpre[n+1]=pre[n]+(s[n]=='a'? 1:2 );\n\t\t\tpre[n+1]%=3;\n\t\t}\n\tfor(rg int i=1;i<n;++i)\n\t\tif(s[i]==s[i-1])\n\t\t\tflag=1;\n\tif(flag==0)\n\t\t{\n\t\t\tputchar('1');\n\t\t\texit(1);\n\t\t}\n\tf[n]=1;\n\tfor(rg int i=0;i<3;++i)\n\t\tnx[i]=i==pre[n]?n:n+1;\n\tfor(rg int i=n-1;i;--i)\n\t\t{\n\t\t\tf[i]= pre[i]==pre[n];\n\t\t\tfor(rg int c=1;c<=2;++c)\n\t\t\t\tf[i]=add(f[i],f[nx[(pre[i]+c)%3]]);\n\t\t\tnx[pre[i]]=i;\n\t\t}\n\tcout<<add(f[nx[1]],f[nx[2]]);\n\t//fclose(stdin);\n\t//fclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=1e9+7;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nchar st[MAXN]; \nint s[MAXN],f[MAXN],pre[MAXN][3],fst[MAXN];\nint upd(int x,int y) { return x+y>=mods?x+y-mods:x+y; }\nint main()\n{\n\tscanf(\"%s\",st+1); \n\tint n=strlen(st+1);\n\tfor (int i=1;i<=n;i++) s[i]=(s[i-1]+st[i]-'a'+1)%3;\n\tpre[0][0]=pre[0][1]=pre[0][2]=-1;\n\tfor (int i=1;i<=n;i++) \n\t{\n\t\tpre[i][0]=pre[i-1][0];\n\t\tpre[i][1]=pre[i-1][1];\n\t\tpre[i][2]=pre[i-1][2];\n\t\tpre[i][s[i-1]]=i-1;\n\t}\n\tfor (int i=1;i<=n;i++) \n\t{\n\t\tfst[i]=fst[i-1];\n\t\tif (st[i]==st[i-1]) fst[i]=i;\n\t}\n\tf[0]=1;\n\tfor (int i=1;i<=n;i++) \n\t{\n\t\tf[i]=f[i-1];\n\t\tint lst=fst[i]-1,num=(st[i]=='a')?2:1;\n\t\tif (~lst) \n\t\t{\n\t\t\tlst=pre[lst][(s[i]-num+3)%3];\n\t\t\tif (~lst) f[i]=upd(f[i],f[lst]);\n\t\t}\n\t\tif (!s[i]&&i!=n) f[i]=upd(f[i],1);\n\t}\n\tif (!fst[n]) \n\t\tfor (int i=1;i<n;i++) \n\t\t\tif (!s[i]) f[n]=upd(f[n],mods-1);\n\tprintf(\"%d\\n\",f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define DIM 100005\n#define mod 1000000007\nusing namespace std;\nint n, i, j, x, sol, ok;\nchar s[DIM];\nint sum[DIM], nxt[DIM][3], d[DIM];\nint main(){\n    cin>> s + 1;\n    n = strlen(s + 1);\n    nxt[n][0] = nxt[n][1] = nxt[n][2] = -1;\n    for(i = 1; i <= n; i++){\n        sum[i] = (sum[i - 1] + s[i] - 'a' + 1) % 3;\n        if(s[i] == s[i - 1]){\n            ok = 1;\n        }\n    }\n    for(i = n - 1; i >= 0; i--){\n        nxt[i][0] = nxt[i + 1][0];\n        nxt[i][1] = nxt[i + 1][1];\n        nxt[i][2] = nxt[i + 1][2];\n        nxt[i][ sum[i + 1] ] = i + 1;\n    }\n    if(ok == 0){\n        cout<< 1;\n        return 0;\n    }\n    d[0] = 1;\n    for(i = 0; i <= n; i++){\n        for(j = 1; j <= 2; j++){\n            x = (sum[i] + j) % 3;\n            if(nxt[i][x] != -1){\n                d[ nxt[i][x] ] = (d[i] + d[ nxt[i][x] ]) % mod;\n            }\n        }\n        if(sum[i] == sum[n] && i != 0){\n            sol = (sol + d[i]) % mod;\n        }\n    }\n    cout<< sol;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define ll long long\n#define db double\n#define ull unsigned long long\n#define uint unsigned int\n#define FIO \"\"\n#define dbug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename Y> inline bool updmin(Y &a, Y b){if (a > b) {a = b; return 1;} return 0;}\ntemplate <typename Y> inline bool updmax(Y &a, Y b){if (a < b) {a = b; return 1;} return 0;}\ntemplate <typename Y> inline Y abs(Y a){if (a < 0) a = -a; return a;}\ntemplate <typename Y> inline Y sqr(Y a){return a * a;}\n\ntypedef std::pair<int, int> par;\n#define fx first\n#define fy second\n#define mpar std::make_pair\n#define pb push_back\n\nint read() {\n  int w = 1, q = 0, ch = ' ';\n  for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) q = q * 10 + ch - 48;\n  return q * w;\n}\n\ninline void FileIO(){freopen(FIO\".in\", \"r\", stdin); freopen(FIO\".out\", \"w\", stdout);}\n\n#include <cstring>\nconst int N = 100010, mod = 998244353;\nchar s[N];\nint g[N][3], f[N], n, sum[N];\n\nint main() {\n  scanf(\"%s\", s + 1);\n  n = (int)strlen(s + 1);\n  int tag = 1;\n  for (int i = 2; i <= n; i++) {\n    if (s[i] == s[i - 1]) {\n      tag = 0;\n    }\n  }\n  if (tag) {\n    puts(\"1\");\n    return 0;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    sum[i] = (sum[i - 1] + s[i] - 'a' + 1) % 3;\n  }\n  g[n + 1][0] = g[n + 1][1] = g[n + 1][2] = n + 1;\n  for (int i = n; i; i--) {\n    for (int j = 0; j < 3; j++) {\n      g[i][j] = g[i + 1][j];\n    }\n    g[i][sum[i]] = i;\n  }\n  f[0] = 1;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 1; j <= 2; j++) {\n      int nt = g[i + 1][(sum[i] + j) % 3];\n      if (nt <= n) {\n        f[nt] = (f[nt] + f[i]) % mod;\n      }\n    }\n    if (i && sum[i] == sum[n]) {\n      ans = (ans + f[i]) % mod;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,ln[100005],st[100005],ed[100005],cnt,dp[100005][2];\nchar s[100005];\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n    cnt=1;\n    ln[0]=1;\n    st[0]=ed[0]=(s[0]-'a');\n\tfor(i=1;i<n;++i){\n    \tif(s[i]==s[i-1]){\n    \t\tln[cnt]=1;\n    \t\tst[cnt]=ed[cnt]=(s[i]-'a');\n    \t\t++cnt;\n    \t}\n    \telse{\n    \t\t++ln[cnt-1];\n    \t\ted[cnt-1]=(s[i]-'a');\n    \t}\n    }\n    // initialize for the first block\n    \n    for(i=1;i<cnt;++i){\n    \t// DP transfer\n    \t\n    }\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n    }\n    int nx[100010];\n    int p[3][100010];\n    for(int j=0; j<3; j++) p[j][n]=n;\n    int imx=-1;\n    for(int i=n-1; i>=0; i--){\n        for(int j=0; j<3; j++) p[j][i]=p[j][i+1];\n        p[c[i]][i]=i;\n        if(imx==-1 && i<n-1 && s[i]==s[i+1]) imx=i;\n        if(s[i]=='a') nx[i]=p[(c[i]+2)%3][i];\n        else nx[i]=p[(c[i]+1)%3][i];\n    }\n    int dp[100010]={};\n    int ans=0;\n    for(int i=0; i<n; i++){\n        int x=(c[n]-c[i]+3)%3;\n        if(x!=0) (ans+=dp[i])%=MOD;\n        if(x!=0 && (i==n-1 || i<=imx)) (++ans)%=MOD;\n        else if(i>0 && i-1==imx && s[i]==s[i-1]) (ans+=(n-i-1)/2)%=MOD;\n        (dp[i+1]+=dp[i])%=MOD;\n        (dp[nx[i]]+=dp[i]+1)%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nconst int inf = 1e7;\nconst long long mod = 1e9 + 7;\nint main() {\n        string s;\n        cin >> s;\n        int n = (int) s.size();\n        bool unko = true;\n        rep(i, n - 1) unko = unko && s[i] != s[i + 1];\n        if (unko) {\n                cout << 1 << endl;\n                return 0;\n        }\n        vector<int> acc(n + 1);\n        rep(i, n) {\n                int a = (s[i] == 'a' ? 1 : 2);\n                acc[i + 1] = (acc[i] + a) % 3;\n        }\n        vector<vector<int>> app(n + 2, vector<int> (3));\n        rep(i, 3) app[n + 1][i] = inf;\n        for (int i = n; i >= 0; i --) {\n                rep(j, 3) {\n                        app[i][j] = (acc[i] == j ? i : app[i + 1][j]);\n                }\n        }\n        long long ans = 0;\n        vector<int> add(n + 1);\n        add[0] = 1;\n        rep(i, n + 1) {\n                if (acc[n] == acc[i]) (ans += add[i]) %= mod; // cut last part (sum == 0 (mod 3))\n                for (int put = 1; put <= 2; put ++) {\n                        int pos = app[i + 1][(put + acc[i]) % 3];\n                        if (pos != inf) (add[pos] += add[i]) %= mod;\n                }\n        }\n        if (acc[0] == acc[n]) (ans += mod - 1) %= mod; // no operation\n        cout << ans << endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int N = 100005, P = 1e9+7;\nchar s[N]; int sum[N], f[N], pre[3], n, flag;\n\nint main() {\n\tscanf(\"%s\", &s); n = strlen(s);\n\tfor (int i = 1; i < n; ++i) //判断是否可以操作\n\t\tif (s[i] == s[i-1]) { flag = 1; break; }\n\tif (!flag) { puts(\"1\"); return 0; }\n\tfor (int i = 0; i < n; ++i) sum[i+1] = s[i] - 'a' + 1;\n\tfor (int i = 2; i <= n; ++i) sum[i] = (sum[i] + sum[i-1]) % 3;\n\tf[n] = 1;\n\tfor (int i = 0; i <= 2; ++i) pre[i] = (i == sum[n] ? n : n + 1);\n\tfor (int i = n - 1; i; --i) {\n\t\tf[i] = (sum[i] == sum[n]); //后面的p值是否为0\n\t\tfor (int j = 1; j <= 2; ++j)\n\t\t\tf[i] = (f[i] + f[pre[(sum[i]+j)%3]]) % P; //后面加一段A或B\n\t\tpre[sum[i]] = i; //记录该p值上一次出现的位置\n\t}\n\tprintf(\"%d\\n\", (f[pre[1]] + f[pre[2]]) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int mod = (int) 1e9 + 7;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n;\nstring s;\nchar tmp[maxn];\n\nint read() {\n  if (scanf(\"%s\", tmp) < 1) {\n    return false;\n  }\n  s = tmp;\n  n = sz(s);\n  return true;\n}\n\nint a[maxn];\nint sum[maxn];\nint dp[maxn];\n\nvoid solve() {\n  for (int i = 0; i < n; i++) {\n    a[i] = (s[i] - 'a' + 1);\n  }\n  {\n    bool eq = false;\n    for (int i = 0; i + 1 < n; i++) {\n      if (a[i] == a[i + 1]) {\n        eq = true;\n        break;\n      }\n    }\n    if (!eq) {\n      printf(\"1\\n\");\n      return;\n    }\n  }\n  sum[0] = 0;\n  for (int i = 0; i < n; i++) {\n    sum[i + 1] = (sum[i] + a[i]) % 3;\n  }\n  int lst[3] = {-1, -1, -1};\n  dp[0] = 1;\n  for (int i = 0, j = 0; i < n; i++) {\n    if (i && a[i - 1] == a[i]) {\n      while (j < i) {\n        lst[sum[j]] = j;\n        j++;\n      }\n    }\n    dp[i + 1] = dp[i];\n    int x = (a[i] == 1 ? 2 : 1);\n    x = (sum[i + 1] + 3 - x) % 3;\n    if (lst[x] != -1) {\n      add(dp[i + 1], dp[lst[x]]);\n    }\n    if (!sum[i + 1] && i + 1 < n) {\n      add(dp[i + 1], 1);\n    }\n  }\n  printf(\"%d\\n\", dp[n]);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#ifdef MAROON_LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\t//a=((ll)a+b)%mod;\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\t//a=((ll)a-b%mod+mod)%mod;\n\ta-=b;\n\tif(a<0)a+=mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\twhile(p){\n\t\tif(p&1)mult(s,a);\n\t\tmult(a,a);\n\t\tp>>=1;\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Vmax=1000010;\nint fact[Vmax],factInv[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1];\n\t\tmult(fact[i],i);\n\t}\n\tfactInv[Vmax-1]=modInv(fact[Vmax-1]);\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1];\n\t\tmult(factInv[i],i+1);\n\t}\n}\nint Choose(int n,int k){\n\treturn ll(fact[n])*factInv[n-k]%mod*factInv[k]%mod;\n}\nint Binom(int a,int b){\n\treturn ll(fact[a+b])*factInv[a]%mod*factInv[b]%mod;\n}\n\nvi Waf(string s){\n\tint n=s.size();\n\tvi res(n,0);\n\tres[n-1]=1;\n\tfor(int i=n-2;i>=0;i--)\n\t\tif(s[i]==s[i+1]){\n\t\t\tREP(j,i+1)\n\t\t\t\tres[j]=1;\n\t\t}\n\tcerr<<res<<endl;\n\treturn res;\n}\n\nsigned main(){\n\tstring s=readString();\n\tint n=s.size();\n\tvi sum(n+1,0);\n\tREP(i,n){\n\t\tint c=s[i]=='a'?1:2;\n\t\tsum[i+1]=(sum[i]+c)%3;\n\t}\n\tcerr<<endl;\n\tvector<vi> to(n+1,vi(3,0));\n\tint last[3]={-1,-1,-1};\n\tfor(int i=n;i>=0;i--){\n\t\tREP(k,3)\n\t\t\tto[i][k]=last[(sum[i]+k)%3];\n\t\tlast[sum[i]]=i;\n\t}\n\tcerr<<to<<endl;\n\tcerr<<endl;\n\tvi use=Waf(s);\n\tint ans=0;\n\tvi dp(n+1,0);\n\tdp[0]=1;\n\tREP(i,n){\n\t\tif(use[i]&&sum[i]!=sum[n]){\n\t\t\tcerr<<i<<\" \"<<dp[i]<<endl;\n\t\t\tadd(ans,dp[i]);\n\t\t}\n\t\tFOR(k,1,3)\n\t\t\tif(to[i][k]!=-1){\n\t\t\t\tcerr<<i<<\"->\"<<to[i][k]<<endl;\n\t\t\t\tadd(dp[to[i][k]],dp[i]);\n\t\t\t\tif(to[i][k]<n&&use[i]&&!use[to[i][k]]&&sum[to[i][k]]!=sum[n]){\n\t\t\t\t\tadd(ans,dp[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tcerr<<dp<<endl;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nconst int mod=1e9+7;\nint n,ans;\nchar s[maxn];\nint sum[maxn],dp[maxn],nxt[maxn][3];\n\nint main(){\n\ts[0]='$';scanf(\"%s\",s+1);n=strlen(s)-1;\n\tREP(i,n)sum[i]=sum[i-1]+(s[i]-'a'+1);\n\trep(j,3){\n\t\tnxt[n+1][j]=n+1;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tnxt[i][j]=nxt[i+1][j];\n\t\t\tif(sum[i]%3==j)nxt[i][j]=i;\n\t\t}\n\t}\n\tdp[0]=1;\n\tint cur=1;\n\tREP(i,n){\n\t\tdp[i]+=dp[i-1];\n\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\tint c=(sum[i-1]+(s[i]=='a'?2:1))%3;\n\t\tcur=max(cur,i+1);\n\t\twhile(cur<=n&&s[cur-1]!=s[cur])cur++;\n\t\tif(i==1&&cur==n+1){\n\t\t\tputs(\"1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint j=nxt[cur][c];\n\t\tif(j<=n){\n\t\t\tdp[j]+=dp[i-1];\n\t\t\tif(dp[j]>=mod)dp[j]-=mod;\n\t\t}\n\t}\n\tREP(i,n)if((sum[n]-sum[i])%3==0){\n\t\tans+=dp[i];\n\t\tif(ans>=mod)ans-=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005, mod = 1000000007;\n\nvoid up(int &x, int y) { x += y - mod, x += x >> 31 & mod; }\n\nint n, dp[N][2], nxt[N], ans;\nchar s[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> s + 1, n = std::strlen(s + 1), dp[0][0] = 1;\n\tnxt[n + 1] = n + 1;\n\tfor (int i = n; i >= 1; --i)\n\t\tnxt[i] = s[i] == s[i + 1] ? i + 1 : nxt[i + 1];\n\tfor (int i = 0; i < n; ++i) {\n\t\tint t = dp[i][0]; up(t, dp[i][1]);\n\t\tup(dp[i + 1][0], t), up(dp[nxt[i + 1]][1], t);\n\t}\n\tfor (int i = n, S = 0; i >= 1; S += s[i--])\n\t\tif (!(S % 3)) {\n\t\t\tup(ans, dp[i][1]);\n\t\t\tif (nxt[i] != n + 1 || i == n) up(ans, dp[i][0]);\n\t\t}\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define oo 0x7fffffff\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar jp=getchar();\n\twhile ((jp>'9'||jp<'0')&&jp!='-')\n\t\tjp=getchar();\n\tif (jp=='-')\n\t\t{\n\t\t\tfh=-1;\n\t\t\tjp=getchar();\n\t\t}\n\twhile (jp>='0'&&jp<='9')\n\t\t{\n\t\t\tout=out*10+jp-'0';\n\t\t\tjp=getchar();\n\t\t}\n\treturn out*fh;\n}\nconst int MAXN=1e5+10;\nconst int P=1e9+7;\ninline int add(int a,int b)\n{\n\treturn (a + b) % P;\n}\ninline int mul(int a,int b)\n{\n\treturn 1ll * a * b  % P;\n}\nchar s[MAXN];\nint pre[MAXN],f[MAXN],nx[3];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tscanf(\"%s\",s);\n\tint n;\n\tint flag=0;\n\tfor(;s[n];++n)\n\t\t{\n\t\t\tpre[n+1]=pre[n]+(s[n]=='a'? 1:2 );\n\t\t\tpre[n+1]%=3;\n\t\t}\n\tfor(rg int i=1;i<n;++i)\n\t\tif(s[i]==s[i-1])\n\t\t\tflag=1;\n\tif(flag==0)\n\t\t{\n\t\t\tputchar('1');\n\t\t\treturn 0;\n\t\t}\n\tf[n]=1;\n\tfor(rg int i=0;i<3;++i)\n\t\tnx[i]=i==pre[n]?n:n+1;\n\tfor(rg int i=n-1;i;--i)\n\t\t{\n\t\t\tf[i]= pre[i]==pre[n];\n\t\t\tfor(rg int c=1;c<=2;++c)\n\t\t\t\tf[i]=add(f[i],f[nx[(pre[i]+c)%3]]);\n\t\t\tnx[pre[i]]=i;\n\t\t}\n\tcout<<add(f[nx[1]],f[nx[2]]);\n\t//fclose(stdin);\n\t//fclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 1000000007\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nchar S[100010];\nint f[100010],lst[100010][3];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tscanf(\"%s\",S+1);int n=strlen(S+1);\n\tint R=1;while(R<n&&S[R+1]!=S[R])++R;\n\tfor(int j=0;j<3;++j)lst[0][j]=-1;\n\tfor(int i=1,s=0,L=0;i<=n;++i){\n\t\tfor(int j=0;j<3;++j)lst[i][j]=lst[i-1][j];\n\t\tlst[i][s]=i-1;\n\t\ts=(s+S[i]-'a'+1)%3;\n\t\tif(S[i]==S[i-1])L=i-1;\n\t\tint p=lst[L][(s+1)%3],q=lst[L][(s+2)%3];\n\t\tif(S[i]=='b')p=i-1;else q=i-1;\n\t\tif(~p){\n\t\t\tinc(f[i],f[p]);\n\t\t\tif(p&&p<=R&&R<i)inc(f[i],p-1>>1);\n\t\t}\n\t\tif(~q){\n\t\t\tinc(f[i],f[q]);\n\t\t\tif(q&&q<=R&&R<i)inc(f[i],q-1>>1);\n\t\t}\n\t\tif(s&&(i==1||i>R))inc(f[i],1);\n\t}\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=1e5+50, mod=1e9+7;\ninline void add(int &x,int y) {x=(x+y>=mod) ? (x+y-mod) : (x+y);}\n\nchar t[N]; \nint n,ans,s[N],f[N],pre[N][3],fir[N];\n\nint main() {\n\tscanf(\"%s\",t+1); n=strlen(t+1);\n\tfor(int i=1;i<=n;i++) s[i]=(s[i-1]+t[i]-'a'+1)%3;\n\tpre[0][0]=pre[0][1]=pre[0][2]=-1;\n\tfor(int i=1;i<=n;i++) {\n\t\tpre[i][0]=pre[i-1][0];\n\t\tpre[i][1]=pre[i-1][1];\n\t\tpre[i][2]=pre[i-1][2];\n\t\tpre[i][s[i-1]]=i-1;\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfir[i]=fir[i-1];\n\t\tif(t[i]==t[i-1]) fir[i]=i;\n\t}\n\tf[0]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tint pos=fir[i]-1;\n\t\tf[i]=f[i-1];\n\t\tint val=(t[i]=='a') ? 2 : 1;\n\t\tif(~pos) {\n\t\t\tpos=pre[pos][(s[i]-val+3)%3];\n\t\t\tif(~pos) add(f[i],f[pos]);\n\t\t}\n\t\tif(!s[i] && i!=n) add(f[i],1);\n\t} \n\tif(!fir[n]) for(int i=1;i<n;i++) if(!s[i]) add(f[n],mod-1);\n\tcout<<f[n]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    string s; cin >> s;\n    int N = SZ(s);\n    \n    int last = 3 - (s.back() - 'a' + 1), nl = 0, tot = 0;\n    REP(i, N) (tot += s[i] - 'a' + 1) %= 3;\n\n    mint ans = 0;\n    int tmp = 0;\n    while(N >= 2 && s[N - 2] != s[N - 1]){\n        (tmp += s[N - 1] - 'a' + 1) %= 3;\n        if(tmp == tot) ans += 1;\n        N--;\n        nl++;\n    }\n    if(N == 1){\n        Return(1);\n    }\n\n    vec S(N + 1, 0);\n    vec suc;\n    REP(i, N){\n        S[i + 1] = (S[i] + s[i] - 'a' + 1) % 3;\n        if(i < N - 1 && s[i] == s[i + 1]) suc.pb(i + 1);\n    }\n    suc.pb(INF);\n\n    mat ls(3);\n    REP(i, N + 1) ls[S[i]].pb(i);\n    REP(j, 3) ls[j].pb(INF);\n\n    mvec dp(N + 1, 0);\n    dp[0] = 1;\n\n    REP(i, N){\n        if((last + S[i]) % 3 == tot) ans += dp[i] * nl; \n\n        int x = (S[i + 1] - S[i] + 3) % 3, y = 3 - x;\n        int y2 = (S[i] + y) % 3;\n        bool f = false;\n\n        dp[i + 1] += dp[i];\n        if(i + 1 == N) f = true;\n\n        int j0 = Lower_bound(suc, i + 1);\n        if(suc[j0] < INF){\n            int j1 = Lower_bound(ls[y2], suc[j0] + 1);\n            if(ls[y2][j1] < INF){\n                dp[ls[y2][j1]] += dp[i];\n                if(ls[y2][j1] == N) f = true;\n            }\n\n            if(!f && suc[j0] + 1 <= N){\n                int z = (S[N] - S[i] + 3) % 3;\n                if(z != 0) dp[N] += dp[i];\n            }\n\n        }\n    }\n    ans += dp[N];\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nchar s[MAXN];\nint dp[MAXN], pre[MAXN], lst[MAXN][3], trans[MAXN][3];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1);\n\tmemset(lst[0], -1, sizeof(lst[0]));\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s[i] == 'a') pre[i] = (pre[i - 1] + 1) % 3;\n\t\telse pre[i] = (pre[i - 1] + 2) % 3;\n\t\tmemcpy(lst[i], lst[i - 1], sizeof(lst[i - 1]));\n\t\tlst[i][pre[i - 1]] = i - 1;\n\t}\n\tmemset(trans[0], -1, sizeof(trans[0]));\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i != 1 && s[i - 1] == s[i]) memcpy(trans[i], lst[i], sizeof(lst[i]));\n\t\telse memcpy(trans[i], trans[i - 1], sizeof(trans[i - 1]));\n\t}\n\tif (trans[n][0] == -1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tdp[n] = 1;\n\tfor (int i = n; i >= 1; i--) {\n\t\tupdate(dp[i - 1], dp[i]);\n\t\tif (s[i] == 'a') {\n\t\t\tif (trans[i][(pre[i] + 1) % 3] != -1) update(dp[trans[i][(pre[i] + 1) % 3]], dp[i]);\n\t\t} else {\n\t\t\tif (trans[i][(pre[i] + 2) % 3] != -1) update(dp[trans[i][(pre[i] + 2) % 3]], dp[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n - 1; i++)\n\t\tif (pre[i] == 0) ans = (ans + dp[i]) % P;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005, mod = 1000000007;\n\nvoid up(int &x, int y) { x += y - mod, x += x >> 31 & mod; }\n\nint n, dp[N], nxt[N], ans;\nchar s[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> s + 1, n = std::strlen(s + 1), dp[0] = 1;\n\tnxt[n + 1] = n + 1;\n\tfor (int i = n; i >= 1; --i)\n\t\tnxt[i] = s[i] == s[i + 1] ? i + 1 : nxt[i + 1];\n\tif (nxt[1] > n) return std::cout << 1 << '\\n', 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tup(dp[i + 1], dp[i]), up(dp[nxt[i + 1]], dp[i]);\n\tfor (int i = n, S = 0; i >= 1; S += s[i--])\n\t\tif (!(S % 3)) up(ans, dp[i]);\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int zzy = 998244353;\nchar s[100010];\nint flag;\nint n;\nint nxt[100010][3], dp[100010], sum[100010];\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    for (int i = 2; i <= n; i++) if(s[i] == s[i - 1]) flag = 1;\n    if (!flag) return puts(\"1\"), 0;\n    for (int i = 1; i <= n; i++) sum[i] = (sum[i - 1] + (s[i] == 'a' ? 1 : 2)) % 3;\n    memset(nxt[n], -1, sizeof nxt[n]);\n    for (int i = n - 1; i >= 0; i--) {\n        memcpy(nxt[i], nxt[i + 1], sizeof nxt[i]);\n        nxt[i][sum[i + 1]] = i + 1;\n    }\n    dp[0] = 1;\n    for (int i = 0; i < n; i++) {\n        if (sum[i] != 0 && ~nxt[i][0]) dp[nxt[i][0]] = (dp[nxt[i][0]] + dp[i]) % zzy;\n        if (sum[i] != 1 && ~nxt[i][1]) dp[nxt[i][1]] = (dp[nxt[i][1]] + dp[i]) % zzy;\n        if (sum[i] != 2 && ~nxt[i][2]) dp[nxt[i][2]] = (dp[nxt[i][2]] + dp[i]) % zzy;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        if (sum[i] == sum[n]) ans = (ans + dp[i]) % zzy;\n    }\n    return cout << ans << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nint read(){char c=getchar();int d=0,f=1;for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;for(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());return d*f;}\nchar Read(){char c=getchar();while(c<'0'||c>'9')c=getchar();return c;}\ntypedef pair<int,int>PII;\ntypedef long long LL;\nconst int N=100000;\nconst int mod=1e9+7;\nint n,dp[N+1],a[N+1],t[N+1][3],tt[N+1],p[10];\nchar s[N+1];\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tref(i,1,n)a[i]=(s[i]=='a'?1:2);\n\tref(i,1,n)(a[i]+=a[i-1])%=3;\n\tdef(i,n,1){\n\t\tref(j,0,2)t[i][j]=t[i+1][j]; t[i][a[i]]=i;\n\t\ttt[i]=tt[i+1]; if(i<n&&(a[i-1]+a[i+1]-2*a[i])%3==0)tt[i]=i+1;\n\t}\n\tdp[0]=1;\n\tref(i,0,n-1)if(dp[i]){\n\t\tp[0]=0;\n\t\tp[++p[0]]=i+1;\n\t\tif(tt[i+1])ref(j,0,2)if(j!=a[i]&&j!=a[i+1])p[++p[0]]=t[tt[i+1]][j];\n\t\tif(tt[i+1]&&a[n]!=a[i]){\n\t\t\tp[++p[0]]=n;\n\t\t\tref(j,1,p[0]-1)if(p[j]==n)p[0]--;\n\t\t}\n\t\tref(j,1,p[0])(dp[p[j]]+=dp[i])%=mod;\n\t\tif(i&&i!=n-1&&!tt[i+1]&&(i%2!=n%2))(dp[n]+=(mod+dp[i]-dp[i-1])%mod)%=mod;\n\t}\n\tcout<<dp[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005,mod=1e9+7;\nint f[N],s[N],nxt[N],las[N][3],n,ans;\nchar st[N];\n\nint main(){\n\tscanf(\"%s\",st+1);\n\tn=strlen(st+1);\n\trep(i,1,n){\n\t\ts[i]=(s[i-1]+1+(st[i]=='b'))%3;\n\t\t//printf(\"%d \",s[i]);\n\t}\n\t//puts(\"\");\n\tper(i,n,1){\n\t\tif(st[i]==st[i+1])nxt[i]=i+1;\n\t\telse nxt[i]=nxt[i+1];\n\t\tREP(t,3)las[i][t]=las[i+1][t];\n\t\tlas[i][s[i]]=i;\n\t}\n\tf[0]=1;\n\trep(i,1,n){\n\t\t//printf(\"## f[%d] = %d\\n\",i-1,f[i-1]);\n\t\tf[i]=(f[i]+f[i-1])%mod;\n\t\tint p=nxt[i];\n\t\t//printf(\"nxt[%d] = %d\\n\",i,p);\n\t\tif(p){\n\t\t\tp=las[p][(2*s[i-1]+3-s[i])%3];\n\t\t\t//printf(\"%d -> %d\\n\",i-1,p);\n\t\t\tf[p]=(f[p]+f[i-1])%mod;\n\t\t}\n\t\tif(nxt[i]==i+1&&!nxt[nxt[i]]){\n\t\t\tp=las[nxt[i]][s[i]];\n\t\t\tf[p]=(f[p]+f[i-1])%mod;\n\t\t}\n\t\tif(i==n||nxt[i]&&s[i-1]!=s[n]){\n\t\t\t//printf(\"add %d  %d\\n\",i-1,f[i-1]);\n\t\t\tans=(ans+f[i-1])%mod;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y) {\n\treturn ((ll)x * y) % MOD;\n}\n\nconst int N = 100100;\nvector<int> pos[3];\nint bal[N];\nint dp[N];\nchar s[N];\nint nxt[N];\nint n;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tbal[0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tbal[i + 1] = bal[i];\n\t\tif (s[i] == 'a')\n\t\t\tbal[i + 1] += 1;\n\t\telse\n\t\t\tbal[i + 1] += 2;\n\t\tbal[i + 1] %= 3;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tpos[bal[i]].push_back(i);\n\tnxt[n] = nxt[n - 1] = n + 1;\n\tfor (int i = n - 2; i >= 0; i--) {\n\t\tnxt[i] = nxt[i + 1];\n\t\tif (s[i] == s[i + 1])\n\t\t\tnxt[i] = i + 2;\n\t}\n\tint ans = 0;\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i + 1] = add(dp[i + 1], dp[i]);\n\t\tif (nxt[i + 1] == n + 1) {\n\t\t\tif (i < n - 1 && s[i] == s[i + 1])\n\t\t\t\tans = add(ans, mult(dp[i], (n - i) / 2 - 1));\n\t\t}\n\t\tint want = bal[i];\n\t\tif (s[i] == 'a')\n\t\t\twant += 2;\n\t\telse\n\t\t\twant += 1;\n\t\twant %= 3;\n\t\tif (i == n - 1 || (bal[i] != bal[n] && nxt[i] <= n))\n\t\t\tans = add(ans, dp[i]);\n\t\tint pp = lower_bound(pos[want].begin(), pos[want].end(), nxt[i]) - pos[want].begin();\n\t\tif (pp == (int)pos[want].size()) continue;\n\t\tint q = pos[want][pp];\n\t\tdp[q] = add(dp[q], dp[i]);\n\t\tif (q < n && nxt[q] == n + 1)\n\t\t\tans = add(ans, mult(dp[i], (n - q - 1) / 2));\n\t}\n/*\n\tfor (int i = 0; i <= n; i++)\n\t\tprintf(\"%d \", dp[i]);\n\tprintf(\"\\n\");\n*/\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nchar str[200050];\nint dp[200050];\nint nxt[200050][2];\n\nint main()\n{\n\tscanf(\"%s\",str + 1);\n\tint n = strlen(str + 1);\n\tbool fg = 0;\n\tfor(int i = 1;i < n; ++ i)\n\t\tfg |= str[i] == str[i + 1];\n\tif(!fg) return printf(\"1\\n\"),0;\n\tdp[n + 1] = 1;\n\tint sum = 0;\n\tfor(int i = n;i >= 1; -- i)\n\t{\n\t\tsum = (sum + str[i] - 'a' + 1) % 3;\n\t\tnxt[i][0] = (str[i] == 'a') ? i + 1 : (str[i + 1] == 'b' ? i + 2 : nxt[i + 2][0]);\n\t\tnxt[i][1] = (str[i] == 'b') ? i + 1 : (str[i + 1] == 'a' ? i + 2 : nxt[i + 2][1]);\n\t\tdp[i] = (dp[nxt[i][0]] + dp[nxt[i][1]] + (sum == 0)) % mod;\n\t}\n\tprintf(\"%d\\n\",dp[1] - (sum == 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e5 + 10;\n\nint n, last[3] = {0,-1,-1}, dp[N];\nstring s;\n\nint main() {\n    cin >> s;\n    int n = s.size();\n    s = ' ' + s;\n\n    dp[0] = 1;\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        int x = s[i]-'a'+1;\n        sum += x;\n        if (sum >= 3) sum -= 3;\n\n        dp[i] = 0;\n        for (int c = 1; c <= 2; c++) {\n            int j = last[(sum+3-c)%3];\n            if (j >= 0) {\n                dp[i] += dp[j];\n                if (dp[i] >= MOD) dp[i] -= MOD;\n            }\n        }\n        if (sum == 0) {\n            ++dp[i];\n            if (dp[i] >= MOD) dp[i] -= MOD;\n        }\n        last[sum] = i;\n    }\n    cout << (dp[n] + MOD- (sum == 0)) % MOD << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5, mod = 1e9 + 7;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nchar s[maxn];\nint n, sum, flg, nxt[2][maxn], f[maxn];\n\nint main()\n{\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tflg = 0;\n\tfor (int i = 1; i < n; ++i) flg += s[i] == s[i + 1];\n\tif (!flg) return puts(\"1\"), 0;\n\tf[n + 1] = 1; nxt[0][n + 1] = nxt[1][n + 1] = nxt[0][n + 2] = nxt[1][n + 2] = n + 2;\n\tfor (int i = n; i; --i) {\n\t\t(sum += s[i] - 'a' + 1) %= 3;\n\t\tnxt[0][i] = s[i] == 'a' ? i + 1 : nxt[1][i + 1];\n\t\tnxt[1][i] = s[i] == 'b' ? i + 1 : nxt[0][i + 1];\n\t\tf[i] = sum == 0;\n\t\tinc(f[i], f[nxt[0][i]]);\n\t\tinc(f[i], f[nxt[1][i]]);\n\t}\n\tprintf(\"%d\\n\", f[1] - (sum == 0));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5, mod = 1e9 + 7;\nchar s[maxn + 10];\nint a[maxn + 10], b[maxn + 10], tr[maxn + 10][3];\nint to[maxn + 10], n, ans, f[maxn + 10];\nint main() {\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (s[i] == 'a') a[i] = 1;\n\t\telse a[i] = 2;\n\t\tb[i] = (b[i - 1] + a[i]) % 3;\n\t}\n\tfor (int i = 0; i < 3; ++i) tr[n + 1][i] = n + 1;\n\tfor (int i = n; i >= 1; --i) {\n\t\tif (i == n) to[i] = n + 1;\n\t\telse if (a[i] == a[i + 1]) to[i] = i + 1;\n\t\telse to[i] = to[i + 1];\n\t\tfor (int j = 0; j < 3; ++j) tr[i][j] = tr[i + 1][j];\n\t\ttr[i][b[i]] = i;\n\t}\n\tif (to[1] == n + 1) {\n\t\tprintf(\"1\"); return 0;\n\t}\n\tf[0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 1; j < 3; ++j)\n\t\t\tif (a[i + 1] == j) (f[i + 1] += f[i]) %= mod;\n\t\t\telse {\n\t\t\t\tint p = to[i + 1];\n\t\t\t\tif (p <= n) p = tr[p][(b[i] + j) % 3];\n\t\t\t\tif (p <= n) (f[p] += f[i]) %= mod;\n\t\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = n; i >= 1; --i) {\n\t\tif (!sum) (ans += f[i]) %= mod;\n\t\tsum = (sum + a[i]) % 3;\n\t}\n\tprintf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nint main(){\n    cin.sync_with_stdio(0); cin.tie(0);\n    \n    const LL MOD = 1000000007;\n    \n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<LL> num(n);\n    for(int i = 0; i < n; i++){\n        num[i] = s[i] - 'a' + 1;\n    }\n    vector<LL> dp(n+1, 0);\n    dp[n] = 1;\n    vector<LL> psums(n+1, 0);\n    psums[0] = 0;\n    set<LL> f[3];\n    for(int i = 0; i < n; i++){\n        psums[i+1] = (psums[i] + num[i]) % 3;\n        f[psums[i]].insert(i);\n    }\n    set<LL> repeats;\n    for(int i = 0; i < n; i++){\n        if(i + 1 < n && num[i] == num[i+1]) repeats.insert(i+1);\n    }\n    \n    f[psums[n]].insert(n);\n    int stillbad = 1;\n    for(LL r = n-1; r >= 0; r--){\n        dp[r] = 0;\n        if(r + 1 < n && num[r] == num[r+1]) stillbad = 0;\n        if(stillbad){\n            dp[r] = 1;\n            continue;\n        }\n        for(LL b = 1; b <= 2; b++){\n            int count_whole = 0;\n            if(num[r] == b){\n                dp[r] += dp[r+1];\n                dp[r] %= MOD;\n                if(r+1 == n) count_whole = 1;\n                if(repeats.lower_bound(r+2) == repeats.end()){\n                    LL q = n - (r+1);\n                    dp[r] += q/2;\n                    dp[r] %= MOD;\n                    count_whole = 1;\n                }\n                // do something special; in weird case\n            } else {\n                auto z = repeats.lower_bound(r + 1);\n                if(z == repeats.end()) continue;\n                \n                LL look_for = (psums[r] + b) % 3;\n                auto it = f[look_for].lower_bound(*z);\n                if(it == f[look_for].end()) continue;\n                int idx = *it;\n                dp[r] += dp[idx];\n                dp[r] %= MOD;\n                if(idx == n) count_whole = 1;\n                if(repeats.lower_bound(idx + 1) == repeats.end()){\n                    LL q = n - idx;\n                    dp[r] += q/2;\n                    dp[r] %= MOD;\n                    count_whole = 1;\n                }\n            }\n            if(!count_whole == 1 && (psums[r] + b) % 3 == psums[n] && !stillbad){\n                dp[r] ++;\n                dp[r] %= MOD;\n            }\n        }\n    }\n    cout << dp[0] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\ntypedef long long LL;\nconst int N=1e5+5,P=1e9+7;\n\nint n;\nchar S[N];\nLL s[N];\nint app_a[N],app_b[N];//在当前状态下加一个a后转移到的状态\nint nex[N][3];//下一个，前缀和%3=i的位置（不算当前的位置）\nint nex_xx[N];//下一个连续相同字符的位置， nex_xx[i] 和nex_xx[i]+1相同\nLL f[N];\n\nint main(){\n    scanf(\"%s\",S+1);\n    n=strlen(S+1);\n    FOR(i,1,n)s[i]=S[i]=='a'?1:2;\n    FOR(i,2,n)s[i]+=s[i-1];\n    nex[n][0]=nex[n][1]=nex[n][2]=n+1;\n    nex[n+1][0]=nex[n+1][1]=nex[n+1][2]=n+1;\n    ROF(i,n-1,0){\n        FOR(j,0,2)nex[i][j]=s[i+1]%3==j?i+1:nex[i+1][j];\n    }\n    //FOR(i,0,n)printf(\"%d%c\",nex[i][0],\" \\n\"[i==n]);\n    //FOR(i,0,n)printf(\"%d%c\",nex[i][1],\" \\n\"[i==n]);\n    //FOR(i,0,n)printf(\"%d%c\",nex[i][2],\" \\n\"[i==n]);\n    nex_xx[n]=nex_xx[n+1]=n+1;\n    ROF(i,n-1,0){\n        nex_xx[i]=s[i+1]-s[i]==s[i+2]-s[i+1]?i+1:nex_xx[i+1];\n    }\n    //FOR(i,0,n)printf(\"%d%c\",nex_xx[i],\" \\n\"[i==n]);\n    FOR(i,0,n){\n        app_a[i]=s[i+1]-s[i]==1?i+1:nex[nex_xx[i]][(s[i]+1)%3];\n        app_b[i]=s[i+1]-s[i]==2?i+1:nex[nex_xx[i]][(s[i]+2)%3];\n    }\n    //FOR(i,0,n)printf(\"%d%c\",app_a[i],\" \\n\"[i==n]);\n    //FOR(i,0,n)printf(\"%d%c\",app_b[i],\" \\n\"[i==n]);\n    f[0]=1;\n    FOR(i,0,n){\n        f[app_a[i]]=(f[app_a[i]]+f[i])%P;\n        f[app_b[i]]=(f[app_b[i]]+f[i])%P;\n    }\n    LL ans=0;\n    FOR(i,1,n)if(s[i]%3==s[n]%3)ans=(ans+f[i])%P;\n    if(nex_xx[0]==n+1)puts(\"1\");\n    else printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstring S;\nmap<string, int> mp;\n\nll rec(string temp = S){\n    \n    ll ans = 0;\n    \n    for(int i = 0; i < temp.size() - 1; ++i){\n        if(temp[i] == 'a' && temp[i + 1] == 'a'){\n            string n;\n            for(int j = 0; j < i; ++j) n.push_back(temp[j]);\n            n.push_back('b');\n            for(int j = i + 2; j < temp.size(); ++j) n.push_back(temp[j]);\n            auto itr = mp.find(n);\n            if(itr == mp.end()){\n                ++ans;\n                ans %= MOD;\n                ++mp[n];\n                ans += rec(n);\n                ans %= MOD;\n            }\n        }\n        if(temp[i] == 'b' && temp[i + 1] == 'b'){\n            string n;\n            for(int j = 0; j < i; ++j) n.push_back(temp[j]);\n            n.push_back('a');\n            for(int j = i + 2; j < temp.size(); ++j) n.push_back(temp[j]);\n            auto itr = mp.find(n);\n            if(itr == mp.end()){\n                ++ans;\n                ans %= MOD;\n                ++mp[n];\n                ans += rec(n);\n                ans %= MOD;\n            }\n        }\n    }\n    \n    return ans;\n}\n\nint main(void){\n\t\n\tcin >> S;\n\tprintf(\"%lld\\n\", (rec() + 1) % MOD);\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint n, sum[100007], dp[100007], is, pre[3] = { 0,-1,-1 };\nchar s[100007];\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++)\n\t\tsum[i] = (sum[i - 1] + (s[i] - 'a' + 1)) % 3;\n\tfor (int i = 2; i <= n; i++)\n\t\tif (s[i] == s[i - 1])is = 1;\n\tif (!is) { cout << 1 << endl; return 0; }\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i < n && !sum[i])dp[i] = 1;\n\t\tdp[i] = (dp[i] + dp[i - 1]) % mod;\n\t\tint v = (sum[i] + (s[i] - 'a' + 1)) % 3;\n\t\tif (pre[v] != -1)dp[i] = (dp[i] + dp[pre[v]]) % mod;\n\t\tpre[sum[i]] = i;\n\t}\n\tcout << dp[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int Q=1<<17;\nchar s[Q];\nint sm[Q];\nint f[3];\nconst int MOD=1e9+7;\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\nint main()\n{\n    scanf(\"%s\",s+1);\n    int n=strlen(s+1);\n    int fl=0;\n    for(int i=1;i<=n;i++){\n        sm[i]=(sm[i-1]+(s[i]=='a'?1:2))%3;\n        if(i>1&&s[i]==s[i-1])fl=1;\n    }\n    if(!fl)return printf(\"1\")&0;\n    for(int i=n;i>=0;--i){\n        int now=sm[i]==sm[n];\n        now=add(now,add(f[(sm[i]+1)%3],f[(sm[i]+2)%3]));\n        f[sm[i]]=now;\n    }\n    printf(\"%d\",add(f[1],f[2]));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nauto rd=read<int>;\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\nconst u32 P=1e9+7;\nu32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\nu32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\nu32 sum(u32 a, u32 b) {return inc(a, b);}\nu32 dif(u32 a, u32 b) {return dec(a, b);}\n\nconst int N=1e5+1;\nint n, p[N];\nu32 f[N];\nchar s[N];\nint main() {\n\tu32 ans=0;\n\tint pos[3]={};\n\tassert(scanf(\"%s\", s)==1);\n\tn=strlen(s);\n\tfor(int i=0; i<n; ++i) s[i]=(s[i]=='a')?1:2;\n\tbool diff=true;\n\tfor(int i=1; i<n; ++i) if(s[i]==s[i-1]) diff=false;\n\tif(diff) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<n; ++i) p[i+1]=(p[i]+s[i])%3;\n\tf[0]=1;\n\tfor(int i=0, j=0; i<n; ++i) {\n\t\tint pinkrabbit=(p[i]-s[i]+3)%3, &k=pos[pinkrabbit];\n\t\tinc(f[i+1], f[i]);\n\t\tif(cmax(j, i+1)) while(j<n&&s[j-1]!=s[j]) ++j;\n\t\tif(cmax(k, j+1)) while(k<=n&&p[k]!=pinkrabbit) ++k;\n\t\tif(k<=n) inc(f[k], f[i]);\n\t\tif(p[i]!=p[n]) inc(ans, f[i]);\n\t}\n\tprintf(\"%u\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint change_time = 0;\nchar maked_word[10000][100001] = {{'\\0'}};\nint temp = 0;\n\nchar* change(int t,char *s,char sw)\n{\n\tchar ret[100001];\n\tfor(int i =0;i<t;i++)\n\t{\n\t\tret[i] = s[i];\n\t}\n\tret[t] = sw;\n\tfor(int i=t+1;s[i+1] != '\\0';i++)\n\t{\n\t\tret[i] = s[i+1];\n\t}\n\n\treturn ret;\n}\n\n\nvoid saiki(char *s)\n{\n\t//printf(\"%s\\n\",s);\n\tstrcpy(maked_word[change_time],s);\n\tfor(int i =0;i<change_time;i++)\n\t{\n\t\tif(strcmp(maked_word[i],s) == 0)\n\t\t{\n\t\t\tchange_time -=1;\n\t\t}\n\t}\n\tchange_time++;\n\tint num=0;\n\tfor(int i=0;s[i] != '\\0';i++)\n\t{\n\t\tnum++;\n\t}\n\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tif(s[i] == 'a' && s[i+1] == 'a')\n\t\t{\n\t\t\tchar *ss = change(i,s,'b');\n\t\t\tsaiki(ss);\n\t\t}\n\t\tif(s[i] == 'b' && s[i+1] == 'b')\n\t\t{\n\t\t\tchar *ss =change(i,s,'a');\n\t\t\tsaiki(ss);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tchar s[100001];\n\tscanf(\"%s\",s);\n\tsaiki(s);\n\tprintf(\"%d\\n\",change_time);\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn=100111;\nchar s[maxn];\nint pre[maxn];\nint nxta[maxn],nxtb[maxn];\nll dp[maxn];\nint n;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool f=true;\n\tfor(int i=1;i<n;i++)f&=s[i]!=s[i+1];\n\tif(f)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpre[i]=pre[i-1]+(s[i]=='a'?1:-1);\n \t}\n \tint lst[3]={};\n \tfor(int i=n;i>=0;i--)\n \t{\n \t\tif(i<n)\n \t\t{\n \t\t\tnxta[i]=lst[((pre[i]+1)%3+3)%3];\n \t\t\tnxtb[i]=lst[((pre[i]+2)%3+3)%3];\n\t\t}\n\t\tlst[(pre[i]%3+3)%3]=i;\n \t\t\n \t}\n //\tfor(int i=0;i<n;i++)cerr<<nxta[i]<<\",\"<<nxtb[i]<<\" \";cerr<<endl;\n \tdp[0]=1;\n \tfor(int i=0;i<n;i++)\n \t{\n \t\tif(nxta[i])dp[nxta[i]]=(dp[nxta[i]]+dp[i])%mod;\n \t\tif(nxtb[i])dp[nxtb[i]]=(dp[nxtb[i]]+dp[i])%mod;\n \t}\n// \tfor(int i=1;i<=n;i++)cerr<<dp[i]<<\" \";cerr<<endl;\n \tll sum=0;\n \tfor(int i=1;i<=n;i++)if((pre[i]-pre[n])%3==0)sum=(sum+dp[i])%mod;\n \tcout<<sum<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define file(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool chkmin(T &a,T b){return (a>b)?a=b,1:0;}\n\ninline int read() {\n int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\nint n;\nchar s[1000005];\nint sum[1000005];\nint dp[1000005];\nint nxt[10];\nconst int mod=1e9+7;\nint main () {\n#ifndef ONLINE_JUDGE\n//file(\"agc27e\");\n#endif\n    scanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tF(i,1,n)sum[i]=(sum[i-1]+s[i]-'a'+1)%3;\n\tdp[n]=1;\n\tbool flag=0;\n\tF(i,1,n-1)if(s[i]==s[i+1])flag=1;\n\tif(!flag){\n\t  puts(\"1\");\n\t  return 0;\n\t}\n\tF(i,0,2)nxt[i]=i==sum[n]?n:n+1;\n\tf(i,n-1,1){\n\t  dp[i]=sum[i]==sum[n];\n\t  F(j,1,2){\n\t     dp[i]=(dp[i]+dp[nxt[(sum[i]+j)%3]])%mod;\n\t  }\n\t  nxt[sum[i]]=i;\n\t}\n    printf(\"%d\\n\",(dp[nxt[1]]+dp[nxt[2]])%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005,mod=1e9+7;\nint f[N],s[N],nxt[N],las[N][3],sum[N][3];\nint n,flag,ans=1;\nchar st[N];\n\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\n\nint main(){\n\tscanf(\"%s\",st+1);\n\tn=strlen(st+1);\n\trep(i,1,n){\n\t\ts[i]=(s[i-1]+1+(st[i]=='b'))%3;\n\t}\n\tper(i,n,1){\n\t\tif(st[i]==st[i+1])nxt[i]=i+1;\n\t\telse nxt[i]=nxt[i+1];\n\t\tREP(t,3) las[i][t]=las[i+1][t];\n\t\tlas[i][s[i]]=i;\n\t}\n\tf[0]=1;\n\trep(i,1,n){\n\t\tadd(f[i],f[i-1]);\n\t\tint p=nxt[i];\n\t\tif(p){\n\t\t\tadd(sum[p][s[i-1]],f[i-1]);\n\t\t\tp=las[p][(2*s[i-1]+3-s[i])%3];\n\t\t\tadd(f[p],f[i-1]);\n\t\t}\n\t\tREP(t,3){\n\t\t\tadd(sum[i][t],sum[i-1][t]);\n\t\t\tint tmp=(s[i]-t+3)%3;\n\t\t\tif(tmp&&tmp!=(s[i]-s[i-1]+3)%3){\n\t\t\t\tadd(ans,sum[i][t]);\n\t\t\t\t//printf(\"%d %d   %d\\n\",i,t,sum[i][t]);\n\t\t\t}\n\t\t}\n\t\tif(!flag&&st[i]==st[i-1])\n\t\t\tflag=1,ans+=(i-1)/2;\n\t\tif(!s[i-1]&&flag)ans++;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define f(a,b) a=(a+b)%mod\ntypedef long long ll;\n\nusing namespace std;\nstring s;\n#define N 100010\nll d[N],cs[N];\nvector<int> v[3];\nint main(){\n    cin>>s;cs[0]=0;\n    lol(i,s.size()){\n\ts[i]=s[i]-'a'+1;\n\tcs[i+1]=cs[i]+s[i];\n\tv[cs[i+1]%3].push_back(i+1);\n    }\n    ll p[3]={0,0,0};d[0]=1;\n    lol(i,s.size())lol(j,2){\n\tll r=(cs[i]+j+1)%3;\n\tfor(;p[r]<v[r].size()&&v[r][p[r]]<=i;p[r]++){}\n\tif(p[r]!=v[r].size())f(d[v[r][p[r]]],d[i]);\n    }\n    ll cnt=cs[s.size()],ans=0;\n    for(int i=0;i<s.size();i++){\n\tcnt-=s[i]-'a'+1;\n\tif(cnt%3==0)f(ans,d[i+1]);\n    }\n    bool ok=0;lol(i,s.size()-1)ok|=(s[i]==s[i+1]);\n    cout<<(ok?ans:1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define fir first\n#define sec second\n#define mod 1000000007\n#define ll long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\ninline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\ninline int add(int x,int y,int z){return add(add(x,y),z);}\ninline int sub(int x,int y){return x-y<0?x-y+mod:x-y;}\ninline int mul(int x,int y){return 1LL*x*y%mod;}\ninline int mul(int x,int y,int z){return mul(mul(x,y),z);}\n#define N 100005\nchar s[N];\nint nxt[N][3],a[N],f[N];\nsigned main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tfor(int i=1;i<=n;i++) a[i]=s[i]-'a';\n\tbool ok=0; for(int i=2;i<=n;i++) if(s[i]==s[i-1]) ok=1;\n\tif(!ok) {cout<<1<<endl; return 0;}\n\tnxt[n+1][0]=nxt[n+1][1]=nxt[n+2][0]=nxt[n+2][1]=n+2;\n\tint sum=0;\n\tf[n+1]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tsum=(sum+a[i]+1)%3;\n\t\tif(a[i]==0) nxt[i][0]=i+1;\n\t\telse if(a[i+1]==1) nxt[i][0]=i+2;\n\t\telse nxt[i][0]=nxt[i+2][0];\n\t\tif(a[i]==1) nxt[i][1]=i+1;\n\t\telse if(a[i+1]==0) nxt[i][1]=i+2;\n\t\telse nxt[i][1]=nxt[i+2][1];\n\t\tf[i]=add(f[nxt[i][0]],f[nxt[i][1]],sum==0);\n\t}\n\tif(sum==0) f[1]=sub(f[1],1);\n\tcout<<f[1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define last last2\n\nusing namespace std;\n\nchar str[100005];\nint f[100005],last[100005][3];\n\nint main() {\n  memset(last,255,sizeof(last));\n  scanf(\"%s\",str+1);\n  int n=strlen(str+1);\n  int nr=0;\n  while (nr<n&&str[nr+1]!=str[nr]) nr++;\n  int l=0,s=0;\n  last[0][0]=0;\n  for(int i=1;i<=n;i++) {\n  \ts=(s+str[i]-'a'+1)%3;\n  \tmemcpy(last[i],last[i-1],sizeof(last[i]));\n  \tlast[i][s]=i;\n  \tif (str[i]==str[i-1]) l=i-2;\n  \tint u=last[l][(s+2)%3],v=last[l][(s+1)%3];\n  \tif (str[i]=='a') u=i-1; else v=i-1;\n  \tif (u!=-1) {\n\t  f[i]=(f[i]+f[u])%MOD;\n\t  if (u&&nr>=u&&nr<i) f[i]=(f[i]+((u-1)>>1))%MOD;\n    }\n    if (v!=-1) {\n\t  f[i]=(f[i]+f[v])%MOD;\n\t  if (v&&nr>=v&&nr<i) f[i]=(f[i]+((v-1)>>1))%MOD;\n\t}\n  \tif (s&&(i==1||nr<i)) f[i]=(f[i]+1)%MOD;\n  }\n  printf(\"%d\\n\",f[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\nconst int mod = 1e9 + 7;\n\nchar s[N]; int pre[N], dp[N], nxt[3];\n\nint main() {\n    scanf(\"%s\", s + 1); int n = strlen(s + 1);\n    for (int i = 1; i <= n; i++) \n        pre[i] = (pre[i - 1] + s[i] - 'a' + 1) % 3;\n    bool flag = true;\n    for (int i = 2; i <= n; i++)\n        if (s[i] == s[i - 1]) {\n            flag = false; break;\n        }\n    if (flag) return puts(\"1\"), 0;\n    nxt[0] = nxt[1] = nxt[2] = n + 1, dp[n + 1] = 1;\n    for (int i = n; i >= 1; i--) {\n        if (pre[i - 1] == pre[n] && i != 1) dp[i] = 1;\n        dp[i] = (dp[i] + dp[i + 1]) % mod;\n        int nw = s[i] - 'a' + 1, t = (pre[i - 1] + 3 - nw) % 3;\n        dp[i] = (dp[i] + dp[nxt[t] + 1]) % mod, nxt[pre[i]] = i;\n    }\n    printf(\"%d\\n\", dp[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;\n    mint() = default;\n    mint(int64_t value_) : value(value_) {}\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    inline bool operator == (mint<MOD> other) const { return value == other.value; }\n};\n\nconstexpr int MOD = 1e9 + 7;\nmint<MOD> solve(string const & s) {\n    int n = s.length();\n\n    // it becomes a corner case when no operation is available\n    bool is_trivial = true;\n    REP (i, n - 1) {\n        if (s[i] == s[i + 1]) {\n            is_trivial = false;\n            break;\n        }\n    }\n    if (is_trivial) {\n        return 1;\n    }\n\n    // prepare invariants with modulo 3\n    vector<mint<3> > invariant(n + 1);\n    REP (i, n) {\n        invariant[i + 1] = invariant[i] + (s[i] - 'a' + 1);\n    }\n\n    // construct the table\n    vector<array<int, 2> > next(n, { INT_MAX, INT_MAX });\n    array<array<array<vector<int>, 2>, 3>, 2> unused;\n    REP (l, n) {\n        // [*, l + 1)\n        if (l >= 1 and s[l - 1] == s[l]) {\n            REP (c, 2) {\n                REP (d, 3) {\n                    copy(ALL(unused[c][d][false]), back_inserter(unused[c][d][true]));\n                    unused[c][d][false].clear();\n                }\n            }\n        }\n        REP (c, 2) {\n            int d = (invariant[l + 1] - (c + 1)).value;\n            for (int l1 : unused[c][d][true]) {\n                next[l1][c] = l + 1;\n            }\n            unused[c][d][true].clear();\n        }\n\n        // [l, *)\n        bool c = s[l] - 'a';\n        next[l][c] = l + 1;\n        unused[not c][invariant[l].value][false].push_back(l);\n    }\n\n    // run dp\n    vector<mint<MOD> > dp(n + 1);\n    dp[0] = 1;\n    REP (l, n) {\n        REP (c, 2) {\n            if (next[l][c] != INT_MAX) {\n                dp[next[l][c]] += dp[l];\n            }\n        }\n    }\n\n    // count the answer\n    mint<MOD> acc = 0;\n    REP3 (r, 1, n + 1) {\n        if (invariant[n] - invariant[r] == 0) {\n            acc += dp[r];\n        }\n    }\n    return acc;\n}\n\nint main() {\n    string s; cin >> s;\n    cout << solve(s).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=1e5+50;\nint n;\nint f[maxn];\nint nex[maxn];\nint sum[maxn];\nchar s[maxn];\nvector<int> pos[3];\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int idx(char c)\n{\n\treturn c=='a'?1:2;\n}\nint solve()\n{\n\tbool flag=true;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(s[i]==s[i+1])\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag)\n\t{\n\t\treturn 1;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tsum[i]=(sum[i-1]+idx(s[i]))%3;\n\t\tpos[sum[i]].push_back(i);\n\t}\n\tnex[n]=n+1;\n\tfor(int i=n-1;i>=0;--i)\n\t{\n\t\tnex[i]=s[i]==s[i+1]?i+1:nex[i+1];\n\t}\n\tf[0]=1;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tf[i+1]=add(f[i+1]+f[i]);\n\t\tint c=idx('a'+'b'-s[i+1]);\n\t\tconst vector<int> &v=pos[(sum[i]+c)%3];\n\t\tint p=lower_bound(v.begin(),v.end(),nex[i])-v.begin();\n\t\tif(p!=int(v.size()))\n\t\t{\n\t\t\tf[v[p]]=add(f[v[p]]+f[i]);\n\t\t}\n\t}\n\tint an=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(sum[i]==sum[n])\n\t\t{\n\t\t\tan=add(an+f[i]);\n\t\t}\n\t}\n\treturn an;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 100100\nconst int mod=1e9+7;\n\nchar s[N];\nint flag,n;\nint f[N],sum[N],last[3]={0,-1,-1};\n\nint main()\n{\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tfor (int i=1;i<n;i++)\n\t\tif (s[i]==s[i+1]) {flag=1; break;}\n\tif (!flag) return puts(\"1\"),0;\n\t\n\tf[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tsum[i]=(sum[i-1]+(s[i]-'a'+1))%3;\n\t\tif (!sum[i] && i<n) f[i]=1;\n\t\tif (last[(sum[i]+1)%3]>=0) f[i]=(f[i]+f[last[(sum[i]+1)%3]])%mod;\n\t\tif (last[(sum[i]+2)%3]>=0) f[i]=(f[i]+f[last[(sum[i]+2)%3]])%mod;\n\t\tlast[sum[i]]=i;\n\t}\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10,mo=1e9+7;\nint f[N],nex[N],n;\nchar s[N];\nvoid move(int &a,int b){a=(a+b)%mo;}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tnex[n]=nex[n-1]=n+1;\n\tfor (int i=n-2;~i;i--){\n\t\tnex[i]=nex[i+1];\n\t\tif (s[i+1]==s[i+2])nex[i]=i+2;\n\t}\n\tif (nex[0]==n+1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tf[0]=1;\n\tfor (int i=0;i<n;i++)\n\t\tmove(f[i+1],f[i]),\n\t\tmove(f[nex[i]],f[i]);\n\tint cnt=0,ans=0,tag=0;\n\tfor (int i=n;i>=1;i--){\n\t\tmove(ans,(cnt%3==0)*f[i]),\n\t\tcnt+=(s[i]=='a')-(s[i]=='b');\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000005\n#define Mod 1000000007\nusing namespace std;\nchar s[N];int sum[N],last[N],dp[N],nxt[N][3];\ninline int gt(char ch){if(ch=='a')return 1;return 2;}\nint main(){\n\tscanf(\"%s\",s+1);int n=strlen(s+1);\n\tbool flag=1;\n\tfor (int i=1;i<=n;i++){\n\t\tif (s[i]==s[i-1]) flag=0;\n\t\tsum[i]=sum[i-1]+gt(s[i]);\n\t\tsum[i]%=3;\n\t}\n\tif (flag) return puts(\"1\"),0;\n\tfor (int i=0;i<3;i++) last[i]=n+1;\n\tfor (int i=n;~i;i--){\n\t\tfor (int j=0;j<3;j++) nxt[i][j]=last[j];\n\t\tlast[sum[i]]=i;\n\t}\n\tint ans=0;dp[0]=1;\n\tfor (int i=0;i<=n;i++){\n\t\tfor (int j=1;j<=2;j++)\n\t\t\tif (nxt[i][(sum[i]+j)%3]<=n) dp[nxt[i][(sum[i]+j)%3]]=1ll*(dp[nxt[i][(sum[i]+j)%3]]+dp[i])%Mod;\n\t\tif (i&&sum[i]==sum[n]) ans=1ll*(ans+dp[i])%Mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nmodint dp[1 << 17];\n\nint col[1 << 17];\nvoid solve() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\trep(i, n) {\n\t\tcol[i + 1] = col[i];\n\t\tif (s[i] == 'a')col[i + 1]--;\n\t\telse col[i + 1]++;\n\t\tcol[i + 1] = (col[i + 1] % 3 + 3) % 3;\n\t}\n\n\n\tvector<int> nex(n);\n\tint las = n;\n\tper(i, n) {\n\t\tif (i + 1 < n && s[i] == s[i + 1])las = i;\n\t\tnex[i] = las;\n\t}\n\n\tmodint ans = 0;\n\tdp[0] = 1;\n\trep(i, n) {\n\t\tif (nex[i] < n && col[n] != col[i]) {\n\t\t\tans += dp[i];\n\t\t}\n\t\tdp[i + 1] += dp[i];\n\t\tif (nex[i] + 2 < n) {\n\t\t\tdp[nex[i] + 2] += dp[i];\n\t\t}\n\t}\n\tans += dp[n];\n\tper(i, n - 1)if (s[i] == s[i + 1]) {\n\t\tfor (int j = i + 3; j < n; j++) {\n\t\t\tif (col[j] != col[i]) {\n\t\t\t\tans += dp[i];\n\t\t\t}\n\t\t}\n\t\t break;\n\t}\n\tcout << ans << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    bool dame=1;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n        if(i<n-1 && s[i]==s[i+1]) dame=0;\n    }\n    if(dame){\n        cout<<1<<endl; return 0;\n    }\n    int nx[100010];\n    int p[3];\n    for(int j=0; j<3; j++) p[j]=n+1;\n    p[c[n]]=n;\n    for(int i=n-1; i>=0; i--){\n        p[c[i]]=i;\n        if(s[i]=='a') nx[i]=p[(c[i]+2)%3];\n        else nx[i]=p[(c[i]+1)%3];\n    }\n    int dp[100010]={};\n    dp[0]=1;\n    int ans=0;\n    for(int i=0; i<n; i++){\n        (dp[i+1]+=dp[i])%=MOD;\n        (dp[nx[i]]+=dp[i])%=MOD;\n        int x=(c[n]-c[i+1]+3)%3;\n        if(x==0) (ans+=dp[i+1])%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\n\nll n;\nll t[100005];\nll u[100005];\n\nll dp[100005];\nstring s;\n\nll eq[100005];\n\nll find0[100005];\nll find1[100005];\nll find2[100005];\n\nint main(){\n  cin>>s;\n  n=s.size();\n  \n  for(int i=1;i<=n;i++){\n    t[i]=(s[i]=='a'?1:2);\n  }\n\n  for(int i=1;i<=n;i++){\n    u[i]=u[i-1]+t[i];\n    u[i]%=3;\n  }\n  \n  for(int i=n;i>=1;i--){\n    find0[i]=find0[i+1];\n    find1[i]=find1[i+1];\n    find2[i]=find2[i+1];\n    \n    if(u[i]==0)find0[i]=i;\n    if(u[i]==1)find1[i]=i;\n    if(u[i]==2)find2[i]=i;\n  }\n  \n  for(int i=n;i>=2;i--){\n    if( s[i-1]==s[i] ){\n      eq[i]=i;\n    }else{\n      eq[i]=eq[i+1];\n    }\n  }\n\n  ll ans=0,tmp;\n  \n  dp[n+1]=1;\n  for(int i=n;i>=1;i--){\n    dp[i]=1;\n    if(eq[i]==0){\n      continue;\n    }\n\n\n    if( u[i-1] == 0 ) tmp = find1[i];\n    if( u[i-1] == 1 ) tmp = find2[i];\n    if( u[i-1] == 2 ) tmp = find0[i];\n\n    if( i == tmp && eq[i+1] == 0 )tmp=0;\n    if( i < tmp ) tmp = max( tmp, eq[i+1] );\n    if( tmp != 0 ){\n      dp[i] += dp[ tmp + 1 ];\n      dp[i] %= mod;\n    }\n\n    \n    if( u[i-1] == 0 ) tmp = find2[i];\n    if( u[i-1] == 1 ) tmp = find0[i];\n    if( u[i-1] == 2 ) tmp = find1[i];\n\n    if( i == tmp && eq[i+1] == 0 )tmp=0;\n    if( i < tmp ) tmp = max( tmp, eq[i+1] );\n    if( tmp != 0 ){\n      dp[i] += dp[ tmp + 1 ];\n      dp[i] %= mod;\n    }\n    \n  }\n  cout<<dp[0]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1e5+10,mod=1e9+7;\ninline void add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nchar s[maxn];\nint Next[maxn][3],sum[maxn],dp[maxn];\nint main(){\n\tbool flag=1;\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1),ans=0;\n\tREP(i,2,n) flag&=(s[i]!=s[i-1]);\n\tif(flag){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tREP(i,1,n) sum[i]=(sum[i-1]+s[i]-'a'+1)%3;\n\tDREP(i,n,0){\n\t\tREP(j,0,2) Next[i][j]=Next[i+1][j];\n\t\tNext[i][sum[i]]=i;\n\t}\n\tdp[0]=1;\n\tREP(i,0,n){\n\t\tREP(j,1,2){\n\t\t\tint u=Next[i][(sum[i]+j)%3];\n\t\t\tif(u) add(dp[u],dp[i]);\n\t\t}\n\t\tif(i && sum[i]==sum[n]) add(ans,dp[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nconst int MOD=1e9+7;\nint add (int x,int y)   {x=x+y;return x>=MOD?x-MOD:x;}\nint mul (int x,int y)   {return (LL)x*y%MOD;}\nint dec (int x,int y)   {x=x-y;return x<0?x+MOD:x;}\nint Pow (int x,int y)\n{\n\tif (y==0) return 1;\n\tif (y==1) return x;\n\tint lalal=Pow(x,y>>1);\n\tlalal=mul(lalal,lalal);\n\tif (y&1) lalal=mul(lalal,x);\n\treturn lalal;\n}\nchar ss[N];\nint f[N];\nint pos[N];\nint pre[N][3];\nint sum[N];\nint suf[N][3];\nint main()\n{\n\tscanf(\"%s\",ss+1);int n=strlen(ss+1);\n\tfor (int u=1;u<=n;u++) sum[u]=(sum[u-1]+ss[u]-'a'+1)%3;\n\tpre[0][1]=pre[0][2]=1;pre[0][0]=-1;\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tpre[u][0]=pre[u-1][0];\n\t\tpre[u][1]=pre[u-1][1];\n\t\tpre[u][2]=pre[u-1][2];\n\t\tpre[u][sum[u-1]]=u-1;\n\t}\n\tf[0]=1;\n\tfor(int u=1;u<=n;u++) \n\t{\n\t\tpos[u]=pos[u-1];\n\t\tif(ss[u]==ss[u-1]) pos[u]=u;\n\t}\n\tif (pos[n]==0)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tf[0]=1;\n\tfor(int u=1;u<=n;u++) \n\t{\n\t\tint id=pos[u]-1;\n\t\tf[u]=f[u-1];\n\t\tint val=(ss[u]=='a')?2:1;\n\t\tif(~id) \n\t\t{\n\t\t\n\t\t\tid=pre[id][(sum[u]-val+3)%3];\n\t\t\t\t//printf(\"YES!:%d\\n\",id);\n\t\t\tif(~id) f[u]=add(f[u],f[id]);\n\t\t}\n\t\tif(sum[u]==0&&u!=n) f[u]=add(f[u],1);\n\t\t\n\t\t//printf(\"%d %d %d\\n\",u,f[u],sum[u]);\n\t}\n\tprintf(\"%d\\n\",f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nstring s;\nmi dp[MX];\nint nex[MX];\n\nbool bad(string s) {\n    F0R(i,sz(s)-1) if (s[i] == s[i+1]) return 0;\n    return 1;\n}\n\nint main() {\n    setIO(); re(s);\n    if (bad(s)) {\n        ps(1);\n        exit(0);\n    }\n    nex[sz(s)+1] = MOD;\n    for (int i = sz(s); i >= 2; --i) {\n        if (s[i-1] == s[i-2]) nex[i] = i;\n        else nex[i] = nex[i+1];\n    }\n    dp[0] = 1;\n    mi ans = 0;\n    int sum = 0, tot = 0;\n    trav(c,s) {\n        if (c == 'a') tot += 1;\n        else tot += 2;\n    }\n    F0R(i,sz(s)+1) {\n        if ((sum-tot)%3 == 0 && i) {\n            // ps(i,dp[i]);\n            ans += dp[i];\n        }\n        if (i < sz(s)) {\n            if (s[i] == 'a') sum += 1;\n            else sum += 2;\n            dp[i+1] += dp[i];\n            if (nex[i+2] != MOD) dp[nex[i+2]] += dp[i];\n        }\n    }\n    ps(ans);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\nconstexpr int MOD = 1e9 + 7;\nchar str[100005];\nint nxt[100005][3], dp[100005], sum[100005];\nint main()\n{\n\t// freopen(\"AGC027-E.in\", \"r\", stdin);\n\tscanf(\"%s\", str);\n\tint n = strlen(str), ans = 0;\n\tbool flg = true;\n\tfor (int i = 1; i < n; i++)\n\t\tflg &= str[i] != str[i - 1];\n\tif (flg)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsum[i] = ((i ? sum[i - 1] : 0) + (str[i] - 'a' + 1)) % 3;\n\tnxt[n][0] = nxt[n][1] = nxt[n][2] = n;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tmemcpy(nxt[i], nxt[i + 1], sizeof(nxt[i + 1]));\n\t\tnxt[i][sum[i]] = i;\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x = i ? sum[i - 1] : 0;\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (j == x)\n\t\t\t\tcontinue;\n\t\t\tint y = nxt[i][j];\n\t\t\tif (y < n)\n\t\t\t\t(dp[y + 1] += dp[i]) %= MOD;\n\t\t}\n\t\tif (sum[i] == sum[n - 1])\n\t\t\t(ans += dp[i + 1]) %= MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int N = 3e5;\nchar st[N];\nint F[N], nxt[N];\nint su, ans, n;\nvoid ADD(int &t, int d)\n{\n    t += d;\n    if (t >= MOD) t -= MOD;\n}\nint main()\n{\n    scanf(\"%s\", st + 1);\n    n = strlen(st + 1);\n    for (int i = 1, j = 1; i <= n; ++ i)\n    {\n        j = max(j, i);\n        while (j < n && st[j + 1] != st[j])\n            j ++;\n        for (int k = i; k <= j; ++ k) nxt[k] = j;\n        i = j;\n    }\n    if (nxt[1] == n)\n    {\n        printf(\"%d\\n\", 1);\n        return 0;\n    }\n    F[0] = 1;\n    for (int i = 1; i <= n; ++ i)\n    {\n        ADD(F[i], F[i - 1]);\n        ADD(F[nxt[i] + 1], F[i - 1]);\n    }\n    for (int i = n, su = 0; i >= 1; -- i)\n    {\n        if (su % 3 == 0) ADD(ans, F[i]);\n        su += st[i] - 'a' + 1;\n    }\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define lf ('\\n')\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 100007 , mo = 1000000007;\n\nint n,val[_],las[3]={0,-1,-1};\nlint f[_]={0};\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\t\n\tn=ts(val+1);\n\tfor(int i=1;i<=n;i++)val[i]-='a'-1;\n\t\n\tint able=0;\n\tfor(int i=1;i<n;i++)if(val[i]==val[i+1])able=1;\n\tif(!able){cout<<1<<lf;return 0;}\n\n\tf[0]=1;\n\tfor(int i=1,now=0;i<=n;i++)\n\t{\n\t\tnow=(now+val[i])%3;\n\t\tif(now==0 && i<n)f[i]=1;\n\t\tnow=(now+1)%3;if(las[now]>=0)f[i]=(f[i]+f[las[now]])%mo;\n\t\tnow=(now+1)%3;if(las[now]>=0)f[i]=(f[i]+f[las[now]])%mo;\n\t\tnow=(now+1)%3,las[now]=i;\n\t}\n\tcout<<f[n]<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int zzy = 998244353;\nchar s[100010];\nint flag;\nint n;\nint nxt[100010][3], dp[100010], sum[100010];\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    for (int i = 2; i <= n; i++) if(s[i] == s[i - 1]) flag = 1;\n    if (!flag) return puts(\"1\"), 0;\n    for (int i = 1; i <= n; i++) sum[i] = (sum[i - 1] + (s[i] == 'a' ? 1 : 2)) % 3;\n    memset(nxt[n + 1], -1, sizeof nxt[n + 1]);\n    for (int i = n; i >= 0; i--) {\n        memcpy(nxt[i], nxt[i + 1], sizeof nxt[i]);\n        if (i) nxt[i][sum[i]] = i;\n    }\n    dp[0] = 1;\n    for (int i = 0; i < n; i++) {\n        if (sum[i] != 0 && ~nxt[i][0]) dp[nxt[i][0]] = (dp[nxt[i][0]] + dp[i]) % zzy;\n        if (sum[i] != 1 && ~nxt[i][1]) dp[nxt[i][1]] = (dp[nxt[i][1]] + dp[i]) % zzy;\n        if (sum[i] != 2 && ~nxt[i][2]) dp[nxt[i][2]] = (dp[nxt[i][2]] + dp[i]) % zzy;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        if (sum[i] == sum[n]) ans = (ans + dp[i]) % zzy;\n    }\n    return cout << ans << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int zzy = 1000000007;\nchar s[100010];\nint flag;\nint n;\nint nxt[100010][3], dp[100010], sum[100010];\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    for (int i = 2; i <= n; i++) if(s[i] == s[i - 1]) flag = 1;\n    if (!flag) return puts(\"1\"), 0;\n    for (int i = 1; i <= n; i++) sum[i] = (sum[i - 1] + (s[i] == 'a' ? 1 : 2)) % 3;\n    memset(nxt[n + 1], -1, sizeof nxt[n + 1]);\n    for (int i = n; i >= 0; i--) {\n        memcpy(nxt[i], nxt[i + 1], sizeof nxt[i]);\n        if (i) nxt[i][sum[i]] = i;\n    }\n    dp[0] = 1;\n    for (int i = 0; i < n; i++) {\n        if (sum[i] != 0 && ~nxt[i][0]) dp[nxt[i][0]] = (dp[nxt[i][0]] + dp[i]) % zzy;\n        if (sum[i] != 1 && ~nxt[i][1]) dp[nxt[i][1]] = (dp[nxt[i][1]] + dp[i]) % zzy;\n        if (sum[i] != 2 && ~nxt[i][2]) dp[nxt[i][2]] = (dp[nxt[i][2]] + dp[i]) % zzy;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        if (sum[i] == sum[n]) ans = (ans + dp[i]) % zzy;\n    }\n    return cout << ans << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define FoR(i,x,y,z) for(int i=(x);i<=(y);i+=(z))\n#define RoF(i,x,y,z) for(int i=(x);i>=(y);i-=(z))\n#define Edge(x) for(int i=head[x],to=e[i].v;i;i=e[i].nxt,to=e[i].v)\ntypedef long long ll;\nconst int N=100005;\nconst int mod=1e9+7;\nusing namespace std;\nchar s[N];\nint pre[N],f[N],pos[3],hve[N];\nvoid add(int &x,int y){ x+y>=mod?x=x+y-mod:x=x+y; }\nint main(){\n\tscanf(\"%s\",s+1); int n=strlen(s+1);\n\tFor(i,1,n){\n\t\tpre[i]=(pre[i-1]+s[i]-'a'+1)%3;\n\t\tif(i!=n) hve[i]=(s[i]==s[i+1]);\n\t}\n\tFor(i,1,n) hve[i]+=hve[i-1];\n\tif(!hve[n]) return puts(\"1\"),0;\n\tf[0]=1;pos[0]=0,pos[1]=pos[2]=-1;\n\tFor(i,1,n){\n\t\tif(!pre[i] && i!=n) add(f[i],1);\n\t\tadd(f[i],f[i-1]);\n\t\tint fr=pos[(pre[i]+s[i]-'a'+1)%3];\n\t\tif(~fr && hve[i]-hve[fr]) add(f[i],f[fr]);\n\t\tpos[pre[i]]=i;\t\t\n\t}\n\tprintf(\"%d\\n\",f[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e5 + 100,mod = 1e9 + 7;\nint n,sum; char s[N];\nint nex[N][2],f[N];\nint main()\n{\n\tscanf(\"%s\",s + 1); n = strlen(s + 1);\n\tint flag = 1; for(int i = 1;i < n;i ++) if(s[i] == s[i + 1]) flag = 0;\n\tif(flag) {puts(\"1\"); return 0;}\n\tsum = 0; f[n + 1] = 1; nex[n + 1][0] = nex[n + 1][1] = nex[n + 2][0] = nex[n + 2][1] = n + 2;\n\tfor(int i = n;i >= 1;i --)  \n\t{\n\t\tsum = (sum + s[i] - 'a' + 1) % 3;\n\t\tnex[i][0] = s[i] == 'a' ? i + 1 : s[i + 1] == 'b' ? i + 2 : nex[i + 2][0];\n\t\tnex[i][1] = s[i] == 'b' ? i + 1 : s[i + 1] == 'a' ? i + 2 : nex[i + 2][1];\n\t\tf[i] = ((sum == 0) + f[nex[i][0]] + f[nex[i][1]] ) % mod;\n \t}\n \tcout << (f[1] - (sum == 0) + mod) % mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint change_time = 0;\nchar maked_word[1000][100001] = {{'\\0'}};\nint temp = 0;\n\nchar* change(int t,char *s,char sw)\n{\n\tchar ret[100001];\n\tfor(int i =0;i<t;i++)\n\t{\n\t\tret[i] = s[i];\n\t}\n\tret[t] = sw;\n\tfor(int i=t+1;s[i+1] != '\\0';i++)\n\t{\n\t\tret[i] = s[i+1];\n\t}\n\n\treturn ret;\n}\n\n\nvoid saiki(char *s)\n{\n\t//printf(\"%s\\n\",s);\n\tstrcpy(maked_word[change_time],s);\n\tfor(int i =0;i<change_time;i++)\n\t{\n\t\tif(strcmp(maked_word[i],s) == 0)\n\t\t{\n\t\t\tchange_time -=1;\n\t\t}\n\t}\n\tchange_time++;\n\tint num=0;\n\tfor(int i=0;s[i] != '\\0';i++)\n\t{\n\t\tnum++;\n\t}\n\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tif(s[i] == 'a' && s[i+1] == 'a')\n\t\t{\n\t\t\tchar *ss = change(i,s,'b');\n\t\t\tsaiki(ss);\n\t\t}\n\t\tif(s[i] == 'b' && s[i+1] == 'b')\n\t\t{\n\t\t\tchar *ss =change(i,s,'a');\n\t\t\tsaiki(ss);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tchar s[100001];\n\tscanf(\"%s\",s);\n\tsaiki(s);\n\tprintf(\"%d\\n\",change_time);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nconst int N=100005,P=1e9+7;\nint n,f[N],nxt[N][2];char s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool flg=0;\n\trep(i,1,n-1)if(s[i]==s[i+1])flg=1;\n\tif(!flg)puts(\"1\"),exit(0); \n\tf[n+1]=1;\n\tnxt[n+1][0]=nxt[n+1][1]=nxt[n+2][0]=nxt[n+2][1]=n+2;\n\tint sum=0;\n\tper(i,n,1){\n\t\t(sum+=s[i]-'a'+1)%=3;\n\t\tnxt[i][0]=(s[i]=='a'?i+1:s[i+1]=='b'?i+2:nxt[i+2][0]);\n\t\tnxt[i][1]=(s[i]=='b'?i+1:s[i+1]=='a'?i+2:nxt[i+2][1]);\n\t\tf[i]=(f[nxt[i][0]]+f[nxt[i][1]]+(sum==0))%P;\n\t}\n\tprintf(\"%d\\n\",(f[1]-(sum==0)+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<cstring> \nconst int maxn = 100007; \nchar t[maxn]; \nint n,s[maxn]; \nint f[maxn]; \nconst int mod = 1e9 + 7; \nint main() { \n\tscanf(\"%s\",t + 1); \n\tn = strlen(t + 1); \n\tbool flag = 0; \n\tfor(int i = 2;i <= n;++ i) if(t[i] == t[i - 1])flag = 1; \n\tif(!flag) return !printf(\"1\"); \n\tint now = 0,pre[3] = {0,-1,-1}; f[0] = 1; \n\tfor(int i = 1;i <= n;++ i) { \n\t\tnow = (now + 2 - (t[i] == 'a')) % 3; \n\t\tif(!now && i < n) f[i] = 1; ++ now,now %= 3; \n\t\tif(pre[now] != - 1) (f[i] += f[pre[now]]) %= mod;  ++ now,now %= 3; \n\t\tif(pre[now] != -1) (f[i] += f[pre[now]]) %= mod; ++ now,now %= 3; \n\t\tpre[now] = i; \n\t} \n\tprintf(\"%d\",f[n]); \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MOD = 1000000007;\n\nint n;\nchar s[MAXN];\nint dp[MAXN], ps[3];\nbool hv[3];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nint add ( int x, int y )\n{\n\treturn ( ( x += y ) < MOD ) ? x : ( x - MOD );\n}\n\nvoid addv ( int &x, int y )\n{\n\t( ( x += y ) < MOD ) ? x : ( x -= MOD );\n}\n\nint sub ( int x, int y )\n{\n\treturn ( ( x -= y ) >= 0 ) ? x : ( x + MOD );\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%s\", s+1 );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tn = strlen ( s + 1 );\n\tint np = 0;\n\tdp[0] = ps[0] = 1;\n\tlpi ( i, 1, n ){\n\t\t( np += s[i] - 'a' + 1 ) %= 3;\n\t\tdp[i] = sub ( add ( add ( ps[0], ps[1] ), ps[2] ), ps[np] );\n\t\tif ( np && hv[0] ) addv ( dp[i], 1 );\n//\t\tcerr << i << \" : \" << dp[i] << endl;\n\t\tps[np] = dp[i];\n\t\thv[np] = true;\n\t}\n\tif ( !hv[1] || !hv[2] ) cout << 1 << endl;\n\telse cout << dp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <string>\n#include <set>\n#include <map>\n#define SIZE 100005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar str[SIZE];\nint ta[SIZE],tb[SIZE];\nll dp[SIZE];\nbool oka[SIZE];\nbool okb[SIZE];\n\nint main()\n{\n\tscanf(\"%s\",&str);\n\tint n=strlen(str);\n\tta[n]=tb[n]=-1;\n\toka[n]=okb[n]=true;\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tif(str[i]=='a')\n\t\t{\n\t\t\tta[i]=i+1;\n\t\t\ttb[i]=ta[i+1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tta[i]=tb[i+1];\n\t\t\ttb[i]=i+1;\n\t\t}\n\t\toka[i]=okb[i]=false;\n\t\tif(ta[i]!=-1&&tb[ta[i]]!=-1) oka[i]=oka[tb[ta[i]]];\n\t\tif(tb[i]!=-1&&ta[tb[i]]!=-1) okb[i]=okb[ta[tb[i]]];\n\t\t//printf(\"%d %d\\n\",oka[i],okb[i]);\n\t}\n\tdp[0]=1;\n\tll ret=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\t//printf(\"%lld\\n\",dp[i]);\n\t\tif(ta[i]!=-1)\n\t\t{\n\t\t\tif(oka[ta[i]]||okb[ta[i]])\n\t\t\t{\n\t\t\t\tret+=dp[i];\n\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t}\n\t\t\tdp[ta[i]]+=dp[i];\n\t\t\tif(dp[ta[i]]>=MOD) dp[ta[i]]-=MOD;\n\t\t}\n\t\tif(tb[i]!=-1)\n\t\t{\n\t\t\tif(okb[tb[i]]||oka[tb[i]])\n\t\t\t{\n\t\t\t\tret+=dp[i];\n\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t}\n\t\t\tdp[tb[i]]+=dp[i];\n\t\t\tif(dp[tb[i]]>=MOD) dp[tb[i]]-=MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Author -- Frame\n\n#include<bits/stdc++.h>\n\n#define lowbit(x) ((x)&(-(x)))\n#define Finline __inline__ __attribute__ ((always_inline))\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n#define SZ(x) ((int)x.size())\n#define mkpr std::make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> pi;\ntypedef std::pair<ll,ll> pl;\nusing std::min;\nusing std::max;\n\nconst int inf=0x3f3f3f3f,Inf=0x7fffffff;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\n\nFinline uint rnd(){static uint seed=416;return seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;}\ntemplate <typename _Tp>_Tp gcd(const _Tp &a,const _Tp &b){return (!b)?a:gcd(b,a%b);}\ntemplate <typename _Tp>Finline _Tp abs(const _Tp &a){return a>=0?a:-a;}\ntemplate <typename _Tp>Finline void chmax(_Tp &a,const _Tp &b){(a<b)&&(a=b);}\ntemplate <typename _Tp>Finline void chmin(_Tp &a,const _Tp &b){(b<a)&&(a=b);}\ntemplate <typename _Tp>Finline void read(_Tp &x)\n{\n\tchar ch(getchar());bool f(false);while(!isdigit(ch)) f|=ch==45,ch=getchar();\n\tx=ch&15,ch=getchar();while(isdigit(ch)) x=(((x<<2)+x)<<1)+(ch&15),ch=getchar();\n\tf&&(x=-x);\n}\ntemplate <typename _Tp,typename... Args>Finline void read(_Tp &t,Args &...args){read(t);read(args...);}\ntemplate <typename _Tp,typename... Args>Finline _Tp min(const _Tp &a,const _Tp &b,const Args &...args){return a<b?min(a,args...):min(b,args...);}\ntemplate <typename _Tp,typename... Args>Finline _Tp max(const _Tp &a,const _Tp &b,const Args &...args){return a<b?max(b,args...):max(a,args...);}\nFinline int read_str(char *s)\n{\n\tchar ch(getchar());while(ch==' '||ch=='\\r'||ch=='\\n') ch=getchar();\n\tchar *tar=s;*tar=ch,ch=getchar();while(ch!=' '&&ch!='\\r'&&ch!='\\n'&&ch!=EOF) *(++tar)=ch,ch=getchar();\n\treturn tar-s+1;\n}\n\nconst int N=100005;\nconst int mod=1000000007;\ntemplate<typename _Tp1,typename _Tp2>Finline void add(_Tp1 &a,_Tp2 b){(a+=b)>=mod&&(a-=mod);}\ntemplate<typename _Tp1,typename _Tp2>Finline void sub(_Tp1 &a,_Tp2 b){(a-=b)<0&&(a+=mod);}\nchar s[N];\nint dp[N],sum[N];\nint pos[3];\nint main()\n{\n\tint n=read_str(s+1);\n\tbool flag=true;for(int i=1;i<n;++i) flag&=s[i]!=s[i+1];\n\tif(flag) return puts(\"1\"),0;\n\tfor(int i=1;i<=n;++i) sum[i]=sum[i-1]+(s[i]=='a'?1:2),sum[i]%=3;\n\tdp[n+1]=1,pos[sum[n]]=n+1;\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tint qwq=sum[i-1];\n\t\tdp[i]=dp[i+1]+((sum[n]-sum[i-1])==0);\n\t\tfor(int j=1;j<=2;++j)\n\t\t{\n\t\t\tint to=(qwq+j)%3;\n\t\t\tif(pos[to]>i+1) add(dp[i],dp[pos[to]]);\n\t\t}\n\t\tpos[qwq]=i;\n\t}\n\tint ans=dp[1];sub(ans,sum[n]==0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int MOD=1e9+7;\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint nxt[111111];\nint dp[111111][2];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring s; cin>>s; int n=s.length(); \n\tbool pos=1;\n\tfor(int i=0;i+1<n;i++)\n\t{\n\t\tif(s[i]==s[i+1]) pos=0;\n\t}\n\tif(pos) {cout<<1<<'\\n'; return 0;}\n\ts=\"$\"+s;\n\tnxt[n]=-1;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tnxt[i]=-1;\n\t\tif(s[i+1]==s[i]) {nxt[i]=i+1; continue;}\n\t\tnxt[i]=nxt[i+1];\n\t}\n\tnxt[0]=nxt[1];\n\tdp[0][0]=1; \n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint v=add(dp[i][0],dp[i][1]);\n\t\tdp[i+1][s[i+1]-'a']=add(dp[i+1][s[i+1]-'a'],v);\n\t\tif(nxt[i+1]>0) dp[nxt[i+1]][(s[i+1]-'a')^1]=add(dp[nxt[i+1]][(s[i+1]-'a')^1],v);\n\t}\t\n\tint ans=0; int sum=0;\n\tfor(int i=n;i>=1;i--)\n\t{\t\t\n\t\tif(sum==0) ans=add(ans,add(dp[i][0],dp[i][1]));\n\t\tsum+=(s[i]=='a'?1:2); sum%=3;\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for (int i = j; i <= k; i++)\n#define Forr(i, j, k) for (int i = j; i >= k; i--)\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int Mod = 1e9 + 7;\n\nchar S[N];\nint a[N], n;\nint nxt[N][3], dp[N];\n\nint main() {\n\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1);\n\tFor(i, 1, n) a[i] = S[i] - 'a' + 1;\n\n\tbool flag = true;\n\tFor(i, 2, n) flag &= a[i] != a[i - 1];\n\tif (flag) { puts(\"1\"); return 0; }\n\tFor(i, 1, n) a[i] = (a[i - 1] + a[i]) % 3;\n\n\tFor(j, 0, 2) nxt[n + 1][j] = n + 1;\n\tForr(i, n, 1) For(j, 0, 2) nxt[i][j] = a[i] == j ? i : nxt[i + 1][j];\n\n\tint ans = 0;\n\tdp[0] = 1;\n\tFor(i, 0, n) {\n\t\tFor(j, 1, 2) {\n\t\t\tint p = nxt[i + 1][(a[i] + j) % 3];\n\t\t\tif (p <= n) dp[p] = (dp[p] + dp[i]) % Mod;\n\t\t}\n\t\tif (i > 0 && a[i] == a[n]) ans = (ans + dp[i]) % Mod;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=1e5+10;\nconst int mod=1e9+7;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nchar s[N];\nint n,f[N],sum[N],nxt[N][3],ans=0;\nint main() {\n    scanf(\"%s\",s+1),n=strlen(s+1);\n    int fl=1;\n    for(int i=2;i<=n;i++) fl&=(s[i]!=s[i-1]);\n    if(fl) return puts(\"1\"),0;\n    for(int i=1;i<=n;i++) sum[i]=(sum[i-1]+(s[i]=='a')+1)%3;\n    for(int i=0;i<3;i++) nxt[n+1][i]=n+1;\n    for(int i=n;i;i--) {\n        for(int j=0;j<3;j++) nxt[i][j]=nxt[i+1][j];\n        nxt[i][sum[i]]=i;\n    }\n    f[0]=1;\n    for(int i=0;i<=n;i++) {\n        for(int j=1;j<3;j++)\n            if(nxt[i+1][(sum[i]+j)%3]<=n) inc(f[nxt[i+1][(sum[i]+j)%3]],f[i]);\n        if(i&&sum[i]==sum[n]) inc(ans,f[i]);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int MOD=1e9+7;\nchar s[1000001];\nint nxt[1000001];\nint dp[1000001];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);s[n+1]=s[n];\n\tfor(int i=1,j=2;j<=n+1;j++){\n\t\tif(s[j-1]==s[j]){\n\t\t\twhile(i<j)nxt[i++]=j;\n\t\t}\n\t}\n\tif(nxt[1]>n)printf(\"1\");\n\telse{\n\t\tdp[0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t(dp[i+1]+=dp[i])%=MOD;\n\t\t\t(dp[nxt[i+1]]+=dp[i])%=MOD;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=n,j=0;i>0;i--){\n\t\t\tif(j%3==0)ans=(ans+dp[i])%MOD;\n\t\t\tj+=s[i]=='a'?1:2;\n\t\t}\n\t\tprintf(\"%d\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nchar s[100005];\nint f[100005],nxt[100005][3],v[100005],db[100005];\ninline void add(int &x,int y){\n\tx+=y;\n\tif(x>=mod)x-=mod;\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tint l=strlen(s+1);\n\tfor(int i=1;i<=l;i++)v[i]=(v[i-1]+s[i]-'a'+1)%3;\n\tfor(int i=l;i>=1;i--){\n\t\tfor(int j=0;j<3;j++)nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][v[i]]=i;\n\t\tdb[i]=s[i]==s[i+1]?i+1:db[i+1];\n\t}\n\tif(!db[1]){puts(\"1\"); return 0;}\n\tf[0]=1;\n\tfor(int i=0;i<l;i++){\n\t\tfor(int j=1;j<=2;j++){\n\t\t\tif(s[i+1]-'a'+1==j)add(f[i+1],f[i]);\n\t\t\telse if(db[i+1]&&nxt[db[i+1]][(v[i]+j)%3])add(f[nxt[db[i+1]][(v[i]+j)%3]],f[i]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=l;i++)if(v[i]==v[l])add(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define N 100010\nusing namespace std;\nstring s;\nint n,a[N],ne[N][4],dp[N],ans;\nvoid add(int &x,int y){x+=y;if (x>=mo)x-=mo;}\nint main(){\n\tcin>>s;n=s.length();\n\tfor (int i=1;i<=n;i++)a[i]=(a[i-1]+s[i-1]-'a'+1)%3;\n\tne[n+1][0]=ne[n+1][1]=ne[n+1][2]=ne[n+1][3]=n+1;\n\tfor (int i=n;i>=1;i--){\n\t\tfor (int j=0;j<=3;j++)ne[i][j]=ne[i+1][j];ne[i][a[i]]=i;\n\t\tif (i!=1&&s[i-1]==s[i-2])ne[i][3]=i;\n\t}\n\tif (ne[1][3]==n+1){puts(\"1\");return 0;}\n\tdp[0]=1;\n\tfor (int i=0;i<n;i++){\n\t\tadd(dp[i+1],dp[i]);\n\t\tadd(dp[ne[ne[i+2][3]][(a[i]+(3-s[i]+'a'-1))%3]],dp[i]);\n\t}\n\tfor (int i=1;i<=n;i++)if (a[i]==a[n])add(ans,dp[i]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nconst int N=1e5+5,Mo=1e9+7;\n\nint n,sum[N],f[N],nxt[N][3];\nchar s[N];\n\nvoid inc(int &x,int y) {x=x+y>=Mo?x+y-Mo:x+y;}\n\nint main() {\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tbool ok=0;\n\tfo(i,1,n-1) if (s[i]==s[i+1]) {ok=1;break;}\n\tif (!ok) {puts(\"1\");return 0;}\n\tsum[0]=0;fo(i,1,n) sum[i]=(sum[i-1]+((s[i]=='a')?1:2))%3;\n\tfo(i,0,2) nxt[n][i]=n+1;\n\tfd(i,n-1,0) {\n\t\tfo(j,0,2) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][sum[i+1]]=i+1;\n\t}\n\tf[0]=1;int ans=0;\n\tfo(i,0,n) {\n\t\tfo(j,1,2) inc(f[nxt[i][(sum[i]+j)%3]],f[i]);\n\t\tif (i&&sum[i]==sum[n]) inc(ans,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nchar in[110000];\nlong long dp[110000];\nvector<int>v[3];\nint sum[110000];\nint main(){\n\tscanf(\"%s\",in);\n\tint n=strlen(in);\n\tbool ok=true;\n\tfor(int i=1;i<n;i++){\n\t\tif(in[i]==in[i-1]){\n\t\t\tok=false;\n\t\t\tsum[i+1]++;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tsum[i+1]+=sum[i];\n\t\t// printf(\"%d %d\\n\",i,sum[i]);\n\t}\n\tif(ok){\n\t\tprintf(\"1\\n\");return 0;\n\t}\n\tint t=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(in[i]=='a')t++;\n\t\telse t+=2;\n\t\tv[t%3].push_back(i+1);\n\t}\n\n\tdp[0]=1;\n\tint now=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dp[i]==0)continue;\n\t\t// printf(\"%d: %lld\\n\",i,dp[i]);\n\t\tint left,right;\n\t\tleft=-1;\n\t\tright=v[(now+1)%3].size();\n\t\twhile(left+1<right){\n\t\t\tint M=(left+right)/2;\n\t\t\tint to=v[(now+1)%3][M];\n\t\t\tbool dame=false;\n\t\t\tif(to<=i)dame=true;\n\t\t\tif(to-i>1&&sum[to]-sum[i+1]==0)dame=true;\n\t\t\tif(dame){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tif(in[i]=='a'){\n\t\t\tdp[i+1]=(dp[i+1]+dp[i])%mod;\n\t\t}else if(right<v[(now+1)%3].size()){\n\t\t\tdp[v[(now+1)%3][right]]=(dp[v[(now+1)%3][right]]+dp[i])%mod;\n\t\t}\n\t\tleft=-1;\n\t\tright=v[(now+2)%3].size();\n\t\twhile(left+1<right){\n\t\t\tint M=(left+right)/2;\n\t\t\tint to=v[(now+2)%3][M];\n\t\t\tbool dame=false;\n\t\t\tif(to<=i)dame=true;\n\t\t\tif(to-i>1&&sum[to]-sum[i+1]==0)dame=true;\n\t\t\tif(dame){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tif(in[i]=='b'){\n\t\t\tdp[i+1]=(dp[i+1]+dp[i])%mod;\n\t\t}else if(right<v[(now+2)%3].size()){\n\t\t\tdp[v[(now+2)%3][right]]=(dp[v[(now+2)%3][right]]+dp[i])%mod;\n\t\t}\n\t\t// printf(\"%d\\n\",v[(now+2)%3][right]);\n\t\tif(in[i]=='a')now++;\n\t\telse now+=2;\n\t}\n\tint s=0;\n\tlong long ret=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(in[i-1]=='a')s++;\n\t\telse s+=2;\n\t\tif(t%3==s%3){\n\t\t\tret=(ret+dp[i])%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nchar s[maxn];\nint sum[maxn],f[maxn];\nint n;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tsum[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=(sum[i-1]+(s[i]=='a'?1:2))%3;\n\tint flag=0;\n\tfor(int i=1;i<n;i++)\n\t\tif(s[i]==s[i+1])flag=1;\n\tif(!flag){\n\t\tputs(\"1\"); return 0;\n\t}\n\tf[0]=1;\n\tint pos[3]={0,-1,-1};\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=(!sum[i])&&(i<n);\n\t\tif(~pos[(sum[i]+1)%3])f[i]=(f[i]+f[pos[(sum[i]+1)%3]])%mod;\n\t\tif(~pos[(sum[i]+2)%3])f[i]=(f[i]+f[pos[(sum[i]+2)%3]])%mod;\n\t\tpos[sum[i]]=i;\n\t\t// printf(\"%d %d %d : %d %d %d\\n\",i,sum[i],f[i],pos[0],pos[1],pos[2]);\n\t}\n\twriteln(f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nint n,nxt[100005];\nchar s[100005];\nll f[100005],ans;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=(int)strlen(s+1);\n\tnxt[n]=n+1;\n\tfor(int i=n;i>=1;i--)nxt[i-1]=s[i]==s[i+1]?i+1:nxt[i];\n\tf[0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tf[i]%=MOD;\n\t\tf[i+1]+=f[i];\n\t\tf[nxt[i]]+=f[i];\n\t}\n\tint now=0;\n\tbool flag=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tflag|=s[i]==s[i+1];\n\t\tif(now==0)ans+=f[i];\n\t\tnow=(now+s[i]-'a'+1)%3;\n\t}\n\tif(!flag)printf(\"1\\n\");\n\telse printf(\"%lld\\n\",ans%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100,mod=1e9+7;\nll nxt[N];\nll b[N][3];\nll d[N][3];\nll a[N];\nll dp[N];\nll par[N];\nint32_t main(){\n    string s;\n    cin >> s;\n    ll n=s.size();\n    for (int i=0;i<s.size();i++){\n        a[i+1]=s[i]-'a'+1;\n    }\n    nxt[n]=n+1;\n    for (int i=n-1;i;i--){\n        if (a[i+1]==a[i]) nxt[i]=i+1;\n        else nxt[i]=nxt[i+1];\n    }\n    b[n+1][0]=n+1;\n    b[n+1][1]=n+1;\n    b[n+1][2]=n+1;\n    b[n+2][0]=n+2;\n    b[n+2][1]=n+2;\n    b[n+2][2]=n+2;\n    d[n+1][0]=n+1;\n    d[n+1][1]=n+1;\n    d[n+1][2]=n+1;\n    d[n+2][0]=n+2;\n    d[n+2][1]=n+2;\n    d[n+2][2]=n+2;\n    for (int i=n;i;i--){\n        if (a[i]==1){\n            b[i][1]=i;\n            ll z=nxt[i];\n            z--;\n            ll y=(z-i+2)/2+((z-i+1)/2)*2;\n            y%=3;\n            if (y==2){\n                b[i][2]=d[z+1][0];\n            }\n            if (y==0){\n                b[i][2]=b[z+1][2];\n            }\n            if (y==1){\n                b[i][2]=b[z+1][1];\n            }\n        }\n        else if (a[i]==2){\n            b[i][2]=i;\n            ll z=nxt[i];\n            z--;\n            ll y=((z-i+2)/2)*2+(z-i+1)/2;\n            y%=3;\n            if (y==1){\n                b[i][1]=d[z+1][0];\n            }\n            if (y==0){\n                b[i][1]=b[z+1][1];\n            }\n            if (y==2){\n                b[i][1]=b[z+1][2];\n            }\n        }\n        for (int j=0;j<3;j++){\n            if (j==a[i]){\n                d[i][j]=i;\n                continue;\n            }\n            ll z=j+a[i];\n            z%=3;\n            d[i][j]=d[i+1][z];\n        }\n\n    }\n    for (int i=n;i;i--) par[i]=a[i]+par[i+1],par[i]%=3;\n    for (int i=n;i;i--){\n       // cout << i << \" \" << par[i] << \" \" << b[i][1] << \" \" << b[i][2] << endl;\n        if (par[i]) dp[i]++;\n        dp[i]+=dp[b[i][1]+1];\n        dp[i]+=dp[b[i][2]+1];\n        dp[i]%=mod;\n    }\n    cout << dp[1] << endl;\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nconst int N = 233333,mo=1e9+7;\nchar S[N];int n,f[N],s[N],qz[N],b[N],res,ok[N];vector<int> a[3];\nvoid add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\n\nint main(){\n\tscanf(\"%s\",S+1);n=strlen(S+1);rep(i,1,n)s[i]=S[i]-'a'+1;\n\trep(i,1,n)qz[i]=(qz[i-1]+s[i])%3,a[qz[i]].push_back(i);f[0]=1;\n\tfor(int i=n,j=n+1;i>=0;i--){if(s[i]==s[i+1])j=i+1;b[i]=j;}\n\trep(i,1,n)ok[i]=b[i]<=n&&(qz[n]-qz[i-1])%3;ok[n]=1;\n\tres=ok[1];\n\trep(i,0,n-1)rep(j,1,2){\n\t\tif(s[i+1]==j)add(f[i+1],f[i]),add(res,f[i]*(ok[i+2]||b[i+1]<n&&(qz[n-1]-qz[i])%3==j));\n\t\telse if(SZ(a[(qz[i]+j)%3])&&b[i+1]<=a[(qz[i]+j)%3].back()){//RE\n\t\t\tint k=*lower_bound(a[(qz[i]+j)%3].begin(),a[(qz[i]+j)%3].end(),b[i+1]);\n\t\t\tif(k<=n)add(f[k],f[i]),add(res,f[i]*(ok[k+1]|(qz[n-1]-qz[i])%3==j));\n\t\t}\n\t}\n//\trep(i,0,n)printf(\"%d:%d\\n\",i,f[i]);\n//\tint res=0;rep(i,0,n-1)if(b[i+1]<=n&&(qz[n]-qz[i])%3||i&&(qz[n-1]-qz[i])%3==0)add(res,f[i]);\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=100005;\nconst int mo=1000000007;\nint n,ans;\nchar s[N];\nint las[N],S[N];\nint suf[N][3],f[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool fl=0;\n\tFor(i,1,n-1) if (s[i]==s[i-1]) fl=1;\n\tif (!fl) return puts(\"1\"),0;\n\tFor(i,1,n) S[i]=(S[i-1]+s[i]-'a'+1)%3;\n\tFor(i,0,2) suf[n+1][i]=n+1;\n\tRep(i,n,1){\n\t\tFor(j,0,2)\n\t\t\tsuf[i][j]=suf[i+1][j];\n\t\tsuf[i][S[i]]=i;\n\t}\n\tf[0]=1;\n\tFor(i,1,n+1){\n\t\tif (S[i-1]==S[n]&&i!=1) ans=(ans+f[i-1])%mo;\n\t\tint nx=suf[i+1][3-S[i-1]-S[i]];\n\t\tf[i]=(f[i]+f[i-1])%mo;\n\t\tf[nx]=(f[nx]+f[i-1])%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n/*\nbabba\nbaaa\nbba\naa\nb\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,ln[100005],st[100005],ed[100005],cnt,sum[2][100005];\nvector < int > dp[100005][2];\nchar s[100005];\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n    cnt=1;\n    ln[0]=1;\n    st[0]=ed[0]=(s[0]-'a');\n\tfor(i=1;i<n;++i){\n    \tif(s[i]==s[i-1]){\n    \t\tln[cnt]=1;\n    \t\tst[cnt]=ed[cnt]=(s[i]-'a');\n    \t\t++cnt;\n    \t}\n    \telse{\n    \t\t++ln[cnt-1];\n    \t\ted[cnt-1]=(s[i]-'a');\n    \t}\n    }\n    // initialize for the first block\n    dp[0][0].resize(ln[0]+1,0);\n\tdp[0][1].resize(ln[0]+1,0);\n\tfor(i=1;i<=ln[0];++i){\n\t\tdp[0][(i&1)^(int)(s[0]-'a')][i]=1;\n\t}\n\tfor(i=0;i<2;++i){\n\t\tfor(j=1+(int)(s[0]==('a'+i));j<=ln[0]+1;j+=2){\n\t\t\tsum[i][j]=(j>=2?sum[i][j-2]:0)+dp[0][i][j];\n\t\t}\n\t}\n    for(i=1;i<cnt;++i){\n    \t// DP transfer\n\t\tdp[i][0].resize(ln[i]+1);\n\t\tdp[i][1].resize(ln[i]+1);\n\t\t// transfer from larger part\n\t\tfor(j=1;j<=ln[i];++j){\n\t\t\t// j: t\n\t\t\t// ln-j: length in current block\n\t\t\t// \n\t\t\tint cur=(LL)dp[i-1][s[st[i]]-'a'][]\n\t\t}\n    }\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=(s);i<(t);++i)\n#define per(i,s,t) for(int i=((t)-1);i>=s;--i)\n#define repb(i,s,t) for(int i=(s);i<=(t);++i)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)x.size())\n#define mst(a,b) memset(a,b,sizeof(a))\n#define mcpy(des,sor) memcpy(des,sor,sizeof(sor))\n#define dd(x) cout<<#x<<'='<<x<<' '\n#define de(x) cout<<#x<<'='<<x<<'\\n'\n#define fi first\n#define se second\n#define sq(x) ((x)*(x))\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef double db;\n\nconst int inf = 0x3f3f3f3f;\nconst ll mod = 1e9+7;\nconst db eps = 1e-8;\n\nchar io[1<<15],*is=io,*ie=io+1;\n#define rd if(++is==ie)ie=(is=io)+fread(io,1,sizeof(io),stdin)\ntemplate<class T>\ninline bool Cin(T &a){\n\ta=0;bool s=0;\n\tif(is==ie)return 0;\n\tdo{rd;if(*is=='-')s=1;}while(!isdigit(*is)&&is!=ie);\n\tif(is==ie)return 0;\n\tdo{(a*=10)+=*is&15;rd;}while(isdigit(*is)&&is!=ie);\n\tif(s)a=-a;;return 1;}\n\ninline int Gets(char a[]){\n\tint p=0;\n\tif(is==ie)return 0;\n\tdo rd; while(!isgraph(*is)&&is!=ie);\n\tif(is==ie)return 0;\n\tdo {a[p++]=*is;rd;}while(isgraph(*is)&&is!=ie);\n\ta[p]=0;return p;}\n\n#define maxn 100005\n\nchar s[maxn];\nint v[maxn],f[maxn];\n\nint main()\n{\n\tint n=Gets(s+1),o=0,pre[3];\n\trepb(i,1,n)\n\t{\n\t\tif(s[i]==s[i+1])o=i;\n\t\tv[i]=(v[i-1]+s[i]-'a'+1)%3;\n\t}\n\tif(!o)return !printf(\"1\\n\");\n\tf[0]=1;pre[0]=0;pre[1]=pre[2]=-1;\n\trepb(i,1,n)\n\t{\n\t\tif(v[i]==0&&i!=n)f[i]=1;\n\t\trepb(j,1,2)\n\t\t{\n\t\t\to=pre[(v[i]+3-j)%3];\n\t\t\tif(~o)(f[i]+=f[o])%=mod;\n\t\t}\n\t\tpre[v[i]]=i;\n\t}\n\tprintf(\"%d\\n\",f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e5+5,Mod=1e9+7;\nchar buf[1<<12],*p1=buf,*p2=buf,nc;int ny;\ninline char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}char s[MAXN];int n,nxt[2][MAXN],F[MAXN],Sum,flg;\nint main(){\n\tscanf(\"%s\",s+1),n=strlen(s+1),flg=1;\n\tRep(i,1,n)if(s[i]==s[i+1])flg=0;if(flg){puts(\"1\");return 0;}\n\tF[n+1]=1,nxt[0][n+1]=nxt[1][n+1]=nxt[0][n+2]=nxt[1][n+2]=n+2;\n\tRed(i,n,1){\n\t\t(Sum+=(s[i]-'a'+1))%=3;\n\t\tnxt[0][i]=s[i]=='a'?i+1:s[i+1]=='b'?i+2:nxt[0][i+2];\n\t\tnxt[1][i]=s[i]=='b'?i+1:s[i+1]=='a'?i+2:nxt[1][i+2];\n\t\tF[i]=(F[nxt[0][i]]+F[nxt[1][i]]+(Sum==0))%Mod;\n\t}cout<<(F[1]-(Sum==0))<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int mod = 1e9 + 7;\nint n, a[N], flag, f[N], last[5];\nchar s[N];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tfor(int i = 1; i <= n; i ++) if(s[i] == s[i - 1]) flag = 1;\n\tif(!flag) {puts(\"1\"); return 0;}\n\tfor(int i = 1; i <= n; i ++) a[i] = (a[i - 1] + s[i] - 'a' + 1) % 3;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tf[i] = ((f[last[0]] + f[last[1]] + f[last[2]] - f[last[a[i]]] + (a[i] >= 1)) % mod + mod) % mod;\n\t\tlast[a[i]] = i;\n\t}\n\tprintf(\"%d\\n\", f[n]);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n    }\n    int nx[2][100010];\n    int p[3][100010];\n    for(int j=0; j<3; j++) p[j][n]=n;\n    int mn[100010];\n    mn[n]=n+1;\n    for(int i=n-1; i>=0; i--){\n        for(int j=0; j<3; j++) p[j][i]=p[j][i+1];\n        p[c[i]][i]=i;\n        mn[i]=mn[i+1];\n        if(i<n-1 && s[i]==s[i+1]) mn[i]=i+2;\n        if(s[i]=='a'){\n            nx[0][i]=i+1;\n            if(mn[i]<=n) nx[1][i]=p[(c[i]+2)%3][mn[i]];\n            else nx[1][i]=n+1;\n        }else{\n            nx[1][i]=i+1;\n            if(mn[i]<=n) nx[0][i]=p[(c[i]+1)%3][mn[i]];\n            else nx[0][i]=n+1;\n        }\n    }\n    ll dp[2][100010]={};\n    dp[0][0]=1;\n    ll ans=0;\n    for(int i=0; i<n; i++){\n        //cout<<nx[0][i]<<\" \"<<nx[1][i]<<endl;\n        int x=(c[n]-c[i]+3)%3;\n      if(x!=0) (ans+=dp[1][i])%=MOD;\n      if(x!=0 && (i==n-1 || mn[i]<=n)) (ans+=dp[0][i])%=MOD;\n      else if(mn[i]>n && i>0 && s[i]==s[i-1]) (ans+=(n-i-1)/2)%=MOD;\n      //cerr<<mn[i]<<endl;\n      //cerr<<dp[0][i]<<endl;\n        if(nx[0][i]<n){\n          if(nx[0][i]==i+1){\n            (dp[0][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[0][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[0][i]]+=dp[1][i])%=MOD;\n          }\n        }\n        if(nx[1][i]<n){\n          if(nx[1][i]==i+1){\n            (dp[0][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }else{\n            (dp[1][nx[1][i]]+=dp[0][i])%=MOD;\n            (dp[1][nx[1][i]]+=dp[1][i])%=MOD;\n          }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define For(i, a, b) for(register int i = a; i <= b; ++i)\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int mod = 1e9 + 7;\nchar s[maxn];\nint dp[maxn], sum[maxn], n, flag, trans[3] = {0, -1, -1};\n\nvoid Add(int & a, const int &b) {\n\ta += b;if(a >= mod) a -= mod;\n}\n\nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1), dp[0] = 1;\n\tFor(i, 1, n) sum[i] = (sum[i - 1] + (s[i] - 'a' + 1)) % 3;\n\tFor(i, 2, n)\n\t\tif(s[i] == s[i - 1]) \n\t\t\t{flag = 1; break;}\n\tif(!flag) return printf(\"1\"), 0;\n\tint from; dp[0] = 1;\n\tFor(i, 1, n) {\n\t\tif(!sum[i] && i < n) dp[i] = 1;\n\t\t//Add(dp[i], dp[i - 1]);\n\t\tfrom = trans[(sum[i] + 1) % 3];\n\t\tif(~from) Add(dp[i], dp[from]);\n\t\tfrom = trans[(sum[i] + 2) % 3];\n\t\tif(~from) Add(dp[i], dp[from]);\n\t\ttrans[sum[i]] = i;\n\t}\n\tprintf(\"%d\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1e5+5,mo=1e9+7;\nint n,i,j,nxt[N][3],lst,f[N],s[N];\nchar c[N];\ninline void add(int&x,int y){x+=y-mo;x+=x>>31&mo;}\nint main(){\n\tscanf(\"%s\",c+1);n=strlen(c+1);\n\tfor(i=1;i<=n;++i)s[i]=(s[i-1]+c[i]-'a'+1)%3;\n\tf[n+1]=1;\n\tfor(i=n;i;--i){\n\t\tmemcpy(nxt[i],nxt[i+1],12);nxt[i][s[i]]=i;\n\t\tif(i<n && c[i]==c[i+1])lst=i+1;\n\t\tint a=0,b=0;\n\t\tif(c[i]=='a')a=i;else b=i;\n\t\tif(!a)a=nxt[lst][(s[i-1]+1)%3];\n\t\tif(!b)b=nxt[lst][(s[i-1]+2)%3];\n\t\tif(a)add(f[i],f[a+1]);if(b)add(f[i],f[b+1]);\n\t\tif(s[i-1]==s[n] && i>1)add(f[i],1);\n\t}\n//for(i=1;i<=n;++i)printf(\"%d \",f[i]);puts(\"\");\n\tif(!lst)f[1]=1;\n\tprintf(\"%d\\n\",f[1]);\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n,sum[N],nxt[N][3],dp[N];\nchar s[N];\nvoid add(int &a, int b) {a=(a+b)%P;}\nint main() {\n\tscanf(\"%s\",s+1);\n\tn = strlen(s+1);\n\tREP(i,1,n) s[i] += -'a'+1;\n\tint ok = 0;\n\tREP(i,2,n) if (s[i]==s[i-1]) ok = 1;\n\tif (!ok) return puts(\"1\"),0;\n\tREP(i,1,n) sum[i] = (sum[i-1]+s[i])%3;\n\tPER(i,0,n) {\n\t\tmemcpy(nxt[i],nxt[i+1],sizeof nxt[0]);\n\t\tnxt[i][sum[i]] = i;\n\t}\n\tdp[0] = 1;\n\tREP(i,0,n) if (dp[i]) { \n\t\tadd(dp[nxt[i][(sum[i]+1)%3]],dp[i]);\n\t\tadd(dp[nxt[i][(sum[i]+2)%3]],dp[i]);\n\t}\n\tint ans = 0;\n\tREP(i,1,n) if (sum[i]==sum[n]) add(ans,dp[i]);\n\tprintf(\"%d\\n\",ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200000\n\n\nint main(){\n\tchar a[N + 1];\n\tint b[N + 1];\n\tint na[N + 1];\n\tint nb[N + 1];\n\tlong long dp[N + 1];\n\tf(i, N + 1)a[i] = 0;\n\tint n, k;\n\tint x, y, z;\n\tint r[3];\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%s\", a);\n\tn = strlen(a);\n\tf(i, n){\n\t\tif (i % 2 == 0 && a[i] != a[0])v = false;\n\t\tif (i % 2 == 1 && a[i] == a[0])v = false;\n\t}\n\tif (v){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tif (a[0] == 'a')b[0] = 1;\n\telse b[0] = 2;\n\tf(i, n-1){\n\t\tif (a[i + 1] == 'a')b[i + 1] = (b[i] + 1) % 3;\n\t\telse b[i + 1] = (b[i] + 2) % 3;\n\t}\n\tr[0] = n;\n\tr[1] = n;\n\tr[2] = n;\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tna[i] = r[((b[i] + 1) % 3)];\n\t\tnb[i] = r[((b[i] + 2) % 3)];\n\t\tr[b[i]] = i;\n\t}\n\tans = 0;\n\tf(i, N)dp[i] = 0;\n\tdp[r[1]]++;\n\tdp[r[2]]++;\n\tfor(int i=0;i<n;i++){\n\t\tdp[na[i]] = (dp[na[i]] + dp[i]) % MOD;\n\t\tdp[nb[i]] = (dp[nb[i]] + dp[i]) % MOD;\n\t\tif (b[i] == b[n - 1])ans = (ans + dp[i]) % MOD;\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MOD=1e9+7;\nint add(int a,int b){\n\treturn (a+b)%MOD;\n}\nconst int N=100100;\nint n;\nchar s[N];\nint a[N]={0};\nint z1[N]={0};\nint z2[N]={0};\nint main(){\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tfor(int i=0;i<n;i++){\n\t\ta[i]=s[i]=='a'?1:2;\n\t}\n\n\tint cur=0;\n\tint bb=false;\n\tint qwq;\n\tfor(int i=n;i>=0;i--){\n\t\tbool e=a[i]==a[i+1];\n\t\tif(e){\n\t\t\tqwq=i+2;\n\t\t\tif(i<n){\n\t\t\t\tbb=true;\n\t\t\t}\n\t\t}\n\t\tz1[i]=add((e?z2:z1)[i+1],z2[qwq]);\n\t\tz2[i]=add(z2[i+1],z2[qwq]);\n\t\tcur=(cur+a[i])%3;\n\t\tif(cur==0){\n\t\t\tz2[i]=add(z2[i],1);\n\t\t\tif(i==n||(bb&&i>0)){\n\t\t\t\tz1[i]=add(z1[i],1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=z1[0];\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=1001000,P=1e9+7;\nint n,x,a[N],s[N],t[N],f[3][N],g[N],q[3][N],L[3],R[3];\nchar S[N];\nbool ok0(int l,int r){return (s[r]-s[l-1])%3==0;}\nbool ok1(int l,int r){return t[r]>t[l];}\nvoid chk(int&x){x-=P;x+=(x>>31)&P;}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%s\",S+1);\n\tn=strlen(S+1);\n\tFOR(i,1,n) a[i]=S[i]=='a'?1:2;\n\tFOR(i,1,n) s[i]=a[i]+s[i-1],t[i]=(a[i]==a[i-1])+t[i-1];\n\tif(!t[n]) return puts(\"1\"),0;\n\tROF(i,n,0){\n\t\tFOR(j,1,2){\n\t\t\tx=(s[i]+j)%3;f[j][i]=n+1;\n\t\t\tif(L[x]==R[x]) continue;\n\t\t\twhile(L[x]+1<R[x] && ok1(i+1,q[x][L[x]+1])) L[x]++;\n\t\t\tif(ok1(i+1,q[x][L[x]])) f[j][i]=q[x][L[x]];\n\t\t\tif(a[i+1]==j) f[j][i]=i+1;\n\t\t\tchk(g[i]+=g[f[j][i]]);\n\t\t\tif(f[j][i]<=n && ok0(f[j][i]+1,n)) chk(++g[i]);\n\t\t}\n\t\tq[s[i]%3][R[s[i]%3]++]=i;\n\t\t//cout<<i<<':'<<f[1][i]<<' '<<f[2][i]<<' '<<g[i]<<'\\n';\n\t}\n\tcout<<g[0]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int N = 3e5;\nchar st[N];\nint F[N], nxt[N];\nint su, ans, n;\nvoid ADD(int &t, int d)\n{\n    t += d;\n    if (t >= MOD) t -= MOD;\n}\nint main()\n{\n    scanf(\"%s\", st + 1);\n    n = strlen(st + 1);\n    for (int i = 1, j = 1; i <= n; ++ i)\n    {\n        j = max(j, i);\n        while (j < n && st[j + 1] != st[j])\n            j ++;\n        for (int k = i; k <= j; ++ k) nxt[k] = j;\n    }\n    if (nxt[1] == n)\n    {\n        printf(\"%d\\n\", 1);\n        return 0;\n    }\n    F[0] = 1;\n    for (int i = 1; i <= n; ++ i)\n    {\n        ADD(F[i], F[i - 1]);\n        ADD(F[nxt[i] + 1], F[i - 1]);\n    }\n    for (int i = n, su = 0; i >= 1; -- i)\n    {\n        if (su % 3 == 0) ADD(ans, F[i]);\n        su += st[i] - 'a' + 1;\n    }\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#ifdef MAROON_LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\t//a=((ll)a+b)%mod;\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\t//a=((ll)a-b%mod+mod)%mod;\n\ta-=b;\n\tif(a<0)a+=mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\twhile(p){\n\t\tif(p&1)mult(s,a);\n\t\tmult(a,a);\n\t\tp>>=1;\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Vmax=1000010;\nint fact[Vmax],factInv[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1];\n\t\tmult(fact[i],i);\n\t}\n\tfactInv[Vmax-1]=modInv(fact[Vmax-1]);\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1];\n\t\tmult(factInv[i],i+1);\n\t}\n}\nint Choose(int n,int k){\n\treturn ll(fact[n])*factInv[n-k]%mod*factInv[k]%mod;\n}\nint Binom(int a,int b){\n\treturn ll(fact[a+b])*factInv[a]%mod*factInv[b]%mod;\n}\n\nvi Waf(string s){\n\tint n=s.size();\n\tvi res(n,0);\n\tres[n-1]=1;\n\tfor(int i=n-2;i>=0;i--)\n\t\tif(s[i]==s[i+1]){\n\t\t\tREP(j,i+1)\n\t\t\t\tres[j]=1;\n\t\t\tbreak;\n\t\t}\n\tcerr<<res<<endl;\n\treturn res;\n}\n\nsigned main(){\n\tstring s=readString();\n\tint n=s.size();\n\tvi sum(n+1,0);\n\tREP(i,n){\n\t\tint c=s[i]=='a'?1:2;\n\t\tsum[i+1]=(sum[i]+c)%3;\n\t}\n\tcerr<<endl;\n\tvector<vi> to(n+1,vi(3,0));\n\tint last[3]={-1,-1,-1};\n\tfor(int i=n;i>=0;i--){\n\t\tREP(k,3)\n\t\t\tto[i][k]=last[(sum[i]+k)%3];\n\t\tlast[sum[i]]=i;\n\t}\n\tcerr<<to<<endl;\n\tcerr<<endl;\n\tvi use=Waf(s);\n\tint ans=0;\n\tvi dp(n+1,0);\n\tdp[0]=1;\n\tREP(i,n){\n\t\tif(use[i]&&sum[i]!=sum[n]){\n\t\t\tcerr<<i<<\" \"<<dp[i]<<endl;\n\t\t\tadd(ans,dp[i]);\n\t\t}\n\t\tFOR(k,1,3)\n\t\t\tif(to[i][k]!=-1){\n\t\t\t\tcerr<<i<<\"->\"<<to[i][k]<<endl;\n\t\t\t\tadd(dp[to[i][k]],dp[i]);\n\t\t\t\tif(to[i][k]<n&&use[i]&&!use[to[i][k]]&&sum[to[i][k]]!=sum[n]){\n\t\t\t\t\tadd(ans,dp[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tcerr<<dp<<endl;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <string>\n#include <set>\n#include <map>\n#define SIZE 100005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar str[SIZE];\nint nxt[SIZE][3];\nint dp[SIZE];\nint memo[3];\n\nll solve(vector <int> vec)\n{\n\tint n=vec.size();\n\tmemset(memo,-1,sizeof(memo));\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tmemo[vec[i]]=i;\n\t\tfor(int t=0;t<3;t++) nxt[i][t]=memo[t];\n\t}\n\tif(memo[0]==-1||memo[1]==-1||memo[2]==-1) return 1;\n\tfor(int i=0;i<=n;i++) dp[i]=0;\n\t//for(int i=0;i<n;i++) printf(\"%d \",vec[i]);puts(\"\");\n\tdp[0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int t=0;t<3;t++)\n\t\t{\n\t\t\tif(t==vec[i]) continue;\n\t\t\tif(nxt[i][t]!=-1)\n\t\t\t{\n\t\t\t\tdp[nxt[i][t]]+=dp[i];\n\t\t\t\tif(dp[nxt[i][t]]>=MOD) dp[nxt[i][t]]-=MOD;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",dp[i]);\n\t}\n\tll ret=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(vec[i]==vec[n-1])\n\t\t{\n\t\t\tret+=dp[i];\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t}/*\n\tfor(int i=n-4;i>=0;i-=2)\n\t{\n\t\tif(vec[i]==vec[i+2]&&vec[i+1]==vec[i+3])\n\t\t{\n\t\t\tret-=dp[i];\n\t\t\tif(ret<0) ret+=MOD;\n\t\t}\n\t\telse break;\n\t}*/\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%s\",&str);\n\tint n=strlen(str);\n\tint sum=0;\n\tvector <int> vec;\n\tvec.push_back(0);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(str[i]=='a') sum+=2;\n\t\telse sum++;\n\t\tsum%=3;\n\t\tvec.push_back(sum);\n\t}\n\t//for(int i=0;i<vec.size();i++) printf(\"%d \",vec[i]);puts(\"\");\n\tll ret=1;\n\tvector <int> now;\n\tfor(int i=0;i<vec.size();i++)\n\t{\n\t\tif(now.size()>=1&&now[now.size()-1]==vec[i])\n\t\t{\n\t\t\tret=ret*solve(now);\n\t\t\tret%=MOD;\n\t\t\tnow.clear();\n\t\t}\n\t\tnow.push_back(vec[i]);\n\t}\n\tret=ret*solve(now);\n\tret%=MOD;\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nstring S;\n\nint m[111111];\n\nint dp[111111];\n\nsigned main(){\n    cin>>S;\n    rep(i,S.size()){\n        if(S[i]=='a')m[i+1]=(m[i]+1)%3;\n        else m[i+1]=(m[i]+2)%3;\n    }\n\n    dp[0]=1;\n\n    queue<int>que[3];\n    rep(i,S.size())que[m[i+1]].push(i+1);\n\n    rep(i,S.size()){\n        for(int j=1;j<=2;j++){\n            if(que[(m[i]+j)%3].size()==0)continue;\n            int k=que[(m[i]+j)%3].front();\n            add(dp[k],dp[i]);\n        }\n        que[m[i+1]].pop();\n    }\n\n    int ans=0;\n    for(int i=1;i<=S.size();i++){\n        if(m[i]==m[S.size()])add(ans,dp[i]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nint sum[100100],ne[100100][3];\nlint dp[100100];\nint main()\n{\n\tstring s;cin>>s;\n\tint n=s.size(),f=0;\n\trep(i,n-1){\n\t\tif(s[i]==s[i+1]) f=1;\n\t}\n\tif(f<1){\n\t\tcout<<1<<endl;return 0;\n\t}\n\tsum[0]=0;\n\trep(i,n){\n\t\tsum[i+1]=sum[i];\n\t\tif(s[i]=='a') sum[i+1]++;\n\t\telse sum[i+1]+=2;\n\t\tsum[i+1]%=3;\n\t}\n\trep(i,3){\n\t\tne[n][i]=n+1;\n\t\tfor(int j=n;j>0;j--){\n\t\t\tif(sum[j]==i) ne[j][i]=j;\n\t\t\tne[j-1][i]=ne[j][i];\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));dp[0]=1;\n\tlint out=0,mo=1000000007;\n\trep(i,n){\n\t\trep(j,2){\n\t\t\tint nex=ne[i+1][(sum[i]+j+1)%3];\n\t\t\tdp[nex]+=dp[i];dp[nex]%=mo;\n\t\t}\n\t\tif(i>0 && sum[i]==sum[n]){\n\t\t\tout+=dp[i];out%=mo;\n\t\t}\n\t}\n\tout+=dp[n];\n\tcout<<out%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\n#define oo 0x7fffffff\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar jp=getchar();\n\twhile ((jp>'9'||jp<'0')&&jp!='-')\n\t\tjp=getchar();\n\tif (jp=='-')\n\t\t{\n\t\t\tfh=-1;\n\t\t\tjp=getchar();\n\t\t}\n\twhile (jp>='0'&&jp<='9')\n\t\t{\n\t\t\tout=out*10+jp-'0';\n\t\t\tjp=getchar();\n\t\t}\n\treturn out*fh;\n}\nconst int MAXN=1e5+10;\nconst int P=1e9+7;\ninline int add(int a,int b)\n{\n\treturn (a + b) % P;\n}\ninline int mul(int a,int b)\n{\n\treturn 1ll * a * b  % P;\n}\nchar s[MAXN];\nint pre[MAXN],f[MAXN],nx[3];\nint main()\n{\n\t//freopen(\"composer.in\",\"r\",stdin);\n\t//freopen(\"composer.out\",\"w\",stdout);\n\tscanf(\"%s\",s);\n\tint n;\n\tint flag=0;\n\tfor(; s[n]; ++n)\n\t\t{\n\t\t\tpre[n+1]=pre[n]+(s[n]=='a'? 1:2 );\n\t\t\tpre[n+1]%=3;\n\t\t}\n\tfor(rg int i=1; i<n; ++i)\n\t\tif(s[i]==s[i-1])\n\t\t\tflag=1;\n\tif(flag==0)\n\t\t{\n\t\t\tputchar('1');\n\t\t\treturn 0;\n\t\t}\n\tf[n]=1;\n\tfor(rg int i=0; i<3; ++i)\n\t\tnx[i]=i==pre[n]?n:n+1;\n\tfor(rg int i=n-1; i; --i)\n\t\t{\n\t\t\tf[i]= pre[i]==pre[n];\n\t\t\tfor(rg int c=1; c<=2; ++c)\n\t\t\t\tf[i]=add(f[i],f[nx[(pre[i]+c)%3]]);\n\t\t\tnx[pre[i]]=i;\n\t\t}\n\tcout<<add(f[nx[1]],f[nx[2]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 3;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nsigned main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tvvel lis(3);\n\tvel sum(n + 1);\n\tbool fl = true;\n\trep(i, n) {\n\t\tlis[sum[i]].push_back(i);\n\t\tsum[i + 1] = sum[i] + (s[i] - 'a') + 1; sum[i + 1] %= 3;\n\t\tif (i % 2 == 0 xor s[i] == s[0]) { fl = false; }\n\t}\n\tif (fl) { cout << 1 << endl; return 0; }\n\tvel dp(n);\n\tdp[0] = 1;\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (sum[i] != sum[n]) { ans += dp[i]; }\n\t\tint pla = (sum[i] + 1) % 3;\n\t\tauto itr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; }\n\t\tpla++; pla %= 3;\n\t\titr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=1e5+9,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tint f[N],n,nxt[N][3],sum[N],ans;char s[N];\n\tint main(){\n\t\tscanf(\"%s\",s+1),n=strlen(s+1);\n\t\tint peg=0;\n\t\tfor(int i=1;i<n;i++) if(s[i]==s[i+1]){peg=1;break;}\n\t\tif(!peg) puts(\"1\"),exit(0);\n\t\tfor(int i=1;i<=n;i++) sum[i]=(sum[i-1]+(s[i]=='a'?1:2))%3;\n\t\tfor(int j=0;j<3;j++) nxt[n][j]=n+1;\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tfor(int j=0;j<3;j++) nxt[i][j]=nxt[i+1][j];\n\t\t\tnxt[i][sum[i+1]]=i+1;\n\t\t}\n\t\tf[0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=1;j<3;j++) f[nxt[i][(sum[i]+j)%3]]=add(f[i],f[nxt[i][(sum[i]+j)%3]]);\n\t\t\tif(i && sum[n]==sum[i]) ans=add(ans,f[i]); \n\t\t}\n\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\tprintf(\"%d\\n\",add(ans,f[n]));\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define For(i, a, b) for(register int i = a; i <= b; ++i)\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int mod = 1e9 + 7;\nchar s[maxn];\nint dp[maxn], sum[maxn], n, flag, trans[3] = {0, -1, -1};\n\nvoid Add(int & a, const int &b) {\n\ta += b;if(a >= mod) a -= mod;\n}\n\nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1), dp[0] = 1;\n\tFor(i, 1, n) sum[i] = (sum[i - 1] + (s[i] - 'a' + 1)) % 3;\n\tFor(i, 2, n)\n\t\tif(s[i] == s[i - 1]) \n\t\t\t{flag = 1; break;}\n\tif(!flag) return printf(\"1\"), 0;\n\tint from; dp[0] = 1;\n\tFor(i, 1, n) {\n\t\tif(!sum[i] && i < n) dp[i] = 1;\n\t\tAdd(dp[i], dp[i - 1]);\n\t\tfrom = trans[(sum[i] + (s[i] == 'a' ? 1 : 2)) % 3];\n\t\tif(~from) Add(dp[i], dp[from]);\n\t\ttrans[sum[i]] = i;\n\t}\n\tprintf(\"%d\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nconst int mod=1000000007;\nvoid inc(int&a,int b){(a+=b)%=mod;}\nchar s[100010];\nint sum[100010],f[300010],las[3]={0,-1,-1};\nint main(){\n\tint n,i;\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(i=1;i<n;i++){\n\t\tif(s[i]==s[i+1]){\n\t\t\ti=-1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(~i){\n\t\tputchar('1');\n\t\treturn 0;\n\t}\n\tf[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tsum[i]=(sum[i-1]+2-(s[i]=='a'))%3;\n\t\tif(sum[i]==0&&i<n)f[i]=1;\n\t\t#define gao(x) if(~x)inc(f[i],f[x]);\n\t\tgao(las[(sum[i]+1)%3])\n\t\tgao(las[(sum[i]+2)%3])\n\t\tlas[sum[i]]=i;\n\t}\n\tprintf(\"%d\",f[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % mod;\n\t\tx = x * x % mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n\n\nmodint cnt(string s) {\n\tint n = s.size();\n\tvector<set<string>> st(n);\n\tst[0].insert(s);\n\tmodint res = 0;\n\trep(i, n - 1) {\n\t\tfor (string t : st[i]) {\n\t\t\trep(j, n - i - 1) {\n\t\t\t\tif (t[j] == t[j + 1]) {\n\t\t\t\t\tstring cop = t;\n\t\t\t\t\tchar memo = t[j];\n\t\t\t\t\tmemo = 'a' + 'b' - memo;\n\t\t\t\t\tcop.erase(cop.begin() + j);\n\t\t\t\t\tcop.erase(cop.begin() + j);\n\t\t\t\t\tcop.insert(cop.begin() + j, memo);\n\t\t\t\t\tst[i + 1].insert(cop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n)res += st[i].size();\n\treturn res;\n}\nmodint dp[1 << 17];\n\nint col[1 << 17];\nvoid solve() {\n\tstring s; cin >> s;\n\n\tint n = s.size();\n\trep(i, n) {\n\t\tcol[i + 1] = col[i];\n\t\tif (s[i] == 'a')col[i + 1]--;\n\t\telse col[i + 1]++;\n\t\tcol[i + 1] = (col[i + 1] % 3 + 3) % 3;\n\t}\n\n\n\tvector<int> nex(n);\n\tint las = n;\n\tint chk = -1;\n\tper(i, n) {\n\t\tif (i + 1 < n && s[i] == s[i + 1])las = i;\n\t\tnex[i] = las;\n\t\tif (chk < 0 && las < n)chk = las;\n\t}\n\n\tvector<int> loc[3];\n\trep(i, n + 1) {\n\t\tloc[col[i]].push_back(i);\n\t}\n\tint num[3] = {};\n\tif (chk >= 0) {\n\t\tRep1(i, chk + 1, n) {\n\t\t\tnum[col[i]]++;\n\t\t}\n\t}\n\tmodint ans = 0;\n\tdp[n] = 1;\n\tper(i, n) {\n\t\tdp[i] += dp[i + 1];\n\t\tif (nex[i] + 2 < n) {\n\t\t\tdp[i] += dp[nex[i] + 2];\n\t\t}\n\t\tif (nex[i] < n && col[i] != col[n]) {\n\t\t\tdp[i] += 1;\n\t\t}\n\t\tif (i + 1 < n && nex[i + 1] == n&&s[i]==s[i+1]) {\n\t\t\tfor (int j = i + 2; j < n; j++) {\n\t\t\t\tif (col[i + 1] == col[j]) {\n\t\t\t\t\tdp[i] += dp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nex[i]+2 < n) {\n\t\t\tint to = nex[i] + 2;\n\t\t\tif (nex[to] == n) {\n\t\t\t\tfor (int j = to + 1; j < n; j++) {\n\t\t\t\t\tif (col[to] == col[j]) {\n\t\t\t\t\t\t//cout << \"? \" << i << \" \" << j << \"\\n\";\n\t\t\t\t\t\tdp[i] += dp[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//rep(i, n)cout << dp[i] << \"\\n\";\n\n\tans = dp[0];\n\tcout << ans << \"\\n\";\n\t//cout << cnt(s) << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 300010\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nchar ch[N]; int lst[3],n,l[N],r[N],pre[N],f[N],s[N];\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint query(int l,int r){return l>=0?(pre[r]-pre[l]+mdn)%mdn:pre[r];}\nint main()\n{\n\tscanf(\"%s\",ch+1); n=strlen(ch+1); int flag=0;\n\tfor(int i=1;i<n;i++)\tflag|=(ch[i]==ch[i+1]);\n\tif(!flag)\treturn puts(\"1\"),0;\n\tfor(int i=1;i<=n;i++)\ts[i]=s[i-1]+ch[i]-'a'+1;\n\tlst[1]=lst[2]=-1; int pt=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ch[i]==ch[i-1])\tpt=i-2;\n\t\tr[i]=pt; l[i]=lst[s[i]%3]; lst[s[i]%3]=i;\n\t}\n\tf[0]=pre[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1];\n\t\tif(l[i]<r[i]&&~r[i])\tupd(f[i],query(l[i],r[i]));\n\t\tpre[i]=(pre[i-1]+f[i])%mdn;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\tif((s[n]-s[i])%3==0)\tupd(ans,f[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define fi first\n#define se second\n//#define ivorysi\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long int64;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\n\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) out(x / 10);\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N;\nchar s[100005];\nint nxt[100005][3],sum[100005],dp[100005];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nvoid Solve() {\n    scanf(\"%s\",s + 1);\n    N = strlen(s + 1);\n    bool flag = 0;\n    for(int i = 2 ; i <= N ; ++i) {\n        if(s[i] == s[i - 1]) {flag = 1;break;}\n    }\n    if(!flag) {puts(\"1\");return;}\n    for(int i = 1 ; i <= N ; ++i) {\n        sum[i] = (sum[i - 1] + (s[i] - '0')) % 3;\n    }\n    for(int i = 0 ; i < 3 ; ++i) nxt[N + 1][i] = N + 1;\n    for(int i = N ; i >= 1 ; --i) {\n        for(int j = 0 ; j < 3 ; ++j) nxt[i][j] = nxt[i + 1][j];\n        nxt[i][sum[i]] = i;\n    }\n    dp[0] = 1;\n    for(int i = 0 ; i <= N ; ++i) {\n        for(int j = 1 ; j <= 2 ; ++j) {\n            update(dp[nxt[i + 1][(sum[i] + j) % 3]],dp[i]);\n        }\n    }\n    int ans = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n        if(sum[i] == sum[N]) update(ans,dp[i]);\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n\ntemplate<typename T> class BIT {\nprivate:\n\tint n;\n\tvector<T> bit;\npublic:\n\t// 0_indexed で i 番目の要素に x を加える\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile(i < n){\n\t\t\tbit[i] += x, i += i & -i;\n\t\t}\n\t}\n\t// 0_indexed で [0,i] の要素の和(両閉区間！！)\n\tT sum(int i){\n\t\ti++;\n\t\tT s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i], i -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tBIT(){}\n\t//初期値がすべて0の場合\n\tBIT(int sz) : n(sz+1), bit(n, 0){}\n\tBIT(vector<T>& v) : n((int)v.size()+1), bit(n, 0){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tadd(i,v[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcout<<sum(i)-sum(i-1)<< \" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t//-1スタート\n\tvoid print_sum(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout<<sum(i-1)<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<mod>dp(n+1);\n    vector<int>a[3];\n    vector<int>b(n+1);\n    int c = 0;\n    rep(i,n){\n        b[i] = c;\n        c += s[i]-'a'+1;\n        c %= 3;\n        a[c].push_back(i+1);\n    }\n    a[0].push_back(n);\n    a[1].push_back(n);\n    a[2].push_back(n);\n    b[n] = c;\n    BIT<int> bit(n);\n    rep(i,n-1){\n        if(s[i]==s[i+1]){\n            bit.add(i,1);\n        }\n    } \n    dp[0] = 1;\n    rep(i,n){\n        for(int j=1;j<3;j++){\n            int ca = (b[i]+j)%3;\n            int id = i;\n            while(1){\n                int x = *upper_bound(a[ca].begin(),a[ca].end(),id);\n                id = x;\n                if(x==n)break;\n                if(x==i+1){\n                    dp[x] += dp[i];\n                    break;\n                }else{\n                    if(bit.sum(x)-bit.sum(i-1)!=0){\n                        dp[x] += dp[i];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    mod res = 0;\n    rep(i,n){\n        int k = (3+b[n]-b[i])%3;\n        if(k==0)continue;\n        if(i==n-1){\n            res += dp[i];\n        }else if(bit.sum(n-1)-bit.sum(i-2)!=0){\n            res += dp[i];\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=1e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N][3],last[3];\nsigned main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  string s;\n  int n,i,j,k,l=0;\n  cin>>s;\n  n=s.size();\n  s=\" \"+s;\n  dp[0]=1;\n  sum[0][0]=1;\n  last[1]=-1;\n  last[2]=-1;\n  bool cac=true;\n  for(i=1;i<=n;i++){\n    if(s[i]==s[i-1]){\n      cac=false;\n    }\n    if(s[i]=='a'){\n      l++;\n    }\n    else{\n      l+=2;\n    }\n    if(l>=3){\n      l-=3;\n    }\n    for(j=0;j<3;j++){\n      sum[i][j]=sum[i-1][j];\n      dp[i]+=sum[i][j];\n        if(last[l]>-1){\n          dp[i]-=sum[last[l]][j];\n        }\n    }\n  \tdp[i]-=sum[i][l];\n    if(last[l]>-1){\n      dp[i]+=sum[last[l]][l];\n    }\n    dp[i]=(dp[i]%mod+mod)%mod;\n    last[l]=i;\n    sum[i][l]+=dp[i];\n    //cout<<dp[i]<<endl;\n  }\n  if(cac){\n    cout<<1;\n    return 0;\n  }\n  if(!l){\n    sum[n][l]--;\n  }\n  cout<<sum[n][l];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define N 100005\n#define p 1000000007\ninline int _a(int x){return x<3?x:x-3;}\ninline int _b(int x){return x<p?x:x-p;}\nchar c[N];int a[N],b[N][3],f[N],i,j,n,o[3],x;\nint main()\n{\n    scanf(\"%s\",c+1),n=strlen(c+1),o[0]=o[1]=o[2]=b[n+1][0]=b[n+1][1]=b[n+1][2]=n+1,*f=1;\n    for(i=1;i<=n;i++)a[i]=_a(a[i-1]+(c[i]==97?1:2));\n    for(i=1;i<n&&c[i]!=c[i+1];i++);\n    if(i==n)return 0&puts(\"1\");\n    for(i=j=n;i;b[i][_a(3-a[i-1])]=o[0],b[i][_a(4-a[i-1])]=o[1],b[i][_a(5-a[i-1])]=o[2],b[i][c[i]==97?1:2]=i,i--)if(c[i]==c[i+1])while(i<j)o[a[j]]=j,j--;\n    for(i=0;i<=n;i++)f[b[i+1][1]]=_b(f[b[i+1][1]]+f[i]),f[b[i+1][2]]=_b(f[b[i+1][2]]+f[i]);\n    for(i=1;i<=n;i++)if(a[i]==a[n])x=_b(x+f[i]);\n    return 0*printf(\"%d\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 100010\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nchar str[N];\nll f[N];\nint nxt[3];\nint main()\n{\n\tscanf(\"%s\",str+1);\n\tint n=strlen(str+1);\n\tbool same=false;\n\tfor(int i=1;i<n && !same;i++) same=str[i]==str[i-1];\n\tif(!same){puts(\"1\");return 0;}\n\tint u=0;\n\tf[0]=1;\n\tnxt[1]=nxt[2]=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(str[i]=='a') u=(u+1)%3;\n\t\telse u=(u+2)%3;\n\t\tif(!u && i!=n) f[i]=1;\n\t\tfor(int _=0;_<=1;_++)\n\t\tif(nxt[u=(u+1)%3]>=0) f[i]=(f[i]+f[nxt[u]])%mod;\n\t\tu=(u+1)%3;\n\t\tnxt[u]=i;\n\t}\n\tprintf(\"%lld\\n\",f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <string.h>\n\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int M = 1e5 + 5;\n\nchar s[M];\nint f[M], nxt[M][2];\n\nint main() {\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1);\n\tbool ab_flag = true;\n\tfor (int i = 2; i <= n; ++ i) if (s[i] == s[i - 1]) ab_flag = false;\n\tif(ab_flag) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[n + 1] = 1; nxt[n + 1][0] = nxt[n + 1][1] = nxt[n + 2][0] = nxt[n + 2][1] = n + 2;\n\tint sum = 0;\n\tfor (int i = n; i >= 1; -- i) {\n\t\tsum = (sum + (s[i] == 'a' ? 1 : 2)) % 3;\n\t\tif (s[i] == 'a') {\n\t\t\t// a mod 3 = 1\n\t\t\tnxt[i][0] = i + 1;\n\t\t} else if (s[i + 1] == 'b') {\n\t\t\t// bb mod 3 = 1\n\t\t\tnxt[i][0] = i + 2;\n\t\t} else {\n\t\t\t// ba mod 3 = 0\n\t\t\tnxt[i][0] = nxt[i + 2][0];\n\t\t}\n\t\tif (s[i] == 'b') {\n\t\t\t// b mod 3 = 2;\n\t\t\tnxt[i][1] = i + 1;\n\t\t} else if (s[i + 1] == 'a') {\n\t\t\t// aa mod 3 = 2\n\t\t\tnxt[i][1] =  i + 2;\n\t\t} else {\n\t\t\t// ab mod 3 = 0\n\t\t\tnxt[i][1] = nxt[i + 2][1];\n\t\t}\n\t\tf[i] = f[nxt[i][0]] + f[nxt[i][1]];\n\t\tif (f[i] >= mod) f[i] -= mod;\n\t\tif (sum == 0) {\n\t\t\tf[i] ++;\n\t\t\tif (f[i] >= mod) f[i] -= mod;\n\t\t}\n\t}\n\tint ans = f[1];\n\tif (sum == 0) {\n\t\tans --;\n\t\tif (ans < 0) ans += mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 100010;\nconst int INF = 2147483600;\n\nint nxt[2][MAXN+1][3];\nLL f[MAXN+1]; char str[MAXN+1];\nint a[MAXN+1];\nLL sum;\n\ninline int Tns(int x){\n\treturn (x==2?1:2);\n} int N; \nconst int Mod = 1000000007LL;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tscanf(\"%s\",str+1); f[0]=1; N=strlen(str+1);\n\tfor(int i=1;i<=N;i++) a[i]=(int)(str[i]-'a')+1; \n\tfor(int i=N;i>=1;i--){\n\t\tnxt[0][i][1]=nxt[0][i+1][(1-a[i]+3)%3];\n\t\tnxt[0][i][2]=nxt[0][i+1][(2-a[i]+3)%3];\n\t\tnxt[0][i][0]=nxt[0][i+1][(3-a[i])%3];\n\t\tnxt[0][i][a[i]]=i;\n\t\tif(a[i]==a[i+1]&&i<N){\n\t\t\tnxt[1][i][0]=nxt[0][i][0];\n\t\t\tnxt[1][i][1]=nxt[0][i][1];\n\t\t\tnxt[1][i][2]=nxt[0][i][2];\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\t(f[i]+=f[i-1])%=Mod; \n\t\tif(nxt[1][i][Tns(a[i])]) \n\t\t\t(f[nxt[1][i][Tns(a[i])]]+=f[i-1])%=Mod;\n\t} LL ans=0; bool vis=0;\n\tfor(int i=N;i>=1;i--){\n\t\tif(i<N&&a[i+1]==a[i+2]) vis=1; \n\t\tif(!(sum%3)&&(vis||i==N)) (ans+=f[i])%=Mod;\n\t\tsum+=a[i];\n\t} printf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5, mod = 1e9 + 7;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\ninline void inc(int &a, int b) {a += b; if (a >= mod) a -= mod;}\n\nchar s[maxn];\nint n, sum, flg, nxt[2][maxn], f[maxn];\n\nint main()\n{\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tflg = 0;\n\tfor (int i = 1; i < n; ++i) flg += s[i] == s[i + 1];\n\tif (!flg) return puts(\"1\"), 0;\n\tf[n + 1] = 1; nxt[0][n + 1] = nxt[1][n + 1] = nxt[0][n + 2] = nxt[1][n + 2] = n + 2;\n\tfor (int i = n; i; --i) {\n\t\t(sum += s[i] - 'a' + 1) %= 3;\n\t\tnxt[0][i] = s[i] == 'a' ? i + 1 : nxt[1][i + 1];\n\t\tnxt[1][i] = s[i] == 'b' ? i + 1 : nxt[0][i + 1];\n\t\tf[i] = sum == 0;\n\t\tinc(f[i], f[nxt[0][i]]);\n\t\tinc(f[i], f[nxt[1][i]]);\n\t}\n\tprintf(\"%d\\n\", f[1] - (sum == 0));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nconst ll mod = 1e9 + 7;\nchar ch[maxn];\nint n,a[maxn],s[maxn],nxt[maxn][3],id[3];\nll f[maxn];\n\ninline void up(ll &x,ll y) { x = (x + y) % mod; }\n\nbool check(){\n\trep(i,1,n - 1) if ( a[i] == a[i + 1] ) return 0;\n\treturn 1;\n}\nint main(){\n\tscanf(\"%s\",ch + 1);\n\tn = strlen(ch + 1);\n\trep(i,1,n) a[i] = ch[i] - 'a' + 1 , s[i] = (s[i - 1] + a[i]) % 3;\n\tif ( check() ){ \n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tid[0] = id[1] = id[2] = n + 1;\n\trepd(i,n,0){\n\t\trep(j,0,2) nxt[i][j] = id[j];\n\t\tid[s[i]] = i;\n\t}\t\n\tll ans = 0;\n\tf[0] = 1;\n\trep(i,0,n - 1){\n\t\tup(f[nxt[i][(s[i] + 1) % 3]],f[i]);\n\t\tup(f[nxt[i][(s[i] + 2) % 3]],f[i]);\n\t\tif ( i && (s[n] - s[i] + 3) % 3 == 0 ) up(ans,f[i]);\n\t}\n\tup(ans,f[n]);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nchar s[maxn];\nint sum[maxn],f[maxn];\nint n;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tsum[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=(sum[i-1]+(s[i]=='a'?1:2))%3;\n\tint flag=1;\n\tfor(int i=1;i<n;i++)\n\t\tif(s[i]==s[i+1])flag=1;\n\tif(flag){\n\t\tputs(\"1\"); return 0;\n\t}\n\tf[0]=1;\n\tint pos[3]={-1,-1,-1};\n\tpos[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=(!sum[i])&&(i<n);\n\t\tif(~pos[(sum[i]+1)%3])f[i]=(f[i]+f[pos[(sum[i]+1)%3]]);\n\t\tif(~pos[(sum[i]+2)%3])f[i]=(f[i]+f[pos[(sum[i]+2)%3]]);\n\t\tpos[sum[i]]=i;\n\t}\n\twriteln(f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 15.09.2018 16:44:35       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % md);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int n = (int) s.size();\n  vector<int> sum(n + 1);\n  sum[0] = 0;\n  for (int i = 0; i < n; i++) {\n    sum[i + 1] = (sum[i] + (s[i] == 'a' ? 1 : 2)) % 3;\n  }\n  vector<vector<int>> nxt(n + 1, vector<int>(3, n + 1));\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = 0; j < 3; j++) {\n      nxt[i][j] = nxt[i + 1][j];\n    }\n    nxt[i][sum[i + 1]] = i + 1;\n  }\n  vector<int> eq(n + 1);\n  eq[n] = n;\n  eq[n - 1] = n;\n  for (int i = n - 2; i >= 0; i--) {\n    if (s[i] == s[i + 1]) {\n      eq[i] = i + 1;\n    } else {\n      eq[i] = eq[i + 1];\n    }\n  }\n  if (eq[0] == n) {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  vector<int> dp(n + 1, 0);\n  dp[0] = 1;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int t = 1; t <= 2; t++) {\n      int look = (sum[i] + t) % 3;\n      if (sum[i + 1] == look) {\n        add(dp[i + 1], dp[i]);\n      } else {\n        int pos = nxt[eq[i]][look];\n        if (pos <= n) {\n          add(dp[pos], dp[i]);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (sum[i] == sum[n]) {\n      add(ans, dp[i]);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int zzy = 998244353;\nchar s[100010];\nint flag;\nint n;\nint nxt[100010][3], dp[100010], sum[100010];\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    for (int i = 2; i <= n; i++) if(s[i] == s[i - 1]) flag = 1;\n    if (!flag) return puts(\"1\"), 0;\n    for (int i = 1; i <= n; i++) sum[i] = (sum[i - 1] + (s[i] == 'a' ? 1 : 2)) % 3;\n    memset(nxt[n + 1], -1, sizeof nxt[n + 1s]);\n    for (int i = n; i >= 0; i--) {\n        memcpy(nxt[i], nxt[i + 1], sizeof nxt[i]);\n        if (i) nxt[i][sum[i]] = i;\n    }\n    dp[0] = 1;\n    for (int i = 0; i < n; i++) {\n        if (sum[i] != 0 && ~nxt[i][0]) dp[nxt[i][0]] = (dp[nxt[i][0]] + dp[i]) % zzy;\n        if (sum[i] != 1 && ~nxt[i][1]) dp[nxt[i][1]] = (dp[nxt[i][1]] + dp[i]) % zzy;\n        if (sum[i] != 2 && ~nxt[i][2]) dp[nxt[i][2]] = (dp[nxt[i][2]] + dp[i]) % zzy;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        if (sum[i] == sum[n]) ans = (ans + dp[i]) % zzy;\n    }\n    return cout << ans << endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"1\"),0;\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,a[N],l[N],dp[N],sum[N];\nchar str[N];\ninline void add(int &x,int k){\n\tx+=k;x-=(x>=mod)?mod:0;\n}\nsigned main(){\n\tscanf(\"%s\",str+1);n=strlen(str+1);\n\tF(i,1,n) a[i]=(str[i]=='a')?1:2;\n\tint pd=0;\n\tF(i,1,n-1) pd|=(a[i]==a[i+1]);\n\tif (!pd) ret;\n\tl[1]=l[2]=-1;dp[0]=1;\n\tF(i,1,n){\n\t\tsum[i]=sum[i-1]+a[i];\n\t\tif (sum[i]%3==0&&i<n) dp[i]=1;\n\t\tF(j,1,2){\n\t\t\tif (l[(sum[i]+3-j)%3]!=-1) add(dp[i],dp[l[(sum[i]+3-j)%3]]);\n\t\t}\n\t\tl[sum[i]%3]=i;\n\t}\n\twrn(dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100005\n#define mo 1000000007\nint n,ans;\nchar s[M];\nint pre[M][2],f[M],g[M];\nvoid work() {\n    for(int i=n;i>=1;i--)\n\t{\n\t    if(s[i]=='a')\n\t\t{\n\t\t    pre[i-1][0]=i;\n\t\t    pre[i-1][1]=pre[i][0];\n\t\t    if(i==n) pre[i-1][1]=-1;\n\t\t}\n\t    else\n\t\t{\n\t\t    pre[i-1][1]=i;\n\t\t    pre[i-1][0]=pre[i][1];\n\t\t    if(i==n) pre[i-1][0]=-1;\n\t\t}\n\t}\n    f[0]=1;\n    for(int i=0;i<n;i++)\n\t{\n\t    if(pre[i][0]!=-1) f[pre[i][0]]=(f[pre[i][0]]+f[i])%mo;\n\t    if(pre[i][1]!=-1) f[pre[i][1]]=(f[pre[i][1]]+f[i])%mo;\n\t}\n    for(int i=n;i>=1;i--) g[i]=(g[i+1]+(s[i]=='a'?1:2))%3;\n    for(int i=1;i<=n;i++) if(!g[i+1]) ans=(ans+f[i])%mo;\n    cout<<ans<<'\\n';\n}\nint main()\n{\n    int tp=0;\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n;i++) if(s[i]==s[i-1]) tp=1;\n    if(tp) work();\n    else cout<<1<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Winding\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\nnamespace fastIO\n{\n\tconst UI BUFFER_SIZE = (UI) 1 << 15;\n\tchar buffer[BUFFER_SIZE], *cur, *ed;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ninline char *read_str(char *s)\n{\n\tregister char ch(getc());\n\twhile(!isgraph(ch)) ch = getc();\n\tfor(; isgraph(ch); ch = getc()) *s++ = ch;\n\t*s = '\\0';\n\treturn s;\n}\n\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\n\n// END tpl.\n\nconst int MOD = (int) 1e9 + 7;\n\nconst int MAXN = (int) 1e5;\n\nint n;\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read_str(s + 1) - (s + 1);\n}\n\ninline void solve()\n{\n\tstatic int a[MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i) a[i] = s[i] == 'a' ? 1 : 2;\n\n\tint fg = 0;\n\tfor(int i = 1; i < n; ++i) if(s[i] == s[i + 1]) { fg = 1; break; }\n\tif(!fg) { puts(\"1\"); return; }\n\n\tstatic int sum[MAXN + 5], pos[MAXN + 5][3];\n\n\tfor(int i = 1; i <= n; ++i) sum[i] = (sum[i - 1] + a[i]) % 3;\n\tfor(int i = 0; i < 3; ++i) pos[n][i] = n + 1;\n\tfor(int i = n - 1; i >= 0; --i)\n\t{\n\t\tfor(int j = 0; j < 3; ++j) pos[i][j] = pos[i + 1][j];\n\t\tpos[i][sum[i + 1]] = i + 1;\n\t}\n\n\tstatic int f[MAXN + 5];\n\n\tf[0] = 1;\n\tfor(int i = 0; i < n; ++i) if(f[i])\n\t\tfor(int j = 1; j < 3; ++j)\n\t\t\t(f[pos[i][(sum[i] + j) % 3]] += f[i]) %= MOD;\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i) if(sum[i] == sum[n]) (ans += f[i]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nconst int N=1e5+5,P=1e9+7;\nchar s[N];int n,m,p[N],g[N][3],f[N];\nint main(){\n\tint x,c;\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfor(x=1;x<n;x++)if(s[x]!=s[x-1])break;\n\tif(x<n){\n\t\tfor(x=1;x<=n;x++)p[x]=(p[x-1]+(s[x]=='b')+1)%3;\n\t\tfor(x=n;x>=0;x--)g[x][0]=g[x+1][0],g[x][1]=g[x+1][1],g[x][2]=g[x+1][2],g[x][p[x]]=x;\n\t\tf[0]=1;\n\t\tfor(x=0;x<n;x++)if(f[x])for(c=0;c<3;c++)if(c!=p[x]&&g[x+1][c])f[g[x+1][c]]=(f[g[x+1][c]]+f[x])%P;\n\t\tfor(x=1;x<=n;x++)if(p[x]==p[n])m=(m+f[x])%P;\n\t}else m=1;\n\tprintf(\"%d\\n\",m);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod = 1e9+7;\nchar s[1010000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>s+1;\n\tint n=strlen(s+1);\n\tint flag=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>1)flag&=s[i]!=s[i-1];\n\t}\n\tif(flag){cout<<1<<'\\n';return 0;}\n\tint now=0,p[3]={0,-1,-1},f[101000]={1};\n\tfor(int i=1;i<=n;i++){\n\t\tnow=(now+s[i]-'a'+1)%3;\n\t\tif(!now&&i<n) f[i]=1;\n\t\tauto upd=[](int&a,int b){a+=b;if(a>=mod) a-=mod;};\n\t\tif(~p[(now+2)%3]) upd(f[i],f[p[(now+2)%3]]);\n\t\tif(~p[(now+1)%3]) upd(f[i],f[p[(now+1)%3]]);\n\t\tp[now]=i;\n\t}\n\tcout<<f[n]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nconst int N = 233333,mo=1e9+7;\nchar S[N];int n,f[N],s[N],qz[N],b[N];vector<int> a[3];\nvoid add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\n\nint main(){\n\tscanf(\"%s\",S+1);n=strlen(S+1);rep(i,1,n)s[i]=S[i]-'a'+1;\n\trep(i,1,n)qz[i]=(qz[i-1]+s[i])%3,a[qz[i]].push_back(i);f[0]=1;\n\tfor(int i=n,j=n+1;i>=0;i--){if(s[i]==s[i+1])j=i+1;b[i]=j;}\n\trep(i,0,n-1)rep(j,1,2){\n\t\tif(s[i+1]==j)add(f[i+1],f[i]);\n\t\telse if(SZ(a[(qz[i]+j)%3])&&b[i+1]<=a[(qz[i]+j)%3].back()){//RE\n\t\t\tint k=*lower_bound(a[(qz[i]+j)%3].begin(),a[(qz[i]+j)%3].end(),b[i+1]);\n\t\t\tif(k<=n)add(f[k],f[i]);\n\t\t}\n\t}\n//\trep(i,0,n)printf(\"%d:%d\\n\",i,f[i]);\n\tint res=0;rep(i,0,n-1)if(b[i+1]<=n&&(qz[n]-qz[i])%3||(qz[n-1]-qz[i])%3==0)add(res,f[i]);\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX=10e5;\ntypedef struct\n{vector<int> vec;int size;}Node;\n\n\nint main(void)\n{\n\tstring S;\n\t\tcin >> S;\n\tvector<int > SF;\n\tfor(int i=0;i<S.size();i++)\n\t{\n\t\tif(S[i]=='a')\n\t\t\tSF.push_back(-1);\n\t\telse\n\t\t\tSF.push_back(1);\n\t}\n\tNode SE;\n\tSE.vec=SF;\n\tSE.size=S.size();\n\t\n\tvector<Node> V;\n\tV.push_back(SE);\n\tint g=0;\n\twhile(V.size()>=g)\n\t{\n\t\tNode F=V[g];\n\t\tg++;\n\t\tfor(int i=0;i<F.size-1;i++)\n\t\t{\n\t\t\tif(F.vec[i]*F.vec[i+1]>0)\n\t\t\t{\n\t\t\t\tvector<int > IN;\n\t\t\t\tIN=F.vec;\n\t\t\t\tIN.erase(IN.begin()+i);\n\t\t\t\tIN[i]*=-1;\n\t\t\t\tNode INT;\n\t\t\t\tINT.vec=IN;\n\t\t\t\tINT.size=F.size-1;\n\t\t\t\tV.push_back(INT);\n\t\t\t}\n\t\t}\n\t}\t\n\tvector <vector<int> > ANS;\n\tfor(int i=0;i<V.size();i++)\n\t\tANS.push_back(V[i].vec);\n\tsort(ANS.begin(),ANS.end());\n\tANS.erase(unique(ANS.begin(),ANS.end()),ANS.end());\n\tcout << ANS.size() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=100005,mod=1000000007;\nint nxt[N][2],dp[N],sum[N],Pos=N;\nchar ch[N];\nvector<int> v[3];\ninline void add(int &a,int b){\n\ta=a+b>=mod?a+b-mod:a+b;\n}\nsigned main(){\n\tscanf(\"%s\",ch+1);\n\tint n=strlen(ch+1);\n\tfor(int i=1;i<=n;i++){\n\t\tch[i]-='a'; ch[i]++;\n\t\tsum[i]=(sum[i-1]+ch[i])%3;\n\t}\n\tfor(int i=1;i<=n;i++)v[sum[i]].push_back(i); ch[0]=-1;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(ch[i+1]==ch[i])Pos=i;\n\t\tint t=(sum[i]+1)%3,pos=lower_bound(v[t].begin(),v[t].end(),Pos)-v[t].begin(); \n\t\tif(sum[i+1]==t)nxt[i][0]=i+1; else if(pos<v[t].size())nxt[i][0]=v[t][pos];\n\t\tt=(t+1)%3; pos=lower_bound(v[t].begin(),v[t].end(),Pos)-v[t].begin();\n\t\tif(sum[i+1]==t)nxt[i][1]=i+1; else if(pos<v[t].size())nxt[i][1]=v[t][pos];\n\t}\n\tif(Pos>n){\n\t\tputs(\"1\"); return 0;\n\t}\n\tdp[0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(nxt[i][0])add(dp[nxt[i][0]],dp[i]);\n\t\tif(nxt[i][1])add(dp[nxt[i][1]],dp[i]);\n\t\t//cout<<dp[i]<<\" \"<<nxt[i][0]<<\" \"<<nxt[i][1]<<endl;\n\t}\n\tfor(int i=1;i<n;i++)if(sum[i]==sum[n])add(dp[n],dp[i]);\n\tcout<<dp[n]<<endl;\n}\n/*\naa/b/ab\naa/a/ab\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = uint64_t;\nusing ll = int64_t;\nusing ld = long double;\n\nconst int MAXN = 200228;\nint b[MAXN];\nint a[MAXN];\nint nx[MAXN][3];\nconst ll MOD = 1e9 + 7;\nll f[MAXN];\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n    string s;\n    cin >> s;\n\n    int n = s.length();\n    b[0] = 0;\n\n    for (int i = 0; i < n; ++i) {\n        a[i] = s[i] - 'a' + 1;\n        b[i + 1] = (b[i] + a[i]) % 3;\n    }\n\n    bool alternate = true;\n    for (int i = 1; i < s.length(); ++i) {\n        alternate &= (s[i] != s[i - 1]);\n    }\n\n    if (alternate) {\n        cout << 1 << \"\\n\";\n        return 0;\n    }\n\n    for (int i = 0; i < 3; ++i) {\n        nx[n + 1][i] = n + 1;\n    }\n\n    for (int i = n; i >= 0; --i) {\n        copy(nx[i + 1], nx[i + 1] + 3, nx[i]);\n        nx[i][b[i]] = i;\n    }\n\n    ll ans = (b[0] == b[n]) ? (MOD - 1) : 0;\n    f[0] = 1;\n\n    for (int i = 0; i <= n; ++i) {\n        if (b[i] == b[n]) {\n            ans = (ans + f[i]) % MOD;\n        }\n\n        for (int j = 1; j <= 2; ++j) {\n            int d = nx[i + 1][(b[i] + j) % 3];\n            f[d] = (f[d] + f[i]) % MOD;\n        }\n    }\n\n    cout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nsigned main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tvvel lis(3);\n\tvel sum(n + 1);\n\tbool fl = true;\n\trep(i, n) {\n\t\tlis[sum[i]].push_back(i);\n\t\tsum[i + 1] = sum[i] + (s[i] - 'a') + 1; sum[i + 1] %= 3;\n\t\tif (i % 2 == 0 xor s[i] == s[0]) { fl = false; }\n\t}\n\tif (fl) { cout << 1 << endl; return 0; }\n\tvel dp(n);\n\tdp[0] = 1;\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (sum[i] != sum[n]) { ans += dp[i]; }\n\t\tint pla = (sum[i] + 1) % 3;\n\t\tauto itr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; dp[*itr] %= p; }\n\t\tpla++; pla %= 3;\n\t\titr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; dp[*itr] %= p; }\n\t}\n\tcout << ans%p << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define Z int\n#define C char\n#define L long long\n#define S(s) scanf(\"%s\",s+1)\n#define P(n) printf(\"%lld\",(n+p)%p)\n#define F(i,a,b) for(L i=a;i<=b;i++)\n#define D(i,a,b) for(L i=a;i>=b;i--)\n#define W while\n#define I if\n#define R return\n#define nx 100001\n#define p (L)(1e9+7)\nC s[nx];\nL n,g,a[nx],pre[nx],nxt[nx][3],f[nx],ans;\nZ main(){\n\tS(s);\n\tW(s[n+1])n++;\n\tF(i,1,n)pre[i]=pre[i-1]+(a[i]=s[i]-'`');\n\tF(i,1,n-1)I(a[i]==a[i+1])g=1;\n\tI(!g){P(1);R 0;}\n\tD(i,n-1,0)F(o,1,2)nxt[i][(pre[i]+o)%3]=\n\ta[i+1]==o?i+1:nxt[i+1][(pre[i]+o)%3];\n\tf[0]=1;\n\tF(i,0,n-1)F(o,1,2)(f[nxt[i][(pre[i]+o)%3]]+=f[i])%=p;\n\tF(i,1,n)I((pre[n]-pre[i])%3==0)(ans+=f[i])%=p;\n\tP(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nconst int N=1e5+5,P=1e9+7;\nchar s[N];int n,m,p[N],g[N][3],f[N];\nint main(){\n\tint x,c;\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfor(x=1;x<n;x++)if(s[x]==s[x+1])break;\n\tif(x<n){\n\t\tfor(x=1;x<=n;x++)p[x]=(p[x-1]+(s[x]=='b')+1)%3;\n\t\tfor(x=n;x>=0;x--)g[x][0]=g[x+1][0],g[x][1]=g[x+1][1],g[x][2]=g[x+1][2],g[x][p[x]]=x;\n\t\tf[0]=1;\n\t\tfor(x=0;x<n;x++)if(f[x])for(c=0;c<3;c++)if(c!=p[x]&&g[x+1][c])f[g[x+1][c]]=(f[g[x+1][c]]+f[x])%P;\n\t\tfor(x=1;x<=n;x++)if(p[x]==p[n])m=(m+f[x])%P;\n\t}else m=1;\n\tprintf(\"%d\\n\",m);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst int mod = 1e9 + 7;\n\nnamespace {\n  inline int add(int x) {return (x >= mod) ? x - mod : x;}\n  inline int sub(int x) {return (x < 0) ? x + mod : x;}\n  inline void Add(int &x, int y) {x = add(x + y);}\n  inline void Sub(int &x, int y) {x = sub(x - y);}\n  inline int Pow(int x, int y) {\n\tint res = 1;\n\tfor(; y; y >>= 1, x = 1LL * x * x % mod) {\n\t  if(y & 1) {\n\t\tres = 1LL * res * x % mod;\n\t  }\n\t}\n\treturn res;\n  }\n}\n\nint A[N], n, m, x, y, dp[N];\nchar s[N];\n\nint tmp[N][3];\n\nbool pd(void) {\n  bool ok = 1;\n  for(int i = 1; i < n; ++ i) ok &= (s[i] != s[i + 1]);\n  return ok;\n}\n\nmain() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for(int i = 1; i <= n; ++ i) {\n\tA[i] = s[i] - 'a' + 1;\n\tA[i] += A[i - 1];\n\tA[i] %= 3;\n  }\n  if(pd()) {\n\treturn 0 *puts(\"1\");\n  }\n  dp[0] = 1;\n  tmp[n + 1][0] = tmp[n + 1][1] = tmp[n + 1][2] = n + 1;\n  int ans = 0;\n  for(int i = n; i >= 1; -- i) {\n\tfor(int a = 0; a < 3; ++ a) tmp[i][a] = tmp[i + 1][a];\n\ttmp[i][A[i]] = min(tmp[i][A[i]], i);\n  }\n  //cerr << A[2] <<\" \" << A[3] << endl;\n  for(int i = 0; i < n; ++ i) {\n\tfor(int j = 0; j < 3; ++ j) \n\t  if(A[i] != j && tmp[i + 1][j] <= n) \n\t\tAdd(dp[tmp[i + 1][j]], dp[i]);\n  }\n  for(int i = 1; i <= n; ++ i) if((A[i] == A[n])) Add(ans, dp[i]);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define ll long long\n#define mo 1000000007\nint n;\nchar s[N];\nint sum[N][2];\nint nxt[N][2][3];\nint f[N];\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor (int i=1;i<=n;++i)\n\t\ts[i]-='a';\n\tbool spj=1;\n\tfor (int i=1;i<n && spj;++i)\n\t\tspj&=(s[i]!=s[i+1]);\n\tif (spj){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tsum[i][0]=sum[i-1][0]+(s[i]==0);\n\t\tsum[i][1]=sum[i-1][1]+(s[i]==1);\n\t}\n\tnxt[n+1][0][0]=nxt[n+1][0][1]=nxt[n+1][0][2]=\n\tnxt[n+1][1][0]=nxt[n+1][1][1]=nxt[n+1][1][2]=n+1;\n\tfor (int i=n;i>=1;--i){\n\t\tmemcpy(nxt[i],nxt[i+1],sizeof nxt[i]);\n\t\tnxt[i][0][(sum[i][0]+i)%3]=i;\n\t\tnxt[i][1][(sum[i][1]+i)%3]=i;\n\t}\n\tf[0]=1;\n\tll ans=0;\n\tfor (int i=0;i<n;++i)\n\t\tfor (int c=0;c<2;++c){\n\t\t\tint d=(sum[i][c^1]+i+1)%3,j=nxt[i+1][c^1][d];\n\t\t\tif (j<=n)\n\t\t\t\t(f[j]+=f[i])%=mo;\n\t\t\tif ((sum[n][c^1]+n)%3==(sum[i][c^1]+i+1)%3)\n\t\t\t\t(ans+=f[i])%=mo;\n\t\t}\n//\tfor (int i=0;i<n;++i)\n//\t\tprintf(\"%d \",f[i]);\n//\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=100111;\nconst int mod=1e9+7;\ninline void add(int&x,int y){x+=y;if(x>=mod)x-=mod;}\n\nchar s[maxn];int n,pre[maxn],dp[maxn],nxt[maxn][3];\n\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tbool have=0;for(int i=1;i<n;i++)if(s[i]==s[i+1])have=1;\n\t\n\tif(!have)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=1;i<=n;i++)if(s[i]=='a')pre[i]=(pre[i-1]+1)%3;else pre[i]=(pre[i-1]+2)%3;\n\tfor(int i=0;i<3;i++)nxt[n+1][i]=n+1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tmemcpy(nxt[i],nxt[i+1],sizeof(nxt[i]));\n\t\tnxt[i][pre[i]]=i;\n\t}\n\tdp[0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int k=1;k<=2;k++)\n\t\t\tadd(dp[nxt[i+1][(pre[i]+k)%3]],dp[i]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)if(pre[i]==pre[n])add(ans,dp[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,mod=1e9+7;\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n;\nint a[N],s[N];\nvoid IN(){\n\tchar s[N];\n\tcin>>s+1;\n\tn=strlen(s+1);\n\tFor(i,1,n)\n\t\ta[i]=s[i]-'a'+1;\n}\nint p[3];\nint b1[N],b2[N];\nint dp[N];\nint ans=0;\nint main(){\n\tIN();\n\tFor(i,0,2)\n\t\tp[i]=n+1;\n\tFor(i,1,n)\n\t\ts[i]=(s[i-1]+a[i])%3;\n\tint las=n;\n\tFod(i,n,1){\n\t\tif (i<n&&a[i]==a[i+1]){\n\t\t\tFod(j,las,i+1)\n\t\t\t\tp[s[j]]=j;\n\t\t\tlas=i;\n\t\t}\n\t\tif (a[i]==1)\n\t\t\tb1[i-1]=i,b2[i-1]=p[(s[i-1]+2)%3];\n\t\telse\n\t\t\tb2[i-1]=i,b1[i-1]=p[(s[i-1]+1)%3];\n\t}\n\tif (las==n)\n\t\treturn puts(\"1\"),0;\n\tdp[0]=1;\n\tFor(i,0,n-1){\n\t\tAdd(dp[b1[i]],dp[i]);\n\t\tAdd(dp[b2[i]],dp[i]);\n\t}\n\tFor(i,1,n)\n\t\tif ((s[n]-s[i]+3)%3==0)\n\t\t\tAdd(ans,dp[i]);\n\tcout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define fi first\n#define se second\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\nint read(){char c=getchar();int d=0,f=1;for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;for(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());return d*f;}\nchar Read(){char c=getchar();while(c<'0'||c>'9')c=getchar();return c;}\ntypedef pair<int,int>PII;\ntypedef long long LL;\nconst int N=100000;\nconst int mod=1e9+7;\nint n,dp[N+1],a[N+1],t[N+1][3],tt[N+1],p[10];\nchar s[N+1];\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tref(i,1,n)a[i]=(s[i]=='a'?1:2);\n\tref(i,1,n)(a[i]+=a[i-1])%=3;\n\tdef(i,n,1){\n\t\tref(j,0,2)t[i][j]=t[i+1][j]; t[i][a[i]]=i;\n\t\ttt[i]=tt[i+1]; if(i<n&&s[i]==s[i+1])tt[i]=i+1;\n\t}\n\tdp[0]=1;\n\tref(i,0,n-1)if(dp[i]){\n\t\tp[0]=0;\n\t\tp[++p[0]]=i+1;\n\t\tif(tt[i+1])ref(j,0,2) if(j!=a[i]&&j!=a[i+1])p[++p[0]]=t[tt[i+1]][j];\n\t\tif(tt[i+1]&&a[n]!=a[i]){ p[++p[0]]=n; ref(j,1,p[0]-1)if(p[j]==n)p[0]--; }\n\t\tref(j,1,p[0])(dp[p[j]]+=dp[i])%=mod;\n\t\tif(i&&i!=n-1&&!tt[i+1]){\n\t\t\tint S=(s[i]!=s[i+1])?(mod+dp[i]-dp[i-1]):dp[i];\n\t\t\tS=1LL*S*((n-i-1)/2)%mod;\n\t\t\t(dp[n]+=S)%=mod;\n\t\t}\n\t}\n\tcout<<dp[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n    }\n    int nx[100010];\n    int p[3];\n    for(int j=0; j<3; j++) p[j]=n+1;\n    p[c[n]]=n;\n    for(int i=n-1; i>=0; i--){\n        p[c[i]]=i;\n        if(s[i]=='a') nx[i]=p[(c[i]+2)%3];\n        else nx[i]=p[(c[i]+1)%3];\n    }\n    int dp[100010]={};\n    dp[0]=1;\n    int ans=0;\n    for(int i=0; i<n; i++){\n        (dp[i+1]+=dp[i])%=MOD;\n        (dp[nx[i]]+=dp[i])%=MOD;\n        int x=(c[n]-c[i+1]+3)%3;\n        if(x==0) (ans+=dp[i+1])%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#include<atcoder/all>\nusing namespace atcoder;\n\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\n\n\nint main() {\n\tstring S;\n\tcin >> S;\n\n\t\n\tll N = S.size();\n\t\n\tvll a(N + 1);\n\trepn(i, N) {\n\t\tif (S[i - 1] == 'a') { a[i] = 1; }\n\t\telse { a[i] = 2; }\n\t}\n\n\tvll sum(N + 1, 0);\n\tvvll lis(3);\n\n\trepn(i, N) {\n\t\tsum[i] = (sum[i - 1] + a[i]) % 3;\n\t\tlis[sum[i]].push_back(i);\n\t}\n\n\tvvll ad(N + 1);\n\tll ren = N + 1;\n\tfor (ll i = N-1; i >= 0; i--) {\n\t\tif (i <= N - 2 && a[i + 1] == a[i + 2]) { ren = i + 2; }\n\n\t\tad[i + 1].push_back(i);\n\n\t\tll x = (sum[i] + (3-a[i+1])) % 3;\n\t\tauto itr = lower_bound(lis[x].begin(), lis[x].end(), ren);\n\t\t\n\t\tif (itr != lis[x].end()) { ad[*itr].push_back(i); }\n\t}\n\n\tif (ren == N + 1) { cout << 1 << endl; return 0; }\n\n\tvmint dp(N + 1, 0);\n\tdp[0] = 1;\n\n\n\trepn(i, N) {\n\t\t//cout << i << endl;\n\t\tfor (ll j : ad[i]) {\n\t\t\tdp[i] += dp[j];\n\t\t\t//cout << j << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\n\tmint ans = 0;\n\trepn(i, N) {\n\t\tif (sum[i] == sum[N]) { ans += dp[i]; }\n\t}\n\n\tcout << ans << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define ll long long\n#define mo 1000000007\nint n;\nchar s[N];\nint sum[N][2];\nint nxt[N][2][3];\nint f[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor (int i=1;i<=n;++i)\n\t\ts[i]-='a';\n\tbool spj=1;\n\tfor (int i=1;i<n && spj;++i)\n\t\tspj&=(s[i]!=s[i+1]);\n\tif (spj){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tsum[i][0]=sum[i-1][0]+(s[i]==0);\n\t\tsum[i][1]=sum[i-1][1]+(s[i]==1);\n\t}\n\tnxt[n+1][0][0]=nxt[n+1][0][1]=nxt[n+1][0][2]=\n\tnxt[n+1][1][0]=nxt[n+1][1][1]=nxt[n+1][1][2]=n+1;\n\tfor (int i=n;i>=1;--i){\n\t\tmemcpy(nxt[i],nxt[i+1],sizeof nxt[i]);\n\t\tnxt[i][0][(sum[i][0]+i)%3]=i;\n\t\tnxt[i][1][(sum[i][1]+i)%3]=i;\n\t}\n\tf[0]=1;\n\tll ans=0;\n\tfor (int i=0;i<n;++i)\n\t\tfor (int c=0;c<2;++c){\n\t\t\tint d=(sum[i][c^1]+i+1)%3,j=nxt[i+1][c^1][d];\n\t\t\tif (j<=n)\n\t\t\t\t(f[j]+=f[i])%=mo;\n\t\t\tif ((sum[n][c^1]+n)%3==(sum[i][c^1]+i+1)%3)\n\t\t\t\t(ans+=f[i])%=mo;\n\t\t}\n//\tfor (int i=0;i<n;++i)\n//\t\tprintf(\"%d \",f[i]);\n//\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int MOD=1e9+7;\n\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\n\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\n\nint nxt[111111];\nint dp[111111][2];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring s; cin>>s; int n=s.length(); s=\"$\"+s;\n\tnxt[n]=-1;\n\tfor(int i=n-1;i>=1;i--)\n\t{\n\t\tnxt[i]=-1;\n\t\tif(s[i+1]==s[i]) {nxt[i]=i+1; continue;}\n\t\tnxt[i]=nxt[i+1];\n\t}\n\tnxt[0]=nxt[1];\n\tdp[0][0]=1; \n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint v=add(dp[i][0],dp[i][1]);\n\t\tdp[i+1][s[i+1]-'a']=add(dp[i+1][s[i+1]-'a'],v);\n\t\tif(nxt[i+1]>0) dp[nxt[i+1]][(s[i+1]-'a')^1]=add(dp[nxt[i+1]][(s[i+1]-'a')^1],v);\n\t}\t\n\tint ans=0; int sum=0;\n\tfor(int i=n;i>=1;i--)\n\t{\t\t\n\t\tif(sum==0) ans=add(ans,add(dp[i][0],dp[i][1]));\n\t\tsum+=(s[i]=='a'?1:2); sum%=3;\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int Max_N(100050);\nconst int MOD(1000000000 + 7);\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nint N, F[Max_N], Last[3];\nchar S[Max_N]; \n\nint main()\n{\n\tscanf(\"%s\", S + 1), N = strlen(S + 1);\n\tbool special = true;\n\tfor (int i = 2;i <= N;++i)\n\t\tif (S[i] == S[i - 1])\n\t\t\tspecial = false;\n\tif (special)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tLast[0] = 0, Last[1] = Last[2] = -1, F[0] = 1;\n\tfor (int i = 1, Sum = 0, a;i <= N;++i)\n\t{\n\t\tif (i < N && Sum == 0)\n\t\t\tF[i] = 1;\n\t\t(Sum += (S[i] - 'a' + 1)) %= 3;\n\t\ta = ((Sum - 1) % 3 + 3) % 3;\n\t\tif (Last[a] != -1)\n\t\t\tupd(F[i], F[Last[a]]);\n\t\ta = ((Sum - 2) % 3 + 3) % 3;\n\t\tif (Last[a] != -1)\n\t\t\tupd(F[i], F[Last[a]]);\n\t\tLast[Sum] = i;\n\t}\n\tprintf(\"%d\", F[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MOD=1000000007;\n\nchar s[MAXN+1]; int n;\n\nint sum[MAXN+1];\nint dp[MAXN+1][2]; // dp[i][j] is number of strings we can make, where we may skip any zerosum prefix iff j=1\n\nint nxtsum[MAXN+1][3];\nint nxtsame[MAXN];\n\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\nvoid run() {\n\tscanf(\"%s\",s); n=strlen(s);\n\n\tsum[0]=0; REP(i,n) sum[i+1]=(sum[i]+s[i]-'a'+1)%3;\n\tfor(int i=n;i>=0;--i) { REP(j,3) nxtsum[i][j]=i==n?-1:nxtsum[i+1][j]; nxtsum[i][sum[i]]=i; }\n\tnxtsame[n-1]=-1; for(int i=n-2;i>=0;--i) nxtsame[i]=s[i]==s[i+1]?i:nxtsame[i+1];\n\n\tdp[n][0]=dp[n][1]=1;\n\tfor(int i=n-1;i>=0;--i) REP(j,2) {\n\t\tdp[i][j]=0;\n\t\tbool nj=j==1||i+1<n&&s[i]==s[i+1]?1:0;\n\t\tif(sum[i]==sum[n]&&j==1) inc(dp[i][j],1); // stop\n\t\tinc(dp[i][j],dp[i+1][nj]); // take s[i]\n\t\tif(nj==0&&nxtsame[i]!=-1&&sum[i+1]==sum[n]) inc(dp[i][j],1); // take s[i] and stop\n\t\tint k=(sum[i]+3-(s[i]-'a'+1))%3;\n\t\tif(j!=0||nxtsame[i]!=-1) {\n\t\t\tint fr=j==0?nxtsame[i]+2:i;\n\t\t\tif(nxtsum[fr][k]!=-1) inc(dp[i][j],dp[nxtsum[fr][k]][1]); // take other letter\n\t\t}\n\t\t//printf(\"%d,%d: %d\\n\",i,j,dp[i][j]);\n\t}\n\tprintf(\"%d\\n\",dp[0][0]);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100,mod=1e9+7;\nll nxt[N];\nll b[N][3];\nll d[N][3];\nll a[N];\nll dp[N];\nll par[N];\nint32_t main(){\n    string s;\n    cin >> s;\n    ll n=s.size();\n    for (int i=0;i<s.size();i++){\n        a[i+1]=s[i]-'a'+1;\n    }\n    nxt[n]=n+1;\n    for (int i=n-1;i;i--){\n        if (a[i+1]==a[i]) nxt[i]=i+1;\n        else nxt[i]=nxt[i+1];\n    }\n    b[n+1][0]=n+1;\n    b[n+1][1]=n+1;\n    b[n+1][2]=n+1;\n    b[n+2][0]=n+2;\n    b[n+2][1]=n+2;\n    b[n+2][2]=n+2;\n    d[n+1][0]=n+1;\n    d[n+1][1]=n+1;\n    d[n+1][2]=n+1;\n    d[n+2][0]=n+2;\n    d[n+2][1]=n+2;\n    d[n+2][2]=n+2;\n    for (int i=n;i;i--){\n        if (a[i]==1){\n            b[i][1]=i;\n            ll z=nxt[i];\n            z--;\n            ll y=(z-i+2)/2+((z-i+1)/2)*2;\n            y%=3;\n            if (y==2){\n                b[i][2]=d[z+1][0];\n            }\n            if (y==0){\n                b[i][2]=b[z+1][2];\n            }\n            if (y==1){\n                b[i][2]=b[z+1][1];\n            }\n        }\n        else if (a[i]==2){\n            b[i][2]=i;\n            ll z=nxt[i];\n            z--;\n            ll y=((z-i+2)/2)*2+(z-i+1)/2;\n            y%=3;\n            if (y==1){\n                b[i][1]=d[z+1][0];\n            }\n            if (y==0){\n                b[i][1]=b[z+1][1];\n            }\n            if (y==2){\n                b[i][1]=b[z+1][2];\n            }\n        }\n        for (int j=0;j<3;j++){\n            if (j==a[i]){\n                d[i][j]=i;\n                continue;\n            }\n            ll z=j+a[i];\n            z%=3;\n            d[i][j]=d[i+1][z];\n        }\n        for (int j=0;j<3;j++){\n            if (b[i][j]>n || b[i][j]==0) b[i][j]=n+1;\n            if (d[i][j]>n || d[i][j]==0) d[i][j]=n+1;\n        }\n\n    }\n    for (int i=n;i;i--) par[i]=a[i]+par[i+1],par[i]%=3;\n    for (int i=n;i;i--){\n       // cout << i << \" \" << par[i] << \" \" << b[i][1] << \" \" << b[i][2] << endl;\n        if (par[i]) dp[i]++;\n        dp[i]+=dp[b[i][1]+1];\n        dp[i]+=dp[b[i][2]+1];\n        dp[i]%=mod;\n    }\n    cout << dp[1] << endl;\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 100010\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nchar str[N];\nll f[N];\nint nxt[3];\nint main()\n{\n\tscanf(\"%s\",str+1);\n\tint n=strlen(str+1);\n\tbool same=false;\n\tfor(int i=1;i<n && !same;i++) same=str[i]==str[i+1];\n\tif(!same){puts(\"1\");return 0;}\n\tint u=0;\n\tf[0]=1;\n\tnxt[1]=nxt[2]=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(str[i]=='a') u=(u+1)%3;\n\t\telse u=(u+2)%3;\n\t\tif(!u && i!=n) f[i]=1;\n\t\tfor(int _=0;_<=1;_++)\n\t\tif(nxt[u=(u+1)%3]>=0) f[i]=(f[i]+f[nxt[u]])%mod;\n\t\tu=(u+1)%3;\n\t\tnxt[u]=i;\n\t}\n\tprintf(\"%lld\\n\",f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\n\nint N;\nchar S[100011];\n\nMint dp[100011][3][3][2][2];\nMint dpe[100011];\n\nint sums[100011];\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n    bool alter = true;\n    REP (i, N-1) if (S[i] == S[i+1]) alter = false;\n\n    if (alter) {\n\tputs(\"1\");\n\treturn;\n    }\n\n    REP (i, N) sums[i+1] = (sums[i] + (S[i]-'a') + 1) % 3;\n\n    dpe[0] = 1;\n    REP (i, N) {\n\tchar c = S[i];\n\tint d = c - 'a';\n\tdpe[i+1] += dpe[i];\n\tdp[i+1][d][d+1][0][d] += dpe[i];\n\n\tREP (t, 2) REP (m, 3) REP (h, 2) REP (p, 2) {\n\t    int nh = h || (p == d);\n\t    int nm = (m + d + 1) % 3;\n\t    if (nh && t+nm==2) {\n\t\tdpe[i+1] += dp[i][t][m][h][p];\n\t    } else {\n\t\tdp[i+1][t][nm][nh][d] += dp[i][t][m][h][p];\n\t    }\n\t}\n    }\n\n    Mint ans = 0;\n    for (int i=1; i<=N; i++) if ((sums[N] - sums[i]) % 3 == 0) ans += dpe[i];\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nstring S; int N;\nmint dp[101010];\nint sm[101010], nxt[101010][3];\nint ok[101010], oksm[101010];\nvector<int> idx[3];\n//---------------------------------------------------------------------------------------------------\nint getok(int l, int r) { // [l,r)\n    if (l >= r) return 0;\n\n    int res = oksm[r - 1];\n    if (l) res -= oksm[l - 1];\n    return res;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> S;\n    N = S.length();\n    rep(i, 0, N) {\n        if (S[i] == 'a') sm[i] = 1;\n        else sm[i] = 2;\n    }\n    rep(i, 1, N) sm[i] = (sm[i] + sm[i - 1]) % 3;\n    rep(i, 0, N) idx[sm[i]].push_back(i);\n    rep(i, 0, 3) idx[i].push_back(N);\n\n    rep(i, 0, N - 1) if (S[i] == S[i + 1]) ok[i] = 1;\n    oksm[0] = ok[0];\n    rep(i, 1, N) oksm[i] = oksm[i - 1] + ok[i];\n\n    rep(i, 0, N) {\n        rep(c, 0, 3) {\n            int ng = i, ok = N;\n            while (ng + 1 != ok) {\n                int md = (ng + ok) / 2;\n                int j = *lower_bound(all(idx[c]), md);\n\n                if (getok(i, j)) ok = md;\n                else ng = md;\n            }\n\n            nxt[i][c] = *lower_bound(all(idx[c]), ok);\n        }\n    }\n\n    dp[0] = 1;\n    rep(i, 0, N) {\n        int pre = 0;\n        if (i) pre = sm[i - 1];\n\n        // make 'a'\n        // sm[j] - pre = 1\n        // sm[j] = pre + 1\n        if (S[i] == 'a') dp[i + 1] += dp[i];\n        else {\n            int ai = nxt[i][(pre + 1) % 3];\n            if (ai < N) dp[ai + 1] += dp[i];\n        }\n        \n        // make 'b'\n        // sm[j] - pre = 2\n        // sm[j] = pre + 2\n        if (S[i] == 'b') dp[i + 1] += dp[i];\n        else {\n            int bi = nxt[i][(pre + 2) % 3];\n            if (bi < N) dp[bi + 1] += dp[i];\n        }\n    }\n\n    mint ans = 0;\n    rep(i, 1, N + 1) if ((sm[N - 1] - sm[i - 1] + 3) % 3 == 0) ans += dp[i];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1e5+10,mod=1e9+7;\ninline void add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nchar s[maxn];\nint Next[maxn][3],sum[maxn],dp[maxn];\nint main(){\n\tbool flag=1;\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1),ans=0;\n\tREP(i,2,n) flag&=(s[i]!=s[i-1]);\n\tif(flag){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tREP(i,1,n) sum[i]=(sum[i-1]+s[i]-'a'+1)%3;\n\tDREP(i,n,0){\n\t\tREP(j,0,2) Next[i][j]=Next[i+1][j];\n\t\tNext[i][sum[i]]=i;\n\t}\n\tdp[0]=1;\n\tREP(i,0,n){\n\t\tREP(j,1,2){\n\t\t\tint u=Next[i][(sum[i]+j)%3];\n\t\t\tif(u) add(dp[u],dp[i]);\n\t\t}\n\t\tif(i && sum[i]==sum[n]) add(ans,dp[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nint n,f[100010],la[100010],sla[100010][3],sum[100010],ans,fir;\nchar s[100010];\n\nint main()\n{\n\tscanf(\"%s\",s+1),n=strlen(s+1),sum[0]=0;\n\tfor (int i=1; i<=n; i++) sum[i]=(sum[i-1]+(s[i]-'a'+1))%3;\n\tsla[0][0]=0,sla[0][1]=sla[0][2]=-1;\n\tfor (int i=1; i<=n; i++)\n\t\tmemcpy(sla[i],sla[i-1],sizeof(sla[i])),sla[i][sum[i]]=i;\n\tla[0]=la[1]=-1;\n\tfor (int i=2; i<=n; i++)\n\t\tif (s[i]==s[i-1]) la[i]=i-1;\n\t\telse la[i]=la[i-1];\n\tif (la[n]==-1) return puts(\"1\"),0;\n\tf[n+1]=1;\n\tfor (int nw,i=n; i; i--)\n\t{\n\t\tf[i]=(f[i]+f[i+1]>=mod?f[i]+f[i+1]-mod:f[i]+f[i+1]);\n\t\tif ((nw=la[i])!=-1)\n\t\t{\n\t\t\tnw=sla[nw][(sum[i]-((s[i]-'a')^1)+5)%3];\n\t\t\tif (nw!=-1) f[nw+1]=(f[nw+1]+f[i+1]>=mod?f[nw+1]+f[i+1]-mod:f[nw+1]+f[i+1]);\n\t\t}\n\t}\n\tans=0;\n\tfor (int i=1; i<=n; i++) if (sum[i-1]==0) \n\t\tans=(ans+f[i]>=mod?ans+f[i]-mod:ans+f[i]);\n\treturn printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005, mod = 1000000007;\n\nvoid up(int &x, int y) { x += y - mod, x += x >> 31 & mod; }\n\nint n, dp[N], nxt[N], ans;\nchar s[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> s + 1, n = std::strlen(s + 1), dp[0] = 1;\n\tnxt[n + 1] = n + 1;\n\tfor (int i = n; i >= 1; --i)\n\t\tnxt[i] = s[i] == s[i + 1] ? i + 1 : nxt[i + 1];\n\tfor (int i = 0; i < n; ++i)\n\t\tup(dp[i + 1], dp[i]), up(dp[nxt[i + 1]], dp[i]);\n\tfor (int i = n, S = 0; i >= 1; S += s[i--])\n\t\tif (!(S % 3)) up(ans, dp[i]);\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint solve(string s)\n{\n    const int M = 1e9 + 7;\n    int n = (int) s.size();\n    vector <int> go(n);\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (i == n - 1 || s[i] == s[i + 1])\n        {\n            go[i] = i + 1;\n        }\n        else\n        {\n            go[i] = go[i + 1];\n        }\n    }\n    if (go[0] == n)\n    {\n        return 1;\n    }\n    vector <int> dp(n + 1);\n    vector <int> pref(n);\n    int sm = 0;\n    for (int i = 0; i < n; i++)\n    {\n        sm += (s[i] - 'a' + 1);\n        if (sm >= 3) sm -= 3;\n        pref[i] = sm;\n    }\n    vector <vector <int> > g(n + 1, vector <int> (3, n));\n    for (int i = n - 1; i >= 0; i--)\n    {\n        g[i] = g[i + 1];\n        g[i][pref[i]] = i;\n    }\n    int ans = 0;\n    dp[0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        dp[i + 1] += dp[i];\n        if (dp[i + 1] >= M) dp[i + 1] -= M;\n        int cur = (s[i] == 'a' ? 2 : 1);\n        int ret = go[i];\n        int need = ((i ? pref[i - 1] : 0) + cur) % 3;\n        int where = g[ret][need];\n        if (where + 1 <= n)\n        {\n            dp[where + 1] += dp[i];\n            if (dp[where + 1] >= M) dp[where + 1] -= M;\n        }\n        if (i != 0 && pref[i - 1] == pref[n - 1])\n        {\n            ans += dp[i];\n            if (ans >= M) ans -= M;\n        }\n    }\n    ans += dp[n];\n    if (ans >= M) ans -= M;\n    return ans;\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif // ONPC\n    string s;\n    while (cin >> s)\n    {\n        cout << solve(s) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\n\nconst ll MOD = 1000000007;\nconst int MN = 100010;\n\nint acc[MN];\nll dp[MN];\nint nx[MN][3];\n\nint main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\n\trep(i, n) {\n\t\tacc[i + 1] = (acc[i] + (s[i] != 'a') + 1) % 3;\n\t}\n\n\trep(j, 3) nx[n][j] = n + 1;\n\n\tfor (int i = n; i >= 1; --i) {\n\t\trep(j, 3) {\n\t\t\tnx[i-1][j] = nx[i][j];\n\t\t}\n\t\tnx[i-1][acc[i]] = i;\n\t}\n\n\tbool alt = true;\n\trep(i, n-1) {\n\t\tif (s[i] == s[i+1]) {\n\t\t\talt = false;\n\t\t}\n\t}\n\n\tif (alt) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tdp[0] = 1;\n\n\trep(i, n) {\n\t\tfor (int c = 1; c <= 2; ++c) {\n\t\t\tint m = (acc[i] + c) % 3;\n\t\t\tif (nx[i][m] <= n) {\n\t\t\t\tint p = nx[i][m];\n\t\t\t\tdp[p] = (dp[p] + dp[i]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (acc[n] == acc[i]) {\n\t\t\tans = (ans + dp[i]) % MOD;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 100005;\nconst int MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n;\nchar str[MX];\nint f[MX], s[MX];\nint nxt[MX];\n\nint main()\n{\n\tscanf(\"%s\", str+1);\n\tn = strlen(str+1);\n\tbool con = 0;\n\tfor(int i=2; i<=n; i++)\n\t\tif(str[i] == str[i-1])\n\t\t\tcon = 1;\n\tif(!con) puts(\"1\");\n\telse\n\t{\n\t\tnxt[n+1] = n+1;\n\t\tfor(int i=n; i>=1; i--)\n\t\t\tnxt[i] = (str[i]==str[i+1]) ? i+1 : nxt[i+1];\n\t\tf[0] = 1;\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tf[i+1] = (f[i+1] + f[i]) % MOD;\n\t\t\tf[nxt[i+1]] = (f[nxt[i+1]] + f[i]) % MOD;\n\t\t\t//if the sum of subsequence between i and nxt[i] is 0,\n\t\t\t//it means that we add the contribution of i to the neares\n\t\t\t//j which i<j and sum[i...j]!=0, by repeatedly jumping nxt[].\n\t\t\t//the subsequence s[i...nxt[i]] can always be eliminated by canceling characters with neibours.\n\t\t\t//it can be proved that one can never construct a input such that nxt[nxt[...[i]]] is not the nearest one.\n\t\t\t//the meaning of nxt[] is explained in the tutorial.\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=n; i>=1; i--)\n\t\t{\n\t\t\ts[i] = (s[i+1] + str[i+1] - 'a' + 1) % 3;\n\t\t\tif(s[i] == 0) ans = (ans + f[i]) % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\nconst int mod = 1e9 + 7;\n\nchar s[N]; int pre[N], dp[N], nxt[3];\n\nint main() {\n    scanf(\"%s\", s + 1); int n = strlen(s + 1);\n    for (int i = 1; i <= n; i++) \n        pre[i] = (pre[i - 1] + s[i] - 'a' + 1) % 3;\n    bool flag = true;\n    for (int i = 2; i <= n; i++)\n        if (s[i] == s[i - 1]) {\n            flag = false; break;\n        }\n    if (flag) return puts(\"1\"), 0;\n    nxt[0] = nxt[1] = nxt[2] = n + 1, dp[n + 1] = 1;\n    for (int i = n; i >= 1; i--) {\n        if (pre[i - 1] == pre[n] && i != 1) dp[i] = 1;\n        dp[i] = (dp[i] + dp[i + 1]) % mod;\n        int nw = s[i] - 'a' + 1, t = (pre[i - 1] + 3 - nw) % 3;\n        dp[i] = (dp[i] + dp[nxt[t] + 1]) % mod, nxt[pre[i]] = i;\n    }\n    printf(\"%d\\n\", dp[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 100000\n#define MOD 1000000007\nchar s[MN+5];\nint S[MN+5],t[MN+5][3],f[MN+5];\ninline void rw(int&x,int y){if((x+=y)>=MOD)x-=MOD;}\nint main()\n{\n\tint n,i,j,ans=0;\n\tscanf(\"%s\",s+1);n=strlen(s+1); \n\tfor(i=1;i<n;++i)if(s[i]==s[i+1])break;\n\tif(i==n)return 0*puts(\"1\");\n\tfor(i=1;i<=n;++i)S[i]=(S[i-1]+s[i]-'a'+1)%3;\n\tfor(j=0;j<3;++j)t[n+1][j]=n+1;\n\tfor(i=n;i;t[i][S[i]]=i,--i)for(j=0;j<3;++j)t[i][j]=t[i+1][j];\n\tfor(f[0]=i=1;i<=n;(S[n]-S[i])%3?0:(rw(ans,f[i]),0),++i)\n\t\tfor(j=1;j<3;++j)rw(f[t[i][(S[i-1]+j)%3]],f[i-1]);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nconst int N = 233333,mo=1e9+7;\nchar S[N];int n,f[N],s[N],qz[N],b[N];vector<int> a[3];\nvoid add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\n\nint main(){\n\tscanf(\"%s\",S+1);n=strlen(S+1);rep(i,1,n)s[i]=S[i]-'a'+1;\n\trep(i,1,n)qz[i]=(qz[i-1]+s[i])%3,a[qz[i]].push_back(i);f[0]=1;\n\tfor(int i=n,j=n+1;i>=0;i--){if(s[i]==s[i+1])j=i+1;b[i]=j;}\n\trep(i,0,n-1)rep(j,1,2){\n\t\tif(s[i+1]==j)add(f[i+1],f[i]);\n\t\telse if(SZ(a[(qz[i]+j)%3])&&b[i+1]<=a[(qz[i]+j)%3].back()){\n\t\t\tint k=*lower_bound(a[(qz[i]+j)%3].begin(),a[(qz[i]+j)%3].end(),b[i+1]);\n\t\t\tif(k<=n)add(f[k],f[i]);\n\t\t}\n\t}\n//\trep(i,0,n)printf(\"%d:%d\\n\",i,f[i]);\n\tint res=0;rep(i,0,n-1)if(b[i]<=n&&(qz[n]-qz[i])%3||i==n-1)add(res,f[i]);\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 100500\n#define mod 1000000007\nint n,nt[N],su[N],nt2[N][3],as,dp[N];\nchar s[N];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=1;i<=n;i++){su[i]=(su[i-1]+s[i]-'a'+1)%3;}\n\tnt[n+1]=n+1;nt2[n+1][0]=nt2[n+1][1]=nt2[n+1][2]=n+1;\n\tfor(int i=n;i>=0;i--)\n\t{\n\t\tnt[i]=nt[i+1];nt2[i][0]=nt2[i+1][0];nt2[i][1]=nt2[i+1][1];nt2[i][2]=nt2[i+2][2];\n\t\tif(s[i]==s[i+1])nt[i]=i+1;\n\t\tnt2[i][su[i+1]]=i+1;\n\t}\n\tdp[0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint tp=nt[i]-1;\n\t\tif(nt[tp]==n+1)tp=n;\n\t\tif(s[i+1]=='a')dp[nt2[tp][(2+su[i])%3]]=(dp[nt2[tp][(2+su[i])%3]]+dp[i])%mod;else dp[i+1]=(dp[i+1]+dp[i])%mod;\n\t\tif(s[i+1]=='b')dp[nt2[tp][(1+su[i])%3]]=(dp[nt2[tp][(1+su[i])%3]]+dp[i])%mod;else dp[i+1]=(dp[i+1]+dp[i])%mod;\n\t\tif(!(su[n]-su[i])%3&&i)as=(as+dp[i])%mod;\n\t}\n\tif(nt[0]==n+1)as=1;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　 |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nstring S; int N;\nmint dp[101010];\nint sm[101010], nxt[101010][3];\nint ok[101010], oksm[101010];\nvector<int> idx[3];\n//---------------------------------------------------------------------------------------------------\nint getok(int l, int r) { // [l,r)\n    if (l >= r) return 0;\n\n    int res = oksm[r - 1];\n    if (l) res -= oksm[l - 1];\n    return res;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> S;\n    N = S.length();\n    rep(i, 0, N) {\n        if (S[i] == 'a') sm[i] = 1;\n        else sm[i] = 2;\n    }\n    rep(i, 1, N) sm[i] = (sm[i] + sm[i - 1]) % 3;\n    rep(i, 0, N) idx[sm[i]].push_back(i);\n    rep(i, 0, 3) idx[i].push_back(N);\n\n    rep(i, 0, N - 1) if (S[i] == S[i + 1]) ok[i] = 1;\n    oksm[0] = ok[0];\n    rep(i, 1, N) oksm[i] = oksm[i - 1] + ok[i];\n\n    rep(i, 0, N) {\n        rep(c, 0, 3) {\n            int ng = i, ok = N;\n            while (ng + 1 != ok) {\n                int md = (ng + ok) / 2;\n                int j = *lower_bound(all(idx[c]), md);\n\n                if (getok(i, j)) ok = md;\n                else ng = md;\n            }\n\n            nxt[i][c] = *lower_bound(all(idx[c]), ok);\n        }\n    }\n\n    dp[0] = 1;\n    rep(i, 0, N) {\n        int pre = 0;\n        if (i) pre = sm[i - 1];\n\n        // make 'a'\n        // sm[j] - pre = 1\n        // sm[j] = pre + 1\n        if (S[i] == 'a') dp[i + 1] += dp[i];\n        else {\n            int ai = nxt[i][(pre + 1) % 3];\n            if (ai < N) dp[ai + 1] += dp[i];\n        }\n        \n        // make 'b'\n        // sm[j] - pre = 2\n        // sm[j] = pre + 2\n        if (S[i] == 'b') dp[i + 1] += dp[i];\n        else {\n            int bi = nxt[i][(pre + 2) % 3];\n            if (bi < N) dp[bi + 1] += dp[i];\n        }\n    }\n\n    mint ans = 0;\n    if (oksm[N - 1]) {\n        rep(i, 1, N + 1) if ((sm[N - 1] - sm[i - 1] + 3) % 3 == 0) ans += dp[i];\n    }\n    else ans = 1;\n    \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=100005;\nconst int mo=1000000007;\nint n,ans;\nchar s[N];\nint las[N],S[N];\nint suf[N][3],f[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool fl=0;\n\tFor(i,1,n-1) if (s[i]==s[i-1]) fl=1;\n\tif (!fl) return puts(\"1\"),0;\n\tFor(i,1,n) S[i]=(S[i-1]+s[i]-'a'+1)%3;\n\tFor(i,0,2) suf[n+1][i]=n+1;\n\tRep(i,n,1){\n\t\tFor(j,0,2)\n\t\t\tsuf[i][j]=suf[i+1][j];\n\t\tsuf[i][S[i]]=i;\n\t}\n\tf[0]=1;\n\tFor(i,1,n+1){\n\t\tif (S[i-1]==S[n]&&i!=1) ans=(ans+f[i-1])%mo;\n\t\tint nx=suf[las[i]+1][3-S[i-1]-S[i]];\n\t\tf[i]=(f[i]+f[i-1])%mo;\n\t\tf[nx]=(f[nx]+f[i-1])%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n/*\nbabba\nbaaa\nbba\naa\nb\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n\ntemplate<typename T> class BIT {\nprivate:\n\tint n;\n\tvector<T> bit;\npublic:\n\t// 0_indexed で i 番目の要素に x を加える\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile(i < n){\n\t\t\tbit[i] += x, i += i & -i;\n\t\t}\n\t}\n\t// 0_indexed で [0,i] の要素の和(両閉区間！！)\n\tT sum(int i){\n        if(i<0)return 0;\n\t\ti++;\n\t\tT s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i], i -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tBIT(){}\n\t//初期値がすべて0の場合\n\tBIT(int sz) : n(sz+1), bit(n, 0){}\n\tBIT(vector<T>& v) : n((int)v.size()+1), bit(n, 0){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tadd(i,v[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcout<<sum(i)-sum(i-1)<< \" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t//-1スタート\n\tvoid print_sum(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout<<sum(i-1)<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    bool flag = 1;\n    rep(i,n-1){\n        if(s[i]==s[i+1])flag = 0;\n    }\n    if(flag){\n        cout << 1 << endl;\n        return 0;\n    }\n    vector<mod>dp(n+1);\n    vector<int>a[3];\n    vector<int>b(n+1);\n    int c = 0;\n    rep(i,n){\n        b[i] = c;\n        c += s[i]-'a'+1;\n        c %= 3;\n        a[c].push_back(i+1);\n    }\n    a[0].push_back(n+1);\n    a[1].push_back(n+1);\n    a[2].push_back(n+1);\n    b[n] = c;\n    BIT<int> bit(n+1);\n    rep(i,n-1){\n        if(s[i]==s[i+1]){\n            bit.add(i,1);\n        }\n    } \n    dp[0] = 1;\n    rep(i,n){\n        for(int j=1;j<3;j++){\n            int ca = (b[i]+j)%3;\n            int id = i;\n            while(1){\n                int x = *upper_bound(a[ca].begin(),a[ca].end(),id);\n                id = x;\n                if(x==n+1)break;\n                if(x==i+1){\n                    dp[x] += dp[i];\n                    break;\n                }else{\n                    if(bit.sum(x-1)-bit.sum(i-2)!=0){\n                        dp[x] += dp[i];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    mod res = 0;\n    rep(i,n+1){\n        int k = (3+b[n]-b[i])%3;\n        if(k==0){\n            if(i==0)continue;    \n            res += dp[i];\n        }\n        // cerr << i << \" \" << dp[i] << \" \"  << res << endl;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 1e5 + 10;\nconst ll MOD = 1e9 + 7;\n\nint N, S[MAX_N], pref_sum[MAX_N], next_sum[MAX_N][3];\nll F[MAX_N];\n\nvoid init() {\n    char _S[MAX_N]; scanf(\"%s\", _S + 1); N = strlen(_S + 1);\n    for (int i = 1; i <= N; i++) S[i] = _S[i] - 'a' + 1;\n\n    bool flag = true;\n    for (int i = 2; i <= N; i++) flag &= S[i] != S[i - 1];\n    if (flag) {\n        printf(\"1\\n\");\n        exit(0);\n    }\n\n    for (int i = 1; i <= N; i++) pref_sum[i] = (pref_sum[i - 1] + S[i]) % 3;\n    for (int i = 0; i < 3; i++) next_sum[N + 1][i] = N + 1;\n    for (int i = N; i; i--) {\n        for (int j = 0; j < 3; j++) next_sum[i][j] = next_sum[i + 1][j];\n        next_sum[i][pref_sum[i]] = i;\n    }\n}\n\nvoid solve() {\n    ll ans = 0;\n    F[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= 2; j++) {\n            int t = next_sum[i][(pref_sum[i - 1] + j) % 3];\n            if (t <= N) (F[t] += F[i - 1]) %= MOD;\n        }\n        if (pref_sum[N] != pref_sum[i - 1]) (ans += F[i - 1]) %= MOD;\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    init();\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5 + 10, mo = 1e9 + 7;\nchar s[N];\nint n;\nll ksm(ll x,ll y) {\n\tll ret = 1; for(; y; y>>=1) {\n\t\tif (y & 1) ret = ret * x % mo;\n\t\tx = x * x % mo;\n\t}\n\treturn ret;\n}\n\nll f[N][3];\nint main() {\n\tscanf(\"%s\",s+1);\n\tn = strlen(s+1);\n\tint m=0;\n\tfor(int i=1;i<=n;i++)m=(m+s[i]-'0')%3;\n\n\tint can=0;\n\tfor(int i = 2; i <= n; i++) if (s[i] == s[i - 1]) can = 1;\n\tif (can == 0) printf(\"0\\n\");\n\telse {\n\t\tll ans = 0;\n\t\tf[0][0]=1;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tf[i][0]=(f[i-1][2]+f[i-1][1])%mo;\n\t\t\tf[i][1]=(f[i-1][0]+f[i-1][2])%mo;\n\t\t\tf[i][2]=(f[i-1][0]+f[i-1][1])%mo;\n\t\t\tans=(ans+f[i][m])%mo;\n\t\t}\n\t\tcout<<(ans+1+mo)%mo<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int N = 100005, P = 1e9+7;\nchar s[N]; int sum[N], f[N], pre[N], n, flag;\n\nint main() {\n\tscanf(\"%s\", &s); n = strlen(s);\n\tfor (int i = 1; i < n; ++i) //判断是否可以操作\n\t\tif (s[i] == s[i-1]) { flag = 1; break; }\n\tif (!flag) { puts(\"1\"); return 0; }\n\tfor (int i = 0; i < n; ++i) sum[i+1] = (s[i] == 'a' ? 1 : 2);\n\tfor (int i = 2; i <= n; ++i) sum[i] += sum[i-1];\n\tf[n] = 1;\n\tfor (int i = 0; i <= 2; ++i) pre[i] = (i == sum[n] ? n : n + 1);\n\tfor (int i = n - 1; i; --i) {\n\t\tf[i] = (sum[i] == sum[n]); //后面的p值是否为0\n\t\tfor (int j = 1; j <= 2; ++j)\n\t\t\tf[i] = (f[i] + f[pre[(sum[i]+j)%3]]) % P; //后面加一段A或B\n\t\tpre[sum[i]] = i; //记录该p值上一次出现的位置\n\t}\n\tprintf(\"%d\\n\", (f[pre[1]] + f[pre[2]]) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nconst int mod=1000000007;\nint n,a[N],nxt[N],sum[N],f[N],ans;\nchar s[N];\n\nvoid upd(int &x,int y){x=(x+y)%mod;}\n\nint main(){\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tfor (int i=n;i;--i){\n\t\ta[i]=s[i]=='a'?1:2;\n\t\tnxt[i]=a[i]==a[i+1]?i+1:nxt[i+1];\n\t\tsum[i]=(sum[i+1]+a[i])%3;\n\t}\n\tif (!nxt[1]){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tf[0]=1;\n\tfor (int i=0;i<=n;++i){\n\t\tupd(f[i+1],f[i]);\n\t\tif (nxt[i+1]) upd(f[nxt[i+1]],f[i]);\n\t\tif (i&&!sum[i+1]) upd(ans,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\n\n#define M 100005\n#define mod 1000000007\nint n;\nint f[M];\nchar a[M];\ninline void inc(int &x,int y) {x+=y,x-=x>=mod?mod:0;}\n\nint main () {\n\t//freopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%s\",a+1);\n\tn=strlen(a+1);\n\tbool t=0;\n\tfor1(1,n-1,i) if(a[i]==a[i+1]) {t=1;break;}\n\tif(!t) return puts(\"1\"),0;\n\tint ans=0;\n\tint s=0,pre[3]={0,-1,-1};\n\tf[0]=1;\n\tfor1(1,n,i) {\n\t\ts=(s+2-(a[i]=='a'))%3;\n\t\tif(!s&&i<n) f[i]=1;\n\t\t++s,s%=3;\n\t\tif(pre[s]!=-1) inc(f[i],f[pre[s]]);\n\t\t++s,s%=3;\n\t\tif(pre[s]!=-1) inc(f[i],f[pre[s]]);\n\t\t++s,s%=3;\n\t\tpre[s]=i;\n\t}\n\tcout<<f[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint add(int x,int y){return x+y<3?x+y:x+y-3;}\nconst int mod=1e9+7;\nint n;\nchar s[100100];\nint a[100100];\n\nint sum[100100];\nint nd[100100];\nint nxt[100100][3];\nint dp[100100];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=s[i]-'a'+1;\n\t\tsum[i]=add(sum[i-1],a[i]);\n\t}\n\ta[n+2]=4;\n\tnxt[n][0]=nxt[n][1]=nxt[n][2]=n+1;\n\tnxt[n+1][0]=nxt[n+1][1]=nxt[n+1][2]=n+1;\n\tnd[n+1]=n+1;\n\tfor(int i=n;i>=0;--i)\n\t{\n\t\tmemcpy(nxt[i],nxt[i+1],sizeof(nxt[i+1]));\n\t\tnxt[i][sum[i]]=i;\n\t\tnd[i]=nd[i+1];\n\t\tif(a[i+1]==a[i+2])nd[i]=i+2;\n\t}\n\tdp[0]=1;\n\tint p1,p2;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tp1=nxt[nd[i]][add(sum[i],1)];\n\t\tp2=nxt[nd[i]][add(sum[i],2)];\n\t\tif(a[i+1]!=1)dp[p1]=(dp[p1]+dp[i])%mod;\n\t\tif(a[i+1]!=2)dp[p2]=(dp[p2]+dp[i])%mod;\n\t\tdp[i+1]=(dp[i+1]+dp[i])%mod;\n\t}\n\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(add(sum[n],3-sum[i])==0)\n\t\t\t(ans+=dp[i])%=mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int Max_N(100050);\nconst int MOD(1000000000 + 7);\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nint N, F[Max_N], Last[3];\nchar S[Max_N]; \n\nint main()\n{\n\tscanf(\"%s\", S + 1), N = strlen(S + 1);\n\tbool special = true;\n\tfor (int i = 2;i <= N;++i)\n\t\tif (S[i] == S[i - 1])\n\t\t\tspecial = false;\n\tif (special)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tLast[0] = 0, Last[1] = Last[2] = -1, F[0] = 1;\n\tfor (int i = 1, Sum = 0, a;i <= N;++i)\n\t{\n\t\t(Sum += (S[i] - 'a' + 1)) %= 3;\n\t\tif (i < N && Sum == 0)\n\t\t\tF[i] = 1;\n\t\ta = ((Sum - 1) % 3 + 3) % 3;\n\t\tif (Last[a] != -1)\n\t\t\tupd(F[i], F[Last[a]]);\n\t\ta = ((Sum - 2) % 3 + 3) % 3;\n\t\tif (Last[a] != -1)\n\t\t\tupd(F[i], F[Last[a]]);\n\t\tLast[Sum] = i;\n\t}\n\tprintf(\"%d\", F[N]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 1e5 + 7 , MOD = 1e9 + 7;\nchar str[_]; int L , dp[_] , pos[_][3] , sum[_];\n\nvoid inc(int &a , int b){a = a + b >= MOD ? a + b - MOD : a + b;}\n\nint main(){\n\tscanf(\"%s\" , str + 1); L = strlen(str + 1); bool flg = 1;\n\tfor(int i = 1 ; i <= L ; ++i) sum[i] = (sum[i - 1] + str[i] - 'a' + 1) % 3;\n\tfor(int i = 2 ; i <= L ; ++i) flg &= str[i] != str[i - 1];\n\tif(flg){puts(\"1\"); return 0;}\n\tpos[L + 1][0] = pos[L + 1][1] = pos[L + 1][2] = L + 1;\n\tfor(int i = L ; i ; --i){\n\t\tfor(int j = 0 ; j < 3 ; ++j) pos[i][(j + str[i] - 'a' + 1) % 3] = pos[i + 1][j];\n\t\tpos[i][str[i] - 'a' + 1] = i;\n\t}\n\tint p = dp[0] = 1 , ans = 0;\n\tfor(int i = 0 ; i < L ; ++i){\n\t\tinc(dp[i + 1] , dp[i]);\n\t\twhile(p <= L && (p == i + 1 || str[p] != str[p - 1])) ++p;\n\t\tinc(dp[pos[p][(!(str[i + 1] - 'a') + 4 - (sum[p - 1] - sum[i])) % 3]] , dp[i]);\n\t}\n\tfor(int i = 1 ; i <= L ; ++i) inc(ans , (sum[i] == sum[L]) * dp[i]);\n\tcout << ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\nint p = 1000000007;\n#define vel vector<int>\n#define rep(i,n) for(int i=0;i<n;i++)\nint main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tvector<vel> lis(3);\n\tvel sum(n + 1);\n\tbool fl = true;\n\trep(i, n) {\n\t\tlis[sum[i]].push_back(i);\n\t\tsum[i + 1] = sum[i] + (s[i] - 'a') + 1; sum[i + 1] %= 3;\n\t\tif (i % 2 == 0 xor s[i] == s[0]) { fl = false; }\n\t}\n\tif (fl) { cout << 1 << endl; return 0; }\n\tvel dp(n);\n\tdp[0] = 1;\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (sum[i] != sum[n]) { ans += dp[i]; ans %= p; }\n\t\tint pla = (sum[i] + 1) % 3;\n\t\tauto itr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; dp[*itr] %= p; }\n\t\tpla++; pla %= 3;\n\t\titr = lower_bound(lis[pla].begin(), lis[pla].end(), i);\n\t\tif (itr != lis[pla].end()) { dp[*itr] += dp[i]; dp[*itr] %= p; }\n\t}\n\tcout << ans % p << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define gc getchar\n#define pc putchar\ninline ll rd(){\n    ll x=0,f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 1e5+233;\nconst int mod = 1e9+7;\nvoid add(int &x,int v){\n\tx+=v;\n\tif(x>=mod) x-=mod;\n}\nchar t[maxn]; \nint n,ans,s[maxn],dp[maxn],nxt[maxn][3];\nint main() {\n\tscanf(\"%s\",t+1);n=strlen(t+1);\n\tbool flag=0;\n\tRep(i,1,n-1) if (s[i]==s[i+1]) flag=1;\n\tif (!flag) return puts(\"1\"),0;\n\tRep(i,1,n) s[i]=t[i]-'a'+1;\n\tRep(i,1,n+1) s[i]=(s[i]+s[i-1])%3;\n\tRep(i,0,2) nxt[n+1][i]=n+1;\n\tDep(i,n,1){\n\t\tRep(j,0,2) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][s[i]]=i;\n//\t\tprintf(\"[%d %d %d]\\n\",nxt[i][0],nxt[i][1],nxt[i][2]);\n\t}\n\tdp[1]=1;\n\tRep(i,1,n+1){\n//\t\tprintf(\"dp[%d] = %d\\n\",i,dp[i]);\n\t\tRep(k,1,2)\n\t\t\tif(nxt[i][(s[i-1]+k)%3] != n+1)\n\t\t\t\tadd(dp[nxt[i][(s[i-1]+k)%3]+1],dp[i]);\n\t\tif(s[i-1]==s[n]&&i!=1) add(ans,dp[i]);\n\t}\n\twriteln(ans);\n}\n\n//0 1 2 3 4 5 \n//0 1 2 0 1 X\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstring str;\nll dp[100005];\nint rui[100005];\nint n;\nvector<int>adj;\nvector<int>pos[3];\nint las = -1;\nll rec(int beg){\n\tif(beg == n) return 1;\n\tif(dp[beg] >= 0) return dp[beg];\n\t\n\tchar ch = str[beg];\n\tll add = rec(beg+1);\n\tif(beg+1 != n && rui[n-1] == rui[beg] && las >= beg) add = (add+1)%mod;\n\tif(las == beg){\n\t\tint zan = n-1-beg;\n\t\tif(zan > 0 && zan%2 == 0) zan -= 2;\n\t\tadd = (add+1LL*(zan/2))%mod;\n\t}\n\tint f = POSL(adj,beg);\n\tif(f != adj.size()){\n\t\tint rg = adj[f]+1;\n\t\tint need = (str[beg] == 'a'?1:2);\n\t\tint target = (rui[beg]+need)%3;\n\t\tint h = POSL(pos[target],rg);\n\t\tif(h != pos[target].size()){\n\t\t\tint en = pos[target][h];\n\t\t\tadd = (add+rec(en+1))%mod;\n\t\t\tif(en+1 != n && rui[n-1] == rui[en]) add = (add+1)%mod;\n\t\t\tif(las <= en){\n\t\t\t\tint zan = n-1-en;\n\t\t\t\tif(zan > 0 && zan%2 == 0) zan -= 2;\n\t\t\t\tadd = (add+1LL*(zan/2))%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[beg] = add;\n}\nint main(){\n\tcin>>str;\n\tn = str.size();\n\tfor(int i=1;i<n;i++){\n\t\tif(str[i-1] == str[i]){\n\t\t\tadj.pb(i-1);\n\t\t\tlas = i-1;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\trui[i] = (str[i]=='a'?1:2);\n\t\tif(i) rui[i] = (rui[i]+rui[i-1])%3;\n\t\tpos[rui[i]].pb(i);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tll ans = rec(0);\n\tans = (ans%mod+mod)%mod;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=100005;\nint fl,n,ans,dp[N],pre[N],nxt[N][3];\nchar s[N];\nvoid up(int &x,int y){x=x-mod+y;x=(x<0)?x+mod:x;}\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfl=1;\n\tfor (int i=1;i<n;i++) fl&=(s[i]!=s[i+1]);\n\tif (fl) return puts(\"1\"),0;\n\tfor (int i=1;i<=n;i++) pre[i]=(pre[i-1]+(s[i]=='b')+1)%3;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tfor (int j=0;j<=2;j++) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][pre[i]]=i;\n\t}\n\tdp[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=2;j++)\n\t\t{\n\t\t\tint t=nxt[i][(pre[i-1]+j)%3];\n\t\t\tif (t) up(dp[t],dp[i-1]);\n\t\t}\n\t\tif (pre[i]==pre[n]) up(ans,dp[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n// #define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nsigned main(){\n\tstring s;\n\tcin>>s;\n\tint n=s.size(),MOD=1000000007;\n\t\n\tbool h=true;\n\trep(i,n-1)if(s[i]==s[i+1])h=false;\n\tif(h){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\t\n\tvi c(n+1);\n\trep(i,n)c[i+1]=s[i]-'a'+1;\n\trep(i,n)(c[i+1]+=c[i])%=3;\n\t\n\tvi dp(n+1);\n\tdp[0]=1;\n\trep(i,n)if(dp[i]){\n\t\trep(q,2){\n\t\t\tif(s[i]-'a'==q){\n\t\t\t\t(dp[i+1]+=dp[i])%=MOD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\th=false;\n\t\t\tloop(j,i+1,n+1){\n\t\t\t\tif(j-i-1&&s[j-1]==s[j-2])h=true;\n\t\t\t\tif(h&&q+1==(c[j]+3-c[i])%3){\n\t\t\t\t\t(dp[j]+=dp[i])%=MOD;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint out=0;\n\trep(i,n)if((c[n]+3-c[i+1])%3==0)(out+=dp[i+1])%=MOD;\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010, mod = 1000000007;\nchar s[N];\nint g[N], f[N], n, sum[N];\n\nint main() {\n  scanf(\"%s\", s + 1);\n  n = (int)strlen(s + 1);\n  g[n + 1] = n + 1;\n  sum[n + 1] = 0;\n  for (int i = n; i; i--) {\n    g[i] = s[i] == s[i + 1] ? i + 1 : g[i + 1];\n    sum[i] = (sum[i + 1] + s[i] - 'a' + 1) % 3;\n  }\n  if (g[1] == n + 1) {\n    puts(\"1\");\n    return 0;\n  }\n  f[0] = 1;\n  int ans = 0;\n  for (int i = 0; i <= n; i++) {\n    if (i && sum[i + 1] == 0) {\n      ans = (ans + f[i]) % mod;\n    }\n    f[i + 1] = (f[i + 1] + f[i]) % mod;\n    f[g[i + 1]] = (f[g[i + 1]] + f[i]) % mod;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define for1(a,b,i) for(int i=a;i<=b;++i)\n#define FOR2(a,b,i) for(int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n    int f=1,sum=0;\n    char x=getchar();\n    for(;(x<'0'||x>'9');x=getchar()) if(x=='-') f=-1;\n    for(;x>='0'&&x<='9';x=getchar()) sum=sum*10+x-'0';\n    return f*sum;\n}\n\n#define M 105\n#define mod 1000000007\nint ans;\nint js[M],ni[M],inv[M];\n\nmap <string,int> st;\n\ninline int qpow(int x,int ci) {\n    int sum=1;\n    for(;ci;ci>>=1,x=1ll*x*x%mod)\n        if(ci&1) sum=1ll*sum*x%mod;\n    return sum;\n}\n\ninline void inc(int &x,int y) {x+=y,x-=x>=mod?mod:0;}\n\ninline void dfs(string s) {\n    if(st.count(s)) return;\n    st[s]=1;\n    int t=0;\n    int len=s.size();\n    for1(0,len-2,i) {\n        if(s[i]!=s[i+1]) continue;\n        int opt=s[i]-'a';\n        opt^=1;\n        string to;\n        for1(0,i-1,j) to+=s[j];\n        to+=char(opt+'a');\n        for1(i+2,len-1,j) to+=s[j];\n        dfs(to);\n    }\n}\n\nint main () {\n   // freopen(\"a.in\",\"r\",stdin);\n    js[0]=1;\n    for1(1,100,i) js[i]=1ll*js[i-1]*i%mod;\n    ni[100]=qpow(js[100],mod-2);\n    FOR2(100,1,i) ni[i-1]=1ll*ni[i]*i%mod;\n    for1(1,100,i) inv[i]=1ll*ni[i]*js[i-1]%mod;\n    string s;\n    cin>>s;\n    dfs(s);\n    /*\n    for(map <string,int>::iterator it=st.begin();it!=st.end();it++) {\n        cout<<it->first<<\" \"<<it->second<<endl;\n    }\n    */\n    cout<<st.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#ifdef MAROON_LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\t//a=((ll)a+b)%mod;\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\t//a=((ll)a-b%mod+mod)%mod;\n\ta-=b;\n\tif(a<0)a+=mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\twhile(p){\n\t\tif(p&1)mult(s,a);\n\t\tmult(a,a);\n\t\tp>>=1;\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Vmax=1000010;\nint fact[Vmax],factInv[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1];\n\t\tmult(fact[i],i);\n\t}\n\tfactInv[Vmax-1]=modInv(fact[Vmax-1]);\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1];\n\t\tmult(factInv[i],i+1);\n\t}\n}\nint Choose(int n,int k){\n\treturn ll(fact[n])*factInv[n-k]%mod*factInv[k]%mod;\n}\nint Binom(int a,int b){\n\treturn ll(fact[a+b])*factInv[a]%mod*factInv[b]%mod;\n}\n\nvi Waf(string s){\n\tint n=s.size();\n\tvi res(n,0);\n\tres[n-1]=1;\n\tfor(int i=n-2;i>=0;i--)\n\t\tif(s[i]==s[i+1]){\n\t\t\tREP(j,i+1)\n\t\t\t\tres[j]=1;\n\t\t\tbreak;\n\t\t}\n\tcerr<<res<<endl;\n\treturn res;\n}\n\nsigned main(){\n\tstring s=readString();\n\tint n=s.size();\n\tvi sum(n+1,0);\n\tREP(i,n){\n\t\tint c=s[i]=='a'?1:2;\n\t\tsum[i+1]=(sum[i]+c)%3;\n\t}\n\tcerr<<endl;\n\tvector<vi> to(n+1,vi(3,0));\n\tint last[3]={-1,-1,-1};\n\tfor(int i=n;i>=0;i--){\n\t\tREP(k,3)\n\t\t\tto[i][k]=last[(sum[i]+k)%3];\n\t\tlast[sum[i]]=i;\n\t}\n\tcerr<<to<<endl;\n\tcerr<<endl;\n\tvi use=Waf(s);\n\tint ans=0;\n\tvi dp(n+1,0);\n\tdp[0]=1;\n\tREP(i,n){\n\t\tif(use[i]&&sum[i]!=sum[n]){\n\t\t\tcerr<<i<<\" \"<<dp[i]<<endl;\n\t\t\tadd(ans,dp[i]);\n\t\t}\n\t\tFOR(k,1,3)\n\t\t\tif(to[i][k]!=-1){\n\t\t\t\tcerr<<i<<\"->\"<<to[i][k]<<endl;\n\t\t\t\tadd(dp[to[i][k]],dp[i]);\n\t\t\t\tif(to[i][k]<n&&use[i]&&!use[to[i][k]]){\n\t\t\t\t\tint len=n-to[i][k];\n\t\t\t\t\tint w=dp[i];\n\t\t\t\t\tmult(w,(len-1)/2);\n\t\t\t\t\tadd(ans,w);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tcerr<<dp<<endl;\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 1000000007\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint n,a[N],lst[3];\nll f[N];\nchar s[N];\n\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    int ok=0;\n    rep(i,1,n)\n    {\n        a[i]=(a[i-1]+(s[i]-'a')+1)%3;\n        if (s[i]==s[i-1]) ok=1;\n    }\n    if (!ok) {puts(\"1\");return 0;}\n    rep(i,1,n)\n    {\n        f[i]=(f[lst[0]]+f[lst[1]]+f[lst[2]])%maxd;\n        f[i]=(f[i]-f[lst[a[i]]]+maxd)%maxd;\n        if (a[i]) f[i]++;lst[a[i]]=i;\n    }\n    printf(\"%lld\\n\",f[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n  if(abs(a) < eps && abs(b) < eps) return 0;\n  else if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n  if(a < b) return -1;\n  return 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n  if(a < b) return -1;\n  if(a == b) return 0;\n  return 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n  if(na == 0) return 0;\n  int be = 0, en = na - 1;\n  if(*a <= *(a + na - 1)){\n    if(f_lb == 0) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != 1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != -1) en = mid;\n      else be = mid + 1;\n    }\n    if(f_small && jud(*(a + be), val) == 1) be--;\n    if(!f_small && jud(*(a + be), val) == -1) be++;\n  } else {\n    if(f_lb) while(be < en){\n      int mid = (be + en + 1) / 2;\n      if(jud(*(a + mid), val) != -1) be = mid;\n      else en = mid - 1;\n    }else while(be < en){\n      int mid = (be + en) / 2;\n      if(jud(*(a + mid), val) != 1) en = mid;\n      else be = mid + 1;\n    }\n    if(!f_small && jud(*(a + be), val) == -1) be--;\n    if(f_small && jud(*(a + be), val) == 1) be++;\n  }\n  return be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n  if(m < 0) return 0;\n  long long ans = 1;\n  long long k = n;\n  while(m){\n    if(m & 1) {\n      ans *= k;\n      if(mod) ans %= mod;\n    }\n    k *= k;\n    if(mod) k %= mod;\n    m >>= 1;\n  }\n  return ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n  if(mod == -1) mod = MOD;\n  a += b;\n  while(a >= mod) a -= mod;\n  while(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    cerr << arr[i] << ' ';\n  cerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n  for(int i = 0; i < (int)arr.size(); i++)\n    output1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 100100;\nconst int mod = MOD;\nchar orig[maxn];\nint sum_mod[maxn], nxt[maxn][4];\nint dp[maxn];\n\nint main() {\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n  ios_base::sync_with_stdio(0);\n  #ifdef DEBUG //......................................................................................................\n  freopen(\"input.txt\", \"r\", stdin);\n  #endif //...........................................................................................................\n\n  scanf(\"%s\", orig);\n  int n = strlen(orig);\n  nxt[n][0] = n;\n  nxt[n][1] = nxt[n][2] = nxt[n][3] = -1;\n  for (int i = n - 1; i >= 0; i--) {\n    memcpy(nxt[i], nxt[i + 1], sizeof(nxt[i]));\n    sum_mod[i] = sum_mod[i + 1] + (orig[i] == 'a' ? 2 : 1);\n    sum_mod[i] %= 3;\n    nxt[i][sum_mod[i]] = i;\n    if (orig[i] == orig[i + 1]) nxt[i][3] = i + 2;\n  }\n\n  dp[0] = 1;\n  ll ans = 0;\n  for (int i = 0; i <= n; i++) {\n    if (nxt[i][3] == -1) {\n      add(ans, dp[i]);\n      continue;\n    }\n    add(dp[i + 1], dp[i]);\n    int cate = (sum_mod[i] + 1) % 3;\n    if (orig[i] == 'a') cate = (sum_mod[i] + 2) % 3;\n    int nxt_loc = nxt[nxt[i][3]][cate];\n    if (nxt_loc != -1) {\n      add(dp[nxt_loc], dp[i]);\n      if (nxt[nxt_loc][3] == -1) {\n        int cnt = n - nxt_loc;\n        if (orig[i] == orig[nxt_loc]) {\n          cnt = (n - nxt_loc) / 2;\n          if (sum_mod[i]) add(ans, mod - dp[i]);\n        } else {\n          if (nxt[i + 1][3] != -1) {\n            cnt = (n - nxt_loc) / 2;\n            if (sum_mod[i] && sum_mod[i + 1] != 0)\n              add(ans, mod - dp[i]);\n          } else {\n            if (sum_mod[i]) {\n              add(ans, mod - dp[i]);\n            }\n          }\n        }\n        add(ans, 1ll * cnt * dp[i]);\n      }\n    }\n    if (sum_mod[i]) {\n      add(ans, dp[i]);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 100500\n#define mod 1000000007\nint n,nt[N],su[N],nt2[N][3],as,dp[N];\nchar s[N];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=1;i<=n;i++){su[i]=(su[i-1]+s[i]-'a'+1)%3;}\n\tnt[n+1]=n+1;nt2[n+1][0]=nt2[n+1][1]=nt2[n+1][2]=n+1;\n\tfor(int i=n;i>=0;i--)\n\t{\n\t\tnt[i]=nt[i+1];nt2[i][0]=nt2[i+1][0];nt2[i][1]=nt2[i+1][1];nt2[i][2]=nt2[i+1][2];\n\t\tif(s[i]==s[i+1])nt[i]=i+1;\n\t\tnt2[i][su[i+1]]=i+1;\n\t}\n\tdp[0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint tp=nt[i]-1;\n\t\tif(s[i+1]=='a')dp[nt2[tp][(2+su[i])%3]]=(dp[nt2[tp][(2+su[i])%3]]+dp[i])%mod;else dp[i+1]=(dp[i+1]+dp[i])%mod;\n\t\tif(s[i+1]=='b')dp[nt2[tp][(1+su[i])%3]]=(dp[nt2[tp][(1+su[i])%3]]+dp[i])%mod;else dp[i+1]=(dp[i+1]+dp[i])%mod;\n\t\tif(!(su[n]-su[i])%3&&i)as=(as+dp[i])%mod;\n\t}\n\tif(nt[0]==n+1)as=1;\n\tprintf(\"%d\\n\",as);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\nchar s[100010];\nint n,f[100010],sum[100010],last[3],nxt[100010][3],tmp[3],ans;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool flag=0;\n\tfor(int i=1;i<n;++i)flag|=s[i]==s[i+1];\n\tif(!flag)return printf(\"1\"),0;\n\tfor(int i=1;i<=n;++i)sum[i]=sum[i-1]+(s[i]=='a'?1:2);\n\tlast[0]=last[1]=last[2]=n+1;\n\tfor(int i=n;i;--i)\n\t{\n\t\tfor(int j=0;j<=2;++j)tmp[(s[i]-'a'+1+j)%3]=last[j];\n\t\tfor(int j=0;j<=2;++j)last[j]=tmp[j];\n\t\tlast[s[i]-'a'+1]=i;\n\t\tfor(int j=0;j<=2;++j)nxt[i][j]=last[j];\n\t}\n/*\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfor(int j=0;j<=2;++j)printf(\"%d \",nxt[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tf[0]=1;\n\tfor(int i=0,r=0;i<n;++i)\n\t{\n\t\tif(r<i+2)\n\t\t{\n\t\t\tr=i+2;\n\t\t\twhile(r<=n&&s[r]!=s[r-1])++r;\n\t\t}\n\t//\tprintf(\"%d %d %d %d\\n\",i,r,nxt[r][((1+sum[i]-sum[r-1])%3+3)%3],nxt[r][((2+sum[i]-sum[r-1])%3+3)%3]);\n\t\tif(s[i+1]=='a')add(f[i+1],f[i]);\n\t\telse if(r<=n)add(f[nxt[r][((1+sum[i]-sum[r-1])%3+3)%3]],f[i]);\n\t\tif(s[i+1]=='b')add(f[i+1],f[i]);\n\t\telse if(r<=n)add(f[nxt[r][((2+sum[i]-sum[r-1])%3+3)%3]],f[i]);\n\t}\n\tfor(int i=1;i<=n;++i)if((sum[n]-sum[i])%3==0)add(ans,f[i]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005,M=1e9+7;\nint sum[N],dp[N],nxt[N][3];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tfor (int i=1;i<=n;i++)sum[i]=(sum[i-1]+s[i]-'a'+1)%3;\n\tfor (int i=0;i<3;i++)nxt[n+1][i]=n+1;\n\tfor (int i=n;i;i--)\n\t\tfor (int j=0;j<3;j++)\n\t\t\tif (j==sum[i])nxt[i][j]=i;\n\t\t\telse nxt[i][j]=nxt[i+1][j];\n\tdp[0]=1;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=1;j<3;j++)\n\t\t\t(dp[nxt[i+1][(j+sum[i])%3]]+=dp[i])%=M;\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (sum[i]==sum[n])(ans+=dp[i])%=M;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=1e5+50;\nint n;\nint f[maxn];\nint nex[maxn];\nint sum[maxn];\nchar s[maxn];\nvector<int> pos[3];\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int idx(char c)\n{\n\treturn c=='a'?1:2;\n}\nint solve()\n{\n\tbool flag=true;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(s[i]==s[i+1])\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag)\n\t{\n\t\treturn 1;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tsum[i]=(sum[i-1]+idx(s[i]))%3;\n\t\tpos[sum[i]].push_back(i);\n\t}\n\tnex[n]=n+1;\n\tfor(int i=n-1;i>=0;--i)\n\t{\n\t\tnex[i]=s[i]==s[i+1]?i+1:nex[i+1];\n\t}\n\tf[0]=1;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tf[i+1]=add(f[i+1]+f[i]);\n\t\tint c=idx('a'+'b'-s[i+1]);\n\t\tconst vector<int> &v=pos[(sum[i]+c)%3];\n\t\tint p=lower_bound(v.begin(),v.end(),nex[i])-v.begin();\n\t\tif(p!=int(v.size()))\n\t\t{\n\t\t\tf[v[p]]=add(f[v[p]]+f[i]);\n\t\t}\n\t}\n\tint an=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(sum[i]==sum[n])\n\t\t{\n\t\t\tan=add(an+f[i]);\n\t\t}\n\t}\n\treturn an;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n\nusing namespace std;\nconst int maxn = 1e5+5;\nint mod = 1e9+7;\nvoid up(int &x,int y) { x+=y; if(x>=mod)x-=mod; }\nint n;\nchar ss[maxn];\nint sm[maxn],f[maxn],nt[3];\nint main() {\n\tscanf(\"%s\",&ss[1]);\n\tn = strlen(ss+1);\n\tbool fl = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tsm[i] = (sm[i-1] + ss[i]-'a'+1)%3;\n\t}\n\tfor(int i=1;i<n;i++) fl |= (ss[i]==ss[i+1]);\n\tif(!fl) {\n\t\tputs(\"1\"); return 0;\n\t}\n\tf[n] = 1;\n\tfor(int i=0;i<3;i++) nt[i] = n+1;\n\tnt[sm[n]] = n;\n\tfor(int i=n-1;i>=1;i--) {\n\t\tif(sm[i]==sm[n]) f[i] = 1;\n\t\tup(f[i],f[nt[(sm[i]+1)%3]]);\n\t\tup(f[i],f[nt[(sm[i]+2)%3]]);\n\t\tnt[sm[i]] = i;\n\t}\n\tprintf(\"%d\",(f[nt[1]]+f[nt[2]])%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstring s;\nllint sum[100005], pos[100005];\nset<llint> S[3], T;\nllint dp[100005];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> s;\n\tllint n = s.size();\n\ts = \"#\" + s;\n\t\n\tS[0].insert(0);\n\tfor(int i = 1; i <= n; i++){\n\t\tsum[i] = (sum[i-1] + s[i]-'a'+1) % 3;\n\t\tS[sum[i]].insert(i);\n\t}\n\tfor(int i = 2; i <= n; i++){\n\t\tif(s[i-1] == s[i]) T.insert(i);\n\t}\n\tif(T.size() == 0){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i < 3; i++) S[i].insert(inf);\n\tT.insert(inf);\n\t\n\tdp[0] = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tdp[i+1] += dp[i], dp[i+1] %= mod;\n\t\tllint lb = *T.lower_bound(i+2), c = 3 - (s[i+1]-'a'+1);\n\t\tif(lb > n) continue;\n\t\tllint p = *S[(sum[i]+c)%3].lower_bound(lb);\n\t\tif(p <= n) dp[p] += dp[i], dp[p] %= mod;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(sum[i] == sum[n]) ans += dp[i], ans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\t/*for(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}cout << endl;\n\t}*/\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define ll long long\n#define db double\n#define ull unsigned long long\n#define uint unsigned int\n#define FIO \"\"\n#define dbug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename Y> inline bool updmin(Y &a, Y b){if (a > b) {a = b; return 1;} return 0;}\ntemplate <typename Y> inline bool updmax(Y &a, Y b){if (a < b) {a = b; return 1;} return 0;}\ntemplate <typename Y> inline Y abs(Y a){if (a < 0) a = -a; return a;}\ntemplate <typename Y> inline Y sqr(Y a){return a * a;}\n\ntypedef std::pair<int, int> par;\n#define fx first\n#define fy second\n#define mpar std::make_pair\n#define pb push_back\n\nint read() {\n  int w = 1, q = 0, ch = ' ';\n  for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) q = q * 10 + ch - 48;\n  return q * w;\n}\n\ninline void FileIO(){freopen(FIO\".in\", \"r\", stdin); freopen(FIO\".out\", \"w\", stdout);}\n\n#include <cstring>\nconst int N = 100010, mod = 1000000007;\nchar s[N];\nint g[N], f[N], n, sum[N];\n\nint main() {\n  scanf(\"%s\", s + 1);\n  n = (int)strlen(s + 1);\n  g[n + 1] = n + 1;\n  sum[n + 1] = 0;\n  for (int i = n; i; i--) {\n    g[i] = s[i] == s[i + 1] ? i + 1 : g[i + 1];\n    sum[i] = (sum[i + 1] + s[i] - 'a' + 1) % 3;\n  }\n  if (g[1] == n + 1) {\n    puts(\"1\");\n    return 0;\n  }\n  f[0] = 1;\n  int ans = 0;\n  for (int i = 0; i <= n; i++) {\n    if (i && sum[i + 1] == 0) {\n      ans = (ans + f[i]) % mod;\n    }\n    f[i + 1] = (f[i + 1] + f[i]) % mod;\n    f[g[i + 1]] = (f[g[i + 1]] + f[i]) % mod;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p 1000000007\nchar c[100010];int a[100010];\nint f[100010],la[3];\nint main(){\n\tscanf(\"%s\",c+1);\n\tint n=strlen(c+1);bool fla=0;\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=(a[i-1]+(c[i]=='b')+1)%3;\n\t\tif(c[i]==c[i-1])fla=1;\n\t}\n\tif(!fla)return putchar('1'),0;\n\tfor(int i=1;i<=n;i++)(f[i]+=((long long)f[la[0]]+f[la[1]]+f[la[2]]+(a[i]>=1)-f[la[a[i]]])%p)%=p,la[a[i]]=i;\n\tprintf(\"%d\",f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100010;\nconst int mod = 1000000007;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nchar buf[MAXN];\nint dp[MAXN];\nint d[3];\nint main() {\n\tstd::cin >> buf + 1; int len = strlen(buf + 1);\n\tbool flg = true;\n\tint pre = 0;\n\tdp[0] = d[0] = 1;\n\tfor (int i = 1; i <= len; ++i) {\n\t\tbuf[i] = buf[i] == 'a' ? 1 : 2;\n\t\tif (i > 1) flg &= buf[i] != buf[i - 1];\n\t\tpre = (buf[i] + pre) % 3;\n\t\treduce(dp[i] = dp[i - 1] + d[(6 - (buf[i] ^ 3) + pre) % 3] - mod);\n\t\tif (!pre) reduce(dp[i] += 1 - mod);\n\t\td[pre] = dp[i];\n\t}\n\tint ans = dp[len];\n\tif (!pre) reduce(ans -= 1);\n\tif (flg) ans = 1;\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 100007;\nconst int MOD = 1000000007;\n\nint n;\nchar s[MAXN];\nint dp[MAXN], ps[3];\nbool hv[3];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nint add ( int x, int y )\n{\n\treturn ( ( x += y ) < MOD ) ? x : ( x - MOD );\n}\n\nvoid addv ( int &x, int y )\n{\n\t( ( x += y ) < MOD ) ? x : ( x -= MOD );\n}\n\nint sub ( int x, int y )\n{\n\treturn ( ( x -= y ) >= 0 ) ? x : ( x + MOD );\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%s\", s+1 );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tn = strlen ( s + 1 );\n\tint np = 0;\n\tdp[0] = ps[0] = 1;\n\tlpi ( i, 1, n ){\n\t\t( np += s[i] - 'a' + 1 ) %= 3;\n\t\tdp[i] = sub ( add ( add ( ps[0], ps[1] ), ps[2] ), ps[np] );\n\t\tif ( np && hv[0] ) addv ( dp[i], 1 );\n//\t\tcerr << i << \" : \" << dp[i] << endl;\n\t\tps[np] = dp[i];\n\t\thv[np] = true;\n\t}\n\tif ( !hv[0] || !hv[1] || !hv[2] ) cout << 1 << endl;\n\telse cout << dp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n\ntemplate<typename T> class BIT {\nprivate:\n\tint n;\n\tvector<T> bit;\npublic:\n\t// 0_indexed で i 番目の要素に x を加える\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile(i < n){\n\t\t\tbit[i] += x, i += i & -i;\n\t\t}\n\t}\n\t// 0_indexed で [0,i] の要素の和(両閉区間！！)\n\tT sum(int i){\n        if(i<0)return 0;\n\t\ti++;\n\t\tT s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i], i -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tBIT(){}\n\t//初期値がすべて0の場合\n\tBIT(int sz) : n(sz+1), bit(n, 0){}\n\tBIT(vector<T>& v) : n((int)v.size()+1), bit(n, 0){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tadd(i,v[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcout<<sum(i)-sum(i-1)<< \" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t//-1スタート\n\tvoid print_sum(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout<<sum(i-1)<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n};\n\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    bool flag = 1;\n    rep(i,n-1){\n        if(s[i]!=s[i+1])flag = 0;\n    }\n    if(!flag){\n        cout << 1 << endl;\n        return 0;\n    }\n    vector<mod>dp(n+1);\n    vector<int>a[3];\n    vector<int>b(n+1);\n    int c = 0;\n    rep(i,n){\n        b[i] = c;\n        c += s[i]-'a'+1;\n        c %= 3;\n        a[c].push_back(i+1);\n    }\n    a[0].push_back(n+1);\n    a[1].push_back(n+1);\n    a[2].push_back(n+1);\n    b[n] = c;\n    BIT<int> bit(n+1);\n    rep(i,n-1){\n        if(s[i]==s[i+1]){\n            bit.add(i,1);\n        }\n    } \n    dp[0] = 1;\n    rep(i,n){\n        for(int j=1;j<3;j++){\n            int ca = (b[i]+j)%3;\n            int id = i;\n            while(1){\n                int x = *upper_bound(a[ca].begin(),a[ca].end(),id);\n                id = x;\n                if(x==n+1)break;\n                if(x==i+1){\n                    dp[x] += dp[i];\n                    break;\n                }else{\n                    if(bit.sum(x-1)-bit.sum(i-2)!=0){\n                        dp[x] += dp[i];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    mod res = 0;\n    rep(i,n+1){\n        int k = (3+b[n]-b[i])%3;\n        if(k==0){\n            if(i==0)continue;    \n            res += dp[i];\n        }\n        // cerr << i << \" \" << dp[i] << \" \"  << res << endl;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=100010, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN], ps[MAXN], nxt[MAXN][3], nxt2[MAXN];\nll dp[MAXN];\nstring S;\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>S;\n\tn=S.size();\n\tfor (int i=1; i<=n; i++){\n\t\tA[i]=(S[i-1]=='b')+1;\n\t\tps[i]=(A[i]+ps[i-1])%3;\n\t}\n\tnxt[n+1][0]=nxt[n+1][1]=nxt[n+1][2]=nxt2[n+1]=n+1;\n\tfor (int i=n; i; i--){\n\t\tnxt[i][0]=nxt[i+1][0];\n\t\tnxt[i][1]=nxt[i+1][1];\n\t\tnxt[i][2]=nxt[i+1][2];\n\t\tnxt2[i]=nxt2[i+1];\n\t\tnxt[i][ps[i]]=i;\n\t\tif (1<i && A[i-1]==A[i]) nxt2[i]=i;\n\t}\n\tif (nxt2[1]==n+1) kill(1)\n\tdp[0]=1;\n\tfor (int i=0; i<n; i++){\n\t\tdp[i]%=mod;\n\t\tif (ps[n]==ps[i] && i) ans=(ans + dp[i])%mod;\n\t\tdp[i+1]+=dp[i];\n\t\t\n\t\tint pos=nxt2[i+1];\n\t\tint c=3^A[i+1];\n\t\tint j=nxt[pos][(c+ps[i])%3];\n//\t\tdebug2(i, j)\n\t\tdp[j]+=dp[i];\n\t}\n\tans=(ans + dp[n])%mod;\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 1e5 + 7;\nint n, a[N], p[N][3];\nchar s[N];\nmodint f[N], ans;\n\ninline bool pd() {\n\tfor (int i = 1; i < n; i++)\n\t\tif (s[i] == s[i+1]) return 0;\n\treturn 1;\n}\n\nint main() {\n\trds(s, n);\n\tif (pd()) return print(1), 0;\n\tfor (int i = 1; i <= n; i++) a[i] = (a[i-1] + (s[i] & 1) + 1) % 3;\n\tfor (int i = 0; i < 3; i++) p[n+1][i] = n + 1;\n\tfor (int i = n; i; i--) {\n\t\tfor (int j = 0; j < 3; j++) p[i][j] = p[i+1][j];\n\t\tp[i][a[i]] = i;\n\t}\n\tf[0] = 1;\n\tfor (int i = 0; i <= n; i++) {\n\t\tif (i && a[i] == a[n]) ans += f[i];\n\t\tfor (int j = 1; j < 3; j++)\n\t\t\tf[p[i+1][(a[i]+j)%3]] += f[i];\n\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nchar s[100005];\nint n,f[100005],nx[100005][2],sum=0;\nbool flag=1;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tf[n+1]=1;nx[n+1][0]=nx[n+1][1]=nx[n+2][0]=nx[n+2][1]=n+2;\n\tfor(int i=1;i<n;i++) if(s[i]==s[i+1]) flag=0;\n\tif(flag)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tsum=(sum+(s[i]-'a'+1))%3;\n\t\tnx[i][0]=(s[i]=='a')?i+1:((s[i+1]=='b')?i+2:nx[i+2][0]);\n\t\tnx[i][1]=(s[i]=='b')?i+1:((s[i+1]=='a')?i+2:nx[i+2][1]);\n\t\tf[i]=(f[nx[i][0]]+f[nx[i][1]]+(sum==0))%mod;\n\t}\n\tprintf(\"%d\\n\",(f[1]-(sum==0)+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define p 1000000007\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,ans;\nchar c[100010];int a[100010];\nint f[100010],la[100010][3];\nint main(){\n\tscanf(\"%s\",c+1);n=strlen(c+1);\n\tla[0][1]=la[0][2]=0;\n\tfor(rt i=1;i<=n;i++){\n\t\tla[i][0]=la[i-1][0],la[i][1]=la[i-1][1],la[i][2]=la[i-1][2];\n\t\ta[i]=(a[i-1]+(c[i]=='b')+1)%3;la[i][a[i]]=i;\n\t}\n\tbool fla=0;\n\tfor(rt i=2;i<=n;i++)if(c[i]==c[i-1])fla=1;\n\tif(!fla)return cout<<1,0;\n\tbool vis[3]={0,0,0};\n\tfor(rt i=1;i<=n;i++){\n\t\tif(a[i])f[i]=1,vis[a[i]]=1;\n\t}\n\tfor(rt i=1;i<=n;i++){\n\t\tf[i]+=((ll)f[la[i][0]]+f[la[i][1]]+f[la[i][2]]-f[la[i][a[i]]])%p;\n\t\t(f[i]+=p)%=p;\n\t}\n\tcout<<f[n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=1e5+10,mod=1e9+7;\nint n,sum[maxn],dp[maxn],last[3]={0,-1,-1};\nchar s[maxn];\n\nint main(){\n\tcin>>(s+1);\n\tn=strlen(s+1);\n\tfor(int i=2;i<=n;++i)\n\t\tif(s[i-1]==s[i])\n\t\t\tgoto dy;\n\tputs(\"1\");\n\treturn 0;\ndy:\n\tdp[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tsum[i]=sum[i-1]+(s[i]=='a'?1:2);\n\t\tif(sum[i]%3==0&&i<n)\n\t\t\tdp[i]=1;\n\t\tfor(int j=1;j<=2;++j){\n\t\t\tint x=last[(sum[i]+3-j)%3];\n\t\t\tif(~x)\n\t\t\t\t(dp[i]+=dp[x])%=mod;\n\t\t}\n\t\tlast[sum[i]%3]=i;\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* - - - - - - - - - - - - - - -\n\tUser : \t\tVanishD\n\tproblem :\n\tPoints : \t\n- - - - - - - - - - - - - - - */\n# include <bits/stdc++.h>\n# define \tll \t\tlong long\nusing namespace std;\nconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\nconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\nint read(){\n\tint tmp = 0, fh = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9'){ if (ch == '-') fh = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9'){ tmp = tmp * 10 + ch - '0'; ch = getchar(); }\n\treturn tmp * fh;\n}\nconst int N = 200010, P = 1e9 + 7;\nchar s[N];\nint num[N], f[N][3], n, tag[N], pre[N], ans, sam[N];\nset <int> mp[3];\nint main(){\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tscanf(\"\\n%s\", s + 1);\n\tn = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++) num[i] = s[i] - 'a' + 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (sam[i - 1] >= i) sam[i] = sam[i - 1];\n\t\telse {\n\t\t\tsam[i] = n;\n\t\t\tfor (int j = i; j < n; j++)\n\t\t\t\tif (num[j] == num[j + 1]){\n\t\t\t\t\tsam[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; i--) tag[i] = tag[i + 1] | (num[i] == num[i - 1]); \n\tfor (int i = 1; i <= n; i++){\n\t\tpre[i] = (pre[i - 1] + num[i]) % 3;\n\t\tmp[pre[i]].insert(i);\n\t}\n\tmp[0].insert(n + 1), mp[1].insert(n + 1), mp[2].insert(n + 1);\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++){\n\t\tint cnt = ((f[i][0] + f[i][1]) % P + f[i][2]) % P;\n\t\tint j = *mp[(pre[i] + 1) % 3].upper_bound(sam[i + 1]);\n\t\tif (num[i + 1] == 1) j = i + 1;\n\t\tif (j <= n){\n\t\t\tif (j > i + 1 || num[j] == num[j - 1]) f[j][0] = (f[j][0] + cnt) % P;\n\t\t\t\telse f[j][1] = (f[j][1] + cnt) % P;\n\t\t}\n\t\tj = *mp[(pre[i] + 2) % 3].upper_bound(sam[i + 1]);\n\t\tif (num[i + 1] == 2) j = i + 1;\n\t\tif (j <= n){\n\t\t\tif (j > i + 1 || num[j] == num[j - 1]) f[j][0] = (f[j][0] + cnt) % P;\n\t\t\t\telse f[j][2] = (f[j][2] + cnt) % P;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (pre[n] - pre[i] == 0){\n\t\t\tif (tag[i + 1] == 1 || i == n) ans = ((ans + f[i][1]) % P + f[i][2]) % P;\n\t\t\tans = (ans + f[i][0]) % P;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include<cassert>\nusing namespace std;\n//#include<atcoder/all>\n//using namespace atcoder;\n\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\n\n\nint main() {\n\tstring S;\n\tcin >> S;\n\n\t\n\tll N = S.size();\n\t\n\tvll a(N + 1);\n\trepn(i, N) {\n\t\tif (S[i - 1] == 'a') { a[i] = 1; }\n\t\telse { a[i] = 2; }\n\t}\n\n\tvll sum(N + 1, 0);\n\tvvll lis(3);\n\n\trepn(i, N) {\n\t\tsum[i] = (sum[i - 1] + a[i]) % 3;\n\t\tlis[sum[i]].push_back(i);\n\t}\n\n\tvvll ad(N + 1);\n\tll ren = N + 1;\n\tfor (ll i = N-1; i >= 0; i--) {\n\t\tif (i <= N - 2 && a[i + 1] == a[i + 2]) { ren = i + 2; }\n\n\t\tad[i + 1].push_back(i);\n\n\t\tll x = (sum[i] + (3-a[i+1])) % 3;\n\t\tauto itr = lower_bound(lis[x].begin(), lis[x].end(), ren);\n\t\t\n\t\tif (itr != lis[x].end()) { ad[*itr].push_back(i); }\n\t}\n\n\tif (ren == N + 1) { cout << 1 << endl; return 0; }\n\n\tvmint dp(N + 1, 0);\n\tdp[0] = 1;\n\n\n\trepn(i, N) {\n\t\t//cout << i << endl;\n\t\tfor (ll j : ad[i]) {\n\t\t\tdp[i] += dp[j];\n\t\t\t//cout << j << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\n\tmint ans = 0;\n\trepn(i, N) {\n\t\tif (sum[i] == sum[N]) { ans += dp[i]; }\n\t}\n\n\tcout << ans << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\nll rui[101010];\nll nxt[3][101010];\nll eq[101010];\nll dp[101010];\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tfor (int i = 0; i < s.size(); i++)rui[i + 1] = (rui[i] + s[i] - 'a' + 1) % 3;\n\tnxt[0][s.size()] = nxt[1][s.size()] = nxt[2][s.size()] = eq[s.size()] = eq[s.size() - 1] = s.size() + 10;\n\tnxt[rui[s.size()]][s.size()] = s.size();\n\tfor (int i = s.size() - 1; i >= 0; i--)\n\t{\n\t\tif (i != 0 && s[i] == s[i - 1])eq[i - 1] = i;\n\t\telse if (i != 0)eq[i - 1] = eq[i];\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (rui[i] == j)nxt[j][i] = i;\n\t\t\telse nxt[j][i] = nxt[j][i + 1];\n\t\t}\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tint a, b;\n\t\tif (s[i] == 'a')a = i + 1;\n\t\telse if (eq[i] <= s.size())a = nxt[(rui[i] + 1) % 3][eq[i] + 1];\n\t\telse a = -1;\n\t\tif (s[i] == 'b')b = i + 1;\n\t\telse if (eq[i] <= s.size())b = nxt[(rui[i] + 2) % 3][eq[i] + 1];\n\t\telse b = -1;\n\t\tif (a != -1)dp[a] = (dp[a] + dp[i]) % mod;\n\t\tif (b != -1)dp[b] = (dp[b] + dp[i]) % mod;\n\t\t//printf(\"%d %d\\n\", a, b);\n\t\t//for (int j = 0; j <= s.size(); j++)printf(\"%lld \", dp[j]); printf(\"\\n\");\n\t}\n\tll r = 0;\n\tif (eq[0] <= s.size())\n\t{\n\t\tfor (int i = 1; i <= s.size(); i++)if (rui[i] == rui[s.size()])r += dp[i];\n\t}\n\telse r += dp[s.size()];\n\tprintf(\"%lld\\n\", r%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\nconst int mod=1e9+7;\n\ninline void pls(int &a,int b){ a+=b;if(a>=mod)a-=mod;}\n\nint n;\nchar str[maxn];\nint s[maxn];\n\nint nxt[maxn][3],num[3];\n\ninline void init()\n{\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1);\n\tREP(i,1,n)s[i]=(s[i-1]+str[i]-'a'+1)%3;\n\tREP(j,0,2)num[j]=n+1;\n\tDREP(i,n,0)\n\t{\n\t\tnum[s[i]]=i;\n\t\tREP(j,0,2)nxt[i][j]=num[j];\n\t}\n\tint flg=1;\n\tREP(i,1,n-1)if(str[i]!=str[i+1]);else flg=0; \n\tif(flg)puts(\"1\"),exit(0);\n}\n\nint dp[maxn];\nint ans=0;\n\ninline void doing()\n{\n\tdp[0]=1;\n\tREP(i,0,n-1)\n\t{\n\t\tREP(j,1,2)\n\t\t{\n\t\t\tint k=nxt[i+1][(s[i]+j)%3];\n\t\t\tif(k<=n)pls(dp[k],dp[i]);\n\t\t}\n\t}\n\tREP(i,1,n)if(s[i]==s[n])pls(ans,dp[i]);\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5, mod = 1e9 + 7;\nint n, a[maxn + 3], pos[maxn + 3][3], dp[maxn + 3], lst[maxn + 3];\nchar s[maxn + 3];\n\nvoid upd(int &x, int y) {\n\tx += y, x < mod ? 0 : x -= y;\n}\n\nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tbool flag = true;\n\tfor (int i = 1; i < n; i++) {\n\t\tflag &= s[i] != s[i + 1];\n\t}\n\tif (flag) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = s[i] == 'a' ? 1 : 2;\n\t\ta[i] = (a[i] + a[i - 1]) % 3;\n\t}\n\tfor (int i = n; i; i--) {\n\t\tlst[a[i]] = i;\n\t\tpos[i][1] = lst[(a[i - 1] + 1) % 3];\n\t\tpos[i][2] = lst[(a[i - 1] + 2) % 3];\n\t}\n\tdp[0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (pos[i + 1][1]) {\n\t\t\tupd(dp[pos[i + 1][1]], dp[i]);\n\t\t}\n\t\tif (pos[i + 1][2]) {\n\t\t\tupd(dp[pos[i + 1][2]], dp[i]);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif ((a[n] - a[i] + 3) % 3 == 0) {\n\t\t\tupd(ans, dp[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nconst int MOD=1e9+7;\n\nvoid addmod(int& x,int y){x=(x+y)%MOD;}\n\nint dp[100005][3][2][2];\n//i, trail sum, cana, canb\n\nint N;\nchar str[100005];\n\nvoid zebra(){\n  for(int i=1;i<N;i++){\n    if(str[i]==str[i-1]) return;\n  }\n  printf(\"1\\n\");\n  exit(0);\n}\n\nint main(){\n  scanf(\"%s\",str);\n  N=strlen(str);\n  zebra();\n  dp[0][0][1][1]=1;\n  for(int i=0;i<N;i++){\n    str[i]=str[i]-'a'+1;\n    for(int s=0;s<3;s++){\n      for(int a=0;a<2;a++){\n\tfor(int b=0;b<2;b++){\n\t  int v=dp[i][s][a][b];\n\t  int s2=(s+str[i])%3;\n\t  switch(s2){\n\t  case 1:\n\t    if(a) addmod(dp[i+1][0][1][1],v);\n\t    addmod(dp[i+1][s2][0][b],v);\n\t    break;\n\t  case 2:\n\t    if(b) addmod(dp[i+1][0][1][1],v);\n\t    addmod(dp[i+1][s2][a][0],v);\n\t    break;\n\t  case 0:\n\t    addmod(dp[i+1][s2][a][b],v);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  int ans=0;\n  for(int a=0;a<2;a++){\n    for(int b=0;b<2;b++){\n      addmod(ans,dp[N][0][a][b]);\n    }\n  }\n  int sum=0;\n  for(int i=0;i<N;i++){\n    sum=(sum+str[i])%3;\n  }\n  if(sum==0) addmod(ans,MOD-1);\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\nconst int N = 1e5+5;\nconst int mo = 1e9+7;\n\nchar s[N];\nint n;\nint a[N];\nint suf[N][3];\nint w[N];\nint f[N];\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tbool pd=1;\n\tfo(i,2,n)pd&=(s[i]!=s[i-1]);\n\tif (pd)return printf(\"1\\n\"),0;\n\tfo(i,1,n){\n\t\ta[i]=s[i]-'a'+1;\n\t}\n\tfo(i,1,n)a[i]=(a[i]+a[i-1])%3;\n\tfd(i,n,0){\n\t\tsuf[i][0]=w[0];\n\t\tsuf[i][1]=w[1];\n\t\tsuf[i][2]=w[2];\n\t\tw[a[i]]=i;\n\t}\n\tf[0]=1;\n\tfo(i,0,n-1){\n\t\t//a\n\t\tint v=(a[i]+1)%3;\n\t\tif (suf[i][v])f[suf[i][v]]=(f[suf[i][v]]+f[i])%mo;\n\t\tv=(a[i]+2)%3;\n\t\tif (suf[i][v])f[suf[i][v]]=(f[suf[i][v]]+f[i])%mo;\n\t}\n\tint ans=0;\n\tbool ext=0;\n\tfo(i,1,n)\n\tif (a[i]==a[n])ans=(ans+f[i])%mo;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MOD=1e9+7;\nint main()\n{\n    string s; cin>>s;\n    int c[100010];\n    int n=s.size();\n    c[0]=0;\n    for(int i=0; i<n; i++){\n        if(s[i]=='a') c[i+1]=(c[i]+1)%3;\n        else c[i+1]=(c[i]+2)%3;\n    }\n    int nx[100010];\n    int p[3][100010];\n    for(int j=0; j<3; j++) p[j][n]=n+1;\n    for(int i=n-1; i>=0; i--){\n        for(int j=0; j<3; j++) p[j][i]=p[j][i+1];\n        p[c[i]][i]=i;\n        if(s[i]=='a') nx[i]=p[(c[i]+2)%3][i];\n        else nx[i]=p[(c[i]+1)%3][i];\n    }\n    int dp[100010]={};\n    dp[0]=1;\n    int ans=0;\n    for(int i=0; i<n; i++){\n        (dp[i+1]+=dp[i])%=MOD;\n        (dp[nx[i]]+=dp[i])%=MOD;\n        int x=(c[n]-c[i+1]+3)%3;\n        if(x==0) (ans+=dp[i+1])%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007LL\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint n,ln[100005],cnt,res;\nvector < int > dp[100005][2];\nchar s[100005];\nint main(){\n    // inputting start\n    // 数据结构记得初始化！ n，m别写反！\n    int i,j,k;\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    // 数据结构记得初始化！ n，m别写反！\n    cnt=1;\n    ln[0]=1;\n\tfor(i=1;i<n;++i){\n    \tif(s[i]==s[i-1]){\n    \t\tln[cnt]=1;\n    \t\t++cnt;\n    \t}\n    \telse{\n    \t\t++ln[cnt-1];\n    \t}\n    }\n    // initialize for the first block\n    dp[0][0].resize(ln[0]+1,0);\n\tdp[0][1].resize(ln[0]+1,0);\n\tdp[0][s[ln[0]-1]-'a'][ln[0]]=1;\n\tint ptr=ln[0];\n    for(i=1;i<cnt;++i){\n    \t// DP transfer\n\t\tdp[i][0].resize(ln[i]+2,0);\n\t\tdp[i][1].resize(ln[i]+2,0);\n\t\t// start from the different char\n\t\tint fs=s[ptr]-'a',ls=s[ptr+ln[i]-1]-'a';\n\t\tdp[i][ls][ln[i]+1]=dp[i-1][!fs][1];\n\t\t// start from the same char\n\t\t// case 1: cut off\n\t\tint coe=0;\n\t\tfor(j=1;j<(int)dp[i-1][0].size();++j){\n\t\t\tcoe+=(LL)dp[i-1][fs][j]*(LL)((j+1)/2)%MOD1;\n\t\t\tcoe%=MOD1;\n\t\t\tdp[i][ls][ln[i]]+=(LL)dp[i-1][fs][j]*(LL)(j/2+1)%MOD1;\n\t\t\tdp[i][ls][ln[i]]%=MOD1;\n\t\t}\n\t\t// case 2: continue\n\t\tfor(j=ptr;j<ptr+ln[i]-1;++j){\n\t\t\tdp[i][ls][ln[i]+ptr-1-j]+=coe;\n\t\t\tdp[i][ls][ln[i]+ptr-1-j]%=MOD1;\n\t\t}\n\t\tdp[i][!ls][1]+=coe;\n\t\tdp[i][!ls][1]%=MOD1;\n\t\tptr+=ln[i];\n    }\n\t\n\tfor(i=0;i<(int)dp[cnt-1][0].size();++i){\n\t\tres+=dp[cnt-1][0][i];\n\t\tres%=MOD1;\n\t\tres+=dp[cnt-1][1][i];\n\t\tres%=MOD1;\n\t}\n\tprintf(\"%d\\n\",res);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-15 15:38:40\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=100010,mod=1000000007;\nchar c[N];\nint s,f[N],n,a[N],b[N];\nint main()\n{\n\tscanf(\"%s\",c+1); n=strlen(c+1); f[n+1]=1;\n\tfr(i,1,n)\n\t{\n\t\tif(i==n){ printf(\"1\\n\"); return 0; }\n\t\tif(c[i]==c[i+1]) break;\n\t}\n\tfd(i,n,1)\n\t{\n\t\ta[i]=c[i]=='a'?i+1:c[i+1]=='b'?i+2:a[i+2];\n\t\tb[i]=c[i]=='b'?i+1:c[i+1]=='a'?i+2:b[i+2];\n\t\ts=(s+(c[i]=='a'?1:2))%3;\n\t\tf[i]=(f[a[i]]+f[b[i]]+(s==0))%mod;\n//\t\tprintf(\"%d %d %d %d\\n\",i,a[i],b[i],f[i]);\n\t}\n\tprintf(\"%d\\n\",(f[1]-(s==0)+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"1\"),0;\n#define N 500055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,a[N],l[N],dp[N],sum[N];\nchar str[N];\ninline void add(int &x,int k){\n\tx+=k;x-=(x>=mod)?mod:0;\n}\nsigned main(){\n\tscanf(\"%s\",str+1);n=strlen(str+1);\n\tF(i,1,n) a[i]=(str[i]=='a')?1:2;\n\tint pd=0;\n\tF(i,1,n-2) pd|=(a[i]==a[i+1]);\n\tif (!pd) ret;\n\tl[1]=l[2]=-1;dp[0]=1;\n\tF(i,1,n){\n\t\tsum[i]=sum[i-1]+a[i];\n\t\tif (sum[i]%3==0&&i<n) dp[i]=1;\n\t\tF(j,1,2){\n\t\t\tif (l[(sum[i]+3-j)%3]!=-1) add(dp[i],dp[l[(sum[i]+3-j)%3]]);\n\t\t}\n\t\tl[sum[i]%3]=i;\n\t}\n\twrn(dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(int k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n\n};\n//INSERT ABOVE HERE\nsigned main(){\n  string s;\n  cin>>s;\n  int n=s.size();\n\n  {\n    string t=s;\n    t.erase(unique(t.begin(),t.end()),t.end());\n    if(s==t){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  \n  vector<int> a(n+1);\n  for(int i=0;i<n;i++)\n    a[i+1]=a[i]+(s[i]=='a'?1:2);\n\n  vector<vector<int> > x(3);\n  for(int i=1;i<=n;i++)\n    x[a[i]%3].emplace_back(i);\n\n  x[0].emplace_back(n+1);\n  x[1].emplace_back(n+1);\n  x[2].emplace_back(n+1);\n  \n  using M = Mint<int>;\n  vector<M> dp(n+1,0);\n  dp[0]=1;\n  \n  for(int i=0,j=0;i<n;i++){\n    dp[i+1]+=dp[i];\n\n    chmax(j,i+1);\n    while(j<n&&s[j-1]!=s[j]) j++;\n\n    //cout<<(a[i]+1+(s[i]=='a'))%3<<endl;\n    auto v=x[(a[i]+1+(s[i]=='a'))%3];\n    int k=*lower_bound(v.begin(),v.end(),j);\n    if(k<=n) dp[k]+=dp[i];\n    \n    //cout<<i<<\":\"<<dp[i].v<<\":\"<<j<<\" \"<<k<<endl;\n  }\n\n  M ans(0);\n  for(int i=1;i<=n;i++)\n    if((a[n]-a[i])%3==0) ans+=dp[i];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n 神仙啊 \n 定义a = 1,b = 1发现在%3的情况下所有变换的相等的\n 性质:一个字符串，能变成字符c的条件是val[a] == val[c]并且a中有一个可以变换的位置\n 只需要判断这种变换不经过ababab这种就好了\n 那我们要求得就把字符串划分为k段，第i段的val值和第i字符的val值相等\n f_i表示前i个看做一段的方案数\n   \n*/\n#include<cstdio> \n#include<cctype> \n#include<cstring> \n#include<algorithm> \n#define gc getchar() \n#define pc putchar\n#define LL long long\ninline int read() { \n\tint x = 0,f = 1; \n\tchar c = getchar(); \n\twhile(c < '0' || c > '9') c = gc; \n\twhile(c <= '9' && c >= '0') x = x * 10 + c - '0',c = getchar(); \n\treturn x * f; \n}\nvoid print(LL x) { \n\tif(x < 0) { \n\t\tpc('-'); \n\t\tx = -x; \n\t} \n\tif(x >= 10) print(x / 10); \n\tpc(x % 10 + '0'); \n} \nconst int maxn = 100007; \nchar t[maxn]; \nint n,s[maxn]; \nint f[maxn]; \nconst int mod = 1e9 + 7; \nint main() { \n\tscanf(\"%s\",t + 1); \n\tn = strlen(t + 1); \n\tbool flag = false ; \n\tfor(int i = 2;i <= n;++ i) if(t[i] == t[i - 1])flag = true; \n\tif(!flag) { \n\t\tputs(\"1\");  \n\t\treturn 0; \n\t} \n\tint now = 0,pre[3] = {0,-1,-1}; \n\tf[0] = 1; \n\tfor(int i = 1;i <= n;++ i) { \n\t\tnow = (now + 2 - (t[i] == 'a')) % 3; \n\t\tif(!now && i < n) f[i] = 1; \n\t\t++ now,now %= 3; \n\t\tif(pre[now] != - 1) (f[i] += f[pre[now]]) %= mod;  \n\t\t++ now,now %= 3; \n\t\tif(pre[now] != -1) (f[i] += f[pre[now]]) %= mod;\n\t\t++ now,now %= 3; \n\t\tpre[now] = i; \n\t} \n\tprint(f[n]); \n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nconst int N=1e5+5,P=1e9+7;\nchar s[N];int n,m,p[N],g[N][3],f[N];\nint main(){\n\tint x,c;\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfor(x=1;x<n;x++)if(s[x]==s[x+1])break;\n\tif(x<n){\n\t\tfor(x=1;x<=n;x++)p[x]=(p[x-1]+(s[x]=='b')+1)%3;\n\t\tfor(x=n;x>=0;x--)g[x][0]=g[x+1][0],g[x][1]=g[x+1][1],g[x][2]=g[x+1][2],g[x][p[x]]=x;\n\t\tf[0]=1;\n\t\tfor(x=0;x<n;x++)if(f[x])for(c=0;c<3;c++)if(c!=p[x]&&g[x+1][c])f[g[x+1][c]]=(f[g[x+1][c]]+f[x])%P;\n\t\tfor(x=1;x<=n;x++)if(p[x]==p[n])m=(m+f[x])%P;\n\t}else m=1;\n\tprintf(\"%d\\n\",m);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n#define N 100010\nchar s[N];\nint S[N],ne[N][4],f[N],ans;\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1); bool flag=1;\n\tfor (int i=2;i<=n && flag;i++) if (s[i]==s[i-1]) flag=0;\n\tif (flag) {puts(\"1\"); return 0;}\n\tfor (int i=1;i<=n;i++) S[i]=(S[i-1]+s[i]-'a'+1)%3;\n\tne[n][0]=ne[n][1]=ne[n][2]=n+1;\n\tfor (int i=n-1;i>=0;i--){\n\t\tfor (int j=0;j<3;j++) ne[i][j]=ne[i+1][j];\n\t\tne[i][S[i+1]]=i+1;\n\t}\n\tf[0]=1;\n\tfor (int i=0;i<n;i++){\n\t\tif (!f[i]) continue;\n\t\tfor (int k=0;k<3;k++){\n\t\t\tif (S[i]==k) continue;\n\t\t\tif (ne[i][k]>n) continue;\n\t\t\t(f[ne[i][k]]+=f[i])%=M;\n\t\t}\n\t\tif (i && S[i]==S[n]) (ans+=f[i])%=M;\n\t}\n\t(ans+=f[n])%=M;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n}; // namespace IO\nusing namespace IO;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\nusing namespace modular;\n\n#define reg register\n#define MAX_N 200007\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\ntypedef long long ll;\n\nint N;\nint a[MAX_N], sum[MAX_N], nxt[MAX_N][3], f[MAX_N];\nchar s[MAX_N];\n\ninline void solve() {\n    bool flag = false;\n    lep(i, 1, N) if (s[i] == s[i + 1]) flag = true;\n    if (!flag)\n        return puts(\"1\"), void();\n    rep(i, 1, N) a[i] = (s[i] == 'a' ? 1 : 2), sum[i] = (sum[i - 1] + a[i]) % 3;\n    nxt[N][0] = nxt[N][1] = nxt[N][2] = N + 1;\n    irep(i, N - 1, 0) {\n        rep(j, 0, 2) nxt[i][j] = nxt[i + 1][j];\n        nxt[i][sum[i + 1]] = i + 1;\n    }\n    int res = 0;\n    f[0] = 1;\n    rep(i, 0, N) {\n        rep(j, 1, 2) inc(f[nxt[i][(sum[i] + j) % 3]], f[i]);\n        if (i && sum[i] == sum[N])\n            inc(res, f[i]);\n    }\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n#ifdef LOCAL\n    FIN(\"in\");\n#endif\n    scanf(\"%s\", s + 1);\n    N = strlen(s + 1);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint add(int x,int y){return x+y<3?x+y:x+y-3;}\nconst int mod=1e9+7;\nint n;\nchar s[100100];\nint a[100100];\n\nint sum[100100];\nint nd[100100];\nint nxt[100100][3];\nint dp[100100];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=s[i]-'a'+1;\n\t\tsum[i]=add(sum[i-1],a[i]);\n\t}\n\ta[n+2]=4;\n\tnxt[n][0]=nxt[n][1]=nxt[n][2]=n+1;\n\tnxt[n+1][0]=nxt[n+1][1]=nxt[n+1][2]=n+1;\n\tnd[n+1]=n+1;\n\tfor(int i=n;i>=0;--i)\n\t{\n\t\tmemcpy(nxt[i],nxt[i+1],sizeof(nxt[i+1]));\n\t\tnxt[i][sum[i]]=i;\n\t\tnd[i]=nd[i+1];\n\t\tif(a[i+1]==a[i+2])nd[i]=i+2;\n\t}\n\tif(nd[1]==n+1)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tdp[0]=1;\n\tint p1,p2;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tp1=nxt[nd[i]][add(sum[i],1)];\n\t\tp2=nxt[nd[i]][add(sum[i],2)];\n\t\tif(a[i+1]!=1)dp[p1]=(dp[p1]+dp[i])%mod;\n\t\tif(a[i+1]!=2)dp[p2]=(dp[p2]+dp[i])%mod;\n\t\tdp[i+1]=(dp[i+1]+dp[i])%mod;\n\t}\n\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(add(sum[n],3-sum[i])==0)\n\t\t\t(ans+=dp[i])%=mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nconst int N=1e5+5,Mo=1e9+7;\n\nint n,sum[N],f[N],nxt[N][3];\nchar s[N];\n\nvoid inc(int &x,int y) {x=x+y>=Mo?x+y-Mo:x+y;}\n\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tbool ok=0;\n\tfo(i,1,n-1) if (s[i]==s[i+1]) {ok=1;break;}\n\tif (!ok) {puts(\"1\");return 0;}\n\tsum[0]=0;fo(i,1,n) sum[i]=(sum[i-1]+((s[i]=='a')?1:2))%3;\n\tfo(i,0,2) nxt[n][i]=n+1;\n\tfd(i,n-1,0)\n\t{\n\t\tfo(j,0,2) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][sum[i+1]]=i+1;\n\t}\n\tf[0]=1;int ans=0;\n\tfo(i,0,n)\n\t{\n\t\tfo(j,1,2) inc(f[nxt[i][(sum[i]+j)%3]],f[i]);\n\t\tif (i&&sum[i]==sum[n]) inc(ans,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nconst int N=1e5+5,Mo=1e9+7;\n\nint n,sum[N],f[N],nxt[N][3];\nchar s[N];\n\nvoid inc(int &x,int y) {x=x+y>=Mo?x+y-Mo:x+y;}\n\nint main() {\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tbool ok=0;\n\tfo(i,1,n-1) if (s[i]==s[i+1]) {ok=1;break;}\n\tif (!ok) {puts(\"1\");return 0;}\n\tsum[0]=0;fo(i,1,n) sum[i]=(sum[i-1]+((s[i]=='a')?1:2))%3;\n\tfo(i,0,2) nxt[n][i]=n+1;\n\tfd(i,n-1,0) {\n\t\tfo(j,0,2) nxt[i][j]=nxt[i+1][j];\n\t\tnxt[i][sum[i+1]]=i+1;\n\t}\n\tf[0]=1;int ans=0;\n\tfo(i,0,n) {\n\t\tfo(j,1,2) inc(f[nxt[i][(sum[i]+j)%3]],f[i]);\n\t\tif (i&&sum[i]==sum[n]) inc(ans,f[i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nchar s[maxn];\nint sum[maxn],f[maxn];\nint n;\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tsum[0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i]=(sum[i-1]+(s[i]=='a'?1:2))%3;\n\tint flag=1;\n\tfor(int i=1;i<n;i++)\n\t\tif(s[i]==s[i+1])flag=1;\n\tif(flag){\n\t\tputs(\"1\"); return 0;\n\t}\n\tf[0]=1;\n\tint pos[3]={-1,-1,-1};\n\tpos[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=(!sum[i])&&(i<n);\n\t\tif(~pos[(sum[i]+1)%3])f[i]=(f[i]+f[pos[(sum[i]+1)%3]])%mod;\n\t\tif(~pos[(sum[i]+2)%3])f[i]=(f[i]+f[pos[(sum[i]+2)%3]])%mod;\n\t\tpos[sum[i]]=i;\n\t\t// printf(\"%d %d %d : %d %d %d\\n\",i,sum[i],f[i],pos[0],pos[1],pos[2]);\n\t}\n\twriteln(f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 100500\n#define mod 1000000007\nint n,nt[N],su[N],nt2[N][3],as,dp[N];\nchar s[N];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tfor(int i=1;i<=n;i++){su[i]=(su[i-1]+s[i]-'a'+1)%3;}\n\tnt[n+1]=n+1;nt2[n+1][0]=nt2[n+1][1]=nt2[n+1][2]=n+1;\n\tfor(int i=n;i>=0;i--)\n\t{\n\t\tnt[i]=nt[i+1];nt2[i][0]=nt2[i+1][0];nt2[i][1]=nt2[i+1][1];nt2[i][2]=nt2[i+1][2];\n\t\tif(s[i]==s[i+1])nt[i]=i+1;\n\t\tnt2[i][su[i+1]]=i+1;\n\t}\n\tdp[0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tint tp=nt[i]-1;\n\t//\tif(nt[tp]==n+1)tp=n;\n\t\tif(s[i+1]=='a')dp[nt2[tp][(2+su[i])%3]]=(dp[nt2[tp][(2+su[i])%3]]+dp[i])%mod;else dp[i+1]=(dp[i+1]+dp[i])%mod;\n\t\tif(s[i+1]=='b')dp[nt2[tp][(1+su[i])%3]]=(dp[nt2[tp][(1+su[i])%3]]+dp[i])%mod;else dp[i+1]=(dp[i+1]+dp[i])%mod;\n\t\tif(!(su[n]-su[i])%3&&i)as=(as+dp[i])%mod;\n\t}\n\tif(nt[0]==n+1)as=1;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n#define N 100012\n#define mod 1000000007\ninline int M(int x){return (x>=mod)?(x-mod):x;}\ninline void Add(int &x,int v){x=M(x+v);}\ninline int M1(int x){return (x<0)?(x+mod):x;}\ninline int ksm(int p,int k){int res=1;while(k){if(k&1)res=1ll*res*p%mod;k>>=1;p=1ll*p*p%mod;}return res;}\nint n,s[N],R[N],V[N],f[N],ne[N][3],now[3],tr[N][3],ans=0;char sc[N];\nint main(){\n\tscanf(\"%s\",sc+1);n=strlen(sc+1);int i,j,v;\n\tfor(i=1;i<=n;i++)s[i]=(s[i-1]+sc[i]-'a'+1)%3;R[n]=n;for(i=n-1;i>=1;i--)R[i]=(sc[i]==sc[i+1])?i:R[i+1];if(R[1]==n){printf(\"1\");return 0;}\n\tfor(i=1;i<=n+1;i++){memcpy(ne[i],ne[i-1],sizeof(ne[i-1]));ne[i][s[i-1]]=i-1;}\n\tnow[0]=now[1]=now[2]=n+1;for(i=n;i>=1;i--){for(j=0;j<=2;j++)while(ne[now[j]][j]>R[i])now[j]=ne[now[j]][j];memcpy(tr[i],now,sizeof(now));}\n\tf[0]=1;for(i=0;i<n;i++)if(v=f[i]){Add(f[i+1],v);Add(f[tr[i+1][(2-sc[i+1]+'a'+s[i])%3]],v);}\n\tfor(i=1;i<=n;i++)if(s[n]==s[i])ans=M(ans+f[i]);printf(\"%d\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntemplate<typename T> void chkmax(T &a, const T &b) { a = a > b ? a : b; }\ntemplate<typename T> void chkmin(T &a, const T &b) { a = a < b ? a : b; }\n\nconst int MAXN = 100005, MOD = 1e9 + 7;\nvoid add(int &x, int y) { x += y - MOD, x += x >> 31 & MOD; }\nint f[MAXN], tran[MAXN][3], suf[3], can[MAXN], n;\nchar str[MAXN];\n\nint main() {\n\tscanf(\"%s\", str + 1);\n\tn = strlen(str + 1);\n\tfor (int i = 1; i <= n; i++)\n\t\tstr[i] = str[i] - 'a' + 1;\n\tmemset(tran[n + 1], -1, sizeof(tran[n + 1]));\n\tmemset(suf, -1, sizeof(suf));\n\tfor (int i = n; i > 0; i--) {\n\t\tint c = str[i], tmp[3] = { suf[(3 - c) % 3], suf[(4 - c) % 3], suf[(5 - c) % 3] };\n\t\ttmp[c] = i;\n\t\tif (str[i] == str[i + 1]) {\n\t\t\ttran[i][c] = suf[0];\n\t\t\ttran[i][c * 2 % 3] = i + 1;\n\t\t\ttran[i][0] = tmp[0];\n\t\t} else {\n\t\t\ttran[i][0] = tran[i + 1][(3 - c) % 3];\n\t\t\ttran[i][1] = tran[i + 1][(4 - c) % 3];\n\t\t\ttran[i][2] = tran[i + 1][(5 - c) % 3];\n\t\t}\n\t\tmemcpy(suf, tmp, sizeof(suf));\n\t\tcan[i] = (can[i + 1] + c) % 3;\n\t}\n\tif (tran[1][can[1]] < 0) return puts(\"1\"), 0;\n\tf[0] = 1;\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) {\n\t\ttran[i + 1][str[i + 1]] = i + 1;\n\t\tif (~tran[i + 1][1]) add(f[tran[i + 1][1]], f[i]);\n\t\tif (~tran[i + 1][2]) add(f[tran[i + 1][2]], f[i]);\n\t\tif (!can[i + 2]) add(res, f[i + 1]);\n\t}\n\tprintf(\"%d\\n\", res % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 1e5 + 10;\nconst int MOD = 1e9 + 7;\n\nchar s[N];\nint a[N], n, f[N], nxt[3];\n\nint main() {\n    scanf(\"%s\", s);\n    for (; s[n]; ++n) a[n+1] = (a[n] + s[n] - 'a' + 1) % 3; // 求前缀和 \n    // 判断是否可以操作 \n    int flag = 0;  \n    for (int i = 1; i < n; ++i) {\n        if (s[i] == s[i-1]) flag = 1;\n    }\n    if (!flag) {\n        puts(\"1\");\n        return 0;\n    }\n    // 递推 \n    f[n] = 1;\n    for (int i = 0; i < 3; ++i) nxt[i] = i == a[n] ? n : n + 1;\n    for (int i = n-1; i; --i) {\n        f[i] = a[i] == a[n]; // 后面可不可以不分段 \n        for (int c = 1; c <= 2; ++c) {\n            (f[i] += f[nxt[(a[i]+c)%3]]) %= MOD; // 后面加一段A或B \n        }\n        nxt[a[i]] = i; // 记录该p值最后一次出现的位置 \n    }\n    printf(\"%d\\n\", (f[nxt[1]] + f[nxt[2]]) % MOD);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nconst int N = 233333,mo=1e9+7;\nchar S[N];int n,f[N],s[N],qz[N],b[N];vector<int> a[3];\nvoid add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\n\nint main(){\n\tscanf(\"%s\",S+1);n=strlen(S+1);rep(i,1,n)s[i]=S[i]-'a'+1;\n\trep(i,1,n)qz[i]=(qz[i-1]+s[i])%3,a[qz[i]].push_back(i);f[0]=1;\n\tfor(int i=n,j=n+1;i>=0;i--){if(s[i]==s[i+1])j=i+1;b[i]=j;}\n\trep(i,0,n-1)rep(j,1,2){\n\t\tif(s[i+1]==j)add(f[i+1],f[i]);\n\t\telse if(SZ(a[(qz[i]+j)%3])&&b[i+1]<=a[(qz[i]+j)%3].back()){//RE\n\t\t\tint k=*lower_bound(a[(qz[i]+j)%3].begin(),a[(qz[i]+j)%3].end(),b[i+1]);\n\t\t\tif(k<=n)add(f[k],f[i]);\n\t\t}\n\t}\n//\trep(i,0,n)printf(\"%d:%d\\n\",i,f[i]);\n\tint res=0;rep(i,0,n-1)if(b[i+1]<=n&&(qz[n]-qz[i])%3||i&&(qz[n-1]-qz[i])%3==0)add(res,f[i]);\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define Z int\n#define C char\n#define L long long\n#define S(s) scanf(\"%s\",s+1)\n#define P(n) printf(\"%lld\",(n+p)%p)\n#define F(i,a,b) for(L i=a;i<=b;i++)\n#define D(i,a,b) for(L i=a;i>=b;i--)\n#define W while\n#define I if\n#define R return\n#define nx 100001\n#define p (L)(1e9+7)\nC s[nx];\nL n,g,a[nx],pre[nx],nxt[nx][3],f[nx],ans;\nZ main(){\n\tS(s);\n\tW(s[n+1])n++;\n\tF(i,1,n)pre[i]=pre[i-1]+(a[i]=s[i]-'`');\n\tF(i,1,n-1)I(a[i]==a[i-1])g=1;\n\tI(!g){P(1);R 0;}\n\tD(i,n-1,0)F(o,1,2)nxt[i][(pre[i]+o)%3]=\n\ta[i+1]==o?i+1:nxt[i+1][(pre[i]+o)%3];\n\tf[0]=1;\n\tF(i,0,n-1)F(o,1,2)(f[nxt[i][(pre[i]+o)%3]]+=f[i])%=p;\n\tF(i,1,n)I((pre[n]-pre[i])%3==0)(ans+=f[i])%=p;\n\tP(ans);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nchar s[100002];\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nsigned main(){\n\tint N, i, j, f;\n\tscanf(\"%s\", &s[1]);\n\tfor(N = 0; s[N + 1] != '\\0'; N++){}\n\tfor(i = 1, f = 1; i < N; i++){\n\t\tif(s[i] == s[i + 1]){\n\t\t\tf = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(f == 1){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tint *A = (int *)malloc(sizeof(int) * (N + 1));\n\tA[0] = 0;\n\tfor(i = 1; i <= N; i++){\n\t\tif(s[i] == 'a'){\n\t\t\tA[i] = (A[i - 1] + 1) % 3;\n\t\t}\n\t\telse{\n\t\t\tA[i] = (A[i - 1] + 2) % 3;\n\t\t}\n\t}\n\tint **dp1 = (int **)malloc(sizeof(int *) * (N + 1));\n\tint **dp2 = (int **)malloc(sizeof(int *) * (N + 1));\n\tfor(i = 0; i <= N; i++){\n\t\tdp1[i] = (int *)malloc(sizeof(int) * 3);\n\t\tdp2[i] = (int *)malloc(sizeof(int) * 3);\n\t\tfor(j = 0; j < 3; j++){\n\t\t\tdp1[i][j] = 0;\n\t\t\tdp2[i][j] = 0;\n\t\t}\n\t}\n\tint pre[3] = {1, 0, 0};\n\tdp1[0][0] = 1;\n\tdp2[0][0] = 1;\n\tfor(i = 1; i <= N; i++){\n\t\tdp1[i][A[i]] = MOD(dp2[i - 1][(A[i] + 1) % 3] + dp2[i - 1][(A[i] + 2) % 3] - pre[A[i]]);\n\t\tif(A[i] == 0){\n\t\t\tdp1[i][A[i]] = MOD(dp1[i][A[i]] + 1);\n\t\t}\n\t\tfor(j = 0; j < 3; j++){\n\t\t\tdp2[i][j] = MOD(dp2[i - 1][j] + dp1[i][j]);\n\t\t}\n\t\tpre[A[i]] = dp2[i][A[i]];\n\t}\n/*\tfor(i = 0; i <= N; i++){\n\t\tfor(j = 0; j < 3; j++){\n\t\t\tprintf(\"%lld \", dp1[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\tif(A[N] == 0){\n\t\tdp2[N][A[N]] = MOD(dp2[N][A[N]] - 1);\n\t}\n\tprintf(\"%lld\\n\", dp2[N][A[N]]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null dab[N_MAX][2];\null dp[N_MAX];\null dq[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tn = strlen(s);\n\tdab[n][0] = n + 1;\n\tdab[n][1] = n + 1;\n\tdab[n + 1][0] = n + 1;\n\tdab[n + 1][1] = n + 1;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (s[i] == s[i + 1]) break;\n\t}\n\tif (i == n) {\n\t\tputs(\"1\");\n\t\treturn 1;\n\t}\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tint c = s[i] - 'a';\n\t\tdab[i][c] = i + 1;\n\t\tdab[i][c ^ 1] = dab[i + 1][c];\n\t\t// printf(\"%lld: %lld/%lld\\n\", i, dab[i][0], dab[i][1]);\n\t}\n\n\tdp[0] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tint c = s[i] - 'a';\n\n\t\tdp[i] %= MOD;\n\t\t// printf(\"%lld: %lld %lld\\n\", i, dp[i], dq[i] % MOD);\n\n\t\tdp[dab[i][c]] += dp[i];\n\t\tdp[dab[i][c ^ 1]] += dp[i];\n\t\t// dq[dab[i][c ^ 1]] += dp[i];\n\t\t// printf(\"%lld, %lld += %lld\\n\", dab[i][c], dab[i][c ^ 1], i);\n\t}\n\tdp[n] %= MOD;\n\t// printf(\"%lld: %lld %lld\\n\", n, dp[n], dq[n] % n);\n\n\t// int fsame = 1;\n\t// while (fsame < n - 1 && s[fsame - 1] != s[fsame]) fsame++;\n\t// printf(\"fsame: %lld\\n\", fsame);\n\n\tresult = 0;\n\n\tsum = 0;\n\t// bool hassame = false;\n\tfor (i = n; i; i--) {\n\t\t// if (i && s[i - 1] == s[i]) hassame = true;\n\n\t\tif (sum % 3 == 0) {\n\t\t\tresult += dp[i];\n\t\t}\n\t\tsum += (s[i - 1] - 'a' + 1);\n\t}\n\tresult %= MOD;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 5;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\tscanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Pascal",
    "code": "var\n  s:ansistring;\n  a:array[1..1000000]of ansistring;\n  i,j,m,n,p:longint;\n  k:qword;\nprocedure search(st:string);\nvar\n  i,j:longint;\nbegin\n  if length(st)=1 then exit;\n  for i:=1 to length(st)-1 do\n  begin\n     if st[i]<>st[i+1] then continue;\n\t if st[i]='a' then \n\t begin\n\t delete(st,i,2);\n\t insert('b',st,i);\n\t for j:=1 to p+1 do if a[j]=st then break;\n\t if j=p+1 then begin\n\t inc(k);\n\t inc(p);\n\t a[p]:=st;\n\t search(st);\n\t end;\n\t delete(st,i,1);\n\t insert('aa',st,i);\n\t continue;\n\t end;\n\t if st[i]='b' then \n\t begin\n\t delete(st,i,2);\n\t insert('a',st,i);\n\t for j:=1 to p+1 do if a[j]=st then break;\n\t if j=p+1 then begin\n\t inc(k);\n\t inc(p);\n\t a[p]:=st;\n\t search(st);\n\t end;\n\t search(st);\n\t delete(st,i,1);\n\t insert('bb',st,i);\n\t end;\n  end;\nend;\nbegin\n  readln(s);\n  k:=1;\n  search(s);\n  writeln(k);\nend."
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        static final long MODULO = (long) (1e9 + 7);\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            String s = in.next();\n            boolean alternating = true;\n            for (int i = 0; i + 1 < s.length(); ++i) if (s.charAt(i) == s.charAt(i + 1)) alternating = false;\n            if (alternating) {\n                out.println(1);\n                return;\n            }\n            int[] sum = new int[s.length() + 1];\n            for (int i = 0; i < s.length(); ++i) {\n                sum[i + 1] = sum[i];\n                if (s.charAt(i) == 'a')\n                    sum[i + 1] += 1;\n                else if (s.charAt(i) == 'b')\n                    sum[i + 1] += 2;\n                else\n                    throw new RuntimeException();\n                sum[i + 1] %= 3;\n            }\n            int[][] next = new int[3][s.length() + 2];\n            for (int i = 0; i < 3; ++i) {\n                next[i][s.length() + 1] = s.length() + 1;\n            }\n            for (int pos = s.length(); pos >= 0; --pos) {\n                for (int i = 0; i < 3; ++i) {\n                    next[i][pos] = next[i][pos + 1];\n                }\n                next[sum[pos]][pos] = pos;\n            }\n            int total = sum[s.length()];\n            long[] ways = new long[s.length() + 2];\n            ways[0] = 1;\n            for (int i = 0; i <= s.length(); ++i) {\n                int need = (sum[i] + 1) % 3;\n                ways[next[need][i]] += ways[i];\n                ways[next[need][i]] %= MODULO;\n                need = (sum[i] + 2) % 3;\n                ways[next[need][i]] += ways[i];\n                ways[next[need][i]] %= MODULO;\n            }\n            long res = 0;\n            for (int i = 1; i <= s.length(); ++i)\n                if (sum[i] == total) {\n                    res = (res + ways[i]) % MODULO;\n                }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tchar[] s = ns().toCharArray();\n\t\tint n = s.length;\n\t\tint mod = 1000000007;\n\t\t\n\t\tint[] cum = new int[n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcum[i+1] = cum[i] + s[i]-'a' + 1;\n\t\t}\n\t\tint[][] next = makeFatNext(cum);\n\t\t\n\t\tint fl = n-1;\n\t\tfor(int i = n-2;i >= 0;i--){\n\t\t\tif(s[i] != s[i+1]){\n\t\t\t\tfl--;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fl == 0){\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tlong[] dp = new long[n+1];\n\t\tdp[0] = 1;\n\t\tfor(int i = 0;i <= n;i++){\n\t\t\tfor(int j = 1;j <= 2;j++){\n\t\t\t\t// jump to end\n\t\t\t\tif((cum[n] - cum[i]) % 3 == j){\n\t\t\t\t\tans += dp[i];\n\t\t\t\t}\n\t\t\t\tint nex = next[(cum[i]+j)%3][i+1]-1;\n//\t\t\t\ttr(i, j, nex);\n\t\t\t\tif(nex <= n){\n\t\t\t\t\tdp[nex] += dp[i];\n\t\t\t\t\tdp[nex] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\ttr(next);\n//\t\ttr(dp);\n\t\tout.println(ans%mod);\n\t}\n\t\n\tpublic static int[][] makeFatNext(int[] s)\n\t{\n\t\tint n = s.length;\n\t\tint[][] next = new int[3][n+1];\n\t\tfor(int i = 0;i < 3;i++)next[i][n] = n+1;\n\t\tfor(int i = s.length-1;i >= 0;i--){\n\t\t\tfor(int j = 0;j < 3;j++)next[j][i] = next[j][i+1];\n\t\t\tnext[s[i]%3][i] = i+1;\n\t\t}\n\t\treturn next;\n\t}\n\t\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal static String aa = \"aa\";\n\tfinal static String a = \"a\";\n\tfinal static String bb = \"bb\";\n\tfinal static String b = \"b\";\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.next();\n\n\t\tif (!s.contains(aa) && !s.contains(bb)) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\n\t\tMap<String, String> sm = new HashMap<String, String>();\n\t\tint n = 1;\n\n\t\tsm.put(s, \"\");\n\n\t\twhile (sm.size() > 0) {\n\t\t\tMap<String, String> m = new HashMap<String, String>();\n\n\t\t\tfor (String str : sm.keySet()) {\n\t\t\t\tint i = 0;\n\t\t\t\twhile (i >= 0) {\n\t\t\t\t\ti = str.indexOf(aa, i);\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tString replaced = str.substring(0, i) + b + str.substring(i + 2, str.length());\n\t\t\t\t\ti++;\n\t\t\t\t\tm.put(replaced, \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (String str : sm.keySet()) {\n\t\t\t\tint i = 0;\n\t\t\t\twhile (i >= 0) {\n\t\t\t\t\ti = str.indexOf(bb, i);\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tString replaced = str.substring(0, i) + a + str.substring(i + 2, str.length());\n\t\t\t\t\ti++;\n\t\t\t\t\tm.put(replaced, \"\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tn += m.size();\n\t\t\tsm = m;\n\t\t}\n\n\t\tSystem.out.println(n);\n\n\t\treturn;\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Program\n{\n\tstatic void Main()\n\t{\n\tstring input = Console.ReadLine();\n\tint answer = 1;\n    \n    for(int i = 0; i < input.Length; i++)\n    {\n      if(input[i] == input[i + 1])\n               {\n                 answer ++;\n               }\n      \n    }\n      \n\tConsole.WriteLine(answer);\n\t}\n}"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nstring s;\nvi a,S,b[3],g[2];\n\nint main(){\n\tcin>>s;\n\tn=s.size();\n\ta=vi(n);S=vi(n+1);\n\tb[0]=b[1]=b[2]=g[0]=g[1]=vi(n+1,-1);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='a') a[i]=2;\n\t\telse a[i]=1;\n\t}\n\tfor(int i=1;i<=n;i++) S[i]=S[i-1]+a[i-1];\n\tfor(int i=n-1;i>=0;i--){\n\t\tb[a[i]][i]=i+1;\n\t\tfor(int j=0;j<3;j++) if(j!=a[i]){\n\t\t\tb[j][i]=b[(j-a[j]+3)%3][i+1];\n\t\t}\n\t}\n\tint I=-1;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i!=n-1&&s[i]==s[i+1]) I=i+2;\n//\t\tcout<<I<<endl;\n\t\tif(s[i]=='a'){\n\t\t\tg[0][i]=i+1;\n\t\t\tif(I==-1) continue;\n\t\t\tint t=(4-S[I]+S[i])%3;\n\t\t\tif(!t) g[1][i]=I;\n\t\t\telse g[1][i]=b[(4-S[I]+S[i])%3][I];\n\t\t}\n\t\telse{\n\t\t\tg[1][i]=i+1;\n\t\t\tif(I==-1) continue;\n\t\t\tint t=(5-S[I]+S[i])%3;\n\t\t\tif(!t) g[0][i]=I;\n\t\t\telse g[0][i]=b[(5-S[I]+S[i])%3][I];\n\t\t}\n\t}\n\tint J=-1;\n\tfor(int i=n-2;i>=0;i--) if(s[i]==s[i+1]){\n\t\tJ=i+2;\n\t\tbreak;\n\t}\n\tif(J==-1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tvi dp(n+1);\n\tdp[0]++;\n\tint res=0;\n\tfor(int i=0;i<n;i++) for(int j=0;j<2;j++) if(g[j][i]!=-1){\n\t\tI=g[j][i];\n\t\t(dp[I]+=dp[i])%=mod;\n\t\tif((S[n]-S[I]+3)%3==0&&(I!=i+1||i+1>=I))(res+=dp[i])%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ns = input()\n\nq = deque()\nq.append(s)\nc = []\nc.append(s)\n\na = 1\np = 1000000007\nL = len(s) - 1\nwhile q:\n    x = q.popleft()\n    l = len(x)\n    if L == l:\n        L -= 1\n        c = []\n    for i in range(l-1):\n        if x[i] == \"a\" and x[i+1] == \"a\":\n            t = x[:i] + \"b\" + x[i+2:]\n            w = True\n            for j in c:\n                if t == j:\n                    w = False\n                    break\n            if w:\n                q.append(t)\n                c.append(t)\n                a += 1\n        elif x[i] == \"b\" and x[i+1] == \"b\":\n            t = x[:i] + \"a\" + x[i+2:]\n            w = True\n            for j in c:\n                if t == j:\n                    w = False\n                    break\n            if w:\n                q.append(t)\n                c.append(t)\n                a += 1\n        if a == p:\n            a = 0\n\nprint(a)\n"
  }
]