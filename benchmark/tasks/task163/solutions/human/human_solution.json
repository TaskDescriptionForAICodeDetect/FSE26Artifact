[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n\n\n  val Array(height, width) = readLine.trim.split(' ').map(_.toInt)\n  val state = Array.tabulate(height){_ ⇒ readLine.trim.split(' ').map(_.toInt)}\n  val sortedPosition = (0 until height).flatMap(y ⇒ (0 until width).map(x ⇒ Coordinate(x, y))).sortBy(c ⇒ state(c.y)(c.x))\n  val isRidge: Array[Array[Option[Int]]] = Array.tabulate(height){_ ⇒ Array.tabulate(width){_ ⇒ None:Option[Int]}}\n  var res = 0\n  for (c ← sortedPosition){\n    val lower = c.neighbors.filter(n ⇒ (0 until height).contains(n.y) && (0 until width).contains(n.x) && state(n.y)(n.x) < state(c.y)(c.x)).map(n ⇒ isRidge(n.y)(n.x))\n    if (lower.exists(_.isEmpty) || lower.flatten.toList.distinct.length >= 2){\n      res += 1\n    }else if (lower.flatten.toList.distinct.length == 1) {\n      isRidge(c.y)(c.x) = Some(lower.flatten.head)\n    }else {\n      isRidge(c.y)(c.x) = Some(state(c.y)(c.x))\n    }\n  }\n  println(res)\n\n  case class Coordinate(x: Int, y: Int) {\n    def neighbors: Iterable[Coordinate] = List(Coordinate(0, 1), Coordinate(0, -1), Coordinate(1, 0), Coordinate(-1, 0)).map(this + _)\n    def +(that: Coordinate): Coordinate = Coordinate(x + that.x, y + that.y)\n  }\n  implicit class ScopeFunc[T](val value: T){\n    def let[A](func: T ⇒ A): A = func(value)\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nstruct H {\n\tint x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\nint ari(int a, int b, int c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\n//---------------------------------------------------\n//+++++++++++++++++++++++++++++++++++++++++++++++++++\nint h, w, a[1000][1000];\nH b[1000001];\nsigned main() {\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++)\n\t\tfor (int j = 0; j < w; j++)\n\t\t\tcin >> a[i][j];\n\tpriority_queue<H, vector<H>, greater<H>>p;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tb[a[i][j]] = H{ i,j };\n\t\t\tif (i > 0 && a[i - 1][j] < a[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (i < h - 1 && a[i + 1][j] < a[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (j > 0 && a[i][j - 1] < a[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (j < w - 1 && a[i][j + 1] < a[i][j])\n\t\t\t\tcontinue;\n\t\t\tp.push(H{ a[i][j], a[i][j] });\n\t\t}\n\t}\n\tint ans = 0;\n\twhile (!p.empty()) {\n\t\tint f = p.top().x, sum = 0;\n\t\tint x = b[f].x, y = b[f].y;\n\t\twhile (!p.empty() && p.top().x == f) {\n\t\t\tint t = p.top().y;\n\t\t\twhile (!p.empty() && p.top().y == t&&p.top().x == f) {\n\t\t\t\tp.pop();\n\t\t\t}\n\t\t\tif (x > 0 && a[x - 1][y] > a[x][y])\n\t\t\t\tp.push(H{ a[x - 1][y],t });\n\t\t\tif (x < h - 1 && a[x + 1][y] > a[x][y])\n\t\t\t\tp.push(H{ a[x + 1][y],t });\n\t\t\tif (y > 0 && a[x][y - 1] > a[x][y])\n\t\t\t\tp.push(H{ a[x][y - 1],t });\n\t\t\tif (y < w - 1 && a[x][y + 1] > a[x][y])\n\t\t\t\tp.push(H{ a[x][y + 1],t });\n\t\t\tsum++;\n\t\t}\n\t\tif (sum > 1)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"{\";\n    for (int i = 0; i < v.size(); ++i) {\n        if(i) os << \", \";\n        os << v[i];\n    }\n    return os << \"}\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"{\" << p.first << \", \" << p.second << \"}\";\n}\n\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    auto v = make_v(h+2, w+2, 0);\n    auto dp = make_v(h+2, w+2, -1);\n    vector<pair<int, int>> u(h*w);\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            scanf(\"%d\", &v[i+1][j+1]);\n            u[i*w+j] = {i+1, j+1};\n        }\n    }\n    using P = pair<int, int>;\n    sort(u.begin(),u.end(), [&v](P a, P b){\n        return v[a.first][a.second] < v[b.first][b.second];\n    });\n    array<int, 4> dy{-1, 1, 0, 0}, dx{0, 0, 1, -1};\n    int ans = 0;\n    for (int i = 0; i < h*w; ++i) {\n        int y, x; tie(y, x) = u[i];\n        for (int k = 0; k < 4; ++k) {\n            if(dp[y+dy[k]][x+dx[k]] == -1) continue;\n            else if(dp[y+dy[k]][x+dx[k]] == -2) dp[y][x] = -2;\n            else if(dp[y][x] >= 0 && dp[y+dy[k]][x+dx[k]] != dp[y][x]){\n                dp[y][x] = -2;\n            } else dp[y][x] = dp[y+dy[k]][x+dx[k]];\n            if(dp[y][x] == -2) break;\n        }\n        if(dp[y][x] == -1) dp[y][x] = v[y][x];\n        if(dp[y][x] == -2) ans++;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n    int a, b, h, w;\n    int nm = 0;\n    cin >> h >> w;\n    int chart[h + 2][w + 2];\n    int water[h + 2][w + 2][2];\n    for(int i = 0; i < h + 2; i++) {\n        for(int j = 0; j < w + 2; j++) {\n            if(j == 0 || j == w + 1 || i == 0 || i == h + 1)\n                chart[i][j] = h * w + 1;\n            else\n                cin >> chart[i][j];\n            water[i][j][0] = 0;\n            water[i][j][1] = 0;\n        }\n    }\n\n    for(int i = 0; i < h; i++) {\n        for(int j = 0; j < w; j++) {\n            if(chart[i + 1][j + 1] < chart[i][j + 1] &&\n               chart[i + 1][j + 1] < chart[i + 2][j + 1] &&\n               chart[i + 1][j + 1] < chart[i + 1][j] &&\n               chart[i + 1][j + 1] < chart[i + 1][j + 2]) {\n                for(int x = 0; x < h; x++) {\n                    for(int y = 0; y < w; y++)\n                        water[x + 1][y + 1][1] = 0;\n                }\n\n                queue<pair<int, int>> q;\n                q.push(make_pair(i + 1, j + 1));\n                while(q.empty() == false) {\n                    pair<int, int> tmp = q.front();\n                    a = tmp.first;\n                    b = tmp.second;\n                    q.pop();\n                    if(water[a][b][1] == 1)\n                        continue;\n\n                    water[a][b][0]++;\n                    water[a][b][1] = 1;\n\n                    if(chart[a][b] < chart[a][b + 1] &&\n                       water[a][b + 1][1] == 0 && water[a][b + 1][0] < 2)\n                        q.push(make_pair(a, b + 1));\n                    if(chart[a][b] < chart[a][b - 1] &&\n                       water[a][b - 1][1] == 0 && water[a][b - 1][0] < 2)\n                        q.push(make_pair(a, b - 1));\n                    if(chart[a][b] < chart[a + 1][b] &&\n                       water[a + 1][b][1] == 0 && water[a + 1][b][0] < 2)\n                        q.push(make_pair(a + 1, b));\n                    if(chart[a][b] < chart[a - 1][b] &&\n                       water[a - 1][b][1] == 0 && water[a - 1][b][0] < 2)\n                        q.push(make_pair(a - 1, b));\n                }\n            }\n        }\n    }\n    for(int i = 0; i < h; i++) {\n        for(int j = 0; j < w; j++) {\n            if(water[i + 1][j + 1][0] >= 2)\n                nm++;\n        }\n    }\n    cout << nm << endl;\n    return 0;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<set>\n#define int long long\n#define mod 1000000007\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\nusing namespace std;\nint h, w, map[1002][1002], ans = 0;\nset<int>s[1000010];\nvector<int>v[1000010];\nbool b[1000007];\nsigned main() {\n\tcin >> h >> w;\n\tfor1(i, h)for1(j, w)cin >> map[i][j];\n\tfor1(i, h - 1)for1(j, w) {\n\t\tv[min(map[i][j], map[i + 1][j])].push_back(max(map[i][j], map[i + 1][j]));\n\t\tb[max(map[i][j], map[i + 1][j])] = 1;\n\t}\n\tfor1(i, h)for1(j, w - 1) {\n\t\tv[min(map[i][j], map[i][j + 1])].push_back(max(map[i][j], map[i][j + 1]));\n\t\tb[max(map[i][j], map[i][j + 1])] = 1;\n\t}\n\tfor1(i, h*w) {\n\t\tif (!b[i]) {\n\t\t\tfor (int j : v[i])s[j].insert(i);\n\t\t}\n\t\telse {\n\t\t\tif (s[i].size() >= 2)ans++;\n\t\t\tfor (int j : v[i])for (int k : s[i])s[j].insert(k);\n\t\t}\n\t\ts[i].clear();\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n#define ALL(a)  a.begin(),a.end()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing LL = long long; template<class T> using V = vector<T>;\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint H, W;\n\tcin >> H >> W;\n\tV<V<int>>vs(H, V<int>(W));\n\tusing PII = pair<int, int>;\n\tV<pair<int, PII>>q;\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tcin >> vs[i][j];\n\t\t\tq.push_back({ vs[i][j] ,{i,j} });\n\t\t}\n\t}\n\tconst int DY[] = { 0,0,1,-1 };\n\tconst int DX[] = { 1,-1,0,0 };\n\tSORT(q);\n\t// unordered_set\n\tV<V<set<int>>>RootFlow(H, V<set<int>>(W));\n\tFOR(i, 0, SZ(q)) {\n\t\tint m = q[i].first;\n\t\tint y = q[i].second.first, x = q[i].second.second;\n\t\tif (!SZ(RootFlow[y][x])) {\n\t\t\tRootFlow[y][x].insert(m); // s\n\t\t}\n\t\tFOR(k, 0, 4) {\n\t\t\tint ny = y + DY[k], nx = x + DX[k];\n#define IN(a,b,c) a<=b&&b<c\n\t\t\tif (IN(0, ny, H) && IN(0, nx, W)) {\n\t\t\t\tif (vs[ny][nx] > vs[y][x]) {\n\t\t\t\t\tfor (const auto&it : RootFlow[y][x]) {\n\t\t\t\t\t\tRootFlow[ny][nx].insert(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tans += (SZ(RootFlow[i][j]) > 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nbool in_field(int x, int y, int W, int H)\n{\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nint main()\n{\n    int H, W;\n    cin >> H >> W;\n    vector<vector<int>> M(H, vector<int>(W));\n    vector<pair<int, int>> a(H * W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> M[i][j];\n            a[M[i][j] - 1] = make_pair(j, i);\n        }\n    }\n    \n    vector<vector<int>> ridge(H, vector<int>(W, -1));\n    constexpr int dx[] = {-1, 0, 1, 0};\n    constexpr int dy[] = {0, -1, 0, 1};\n    \n    int res = 0;\n    for (int i = 0; i < H * W; i++) {\n        int x, y, large_cnt = 0;\n        vector<int> r;\n        tie(x, y) = a[i];\n        for (int j = 0; j < 4; j++) {\n            int nx = x + dx[j];\n            int ny = y + dy[j];\n            \n            if (!in_field(nx, ny, W, H)) {\n                ++large_cnt;\n                continue;\n            }\n            if (ridge[ny][nx] >= 0) {\n                r.emplace_back(ridge[ny][nx]);\n            }\n                \n            large_cnt += (M[y][x] < M[ny][nx]);\n        }\n\n        constexpr int MUL = 252521;\n        \n        if (large_cnt == 4) {\n            ridge[y][x] = i;\n        } else {\n            sort(r.begin(), r.end());\n            r.erase(unique(r.begin(), r.end()), r.end());\n            \n            int rs = r.size();\n            if (rs == 1) {\n                ridge[y][x] = r[0];\n            } else {\n                ridge[y][x] = MUL;\n            }\n        }\n\n        if (ridge[y][x] == MUL) {\n            ++res;\n        }\n    }\n\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int dx[4] = { 0, 0, 1, -1 };\nconst int dy[4] = { 1, -1, 0, 0 };\nint h, w;\nint m[1005][1005];\nint memo[1005][1005];\nusing P = pair<int, int>;\nP p[1005 * 1005];\n\nbool checkRange(int x, int y)\n{\n\treturn (0 <= x && x < w) && (0 <= y && y < h);\n}\n\nint main()\n{\n\tcin >> h >> w;\n\n\tfor (int y = 0; y < h; y++)\n\t{\n\t\tfor (int x = 0; x < w; x++)\n\t\t{\n\t\t\tcin >> m[x][y];\n\t\t\tp[m[x][y]] = P(x, y);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= h * w; i++)\n\t{\n\t\tint x = p[i].first;\n\t\tint y = p[i].second;\n\t\tmemo[x][y] = m[x][y];\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint X = x + dx[j];\n\t\t\tint Y = y + dy[j];\n\t\t\tif (checkRange(X, Y) && m[x][y] > m[X][Y])\n\t\t\t{\n\t\t\t\tif (memo[X][Y] == -1)\n\t\t\t\t{\n\t\t\t\t\tmemo[x][y] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (memo[x][y] == m[x][y])\n\t\t\t\t{\n\t\t\t\t\tmemo[x][y] = memo[X][Y];\n\t\t\t\t}\n\t\t\t\telse if (memo[x][y] != memo[X][Y])\n\t\t\t\t{\n\t\t\t\t\tmemo[x][y] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int y = 0; y < h; y++)\n\t{\n\t\tfor (int x = 0; x < w; x++)\n\t\t{\n\t\t\tif (memo[x][y] == -1) ans++;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n\nint a[1002][1002], b[20004];\nvector<int> G[1002];\nint dy[4] = {-1, 0, 0, 1}, dx[4] = {0, -1, 1, 0};\nqueue<int> q;\nint main(){\n\tint h, w, ans = 0;\n\tscanf(\"%d%d\", &h, &w);\n\trrep(i,h)rrep(j,w)scanf(\"%d\", &a[i][j]);\n\trrep(y,h)rrep(x,w){\n\t\tint f = 0;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tif(a[y][x] < a[y+dy[i]][x+dx[i]]){\n\t\t\t\tG[a[y][x]].push_back(a[y+dy[i]][x+dx[i]]);\n\t\t\t\tf++;\n\t\t\t}\n\t\t\tif(a[y+dy[i]][x+dx[i]] == 0)f++;\n\t\t}\n\t\tif(f == 4)q.push(a[y][x]);\n\t}\n\t\n\twhile(!q.empty()){\n\t\tint p = q.front();q.pop();\n\t\tif(b[p] == 0)b[p] = p;\n\t\tfor(int i = 0;i < G[p].size();i++){\n\t\t\tint t = G[p][i];\n\t\t\tif(b[t] == 0){\n\t\t\t\tb[t] = b[p];\n\t\t\t\tq.push(t);\n\t\t\t}else if(b[t] != b[p] && b[t] != -1){\n\t\t\t\tb[t] = -1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<cstdlib>\n#include<list>\n#include<set>\n#include<numeric>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint field[1010][1010],h[1010][1010];\nint dx[] = { 1,0,-1,0 }, dy[] = {0,1,0,-1};\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint ddx = dx[k] + j, ddy = dy[k] + i;\n\t\t\t\tif (ddx >= 0 && ddx < W && ddy >= 0 && ddy < H) {\n\t\t\t\t\tif (field[i][j] > field[ddy][ddx]) {\n\t\t\t\t\t\th[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint ddx = dx[k] + j, ddy = dy[k] + i;\n\t\t\t\tif (ddx >= 0 && ddx < W && ddy >= 0 && ddy < H) {\n\t\t\t\t\tif ((h[i][j] >= 2) && h[ddy][ddx] == 0) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//const int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\n\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tN = H * W;\n\tvector<vector<int>>v(H + 2, vector<int>(W + 2,MOD));\n\tvector<pair<int, int>>p(N + 1);\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> v[i][j];\n\t\t\tp[v[i][j]] = { i,j };\n\t\t}\n\t}\n\tint dir[] = { 0,1,0,-1,0 };\n\tint ans = 0;\n\tvector<int>ed(N + 1,1);\n\tfor (int i = 2; i <= N; i++) {\n\t\tset<int>st;\n\t\tint y = p[i].first;\n\t\tint x = p[i].second;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint ny = y + dir[j];\n\t\t\tint nx = x + dir[j + 1];\n\t\t\tint num = v[ny][nx];\n\t\t\tif (num > i)continue;\n\t\t\tif (ed[num] == -1) {\n\t\t\t\tst.insert(-MOD);\n\t\t\t\tst.insert(MOD);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.insert(ed[num]);\n\t\t\t}\n\t\t}\n\t\tif (st.size() > 1) {\n\t\t\ted[i] = -1;\n\t\t\tans++;\n\t\t}\n\t\telse if (st.size() == 1)ed[i] = *st.begin();\n\t\telse ed[i] = i;\n\t\t//cout << i << \" \" << ed[i] << endl;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint H, W;\nint ans = 0;\nint INF = 10000000;\nint a[1001][1001];\nint memo[1001][1001];\n\nint a_(int i, int j){\n\tif(i < 0 || j < 0 || i >= H || j >= W){\n\t\treturn INF;\n\t}\n\treturn a[i][j];\n}\n\nint search(int i, int j){\n\tif(i < 0 || j < 0 || i >= H || j >= W){\n\t\treturn -1;\n\t}\n\tif(memo[i][j] > 0){\n\t\treturn memo[i][j];\n\t}\n\tint cnt = 0;\n\tint num = 0;\n\tif(a_(i, j) > a_(i - 1, j)){\n\t\tint ret = search(i - 1, j);\n\t\tif(ret > 0){\n\t\t\tcnt++;\n\t\t\tif(num == ret){\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tnum = ret;\n\t\t}\n\t}\n\tif(a_(i, j) > a_(i + 1, j)){\n\t\tint ret = search(i + 1, j);\n\t\tif(ret > 0){\n\t\t\tcnt++;\n\t\t\tif(num == ret){\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tnum = ret;\n\t\t}\n\t}\n\tif(a_(i, j) > a_(i, j - 1)){\n\t\tint ret = search(i, j - 1);\n\t\tif(ret > 0){\n\t\t\tcnt++;\n\t\t\tif(num == ret){\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tnum = ret;\n\t\t}\n\t}\n\tif(a_(i, j) > a_(i, j + 1)){\n\t\tint ret = search(i, j + 1);\n\t\tif(ret > 0){\n\t\t\tcnt++;\n\t\t\tif(num == ret){\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tnum = ret;\n\t\t}\n\t}\n\tif(cnt == 0){\n\t\tnum = a[i][j];\n\t}\n\tif(cnt > 1){\n\t\tnum = INF;\n\t}\n\tmemo[i][j] = num;\n\tif(num == INF){\n\t\tans++;\n\t}\n\treturn num;\n}\n\nint main(){\n\t\n\tcin >> H >> W;\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t\tmemo[i][j] = -1;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(memo[i][j] == -1){\n\t\t\t\tsearch(i, j);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcout << memo[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_height){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\theight = arg_height;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn height < arg.height;\n\t};\n\n\tint row,col,height;\n};\n\nint H,W;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint memo[1000][1000],table[1000][1000];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvector<Info> recursive(int row,int col,int depth){\n\n\tvector<Info> sum,catcher,ret;\n\n\tint adj_row,adj_col;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = row + diff_row[i];\n\t\tadj_col = col + diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] > table[row][col])continue;\n\n\t\tcatcher = recursive(adj_row,adj_col,depth+1);\n\n\t\tfor(int k = 0; k < catcher.size(); k++){\n\t\t\tsum.push_back(catcher[k]);\n\t\t}\n\t\tcatcher.clear();\n\t}\n\n\tif(sum.size() == 0){\n\t\tmemo[row][col] = 0;\n\t\tif(depth > 0){\n\t\t\tsum.push_back(Info(row,col));\n\t\t}\n\t\treturn sum;\n\t}\n\n\tsort(sum.begin(),sum.end());\n\n\tint pre_row = sum[0].row,pre_col = sum[0].col;\n\tret.push_back(sum[0]);\n\n\tfor(int i = 1; i < sum.size(); i++){\n\t\tif(sum[i].row != pre_row || sum[i].col != pre_col){\n\t\t\tret.push_back(sum[i]);\n\t\t}\n\t\tpre_row = sum[i].row;\n\t\tpre_col = sum[i].col;\n\t}\n\n\tmemo[row][col] = ret.size();\n\n\treturn ret;\n\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tpriority_queue<Data> Q;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&table[row][col]);\n\t\t\tQ.push(Data(row,col,table[row][col]));\n\t\t\tmemo[row][col] = -1;\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\tif(memo[Q.top().row][Q.top().col] == -1){\n\t\t\trecursive(Q.top().row,Q.top().col,0);\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tint ans = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(memo[row][col] > 1){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Point = pair<int, int>;\n\nconst int INF = 1e6 + 1;\nint H, W;\nvector<vector<int>> height, way;\n\nvector<Point> next(int y, int x) {return {{y-1, x}, {y+1, x}, {y, x-1}, {y, x+1}};}\n\nbool bottom(int y, int x) {\n  for(auto p: next(y, x)) if(height[p.first][p.second] < height[y][x]) return false;\n  return true;\n}\n\nvoid mark(int sy, int sx) {\n  queue<Point> q;\n  q.emplace(sy, sx);\n  vector<vector<bool>> visited(H+2, vector<bool>(W+2, false));\n  while(!q.empty()) {\n    int y, x;\n    tie(y, x) = q.front();\n    q.pop();\n    if(height[y][x] == INF) continue;\n    if(visited[y][x]) continue;\n    visited[y][x] = true;\n    if(2 <= way[y][x]) continue;\n    ++way[y][x];\n    for(auto p: next(y, x)) if(height[y][x] < height[p.first][p.second]) if(!visited[p.first][p.second]) q.emplace(p.first, p.second);\n  }\n}\n\nint main() {\n  cin >> H >> W;\n  height.assign(H+2, vector<int>(W+2, INF));\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> height[i][j];\n\n  way.assign(H+2, vector<int>(W+2, 0));\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(bottom(i, j)) {\n    mark(i, j);\n  }\n\n  auto ans = 0;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(2 <= way[i][j]) ++ans;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int INF = 1000000000;\n\nint h, w;\nint m[1000][1000];\nint d[1000][1000]; // ok => INF - 1, one => number, zero => imposible, INF => not check yet\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint check(int y, int x) {\n  if (d[y][x] != INF) return d[y][x];\n  int temp = 0;\n  for (int k = 0; k < 4; k++) {\n    int ny = y + dy[k], nx = x + dx[k];\n    if (ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n    if (m[y][x] > m[ny][nx]) {\n      int t = check(ny, nx);\n      if (t == INF - 1) return d[y][x] = INF - 1;\n      if (temp != 0 && temp != t) return d[y][x] = INF - 1;\n      if (t == 0) {\n        temp = m[ny][nx];\n        continue;\n      }\n      temp = t;\n    }\n  }\n  return d[y][x] = temp;\n}\n\nint main() {\n  scanf(\"%d%d\", &h, &w);\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) scanf(\"%d\", &m[i][j]);\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) d[i][j] = INF;\n  int ans = 0;\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) if (check(i, j) == INF - 1) ans++;\n  printf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n\nint h, w;\nint maze[1010][1010];\nvector<pair<int, pair<int, int>>> v;\nint memo[1001000];\nint ans;\n\nint main() {\n\tcin >> h >> w;\n\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> maze[i][j];\n\t\t\tv.push_back(mp(maze[i][j], mp(i, j)));\n\t\t}\n\t}\n\tsort(ALL(v));\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tint next = v[i].first;\n\t\tint sum = 0;\n\t\tpair<int, pair<int, int>> now = v[i];\n\t\tbool flag = false;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint x = now.second.first + dx[j],\n\t\t\t\ty = now.second.second + dy[j];\n\t\t\tif (0 > x || x >= h || 0 > y || y >= w)continue;\n\t\t\tif (maze[x][y] == -1) {\n\t\t\t\tmaze[now.second.first][now.second.second] = -1;\n\t\t\t\tflag = true;\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (maze[x][y] > maze[now.second.first][now.second.second])continue;\n\t\t\tif (memo[maze[x][y]] != i + 1) {\n\t\t\t\tmemo[maze[x][y]] = i + 1;\n\t\t\t\tsum++;\n\t\t\t\tnext = maze[x][y];\n\t\t\t}\n\t\t}\n\t\tif (!flag && sum > 1) {\n\t\t\tans++;\n\t\t\tmaze[now.second.first][now.second.second] = -1;\n\t\t}\n\t\telse if (!flag)maze[now.second.first][now.second.second] = next;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n        ll h, w;\n        scanf(\"%lld %lld\", &h, &w);\n\n        ll fig[h+2][w+2], x[h*w+1], y[h*w+1];\n        for(int j=0; j<w; j++) fig[0][j]=0, fig[h+1][j]=1e11;\n        for(int i=0; i<h; i++) fig[i][0]=0, fig[i][w+1]=1e11;\n\n        for(int i=1; i<=h; i++){\n                for(int j=1; j<=w; j++){\n                        ll tmp;\n                        scanf(\"%lld\", &tmp);\n                        fig[i][j] = tmp;\n                        x[tmp] = i, y[tmp] = j;\n                }\n        }\n\n        ll ans = 0, chgeIn[h+2][w+2];\n        for(int i=0; i<h+2; i++)for(int j=0; j<w+2; j++)chgeIn[i][j]=0;\n\n        ll dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n        for(int i=1; i<=h*w; i++){\n                for(int j=0; j<4; j++){\n                        ll tx = x[i] + dx[j], ty = y[i] + dy[j];\n                        if(fig[tx][ty]<fig[x[i]][y[i]]){\n                                if(chgeIn[tx][ty]==0)continue;\n                                if(chgeIn[x[i]][y[i]]!=0 and chgeIn[x[i]][y[i]]!=chgeIn[tx][ty]){\n                                        chgeIn[x[i]][y[i]] = -1;\n                                }else{\n                                        chgeIn[x[i]][y[i]] = chgeIn[tx][ty];\n                                }\n                        }\n                }\n                if(chgeIn[x[i]][y[i]]==0) chgeIn[x[i]][y[i]] = i;\n                else if(chgeIn[x[i]][y[i]]==-1) ans++;\n        }\n\n        //for(int i=0; i<h; i++){for(int j=0; j<w; j++)printf(\"%lld \", chgeIn[i+1][j+1]);puts(\"\");}\n        printf(\"%lld\\n\", ans);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n//#define INF (1e9+1)\n#define INF (1LL<<59)\n\n#define MAX_V 1001*1001\n\nint h,w;\nint f(int y,int x){return y*w+x;};\n\nvector<int> G[MAX_V];\n\n\nset<int> dp[1001*1001];\n\nset<int> dfs(int v){\n    if(dp[v].size()!=0)return dp[v];\n    \n    set<int> ret;\n    \n    for(auto &e:G[v]){\n        if(ret.size()>=2)continue;\n        set<int> res = dfs(e);\n        if(ret.size()==0)ret = res;\n        else ret.insert(*res.begin());\n    }\n    \n    return dp[v] = ret;;\n}\n\nint main(){\n    \n    cin>>h>>w;\n    static int inp[1001][1001];\n    \n    rep(i,h)rep(j,w)cin>>inp[i][j];\n    \n    \n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n    \n    rep(i,h){\n        rep(j,w){\n            int c=0;\n            rep(k,4){\n                int ddy = i+dy[k];\n                int ddx = j+dx[k];\n                \n                if( ddx>=0 && ddy>=0 && ddx<w && ddy<h && inp[ddy][ddx]<inp[i][j] ){\n                    G[f(i,j)].pb(f(ddy,ddx));\n                    c++;\n                }\n            }\n            if(c==0){\n                dp[f(i,j)].insert(f(i,j));\n                //                cout<<i<<\" \"<<j<<endl;\n            }\n        }\n    }\n    \n    \n    \n    int c=0;\n    rep(i,h){\n        rep(j,w){\n            if(dfs(f(i,j)).size()>=2)c++;\n        }\n    }\n    cout<<c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int inf = 1e9 + 9;\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\n\nint m[1010][1010];\nint d[1010][1010];\nint x[1010101], y[1010101];\n\nint main()\n{\n  int h, w;\n  cin >> h >> w;\n  for (int i = 0; i < h + 2; i++){\n    for (int j = 0; j < w + 2; j++){\n      m[i][j] = inf;\n      d[i][j] = 0;\n    }\n  }\n\n  for (int i = 1; i <= h; i++){\n    for (int j = 1; j <= w; j++){\n      cin >> m[i][j];\n    }\n  }\n\n  //?????±???????????????\n  for (int i = 1; i <= h; i++){\n    for (int j = 1; j <= w; j++){\n      y[m[i][j]] = i;\n      x[m[i][j]] = j;\n    }\n  }\n\n  int ans = 0;\n  for (int i = 1; i <= h * w; i++){\n    int r = 0;\n    for (int j = 0; j < 4; j++){\n      int nx = x[i] + dx[j], ny = y[i] + dy[j];\n      //2????????°?????????r???-1?????£??\\?????????\n      if (m[ny][nx] < i){\n        if (r == 0) r = d[ny][nx];\n        else if (r != d[ny][nx]) r = -1;\n      }\n    }\n\n    //?°´??????????????????\n    if (r == 0) d[y[i]][x[i]] = i;\n    else d[y[i]][x[i]] = r;\n\n    //?°????\n    if (r == -1) ans++;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long ll;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint he[1000][1000];\nint give[1000][1000];\nPII p[1000000];\n\nint dxy[] = {0,1,0,-1,0};\n\nint main() {\n\tint h,w;\n\tcin >> h >> w;\n\tREP(j,h)\n\t\tREP(i,w){\n\t\t\tcin >> he[i][j];\n\t\t\the[i][j]--;\n\t\t\tp[he[i][j]] = MP(i,j);\n\t}\n\tint ans=0;\n\tREP(i, w*h){\n\t\tbool f=false;\n\t\tREP(d,4){\n\t\t\tint nx = p[i].first + dxy[d], ny = p[i].second + dxy[d+1];\n\t\t\tif(nx < 0 || w <= nx || ny < 0 || h <= ny)continue;\n\t\t\tif(i>he[nx][ny])f|=true;\n\t\t}\n\t\tif(f)continue;\n\t\tqueue<PII> q;\n\t\tq.push(p[i]);\n\t\tbool did[w][h];\n\t\tCLR(did);\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\tint nhe = he[x][y];\n\t\t\tq.pop();\n\t\t\tREP(d,4){\n\t\t\t\tint nx = x + dxy[d], ny = y + dxy[d+1];\n\t\t\t\tif(nx < 0 || w <= nx || ny < 0 || h <= ny)continue;\n\t\t\t\tif(nhe>he[nx][ny])continue; // exclude i\n\t\t\t\tif(did[nx][ny])continue;\n\t\t\t\tdid[nx][ny]=true;\n\t\t\t\tif(give[nx][ny]>1)continue;\n\t\t\t\tgive[nx][ny]++;\n\t\t\t\tif(give[nx][ny]>1)\n\t\t\t\t\tans++;\n\t\t\t\tq.push(MP(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\n\nset<int> d[1111][1111];\nint main() {\n  int n,m;\n  cin >> n >> m;\n  int a[n][m];\n  vector<PP> v;\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<m; j++) {\n      cin >> a[i][j];\n      v.push_back(PP(a[i][j],P(i,j)));\n    }\n  }\n  sort(v.begin(),v.end());\n  int ans=0;\n  for(int i=0; i<v.size(); i++) {\n    int x=v[i].second.first,y=v[i].second.second;\n    if(!d[x][y].size()) d[x][y].insert(v[i].first);\n    if(d[x][y].size()>1) ans++;\n    for(int k=0; k<4; k++) {\n      int xx=x+dx[k],yy=y+dy[k];\n      if(!check(n,m,xx,yy)) continue;\n      if(a[x][y]<a[xx][yy]) {\n        set<int>::iterator it=d[x][y].begin();\n        for(int j=0; j<2; j++,it++) {\n          if(it==d[x][y].end()) break;\n          d[xx][yy].insert(*it);\n        }\n        while(d[xx][yy].size()>2) d[xx][yy].erase(d[xx][yy].begin());\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int dx[4] = { 0, 0, 1, -1 };\nconst int dy[4] = { 1, -1, 0, 0 };\nint h, w;\nint m[1005][1005];\nint memo[1005][1005];\nusing P = pair<int, int>;\nP p[1005 * 1005];\n\nbool checkRange(int x, int y)\n{\n\treturn (0 <= x && x < w) && (0 <= y && y < h);\n}\n\nint main()\n{\n\tcin >> h >> w;\n\n\tfor (int y = 0; y < h; y++)\n\t{\n\t\tfor (int x = 0; x < w; x++)\n\t\t{\n\t\t\tcin >> m[x][y];\n\t\t\tp[m[x][y]] = P(x, y);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= h * w; i++)\n\t{\n\t\tint x = p[i].first;\n\t\tint y = p[i].second;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint X = x + dx[j];\n\t\t\tint Y = y + dy[j];\n\t\t\tif (checkRange(X, Y) && m[x][y] > m[X][Y])\n\t\t\t{\n\t\t\t\tif (memo[X][Y] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (memo[x][y] != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[x][y] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[x][y] = m[X][Y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (memo[X][Y] == -1)\n\t\t\t\t{\n\t\t\t\t\tmemo[x][y] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (memo[x][y] != 0 && memo[x][y] != memo[X][Y])\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[x][y] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[x][y] = memo[X][Y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int y = 0; y < h; y++)\n\t{\n\t\tfor (int x = 0; x < w; x++)\n\t\t{\n\t\t\tif (memo[x][y] == -1) ans++;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[99][99],d[99][99],yy,xx,p,flag;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nset<pair<int,int> >se;\nvoid dfs(int ya,int xa,int dd){\n  d[ya][xa]=p;\n  r(i,4){\n    int y=ya+dy[i],x=xa+dx[i];\n    if(y<0||y>=h||x<0||x>=w)continue;\n    if(a[y][x]>dd){\n      if(d[y][x]&&d[y][x]!=p)se.insert(mk(y,x));\n      dfs(y,x,a[y][x]);\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    dfs(yy,xx,p);\n  }\n  cout<<se.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<map>\n#include<cstdio>\n#include<fstream>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n\n#define mp make_pair\n#define P pair<int,int>\n#define ll __int64\n\nint n,m;\nint t[1005][1005];\nint memo[1005][1005];\npriority_queue<pair<int,P>,vector<pair<int,P> >,greater<pair<int,P> > >se;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\t\t\tset<P>sett;\nvoid dfs(int y,int x){\n\t\t\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx<0||ny<0||nx>=m||ny>=n||sett.find(mp(ny,nx))!=sett.end())continue ;\n\t\tif(t[y][x]<t[ny][nx]){\n\t\t\tmemo[ny][nx]++;\n\t\t\tdfs(ny,nx);\n\t\t\tsett.insert(mp(ny,nx));\n\t\t}\n\t}\n\n\treturn ;\n}\n\tmap<P,bool>ta;\nint main(){\n\tcin>>n>>m;\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin>>t[i][j];\n\t\t\tse.push(mp(t[i][j],mp(i,j)));\n\t\t}\n\t}\n\n\twhile(!se.empty()){\n\t\t\tpair<int,P>T=se.top();\n\t\t\tse.pop();\n\t\t\tint ny=T.second.first,nx=T.second.second,value=T.first;\n\t\t\tif(memo[ny][nx]!=0)continue;\n\t\t\t\n\n\t\t\tdfs(ny,nx);\n\t\t\tsett.clear();\n\n\t/*\t\tcout<<value<<\" \"<<ny<<\" \"<<nx<<endl<<endl;\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcout<<memo[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n\t*/\n\n\n\t}\n\tint ans=0;\n\trep(i,n){\n\t\trep(j,m)if(memo[i][j]>=2)ans++;\n\t}\t\n\tcout<<ans<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint to[1010][1010],c[1010][1010],h,w;\n \nint Press(int y,int x){\n  return y*1010+x;\n}\n \nstruct P{\n  int cost,y,x;\n  bool operator<(const P&P1)const{\n    return cost<P1.cost;\n  };\n  bool operator>(const P&P1)const{\n    return cost>P1.cost;\n  };\n};\npriority_queue<P,vector<P>,greater<P> >Q;\nint main(){\n  cin>>h>>w;\n  lol(i,h)lol(j,w){\n    cin>>c[i][j];\n    P tmp;\n    tmp.cost=c[i][j];\n    tmp.y=i,tmp.x=j;\n    Q.push(tmp);\n    to[i][j]=-2;//?????????\n  }\n  while(!Q.empty()){\n    P tmp=Q.top();\n    Q.pop();\n    int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n    set<int> st;\n    bool ok=true;\n    lol(i,4){\n      int xx=tmp.x+dx[i],yy=tmp.y+dy[i];\n      if(xx<0||yy<0||xx==w||yy==h)continue;\n      if(to[yy][xx]==-1)ok=false;\n      if(to[yy][xx]>=0)st.insert(to[yy][xx]);\n    }\n    if(st.size()>=2)ok=false;\n    if(ok){\n      if(st.size()>=1)to[tmp.y][tmp.x]=*st.begin();\n      else to[tmp.y][tmp.x]=Press(tmp.y,tmp.x);\n    }\n    else to[tmp.y][tmp.x]=-1;\n  }\n  int ans=0;\n  lol(i,h)lol(j,w){\n    if(to[i][j]==-1)ans++;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint t[1000][1000];\nint cnt[1000][1000];\nbool vis[1000][1000];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nint h,w;\nvoid DFS(int x,int y){\n\tcnt[y][x]++;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+dx[i]>=0&&x+dx[i]<w&&y+dy[i]>=0&&y+dy[i]<h){\n\t\t\tif(vis[y+dy[i]][x+dx[i]]==false&&t[y+dy[i]][x+dx[i]]>t[y][x]){\n\t\t\t\tvis[y+dy[i]][x+dx[i]]=true;\n\t\t\t\tDFS(x+dx[i],y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main(){\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>t[i][j];\n\t\t\tcnt[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tbool ok=true;\n\t\t\tif(i>0)if(t[i][j]>t[i-1][j])ok=false;\n\t\t\tif(i<h-1)if(t[i][j]>t[i+1][j])ok=false;\n\t\t\tif(j>0)if(t[i][j]>t[i][j-1])ok=false;\n\t\t\tif(j<w-1)if(t[i][j]>t[i][j+1])ok=false;\n\t\t\tif(ok){\n\t\t\t\tfor(int f=0;f<h;f++){\n\t\t\t\t\tfor(int g=0;g<w;g++){\n\t\t\t\t\t\tvis[f][g]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDFS(j,i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(cnt[i][j]>1)ans++;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint x[1000000];\nint y[1000000];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nint b[1000][1000];\nint one[1000000];\nint to[1000000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint W, H;\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\th--;\n\t\t\tb[i][j] = h;\n\t\t\tx[h] = j;\n\t\t\ty[h] = i;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int h = 0; h < H * W; h++) {\n\t\tset<int> s;\n\t\tfor(int k = 0; k < 4; k++) {\n\t\t\tint nx = x[h] + dx[k];\n\t\t\tint ny = y[h] + dy[k];\n\t\t\tif(nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n\t\t\tint th = b[ny][nx];\n\t\t\tif(th < h) {\n\t\t\t\tif(one[th]) one[h] = 1;\n\t\t\t\telse s.insert(to[th]);\n\t\t\t}\n\t\t}\n\t\tif(s.size() == 0) {\n\t\t\tto[h] = h;\n\t\t}\n\t\telse if(s.size() == 1) {\n\t\t\tto[h] = *s.begin();\n\t\t}\n\t\telse {\n\t\t\tone[h] = 1;\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\nint H,W;\nvector<vector<int>> f;\n\nvector<vector<int>> dp;\nvector<vector<int>> ok;\n\nint main(){\n  cin >> H >> W;\n  f.resize(H,vector<int>(W));\n  dp.resize(H,vector<int>(W,-1));\n  ok.resize(H,vector<int>(W,0));\n\n  vector<int> X(H * W);\n  vector<int> Y(H * W);\n\n  rep(i,0,H - 1){\n    rep(j,0,W - 1){\n      cin >> f[i][j];\n      f[i][j]--;\n      X[f[i][j]] = i;\n      Y[f[i][j]] = j;\n    }\n  }\n  int dx[] = {1,-1,0,0};\n  int dy[] = {0,0,1,-1};\n\n  int res = 0;\n\n  rep(i,0,H * W - 1){\n    int x = X[i];\n    int y = Y[i];\n    set<int> st;\n    int flag = 0;\n    int sz = 0;\n    rep(j,0,3){\n      int nx = X[i] + dx[j];\n      int ny = Y[i] + dy[j];\n      if(0 <= nx && nx < H && 0 <= ny && ny < W){\n        if(f[nx][ny] <= i){\n          st.insert(dp[nx][ny]);\n          flag = flag | ok[nx][ny];\n          sz++;\n        }\n      }\n    }\n    if(sz == 0){dp[x][y] = i;continue;}\n    if(st.size() >= 2){\n      flag = 1;\n    }\n    ok[x][y] = flag;\n    dp[x][y] = *st.begin();\n    if(ok[x][y]) res++;\n  }\n\n  cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap<int,set<int> > m;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint h,w;\nbool ok[1111][1111];\nbool in(int y,int x){\n  return (0<=y&&y<h&&0<=x&&x<w);\n}\nint main(){ \n  cin>>h>>w;\n  int s[h][w];\n  priority_queue<PP> q;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>s[i][j];\n      q.push(PP(-s[i][j],P(i,j)));\n    }\n  }\n  int ans=0;\n  int ax[]={1,-1,0,0};\n  int ay[]={0,0,1,-1};\n  while(!q.empty()){\n    PP pp=q.top();q.pop();\n    P p=pp.second;\n    int t=-pp.first,y=p.first,x=p.second;\n    for(int k=0;k<4;k++){\n      if(!in(y+ay[k],x+ax[k])) continue;\n      int z=s[y+ay[k]][x+ax[k]];\n      if(z>t) continue;\n      if(m.find(z)!=m.end()){\n\tif(m[z].size()==1) m[t].insert(*m[z].begin()); \n\telse ok[y][x]=1;\n      }else m[t].insert(z);\n    }\n    if(m.find(t)!=m.end()) ok[y][x]|=m[t].size()>1;\n    if(ok[y][x]){\n      ans++;\n      m[t].clear();\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nlong long rui(int n) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\telse {\n\t\tlong long x = rui(n - 1);\n\t\treturn 2 * x;\n\t}\n}\nvector<vector<int> > nyu(int h, int w) {\n\tvector<vector<int> > a(h+2, vector<int>(w+2, h*w+1));\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> a[i+1][j+1];\n\t\t}\n\t}\n\treturn a;\n}\nint ra(int i, int j, int h, int w) {\n\tif (1 <= i and i <= h) {\n\t\tif (1 <= j and j <= w) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint idx(int ka, int x) {\n\tif (ka == 0 or ka==2) {\n\t\treturn x - 1;\n\t}\n\tif (ka == 1) {\n\t\treturn x + 2;\n\t}\n\treturn x;\n}\nint idy(int ka, int y) {\n\tif (ka == 2) {\n\t\treturn y + 1;\n\t}\n\tif (ka == 3) {\n\t\treturn y - 2;\n\t}\n\treturn y;\n}\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<vector<int> > a;\n\tint poi = 0;\n\tvector<int> nex(2*h*w);\n\tvector<int> ney(2*h*w);\n\ta = nyu(h, w);\n\tvector<vector<int> > ho(h + 2, vector<int>(w + 2, 0));\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tif (a[i - 1][j] > a[i][j] and a[i + 1][j] > a[i][j]) {\n\t\t\t\tif (a[i][j - 1] > a[i][j] and a[i][j + 1] > a[i][j]) {\n\t\t\t\t\tnex[poi] = i;\n\t\t\t\t\tney[poi] = j;\n\t\t\t\t\tpoi++;\n\t\t\t\t\tho[i][j] = i * w + j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ba = 0;\n\tint hu = -1;\n\twhile (hu != 0) {\n\t\thu = 0;\n\t\tint co = poi;\n\t\tfor (int so = ba; so < co;so++) {\n\t\t\tint i = nex[so];\n\t\t\tint j = ney[so];\n\t\t\tint x = i;\n\t\t\tint y = j;\n\t\t\tfor (int ka = 0; ka < 4; ka++) {\n\t\t\t\tx = idx(ka, x);\n\t\t\t\ty = idy(ka, y);\n\t\t\t\tif (a[x][y] > a[i][j] and ra(x, y, h, w) == 1) {\n\t\t\t\t\tif ( ho[x][y] != ho[i][j]) {\n                                      \thu++;\n\t\t\t\t\t      nex[poi] = x;\n\t\t\t\t\t      ney[poi] = y;\n\t\t\t\t\t      poi++;\n                                      if(ho[x][y]!=0 or ho[i][j]==h * w + w + 1)\n                                      {\n\t\t\t\t\t\tho[x][y] = h * w + w + 1;\n                                      }\n                                      else{\n                                      ho[x][y]=ho[i][j];\n                                      }\n                                 }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tba = co;\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tif (ho[i][j] == h*w+w+1) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int INF = 1000000000;\n\nint h, w;\nint m[1000][1000];\nint d[1000][1000]; // ok => INF - 1, one => number, zero => imposible, INF => not check yet\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint check(int y, int x) {\n  if (d[y][x] != INF) return d[y][x];\n  int temp = 0;\n  for (int k = 0; k < 4; k++) {\n    int ny = y + dy[k], nx = x + dx[k];\n    if (ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n    if (m[y][x] > m[ny][nx]) {\n      int t = check(ny, nx);\n      if (t == INF - 1) return d[y][x] = INF - 1;\n      if (t == 0) {\n        temp = m[ny][nx];\n        continue;\n      }\n      if (temp != 0 && temp != t) return d[y][x] = INF - 1;\n      temp = t;\n    }\n  }\n  return d[y][x] = temp;\n}\n\nint main() {\n  scanf(\"%d%d\", &h, &w);\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) scanf(\"%d\", &m[i][j]);\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) d[i][j] = INF;\n  int ans = 0;\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) if (check(i, j) == INF - 1) ans++;\n  printf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],m1[1001][1001],qw,a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  if(qw>=2)goto L;\n  if(m1[y][x]>0)return 0;\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    qw++;\n    return 1;\n  }\n  m1[y][x]++;\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    qw=0;\n    sum+=dfs(j,i);\n    L:if(wq){\nwq=0;\nsum++;\n    };\n    rep(z,a)rep(h,b)m1[z][h]=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nconst int dy[] = {0, 1, 0, -1};\nconst int dx[] = {1, 0, -1, 0};\n\nint main() {\n  int H, W; cin >> H >> W;\n  auto mat = vector<vector<int>>(H, vector<int>(W));\n  auto inv = vector<P>(H * W + 1);\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      int x; cin >> x;\n      mat[i][j] = x;\n      inv[x] = {i, j};\n    }\n  }\n\n  int ans = 0;\n  auto prv = vector<vector<int>>(H, vector<int>(W, -1));\n  for (int i = 1; i <= H * W; ++i) {\n    int y, x; tie(y, x) = inv[i];\n    for (int j = 0; j < 4; ++j) {\n      int ny = y + dy[j];\n      int nx = x + dx[j];\n      if (0 <= ny && ny < H && 0 <= nx && nx < W && mat[ny][nx] < mat[y][x]) {\n        if (prv[ny][nx] == 0) {\n          prv[y][x] = 0;\n        } else if (prv[y][x] == -1) {\n          prv[y][x] = prv[ny][nx];\n        } else {\n          prv[y][x] = (prv[y][x] == prv[ny][nx]) * prv[ny][nx];\n        }\n      }\n    }\n    if (prv[y][x] == 0) ++ans;\n    if (prv[y][x] == -1) prv[y][x] = mat[y][x];\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nint H, W;\nint dp[1000005]; //0 ?°????, 1??\\??? ???????????????\nint X[1000005], Y[1000005];\nint mas[1005][1005];\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint main()\n{\n    int ans = 0;\n    fill_n(*mas, 1005 * 1005, INF);\n    scanf(\"%d %d\", &H, &W);\n    for(int i = 1; i <= H; i++) {\n        for(int j = 1; j <= W; j++) {\n            scanf(\"%d\", &mas[i][j]);\n            Y[mas[i][j]] = i;\n            X[mas[i][j]] = j;\n        }\n    }\n\n    for(int i = 1; i <= H * W; i++) {\n        int c = -1;\n        for(int j = 0; j < 4; j++) {\n            int ny = Y[i] + dy[j], nx = X[i] + dx[j];\n            if(mas[ny][nx] < i && c != 0) {\n                if(c == -1) c = dp[mas[ny][nx]];\n                else if(c != dp[mas[ny][nx]]) c = 0;\n            }\n        }\n        if(c == -1) dp[i] = i;\n        else dp[i] = c;\n        ans += dp[i] == 0;\n    }\n\n    cout << ans << endl;\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<short int, short int> P;\n\nint H, W;\nvector<vector<int>> map;\nvector<set<P>> dp;\nvector<P> hightopos;\nint vx[4] = { 0,1,0,-1 }, vy[4] = { 1,0,-1,0 };\n\nint main() {\n\tcin >> H >> W;\n\tdp.resize(H * W + 1), hightopos.resize(H * W + 1);\n\tmap.resize(H);\n\tfor (int i = 0; i < map.size(); i++)map[i].resize(W);\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> map[i][j];\n\t\t\thightopos[map[i][j]] = P(i, j);\n\n\t\t}\n\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= H * W; i++) {\n\t\tP now = hightopos[i];\n\t\tint ct = 0;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (now.first + vx[j] < 0 || now.first + vx[j] >= H || now.second + vy[j] < 0 || now.second + vy[j] >= W) continue;\n\t\t\tif (map[now.first + vx[j]][now.second + vy[j]] < map[now.first][now.second]) {\n\t\t\t\tct++;\n\t\t\t\tfor (auto k = dp[map[now.first + vx[j]][now.second + vy[j]]].begin();\n\t\t\t\t\tk != dp[map[now.first + vx[j]][now.second + vy[j]]].end(); k++) {\n\t\t\t\t\tif (dp[i].find(*k) == dp[i].end())dp[i].insert(*k);\n\n\t\t\t\t}\n\n\t\t\t\tif (dp[i].size() >= 2)break;\n\n\t\t\t}\n\n\t\t}\n\t\tif (ct == 0) {\n\t\t\tdp[i].insert(now);\n\n\t\t}\n\t\tif (dp[i].size() > 1)ans++;\n\t\t//cout << i << \" \" << dp[i].size() << endl;\n\n\t}\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nint H, W;\nint memo[1005][1005];\nint mas[1005][1005];\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint dp(int y, int x)\n{\n    int c = -1;\n    if(memo[y][x] != -1) return (memo[y][x]);\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if(mas[ny][nx] < mas[y][x] && c != 0) {\n            int val = dp(ny, nx);\n            if(c == -1) c = val;\n            else if(c != val) c = 0;\n        }\n    }\n    if(c == -1) return (memo[y][x] = (y - 1) * 1000 + (x - 1) + 1);\n    else return (memo[y][x] = c);\n}\n\nint main()\n{\n    int ans = 0;\n    fill_n(*mas, 1005 * 1005, INF);\n    memset(memo, -1, sizeof(memo));\n    cin >> H >> W;\n    for(int i = 1; i <= H; i++) {\n        for(int j = 1; j <= W; j++) {\n            cin >> mas[i][j];\n        }\n    }\n    for(int i = 1; i <= H; i++) {\n        for(int j = 1; j <= W; j++) {\n            ans += dp(i, j) == 0;\n        }\n    }\n    cout << ans << endl;\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint h, w;\nlong long int place[1002][1002] = { 0 };\nint DFS(int,int,int,int,int);\nint ans = 0;\nint kans = 0;\n\nbool one[1002] = { false };\nusing namespace std;\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 0; i < h + 2; i++) {\n\t\tfor (int j = 0; j < w + 2; j++) {\n\t\t\tplace[i][j] = (h + 1)*(w + 1);\n\t\t} \n\t}\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> place[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tDFS(i, j, place[i][j],0,place[i][j]);\n\t\t\tkans = 0;\n\t\t\tfor (int k = 0; k <= h*w; k++) {\n\t\t\t\tone[k] = false;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nint DFS(int x, int y, int start,int nownum,int from) {\n\t\n\tif (place[x - 1][y] < start) {\n\t\tDFS(x - 1, y, place[x - 1][y],1,from);\n\t}\n\tif (place[x][y - 1] < start) {\n\t\tDFS(x, y - 1, place[x][y - 1],1,from);\n\t}\n\tif (place[x][y + 1] < start) {\n\t\tDFS(x, y + 1, place[x][y + 1],1,from);\n\t}\n\tif (place[x + 1][y] < start) {\n\t\tDFS(x + 1, y, place[x + 1][y],1,from);\n\t}\n\tif ((place[x - 1][y] >= start&&place[x][y - 1] >= start) && (place[x][y + 1] >= start&&place[x + 1][y] >= start)) {\n\t\t\n\t\tif (nownum == 1) {\n\t\t\tif (!one[place[x][y]]) {\n\t\t\t\tkans++;\n\t\t\t\tone[place[x][y]] = true;\n\t\t\t\t/*cout << \"start:\" << from << \" water+:\" << place[x][y] << endl;*/\n\t\t\t}\n\n\t\t}\n\t\treturn 0;\n\t}\n\tif (nownum == 0) {\n\t\tif (kans >= 2) {\n\t\t\tans++;\n\t\t}\n\t\t/*cout << \"water=>\" << kans << \" start:\" << start << endl;*/\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_height){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\theight = arg_height;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn height < arg.height;\n\t};\n\n\tint row,col,height;\n};\n\nstruct Shishimaru{\n\tvector<Info> info;\n};\n\nint H,W;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint memo[1000][1000],table[1000][1000];\nShishimaru shishimaru[1000][1000];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvector<Info> recursive(int row,int col,int depth){\n\n\tif(memo[row][col] != -1){\n\t\treturn shishimaru[row][col].info;\n\t}\n\n\tvector<Info> sum,catcher;\n\n\tint adj_row,adj_col;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = row + diff_row[i];\n\t\tadj_col = col + diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] > table[row][col])continue;\n\n\t\tcatcher = recursive(adj_row,adj_col,depth+1);\n\n\t\tfor(int k = 0; k < catcher.size(); k++){\n\t\t\tsum.push_back(catcher[k]);\n\t\t}\n\t\tcatcher.clear();\n\t}\n\n\tif(sum.size() == 0){\n\t\tmemo[row][col] = 0;\n\t\tif(depth > 0){\n\t\t\tshishimaru[row][col].info.push_back(Info(row,col));\n\t\t\tsum.push_back(Info(row,col));\n\t\t}\n\t\treturn sum;\n\t}\n\n\tsort(sum.begin(),sum.end());\n\n\tint pre_row = sum[0].row,pre_col = sum[0].col;\n\tshishimaru[row][col].info.push_back(sum[0]);\n\n\tfor(int i = 1; i < sum.size(); i++){\n\t\tif(sum[i].row != pre_row || sum[i].col != pre_col){\n\t\t\tshishimaru[row][col].info.push_back(sum[i]);\n\t\t}\n\t\tpre_row = sum[i].row;\n\t\tpre_col = sum[i].col;\n\t}\n\n\tmemo[row][col] = shishimaru[row][col].info.size();\n\n\treturn shishimaru[row][col].info;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tpriority_queue<Data> Q;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&table[row][col]);\n\t\t\tQ.push(Data(row,col,table[row][col]));\n\t\t\tmemo[row][col] = -1;\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\tif(memo[Q.top().row][Q.top().col] == -1){\n\t\t\trecursive(Q.top().row,Q.top().col,0);\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tint ans = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(memo[row][col] > 1){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Ridge\n#include <iostream>\n\nusing namespace std;\n\nstatic const int drow[4] = {1, 0, -1, 0};\nstatic const int dcol[4] = {0, 1, 0, -1};\nstatic const int NIL = -1;\nstatic const int RIDGE = -2;\n\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    int A[H][W], B[H][W];\n    int order[H * W];\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            cin >> A[i][j];\n            order[A[i][j] - 1] = i * W + j;\n            B[H][W] = i * W + j;\n        }\n    }\n\n    for(int k = 0; k < H * W; k++) {\n        int i = order[k] / W;\n        int j = order[k] % W;\n        int cnt = 0;\n        int result = NIL;\n        for(int l = 0; l < 4; l++) {\n            int si = i + drow[l];\n            int sj = j + dcol[l];\n            if(si >= 0 && sj >= 0 && si < H && sj < W) {\n                if(A[i][j] > A[si][sj]) {\n                    if(B[si][sj] == RIDGE) {\n                        result = RIDGE;\n                        break;\n                    } else if(result != NIL && result != B[si][sj]) {\n                        result = RIDGE;\n                        break;\n                    } else {\n                        result = B[si][sj];\n                    }\n                }\n            }\n        }\n        B[i][j] = (result == NIL ? i * W + j : result);\n    }\n\n    int cnt = 0;\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            if(B[i][j] == RIDGE) cnt++;\n        }\n    }\n\n    cout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],ma[1001][1001],qw,a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  if(qw>=2)goto L;\n  if(m1[y][x]>0)return 0;\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    qw++;\n    return 1;\n  }\n  m1[y][x]++;\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    qw=0;\n    sum+=dfs(j,i);\n    L:if(wq){\nwq=0;\nsum++;\n    };\n    rep(z,a)rep(h,b)m1[z][h]=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,x,y) for(int i = x;i < y;i++)\nusing namespace std;\nint DP[1001][1001];\nint x[1000001];\nint y[1000001];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint main(){\n  int H,W,h,ans=0;\n  cin >> H >> W;\n  FOR(i,1,H+1)FOR(j,1,W+1){\n    cin >> h;\n    x[h] = i;\n    y[h] = j;\n  }\n  FOR(i,1,H*W+1){\n    int X=x[i],Y=y[i];\n    set<int> s;\n    FOR(j,0,4)if(DP[X+dx[j]][Y+dy[j]])s.insert(DP[X+dx[j]][Y+dy[j]]);\n    if(s.count(-1))DP[X][Y]=-1;\n    else if(s.size()>1)DP[X][Y]=-1;\n    else if(s.size())DP[X][Y]=*s.begin();\n    else DP[X][Y]=i;\n  }\n  FOR(i,1,H+1)FOR(j,1,W+1)if(DP[i][j]==-1)ans++;\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<cstdlib>\n#include<list>\n#include<set>\n#include<numeric>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint field[1002][1002],h[1002][1002];\nint x[1000001], y[1000001];\nint dx[] = { 1,0,-1,0 }, dy[] = {0,1,0,-1};\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H + 2; i++) {\n\t\tfor (int j = 0; j < W + 2; j++) {\n\t\t\tfield[i][j] = 100000000;\n\t\t\th[i][j] = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) \n\t\t\tcin >> field[i+1][j+1];\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tx[field[i][j]] = i;\n\t\t\ty[field[i][j]] = j;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= H*W; i++) {\n\t\tint a = 0;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint ddx = dx[j] + x[i], ddy = dy[j] + y[i];\n\t\t\tif (field[ddx][ddy] < i) {\n\t\t\t\tif (a == 0) a = h[ddx][ddy];\n\t\t\t\telse if (a != h[ddx][ddy])a = -1;\n\t\t\t}\n\t\t}\n\t\tif (a == 0)h[x[i]][y[i]] = i;\n\t\telse h[x[i]][y[i]] = a;\n\t\tif (a == -1)ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define dmp make_pair\nconst int inf = 1e9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n\nint a[1002][1002], b[20004];\nvector<int> G[1002];\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nqueue<int> q;\nint main(){\n\tint h, w, ans = 0;\n\tscanf(\"%d%d\", &h, &w);\n\trrep(i,h)rrep(j,w)scanf(\"%d\", &a[i][j]);\n\trrep(y,h)rrep(x,w){\n\t\tint f = 0;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tif(a[y][x] < a[y+dy[i]][x+dx[i]]){\n\t\t\t\tG[a[y][x]].push_back(a[y+dy[i]][x+dx[i]]);\n\t\t\t\tf++;\n\t\t\t}\n\t\t\tif(a[y+dy[i]][x+dx[i]] == 0)f++;\n\t\t}\n\t\tif(f == 4)q.push(a[y][x]);\n\t}\n\t\n\twhile(!q.empty()){\n\t\tint p = q.front();q.pop();\n\t\tif(b[p] == 0)b[p] = p;\n\t\tfor(int i = 0;i < G[p].size();i++){\n\t\t\tint t = G[p][i];\n\t\t\tif(b[t] == 0){\n\t\t\t\tb[t] = b[p];\n\t\t\t\tq.push(t);\n\t\t\t}else if(b[t] != b[p] && b[t] != -1){\n\t\t\t\tb[t] = -1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\n#define UNDEF -1\n#define IS_RD -2\n#define INF 1073741824\n\nusing namespace std;\n\nint M[1001][1001],H,W;\nint dp[1001][1001];\nstack<int> callX;\nstack<int> callY;\n\nint getM(int x,int y)\n{\n\tif(x >= 0 && y >= 0 && x < W && y < H)\n\t{\n\t\treturn M[x][y];\n\t}\n\telse\n\t{\n\t\treturn INF;\n\t}\n}\n\nvoid calc(int _x,int _y)\n{\n\tint x,y;\n\tcallX.push(_x);\n\tcallY.push(_y);\n\twhile(!callX.empty())\n\t{\n\t\tendfn:\n\t\tx = callX.top();\n\t\ty = callY.top();\n\t\tif(dp[x][y] == UNDEF)\n\t\t{\n\t\t\tint a[4] = {INF,INF,INF,INF};\n\t\t\tif(getM(x+1,y) < getM(x,y))\n\t\t\t{\n\t\t\t\tif(dp[x+1][y] == UNDEF)\n\t\t\t\t{\n\t\t\t\t\tcallX.push(x+1);\n\t\t\t\t\tcallY.push(y);\n\t\t\t\t\tgoto endfn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[0] = dp[x+1][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getM(x-1,y) < getM(x,y))\n\t\t\t{\n\t\t\t\tif(dp[x-1][y] == UNDEF)\n\t\t\t\t{\n\t\t\t\t\tcallX.push(x-1);\n\t\t\t\t\tcallY.push(y);\n\t\t\t\t\tgoto endfn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[1] = dp[x-1][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getM(x,y+1) < getM(x,y))\n\t\t\t{\n\t\t\t\tif(dp[x][y+1] == UNDEF)\n\t\t\t\t{\n\t\t\t\t\tcallX.push(x);\n\t\t\t\t\tcallY.push(y+1);\n\t\t\t\t\tgoto endfn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[2] = dp[x][y+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getM(x,y-1) < getM(x,y))\n\t\t\t{\n\t\t\t\tif(dp[x][y-1] == UNDEF)\n\t\t\t\t{\n\t\t\t\t\tcallX.push(x);\n\t\t\t\t\tcallY.push(y-1);\n\t\t\t\t\tgoto endfn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[3] = dp[x][y-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a[0] == INF && a[1] == INF && a[2] == INF && a[3] == INF)\n\t\t\t{\n\t\t\t\tdp[x][y] = (x*1000)+y;\n\t\t\t\tgoto endok;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i = 0;i < 3;i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int ii = i+1;ii < 4;ii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i] != INF && a[ii] != INF && a[i] != a[ii])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[x][y] = IS_RD;\n\t\t\t\t\t\t\tgoto endok;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < 4;i++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i] != INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[x][y] = a[i];\n\t\t\t\t\t\tgoto endok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tendok:\n\t\tcallX.pop();\n\t\tcallY.pop();\n\t}\n}\n\nint main(void)\n{\n\tcin >> H >> W;\n\tfor(int i = 0;i < H;i++)\n\t{\n\t\tfor(int ii = 0;ii < W;ii++)\n\t\t{\n\t\t\tcin >> M[ii][i];\n\t\t}\n\t}\n\tfor(int x = 0;x < 1001;x++)\n\t{\n\t\tfor(int y = 0;y < 1001;y++)\n\t\t{\n\t\t\tdp[x][y] = UNDEF;\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int x = 0;x < W;x++)\n\t{\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tcalc(x,y);\n\t\t}\n\t}\n\tfor(int x = 0;x < W;x++)\n\t{\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tif(dp[x][y] == IS_RD)\n\t\t\t\tres++;\n\t\t}\n\t}\n\t\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1000][1000],m1[1000][1000],a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    return 1;\n  }\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    m1[i][j]=-1;\n    sum+=dfs(j,i);\n    rep(z,a)rep(g,b)m1[z][g]=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\npair< int, int > cal[1000000 + 10];\n#define h first\n#define w second\n\npair< int, bool > state[1000000 + 10];\n#define la first\n#define ri second\n\nint map[1000 + 5][1000 + 5];\n\n#define LIMT 1001000\n\nint main()\n{\n\tint lh, lw;\n\tint i, j;\n\n\tcin >> lh >> lw;\n\n\tfor (i = 0; i <= lw + 1; i++)\n\t{\n\t\tmap[0][i] = LIMT;\n\t\tmap[lh + 1][i] = LIMT;\n\t}\n\tfor (i = 1; i <= lh; i++)\n\t{\n\t\tmap[i][0] = LIMT;\n\t\tmap[i][lw + 1] = LIMT;\n\t}\n\n\tfor (i = 1; i <= lh; i++)\n\t{\n\t\tfor (j = 1; j <= lw; j++)\n\t\t{\n\t\t\tcin >> map[i][j];\n\n\t\t\tcal[map[i][j]].h = i;\n\t\t\tcal[map[i][j]].w = j;\n\t\t}\n\t}\n\n\n\tint cnt = 0;\n\n\tint mh[] = {1,0,-1,0};\n\tint mw[] = {0,1,0,-1};\n\tint nh, nw;\n\tbool flg1 = true;\n\tint tol;\n\tfor (i = 1; i <= lh*lw; i++)\n\t{\n\t\tnh = cal[i].h;\n\t\tnw = cal[i].w;\n\n\t\tflg1 = true;\n\n\t\tfor (j = 0; j < 4; j++)\n\t\t{\n\t\t\tif (map[nh][nw] > map[nh + mh[j]][nw + mw[j]])\n\t\t\t{\n\t\t\t\tif (state[map[nh + mh[j]][nw + mw[j]]].ri)\n\t\t\t\t{\n\t\t\t\t\tstate[map[nh][nw]].ri = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (flg1)\n\t\t\t\t{\n\t\t\t\t\ttol = state[map[nh + mh[j]][nw + mw[j]]].la;\n\t\t\t\t}\n\n\t\t\t\tflg1 = false;\n\n\t\t\t\tif (tol != state[map[nh + mh[j]][nw + mw[j]]].la)\n\t\t\t\t{\n\t\t\t\t\tstate[map[nh][nw]].ri = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (flg1)\n\t\t{\n\t\t\tstate[map[nh][nw]].la = map[nh][nw];\n\t\t}\n\n\t\telse if (j == 4)\n\t\t{\n\t\t\tstate[map[nh][nw]].la = tol;\n\t\t}\n\n\t\tif (state[map[nh][nw]].ri)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\n\t/*\n\tcout << \"\\n\\n\";\n\tfor (i = 1; i <= lh; i++)\n\t{\n\t\tfor (j = 1; j <= lw; j++)\n\t\t{\n\t\t\tcout << state[map[i][j]].ri;\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tcout << \"\\n\\n\";\n\t*/\n\n\n\tcout << cnt << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); ++i)\nusing namespace std;\nusing Pair = pair<int, int>;\n\n// → ↑ ← ↓\nconst int dy[4] = {0, 1, 0, -1};\nconst int dx[4] = {1, 0, -1, 0};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<int>> M(H, vector<int>(W));\n    vector<vector<int>> T(H, vector<int>(W));\n    map<int, Pair> mp;\n    rep(i, H) rep(j, W) {\n        cin >> M[i][j];\n        mp[M[i][j]] = make_pair(i, j);\n        T[i][j] = M[i][j];\n    }\n    rep(h, H * W) {\n        int y = mp[h + 1].first;\n        int x = mp[h + 1].second;\n        set<int> st;\n        rep(i, 4) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n            if(M[y][x] > M[ny][nx]) {\n                st.insert(T[ny][nx]);\n            }\n        }\n        if(st.size() == 1) T[y][x] = *st.begin();\n        else if(st.size() > 1) T[y][x] = 0;\n    }\n    int ans = 0;\n    rep(i, H) rep(j, W) {\n        if(T[i][j] == 0) ans++;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint hyoukou[1002][1002];\nint x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nint main() {\n\t\tunordered_map<int, unordered_set<int>>U;\n\t\tmemset(hyoukou, 1, sizeof(hyoukou));\n\t\tpriority_queue<P, vector<P>, greater<P>>Q;\n\t\tint c, d;\n\t\tcin >> c >> d;\n\t\tfor (int e = 0; e < c; e++) {\n\t\t\tfor (int f = 0; f < d; f++) {\n\t\t\t\tint g;\n\t\t\t\tscanf(\"%d\", &g);\n\t\t\t\tg--;\n\t\t\t\thyoukou[e + 1][f + 1] = g;\n\t\t\t\tQ.push(P(g, p(e + 1, f + 1)));\n\t\t\t}\n\t\t}\n\t\twhile (Q.size()) {\n\t\t\tP h = Q.top(); Q.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (h.first> hyoukou[h.second.first + x[i]][h.second.second + y[i]]) {\n\t\t\t\t\tfor (auto k = U[hyoukou[h.second.first + x[i]][h.second.second + y[i]]].begin(); k != U[hyoukou[h.second.first + x[i]][h.second.second + y[i]]].end(); k++) {\n\t\t\t\t\t\tU[h.first].insert(*k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U[h.first].size() == 0)U[h.first].insert(h.first);\n\t\t}\n\t\tint S = 0;\n\t\tfor (int i = 1; i <= c; i++) {\n\t\t\tfor (int h = 1; h <= d; h++) {\n\t\t\t\tif (U[hyoukou[i][h]].size() != 1)S++;\n\t\t\t}\n\t\t}   \n\t\tcout << S << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint X,Y,i,i2,i3,i4,map[1000][1000],b[1000][1000],cnt,ans=0,dx[4]={1,-1,0,0},dy[4]={0,0,1,-1},c,ansx,ansy;\nint func(int x,int y){\n\tint tf=0;\n\tfor(int I=0;I<4;I++){\n\t\tint xx=x+dx[I];\n\t\tint yy=y+dy[I];\n\t\tif(xx>=0&&yy>=0&&xx<X&&yy<Y&&map[x][y]>map[xx][yy]&&b[xx][yy]==0){\n\t\t\ttf=1;\n\t\t\tb[xx][yy]=1;\n\t\t\t/*\n\t\t\tfor(int ww=0;ww<Y;ww++){\n\t\t\t\tfor(int www=0;www<X;www++)cout<<b[www][ww]<<' ';\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\t*/\n\t\t\tfunc(xx,yy);\n\t\t}\n\t}\n\tif(tf==0&&!(x==ansx&&y==ansy)){\n\t\tcnt++;\n\t\tansx=x;\n\t\tansy=y;\n\t}\n\tb[x][y]=0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>Y>>X;\n\tfor(i=0;i<Y;i++){\n\t\tfor(i2=0;i2<X;i2++){\n\t\t\tcin>>map[i2][i];\n\t\t}\n\t}\n\tfor(i=0;i<Y;i++){\n\t\tfor(i2=0;i2<X;i2++){\n\t\t\tfor(i3=0;i3<1000;i3++)for(i4=0;i4<1000;i4++)b[i3][i4]=0;\n\t\t\tansx=-1;\n\t\t\tansy=-1;\n\t\t\tcnt=0;\n\t\t\tc=0;\n\t\t\tb[i2][i]=1;\n\t\t\tfunc(i2,i);\n\t\t\tif(cnt>=2){\n\t\t\t\tans++;\n\t\t\t\t//cout<<i2<<' '<<i<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],m1[1020][1020],a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    return 1;\n  }\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    m1[i][j]=-1;\n    sum+=dfs(j,i);\n    rep(z,a)rep(g,b)m1[z][g]=0;\n  }\n  cout<<sum<<endl;\n  exit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint inf = 1000001;\nclass mt {\npublic:\n\tint num,high;\n\tpair<int, int> use;\n\tmt() :num(0), use(pair<int, int>(-1, -1)), high(inf) {\n\n\t}\n};\nint main() {\n\tint H, W;\n\tmt **map;\n\tcin >> H >> W;\n\tmap = new mt*[W + 2];\n\tfor (int i = 0; i < W + 2; ++i) {\n\t\tmap[i] = new mt[H + 2];\n\t}\n\tint dummy;\n\tfor (int y = 1; y <= H; ++y) {\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tcin >> dummy;\n\t\t\tmap[x][y].high = dummy;\n\t\t}\n\t}\n\tint movex[]{ 1,0,-1,0 }, movey[]{ 0,1,0,-1 };\n\tfor (int y = 1; y <= H; ++y) {\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (map[x + movex[i]][y + movey[i]].high > map[x][y].high) {\n\t\t\t\t\t++num;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num == 4) {\n\t\t\t\tpair<int, int> point = pair<int, int>(x, y);\n\t\t\t\tqueue<pair<int, int> > que;\n\t\t\t\tque.push(pair<int, int>(x, y));\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\tpair<int, int>  stock = que.front(); que.pop();\n\t\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\t\tif (map[stock.first + movex[i]][stock.second + movey[i]].high != inf&&map[stock.first + movex[i]][stock.second + movey[i]].high > map[stock.first][stock.second].high&&map[stock.first + movex[i]][stock.second + movey[i]].use != point&&++map[stock.first + movex[i]][stock.second + movey[i]].num < 3) {\n\t\t\t\t\t\t\tque.push(pair<int, int>(stock.first + movex[i], stock.second + movey[i]));\n\t\t\t\t\t\t\tmap[stock.first + movex[i]][stock.second + movey[i]].use = point;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tfor (int y = 1; y <= H; ++y) {\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tif (map[x][y].num >= 2) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t\tcout << map[x][y].num << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint f[1000][1000], dat[1000][100];\nint x[1000001], y[1000001];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint h, w; scanf(\"%d%d\", &h, &w);\n\trep(i, h)rep(j, w) {\n\t\tscanf(\"%d\", &f[i][j]);\n\t\tx[f[i][j]] = i; y[f[i][j]] = j;\n\t}\n\trep(i, h)rep(j, w) {\n\t\tbool ok = true;\n\t\trep(k, 4) {\n\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&f[nx][ny] < f[i][j])ok = false;\n\t\t}\n\t\tif (ok)dat[i][j] = f[i][j];\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= h*w; i++) {\n\t\trep(j, 4) {\n\t\t\tint nx = x[i] + dx[j], ny = y[i] + dy[j];\n\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&f[x[i]][y[i]] > f[nx][ny]) {\n\t\t\t\tif (dat[x[i]][y[i]] == 0)dat[x[i]][y[i]] = dat[nx][ny];\n\t\t\t\telse if (dat[x[i]][y[i]] != dat[nx][ny])dat[x[i]][y[i]] = -1;\n\t\t\t}\n\t\t}\n\t\tif (dat[x[i]][y[i]] == -1)ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\nusing pii = pair<int, int>;\n\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\nint H, W;\nint h[1000][1000];\nbool visited[1000][1000];\nset<pii> v[1000][1000];\n\nvoid dfs(pii p) {\n    const int y = p.first;\n    const int x = p.second;\n    visited[y][x] = true;\n    for(int i = 0; i < 4; ++i) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if(ny < 0 || H <= ny || nx < 0 || W <= nx) {\n            continue;\n        }\n        if(h[ny][nx] >= h[y][x]) {\n            continue;\n        }\n        if(!visited[ny][nx]) {\n            dfs(make_pair(ny, nx));\n        }\n        for(auto& pp : v[ny][nx]) {\n            if(v[y][x].size() < 2) {\n                v[y][x].insert(pp);\n            }\n        }\n    }\n    if(v[y][x].empty()) {\n        v[y][x].insert(p);\n    }\n}\n\nint main() {\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n    cin >> H >> W;\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            cin >> h[i][j];\n        }\n    }\n\n    int res = 0;\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            if(!visited[i][j]) {\n                dfs(make_pair(i, j));\n            }\n            res += v[i][j].size() >= 2;\n        }\n    }\n\tEND_STACK_EXTEND;\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\nint mp[1000][1000];\nPA ku[1000001];\nint main(){\n  int h,w,ans=0;\n  int one[1000001]={};\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mp[i][j];\n      ku[ mp[i][j] ] = PA(i,j);\n    }\n  }\n  int x,y,dy[4] = {1,-1,0,0};\n  int dx[4] = {0,0,1,-1};\n  for(int i=1;i<=h*w;i++){\n    for(int j=0;j<4;j++){\n      y = ku[i].first + dy[j];\n      x = ku[i].second + dx[j];\n      if(x<0||y<0||x>=w||y>=h||mp[ku[i].first][ku[i].second]>mp[y][x]) continue;\n      if(one[ mp[y][x] ] == 0){\n\tif(one[ mp[ku[i].first][ku[i].second]] == 0) one[ mp[y][x]] = i;\n\telse one[ mp[y][x] ] = one[mp[ku[i].first][ku[i].second]];\n      }\n      else if(one[mp[ ku[i].first][ ku[i].second]] == -1){\n\tif(one[ mp[y][x]] != -1) ans++;\n\tone[ mp[y][x] ] = -1;\n      }else if(one[ mp[y][x]] != one[ mp[ku[i].first][ku[i].second]]){\n\tif(one[ mp[y][x]] != -1) ans++;\n\tone[ mp[y][x]] = -1;\n      }\n    }\n  }\n  cout << ans << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nint H, W;\nint dp[1000005]; //0 ?°????, 1??\\??? ???????????????\nint X[1000005], Y[1000005];\nint mas[1005][1005];\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint main()\n{\n    int ans = 0;\n    fill_n(*mas, 1005 * 1005, INF);\n    cin >> H >> W;\n    for(int i = 1; i <= H; i++) {\n        for(int j = 1; j <= W; j++) {\n            cin >> mas[i][j];\n            Y[mas[i][j]] = i;\n            X[mas[i][j]] = j;\n        }\n    }\n\n    for(int i = 1; i <= H * W; i++) {\n        int c = -1;\n        for(int j = 0; j < 4; j++) {\n            int ny = Y[i] + dy[j], nx = X[i] + dx[j];\n            if(mas[ny][nx] < i && c != 0) {\n                if(c == -1) c = dp[mas[ny][nx]];\n                else if(c != dp[mas[ny][nx]]) c = 0;\n            }\n        }\n        if(c == -1) dp[i] = i;\n        else dp[i] = c;\n        ans += dp[i] == 0;\n    }\n\n    cout << ans << endl;\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n// 他人の提出を参考に\n#define inRange(x,a,b) (a <= x && x < b)\nint di[8] = {0,0,1,-1,1,1,-1,-1};\nint dj[8] = {1,-1,0,0,1,-1,1,-1};\n\nint a[1000][1000], x[1000001], y[1000001];\nint f[1000][1000] = {};\n\nint main(){\n    int h, w;\n    cin >> h >> w;\n    int a[h][w];\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cin >> a[i][j];\n            x[a[i][j]] = i;\n            y[a[i][j]] = j;\n        }\n    }\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            bool ok = true;\n            for(int k = 0; k < 4; k++){\n                int ni = i+di[k], nj = j+dj[k];\n                if(inRange(ni,0,h)&&inRange(nj,0,w)&&a[ni][nj]<a[i][j]) ok = false;\n            }\n            if(ok)  f[i][j] = a[i][j];\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= h*w; i++){\n        for(int k = 0; k < 4; k++){\n            int ni = x[i]+di[k], nj = y[i]+dj[k];\n            if(inRange(ni,0,h)&&inRange(nj,0,w)&&a[ni][nj]<a[x[i]][y[i]]){\n                if(f[x[i]][y[i]] == 0)  f[x[i]][y[i]] = f[ni][nj];      // 新しく逆フローを流す\n                else if(f[x[i]][y[i]] != f[ni][nj]) f[x[i]][y[i]] = -1; // 既に別の場所から逆フローが流れてきている...!\n            }\n        }\n        if(f[x[i]][y[i]] == -1) ans++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define UNDEF -1\n#define IS_RD -2\n#define INF 1073741824\n\nusing namespace std;\n\nint M[1000][1000],H,W;\nint dp[1000][1000];\n\nint getM(int x,int y)\n{\n\tif(x >= 0 && y >= 0 && x < W && y < H)\n\t{\n\t\treturn M[x][y];\n\t}\n\telse\n\t{\n\t\treturn INF;\n\t}\n}\n\nint dfs(int x,int y)\n{\n\tif(dp[x][y] == UNDEF)\n\t{\n\t\tint a[4] = {INF,INF,INF,INF};\n\t\tif(getM(x+1,y) < getM(x,y))\n\t\t{\n\t\t\ta[0] = dfs(x+1,y);\n\t\t}\n\t\tif(getM(x-1,y) < getM(x,y))\n\t\t{\n\t\t\ta[1] = dfs(x-1,y);\n\t\t}\n\t\tif(getM(x,y+1) < getM(x,y))\n\t\t{\n\t\t\ta[2] = dfs(x,y+1);\n\t\t}\n\t\tif(getM(x,y-1) < getM(x,y))\n\t\t{\n\t\t\ta[3] = dfs(x,y-1);\n\t\t}\n\t\tif(a[0] == INF && a[1] == INF && a[2] == INF && a[3] == INF)\n\t\t{\n\t\t\tdp[x][y] = (x*1000)+y;\n\t\t\tgoto endloop;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0;i < 4;i++)\n\t\t\t{\n\t\t\t\tfor(int ii = i+1;ii < 4;ii++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i] != INF && a[ii] != INF && a[i] != a[ii])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[x][y] = IS_RD;\n\t\t\t\t\t\tgoto endloop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < 4;i++)\n\t\t\t{\n\t\t\t\tif(a[i] != INF)\n\t\t\t\t{\n\t\t\t\t\tdp[x][y] = a[i];\n\t\t\t\t\tgoto endloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tendloop:\n\treturn dp[x][y];\n}\n\nint main(void)\n{\n\tcin >> H >> W;\n\tfor(int i = 0;i < H;i++)\n\t{\n\t\tfor(int ii = 0;ii < W;ii++)\n\t\t{\n\t\t\tcin >> M[ii][i];\n\t\t}\n\t}\n\tfor(int x = 0;x < 1000;x++)\n\t{\n\t\tfor(int y = 0;y < 1000;y++)\n\t\t{\n\t\t\tdp[x][y] = UNDEF;\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int x = 0;x < W;x++)\n\t{\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tif(dfs(x,y) == IS_RD)\n\t\t\t\tres++;\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<limits.h>\n\n\n#include<iostream>\nusing namespace std;\n\npair< int, int > cal[1000000 + 10];\n#define h first\n#define w second\n\npair< int, bool > state[1000000 + 10];\n#define la first\n#define ri second\n\nint map[1000 + 5][1000 + 5];\n\n#define LIMT 1001000\n\nint main()\n{\n\tint lh, lw;\n\tint i, j;\n\n\tcin >> lh >> lw;\n\n\tfor (i = 0; i <= lw + 1; i++)\n\t{\n\t\tmap[0][i] = LIMT;\n\t\tmap[lh + 1][i] = LIMT;\n\t}\n\tfor (i = 1; i <= lh; i++)\n\t{\n\t\tmap[i][0] = LIMT;\n\t\tmap[i][lw + 1] = LIMT;\n\t}\n\n\tfor (i = 1; i <= lh; i++)\n\t{\n\t\tfor (j = 1; j <= lw; j++)\n\t\t{\n\t\t\tcin >> map[i][j];\n\n\t\t\tcal[map[i][j]].h = i;\n\t\t\tcal[map[i][j]].w = j;\n\t\t}\n\t}\n\n\n\tint cnt = 0;\n\n\tint mh[] = {1,0,-1,0};\n\tint mw[] = {0,1,0,-1};\n\tint nh, nw;\n\tbool flg1 = true;\n\tint tol;\n\tfor (i = 1; i <= lh*lw; i++)\n\t{\n\t\tnh = cal[i].h;\n\t\tnw = cal[i].w;\n\n\t\tflg1 = true;\n\n\t\tfor (j = 0; j < 4; j++)\n\t\t{\n\t\t\tif (map[nh][nw] > map[nh + mh[j]][nw + mw[j]])\n\t\t\t{\n\t\t\t\tif (state[map[nh + mh[j]][nw + mw[j]]].ri)\n\t\t\t\t{\n\t\t\t\t\tstate[map[nh][nw]].ri = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (flg1)\n\t\t\t\t{\n\t\t\t\t\ttol = state[map[nh + mh[j]][nw + mw[j]]].la;\n\t\t\t\t}\n\n\t\t\t\tflg1 = false;\n\n\t\t\t\tif (tol != state[map[nh + mh[j]][nw + mw[j]]].la)\n\t\t\t\t{\n\t\t\t\t\tstate[map[nh][nw]].ri = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (flg1)\n\t\t{\n\t\t\tstate[map[nh][nw]].la = map[nh][nw];\n\t\t}\n\n\t\telse if (j == 4)\n\t\t{\n\t\t\tstate[map[nh][nw]].la = tol;\n\t\t}\n\n\t\tif (state[map[nh][nw]].ri)\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\n\t/*\n\tcout << \"\\n\\n\";\n\tfor (i = 1; i <= lh; i++)\n\t{\n\t\tfor (j = 1; j <= lw; j++)\n\t\t{\n\t\t\tcout << state[map[i][j]].ri;\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tcout << \"\\n\\n\";\n\t*/\n\n\n\tcout << cnt << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nconst int dx[4] = { -1, 0, 0, 1 }, dy[4] = { 0, -1, 1, 0 };\nint H, W, M[1234][1234];\nvector<vector<int>> water;\nvector<set<int>> water_to;\nvector<bool> isOne;\n\nint index(int w, int h) {\n\tif (w < 0 || h < 0 || w >= W || h >= H) return -1;\n\treturn h * W + w;\n}\n\nvoid GetWaterTo(int i) {\n\tif (water_to[i].size() > 0) return;\n\tif (water[i].size() == 0) water_to[i].insert(i);\n\trep(j, water[i].size()) {\n\t\tGetWaterTo(water[i][j]);\n\t\tif (isOne[water[i][j]] || water_to[water[i][j]].size() >= 2) {\n\t\t\tisOne[i] = true;\n\t\t\tbreak;\n\t\t}\n\t\twater_to[i].insert(water_to[water[i][j]].begin(), water_to[water[i][j]].end());\n\t}\n\treturn;\n}\n\nint main() {\n\n\tscanf(\"%d %d\", &H, &W);\n\n\twater.resize(H*W);\n\twater_to.resize(H*W);\n\tisOne.resize(H*W, false);\n\n\tvector<pair<int, int>> order;\n\n\tint IndexCount = 0;\n\trep(i, H) rep(j, W) {\n\t\tscanf(\"%d\", &M[i][j]);\n\t\torder.push_back(make_pair(M[i][j], IndexCount));\n\t\tIndexCount++;\n\t}\n\n\trep(i, H) rep(j, W) {\n\t\trep(d, 4) {\n\t\t\tif (index(j + dx[d], i + dy[d]) != -1 && M[i][j] > M[i + dy[d]][j + dx[d]]) {\n\t\t\t\twater[index(j, i)].push_back(index(j + dx[d], i + dy[d]));\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(order.begin(), order.end());\n\n\trep(i, order.size()) GetWaterTo(order[i].second);\n\t//rep(i, H*W) GetWaterTo(i);\n\n\tint c = 0;\n\trep(i, H*W) if (isOne[i] || water_to[i].size() >= 2) c++;\n\n\tprintf(\"%d\\n\", c);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint H, W;\nbool isin(const PII& p){\n  return 0 <= p.FF && p.FF < W && 0 <= p.SS && p.SS < H;\n}\nbool isin(int x, int y){\n  return isin(MP(x,y));\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W;\n  VVI xs(H, VI(W));\n  REP(y,H) REP(x,W) cin >> xs[y][x];\n\n  vector<PII> out;\n  REP(y,H) REP(x,W){\n\tbool ok = true;\n\tREP(d,4){\n\t  int tx = x + dx[d];\n\t  int ty = y + dy[d];\n\t  if(isin(tx,ty) && xs[y][x] > xs[ty][tx])\n\t\tok = false;\n\t}\n\tif(ok) out.EB(x,y);\n  }\n\n  VVI st(H, VI(W));\n  for(auto&& s: out){\n\tvector<vector<bool>> vis(H, vector<bool>(W));\n\tqueue<PII> q;\n\tq.push(s);\n\tvis[s.SS][s.FF] = true;\n\twhile(!q.empty()){\n\t  PII p = q.front();\n\t  q.pop();\n\t  REP(d,4){\n\t\tPII np(p.FF+dx[d], p.SS+dy[d]);\n\t\tif(isin(np) && !vis[np.SS][np.FF] && st[np.SS][np.FF] < 2 && xs[np.SS][np.FF] > xs[p.SS][p.FF]){\n\t\t  q.push(np);\n\t\t  st[np.SS][np.FF]++;\n\t\t  vis[np.SS][np.FF] = true;\n\t\t}\n\t  }\n\t}\n  }\n\n  int ans = 0;\n  REP(y,H) REP(x,W)\n\tif(st[y][x] >= 2){\n\t  ++ans;\n\t}\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nclass HashP {\npublic :\n    size_t operator()(const P& source) const {\n        return source.first*1000+source.second;\n    }\n};\n\nint main() {\n    int H,W;\n    cin >> H >> W;\n\n    vector<int> mp[H];\n    vector<P> pool;\n\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            int temp;\n            cin >> temp;\n            mp[i].push_back(temp);\n        }\n    }\n\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            if((i==0 || mp[i][j]<mp[i-1][j]) && (i==H-1 || mp[i][j]<mp[i+1][j])\n                && (j==0 || mp[i][j]<mp[i][j-1]) && (j==W-1 || mp[i][j]<mp[i][j+1])) pool.push_back(P(i,j));\n        }\n    }\n\n    queue<P> q;\n    unordered_map<P,int,HashP> check,m;\n    int dh[4]={-1,0,1,0};\n    int dw[4]={0,1,0,-1};\n    int ans=0;\n\n    for(auto x : pool) {\n        q.push(x);\n        m.clear();\n        while(!q.empty()) {\n            P p=q.front(); q.pop();\n            int h=p.first;\n            int w=p.second;\n\n            if(m[p]!=0) continue;\n            m[p]=1; ++check[p];\n            if(check[p]==2) ++ans;\n\n            for(int i=0; i<4; ++i) {\n                if(h+dh[i]>=0 && h+dh[i]<H && w+dw[i]>=0 && w+dw[i]<W \n                    && mp[h][w]<mp[h+dh[i]][w+dw[i]]) q.push(P(h+dh[i],w+dw[i]));\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\n\nint H, W;\nint d[1010][1010];\nauto isOutOfRange = [](int h, int w, int H, int W) {\n\treturn h < 0 || h >= H || w < 0 || w >= W;\n};\n\nvi memo; //-1:non-used, -2:ok, else:ikisaki \n\nvector<int> es[1010*1010];\n\nint dfs(int now) {\n\tif(memo[now] != -1) return memo[now];\n\tint ret = -1;\n\tfor(auto& to : es[now]) {\n\t\tint tmp = dfs(to);\n\t\tif(ret == -1) ret = tmp;\n\t\telse if(ret != tmp) ret = -2;\n\t}\n\treturn memo[now] = (ret == -1 ? now : ret);\n}\n\nint main(){\n\tcin >> H >> W;\n\trep(i, H) rep(j, W) cin >> d[i][j];\n\n\tmemo.clear();\n\tmemo.resize(H*W, -1);\n\t\n\trep(y, H) rep(x, W) {\n\t\tint now = y * W + x;\n\t\trep(i, 4) {\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(isOutOfRange(ny, nx, H, W)) continue;\n\t\t\tint nxt = ny * W + nx;\n\t\t\tif(d[y][x] > d[ny][nx]) es[now].pb(nxt);\n\t\t}\n\t}\n\t\n\trep(i, H) rep(j, W) dfs(i*W+j);\n\t\n\tint ans = 0;\n\trep(i, memo.size()) if(memo[i] == -2) ans++;\n\n\tcout << ans << endl;\n\t#ifdef DEBUG_MODE\n\t//DEBUG_2D\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) printf(\"%3d\",memo[i*W+j]);\n\t\tprintf(\"\\n\");\n\t}\n\t#endif\n\tdump(es[3].size());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, sum, last, cnt, ans, a[1000][1000] = {}, dp[1000][1000] = {};\nint dd[4][2] = { {1,0},{0,1},{ -1,0 },{ 0,-1 } };\nstring str,ss;\nstruct Edge { LL to; };\nvector<Pll>vec[1000][1000];\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nLL dfs(LL x,LL y) {\n\tLL ss = -10;\n\tbool f = 0;\n\tif (dp[x][y] != -1)return dp[x][y];\n\trep(i, vec[x][y].size()) {\n\t\tLL now = dfs(vec[x][y][i].fir, vec[x][y][i].sec);\n\t\tif (ss!=-10&&ss != now)f = 1;\n\t\t\tss = now;\n\t}\n\tif (vec[x][y].size() == 0)return dp[x][y] = x + y * 10000;\n\tif (!f)return dp[x][y] = ss;\n\treturn dp[x][y] = -100;\n}\nint main() {\n\tcin >> h >> w;\n\trep(i, h)rep(j, w) {\n\t\tcin >> a[i][j];\n\t}\n\trep(i, h)rep(j, w) {\n\t\trep(k, 4) {\n\t\t\tint X = i + dd[k][0], Y = j + dd[k][1];\n\t\t\tif (X >= 0 && Y >= 0 && X < h&&Y<w&&a[i][j]>a[X][Y])\n\t\t\t\tvec[i][j].push_back(Pll(X, Y));\n\t\t}\n\t}\n\trep(i, h)rep(j, w)dp[i][j] = -1;\n\trep(i, h)rep(j, w) {\n\t\tans += dfs(i, j) == -100 ? 1 : 0;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nconst int dy[] = {-1, 0, 0, 1};\nconst int dx[] = {0, -1, 1, 0};\nint H, W;\nint M[1010][1010];\nusing P = pair<int, int>;\nP memo[1010][1010];\n\nP rec(int y, int x) {\n    if (~memo[y][x].second) return memo[y][x];\n    P res(H * W, -1);\n    REP(i, 4) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (ny >= 0 && ny < H && nx >= 0 && nx < W && M[ny][nx] < M[y][x]) {\n            P p = rec(ny, nx);\n            res.first = min(res.first, p.first);\n            res.second = max(res.second, p.second);\n        }\n    }\n    if (!~res.second) res.first = res.second = H * y + x;\n    return memo[y][x] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> H >> W;\n    REP(i, H) REP(j, W) {\n        cin >> M[i][j];\n        memo[i][j] = P(H * W, -1);\n    }\n    int ans = 0;\n    REP(i, H) REP(j, W) {\n        P p = rec(i, j);\n        ans += (p.first != p.second);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint H, W;\nbool isin(const PII& p){\n  return 0 <= p.FF && p.FF < W && 0 <= p.SS && p.SS < H;\n}\nbool isin(int x, int y){\n  return isin(MP(x,y));\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W;\n  VVI xs(H, VI(W));\n  REP(y,H) REP(x,W) cin >> xs[y][x];\n\n  vector<PII> out;\n  REP(y,H) REP(x,W){\n\tbool ok = true;\n\tREP(d,4){\n\t  int tx = x + dx[d];\n\t  int ty = y + dy[d];\n\t  if(isin(tx,ty) && xs[y][x] > xs[ty][tx])\n\t\tok = false;\n\t}\n\tif(ok) out.EB(x,y);\n  }\n\n  VVI st(H, VI(W));\n  for(auto&& s: out){\n\tvector<vector<bool>> vis(H, vector<bool>(W));\n\tqueue<PII> q;\n\tq.push(s);\n\tvis[s.SS][s.FF] = true;\n\twhile(!q.empty()){\n\t  PII p = q.front();\n\t  q.pop();\n\t  REP(d,4){\n\t\tPII np(p.FF+dx[d], p.SS+dy[d]);\n\t\tif(isin(np) && !vis[np.SS][np.FF] && st[np.SS][np.FF] < 2 && xs[np.SS][np.FF] > xs[p.SS][p.FF]){\n\t\t  q.push(np);\n\t\t  st[np.SS][np.FF]++;\n\t\t  vis[np.SS][p.FF] = true;\n\t\t}\n\t  }\n\t}\n  }\n\n  int ans = 0;\n  REP(y,H) REP(x,W)\n\tif(st[y][x] >= 2)\n\t  ++ans;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nstruct H {\n\tint x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\nint ari(int a, int b, int c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\n//---------------------------------------------------\n//+++++++++++++++++++++++++++++++++++++++++++++++++++\nset<int>c[1000][1000];\nint h, w, a[1000][1000];\nH b[100001];\nvoid solve(int i, int j, int x, int y) {\n\tset<int>::iterator it = c[x][y].begin();\n\twhile (it != c[x][y].end()) {\n\t\tc[i][j].insert((*it));\n\t\tit++;\n\t}\n}\nsigned main() {\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\tb[a[i][j]] = H{ i,j };\n\t\t}\n\t}\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (i != 0 && a[i - 1][j] < a[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (i < h - 1 && a[i + 1][j] < a[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (j != 0 && a[i][j - 1] < a[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (j < w - 1 && a[i][j + 1] < a[i][j])\n\t\t\t\tcontinue;\n\t\t\tc[i][j].insert(a[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= h*w; i++) {\n\t\tint x = b[i].x, y = b[i].y;\n\t\tif (x > 0 && a[x - 1][y] > a[x][y])\n\t\t\tsolve(x - 1, y, x, y);\n\t\tif (x<h - 1 && a[x + 1][y]>a[x][y])\n\t\t\tsolve(x + 1, y, x, y);\n\t\tif (y > 0 && a[x][y - 1] > a[x][y])\n\t\t\tsolve(x, y - 1, x, y);\n\t\tif (y<w - 1 && a[x][y + 1]>a[x][y])\n\t\t\tsolve(x, y + 1, x, y);\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (c[i][j].size() >= 2)\n\t\t\t\tsum++;\n\t\t}\n\t}\n\tcout << sum << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nint H, W;\nint memo[1005][1005];\nint mas[1005][1005];\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint dp(int y, int x)\n{\n    int c = -1;\n    if(memo[y][x] != -1) return (memo[y][x]);\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if(mas[ny][nx] < mas[y][x] && c != 0) {\n            int val = dp(ny, nx);\n            if(c == -1) c = val;\n            else if(c != val) c = 0;\n        }\n    }\n    if(c == -1) return (memo[y][x] = y * 1000 + x);\n    else return (memo[y][x] = c);\n}\n\nint main()\n{\n    int ans = 0;\n    fill_n(*mas, 1005 * 1005, INF);\n    memset(memo, -1, sizeof(memo));\n    cin >> H >> W;\n    for(int i = 1; i <= H; i++) {\n        for(int j = 1; j <= W; j++) {\n            cin >> mas[i][j];\n        }\n    }\n    for(int i = 1; i <= H; i++) {\n        for(int j = 1; j <= W; j++) {\n            ans += dp(i, j) == 0;\n        }\n    }\n    cout << ans << endl;\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint dx[]={-1,0,0,1},dy[]={0,-1,1,0};\nint a[1001][1001];\npint p[100002];\nint b[100001],c[100001];\nint main(){\n    int h,w;\n    cin>>h>>w;\n    rep(i,h)rep(j,w){\n        cin>>a[i][j];\n        p[a[i][j]]={j,i};\n    }\n    int ans=0;\n    rep(l,h*w){\n        int j=p[l+1].first,i=p[l+1].second;\n        int cnt=0;\n        rep(k,4){\n            int ty=i+dy[k],tx=j+dx[k];\n            if(ty>=0&&tx>=0&&ty<h&&tx<w&&a[ty][tx]<a[i][j]){\n                if(b[a[ty][tx]]==-1){\n                    if(b[l+1]==0) c[l+1]=a[ty][tx],b[l+1]=1;\n                    else if(b[l+1]==1&&c[l+1]!=a[ty][tx]){\n                        ++ans,b[l+1]=2;cnt=4;break;\n                    }\n                }\n                else if(b[a[ty][tx]]==1){\n                    if(b[l+1]==0){\n                        c[l+1]=c[a[ty][tx]];\n                        b[l+1]=1;\n                    }\n                    else{\n                        if(c[l+1]!=c[a[ty][tx]]){\n                            b[l+1]=2;\n                            ++ans;cnt=4;break;\n                        }        \n                    }\n                }\n                else if(b[a[ty][tx]]==2){\n                    b[l+1]=2;\n                    ++ans;cnt=4;break;\n                }\n            }\n            if(ty>=0&&tx>=0&&ty<h&&tx<w&&a[ty][tx]<a[i][j]) ++cnt;\n        }\n        if(cnt==0) b[l+1]=-1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint h,w;\nint mp[1001][1001];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nint used[1001][1001],mem[1001][1001];\n\nint dfs(int y,int x){\n  \n  if(used[y][x]++) return mem[y][x];\n \n  int &res=mem[y][x]=0;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||nx>=w||ny<0||ny>=h||mp[y][x]<mp[ny][nx]) continue;\n    int r=dfs(ny,nx);\n    if(r==0)r=ny*w+nx+1;\n    if(r==-1) res=-1;\n    if(r&&res&&res!=r) res=-1;\n    else if(r) res=r;\n  }\n  return res;\n}\n\n\nint main(){\n  \n  cin>>h>>w;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) cin>>mp[i][j];\n  \n  int ans=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(dfs(i,j)==-1) ans++;\n    }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\nconst int INF = 1000100;\nint h, w, n = 0;\nint a[1002][1002], b[1002][1002];\nbool f[1002][1002];\nvector<pair <int, int> > p;\n\nvoid climb(int i, int j) {\n\tf[i][j] = 1;\n\tb[i][j]++;\n\n\tif (i < h && a[i + 1][j] > a[i][j] && !f[i + 1][j])\n\t\tclimb(i + 1, j);\n\tif (i > 1 && a[i - 1][j] > a[i][j] && !f[i - 1][j])\n\t\tclimb(i - 1, j);\n\tif (j < w && a[i][j + 1] > a[i][j] && !f[i][j + 1])\n\t\tclimb(i, j + 1);\n\tif (j > 1 && a[i][j - 1] > a[i][j] && !f[i][j - 1])\n\t\tclimb(i, j - 1);\n}\n\nint main()\n{\n\tcin >> h >> w;\n\n\tfor (int i = 0; i < 1002; i++)\n\t\tfor (int j = 0; j < 1002; j++)\n\t\t\ta[i][j] = INF;\n\n\tfor (int i = 1; i <= h; i++)\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\tcin >> a[i][j];\n\n\tfor (int i = 1; i <= h; i++)\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tif (a[i + 1][j] > a[i][j] && a[i - 1][j] > a[i][j] &&\n\t\t\t\ta[i][j + 1] > a[i][j] && a[i][j - 1] > a[i][j])\n\t\t\t\tp.push_back({ i, j });\n\t\t}\n\n\tmemset(b, 0, 1004004);\n\n\tfor (int i = 0; i < (int)p.size(); i++) {\n\t\tmemset(f, 0, 1004004);\n\t\tclimb(p[i].first, p[i].second);\n\t}\n\t\t\n\tfor (int i = 1; i <= h; i++)\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\tif (b[i][j] > 1)\n\t\t\t\tn++;\n\n\tcout << n << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1001][1001],m1[1001][1001],a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    return 1;\n  }\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    m1[i][j]=-1;\n    sum+=dfs(j,i);\n    rep(z,a)rep(g,b)m1[z][g]=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[1199][1199],d[1199][1199],yy,xx,p,ans;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nbool bo[1199][1199];\nvoid bfs(){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(p,mk(yy,xx)));\n  d[yy][xx]=p;\n  while(!q.empty()){\n    pair<int,pair<int,int> > g=q.front();q.pop();\n    int ya=g.s.f,xa=g.s.s,dd=g.f;\n    r(i,4){\n      int y=ya+dy[i],x=xa+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd){\n        if(d[y][x]&&d[y][x]!=p)bo[y][x]=1;\n        d[y][x]=p;\n        if(!d[y][x])q.push(mk(a[y][x],mk(y,x)));\n      }\n    }\n  }\n}\nmain(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    bfs();\n  }\n  r(i,h)r(j,w)if(bo[i][j])ans++;\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 10000000\ntypedef pair<int, int>P;\nint h, w;\nint f[1005][1005] = { 0 };\nint dx[] = { 1,0,-1,0 }, dy[] = { 0,-1,0,1 };\nint stop[1005][1005] = { 0 };\nint cnt[1005][1005] = { 0 };\nint visited[1005][1005] = { 0 };\nvoid bfs(int x, int y) {\n\tfor (int i = 0; i < 1005; i++)\n\t\tfor (int j = 0; j < 1005; j++) visited[i][j] = 0;\n\tqueue<P>que;\n\tque.push(P(x, y));\n\tvisited[x][y] = 1;\n\twhile (!que.empty()) {\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint nx = p.first + dx[k];\n\t\t\tint ny = p.second + dy[k];\n\t\t\tif (1 <= nx && nx <= h && 1 <= ny && ny <= w&&!visited[nx][ny]) {\n\t\t\t\tif (f[p.first][p.second] < f[nx][ny]) {\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tcnt[nx][ny]++;\n\t\t\t\t\tvisited[nx][ny] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\tint res = 0;\n\tcin >> h >> w;\n\tfor (int i = 0; i <= h + 1; i++)\n\t\tfor (int j = 0; j <= w + 1; j++) f[i][j] = INF;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) cin >> f[i][j];\n\t}\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tbool flag = true;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint nx = i + dx[k];\n\t\t\t\tint ny = j + dy[k];\n\t\t\t\tif (f[i][j] > f[nx][ny]) flag = false;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tstop[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tif (stop[i][j]) {\n\t\t\t\t//cout << i << \" \" << j << endl;\n\t\t\t\tbfs(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t//cout << cnt[i][j] << \" \";\n\t\t\tif (cnt[i][j] >= 2) res++;\n\t\t}\n\t\t//cout << \"\\n\";\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[1199][1199],d[1199][1199],yy,xx,p,ans;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nbool bo[1199][1199];\nvoid bfs(){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(p,mk(yy,xx)));\n  d[yy][xx]=p;\n  while(!q.empty()){\n    pair<int,pair<int,int> > g=q.front();q.pop();\n    int ya=g.s.f,xa=g.s.s,dd=g.f;\n    r(i,4){\n      int y=ya+dy[i],x=xa+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd){\n        if(d[y][x]&&d[y][x]!=p)bo[y][x]=1;\n        d[y][x]=p;\n        q.push(mk(a[y][x],mk(y,x)));\n      }\n    }\n  }\n}\nmain(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    bfs();\n  }\n  r(i,h)r(j,w)if(bo[i][j])ans++;\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;i<(n);i++)\n#define rrep(i,n) for(int (i)=1;i<=(n);i++)\n#define REP(i,m,n) for(int (i)=(m);(i)<(n);(i)++)\n#define MOD 1000000007\n#define INF 1e18\n#define int long long\n#define endl \"\\n\"\n#define yorn(f) puts((f)?\"Yes\":\"No\")\n#define YORN(f) puts((f)?\"YES\":\"NO\")\ntypedef long long ll;\ntypedef pair<int, int> P;\nint gcd(int a,int b){return b?gcd(b,a%b):a;};\nint lcm(int a,int b){return a/gcd(a,b)*b;};\nint mod(int a,int b){return (a+b-1)/b;};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N],const T &val){std::fill((T*)array,(T*)(array+N),val);}\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;};\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;};\n\nint h, w;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\nint fld[1001][1001];\nint cnt[1001][1001];\n\nbool isOK(int x, int y) {\n\tif(0 <= x && x < w && 0 <= y && y < h) return 1;\n\treturn 0;\n}\n\nbool isvalley(int x, int y) {\n\trep(i, 4) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(isOK(nx, ny)) {\n\t\t\tif(fld[ny][nx] < fld[y][x]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid bfs(int sx, int sy) {\n\tif(!isvalley(sx, sy)) return ;\n\tcnt[sy][sx]++;\n\n\tqueue<P> que;\n\tvector<vector<int>> came(h, vector<int>(w, 0));\n\tque.push(P(sx, sy));\n\twhile(!que.empty()) {\n\t\tP p = que.front();\n\t\tque.pop();\n\t\trep(i, 4) {\n\t\t\tint nx = p.first + dx[i];\n\t\t\tint ny = p.second + dy[i];\n\t\t\tif(!isOK(nx, ny)) continue;\n\t\t\tif(!came[ny][nx] && fld[p.second][p.first] < fld[ny][nx]) {\n\t\t\t\tcame[ny][nx] = 1;\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t\tcnt[ny][nx]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n\t\n\tcin >> h >> w;\n\trep(i, h) rep(j, w) cin >> fld[i][j];\n\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tbfs(j, i);\n\t\t}\n\t}\n\t// rep(i, h) {\n\t// \trep(j, w) cout << cnt[i][j] << \" \";\n\t// \tcout << endl;\n\t// }\n\tint ans = 0;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif(cnt[i][j] != 1) ans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nint h,w,res = 0,pos = 0;\nint field[1000][1000];\nint cnt[1000][1000];\nbool used[1000][1000];\nqueue<P> que;\n\nvoid dfs(int x,int y){\n\tused[x][y] = true;\n\tque.push(P(x,y));\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] > field[x][y] && !used[nx][ny]){\n\t\t\tcnt[nx][ny]++;\n\t\t\tif(cnt[nx][ny] < 3) dfs(nx,ny);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) scanf(\"%d\",&field[i][j]);\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] < field[i][j]) flag = false;\n\t\t\t}\n\t\t\tif(flag) dfs(i,j);\n\t\t\twhile(!que.empty()){\n\t\t\t\tint x = que.front().first,y = que.front().second;que.pop();\n\t\t\t\tused[x][y] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) if(cnt[i][j] >= 2) res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nstatic const int MAX_H = 1000;\nstatic const int MAX_W = 1000;\nstatic const int MULTI_DIRECTED = MAX_H * MAX_W;\n#define MD MULTI_DIRECTED\n\nint H, W;\nint M[MAX_H][MAX_W];\nint y[MAX_H * MAX_W], x[MAX_H * MAX_W];\nint dest[MAX_H * MAX_W];\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {1, 0, -1, 0};\n\nint main(){\n\tscanf(\"%d %d\", &H, &W);\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tscanf(\"%d\", &M[i][j]);\n\t\t\tM[i][j]--;\n\t\t\ty[M[i][j]] = i;\n\t\t\tx[M[i][j]] = j;\n\t\t\tdest[M[i][j]] = M[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < H * W; i++){\n\t\tint cy = y[i], cx = x[i];\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tint ny = cy + dy[j], nx = cx + dx[j];\n\t\t\tif(ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\n\t\t\tif(M[ny][nx] < i) continue;\n\t\t\tif(dest[M[ny][nx]] == M[ny][nx]) dest[M[ny][nx]] = dest[M[cy][cx]];\n\t\t\telse if(dest[M[ny][nx]] != dest[M[cy][cx]]) dest[M[ny][nx]] = MD;\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int i = 0; i < H * W; i++){\n\t\tif(dest[i] == MD) res++;\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nconst int dx[4] = { -1, 0, 0, 1 }, dy[4] = { 0, -1, 1, 0 };\nint H, W, M[1234][1234];\nvector<vector<int>> water;\nvector<set<int>> water_to;\n\nint index(int w, int h) {\n\tif (w < 0 || h < 0 || w >= W || h >= H) return -1;\n\treturn h * W + w;\n}\n\nvoid GetWaterTo(int i) {\n\tif (water_to[i].size() > 0) return;\n\tif (water[i].size() == 0) water_to[i].insert(i);\n\trep(j, water[i].size()) {\n\t\tGetWaterTo(water[i][j]);\n\t\twater_to[i].insert(water_to[water[i][j]].begin(), water_to[water[i][j]].end());\n\t}\n\treturn;\n}\n\nint main() {\n\n\tscanf(\"%d %d\", &H, &W);\n\n\twater.resize(H*W);\n\twater_to.resize(H*W);\n\n\tvector<pair<int, int>> order;\n\n\tint IndexCount = 0;\n\trep(i, H) rep(j, W) {\n\t\tscanf(\"%d\", &M[i][j]);\n\t\torder.push_back(make_pair(M[i][j], IndexCount));\n\t\tIndexCount++;\n\t}\n\n\trep(i, H) rep(j, W) {\n\t\trep(d, 4) {\n\t\t\tif (index(j + dx[d], i + dy[d]) != -1 && M[i][j] > M[i + dy[d]][j + dx[d]]) {\n\t\t\t\twater[index(j, i)].push_back(index(j + dx[d], i + dy[d]));\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(order.begin(), order.end());\n\n\trep(i, order.size()) GetWaterTo(order[i].second);\n\t//rep(i, H*W) GetWaterTo(i);\n\n\tint c = 0;\n\trep(i, H*W) if (water_to[i].size() >= 2) c++;\n\n\tprintf(\"%d\\n\", c);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\nconstexpr int INF = 1 << 29;\nconstexpr int MOD = 1000000007;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nconstexpr int dx[4] = {1, 0, -1, 0};\nconstexpr int dy[4] = {0, 1, 0, -1};\n\nstruct Point {\n\tint h;\n\tint x, y;\n\tbool operator>(const Point &rhs) const {\n\t\treturn h > rhs.h;\n\t}\n};\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> M(H, vector<int>(W));\n\t\n\tpriority_queue<Point, vector<Point>, greater<Point>> Q;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> M[i][j];\n\t\t\tQ.push((Point){M[i][j], j, i});\n\t\t}\n\t}\n\n\tvector<vector<int>> type(H, vector<int>(W, 0));\n\tvector<vector<pii>> dst(H, vector<pii>(W));\n\tint ans = 0;\n\twhile(!Q.empty()) {\n\t\tPoint p = Q.top(); Q.pop();\n\t\tint cnt = 0;\n\t\tint tempx, tempy;\n\t\tset<pii> dests;\n\t\tbool found_type2 = false;\n\t\tfor(int k = 0; k < 4; k++) {\n\t\t\tint tx = p.x + dx[k];\n\t\t\tint ty = p.y + dy[k];\n\t\t\tif (tx < 0 || tx >= W || ty < 0 || ty >= H) continue;\n\t\t\tif (type[ty][tx] == 1) {\n\t\t\t\tcnt++;\n\t\t\t\ttempx = tx, tempy = ty;\n\t\t\t\tdests.insert(dst[ty][tx]);\n\t\t\t} else if (type[ty][tx] == 2) {\n\t\t\t\tfound_type2 = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_type2 && (cnt == 0 || dests.size() == 1)) {\n\t\t\ttype[p.y][p.x] = 1;\n\t\t\tif (cnt == 0) {\n\t\t\t\tdst[p.y][p.x] = mp(p.x, p.y);\n\t\t\t} else {\n\t\t\t\tdst[p.y][p.x] = dst[tempy][tempx];\n\t\t\t}\n\t\t} else {\n\t\t\ttype[p.y][p.x] = 2;\n\t\t\tans++;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nint M[1000][1000];\nint reach[1000][1000];\nint x[100000], y[100000];\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n\n\nint main()\n{\n  scanf(\"%d %d\", &H, &W);\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      scanf(\"%d\", &M[i][j]);\n      --M[i][j];\n      x[M[i][j]] = j;\n      y[M[i][j]] = i;\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < H * W; i++) {\n    int proc = i;\n    for(int j = 0; j < 4; j++) {\n      int nx = x[i] + vx[j], ny = y[i] + vy[j];\n      if(nx < 0 || ny < 0 || nx >= W || ny >= H) continue;\n      if(M[ny][nx] < i) {\n        if(proc == i) proc = reach[ny][nx];\n        else if(proc != reach[ny][nx]) proc = -1;\n      }\n    }\n    reach[y[i]][x[i]] = proc;\n    ret += proc == -1;\n  }\n\n  printf(\"%d\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\nint map[1002][1002];\nint dat[1002][1002];\nint x[1000001], y[1000001];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint main()\n{\n\tint mx, my;\n\tscanf(\"%d%d\", &mx, &my);\n\tfor (int i = 0; i < mx + 2; i++)for (int j = 0; j < my + 2; j++)map[i][j] = 1000000000, dat[i][j] = 0;\n\tfor (int i = 0; i < mx; i++)for (int j = 0; j < my; j++)scanf(\"%d\", &map[i + 1][j + 1]);\n\tfor (int i = 1; i <= mx; i++)for (int j = 1; j <= my; j++)x[map[i][j]] = i, y[map[i][j]] = j;\n\tint c = 0;\n\tfor (int i = 1; i <= mx*my; i++)\n\t{\n\t\tint r = 0;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint a = x[i] + dx[j], b = y[i] + dy[j];\n\t\t\tif (map[a][b] < i)\n\t\t\t{\n\t\t\t\tif (r == 0)r = dat[a][b];\n\t\t\t\telse if (r != dat[a][b])r = -1;\n\t\t\t}\n\t\t}\n\t\tif (r == 0)dat[x[i]][y[i]] = i;\n\t\telse dat[x[i]][y[i]] = r;\n\t\tif (r == -1)c++;\n\t}\n\tprintf(\"%d\\n\", c);\n}"
  },
  {
    "language": "C++",
    "code": "// JOI2017年予選５　尾根\n// http://j...content-available-to-author-only...c.jp/onlinejudge/description.jsp?id=0634\n#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n    int H,W;\n    cin >> H >>W;\n    int map[H+2][W+2];\n    int onecheck[H+2][W+2];\n    for(int i=0;i<H+2;i++){\n        for(int j=0;j<W+2;j++){\n            map[i][j]=H*W+1;\n            onecheck[i][j]=0;\n        }\n    }\n    for(int i=1;i<H+1;i++){\n        for(int j=1;j<W+1;j++){\n            cin >> map[i][j];\n        }\n    }\n    // 水たまりを探す\n    vector<pair<int,int> > mizutamari;\n    for(int i=1;i<H+1;i++){\n        for(int j=1;j<W+1;j++){\n            if(map[i][j]<map[i+1][j] && map[i][j]<map[i-1][j] && map[i][j]<map[i][j+1] && map[i][j]<map[i][j-1])mizutamari.push_back(make_pair(i,j));\n        }\n    }\n    // 各水たまりに流れ込むエリアを探す\n    for(int k=0;k<mizutamari.size();k++){\n        queue<pair<int, int> >q;// キュー q を定義\n        q.push(make_pair(mizutamari[k].first,mizutamari[k].second));//スタート地点をqにプッシュ\n        int step[H+2][W+2];\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                step[i][j]=0;\n            }\n        }\n        while(q.empty()==false){// q が空になるまでループを回す\n            pair<int, int> point=q.front();\n            q.pop();\n            int i=point.first;\n            int j=point.second;\n            //onecheck[][]<2 のチェックを入れておかないと、余計な計算がかなり増えて、AOJで「Runtime Error」がでる。\n            if(map[i][j]<map[i+1][j] && step[i+1][j]==0 && onecheck[i+1][j]<2){step[i+1][j]=1;onecheck[i+1][j]++;q.push(make_pair(i+1,j));}\n            if(map[i][j]<map[i-1][j] && step[i-1][j]==0 && onecheck[i-1][j]<2){step[i-1][j]=1;onecheck[i-1][j]++;q.push(make_pair(i-1,j));}\n            if(map[i][j]<map[i][j+1] && step[i][j+1]==0 && onecheck[i][j+1]<2){step[i][j+1]=1;onecheck[i][j+1]++;q.push(make_pair(i,j+1));}\n            if(map[i][j]<map[i][j-1] && step[i][j-1]==0 && onecheck[i][j-1]<2){step[i][j-1]=1;onecheck[i][j-1]++;q.push(make_pair(i,j-1));}\n        }\n    }\n    int count=0;\n    for(int i=1;i<H+1;i++){\n        for(int j=1;j<W+1;j++){\n            if(onecheck[i][j]>1)count++;\n        }\n    }\n    cout << count << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define dmp make_pair\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\nconst int inf = 1e9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n\nint a[1002][1002], b[1002][1002];\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\npriority_queue<PP, vector<PP>, greater<PP> > q;\nint main(){\n\tint h, w, ans = 0;\n\tscanf(\"%d%d\", &h, &w);\n\tfill((int*)a, (int*)(a+1002), inf);\n\trrep(i,h)rrep(j,w)scanf(\"%d\", &a[i][j]);\n\trrep(y,h)rrep(x,w){\n\t\tint f = 0;\n\t\trep(i,4)if(a[y][x] < a[y+dy[i]][x+dx[i]])f++;\n\t\tif(f == 4)b[y][x] = a[y][x];\n\t\tq.push(dmp(a[y][x], P(y, x)));\n\t}\n\t\n\twhile(!q.empty()){\n\t\tPP p = q.top();q.pop();\n\t\tint y = p.se.fi, x = p.se.se;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(a[y][x] < a[yy][xx] && b[yy][xx] == 0){\n\t\t\t\tb[yy][xx] = b[y][x];\n\t\t\t}\n\t\t\tif(a[y][x] < a[yy][xx] && b[y][x] != b[yy][xx] && b[yy][xx] != -1){\n\t\t\t\t//printf(\"%d \", a[yy][xx]);\n\t\t\t\tb[yy][xx] = -1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[1199][1199],d[1199][1199],yy,xx,p,ans;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nvector<pair<int,int> >vv;\nbool used[1199][1199];\nvoid bfs(){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(p,mk(yy,xx)));\n  d[yy][xx]=p;\n  while(!q.empty()){\n    pair<int,pair<int,int> > g=q.front();q.pop();\n    int ya=g.s.f,xa=g.s.s,dd=g.f;\n    r(i,4){\n      int y=ya+dy[i],x=xa+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd){\n        if(d[y][x]&&d[y][x]!=p)vv.push_back(mk(y,x));\n        if(!d[y][x])q.push(mk(a[y][x],mk(y,x)));\n        d[y][x]=p;\n      }\n    }\n  }\n}\nvoid bfs2(int yy,int xx,int dd){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(dd,mk(yy,xx)));\n  if(!used[yy][xx]){\n    used[yy][xx]=1;\n    while(!q.empty()){\n      pair<int,pair<int,int> > g=q.front();q.pop();\n      ans++;\n      int yy=g.s.f,xx=g.s.s,dd=g.f;\n      r(i,4){\n        int y=yy+dy[i],x=xx+dx[i];\n        if(y<0||y>=h||x<0||x>=w)continue;\n        if(a[y][x]>dd&&!used[y][x]){\n          q.push(mk(a[y][x],mk(y,x)));\n          used[y][x]=1;\n        }\n      }\n    }\n  }\n}\nmain(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    bfs();\n  }\n  r(i,vv.size())bfs2(vv[i].f,vv[i].s,a[vv[i].f][vv[i].s]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int H, W;\n  int M[1000][1000];\n  int reach[1000][1000] = {{}};\n  int x[100000], y[100000];\n  const int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n\n  scanf(\"%d %d\", &H, &W);\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      scanf(\"%d\", &M[i][j]);\n      --M[i][j];\n      x[M[i][j]] = j;\n      y[M[i][j]] = i;\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < H * W; i++) {\n    int proc = i;\n    for(int j = 0; j < 4; j++) {\n      int nx = x[i] + vx[j], ny = y[i] + vy[j];\n      if(nx < 0 || ny < 0 || nx >= W || ny >= H) continue;\n      if(M[ny][nx] < i) {\n        if(proc == i) proc = reach[ny][nx];\n        else if(proc != reach[ny][nx]) proc = -1;\n      }\n    }\n    reach[y[i]][x[i]] = proc;\n    ret += proc == -1;\n  }\n\n  printf(\"%d\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint H, W;\nint M[1010][1010];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> H >> W;\n  vector<int> x(H*W + 1), y(H*W + 1);\n  vector<int> fall(H*W + 1);\n  rep(i, H) rep(j, W) {\n    cin >> M[i][j]; M[i][j]--;\n    x[M[i][j]] = j, y[M[i][j]] = i;\n    fall[M[i][j]] = M[i][j];\n  }\n\n  int ans = 0;\n  reps(elv, 1, H*W) {\n    set<int> st;\n    rep(i, 4) {\n      int nx = x[elv] + dx[i];\n      int ny = y[elv] + dy[i];\n      if(nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n      if(M[ny][nx] < elv) st.insert(fall[M[ny][nx]]);\n    }\n    bool ridge = (*st.begin() == -1 || st.size() > 1);\n    if(ridge) fall[elv] = -1, ans++;\n    else if(st.size()) fall[elv] = *st.begin();\n  }\n\n  cout << ans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<set>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<sstream>\nusing namespace std;\n \n#define P(p) cout<<(p)<<endl\n#define rep(i,m,n) for(int i = (m); i < (int)(n); i++)\n#define rrep(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)\n#define vsort(v) sort(v.begin(), v.end());\n#define rvsort(v) sort(v.begin(), v.end(),greater<int>());\n#define YES cout<<\"YES\"<< endl\n#define NO cout<<\"NO\"<<endl\n#define Yes cout<<\"Yes\"<<endl\n#define No cout<<\"No\"<<endl  \n#define yes cout<<\"yes\"<<endl\n#define no cout<<\"no\"<<endl\n#define ret return\n#define lb(v,n) lower_bound(v.begin(),v.end(),n)\n#define ub(v,n) upper_bound(v.begin(),v.end(),n)\n#define mae(v) max_element(v.begin(),v.end())\n#define mie(v) min_element(v.begin(),v.end())\n#define INF 0x7FFFFFFF\n#define mod 1000000007\ntypedef long long ll;\n////////////////////////////////////////////////////////////\n\nint f[1010][1010];\nint b[2000];\nint bb[2000];\nbool bbb[2000];\n\nint solve( int i , int j , int cnt ){\n\t\n\tif( !bbb[f[i][j]] )\n\t\tbbb[f[i][j]] = 1;\n\t\n\t//cout << i << \" \" << j << \" \" << f[i][j] << \" \" << b[f[i][j]] << endl;\n\n\tif( !f[i][j] )\n\t\tret 0;\n\t\n\tif( cnt > 0 && b[f[i][j]] >= 0){\n\t\tret b[f[i][j]];\n\t}\n\telse{\n\t\tint sum = 0;\n\t\tif( f[i][j] > f[i+1][j] ) sum += solve( i+1 , j , cnt+1 );\n\t\tif( f[i][j] > f[i-1][j] ) sum += solve( i-1 , j , cnt+1 );\n\t\tif( f[i][j] > f[i][j+1] ) sum += solve( i , j+1 , cnt+1 );\n\t\tif( f[i][j] > f[i][j-1] ) sum += solve( i , j-1 , cnt+1 );\n\t\tb[f[i][j]] = sum;\n\t\tret sum;\n\t}\n\t\n\t\n}\n\nint main(){\n\tint h,w;\n\tcin >> h >> w;\n\t\n\trep(i,0,1010){\n\t\trep(j,0,1010){\n\t\t\tf[i][j] = 1010;\n\t\t}\n\t}\n\t\n\tmemset(b,0,sizeof b);\n\n\trep(i,0,h){\n\t\trep(j,0,w){\n\t\t\tcin >> f[i+1][j+1];\n\t\t}\n\t}\n\t\n\n\n\trep(i,0,h){\n\t\trep(j,0,w){\n\t\t\tint ii = i+1, jj = j+1;\n\t\t\t\n\t\t\tb[f[ii][jj]]=-1;\n\n\t\t\tif( f[ii][jj] < f[ii-1][jj] ){\n\t\t\t\tif( f[ii][jj] < f[ii+1][jj] ){\n\t\t\t\t\tif( f[ii][jj] < f[ii][jj+1] ){ \n\t\t\t\t\t\tif( f[ii][jj] < f[ii][jj-1] ){\n\t\t\t\t\t\t\tb[f[ii][jj]] = 1;\n\t\t\t\t\t\t\tbb[f[ii][jj]] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\trep(i,0,h){\n\t\trep(j,0,w){\n\n\t\t\tif( bb[f[i+1][j+1]]  )\n\t\t\t\tcontinue;\n\n\t\t\tint tmp = solve( i+1 , j+1 , 0 );\n\t\t\tif( tmp > 1 )\n\t\t\t\tans++;\n\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\tret 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nconst int dx[4] = { -1, 0, 0, 1 }, dy[4] = { 0, -1, 1, 0 };\nint H, W, M[1234][1234];\nvector<vector<int>> water;\nvector<int> water_to;\n\nint index(int w, int h) {\n\tif (w < 0 || h < 0 || w >= W || h >= H) return -1;\n\treturn h * W + w;\n}\n\nvoid GetWaterTo(int i) {\n\tif (water_to[i] != 0) return;\n\tif (water[i].size() == 0) {\n\t\twater_to[i] = i;\n\t\treturn;\n\t}\n\tset<int> t;\n\trep(j, water[i].size()) {\n\t\tGetWaterTo(water[i][j]);\n\t\tt.insert(water_to[water[i][j]]);\n\t\tif (t.size() >= 2) break;\n\t}\n\tif (t.size() >= 2) water_to[i] = -1;\n\telse water_to[i] = *t.begin();\n\n\treturn;\n}\n\nint main() {\n\n\tscanf(\"%d %d\", &H, &W);\n\n\twater.resize(H*W);\n\twater_to.resize(H*W, 0);\n\n\tvector<pair<int, int>> order;\n\n\tint IndexCount = 0;\n\trep(i, H) rep(j, W) {\n\t\tscanf(\"%d\", &M[i][j]);\n\t\torder.push_back(make_pair(M[i][j], IndexCount));\n\t\tIndexCount++;\n\t}\n\n\trep(i, H) rep(j, W) {\n\t\trep(d, 4) {\n\t\t\tif (index(j + dx[d], i + dy[d]) != -1 && M[i][j] > M[i + dy[d]][j + dx[d]]) {\n\t\t\t\twater[index(j, i)].push_back(index(j + dx[d], i + dy[d]));\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(order.begin(), order.end());\n\n\trep(i, order.size()) GetWaterTo(order[i].second);\n\t//rep(i, H*W) GetWaterTo(i);\n\n\tint c = 0;\n\trep(i, H*W) if (water_to[i] == -1) c++;\n\n\tprintf(\"%d\\n\", c);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],m1[1020][1020],a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    return 1;\n  }\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    m1[i][j]=-1;\n    sum+=dfs(j,i);\n    rep(z,a)rep(g,b)m1[z][g]=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(ll i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\nll ppow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n > 0) {\n\t\tif ((n & 1) == 1)ans = ans * x;\n\t\tx = x * x;\n\t\tn >>= 1;\n\t\tx %= mod;\n\t\tans %= mod;\n\t}\n\treturn ans;\n}\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll sz, fact[N], inv[N];\nvoid setinv() {\n\tfact[0] = 1; inv[0] = 1;\n\tfor (int i = 1; i <= sz; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % mod;  //階乗を求める\n\t\tinv[i] = ppow(fact[i], (ll)mod - 2) % mod; // フェルマーの小定理で逆元を求める\n\t}\n}\nll conv(ll r) {//nCr\n\treturn fact[sz] * inv[r] % mod * inv[sz - r] % mod;\n}\nll h, w, m[1000][1000];\nvector<ll>v[1000][1000];\nvector<int>vv;\nvoid f(pp pos) {\n\tbool b = 1;\n\tif (pos.fi > 0 && m[pos.fi][pos.se] > m[pos.fi - 1][pos.se]) { f(pp{ pos.fi-1 ,pos.se }); b = 0; }\n\tif (pos.fi < h-1 && m[pos.fi][pos.se] > m[pos.fi + 1][pos.se]) { f(pp{ pos.fi+1 ,pos.se }); b = 0; }\n\tif (pos.se > 0 && m[pos.fi][pos.se] > m[pos.fi][pos.se-1]) { f(pp{ pos.fi ,pos.se-1 }); b = 0; }\n\tif (pos.se <w-1 && m[pos.fi][pos.se] > m[pos.fi][pos.se+1]) { f(pp{ pos.fi ,pos.se+1 }); b = 0; }\n\tif (b)vv.pb(m[pos.fi][pos.se]);\n}\nint main() {\n\tcin >> h >> w;\n\tint ans=0, a=INF;\n\trep(i, h)rep(j, w)cin >> m[i][j];\n\trep(i, h)rep(j, w) {\n\t\ta = INF;\n\t\tvv.clear();\n\t\tf(pp{ i,j });\n\t\trep(k,vv.size()) {\n\t\t\t//cout << vv[k] << \",\" << m[i][j] << endl;\n\t\t\tif (a == INF)a = vv[k];\n\t\t\telse if (a != vv[k]) { ++ans; break; }\n\t\t}\n\t}\n\tcout << ans<< endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//q5.cpp\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\nint m[SIZE][SIZE];\nint dp[SIZE][SIZE];\nvector<pair<int,pair<int,int> > > vec;\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nint main(){\n  int h,w;\n\n  scanf(\"%d%d\",&h,&w);\n\n  for(int i=0;i<=h+1;i++){\n    for(int j=0;j<=w+1;j++){\n      m[i][j] = INF;\n    }\n  }\n  \n  for(int i=1;i<=h;i++){\n    for(int j=1;j<=w;j++){\n      scanf(\"%d\",&m[i][j]);\n      vec.push_back({m[i][j],{i,j}});\n    }\n  }\n\n  sort(vec.begin(),vec.end());\n\n  for(int i=0;i<h*w;i++){\n    int y = vec[i].second.first;\n    int x = vec[i].second.second;\n\n    if(dp[y][x] == 0){\n      dp[y][x] = m[y][x];\n      \n      for(int j=0;j<4;j++){\n        if(m[y][x] > m[y+dy[j]][x+dx[j]]) dp[y][x] = 0;\n      }\n    }\n\n    if(dp[y][x] == -1){\n      for(int j=0;j<4;j++){\n        if(m[y][x] < m[y+dy[j]][x+dx[j]]) dp[y+dy[j]][x+dx[j]] = -1;\n      }\n    }\n\n    if(dp[y][x] > 0){\n      for(int j=0;j<4;j++){\n        if(m[y][x] < m[y+dy[j]][x+dx[j]]){\n          if(dp[y+dy[j]][x+dx[j]] == 0) \n            dp[y+dy[j]][x+dx[j]] = dp[y][x];\n          else if(dp[y+dy[j]][x+dx[j]] > 0 && dp[y+dy[j]][x+dx[j]] != dp[y][x]) \n            dp[y+dy[j]][x+dx[j]] = -1;\n        }\n      } \n    }\n  }\n\n  int ans = 0;\n  \n  for(int i=1;i<=h;i++){\n    for(int j=1;j<=w;j++){\n      if(dp[i][j] == -1) ans++;\n    }\n  }\n  \n  printf(\"%d\\n\",ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],m1[1020][1020],a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  if(m1[y][x]>0)return 0;\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    return 1;\n  }\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    m1[i][j]=-1;\n    sum+=dfs(j,i);\n    rep(z,a)rep(g,b)m1[z][g]=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int dx[]={1,0,-1,0,1,-1,-1,1}; \nconst int dy[]={0,1,0,-1,1,1,-1,-1}; \nconst int INF = 1e9; \nconst long long LINF = 1e18; \nconst double EPS = 1e-8; \n#define pb push_back \n#define mk make_pair \n#define fr first \n#define sc second \n#define ll long long \n#define reps(i,j,k) for(int i = (j); i < (k); ++i) \n#define rep(i,j) reps(i,0,j) \n#define all(a) (a).begin(),(a).end() \n#define MOD 1000000007 \ntypedef pair<int,int> Pii;\ntypedef pair<Pii,int> P;\ntypedef vector<int> vi;\nint stage[1024][1024];\nint H,W;\nint memo[1024][1024];\nint main(){\n    //input\n    cin >> H >> W;\n    \n    rep(i,H){\n        rep(j,W){\n            cin >> stage[i][j];\n        }\n    }\n    vector<Pii> pond;\n    \n    rep(i,H){\n        rep(j,W){\n            bool flg = false;\n            rep(k,4){\n                int ny = i + dy[k];\n                int nx = j + dx[k];\n                if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n                if(stage[i][j] > stage[ny][nx]){\n                    flg = true;\n                }\n            }\n            if(!flg){\n                pond.pb(mk(i,j));\n            }\n        }\n    }\n    \n    rep(q,pond.size()){\n        bool used[1024][1024]={{}};\n        queue < Pii > Q;\n        Q.push(pond[q]);\n        while(!Q.empty()){\n            Pii p = Q.front();Q.pop();\n            if(used[p.fr][p.sc])continue;\n            used[p.fr][p.sc] = 1;\n            rep(k,4){\n                int ny = p.fr + dy[k];\n                int nx = p.sc + dx[k];\n            \n                if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n                if(stage[p.fr][p.sc] > stage[ny][nx] || used[ny][nx])continue;\n                Q.push(Pii(ny,nx));\n            }\n        }\n        \n        rep(i,H){\n            rep(j,W){\n                if(used[i][j] && !(pond[q].fr == i && pond[q].sc == j)){\n                    memo[i][j]++;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,H){\n        rep(j,W){\n            if(memo[i][j] > 1){\n                ++ans;\n            }\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : DPTest.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint H,W;\nint M[1002][1002]={};\nint dp[1002][1002]={};\nint dp2[1002][1002]={};\ntypedef pair<int,int> P;\nconst int INF=1000000000;\n\nint main() {\n\tcin>>H>>W;\n\tfill(M[0],M[1002],INF);\n\n\tfor(int i=1;i<H+1;i++){\n\t\tfor(int j=1;j<W+1;j++){\n\t\t\tcin>>M[i][j];\n\t\t}\n\t}\n//\tfor(int i=0;i<H+2;i++){\n//\t\tM[i][0]=INF;\n//\t\tM[i][W+1]=INF;\n//\t}\n//\tfor(int i=0;i<W+2;i++){\n//\t\tM[0][i]=INF;\n//\t\tM[H+1][i]=INF;\n//\t}\n\tqueue<P> que;\n\tint x1,y1;\n\tfor(int i=1;i<H+1;i++){\n\t\tfor(int j=1;j<W+1;j++){\n\t\t\tif((M[i][j]<M[i-1][j]&&M[i][j]<M[i+1][j])&&(M[i][j]<M[i][j-1]&&M[i][j]<M[i][j+1])){\n\t\t\t\t//init\n\t\t\t\tfill(dp[0],dp[1002],0);\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p1=que.front();que.pop();\n\t\t\t\t\tx1=p1.first;\n\t\t\t\t\ty1=p1.second;\n\t\t\t\t\tif(dp[x1][y1]>0||dp2[x1][y1]>1)continue;\n\t\t\t\t\tdp[x1][y1]=1;\n\t\t\t\t\tdp2[x1][y1]+=1;\n\t\t\t\t\tif(M[x1-1][y1]>M[x1][y1]&&x1>1)que.push(P(x1-1,y1));\n\t\t\t\t\tif(M[x1+1][y1]>M[x1][y1]&&x1<H)que.push(P(x1+1,y1));\n\t\t\t\t\tif(M[x1][y1-1]>M[x1][y1]&&y1>1)que.push(P(x1,y1-1));\n\t\t\t\t\tif(M[x1][y1+1]>M[x1][y1]&&y1<W)que.push(P(x1,y1+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint R=0;\n\tfor(int i=1;i<H+1;i++){\n\t\tfor(int j=1;j<W+1;j++){\n\t\t\tif(dp2[i][j]>1)R++;\n\t\t}\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#pragma warning(disable : 4996);\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<vector<int> > v(H, vector<int>(W));\n\tvector<int> x(H * W), y(H * W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> v[i][j]; v[i][j]--;\n\t\t\tx[v[i][j]] = j;\n\t\t\ty[v[i][j]] = i;\n\t\t}\n\t}\n\tvector<int> dp(H * W, -1);\n\tfor (int i = 0; i < H * W; i++) {\n\t\tvector<int> s;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint dx = dir[j], dy = dir[j ^ 1];\n\t\t\tint tx = x[i] + dx, ty = y[i] + dy;\n\t\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && v[ty][tx] < i) {\n\t\t\t\ts.push_back(dp[v[ty][tx]]);\n\t\t\t}\n\t\t}\n\t\tsort(s.begin(), s.end());\n\t\ts.erase(unique(s.begin(), s.end()), s.end());\n\t\tif (s.size() == 0) dp[i] = i;\n\t\telse if (s.size() > 1 || s.back() == 999999999) dp[i] = 999999999;\n\t\telse dp[i] = s[0];\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < H * W; i++) ret += (dp[i] == 999999999 ? 1 : 0);\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define dmp make_pair\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\nconst int inf = 1e9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n\nint a[1002][1002], b[1002][1002];\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\npriority_queue<PP, vector<PP>, greater<PP> > q;\nint main(){\n\tint h, w, ans = 0;\n\tscanf(\"%d%d\", &h, &w);\n\tfill((int*)a, (int*)(a+1002), inf);\n\trrep(i,h)rrep(j,w)scanf(\"%d\", &a[i][j]);\n\trrep(y,h)rrep(x,w){\n\t\tint f = 0;\n\t\trep(i,4)if(a[y][x] < a[y+dy[i]][x+dx[i]])f++;\n\t\tif(f == 4)b[y][x] = a[y][x];\n\t\tq.push(dmp(a[y][x], P(y, x)));\n\t}\n\t\n\twhile(!q.empty()){\n\t\tPP p = q.top();q.pop();\n\t\tint y = p.se.fi, x = p.se.se;\n\t\tif(b[y][x] == -1)ans++;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tint f = (a[y][x] < a[yy][xx]);\n\t\t\tif(f && b[yy][xx] == 0){\n\t\t\t\tb[yy][xx] = b[y][x];\n\t\t\t}else if(f && b[y][x] != b[yy][xx] && b[yy][xx] != -1){\n\t\t\t\tb[yy][xx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\n\nint h, w;\nint m[1000][1000];\nint mem[1000][1000];\n\nint type(int i, int j){\n  if(mem[i][j] != -1){\n    return mem[i][j];\n  }\n  rep(k, 4){\n    int p = i + dx[k];\n    int q = j + dy[k];\n    if(0 <= p && p < h && 0 <= q && q < w && m[p][q] < m[i][j]){\n      int t = type(p, q);\n      if(t == 0 || (mem[i][j] != -1 && mem[i][j] != t)){\n        return mem[i][j] = 0;\n      }\n      mem[i][j] = t;\n    }\n  }\n  if(mem[i][j] == -1){\n    mem[i][j] = m[i][j];\n  }\n  return mem[i][j];\n}\n\nint main(){\n  scanf(\"%d%d\", &h, &w);\n  rep(i, h){\n    rep(j, w){\n      scanf(\"%d\", &m[i][j]);\n    }\n  }\n  fill_n((int*)mem, 1000 * 1000, -1);\n  int ans = 0;\n  rep(i, h){\n    rep(j, w){\n      ans += type(i, j) == 0;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <tuple>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nconst std::vector<int>\n    dx{-1, 0, 1, 0},\n    dy{0, -1, 0, 1};\n\nvoid solve() {\n    int h, w;\n    std::cin >> h >> w;\n\n    auto xss = vec(h, vec(w, 0));\n    std::vector<std::pair<int, int>> pos(h * w);\n    for (int x = 0; x < h; ++x) {\n        for (int y = 0; y < w; ++y) {\n            auto& a = xss[x][y];\n            std::cin >> a;\n            pos[--a] = std::make_pair(x, y);\n        }\n    }\n\n    auto to = vec(h, vec(w, 0));\n    for (auto p : pos) {\n        int x, y;\n        std::tie(x, y) = p;\n\n        std::set<int> tos;\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i],\n                ny = y + dy[i];\n            if (nx < 0 || h <= nx || ny < 0 || w <= ny ||\n                xss[nx][ny] > xss[x][y]) continue;\n\n            if (to[nx][ny] < 0) to[x][y] = -1;\n            tos.insert(to[nx][ny]);\n        }\n\n        if (to[x][y] < 0) continue;\n\n        if (tos.empty()) tos.insert(xss[x][y]);\n        if (tos.size() >= 2) tos.insert(-1);\n        to[x][y] = *tos.begin();\n    }\n\n    int ans = 0;\n    for (int x = 0; x < h; ++x) {\n        for (int y = 0; y < w; ++y) {\n            if (to[x][y] < 0) ++ans;\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct zahyou{\n  int hyoukou;\n  int x;\n  int y;\n};\n\nstruct motoz{\n  int hyoukou;\n  int point;\n  int ok;\n};\n\nclass LessHyoukou{\npublic:\n  bool operator()(const struct zahyou & riLeft, const struct zahyou & riRight) const{\n    return riLeft.hyoukou < riRight.hyoukou;\n  };\n};\n\nstruct zahyou z[1000000];\nstruct motoz zz[1002][1002];\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n  for(int i=0;i<1002;i++){\n    for(int j=0;j<1002;j++){\n      zz[i][j].hyoukou=10000000;\n      zz[i][j].point = 0;\n      zz[i][j].ok=0;\n    }\n  }\n  int m;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> m;\n      z[i*w+j].hyoukou = m;\n      z[i*w+j].x = j+1;\n      z[i*w+j].y = i+1;\n      zz[j+1][i+1].hyoukou = m;\n    }\n  }\n\n  sort(z,z+h*w,LessHyoukou());\n\n  int ans = 0;\n  int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\n  int isHekomi;\n  for(int i=0;i<h*w;i++){\n    isHekomi=1;\n    for(int j=0;j<4;j++){\n      if(z[i].hyoukou>zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].hyoukou)\n        isHekomi=0;\n    }\n    if(isHekomi){\n      for(int j=0;j<4;j++){\n        if(zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point*(zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point!=z[i].hyoukou)){\n          zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].ok=1;\n        }else{\n          zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point=z[i].hyoukou;\n        }\n      }\n    }else{\n      for(int j=0;j<4;j++){\n        if(z[i].hyoukou<zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].hyoukou)\n          if(zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point*(zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point!=zz[z[i].x][z[i].y].point)){\n            zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].ok=1;\n          }else{\n            zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point=zz[z[i].x][z[i].y].point;\n          }\n      }\n    }\n    if( zz[z[i].x][z[i].y].ok ){\n      ans++;\n    }\n  }\n\n  cout << ans << endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <iterator>\nusing namespace std;\n\nint hashx[4] = { 0,1,0,-1 };\nint hashy[4] = { 1,0,-1,0 };\nvector<int>graph[1234][1234];\n\nint height[1234][1234];\n\nint h, w;\n\nbool koshin[1234][1234];\nint memo[1234][1234];\nint dp(int i,int j)\n{\n\tif (koshin[i][j])return memo[i][j];\n\tint ans = 0;\n\tif (graph[i][j].size() == 0)\n\t{\n\t\tans = i * 1234 + j;\n\t}\n\telse\n\t{\n\t\tint firstv = graph[i][j][0];\n\t\tint kyo = dp(i + hashx[firstv], j + hashy[firstv]);\n\t\tfor (auto edge : graph[i][j])\n\t\t{\n\t\t\tif (dp(i + hashx[edge], j + hashy[edge]) != kyo)\n\t\t\t{\n\t\t\t\tans = -1;\n\t\t\t}\n\t\t}\n\t\tif (ans != -1)\n\t\t{\n\t\t\tans = kyo;\n\t\t}\n\t}\n\tkoshin[i][j] = true;\n\treturn memo[i][j] = ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d %d\", &h, &w);\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tscanf(\"%d\", &height[i][j]);\n\t\t}\n\t}\n\t//?¨?\n\tfor (int i = 1; i < h; ++i)\n\t{\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tif (height[i - 1][j] < height[i][j])\n\t\t\t{\n\t\t\t\t//??????\n\t\t\t\tgraph[i][j].push_back(3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//??????\n\t\t\t\tgraph[i - 1][j].push_back(1);\n\t\t\t}\n\t\t}\n\t}\n\t//???\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 1; j < w; ++j)\n\t\t{\n\t\t\tif (height[i][j - 1] < height[i][j])\n\t\t\t{\n\t\t\t\t//???\n\t\t\t\t//???\n\t\t\t\tgraph[i][j].push_back(2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//???\n\t\t\t\t//???\n\t\t\t\tgraph[i][j - 1].push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tif (dp(i, j) < 0)++ans;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\nconstexpr int INF = 1 << 29;\nconstexpr int MOD = 1000000007;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nconstexpr int dx[4] = {1, 0, -1, 0};\nconstexpr int dy[4] = {0, 1, 0, -1};\n\nstruct Point {\n\tint h;\n\tint x, y;\n\tbool operator>(const Point &rhs) const {\n\t\treturn h > rhs.h;\n\t}\n};\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> M(H, vector<int>(W));\n\t\n\tpriority_queue<Point, vector<Point>, greater<Point>> Q;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> M[i][j];\n\t\t\tQ.push((Point){M[i][j], j, i});\n\t\t}\n\t}\n\n\tvector<vector<int>> type(H, vector<int>(W, 0));\n\tvector<vector<pii>> dst(H, vector<pii>(W));\n\tint ans = 0;\n\twhile(!Q.empty()) {\n\t\tPoint p = Q.top(); Q.pop();\n\t\tint cnt = 0;\n\t\tint tempx, tempy;\n\t\tset<pii> dests;\n\t\tbool found_type2 = false;\n\t\tfor(int k = 0; k < 4; k++) {\n\t\t\tint tx = p.x + dx[k];\n\t\t\tint ty = p.y + dy[k];\n\t\t\tif (tx < 0 || tx >= W || ty < 0 || ty >= H) continue;\n\t\t\tif (type[ty][tx] == 1) {\n\t\t\t\tcnt++;\n\t\t\t\ttempx = tx, tempy = ty;\n\t\t\t\tdests.insert(dst[ty][tx]);\n\t\t\t} else if (type[ty][tx] == 2) {\n\t\t\t\tfound_type2 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt == 0) {\n\t\t\tdst[p.y][p.x] = mp(p.x, p.y);\n\t\t} else if (cnt == 1) {\n\t\t\tdst[p.y][p.x] = mp(tempx, tempy);\n\t\t}\n\n\t\tif (found_type2 || (cnt >= 2 && dests.size() != 1)) {\n\t\t\ttype[p.y][p.x] = 2;\n\t\t\tans++;\n\t\t} else {\n\t\t\ttype[p.y][p.x] = 1;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint d[1000][1000], cnt[1000][1000];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool used[1000][1000];\nint main() {\n\tint h, w; scanf(\"%d%d\", &h, &w);\n\trep(i, h)rep(j, w)scanf(\"%d\", &d[i][j]);\n\tstack<P>s;\n\trep(i, h)rep(j, w) {\n\t\tbool ok = true;\n\t\trep(k, 4) {\n\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&d[nx][ny] < d[i][j]) {\n\t\t\t\tok = false; break;\n\t\t\t}\n\t\t}\n\t\tif (!ok)continue;\n\t\tmemset(used, 0, sizeof(used));\n\t\ts.push(P(i, j));\n\t\twhile (!s.empty()) {\n\t\t\tint x = s.top().first, y = s.top().second; s.pop();\n\t\t\tif (used[x][y] || cnt[x][y] >= 2)continue;\n\t\t\tcnt[x][y]++; used[x][y] = true;\n\t\t\trep(k, 4) {\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&d[nx][ny]>d[x][y])s.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, h)rep(j, w) {\n\t\tif (cnt[i][j] >= 2)ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define dmp make_pair\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\nconst int inf = 1e9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n\nint a[1002][1002], b[1002][1002];\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\npriority_queue<PP, vector<PP>, greater<PP> > q;\nint main(){\n\tint h, w, ans = 0;\n\tscanf(\"%d%d\", &h, &w);\n\tfill((int*)a, (int*)(a+1002), inf);\n\trrep(i,h)rrep(j,w)scanf(\"%d\", &a[i][j]);\n\trrep(y,h)rrep(x,w){\n\t\tint f = 0;\n\t\trep(i,4)if(a[y][x] < a[y+dy[i]][x+dx[i]])f++;\n\t\tif(f == 4)b[y][x] = a[y][x];\n\t\tq.push(dmp(a[y][x], P(y, x)));\n\t}\n\t\n\twhile(!q.empty()){\n\t\tPP p = q.top();q.pop();\n\t\tint y = p.se.fi, x = p.se.se;\n\t\tif(b[y][x] == -1)ans++;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tint f = (a[y][x] < a[yy][xx]);\n\t\t\tif(f && b[yy][xx] == 0)b[yy][xx] = b[y][x];\n\t\t\telse if(f && b[y][x] != b[yy][xx] && b[yy][xx] != -1){\n\t\t\t\tb[yy][xx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int INF = 1000000000;\n\nint h, w;\nint m[1000][1000];\nint d[1000][1000]; // ok => INF - 1, one => number, zero => imposible, INF => not check yet\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint check(int y, int x) {\n  if (d[y][x] != INF) return d[y][x];\n  int temp = 0;\n  for (int k = 0; k < 4; k++) {\n    int ny = y + dy[k], nx = x + dx[k];\n    if (ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n    if (m[y][x] > m[ny][nx]) {\n      int t = check(ny, nx);\n      if (t == INF - 1) return d[y][x] = INF - 1;\n      if (temp) {\n        if (t == 0 && temp != m[ny][nx]) return d[y][x] = INF - 1;\n        if (t != 0 && temp != t) return d[y][x] = INF - 1;\n      } else {\n        if (t == 0) temp = m[ny][nx];\n        else temp = t;\n      }\n    }\n  }\n  return d[y][x] = temp;\n}\n\nint main() {\n  scanf(\"%d%d\", &h, &w);\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) scanf(\"%d\", &m[i][j]);\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) d[i][j] = INF;\n  int ans = 0;\n  for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) if (check(i, j) == INF - 1) ans++;\n  printf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\nint mp[1000][1000];\nPA ku[1000001];\nint main(){\n  int h,w,ans=0;\n  int one[1000001]={};\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mp[i][j];\n      ku[ mp[i][j] ] = PA(i,j);\n    }\n  }\n  int x,y,dy[4] = {1,-1,0,0};\n  int dx[4] = {0,0,1,-1};\n  for(int i=1;i<=h*w;i++){\n    for(int j=0;j<4;j++){\n      y = ku[i].first + dy[j];\n      x = ku[i].second + dx[j];\n      if(x<0||y<0||x>=w||y>=h||mp[ku[i].first][ku[i].second]>mp[y][x]||one[ mp[y][x]] == -1) continue;\n      if(one[ mp[y][x] ] == 0){\n\tif(one[ mp[ku[i].first][ku[i].second]] == 0) one[ mp[y][x]] = i;\n\telse one[ mp[y][x] ] = one[mp[ku[i].first][ku[i].second]];\n      }\n      else if(one[ mp[y][x]] != one[ mp[ku[i].first][ku[i].second]]){\n\tans++;\n\tone[ mp[y][x]] = -1;\n      }\n    }\n  }\n  cout << ans << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dx[9]={0,-1,0,1},dy[9]={-1,0,1,0},hw[1000][1000],cnt,x,y,h,w,fcnt,f[1000][1000];\nvoid func(int y,int x){\n\tint i,xx,yy,flg;\n\tflg=0;\n\tfor(i=0;i<4;i++){\n\t\txx=x+dx[i]; yy=y+dy[i];\n\t\tif(xx<w&&yy<h&&xx>=0&&yy>=0){\n\t\t\tif(hw[yy][xx]<hw[y][x]){\n\t\t\t\tflg=1;\n\t\t\t\tfunc(yy,xx);\n\t\t\t}\n\t\t}\n\t}\n\tif(flg==0&&f[y][x]!=1){\n\t\tf[y][x]=1;\n\t\tfcnt++;\n\t}\n}\nint main(void){\n\tint i,j,ii,jj;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++) scanf(\"%d\",&hw[i][j]);\n\t}\n\tcnt=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tfcnt=0;\n\t\t\tfor(ii=0;ii<h;ii++){\n\t\t\t\tfor(jj=0;jj<w;jj++) f[ii][jj]=0;\n\t\t\t}\n\t\t\tfunc(i,j);\n\t\t\tif(fcnt>=2)\tcnt++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint kal[1005][1005];\nbool isr[1005][1005];\nint water[1005][1005];\ntypedef pair<int,pair<int,int> > P;\ntypedef pair<int,int> p;\npriority_queue<P,vector<P>,greater<P> > Q;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nsigned main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>kal[i][j];\n\t\t\tisr[i][j]=false;\n\t\t\tQ.push(P(kal[i][j],p(i,j)));\n\t\t\t}\n\t\t}\t\n\t\t\n\twhile(Q.size()){\n\t\tP a=Q.top();\n\t\tQ.pop();\n\t\tint I=a.second.first,J=a.second.second;\n\t\tint N=a.first;\n\t\t\n\t\tint k=0,s=0,flg=0;\n\t\tset<int>S;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=I+dx[i]&&I+dx[i]<h&&0<=J+dy[i]&&J+dy[i]<w){\n\t\t\t\tk++;\n\t\t\t\tif(kal[I+dx[i]][J+dy[i]]>N){\n\t\t\t\t\ts++;\n\t\t\t\t\t}\n\t\t\t\telse if(isr[I+dx[i]][J+dy[i]]){\n\t\t\t\t\tflg++;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(water[I+dx[i]][J+dy[i]]!=0)S.insert(water[I+dx[i]][J+dy[i]]);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\tif(flg)isr[I][J]=true;\n\t\telse if(s==k)water[I][J]=N;\n\t\telse if(S.size()==1)water[I][J]=N;\n\t\telse isr[I][J]=true;\t\n\t\t}\t\n\tint ans=0;\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)ans+=isr[i][j];\n\tcout<<ans<<endl;\t\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H, W;\nint h[1000][1000];\nint memo[1000][1000];\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint dfs(int x, int y) {\n\tif (memo[x][y]) return memo[x][y] - 1;\n\tint res = x * W + y;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && h[tx][ty] < h[x][y]) {\n\t\t\tauto p = dfs(tx, ty);\n\t\t\tif (p == -2) {\n\t\t\t\tres = -2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res == x * W + y) {\n\t\t\t\tres = p;\n\t\t\t}\n\t\t\telse if (res != p) {\n\t\t\t\tres = -2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmemo[x][y] = res + 1;\n\treturn res;\n}\n\nint main()\n{\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> h[i][j];\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tres += dfs(i, j) < 0;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint x[1005][1005], H, W;\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nint dp[1005][1005];\npair<int, int>c[1000000];\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < 1005 * 1005; i++)x[i / 1005][i % 1005] = 999999999;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t\tc[x[i][j]] = make_pair(i, j);\n\t\t}\n\t}\n\tfor (int i = 1; i <= H*W; i++) {\n\t\tint ax = c[i].first, ay = c[i].second;\n\t\tvector<int>vec; bool flag = false;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint tox = ax + dx[j], toy = ay + dy[j];\n\t\t\tif (dp[tox][toy] == 0)continue;\n\t\t\tif (dp[tox][toy] == -1)flag = true;\n\t\t\tvec.push_back(dp[tox][toy]);\n\t\t}\n\n\t\tif (flag == true)dp[ax][ay] = -1;\n\t\telse if (vec.size() == 0)dp[ax][ay] = ax * 10000 + ay;\n\t\telse {\n\t\t\tsort(vec.begin(), vec.end());\n\t\t\tbool flag2 = false;\n\t\t\tfor (int i = 1; i < vec.size(); i++) {\n\t\t\t\tif (vec[i - 1] != vec[i])flag2 = true;\n\t\t\t}\n\t\t\tif (flag2 == true)dp[ax][ay] = -1;\n\t\t\telse dp[ax][ay] = vec[0];\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (dp[i][j] == -1)cnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\nll solve(){\n    ll res = 0;\n    ll H,W; cin >> H >> W;\n    vector<vector<ll>> M(H+2,vector<ll>(W+2,LINF));\n    vector<pll> Section(H*W);\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            ll x; cin >> x; x--;\n            M[i][j] = x;\n            Section[x] = {i,j};\n        }\n    }\n    \n    vector<vector<ll>> flag(H+2,vector<ll>(W+2,-1));\n    int id = 0;\n    int d[4] = {1,0,-1,0};\n    for(int i = 0; i < H*W;i++){\n        ll x,y; tie(x,y) = Section[i];\n        \n        vector<ll> F;\n        for(int k = 0; k < 4;k++){\n            ll nx = x + d[k];\n            ll ny = y + d[k^1];\n            if(M[nx][ny] < M[x][y]){\n                if(flag[nx][ny] == INF){\n                    F.push_back(INF); F.push_back(INF+1);\n                }else{\n                    F.push_back(flag[nx][ny]);\n                }\n            }\n        }\n        sort(F.begin(),F.end());\n        F.erase(unique(F.begin(),F.end()),F.end());\n        if(F.empty()){\n            flag[x][y] = id++;\n        }else if(F.size() == 1){\n            flag[x][y] = F[0];\n        }else{\n            flag[x][y] = INF;\n            res++;\n        }\n\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\n\nint h, w;\nint m[1000][1000];\nint mem[1000][1000];\n\nint type(int i, int j){\n  rep(k, 4){\n    int p = i + dx[k];\n    int q = j + dy[k];\n    if(0 <= p && p < h && 0 <= q && q < w && m[p][q] < m[i][j]){\n      int t = mem[p][q];\n      if(t == 0 || (mem[i][j] != -1 && mem[i][j] != t)){\n        return mem[i][j] = 0;\n      }\n      mem[i][j] = t;\n    }\n  }\n  return mem[i][j] != -1 ? mem[i][j] : mem[i][j] = m[i][j];\n}\n\nint main(){\n  scanf(\"%d%d\", &h, &w);\n  rep(i, h){\n    rep(j, w){\n      scanf(\"%d\", &m[i][j]);\n    }\n  }\n  rep(i, h){\n    fill_n(mem[i], w, -1);\n  }\n  vector<PP> v;\n  rep(i, h){\n    rep(j, w){\n      v.push_back(PP(m[i][j], P(i, j)));\n    }\n  }\n  sort(v.begin(), v.end());\n  int ans = 0;\n  for(vector<PP>::iterator it = v.begin(); it != v.end(); ++it){\n    ans += type(it->second.first, it->second.second) == 0;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],m1[1001][1001],qw,a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  if(qw>=2)return 1;\n  if(m1[y][x]>0)return 0;\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n    if(qw>=2)return 1;\n  }if(qw>=2)return 1;\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    qw++;\n    return 1;\n  }\n  m1[y][x]++;\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    qw=0;m1[i][j]=-1;\n    sum+=dfs(j,i);qw=0;\n    L:\n    if(qw){\nqw=0;\nsum++;\n    };\n    rep(z,a)rep(h,b)m1[z][h]=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\nusing namespace std;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nint h,w,res = 0,pos = 0;\nint field[1000][1000];\nset<int> cnt[1000][1000];\n\nvoid dfs(int x,int y){\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] > field[x][y]){\n\t\t\tif(!cnt[nx][ny].count(pos)) cnt[nx][ny].insert(pos);\n\t\t\tif(cnt[nx][ny].size() < 3) dfs(nx,ny);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) scanf(\"%d\",&field[i][j]);\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] < field[i][j]) flag = false;\n\t\t\t}\n\t\t\tif(flag) dfs(i,j);\n\t\t\tpos++;\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) if(cnt[i][j].size() >= 2) res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint mp[1010][1010];\nint X[1000010];\nint Y[1000010];\nint F[1000010];\nint dx[4]={0, 1, 0, -1};\nint dy[4]={1, 0, -1, 0};\nint main(){\n    int h, w;\n    cin>>h>>w;\n    for(int y=1;y<=h;y++){\n        for(int x=1;x<=w;x++){\n            cin>>mp[y][x];\n            X[mp[y][x]] = x;\n            Y[mp[y][x]] = y;\n        }\n    }\n    int ans = 0;\n    for(int i=1;i<=h*w;i++){\n        F[i] = i;\n        int tmp = 0;\n        for(int j=0;j<4;j++){\n            int k = mp[Y[i]+dy[j]][X[i]+dx[j]];\n            if(k==0 || k > mp[Y[i]][X[i]])continue;\n            if(F[k]<0){\n                F[i]=-1;\n                break;\n            }\n            if(F[i] == i)F[i] = F[k];\n            else if(F[i] != F[k]){\n                F[i] = -1;\n                break;\n            }\n        }\n        if(F[i]<0)ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\nint mp[1000][1000];\nPA ku[1000001];\nint main(){\n  int h,w,ans=0;\n  int one[1000001]={};\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mp[i][j];\n      ku[ mp[i][j] ] = PA(i,j);\n    }\n  }\n  int x,y,dy[4] = {1,-1,0,0};\n  int dx[4] = {0,0,1,-1};\n  for(int i=1;i<=h*w;i++){\n    for(int j=0;j<4;j++){\n      y = ku[i].first + dy[j];\n      x = ku[i].second + dx[j];\n      if(x<0||y<0||x>=w||y>=h||mp[ku[i].first][ku[i].second]>mp[y][x]||one[ mp[y][x]] == -1) continue;\n      if(one[ mp[y][x] ] == 0){\n\tif(one[ mp[ku[i].first][ku[i].second]] == 0) one[ mp[y][x]] = i;\n\telse one[ mp[y][x] ] = one[mp[ku[i].first][ku[i].second]];\n      }\n      else if(one[ mp[y][x]] != one[ mp[ku[i].first][ku[i].second]]){\n\tone[ mp[y][x]] = -1;\n      }\n    }\n  }\n   for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(one[mp[i][j]] == -1) ans++;\n    }\n  }\n  cout << ans << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint kal[1005][1005];\nbool isr[1005][1005];\nint water[1005][1005];\ntypedef pair<int,pair<int,int> > P;\ntypedef pair<int,int> p;\npriority_queue<P,vector<P>,greater<P> > Q;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nsigned main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>kal[i][j];\n\t\t\tisr[i][j]=false;\n\t\t\tQ.push(P(kal[i][j],p(i,j)));\n\t\t\t}\n\t\t}\t\n\t\t\n\twhile(Q.size()){\n\t\tP a=Q.top();\n\t\tQ.pop();\n\t\tint I=a.second.first,J=a.second.second;\n\t\tint N=a.first;\n\t\t\n\t\tint k=0,s=0,flg=0;\n\t\tset<int>S;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=I+dx[i]&&I+dx[i]<h&&0<=J+dy[i]&&J+dy[i]<w){\n\t\t\t\tk++;\n\t\t\t\tif(kal[I+dx[i]][J+dy[i]]>N){\n\t\t\t\t\ts++;\n\t\t\t\t\t}\n\t\t\t\telse if(isr[I+dx[i]][J+dy[i]]){\n\t\t\t\t\tflg++;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tS.insert(water[I+dx[i]][J+dy[i]]);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\tif(flg)isr[I][J]=true;\n\t\telse if(s==k)water[I][J]=N;\n\t\telse if(S.size()==1){\n\t\t\tauto itr=S.begin();\n\t\t\twater[I][J]=*itr;\n\t\t}\n\t\telse isr[I][J]=true;\t\n\t\t}\t\n\tint ans=0;\n\tfor(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)ans+=isr[i][j];\n\tcout<<ans<<endl;\t\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\nint mp[1000][1000];\nPA ku[1000001];\nint main(){\n  int h,w,mp[1000][1000],ans=0;\n  int one[1000001]={};\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mp[i][j];\n      ku[ mp[i][j] ] = PA(i,j);\n    }\n  }\n  int x,y,dy[4] = {1,-1,0,0};\n  int dx[4] = {0,0,1,-1};\n  for(int i=1;i<=h*w;i++){\n    for(int j=0;j<4;j++){\n      y = ku[i].first + dy[j];\n      x = ku[i].second + dx[j];\n      if(x<0||y<0||x>=w||y>=h||mp[ku[i].first][ku[i].second]>mp[y][x]) continue;\n      if(one[ mp[y][x] ] == 0){\n\tif(one[ mp[ku[i].first][ku[i].second]] == 0) one[ mp[y][x]] = i;\n\telse one[ mp[y][x] ] = one[mp[ku[i].first][ku[i].second]];\n      }\n      else if(one[mp[ ku[i].first][ ku[i].second]] == -1){\n\tif(one[ mp[y][x]] != -1) ans++;\n\tone[ mp[y][x] ] = -1;\n      }else if(one[ mp[y][x]] != one[ mp[ku[i].first][ku[i].second]]){\n\tif(one[ mp[y][x]] != -1) ans++;\n\tone[ mp[y][x]] = -1;\n      }\n    }\n  }\n  cout << ans << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nusing pi = pair<int,int>;\n\nconst int N=1000;\nconst int INF=INT_MAX/3;\nint f[N][N];\nint s[N][N];\npi pos[N*N];\n\nint main()\n{\n    int h,w;\n    scanf(\" %d %d\", &h, &w);\n    rep(i,h)rep(j,w)\n    {\n        scanf(\" %d\", &f[i][j]);\n        --f[i][j];\n        pos[f[i][j]] = pi(i,j);\n    }\n\n    #define IN(x,y) (0<=x && x<w && 0<=y && y<h)\n    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\n    memset(s,-1,sizeof(s));\n    rep(i,h*w)\n    {\n        int x=pos[i].se, y=pos[i].fi;\n\n        int low=0;\n        rep(d,4)\n        {\n            int nx=x+dx[d], ny=y+dy[d];\n            if(!IN(nx,ny)) continue;\n            low += (i>f[ny][nx]);\n        }\n        if(low==0) s[y][x]=i;\n\n        rep(d,4)\n        {\n            int nx=x+dx[d], ny=y+dy[d];\n            if(!IN(nx,ny)) continue;\n\n            if(i<f[ny][nx])\n            {\n                if(s[ny][nx]==-1) s[ny][nx] = s[y][x];\n                else\n                {\n                    if(s[ny][nx] != s[y][x]) s[ny][nx] = INF;\n                }\n            }\n        }\n    }\n\n    int ans=0;\n    rep(i,h)rep(j,w) ans+=(s[i][j]==INF);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int INF = 1e9;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = { 1, -1, 0, 0 };\n\nstruct point\n{\n\tint x, y;\n\tpoint() {}\n\tpoint(int x, int y) :x(x), y(y) {}\n};\n\nint H, W;\nvector< vector<int> > m;\nvector<point> p;\nint dp[1005][1005] = {};\nint main() {\n\tcin >> H >> W;\n\tm = vector<vector<int>>(H+2, vector<int>(W+2, INF));\n\tp = vector<point>(H*W+1);\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> m[i][j];\n\t\t\tp[m[i][j]] = point(i, j);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tbool ok = true;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\tif (m[i][j] > m[nx][ny]) {\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) dp[i][j] = m[i][j];\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= H*W; i++) {\n\t\tint x = p[i].x, y = p[i].y;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\t\tif (m[x][y] > m[nx][ny]) {\n\t\t\t\tif(dp[x][y] == 0) dp[x][y] = dp[nx][ny];\n\t\t\t\telse if (dp[x][y] != dp[nx][ny]) dp[x][y] = -1;\n\t\t\t}\n\t\t}\n\t\tif (dp[x][y] == -1) ans++;\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\nconstexpr int INF = 1 << 29;\nconstexpr int MOD = 1000000007;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nconstexpr int dx[4] = {1, 0, -1, 0};\nconstexpr int dy[4] = {0, 1, 0, -1};\n\nstruct Point {\n\tint h;\n\tint x, y;\n\tbool operator>(const Point &rhs) const {\n\t\treturn h > rhs.h;\n\t}\n};\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> M(H, vector<int>(W));\n\t\n\tpriority_queue<Point, vector<Point>, greater<Point>> Q;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> M[i][j];\n\t\t\tQ.push((Point){M[i][j], j, i});\n\t\t}\n\t}\n\n\tvector<vector<int>> type(H, vector<int>(W, 0));\n\tvector<vector<pii>> dst(H, vector<pii>(W));\n\tint ans = 0;\n\twhile(!Q.empty()) {\n\t\tPoint p = Q.top(); Q.pop();\n\t\tint cnt = 0;\n\t\tint tempx, tempy;\n\t\tset<pii> dests;\n\t\tbool found_type2 = false;\n\t\tfor(int k = 0; k < 4; k++) {\n\t\t\tint tx = p.x + dx[k];\n\t\t\tint ty = p.y + dy[k];\n\t\t\tif (tx < 0 || tx >= W || ty < 0 || ty >= H) continue;\n\t\t\tif (type[ty][tx] == 1) {\n\t\t\t\tcnt++;\n\t\t\t\ttempx = tx, tempy = ty;\n\t\t\t\tdests.insert(dst[ty][tx]);\n\t\t\t} else if (type[ty][tx] == 2) {\n\t\t\t\tfound_type2 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt == 0) {\n\t\t\tdst[p.y][p.x] = mp(p.x, p.y);\n\t\t} else if (cnt == 1) {\n\t\t\tdst[p.y][p.x] = mp(tempx, tempy);\n\t\t}\n\n\t\tif (found_type2 || (cnt >= 2 && dests.size() != 1)) {\n\t\t\ttype[p.y][p.x] = 2;\n\t\t\tans++;\n\t\t} else {\n\t\t\ttype[p.y][p.x] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcout << type[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n\nusing pii = pair<int, int>;\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, -1, 0, 1};\n\nint H, W;\n\nint M[1005][1005];\nint cnt[1005][1005];\nint visit[1005][1005];\n\nint main()\n{\n    cin >> H >> W;\n\n    rep(i, H) rep(j, W) {\n        cin >> M[i][j];\n    }\n\n    vector<pii> last;\n\n    rep(i, H) rep(j, W) {\n        bool f = true;\n\n        rep(k, 4) {\n            int ny = i + dy[k], nx = j + dx[k];\n\n            if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n\n            if (M[i][j] > M[ny][nx]) f = false;\n        }\n\n        if (f) {\n            last.push_back(pii(i, j));\n        }\n    }\n\n    int visit_count = 0;\n\n    for (pii &p : last) {\n        visit_count += 1;\n\n        queue<pii> q;\n\n        rep(i, 4) {\n            int y = p.fst + dy[i], x = p.scd + dx[i];\n\n            if (y < 0 || y >= H || x < 0 || x >= W) continue;\n\n            if (M[p.fst][p.scd] < M[y][x]) {\n                q.push(pii(y, x));\n            }\n        }\n\n        while (q.size()) {\n            pii p = q.front(); q.pop();\n\n            if (visit[p.fst][p.scd] == visit_count) continue;\n            visit[p.fst][p.scd] = visit_count;\n            cnt[p.fst][p.scd] += 1;\n\n            rep(i, 4) {\n                int ny = p.fst + dy[i], nx = p.scd + dx[i];\n\n                if (ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n\n                if (M[p.fst][p.scd] < M[ny][nx]) {\n                    if (cnt[ny][nx] == 2) continue;\n                    q.push(pii(ny, nx));\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n\n    rep(i, H) {\n        rep(j, W) {\n            if (cnt[i][j] >= 2) {\n                //cout << \"v: \" << M[i][j] << endl;\n                ans++;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nint H,W;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint memo[1000][1000],table[1000][1000];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvector<Info> recursive(int row,int col,int depth){\n\n\tvector<Info> sum,catcher,ret;\n\n\tint adj_row,adj_col;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = row + diff_row[i];\n\t\tadj_col = col + diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] > table[row][col])continue;\n\n\t\tcatcher = recursive(adj_row,adj_col,depth+1);\n\n\t\tfor(int k = 0; k < catcher.size(); k++){\n\t\t\tsum.push_back(catcher[k]);\n\t\t}\n\t\tcatcher.clear();\n\t}\n\n\tif(sum.size() == 0){\n\t\tmemo[row][col] = 0;\n\t\tif(depth > 0){\n\t\t\tsum.push_back(Info(row,col));\n\t\t}\n\t\treturn sum;\n\t}\n\n\tsort(sum.begin(),sum.end());\n\n\tint pre_row = sum[0].row,pre_col = sum[0].col;\n\tret.push_back(sum[0]);\n\n\tfor(int i = 1; i < sum.size(); i++){\n\t\tif(sum[i].row != pre_row || sum[i].col != pre_col){\n\t\t\tret.push_back(sum[i]);\n\t\t}\n\t\tpre_row = sum[i].row;\n\t\tpre_col = sum[i].col;\n\t}\n\n\tmemo[row][col] = ret.size();\n\n\treturn ret;\n\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&table[row][col]);\n\t\t\tmemo[row][col] = -1;\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(memo[row][col] == -1){\n\t\t\t\trecursive(row,col,0);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(memo[row][col] > 1){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[99][99],d[99][99],yy,xx,p,flag;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nset<pair<int,int> >se;\nvoid bfs(){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(p,mk(yy,xx)));\n  d[yy][xx]=p;\n  while(!q.empty()){\n    pair<int,pair<int,int> > g=q.front();q.pop();\n    int ya=g.s.f,xa=g.s.s,dd=g.f;\n    r(i,4){\n      int y=ya+dy[i],x=xa+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd){\n        if(d[y][x]&&d[y][x]!=p)se.insert(mk(y,x));\n        d[y][x]=p;\n        q.push(mk(a[y][x],mk(y,x)));\n      }\n    }\n  }\n}\nmain(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    bfs();\n  }\n  cout<<se.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct zahyou{\n  int hyoukou;\n  int x;\n  int y;\n};\n\nstruct motoz{\n  int hyoukou;\n  int point;\n  int ok;\n};\n\nclass LessHyoukou{\npublic:\n  bool operator()(const struct zahyou & riLeft, const struct zahyou & riRight) const{\n    return riLeft.hyoukou < riRight.hyoukou;\n  };\n};\n\nstruct zahyou z[1000000];\nstruct motoz zz[1002][1002];\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n  for(int i=0;i<1002;i++){\n    for(int j=0;j<1002;j++){\n      zz[i][j].hyoukou=10000000;\n      zz[i][j].point = 0;\n      zz[i][j].ok=0;\n    }\n  }\n  int m;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> m;\n      z[i*w+j].hyoukou = m;\n      z[i*w+j].x = j+1;\n      z[i*w+j].y = i+1;\n      zz[j+1][i+1].hyoukou = m;\n    }\n  }\n\n  sort(z,z+h*w,LessHyoukou());\n\n  int ans = 0;\n  int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\n  int isHekomi;\n  for(int i=0;i<h*w;i++){\n    isHekomi=1;\n    for(int j=0;j<4;j++){\n      if(z[i].hyoukou>zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].hyoukou)\n        isHekomi=0;\n    }\n    if(isHekomi){\n      for(int j=0;j<4;j++){\n        if(zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point*(zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point!=z[i].hyoukou)){\n          zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].ok=1;\n        }else{\n          zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point=z[i].hyoukou;\n        }\n      }\n    }else if(zz[z[i].x][z[i].y].ok){\n      for(int j=0;j<4;j++){\n          zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].ok=1;\n      }\n    }else{\n      for(int j=0;j<4;j++){\n        if(z[i].hyoukou<zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].hyoukou)\n          if(zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point*(zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point!=zz[z[i].x][z[i].y].point)){\n            zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].ok=1;\n          }else{\n            zz[z[i].x+vect[j][0]][z[i].y+vect[j][1]].point=zz[z[i].x][z[i].y].point;\n          }\n      }\n    }\n    if( zz[z[i].x][z[i].y].ok ){\n      ans++;\n    }\n  }\n\n  cout << ans << endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],m1[1020][1020],a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  if(m1[y][x]>0)return 0;\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    return 1;\n  }\n  m1[y][x]++;\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    m1[i][j]=-1;\n    sum+=dfs(j,i);\n    rep(z,a)rep(g,b)m1[z][g]=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main() {\n    int H,W;\n    cin >> H >> W;\n\n    vector<int> mp[H];\n    vector<P> pool;\n\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            int temp;\n            cin >> temp;\n            mp[i].push_back(temp);\n        }\n    }\n\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            if((i==0 || mp[i][j]<mp[i-1][j]) && (i==H-1 || mp[i][j]<mp[i+1][j])\n                && (j==0 || mp[i][j]<mp[i][j-1]) && (j==W-1 || mp[i][j]<mp[i][j+1])) pool.push_back(P(i,j));\n        }\n    }\n\n    queue<P> q;\n    map<P,int> check,m;\n    int dh[4]={-1,0,1,0};\n    int dw[4]={0,1,0,-1};\n    int ans=0;\n\n    for(auto x : pool) {\n        q.push(x);\n        m.clear();\n        while(!q.empty()) {\n            P p=q.front(); q.pop();\n            int h=p.first;\n            int w=p.second;\n\n            if(m[p]!=0) continue;\n            m[p]=1; ++check[p];\n            if(check[p]==2) ++ans;\n\n            for(int i=0; i<4; ++i) {\n                if(h+dh[i]>=0 && h+dh[i]<H && w+dw[i]>=0 && w+dw[i]<W \n                    && mp[h][w]<mp[h+dh[i]][w+dw[i]]) q.push(P(h+dh[i],w+dw[i]));\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nint M[1000][1000];\nint reach[1000][1000];\nint x[1000000], y[1000000];\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n\n\nint main()\n{\n  scanf(\"%d %d\", &H, &W);\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      scanf(\"%d\", &M[i][j]);\n      --M[i][j];\n      x[M[i][j]] = j;\n      y[M[i][j]] = i;\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < H * W; i++) {\n    int proc = i;\n    for(int j = 0; j < 4; j++) {\n      int nx = x[i] + vx[j], ny = y[i] + vy[j];\n      if(nx < 0 || ny < 0 || nx >= W || ny >= H) continue;\n      if(M[ny][nx] < i) {\n        if(proc == i) proc = reach[ny][nx];\n        else if(proc != reach[ny][nx]) proc = -1;\n      }\n    }\n    reach[y[i]][x[i]] = proc;\n    ret += proc == -1;\n  }\n\n  printf(\"%d\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nint h,w,res = 0,pos = 0;\nint field[1010][1010];\nint cnt[1010][1010];\nbool used[1010][1010];\nstack<P> que;\nqueue<P> visit;\n\nint main(){\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) scanf(\"%d\",&field[i][j]);\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] < field[i][j]) flag = false;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p = que.top();que.pop();\n\t\t\t\t\tint x = p.first,y = p.second;\n\t\t\t\t\tvisit.push(P(x,y));\n\t\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\t\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] > field[x][y] && !used[nx][ny]){\n\t\t\t\t\t\t\tcnt[nx][ny]++;\n\t\t\t\t\t\t\tif(cnt[nx][ny] < 3){\n\t\t\t\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!visit.empty()){\n\t\t\t\tint x = visit.front().first,y = visit.front().second;visit.pop();\n\t\t\t\tused[x][y] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) if(cnt[i][j] >= 2) res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nconst int dx[4] = { -1, 0, 0, 1 }, dy[4] = { 0, -1, 1, 0 };\nint H, W, M[1234][1234];\nvector<vector<int>> water;\nvector<set<int>> water_to;\n\nint index(int w, int h) {\n\tif (w < 0 || h < 0 || w >= W || h >= H) return -1;\n\treturn h * W + w;\n}\n\nvoid GetWaterTo(int i) {\n\tif (water_to[i].size() > 0) return;\n\tif (water[i].size() == 0) water_to[i].insert(i);\n\trep(j, water[i].size()) {\n\t\tGetWaterTo(water[i][j]);\n\t\twater_to[i].insert(water_to[water[i][j]].begin(), water_to[water[i][j]].end());\n\t}\n\treturn;\n}\n\nint main() {\n\n\tscanf(\"%d %d\", &H, &W);\n\n\twater.resize(H*W);\n\twater_to.resize(H*W);\n\n\trep(i, H) rep(j, W) scanf(\"%d\", &M[i][j]);\n\n\trep(i, H) rep(j, W) {\n\t\trep(d, 4) {\n\t\t\tif (index(j + dx[d], i + dy[d]) != -1 && M[i][j] > M[i + dy[d]][j + dx[d]]) {\n\t\t\t\twater[index(j, i)].push_back(index(j + dx[d], i + dy[d]));\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, H*W) GetWaterTo(i);\n\n\tint c = 0;\n\trep(i, H*W) if (water_to[i].size() >= 2) c++;\n\n\tprintf(\"%d\\n\", c);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dy[4]={0,-1,0,1};\nint dx[4]={-1,0,1,0};\n\nint H,W;\nint A[1000][1000];\n\nint type[1000][1000];\n\nsigned main(){\n    scanf(\"%lld%lld\",&H,&W);\n    vpint vec;\n    rep(i,H){\n        rep(j,W){\n            scanf(\"%lld\",&A[i][j]);\n            vec.pb({A[i][j],i*W+j});\n        }\n    }\n    sort(all(vec));\n    rep(i,vec.size()){\n        int h=vec[i].fi;\n        int y=vec[i].se/W,x=vec[i].se%W;\n\n        set<int>lis;\n        bool flag=false;\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(ny<0||ny>=H||nx<0||nx>=W)continue;\n            if(A[ny][nx]<h){\n                if(type[ny][nx]==-1)flag=true;\n                else lis.insert(type[ny][nx]);\n            }\n        }\n        if(flag||lis.size()>1){\n            type[y][x]=-1;\n        }\n        else if(lis.size()==1){\n            type[y][x]=*lis.begin();\n        }\n        else{\n            type[y][x]=y*W+x;\n        }\n    }\n\n    int ans=0;\n    rep(i,H)rep(j,W)if(type[i][j]==-1)ans++;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nvoid fanc(int,int,int);\nvoid lo();\nint a,s,d[1001][1001],f,g[4]={0,-1,0,1},h[4]={-1,0,1,0},z,x,c,v,q,w,e,aa,zz;\nint flg[1001][1001];\nint main(void)\n{\n\tint i,j;\n\tscanf(\"%d %d\",&a,&s);\n\tfor(i=0;i<a;i++){\n\t\tfor(j=0;j<s;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tf=0;\n\tw=-1;\n\tfor(i=0;i<a;i++){\n\t\tfor(j=0;j<s;j++){\n\t\t\tfanc(i,j,d[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f);\n\treturn 0;\n}\nvoid fanc(int z,int x,int q)\n{\n\tint i,j;\n\tif(q!=w){\n\t\tw=q;\n\t\tv=0;\n\t\te=0;\n\t\tlo();\n\t}\n\tfor(i=0;i<4;i++){\n\t\tif(z+g[i]<a&&z+g[i]>=0&&d[z+g[i]][x]<d[z][x]){\n\t\t\tif(flg[z+g[i]][x]==0)\n\t\t\t\tflg[z][x]=0;\n\t\t\t\tflg[z+g[i]][x]=1;\n\t\t\t\tfanc(z+g[i],x,w);\n\t\t}\n\t\tif(x+h[i]<s&&x+h[i]>=0&&d[z][x+h[i]]<d[z][x]){\n\t\t\tif(flg[z][x+h[i]]==0){\n\t\t\t\tflg[z][x]=0;\n\t\t\t\tflg[z][x+h[i]]=1;\n\t\t\t\tfanc(z,x+h[i],w);\n\t\t\t}\n\t\t}\n\t}\n\taa=0;\n\tzz=0;\n\tfor(i=0;i<a;i++){\n\t\tfor(j=0;j<s;j++){\n\t\t\tif(flg[i][j]==1){\n\t\t\t\tif(i!=a-1) if(d[i][j]>d[i+1][j]) zz=1;\n\t\t\t\tif(j!=s-1) if(d[i][j]>d[i][j+1]) zz=1;\n\t\t\t\tif(i!=0) if(d[i][j]>d[i-1][j]) zz=1;\n\t\t\t\tif(j!=0) if(d[i][j]>d[i][j-1]) zz=1;\n\t\t\t\tif(zz==0){\n\t\t\t\t\tflg[i][j]=2;\n\t\t\t//\t\tprintf(\"%d %d\\n\",w,d[i][j]);\n\t\t\t\t\tv++;\n\t\t\t\t\taa=1;\n\t\t\t\t}\n\t\t\t\telse flg[i][j]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(aa==1) break;\n\t}\n\tif(v>=2&&e==0){\n\t\tf++;\n\t\te=1;\n\t//\tprintf(\"%d\\n\",w);\n\t}\n}\nvoid lo(){\n\tint i,j;\n\tfor(i=0;i<a;i++){\n\t\tfor(j=0;j<s;j++) flg[i][j]=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h,w; \nint field[1005][1005];\nint mh[1005][1005];\nint mw[1005][1005];\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nP search(int a, int b){\n\tif(mh[a][b] != -1){\n\t\treturn P(mh[a][b],mw[a][b]);\n\t}\t\n\n\tP tmp = P(-1,-1);\n\tint cnt = 0;\n\tfor (int i = 0;i < 4;i++){\n\t\tint na = a+dy[i], nb = b+dx[i];\n\t\tif(na<0 || nb<0 || na>=h || nb>= w || field[a][b] < field[na][nb]) continue;\n\t\tP tmp2 = search(na,nb);\n\t\tif(tmp2 == P(-2,-2)){\n\t\t\tmh[a][b] = -2;\n\t\t\tmw[a][b] = -2;\n\t\t\treturn P(-2,-2);\n\t\t}\n\t\tif(tmp != tmp2) cnt++;\n\t\tif(cnt == 2){\n\t\t\tmh[a][b] = -2;\n\t\t\tmw[a][b] = -2;\n\t\t\treturn P(-2,-2);\n\t\t}\n\t\ttmp = tmp2;\n\t}\n\tif(tmp == P(-1,-1)){\n\t\tmh[a][b] = a;\n\t\tmw[a][b] = b;\n\t\treturn P(a,b);\n\t}\n\tmh[a][b] = tmp.first;\n   \tmw[a][b] = tmp.second;\n\treturn tmp;\t\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> h >> w;\n\n\tfor (int i = 0;i < h;i++){\n\t\tfor (int j = 0;j < w;j++){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\n\tmemset(mh,-1,sizeof(mh));\n\tmemset(mw,-1,sizeof(mw));\n\n\tint ans = 0;\n\n\tfor (int i = 0;i < h;i++){\n\t\tfor (int j = 0;j < w;j++){\n\t\t\tif(search(i,j) == P(-2,-2)) ans++;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// JOI2017年予選５　尾根\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0634\n#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n    int H,W;\n    cin >> H >>W;\n    int map[H+2][W+2];\n    int onecheck[H+2][W+2];\n    for(int i=0;i<H+2;i++){\n        for(int j=0;j<W+2;j++){\n            map[i][j]=H*W+1;\n            onecheck[i][j]=0;\n        }\n    }\n    for(int i=1;i<H+1;i++){\n        for(int j=1;j<W+1;j++){\n            cin >> map[i][j];\n        }\n    }\n    // 水たまりを探す\n    vector<pair<int,int> > mizutamari;\n    for(int i=1;i<H+1;i++){\n        for(int j=1;j<W+1;j++){\n            if(map[i][j]<map[i+1][j] && map[i][j]<map[i-1][j] && map[i][j]<map[i][j+1] && map[i][j]<map[i][j-1])mizutamari.push_back(make_pair(i,j));\n        }\n    }\n    \n    for(int k=0;k<mizutamari.size();k++){\n        queue<pair<int, int> >q;// キュー q を定義\n        q.push(make_pair(mizutamari[k].first,mizutamari[k].second));//スタート地点をqにプッシュ\n        int step[H+2][W+2];\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                step[i][j]=0;\n            }\n        }\n        while(q.empty()==false){// q が空になるまでループを回す\n            pair<int, int> point=q.front();\n            q.pop();\n            int i=point.first;\n            int j=point.second;\n            if(map[i][j]<map[i+1][j] && step[i+1][j]==0 && onecheck[i+1][j]<2){step[i+1][j]=1;onecheck[i+1][j]++;q.push(make_pair(i+1,j));}\n            if(map[i][j]<map[i-1][j] && step[i-1][j]==0 && onecheck[i-1][j]<2){step[i-1][j]=1;onecheck[i-1][j]++;q.push(make_pair(i-1,j));}\n            if(map[i][j]<map[i][j+1] && step[i][j+1]==0 && onecheck[i][j+1]<2){step[i][j+1]=1;onecheck[i][j+1]++;q.push(make_pair(i,j+1));}\n            if(map[i][j]<map[i][j-1] && step[i][j-1]==0 && onecheck[i][j-1]<2){step[i][j-1]=1;onecheck[i][j-1]++;q.push(make_pair(i,j-1));}\n        }\n    }\n\n    int count=0;\n    for(int i=1;i<H+1;i++){\n        for(int j=1;j<W+1;j++){\n            if(onecheck[i][j]>1)count++;\n        }\n    }\n\n\n    cout << count << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\n//-----------------------------------------------------------------------------\n\nint h,w;\nint fld[1000][1000];\npriority_queue<PP,vector<PP>,greater<PP> > pq;\nint cnt[1000][1000];\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nvoid bfs(P p) {\n\tqueue<P> q;\n\tq.push(p);\n\tbool reach[1000][1000]={};\n\twhile(!q.empty()) {\n\t\tP p=q.front();q.pop();\n\t\tint x=p.fi,y=p.se;\n\t\tREP(i,4) {\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||reach[ny][nx]||fld[ny][nx]<fld[y][x]) continue;\n\t\t\treach[ny][nx]=true;\n\t\t\tcnt[ny][nx]++;\n\t\t\tq.push(P(nx,ny));\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>h>>w;\n\tREP(i,h) {\n\t\tREP(j,w) {\n\t\t\tcin>>fld[i][j];\n\t\t\tpq.push(PP(fld[i][j],P(j,i)));\n\t\t}\n\t}\n\twhile(!pq.empty()) {\n\t\tPP p=pq.top();pq.pop();\n\t\tif(cnt[p.se.se][p.se.fi]!=0) continue;\n\t\tbfs(p.se);\n\t}\n\tint ans=0;\n\tREP(i,h) REP(j,w) if(cnt[i][j]>=2) ans++;\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <unordered_set>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\nstatic const int INF = 1000010000;\nstatic const int NIL = -1;\nstatic const int MOD = 1000000007;\n \n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define SORT(v) sort(v.begin(), v.end());\n#define pb push_back\n#define mp make_pair\n#define np next_permutation\n#define pq priority_queue\n \nint gcd(int a, int b) { int c; while (b != 0) { c = a%b; a = b; b = c; }return a; }\nint lcm(int a, int b) { int c = gcd(a, b); a /= c; return a*b; }\nint nCr(int a, int b) { int i, r = 1; for (i = 1; i <= b; i++) { r *= (a + 1 - i); r /= i; }return r; }\nint pow(int a, int b) { int i, r = 1; for (i = 1; i <= b; i++) { r *= a; }return r; }\nlong long llpow(long long a, long long b) { long long i, r = 1; for (i = 1; i <= b; i++) { r *= a; }return r; }\nlong long llgcd(long long a, long long b) { long long c; while (b != 0) { c = a%b; a = b; b = c; }return a; }\nlong long lllcm(long long a, long long b) { long long c = llgcd(a, b); a /= c; return a*b; }\nlong long llnCr(long long a, long long b) { long long i, r = 1; for (i = 1; i <= b; i++) { r *= (a + 1 - i); r /= i; }return r; }\n \nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n//int dx5[5] = {-1,0,0,0,1}, dy5[5] = {0,-1,0,1,0};\n//int dx8[8] = {-1,0,1,1,1,0,-1,-1}, dy8[8] = {1,1,1,0,-1,-1,-1,0};\n//int dx9[9] = {-1,0,1,1,1,0,-1,-1,0}, dy9[9] = {1,1,1,0,-1,-1,-1,0,0};\n\n\nint a[1010][1010];\nint h, w;\nint cnt[1010][1010];\n\nvoid bfs(int sx, int sy){\n    int flag[1010][1010];\n    memset(flag, 0, sizeof(flag));\n    queue<P> que;\n    que.push(P(sx, sy));\n    flag[sx][sy] = 1;\n    while(!que.empty()){\n        auto p = que.front(); que.pop();\n        int x = p.first; int y = p.second;\n        REP(k, 4){\n            int nx = x + dx[k]; int ny = y + dy[k];\n            if(flag[nx][ny] || nx < 0 || ny < 0 || nx >= h || ny >= w) continue;\n            if(a[nx][ny] > a[x][y]){\n                cnt[nx][ny]++;\n                que.push(P(nx, ny));\n                flag[nx][ny] = 1;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> h >> w;\n    bool f[1010][1010];    \n    REP(i, h){\n        REP(j, w){\n            cin >> a[i][j];\n        }\n    }\n    REP(i, h){\n        REP(j, w){\n            cnt[i][j] = 0;\n            if(i == 0){\n                if(j == 0){\n                    if(a[i][j] < a[i + 1][j] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }else if(j == w - 1){\n                    if(a[i][j] < a[i + 1][j] && a[i][j] < a[i][j - 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }else{\n                    if(a[i][j] < a[i + 1][j] && a[i][j] < a[i][j - 1] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }\n            }else if(i == h - 1){\n                if(j == 0){\n                    if(a[i][j] < a[i - 1][j] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }else if(j == w - 1){\n                    if(a[i][j] < a[i - 1][j] && a[i][j] < a[i][j - 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }else{\n                    if(a[i][j] < a[i - 1][j] && a[i][j] < a[i][j - 1] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }\n            }else if(j == 0){\n                if(a[i][j] < a[i + 1][j] && a[i][j] < a[i - 1][j] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                else f[i][j] = false;\n            }else if(j == w - 1){\n                if(a[i][j] < a[i + 1][j] && a[i][j] < a[i - 1][j] && a[i][j] < a[i][j - 1]) f[i][j] = true;\n                else f[i][j] = false;\n            }else{\n                if(a[i][j] < a[i + 1][j] && a[i][j] < a[i - 1][j] && a[i][j] < a[i][j - 1] && a[i][j + 1]) f[i][j] = true;\n                else f[i][j] = false;\n            }\n        }\n    }\n\n    REP(i, h) REP(j, w) if(f[i][j]) bfs(i, j);\n\n    int ans = 0;\n    REP(i, h) REP(j, w){\n        if(cnt[i][j] >= 2) ans++;\n    }\n    cout << ans << endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\ntypedef std::pair<int, int> Pair;\n\nconstexpr int MAX_HW = 1000;\nconstexpr int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint H, W;\nint field[MAX_HW][MAX_HW];\nint tmp[MAX_HW][MAX_HW];\n\nvoid bfs(int h, int w);\n\nint main(){\n\t\n\tstd::cin >> H >> W;\n\t\n\tfor(int i = 0; i < H; ++i){\n\t\tfor(int j = 0; j < W; ++j){\n\t\t\tstd::cin >> field[i][j];\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\n\tfor(int i = 0; i < H; ++i){\n\t\tfor(int j = 0; j < W; ++j){\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\tint nh = i + dx[k], nw = j + dy[k];\n\t\t\t\tif(nh < 0 || nw < 0 || nh >= H || nw >= W){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[nh][nw] < field[i][j]){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tbfs(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; ++i){\n\t\tfor(int j = 0; j < W; ++j){\n\t\t\tif(tmp[i][j] > 1){\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}\n\nvoid bfs(int h, int w){\n\tbool is_reached[MAX_HW][MAX_HW] = {};\n\tstd::queue<Pair> que;\n\tque.push(Pair(h, w));\n\n\twhile(!que.empty()){\n\t\tPair cur = que.front(); que.pop();\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint nh = cur.first + dx[i], nw = cur.second + dy[i];\n\t\t\tif(nh < 0 || nw < 0 || nh >= H || nw >= W){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(field[nh][nw] > field[cur.first][cur.second] && !is_reached[nh][nw]){\n\t\t\t\tque.push(Pair(nh, nw));\n\t\t\t\tis_reached[nh][nw] = true;\n\t\t\t\t++tmp[nh][nw];\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],qw,a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  if(qw>=2)return 1;\n  if(m1[y][x]>0)return 0;\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n    if(qw>=2)return 1;\n  }\n  if(e==y&&f==x){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c){\n    qw++;\n    return 1;\n  }\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    qw=0;e=i;f=j;\n    sum+=dfs(j,i);qw=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint inf = 1000001;\nclass mt {\npublic:\n\tint num,high;\n\tpair<int, int> use;\n\tmt() :num(0), use(pair<int, int>(-1, -1)), high(inf) {\n\n\t}\n};\nint main() {\n\tint H, W;\n\tmt **map;\n\tcin >> H >> W;\n\tmap = new mt*[W + 2];\n\tfor (int i = 0; i < W + 2; ++i) {\n\t\tmap[i] = new mt[H + 2];\n\t}\n\tint dummy;\n\tfor (int y = 1; y <= H; ++y) {\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tcin >> dummy;\n\t\t\tmap[x][y].high = dummy;\n\t\t}\n\t}\n\tint movex[]{ 1,0,-1,0 }, movey[]{ 0,1,0,-1 };\n\tfor (int y = 1; y <= H; ++y) {\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (map[x + movex[i]][y + movey[i]].high > map[x][y].high) {\n\t\t\t\t\t++num;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num == 4) {\n\t\t\t\tpair<int, int> point = pair<int, int>(x, y);\n\t\t\t\tqueue<pair<int, int> > que;\n\t\t\t\tque.push(pair<int, int>(x, y));\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\tpair<int, int>  stock = que.front(); que.pop();\n\t\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\t\tif (map[stock.first + movex[i]][stock.second + movey[i]].high != inf&&map[stock.first + movex[i]][stock.second + movey[i]].high > map[stock.first][stock.second].high&&map[stock.first + movex[i]][stock.second + movey[i]].use != point&&++map[stock.first + movex[i]][stock.second + movey[i]].num < 3) {\n\t\t\t\t\t\t\tque.push(pair<int, int>(stock.first + movex[i], stock.second + movey[i]));\n\t\t\t\t\t\t\tmap[stock.first + movex[i]][stock.second + movey[i]].use = point;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tfor (int y = 1; y <= H; ++y) {\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tif (map[x][y].num >= 2) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nconst int dx[4] = { -1, 0, 0, 1 }, dy[4] = { 0, -1, 1, 0 };\nint H, W, M[1234][1234];\nvector<vector<int>> water;\nvector<set<int>> water_to;\nvector<bool> isOne;\n\nint index(int w, int h) {\n\tif (w < 0 || h < 0 || w >= W || h >= H) return -1;\n\treturn h * W + w;\n}\n\nvoid GetWaterTo(int i) {\n\tif (water_to[i].size() > 0 || isOne[i]) return;\n\tif (water[i].size() == 0) water_to[i].insert(i);\n\trep(j, water[i].size()) {\n\t\tGetWaterTo(water[i][j]);\n\t\tif (isOne[water[i][j]] || water_to[water[i][j]].size() >= 2) {\n\t\t\tisOne[i] = true;\n\t\t\tbreak;\n\t\t}\n\t\twater_to[i].insert(water_to[water[i][j]].begin(), water_to[water[i][j]].end());\n\t}\n\treturn;\n}\n\nint main() {\n\n\tscanf(\"%d %d\", &H, &W);\n\n\twater.resize(H*W);\n\twater_to.resize(H*W);\n\tisOne.resize(H*W, false);\n\n\tvector<pair<int, int>> order;\n\n\tint IndexCount = 0;\n\trep(i, H) rep(j, W) {\n\t\tscanf(\"%d\", &M[i][j]);\n\t\torder.push_back(make_pair(M[i][j], IndexCount));\n\t\tIndexCount++;\n\t}\n\n\trep(i, H) rep(j, W) {\n\t\trep(d, 4) {\n\t\t\tif (index(j + dx[d], i + dy[d]) != -1 && M[i][j] > M[i + dy[d]][j + dx[d]]) {\n\t\t\t\twater[index(j, i)].push_back(index(j + dx[d], i + dy[d]));\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(order.begin(), order.end());\n\n\trep(i, order.size()) GetWaterTo(order[i].second);\n\t//rep(i, H*W) GetWaterTo(i);\n\n\tint c = 0;\n\trep(i, H*W) if (isOne[i] || water_to[i].size() >= 2) c++;\n\n\tprintf(\"%d\\n\", c);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap<int,set<int> > m;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint h,w;\nbool in(int y,int x){\n  return (0<=y&&y<h&&0<=x&&x<w);\n}\nint main(){ \n\n  cin>>h>>w;\n  int s[h][w];\n  priority_queue<PP> q;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>s[i][j];\n      q.push(PP(-s[i][j],P(i,j)));\n    }\n  }\n  int ans=0;\n  int ax[]={1,-1,0,0};\n  int ay[]={0,0,1,-1};\n  while(!q.empty()){\n    PP pp=q.top();q.pop();\n    P p=pp.second;\n    int t=-pp.first,y=p.first,x=p.second;\n    for(int k=0;k<4;k++){\n      if(!in(y+ay[k],x+ax[k])) continue;\n      int z=s[y+ay[k]][x+ax[k]];\n      if(z>t) continue;\n      if(m.find(z)!=m.end()){\n\tfor(set<int>::iterator it=m[z].begin();it!=m[z].end();++it)\n\tm[t].insert(*it);\n      }else m[t].insert(z);\n    }\n    if(m.find(t)!=m.end()) ans+=m[t].size()>1;\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <cstdlib>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <math.h>\n#include <random>\n#include <time.h>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    int H, W;\n    cin >> H >> W;\n    int height[1000][1000];\n    pair<int, int> sorted[1000000];\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            cin >> height[i][j];\n            height[i][j]--;\n            sorted[height[i][j]] = make_pair(i, j);\n        }\n    }\n\n    int point[1000][1000] = {};//そこから流したときに溜まる箇所がいくつあるか\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            if((i==0 || height[i-1][j] > height[i][j]) && (i==H-1 || height[i+1][j] > height[i][j])\n            && (j==0 || height[i][j-1] > height[i][j]) && (j==W-1 || height[i][j+1] > height[i][j])){\n                //ここはくぼみ\n            }\n            else continue;\n            bool already[1000][1000] = {};//全部false\n            queue<pair<int, int>> que;\n            point[i][j] = 1;\n            already[i][j] = true;\n            que.push(make_pair(i, j));\n            while(!que.empty()){\n                int i = que.front().first;\n                int j = que.front().second;\n                if(i!=0 && already[i-1][j]== false && height[i-1][j] > height[i][j]){\n                    point[i-1][j]++;\n                    already[i-1][j] = true;\n                    que.push(make_pair(i-1, j));\n                }\n                if(i!=H-1 && already[i+1][j]== false && height[i+1][j] > height[i][j]){\n                    point[i+1][j]++;\n                    already[i+1][j] = true;\n                    que.push(make_pair(i+1, j));\n                }\n                if(j!=0 && already[i][j-1]== false && height[i][j-1] > height[i][j]){\n                    point[i][j-1]++;\n                    already[i][j-1] = true;\n                    que.push(make_pair(i, j-1));\n                }\n                if(j!=W-1 && already[i][j+1]== false && height[i][j+1] > height[i][j]){\n                    point[i][j+1]++;\n                    already[i][j+1] = true;\n                    que.push(make_pair(i, j+1));\n                }\n                que.pop();\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            if(point[i][j] > 1) ans++;\n        }\n    }\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <unordered_set>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\nstatic const int INF = 1000010000;\nstatic const int NIL = -1;\nstatic const int MOD = 1000000007;\n \n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define SORT(v) sort(v.begin(), v.end());\n#define pb push_back\n#define mp make_pair\n#define np next_permutation\n#define pq priority_queue\n \nint gcd(int a, int b) { int c; while (b != 0) { c = a%b; a = b; b = c; }return a; }\nint lcm(int a, int b) { int c = gcd(a, b); a /= c; return a*b; }\nint nCr(int a, int b) { int i, r = 1; for (i = 1; i <= b; i++) { r *= (a + 1 - i); r /= i; }return r; }\nint pow(int a, int b) { int i, r = 1; for (i = 1; i <= b; i++) { r *= a; }return r; }\nlong long llpow(long long a, long long b) { long long i, r = 1; for (i = 1; i <= b; i++) { r *= a; }return r; }\nlong long llgcd(long long a, long long b) { long long c; while (b != 0) { c = a%b; a = b; b = c; }return a; }\nlong long lllcm(long long a, long long b) { long long c = llgcd(a, b); a /= c; return a*b; }\nlong long llnCr(long long a, long long b) { long long i, r = 1; for (i = 1; i <= b; i++) { r *= (a + 1 - i); r /= i; }return r; }\n \nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n//int dx5[5] = {-1,0,0,0,1}, dy5[5] = {0,-1,0,1,0};\n//int dx8[8] = {-1,0,1,1,1,0,-1,-1}, dy8[8] = {1,1,1,0,-1,-1,-1,0};\n//int dx9[9] = {-1,0,1,1,1,0,-1,-1,0}, dy9[9] = {1,1,1,0,-1,-1,-1,0,0};\n\n\nint a[1010][1010];\nint h, w;\nint cnt[1010][1010];\n\nvoid bfs(int sx, int sy){\n    int flag[1010][1010];\n    memset(flag, 0, sizeof(flag));\n    queue<P> que;\n    que.push(P(sx, sy));\n    flag[sx][sy] = 1;\n    while(!que.empty()){\n        auto p = que.front(); que.pop();\n        int x = p.first; int y = p.second;\n        REP(k, 4){\n            int nx = x + dx[k]; int ny = y + dy[k];\n            if(flag[nx][ny] || nx < 0 || ny < 0 || nx >= h || ny >= w) continue;\n            if(a[nx][ny] > a[x][y]){\n                cnt[nx][ny]++;\n                que.push(P(nx, ny));\n                flag[nx][ny] = 1;\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> h >> w;\n    bool f[1010][1010];    \n    REP(i, h){\n        REP(j, w){\n            cin >> a[i][j];\n        }\n    }\n    REP(i, h){\n        REP(j, w){\n            cnt[i][j] = 0;\n            if(i == 0){\n                if(j == 0){\n                    if(a[i][j] < a[i + 1][j] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }else if(j == w - 1){\n                    if(a[i][j] < a[i + 1][j] && a[i][j] < a[i][j - 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }else{\n                    if(a[i][j] < a[i + 1][j] && a[i][j] < a[i][j - 1] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }\n            }else if(i == h - 1){\n                if(j == 0){\n                    if(a[i][j] < a[i - 1][j] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }else if(j == w - 1){\n                    if(a[i][j] < a[i - 1][j] && a[i][j] < a[i][j - 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }else{\n                    if(a[i][j] < a[i - 1][j] && a[i][j] < a[i][j - 1] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                    else f[i][j] = false;\n                }\n            }else if(j == 0){\n                if(a[i][j] < a[i + 1][j] && a[i][j] < a[i - 1][j] && a[i][j] < a[i][j + 1]) f[i][j] = true;\n                else f[i][j] = false;\n            }else if(j == w - 1){\n                if(a[i][j] < a[i + 1][j] && a[i][j] < a[i - 1][j] && a[i][j] < a[i][j - 1]) f[i][j] = true;\n                else f[i][j] = false;\n            }else{\n                if(a[i][j] < a[i + 1][j] && a[i][j] < a[i - 1][j] && a[i][j] < a[i][j - 1] && a[i][j + 1]) f[i][j] = true;\n                else f[i][j] = false;\n            }\n        }\n    }\n\n    REP(i, h) REP(j, w) if(f[i][j]) bfs(i, j);\n\n    int ans = 0;\n    REP(i, h) REP(j, w){\n        if(cnt[i][j] >= 2) ans++;\n    }\n    cout << ans << endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst vector<vector<int>> moves{{0,  1},\n                                {0,  -1},\n                                {1,  0},\n                                {-1, 0}};\nconst int INF = 1145141919;\nint h, w;\n\nbool inRange(int x, int y) {\n    return 1 <= x && x <= h && 1 <= y && y <= w;\n}\n\nint main() {\n    cin >> h >> w;\n    vector<vector<int>> ban(h + 2, vector<int>(w + 2, INF));\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> ban[i + 1][j + 1];\n        }\n    }\n\n    vector<vector<int>> count(h + 2, vector<int>(w + 2));\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            bool isPool = true;\n            for (auto m:moves) {\n                if (ban[i][j] > ban[i + m[0]][j + m[1]]) isPool = false;\n            }\n\n            if (isPool) {\n                vector<vector<bool>> visited(h + 2, vector<bool>(w + 2));\n                visited[i][j] = true;\n                queue<vector<int>> que;\n                que.push({i, j});\n                while (!que.empty()) {\n                    auto now = que.front();\n                    que.pop();\n\n                    int x = now[0], y = now[1];\n\n                    for (auto m:moves) {\n                        int nx = x + m[0], ny = y + m[1];\n                        if (inRange(nx, ny) && !visited[nx][ny] && ban[x][y] < ban[nx][ny]) {\n                            visited[nx][ny] = true;\n                            que.push({nx, ny});\n                        }\n                    }\n                }\n\n                for (int k = 1; k <= h; k++) {\n                    for (int l = 1; l <= w; l++) {\n                        count[k][l] += visited[k][l];\n                    }\n                }\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (count[i][j] >= 2)ret++;\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint h,w;\nint mp[1001][1001];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nint used[1001][1001],mem[1001][1001];\n\nint dfs(int y,int x){\n  \n  if(used[y][x]++) return mem[y][x];\n \n  int &res=mem[y][x]=0;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||nx>=w||ny<0||ny>=h||mp[y][x]<mp[ny][nx]) continue;\n    int r=dfs(ny,nx);\n    if(r==0)r=ny*w+nx+1;\n    if(r==-1) res=-1;\n    if(r&&res&&res!=r) res=-1;\n    else if(r) res=r;\n  }\n  return res;\n}\n\ntypedef pair<int,int> P;\nP A[1001*1001];\nint main(){\n  \n  cin>>h>>w;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) cin>>mp[i][j],A[i*w+j]=P(mp[i][j],i*w+j);\n  \n  sort(A,A+h*w);\n\n  int ans=0;\n  for(int i=0;i<h*w;i++) \n    if(dfs(A[i].second/w,A[i].second%w)==-1)ans++;\n  \n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nconst int dx[4] = { -1, 0, 0, 1 }, dy[4] = { 0, -1, 1, 0 };\nint H, W, M[1234][1234];\nvector<vector<int>> water;\nvector<int> water_to;\n\nint index(int w, int h) {\n\tif (w < 0 || h < 0 || w >= W || h >= H) return -1;\n\treturn h * W + w;\n}\n\nvoid GetWaterTo(int i) {\n\tif (water_to[i] != 0) return;\n\tif (water[i].size() == 0) water_to[i] = 1;\n\trep(j, water[i].size()) {\n\t\tGetWaterTo(water[i][j]);\n\t\twater_to[i] += water_to[water[i][j]];\n\t}\n\twater_to[i] = min(2, water_to[i]);\n\n\treturn;\n}\n\nint main() {\n\n\tscanf(\"%d %d\", &H, &W);\n\n\twater.resize(H*W);\n\twater_to.resize(H*W, 0);\n\n\tvector<pair<int, int>> order;\n\n\tint IndexCount = 0;\n\trep(i, H) rep(j, W) {\n\t\tscanf(\"%d\", &M[i][j]);\n\t\torder.push_back(make_pair(M[i][j], IndexCount));\n\t\tIndexCount++;\n\t}\n\n\trep(i, H) rep(j, W) {\n\t\trep(d, 4) {\n\t\t\tif (index(j + dx[d], i + dy[d]) != -1 && M[i][j] > M[i + dy[d]][j + dx[d]]) {\n\t\t\t\twater[index(j, i)].push_back(index(j + dx[d], i + dy[d]));\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(order.begin(), order.end());\n\n\trep(i, order.size()) GetWaterTo(order[i].second);\n\t//rep(i, H*W) GetWaterTo(i);\n\n\tint c = 0;\n\trep(i, H*W) if (water_to[i] == 2) c++;\n\n\tprintf(\"%d\\n\", c);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nint HMap[1002][1002],RMap[1002][1002] = { 0 };\nint H, W;\nint OneNum = 0;\n\nint main() {\n\tcin >> H >> W;\n\tvector<int> SH(H*W), SW(H*W);\n\n\t//??\\??????\n\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\tint temp;\n\t\tcin >> temp;\n\t\tHMap[i + 1][j + 1] = temp;\n\t\tSH[temp - 1] = i + 1;\n\t\tSW[temp - 1] = j + 1;\n\t\tRMap[i + 1][j + 1] = -1;\n\t}\n\tfor (int i = 0; i < H*W; i++) {\n\t\tint flag = 0;\n\t\tvector<int> Near;\n\n\t\tif (HMap[SH[i] - 1][SW[i]] != 0) {\n\t\t\tif (HMap[SH[i] - 1][SW[i]] > HMap[SH[i]][SW[i]]) {\n\t\t\t\tflag++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRMap[SH[i]][SW[i]] = RMap[SH[i] - 1][SW[i]];\n\t\t\t\tNear.push_back(RMap[SH[i] - 1][SW[i]]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tflag++;\n\t\t}\n\n\t\tif (HMap[SH[i] + 1][SW[i]] != 0) {\n\t\t\tif (HMap[SH[i] + 1][SW[i]] > HMap[SH[i]][SW[i]]) {\n\t\t\t\tflag++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRMap[SH[i]][SW[i]] = RMap[SH[i] + 1][SW[i]];\n\t\t\t\tNear.push_back(RMap[SH[i] + 1][SW[i]]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tflag++;\n\t\t}\n\n\t\tif (HMap[SH[i]][SW[i] + 1] != 0) {\n\t\t\tif (HMap[SH[i]][SW[i] + 1] > HMap[SH[i]][SW[i]]) {\n\t\t\t\tflag++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRMap[SH[i]][SW[i]] = RMap[SH[i]][SW[i] + 1];\n\t\t\t\tNear.push_back(RMap[SH[i]][SW[i] + 1]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tflag++;\n\t\t}\n\n\t\tif (HMap[SH[i]][SW[i] - 1] != 0) {\n\t\t\tif (HMap[SH[i]][SW[i] - 1] > HMap[SH[i]][SW[i]]) {\n\t\t\t\tflag++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRMap[SH[i]][SW[i]] = RMap[SH[i]][SW[i] - 1];\n\t\t\t\tNear.push_back(RMap[SH[i]][SW[i] - 1]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tflag++;\n\t\t}\n\n\n\t\tif (flag == 4) {\n\t\t\tRMap[SH[i]][SW[i]] = HMap[SH[i]][SW[i]];\n\t\t}\n\t\telse {\n\t\t\tif (flag != 3) {\n\t\t\t\tif (count(Near.begin(), Near.end(), -2) == 0) {\n\t\t\t\t\tsort(Near.begin(), Near.end());\n\t\t\t\t\tNear.erase(unique(Near.begin(), Near.end()), Near.end());\n\t\t\t\t\tif (Near.size() != 1) {\n\t\t\t\t\t\tRMap[SH[i]][SW[i]] = -2;\n\t\t\t\t\t\t//OneNum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tRMap[SH[i]][SW[i]] = -2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\n\n\tfor (int i = 0; i < H + 2; i++) {\n\t\tfor (int j = 0; j < W + 2; j++) {\n\t\t\t//RMap[i][j] << \" \";\n\t\t\t//if (j == W + 1) cout << endl;\n\t\t\tif (RMap[i][j] == -2) OneNum++;\n\t\t}\n\t}\n\n\tcout << OneNum << endl;\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\n\nint h[1000000];\nint ANS = 0;\nint a, b, c[1002][1002], x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nP d[1000000];\nint main() {\n\tmemset(h, -1, sizeof(h));\n\tfor (int i = 0; i < 1002; i++) {\n\t\tfor (int j = 0; j < 1002; j++) {\n\t\t\tc[i][j] = 1 << 29;\n\t\t}\n\t}\n\tcin >> a >> b;\n\tfor (int e = 0; e < a; e++) {\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\tint g; scanf(\"%d\", &g);\n\t\t\tg--;\n\t\t\tc[e + 1][f + 1] = g;\n\t\t\td[g] = P(e + 1, f + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < a*b; i++) {\n\t\tint dx = d[i].first, dy = d[i].second;\n\t\tbool k = false; int sum = 0;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (c[dx + x[j]][dy + y[j]]<i) {\n\t\t\t\tsum++;\n\t\t\t\tif (h[c[dx + x[j]][dy + y[j]]] ==-1) {\n\t\t\t\t\tk = true;\n\t\t\t\t}\n\t\t\t\telse {\t\n\t\t\t\t\tif (h[i] == -1) {\n\t\t\t\t\t\th[i] = h[c[dx + x[j]][dy + y[j]]];\n\t\t\t\t\t}\n\t\t\t\t\telse if (h[i] != h[c[dx + x[j]][dy + y[j]]])k = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sum!=0) {\n\t\t\tif (k)h[i] = -1;\n\t\t\telse  {  ANS++; }\n\t\t}\n\t\telse {\n\t\t\th[i] = i;\n\t\t\tANS++;\n\t\t}\n\t}\n\tcout << a*b-ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[1199][1199],d[1199][1199],yy,xx,p,flag;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nset<pair<int,int> >se;\nvoid bfs(){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(p,mk(yy,xx)));\n  d[yy][xx]=p;\n  while(!q.empty()){\n    pair<int,pair<int,int> > g=q.front();q.pop();\n    int ya=g.s.f,xa=g.s.s,dd=g.f;\n    r(i,4){\n      int y=ya+dy[i],x=xa+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd){\n        if(d[y][x]&&d[y][x]!=p)se.insert(mk(y,x));\n        d[y][x]=p;\n        q.push(mk(a[y][x],mk(y,x)));\n      }\n    }\n  }\n}\nmain(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    bfs();\n  }\n  cout<<se.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dx[9]={0,-1,0,1},dy[9]={-1,0,1,0},hw[1000][1000],cnt,x,y,h,w,fcnt,f[1000][1000];\nvoid func(int y,int x){\n\tint i,xx,yy,flg;\n\tflg=0;\n\tfor(i=0;i<4;i++){\n\t\txx=x+dx[i]; yy=y+dy[i];\n\t\tif(xx<w&&yy<h&&xx>=0&&yy>=0){\n\t\t\tif(hw[yy][xx]<hw[y][x]){\n\t\t\t\tflg=1;\n\t\t\t\tfunc(yy,xx);\n\t\t\t}\n\t\t}\n\t}\n\tif(flg==0&&f[y][x]!=1){\n\t\tf[y][x]=1;\n\t\tfcnt++;\n\t}\n}\nint main(void){\n\tint i,j,ii,jj;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++) scanf(\"%d\",&hw[i][j]);\n\t}\n\tcnt=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tfcnt=0;\n\t\t\tfor(ii=0;ii<h;ii++){\n\t\t\t\tfor(jj=0;jj<w;jj++) f[ii][jj]=0;\n\t\t\t}\n\t\t\tfunc(i,j);\n\t\t\tif(fcnt>=2)\tcnt++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<tuple>\n#define TT std::tuple<int,int,int>\nint H, W;\nstd::vector<int> one[1010][1010];\nstd::vector<TT> M;\nint ans;\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\nint map[1010][1010];\nbool Q[1010][1010];\nint main() {\n\tstd::cin >> H >> W;\n\tfor (int i = 0; i <= H + 1; i++) {\n\t\tfor (int j = 0; j <= W + 1; j++) {\n\t\t\tif (i == 0 || j == 0 || i == H + 1 || j == W + 1) {\n\t\t\t\tmap[i][j] = 1 << 30;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::cin >> map[i][j];\n\t\t\tM.emplace_back(TT{ map[i][j],i,j });\n\t\t}\n\t}\n\tstd::sort(M.begin(), M.end());\n\tfor (auto u : M) {\n\t\tint a, b, c;\n\t\tstd::tie(a, b, c) = u;\n\t\tbool flag = 1;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint rx = b + dx[i];\n\t\t\tint ry = c + dy[i];\n\t\t\tif (map[rx][ry] < map[b][c]) {\n\t\t\t\tflag = false;\n\t\t\t\tif (Q[rx][ry]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tmap[b][c] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (auto w : one[rx][ry]) {\n\t\t\t\t\tone[b][c].emplace_back(w);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (flag)one[b][c].emplace_back(a);\n\t\tstd::sort(one[b][c].begin(), one[b][c].end());\n\t\tone[b][c].erase(std::unique(one[b][c].begin(), one[b][c].end()), one[b][c].end());\n\t\tif (one[b][c].size() >= 2)ans++;\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nint h,w,res = 0,pos = 0;\nint field[1000][1000];\nint cnt[1000][1000];\nbool used[1000][1000];\nqueue<P> que;\n\nvoid dfs(int x,int y){\n\tused[x][y] = true;\n\tque.push(P(x,y));\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] > field[x][y]){\n\t\t\tif(!used[nx][ny]) cnt[nx][ny]++;\n\t\t\tif(cnt[nx][ny] < 3) dfs(nx,ny);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) scanf(\"%d\",&field[i][j]);\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] < field[i][j]) flag = false;\n\t\t\t}\n\t\t\tif(flag) dfs(i,j);\n\t\t\twhile(!que.empty()){\n\t\t\t\tint x = que.front().first,y = que.front().second;que.pop();\n\t\t\t\tused[x][y] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) if(cnt[i][j] >= 2) res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[9999][9999],d[9999][9999],yy,xx,p,flag;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nset<pair<int,int> >se;\nvoid dfs(int ya,int xa,int dd){\n  d[ya][xa]=p;\n  r(i,4){\n    int y=ya+dy[i],x=xa+dx[i];\n    if(y<0||y>=h||x<0||x>=w)continue;\n    if(a[y][x]>dd){\n      if(d[y][x]&&d[y][x]!=p)se.insert(mk(y,x));\n      dfs(y,x,a[y][x]);\n    }\n  }\n}\nint main(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    dfs(yy,xx,p);\n  }\n  cout<<se.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\nint mx[] = { 0,1,0,-1 };\nint my[] = { 1,0,-1,0 };\nint map[1001][1001];\nP sor[1001*1001];\npair<bool, P> go[1001][1001];\nbool check(int, int);\nint h, w;\n\nint main() {\n\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\tsor[map[i][j]] = make_pair(i, j);\n\t\t\tgo[i][j].first = false;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tgo[sor[1].F][sor[1].S].S = sor[1];\n\tfor (int i = 1; i <= h*w; i++) {\n\t\tP befor = make_pair(-1, -1);\n\t\tbool ok = false;\n\t\tfor (int t = 0; t < 4; t++) {\n\t\t\tint MX = mx[t] + sor[i].F;\n\t\t\tint MY = my[t] + sor[i].S;\n\t\t\tif (!check(MX, MY) || map[sor[i].F][sor[i].S] < map[MX][MY]) continue;\n\t\t\tok = true;\n\t\t\tif (go[MX][MY].F) {\n\t\t\t\tgo[sor[i].F][sor[i].S].first = true;\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (befor.first == -1) befor = go[MX][MY].S;\n\t\t\telse if (befor != go[MX][MY].S) {\n\t\t\t\tans++;\n\t\t\t\tgo[sor[i].F][sor[i].S].first = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) go[sor[i].F][sor[i].S].S = sor[i];\n\t\telse if (!go[sor[i].F][sor[i].S].F) go[sor[i].F][sor[i].S].S = befor;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n}\n\nbool check(int i, int j) {\n\tif (i < h && i >= 0 && j < w && j >= 0) return true;\n\treturn false;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<int ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint h, w, m[1005][1005], ans = 0;\nP pos[1000005];\nset<int> cnt[1005][1005];\n\nint main() {\n    cin >> h >> w;\n    REP(i,h)REP(j,w){\n        scanf(\"%d\",&m[i][j]);\n        pos[m[i][j]-1] = {i,j};\n    }\n    REP(k,h*w){\n        int i = pos[k].first, j = pos[k].second;\n        if(cnt[i][j].size()>=2) ans++;\n        else if(cnt[i][j].size()==0) cnt[i][j].insert(k);\n        REP(l,4){\n            int ni = i+di[l], nj = j+dj[l];\n            if(ni<0 || ni>=h)continue;\n            if(nj<0 || nj>=w)continue;\n            if(m[ni][nj] > m[i][j]){\n                cnt[ni][nj].insert(cnt[i][j].begin(),cnt[i][j].end());\n            }\n        }\n        cnt[i][j].clear();\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-7)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tint x;\n                                        \tint y,z,w;\n                                        \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\nunsigned int randxor()\n{\n    static unsigned int x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned int t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\nint ans[1010*1010]={0};\nint ban[1010][1010];\nvector<int> G[1000020];\n\nint dfs(int r){\n\tif(ans[r]!=0)  return ans[r];\n\t\n\tif(G[r].size()==0){\n\t\tans[r]=r;\n\t\treturn r;\n\t}\n\tset<int> se;\n\tfor(auto v:G[r]){\n\t\tse.insert(dfs(v));\n\t}\n\tif(se.find(-1)!=se.end()){\n\t\tans[r]=-1;\n\t}\n\telse if(se.size()!=1) ans[r]=-1;\n\telse ans[r]=*se.begin();\n\treturn ans[r];\n}\n\n  signed main(){\n  \t              cin.tie(0);\n    \t\tios::sync_with_stdio(false);\n\nint n,m;\n  \tcin>>n>>m;\n  \t\n\n  \tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)cin>>ban[i][j];\n  \t\n  \tfor(int i=0;i<n;i++)for(int j=0;j<m-1;j++){\n  \t\tif(ban[i][j]<ban[i][j+1]){\n  \t\t\tG[i*m+j+1+1].pb(i*m+j+1);\n  \t\t}\n  \t\telse G[i*m+j+1].pb(i*m+j+1+1);\n  \t}\n  \t\n  \tfor(int i=0;i<n-1;i++)for(int j=0;j<m;j++){\n  \t\tif(ban[i][j]<ban[i+1][j]){\n  \t\t\tG[i*m+j+m+1].pb(i*m+j+1);\n  \t\t}\n  \t\telse G[i*m+j+1].pb(i*m+j+m+1);\n  \t}\n  \t\n  \tfor(int i=1;i<=n*m;i++)if(ans[i]==0)dfs(i);\n  \tint c=0;\n  \tfor(int i=1;i<=n*m;i++)if(ans[i]==-1)c++;\n  \tcout<<c<<endl;\n  \treturn 0;\n                }\n                \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nint h,w,res = 0,pos = 0;\nint field[1010][1010];\nint cnt[1010][1010];\nbool used[1010][1010];\nqueue<P> que;\n\nvoid dfs(int x,int y){\n\tused[x][y] = true;\n\tque.push(P(x,y));\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] > field[x][y] && !used[nx][ny]){\n\t\t\tcnt[nx][ny]++;\n\t\t\tif(cnt[nx][ny] < 3) dfs(nx,ny);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) scanf(\"%d\",&field[i][j]);\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] < field[i][j]) flag = false;\n\t\t\t}\n\t\t\tif(flag) dfs(i,j);\n\t\t\twhile(!que.empty()){\n\t\t\t\tint x = que.front().first,y = que.front().second;que.pop();\n\t\t\t\tused[x][y] = false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) if(cnt[i][j] >= 2) res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Ridge\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstatic const int drow[4] = {1, 0, -1, 0};\nstatic const int dcol[4] = {0, 1, 0, -1};\nstatic const int NIL = -1;\nstatic const int RIDGE = -2;\n\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    int A[H][W];\n    ll B[H][W];\n    ll order[H * W];\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            cin >> A[i][j];\n            order[A[i][j] - 1] = i * W + j;\n            B[H][W] = i * W + j;\n        }\n    }\n\n    for(int k = 0; k < H * W; k++) {\n        int i = order[k] / W;\n        int j = order[k] % W;\n        int cnt = 0;\n        ll result = NIL;\n        for(int l = 0; l < 4; l++) {\n            int si = i + drow[l];\n            int sj = j + dcol[l];\n            if(si >= 0 && sj >= 0 && si < H && sj < W) {\n                if(A[i][j] > A[si][sj]) {\n                    if(B[si][sj] == RIDGE) {\n                        result = RIDGE;\n                        break;\n                    } else if(result != NIL && result != B[si][sj]) {\n                        result = RIDGE;\n                        break;\n                    } else {\n                        result = B[si][sj];\n                    }\n                }\n            }\n        }\n        B[i][j] = (result == NIL ? i * W + j : result);\n    }\n\n    int cnt = 0;\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            if(B[i][j] == RIDGE) cnt++;\n            cout << B[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    cout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint h, w;\nint maze[1010][1010];\nvector<pair<int, pair<int, int>>> v;\nint memo[1010101];\nint ans;\n\nint main() {\n\tcin >> h >> w;\n\tREP(i, h)REP(j, w) {\n\t\tcin >> maze[i][j];\n\t\tv.push_back(make_pair(maze[i][j], make_pair(i, j)));\n\t}\n\tsort(ALL(v));\n\tREP(i, v.size()) {\n\t\tint next = v[i].first;\n\t\tint cnt = 0;\n\t\tpair<int, pair<int, int>> now = v[i];\n\t\tbool flg = false;\n\t\tREP(j, 4) {\n\t\t\tint nx = now.second.first + dx[j];\n\t\t\tint\tny = now.second.second + dy[j];\n\t\t\tif (0 > nx || nx >= h || 0 > ny || ny >= w)continue;\n\t\t\tif (maze[nx][ny] == -1) {\n\t\t\t\tmaze[now.second.first][now.second.second] = -1;\n\t\t\t\tflg = true;\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (maze[nx][ny] > maze[now.second.first][now.second.second])continue;\n\t\t\tif (memo[maze[nx][ny]] != i + 1) {\n\t\t\t\tmemo[maze[nx][ny]] = i + 1;\n\t\t\t\tcnt++;\n\t\t\t\tnext = maze[nx][ny];\n\t\t\t}\n\t\t}\n\t\tif (!flg && cnt > 1) {\n\t\t\tans++;\n\t\t\tmaze[now.second.first][now.second.second] = -1;\n\t\t}\n\t\telse if (!flg)maze[now.second.first][now.second.second] = next;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],qw,a,b,e,f,r[1000000],zx;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  if(qw>=2)return 1;\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n    if(qw>=2)return 1;\n  }\n  if(e==y&&f==x){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c){\n    rep(i,zx)if(m[y][x]==r[i])goto L;\n    r[zx++]=m[y][x];\n    qw++;\n    return 1;\n  }L:\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    qw=0;e=i;f=j;\n    sum+=dfs(j,i);qw=0;\n    rep(z,zx)r[z]=0;\n    zx=0;\n  }\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[99][99],d[99][99],yy,xx,p,flag;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nset<pair<int,int> >se;\nvoid bfs(){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(p,mk(yy,xx)));\n  d[yy][xx]=p;\n  while(!q.empty()){\n    pair<int,pair<int,int>> g=q.front();q.pop();\n    int ya=g.s.f,xa=g.s.s,dd=g.f;\n    r(i,4){\n      int y=ya+dy[i],x=xa+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd){\n        if(d[y][x]&&d[y][x]!=p)se.insert(mk(y,x));\n        d[y][x]=p;\n        q.push(mk(a[y][x],mk(y,x)));\n      }\n    }\n  }\n}\nmain(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    bfs();\n  }\n  cout<<se.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n尾根(Ridge)\n<問題>\nJOI カルデラは景観の良さが多くの登山家に愛される美しい地形である．\n特に，尾根と呼ばれる場所からの景観は絶景である．\nJOI カルデラの土地は南北 H キロメートル，東西 W キロメートルの長方形である．\n南北，東西に 1 キロメートルごとに JOI カルデラの土地を分け，これら H×W 個の領域を区域と呼ぶ． \nすべての区域において，その中では標高は等しい．また，異なる区域の標高は異なる．\nある区域に雨が降ると，雨水はその区域に東西南北に隣り合う最大で 4 つの区域のうち，\n標高がその区域より低いような区域のすべてに流れる．そのような区域がない場合，雨水はその区域に溜まる．\n他の区域から流れてきた雨水についても同様である． JOI カルデラの外側は，\n外輪山の急峻な崖に囲まれているため，雨水が JOI カルデラの外に流れ出すことはない．\nある区域について，その区域のみに雨が降った場合，\n最終的に複数の区域に雨水が溜まるとき，その区域を尾根と呼ぶ．\n絶景をこよなく愛する登山家たちのために，尾根の区域がいくつあるかを求めるプログラムを作成せよ．\n<入力>\n入力は 1 + H 行からなる．\n1 行目には 2 個の整数 H, W (1 ≦ H ≦ 1000, 1 ≦ W ≦ 1000) が\n空白を区切りとして書かれており，JOI カルデラが南北に H キロメートル，東西に W キロメートルにわたることを表す．\n続く H 行にはそれぞれ W 個の整数が空白を区切りとして書かれており，標高の情報を表す．\n H 行のうちの i 行目の j 番目 (1 ≦ i ≦ H, 1 ≦ j ≦ W) の\n 整数 Mi,j (1 ≦ Mi,j ≦ H×W) は，JOI カルデラの北から i 行目，\n 西から j 列目の区域の標高を表す． (i,j) ≠ (k,l) なら，Mi,j ≠ Mk,l を満たす．\n<出力>\n尾根の区域の個数を 1 行で出力せよ．\n*/\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\nusing namespace std;\nint map[1002][1002];\nint dat[1002][1002];\nint x[1000001],y[1000001];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint main(void)\n{\n    int mx,my;\n\tcin>>mx>>my;\n\tfor(int i=0;i<mx+2;i++){\n\t\tfor(int j=0;j<my+2;j++){\n\t\t\tmap[i][j]=1000000000,dat[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<mx;i++){\n\t\tfor(int j=0;j<my;j++){\n\t\t\tcin>>map[i+1][j+1];\n\t\t}\n\t}\n\tfor(int i=1;i<=mx;i++){\n\t\tfor(int j=1;j<=my;j++)\n\t\t{\n\t\t\tx[map[i][j]]=i,y[map[i][j]]=j;\n\t\t}\n\t}\n\tint c;\n\tfor(int i=1;i<=mx*my;i++){\n\t\tint r=0;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint a=x[i]+dx[j],b=y[i]+dy[j];\n\t\t\tif(map[a][b]<i)\n\t\t\t{\n\t\t\t\tif(r==0)r=dat[a][b];\n\t\t\t\telse if(r!=dat[a][b])r=-1;\n\t\t\t}\n\t\t}\n\t\tif(r==0)dat[x[i]][y[i]]=i;\n\t\telse dat[x[i]][y[i]]=r;\n\t\tif(r==-1)c++;\n\t}\n\tcout<<c<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H, vector<int>(W));\n\tvector<vector<int>>froms(H, vector<int>(W,-2));\n\tvector<pair<int, int>>coords(H*W);\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tfield[i][j] = a;\n\t\t\tcoords[a] = make_pair(j,i);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < H*W; ++i) {\n\t\tint nx = coords[i].first;\n\t\tint ny = coords[i].second;\n\t\tif (froms[ny][nx] == -2) {\n\t\t\tfroms[ny][nx] = i;\n\t\t}\n\t\telse if (froms[ny][nx] == -1) {\n\t\t\tans++;\n\t\t}\n\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\tint nextx = nx + dx[way];\n\t\t\tint nexty = ny + dy[way];\n\t\t\tif (nextx >= 0 && nextx < W&&nexty >= 0 && nexty < H) {\n\t\t\t\tif (froms[nexty][nextx] == -2) {\n\t\t\t\t\tfroms[nexty][nextx] = froms[ny][nx];\n\t\t\t\t}\n\t\t\t\telse if (froms[nexty][nextx] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (froms[nexty][nextx] == froms[ny][nx]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfroms[nexty][nextx] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\ntypedef std::pair<int, int> Pair;\n\nconstexpr int MAX_HW = 1000;\nconstexpr int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint H, W;\nint field[MAX_HW][MAX_HW];\n\nbool bfs(int h, int w);\n\nint main(){\n\t\n\tstd::cin >> H >> W;\n\t\n\tfor(int i = 0; i < H; ++i){\n\t\tfor(int j = 0; j < W; ++j){\n\t\t\tstd::cin >> field[i][j];\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\n\tfor(int i = 0; i < H; ++i){\n\t\tfor(int j = 0; j < W; ++j){\n\t\t\tif(bfs(i, j)){\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}\n\nbool bfs(int h, int w){\n\tint puddle = 0;\n\tbool is_reached[MAX_HW][MAX_HW] = {};\n\tstd::queue<Pair> que;\n\tque.push(Pair(h, w));\n\n\twhile(!que.empty()){\n\t\tPair cur = que.front(); que.pop();\n\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint nh = cur.first + dx[i], nw = cur.second + dy[i];\n\t\t\tif(nh < 0 || nw < 0 || nh >= H || nw >= W){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(field[nh][nw] < field[cur.first][cur.second]){\n\t\t\t\tque.push(Pair(nh, nw));\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\tif(flag && !is_reached[cur.first][cur.second]){\n\t\t\tis_reached[cur.first][cur.second] = true;\n\t\t\t++puddle;\n\t\t}\n\t}\n\n\tif(puddle > 1){\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define rrep(i,n) for(int i = 1;i <= n;i++)\n\nint a[1002][1002], b[20004];\nvector<int> G[20004];\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\nqueue<int> q;\nint main(){\n\tint h, w, ans = 0;\n\tscanf(\"%d%d\", &h, &w);\n\trrep(i,h)rrep(j,w)scanf(\"%d\", &a[i][j]);\n\trrep(y,h)rrep(x,w){\n\t\tint f = 0;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tif(a[y][x] < a[y+dy[i]][x+dx[i]]){\n\t\t\t\tint t = a[y+dy[i]][x+dx[i]];\n\t\t\t\tG[a[y][x]].push_back(t);\n\t\t\t\tf++;\n\t\t\t}\n\t\t\tif(a[y+dy[i]][x+dx[i]] == 0)f++;\n\t\t}\n\t\tif(f == 4)q.push(a[y][x]);\n\t}\n\t\n\twhile(!q.empty()){\n\t\tint p = q.front();q.pop();\n\t\tif(b[p] == 0)b[p] = p;\n\t\tfor(int i = 0;i < G[p].size();i++){\n\t\t\tint t = G[p][i];\n\t\t\tif(b[t] == 0){\n\t\t\t\tb[t] = b[p];\n\t\t\t\tq.push(t);\n\t\t\t}else if((b[t] != b[p] || b[p] == -1) && b[t] != -1){\n\t\t\t\tb[t] = -1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1000][1000],m1[1000][1000],a,b,e,f;\nint v[4][2]={-1,0,1,0,0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  int s=0,c=0;\n  rep(i,4){\n    if(0<x+v[i][0]||b>=x+v[i][0]||0<y+v[i][1]||a>=y+v[i][1])continue;\n    if(m[y][x+v[i][0]]<m[y][x]||m[y+v[i][1]][0]<m[y][x]){\n      s+=dfs(x+v[i][0],y+v[i][1]);\n      c++;\n    }\n  }\n  if(!c&&m1[x][y]==0){\n    m1[x][y]++;\n    return 1;\n  }\n  if(s>=1)return 1;\n  return 0;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){m1[i][j]++;sum+=dfs(j,i);}\n  cout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int dx[4] = { 0, 0, 1, -1 };\nconst int dy[4] = { 1, -1, 0, 0 };\nint h, w;\nint m[1005][1005];\nint memo[1005][1005];\nusing P = pair<int, int>;\nP p[1005 * 1005];\n\nbool checkRange(int x, int y)\n{\n\treturn (0 <= x && x < w) && (0 <= y && y < h);\n}\n\nint main()\n{\n\tcin >> h >> w;\n\n\tfor (int y = 0; y < h; y++)\n\t{\n\t\tfor (int x = 0; x < w; x++)\n\t\t{\n\t\t\tcin >> m[x][y];\n\t\t\tp[m[x][y]] = P(x, y);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= h * w; i++)\n\t{\n\t\tint x = p[i].first;\n\t\tint y = p[i].second;\n\t\tfor (int j = 0; j < 4; j++)\n\t\t{\n\t\t\tint X = x + dx[j];\n\t\t\tint Y = y + dy[j];\n\t\t\tif (checkRange(X, Y) && m[x][y] > m[X][Y])\n\t\t\t{\n\t\t\t\tif (memo[X][Y] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (memo[x][y] != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[x][y] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[x][y] = m[X][Y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (memo[X][Y] == -1)\n\t\t\t\t{\n\t\t\t\t\tmemo[x][y] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (memo[x][y] != 0 && memo[x][y] != memo[X][Y])\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[x][y] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[x][y] = memo[X][Y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int y = 0; y < h; y++)\n\t{\n\t\tfor (int x = 0; x < w; x++)\n\t\t{\n\t\t\tif (memo[x][y] == -1) ans++;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<unordered_set>\n#define P pair<int,int>\nusing namespace std;\n\nint h[1000000];\nint ANS = 0;\nint a, b, c[1002][1002], x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nP d[1000000];\nint main() {\n\tmemset(h, -1, sizeof(h));\n\tfor (int i = 0; i < 1002; i++) {\n\t\tfor (int j = 0; j < 1002; j++) {\n\t\t\tc[i][j] = 1 << 29;\n\t\t}\n\t}\n\tcin >> a >> b;\n\tfor (int e = 0; e < a; e++) {\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\tint g; scanf(\"%d\", &g);\n\t\t\tg--;\n\t\t\tc[e + 1][f + 1] = g;\n\t\t\td[g] = P(e + 1, f + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < a*b; i++) {\n\t\tint dx = d[i].first, dy = d[i].second;\n\t\tbool k = false; int sum = 0;\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (c[dx + x[j]][dy + y[j]]<i) {\n\t\t\t\tsum++;\n\t\t\t\tif (h[c[dx + x[j]][dy + y[j]]] ==-1) {\n\t\t\t\t\tk = true;\n\t\t\t\t}\n\t\t\t\telse {\t\n\t\t\t\t\tif (h[i] == -1) {\n\t\t\t\t\t\th[i] = h[c[dx + x[j]][dy + y[j]]];\n\t\t\t\t\t}\n\t\t\t\t\telse if (h[i] != h[c[dx + x[j]][dy + y[j]]])k = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sum!=0) {\n\t\t\tif (k)h[i] = -1;\n\t\t\telse  {  ANS++; }\n\t\t}\n\t\telse {\n\t\t\th[i] = i;\n\t\t\tANS++;\n\t\t}\n\t}\n\tcout << a*b-ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint dx[]={-1,0,0,1},dy[]={0,-1,1,0};\nint a[1001][1001];\npint p[1000002];\nint b[1000002],c[1000002];\nint main(){\n    int h,w;\n    cin>>h>>w;\n    rep(i,h)rep(j,w){\n        cin>>a[i][j];\n        p[a[i][j]]={j,i};\n    }\n    int ans=0;\n    rep(l,h*w){\n        int j=p[l+1].first,i=p[l+1].second;\n        int cnt=0;\n        rep(k,4){\n            int ty=i+dy[k],tx=j+dx[k];\n            if(ty>=0&&tx>=0&&ty<h&&tx<w&&a[ty][tx]<a[i][j]){\n                if(b[a[ty][tx]]==-1){\n                    if(b[l+1]==0) c[l+1]=a[ty][tx],b[l+1]=1;\n                    else if(b[l+1]==1&&c[l+1]!=a[ty][tx]){\n                        ++ans,b[l+1]=2;cnt=4;break;\n                    }\n                }\n                else if(b[a[ty][tx]]==1){\n                    if(b[l+1]==0){\n                        c[l+1]=c[a[ty][tx]];\n                        b[l+1]=1;\n                    }\n                    else{\n                        if(c[l+1]!=c[a[ty][tx]]){\n                            b[l+1]=2;\n                            ++ans;cnt=4;break;\n                        }        \n                    }\n                }\n                else if(b[a[ty][tx]]==2){\n                    b[l+1]=2;\n                    ++ans;cnt=4;break;\n                }\n            }\n            if(ty>=0&&tx>=0&&ty<h&&tx<w&&a[ty][tx]<a[i][j]) ++cnt;\n        }\n        if(cnt==0) b[l+1]=-1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : DPTest.cpp\n// Author      :\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint H,W;\nint M[1002][1002]={};\nint dp[1002][1002]={};\nint dp2[1002][1002]={};\ntypedef pair<int,int> P;\nconst int INF=1000000000;\n\nint main() {\n\tcin>>H>>W;\n\tfor(int i=1;i<H+1;i++){\n\t\tfor(int j=1;j<W+1;j++){\n\t\t\tcin>>M[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<H+2;i++){\n\t\tM[i][0]=INF;\n\t\tM[i][W+1]=INF;\n\t}\n\tfor(int i=0;i<W+2;i++){\n\t\tM[0][i]=INF;\n\t\tM[H+1][i]=INF;\n\t}\n\tqueue<P> que;\n\tint x1,y1;\n\tfor(int i=1;i<H+1;i++){\n\t\tfor(int j=1;j<W+1;j++){\n\t\t\tif((M[i][j]<M[i-1][j]&&M[i][j]<M[i+1][j])&&(M[i][j]<M[i][j-1]&&M[i][j]<M[i][j+1])){\n\t\t\t\t//init\n\t\t\t\tfill(dp[0],dp[1002],0);\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p1=que.front();que.pop();\n\t\t\t\t\tx1=p1.first;\n\t\t\t\t\ty1=p1.second;\n\t\t\t\t\tif(dp[x1][y1]>0||dp2[x1][y1]>1)continue;\n\t\t\t\t\tdp[x1][y1]=1;\n\t\t\t\t\tdp2[x1][y1]+=1;\n\t\t\t\t\tif(M[x1-1][y1]>M[x1][y1]&&x1>1)que.push(P(x1-1,y1));\n\t\t\t\t\tif(M[x1+1][y1]>M[x1][y1]&&x1<H)que.push(P(x1+1,y1));\n\t\t\t\t\tif(M[x1][y1-1]>M[x1][y1]&&y1>1)que.push(P(x1,y1-1));\n\t\t\t\t\tif(M[x1][y1+1]>M[x1][y1]&&y1<W)que.push(P(x1,y1+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint R=0;\n\tfor(int i=1;i<H+1;i++){\n\t\tfor(int j=1;j<W+1;j++){\n\t\t\tif(dp2[i][j]>1)R++;\n\t\t}\n\t}\n\tcout<<R<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e6 + 1;\nvector<vector<int>> height, way;\nvector<vector<bool>> visited;\n\nvector<pair<int, int>> next(int y, int x) {return {{y-1, x}, {y+1, x}, {y, x-1}, {y, x+1}};}\n\nbool bottom(int y, int x) {\n  for(auto p: next(y, x)) if(height[p.first][p.second] < height[y][x]) return false;\n  return true;\n}\n\nvoid mark(int y, int x) {\n  if(visited[y][x]) return;\n  visited[y][x] = true;\n  if(height[y][x] == INF) return;\n  if(2 <= way[y][x]) return;\n  ++way[y][x];\n  for(auto p: next(y, x)) if(height[y][x] < height[p.first][p.second]) mark(p.first, p.second);\n}\n\nint main() {\n  int H, W;\n  cin >> H >> W;\n  height.assign(H+2, vector<int>(W+2, INF));\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) cin >> height[i][j];\n\n  way.assign(H+2, vector<int>(W+2, 0));\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(bottom(i, j)) {\n    visited.assign(H+2, vector<bool>(W+2, false));\n    mark(i, j);\n  }\n\n  auto ans = 0;\n  for(auto i = 1; i <= H; ++i) for(auto j = 1; j <= W; ++j) if(2 <= way[i][j]) ++ans;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\n#define UNDEF -1\n#define IS_RD -2\n#define INF 1073741824\n\nusing namespace std;\n\nint M[1001][1001],H,W;\nint dp[1001][1001];\nstack<int> callX;\nstack<int> callY;\n\nint getM(int x,int y)\n{\n\tif(x >= 0 && y >= 0 && x < W && y < H)\n\t{\n\t\treturn M[x][y];\n\t}\n\telse\n\t{\n\t\treturn INF;\n\t}\n}\n\nvoid calc(int _x,int _y)\n{\n\tint x,y;\n\tcallX.push(_x);\n\tcallY.push(_y);\n\twhile(!callX.empty())\n\t{\n\t\tendfn:\n\t\tx = callX.top();\n\t\ty = callY.top();\n\t\tif(dp[x][y] == UNDEF)\n\t\t{\n\t\t\tint a[4] = {INF,INF,INF,INF};\n\t\t\tif(getM(x+1,y) < getM(x,y))\n\t\t\t{\n\t\t\t\tif(dp[x+1][y] == UNDEF)\n\t\t\t\t{\n\t\t\t\t\tcallX.push(x+1);\n\t\t\t\t\tcallY.push(y);\n\t\t\t\t\tgoto endfn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[0] = dp[x+1][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getM(x-1,y) < getM(x,y))\n\t\t\t{\n\t\t\t\tif(dp[x-1][y] == UNDEF)\n\t\t\t\t{\n\t\t\t\t\tcallX.push(x-1);\n\t\t\t\t\tcallY.push(y);\n\t\t\t\t\tgoto endfn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[1] = dp[x-1][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getM(x,y+1) < getM(x,y))\n\t\t\t{\n\t\t\t\tif(dp[x][y+1] == UNDEF)\n\t\t\t\t{\n\t\t\t\t\tcallX.push(x);\n\t\t\t\t\tcallY.push(y+1);\n\t\t\t\t\tgoto endfn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[2] = dp[x][y+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(getM(x,y-1) < getM(x,y))\n\t\t\t{\n\t\t\t\tif(dp[x][y-1] == UNDEF)\n\t\t\t\t{\n\t\t\t\t\tcallX.push(x);\n\t\t\t\t\tcallY.push(y-1);\n\t\t\t\t\tgoto endfn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta[3] = dp[x][y-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a[0] == INF && a[1] == INF && a[2] == INF && a[3] == INF)\n\t\t\t{\n\t\t\t\tdp[x][y] = (x*1000)+y;\n\t\t\t\tgoto endok;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i = 0;i < 3;i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int ii = i+1;ii < 4;ii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[i] != INF && a[ii] != INF && a[i] != a[ii])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[x][y] = IS_RD;\n\t\t\t\t\t\t\tgoto endok;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < 4;i++)\n\t\t\t\t{\n\t\t\t\t\tif(a[i] != INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[x][y] = a[i];\n\t\t\t\t\t\tgoto endok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tendok:\n\t\tcallX.pop();\n\t\tcallY.pop();\n\t}\n}\n\nint main(void)\n{\n\tcin >> H >> W;\n\tfor(int i = 0;i < H;i++)\n\t{\n\t\tfor(int ii = 0;ii < W;ii++)\n\t\t{\n\t\t\tcin >> M[ii][i];\n\t\t}\n\t}\n\tfor(int x = 0;x < 1001;x++)\n\t{\n\t\tfor(int y = 0;y < 1001;y++)\n\t\t{\n\t\t\tdp[x][y] = UNDEF;\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int x = 0;x < W;x++)\n\t{\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tcalc(x,y);\n\t\t}\n\t}\n\tfor(int x = 0;x < W;x++)\n\t{\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tif(dfs(x,y) == IS_RD)\n\t\t\t\tres++;\n\t\t}\n\t}\n\t\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint hyoukou[1002][1002];\nint x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nint main() {\n\t\tunordered_map<int, unordered_set<int>>U;\n\t\tmemset(hyoukou, 1, sizeof(hyoukou));\n\t\tpriority_queue<P, vector<P>, greater<P>>Q;\n\t\tint c, d;\n\t\tcin >> c >> d;\n\t\tfor (int e = 0; e < c; e++) {\n\t\t\tfor (int f = 0; f < d; f++) {\n\t\t\t\tint g;\n\t\t\t\tscanf(\"%d\", &g);\n\t\t\t\tg--;\n\t\t\t\thyoukou[e + 1][f + 1] = g;\n\t\t\t\tQ.push(P(g, p(e + 1, f + 1)));\n\t\t\t}\n\t\t}\n\t\twhile (Q.size()) {\n\t\t\tP h = Q.top(); Q.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (h.first> hyoukou[h.second.first + x[i]][h.second.second + y[i]]) {\n\t\t\t\t\tfor (auto k = U[hyoukou[h.second.first + x[i]][h.second.second + y[i]]].begin(); k != U[hyoukou[h.second.first + x[i]][h.second.second + y[i]]].end(); k++) {\n\t\t\t\t\t\tU[h.first].insert(*k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (U[h.first].size() == 0)U[h.first].insert(h.first);\n\t\t}\n\t\tint S = 0;\n\t\tfor (int i = 1; i <= c; i++) {\n\t\t\tfor (int h = 1; h <= d; h++) {\n\t\t\t\tif (U[hyoukou[i][h]].size() != 1)S++;\n\t\t\t}\n\t\t}   \n\t\tcout << S << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[99][99],d[99][99],yy,xx,p,ans;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nbool bo[1199][1199];\nvoid bfs(){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(p,mk(yy,xx)));\n  d[yy][xx]=p;\n  while(!q.empty()){\n    pair<int,pair<int,int>> g=q.front();q.pop();\n    int ya=g.s.f,xa=g.s.s,dd=g.f;\n    r(i,4){\n      int y=ya+dy[i],x=xa+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd){\n        if(d[y][x]&&d[y][x]!=p)bo[y][x]=1;\n        d[y][x]=p;\n        q.push(mk(a[y][x],mk(y,x)));\n      }\n    }\n  }\n}\nmain(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    bfs();\n  }\n  r(i,h)r(j,w)if(bo[i][j])ans++;\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define f first\n#define s second\nusing namespace std;\nint h,w,a[1199][1199],d[1199][1199],yy,xx,p,ans;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvector<pair<int,pair<int,int> > >v;\nvector<pair<int,int> >vv;\nbool used[1199][1199];\nvoid bfs(){\n  queue<pair<int,pair<int,int> > >q;\n  q.push(mk(p,mk(yy,xx)));\n  d[yy][xx]=p;\n  while(!q.empty()){\n    pair<int,pair<int,int> > g=q.front();q.pop();\n    int ya=g.s.f,xa=g.s.s,dd=g.f;\n    r(i,4){\n      int y=ya+dy[i],x=xa+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd){\n        if(d[y][x]&&d[y][x]!=p)vv.push_back(mk(y,x));\n        if(!d[y][x])q.push(mk(a[y][x],mk(y,x)));\n        d[y][x]=p;\n      }\n    }\n  }\n}\nvoid dfs(int yy,int xx,int dd){\n  if(!used[yy][xx]){\n    ans++;\n    used[yy][xx]=1;\n    r(i,4){\n      int y=yy+dy[i],x=xx+dx[i];\n      if(y<0||y>=h||x<0||x>=w)continue;\n      if(a[y][x]>dd&&!used[y][x])\n        dfs(y,x,a[y][x]);\n    }\n  }\n}\nmain(){\n  cin>>h>>w;\n  r(i,h)r(j,w){\n    cin>>a[i][j];\n    v.push_back(mk(a[i][j],mk(i,j)));\n  }\n  sort(v.begin(),v.end());\n  r(i,h*w){\n    yy=v[i].s.f,xx=v[i].s.s,p=v[i].f;\n    if(d[yy][xx])continue;\n    bfs();\n  }\n  r(i,vv.size())dfs(vv[i].f,vv[i].s,a[vv[i].f][vv[i].s]);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t};\n\tint row,col;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_height){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\theight = arg_height;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn height > arg.height;\n\t};\n\n\tint row,col,height;\n};\n\nstruct Shishimaru{\n\tvector<Info> info;\n};\n\nint H,W;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint memo[1000][1000],table[1000][1000];\nShishimaru shishimaru[1000][1000];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvector<Info> recursive(int row,int col,int depth){\n\n\tif(memo[row][col] != -1){\n\t\treturn shishimaru[row][col].info;\n\t}\n\n\tvector<Info> sum,catcher;\n\n\tint adj_row,adj_col;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = row + diff_row[i];\n\t\tadj_col = col + diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] > table[row][col])continue;\n\n\t\tcatcher = recursive(adj_row,adj_col,depth+1);\n\n\t\tfor(int k = 0; k < catcher.size(); k++){\n\t\t\tsum.push_back(catcher[k]);\n\t\t}\n\t\tcatcher.clear();\n\t}\n\n\tif(sum.size() == 0){\n\t\tmemo[row][col] = 0;\n\t\tif(depth > 0){\n\t\t\tshishimaru[row][col].info.push_back(Info(row,col));\n\t\t\tsum.push_back(Info(row,col));\n\t\t}\n\t\treturn sum;\n\t}\n\n\tsort(sum.begin(),sum.end());\n\n\tint pre_row = sum[0].row,pre_col = sum[0].col;\n\tshishimaru[row][col].info.push_back(sum[0]);\n\n\tfor(int i = 1; i < sum.size(); i++){\n\t\tif(sum[i].row != pre_row || sum[i].col != pre_col){\n\t\t\tshishimaru[row][col].info.push_back(sum[i]);\n\t\t}\n\t\tpre_row = sum[i].row;\n\t\tpre_col = sum[i].col;\n\t}\n\n\tmemo[row][col] = shishimaru[row][col].info.size();\n\n\treturn shishimaru[row][col].info;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tpriority_queue<Data> Q;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&table[row][col]);\n\t\t\tQ.push(Data(row,col,table[row][col]));\n\t\t\tmemo[row][col] = -1;\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\tif(memo[Q.top().row][Q.top().col] == -1){\n\t\t\trecursive(Q.top().row,Q.top().col,0);\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tint ans = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(memo[row][col] > 1){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nint H, W;\nint maps[1000][1000];\nset<pii> ss[1000][1000];\nbool done[1000][1000];\nint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\nbool check(int y, int x) {\n\treturn x >= 0 && x < W && y >= 0 && y < H;\n}\n\nint main() {\n\tcin >> H >> W;\n\tREP(i, H) REP(j, W) scanf(\"%d\", &maps[i][j]);\n\t\n\tpriority_queue<pip> pq;\n\tREP(i, H) REP(j, W) {\n\t\tbool ng = false;\n\t\tREP(k, 4) {\n\t\t\tint nx = j + dx[k], ny = i + dy[k];\n\t\t\tif (!check(ny, nx)) continue;\n\t\t\tif (maps[i][j] > maps[ny][nx]) { ng = true; continue; }\n\t\t}\n\t\tif (ng) continue;\n\t\t\n\t\tdone[i][j] = true;\n\t\tREP(k, 4) {\n\t\t\tint nx = j + dx[k], ny = i + dy[k];\n\t\t\tif (!check(ny, nx)) continue;\n\t\t\tss[ny][nx].insert(pii(i, j));\n\t\t\tpq.push(pip(-maps[ny][nx], pii(ny, nx)));\n\t\t}\n\t}\n\t\n\twhile (!pq.empty()) {\n\t\tint x = pq.top().se.se, y = pq.top().se.fi;\n\t\tpq.pop();\n\t\t\n\t\tif (done[y][x]) continue;\n\t\tdone[y][x] = true;\n\t\t\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (!check(ny, nx) || done[ny][nx] || maps[y][x] > maps[ny][nx]) continue;\n\t\t\t\n\t\t\tfor (set<pii>::iterator it = ss[y][x].begin(); it != ss[y][x].end(); ++it) {\n\t\t\t\tif (ss[ny][nx].size() >= 2) break;\n\t\t\t\tss[ny][nx].insert(*it);\n\t\t\t}\n\t\t\t\n\t\t\tpq.push(pip(-maps[ny][nx], pii(ny, nx)));\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tREP(i, H) REP(j, W) if (ss[i][j].size() >= 2) ans++;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int X, Y;\n    cin >> Y >> X;\n    int max=Y*X+1;//周りの壁\n    int n = 0;\n    int a[Y][X]; //高さのデータ(入力)\n    int b[Y][X]; //低い部分から上がってくる個数のデータ(答えの元)\n    int c[Y][X]; //幅優先探索用のデータ(重複潰し)\n    int d[Y+2][X+2];\n    for(int i = 0; i < Y; i++) {\n        for(int j = 0; j < X; j++) {\n            b[i][j] = 0;\n            c[i][j] = 0;\n        }\n    }\n    for(int i=0;i<Y+2;i++)\n    {\n        for(int j=0;j<X+2;j++)\n        {\n            d[i][j]=max;\n        }\n    }\n    for(int i = 0; i < Y; i++) {\n        for(int j = 0; j < X; j++) {\n            cin >> a[i][j];\n        }\n    }\n    for(int i=1;i<=Y;i++)\n    {\n        for(int j=1;j<=X;j++)\n        {\n            d[i][j]=a[i-1][j-1];\n        }\n    }\n    vector<pair<int, int> > q;\n    for(int i =1; i <= Y; i++){\n        for(int j = 1; j <= X; j++) {\n            if(d[i][j] < d[i + 1][j] && d[i][j] < d[i - 1][j] &&\n               d[i][j] < d[i][j + 1] && d[i][j] < d[i][j - 1]) {\n                q.push_back(make_pair(i-1, j-1));\n                b[i-1][j-1]=1;\n                n++;\n            }\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        queue<pair<int, int> > p;\n        p.push(make_pair(q[i].first, q[i].second));\n        c[p.front().first][p.front().second] = 1;\n        while(p.empty() == false) {\n            if(a[p.front().first][p.front().second]<a[p.front().first+1][p.front().second]&&c[p.front().first+1][p.front().second]==0&&p.front().first+1<Y)\n            {\n                p.push(make_pair(p.front().first+1,p.front().second));\n                b[p.front().first+1][p.front().second]++;\n                c[p.front().first+1][p.front().second] = 1;\n            }\n            if(a[p.front().first][p.front().second]<a[p.front().first-1][p.front().second]&&c[p.front().first-1][p.front().second]==0&&p.front().first-1>=0)\n            {\n                p.push(make_pair(p.front().first-1,p.front().second));\n                b[p.front().first-1][p.front().second]++;\n                c[p.front().first-1][p.front().second] = 1;\n            }\n            if(a[p.front().first][p.front().second]<a[p.front().first][p.front().second+1]&&c[p.front().first][p.front().second+1]==0&&p.front().second+1<X)\n            {\n                p.push(make_pair(p.front().first,p.front().second+1));\n                b[p.front().first][p.front().second+1]++;\n                c[p.front().first][p.front().second+1] = 1;\n            }\n            if(a[p.front().first][p.front().second]<a[p.front().first][p.front().second-1]&&c[p.front().first][p.front().second-1]==0&&p.front().second-1>=0)\n            {\n                p.push(make_pair(p.front().first,p.front().second-1));\n                b[p.front().first][p.front().second-1]++;\n                c[p.front().first][p.front().second-1] = 1;\n            }\n            p.pop();\n        }\n        for(int i = 0; i < Y; i++) {\n            for(int j = 0; j < X; j++) {\n                c[i][j] = 0;\n            }\n        }\n    }\n    int ans=0;\n        for(int i=0;i<Y;i++)\n        {\n            for(int j=0;j<X;j++)\n            {\n                if(b[i][j]>=2)  ans++;\n            }\n        }\n        cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\nll solve(){\n    ll res = 0;\n    ll H,W; cin >> H >> W;\n    vector<vector<ll>> M(H+2,vector<ll>(W+2,LINF));\n    vector<pll> Section(H*W);\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            ll x; cin >> x; x--;\n            M[i][j] = x;\n            Section[x] = {i,j};\n        }\n    }\n    \n    vector<vector<ll>> flag(H+2,vector<ll>(W+2,-1));\n    int id = 0;\n    int d[4] = {1,0,-1,0};\n    for(int i = 0; i < H*W;i++){\n        ll x,y; tie(x,y) = Section[i];\n        \n        vector<ll> F;\n        for(int k = 0; k < 4;k++){\n            ll nx = x + d[k];\n            ll ny = y + d[k^1];\n            if(M[nx][ny] < M[x][y]){\n                if(flag[nx][ny] == INF){\n                    F.push_back(INF); F.push_back(INF+1);\n                }else{\n                    F.push_back(flag[nx][ny]);\n                }\n            }\n        }\n        sort(F.begin(),F.end());\n        F.erase(unique(F.begin(),F.end()),F.end());\n        if(F.empty()){\n            flag[x][y] = id++;\n        }else if(F.size() == 1){\n            flag[x][y] = F[0];\n        }else{\n            flag[x][y] = INF;\n            res++;\n        }\n\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nint t[1000][1000];\nint v[1000][1000];\n\nqueue<int> qy,qx;\nint d[1000][1000];\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nint main(){\n  \n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      scanf(\"%d\",&t[i][j]);\n\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n        int y=i+dy[k];\n        int x=j+dx[k];\n        if(y<0||H<=y)continue;\n        if(x<0||W<=x)continue;\n        if(t[i][j]<t[y][x]){\n          v[y][x]++;\n        }\n      }\n    }\n  }\n\n  \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(v[i][j]==0){\n        qy.push(i);\n        qx.push(j);\n        d[i][j]=qy.size();\n      }\n    }\n  }\n  \n  int ans=0;\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if(d[y][x]==-1)ans++;\n    \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||H<=ny)continue;\n      if(nx<0||W<=nx)continue;\n      v[ny][nx]--;\n      if(v[ny][nx]==0){\n        qy.push(ny);\n        qx.push(nx);\n      }\n      if(d[ny][nx]==-1){\n        //continue;\n      }else if(d[ny][nx]==0){\n        d[ny][nx]=d[y][x];\n      }else{\n        d[ny][nx]=(d[ny][nx]==d[y][x]?d[y][x]:-1);\n      }\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint f[1000][1000], dat[1000][1000];\nint x[1000001], y[1000001];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint h, w; scanf(\"%d%d\", &h, &w);\n\trep(i, h)rep(j, w) {\n\t\tscanf(\"%d\", &f[i][j]);\n\t\tx[f[i][j]] = i; y[f[i][j]] = j;\n\t}\n\trep(i, h)rep(j, w) {\n\t\tbool ok = true;\n\t\trep(k, 4) {\n\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&f[nx][ny] < f[i][j])ok = false;\n\t\t}\n\t\tif (ok)dat[i][j] = f[i][j];\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= h*w; i++) {\n\t\trep(j, 4) {\n\t\t\tint nx = x[i] + dx[j], ny = y[i] + dy[j];\n\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&f[x[i]][y[i]] > f[nx][ny]) {\n\t\t\t\tif (dat[x[i]][y[i]] == 0)dat[x[i]][y[i]] = dat[nx][ny];\n\t\t\t\telse if (dat[x[i]][y[i]] != dat[nx][ny])dat[x[i]][y[i]] = -1;\n\t\t\t}\n\t\t}\n\t\tif (dat[x[i]][y[i]] == -1)ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nint m[1020][1020],m1[1020][1020],a,b,e,f;\nint v[4]={-1,0,1,0},t[4]={0,-1,0,1};\nusing namespace std;\nint dfs(int x,int y){\n  int s=0,c=0;\n  rep(i,4){\n    if(0>x+v[i]||b<=x+v[i]||0>y+t[i]||a<=y+t[i])continue;\n    if(m[y][x+v[i]]<m[y][x]||m[y+t[i]][x]<m[y][x]){\n      s+=dfs(x+v[i],y+t[i]);\n      c++;\n    }\n  }\n  if(0>m1[y][x]){\n    if(s>1)return 1;\n    return 0;\n  }\n  if(!c&&!m1[y][x]){\n    m1[y][x]++;\n    return 1;\n  }\n  return s;\n}\nint main(){\n  int sum=0;\n  cin>>a>>b;\n  rep(i,a)rep(j,b)cin>>m[i][j];\n  rep(i,a)rep(j,b){\n    m1[i][j]=-1;\n    sum+=dfs(j,i);\n    rep(z,a)rep(g,b)m1[z][g]=0;\n  }\n  cout<<sum<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\n\nint H, W;\nint d[1010][1010];\nauto isOutOfRange = [](int h, int w, int H, int W) {\n\treturn h < 0 || h >= H || w < 0 || w >= W;\n};\n\nvi memo; //-1:non-used, -2:ok, else:ikisaki \n\nvector<int> es[1010*1010];\n\n\nint dfs(int now) {\n\tif(memo[now] != -1) return memo[now];\n\tint ret = -1;\n\tfor(auto& to : es[now]) {\n\t\tint tmp = dfs(to);\n\t\tif(ret == -1) ret = tmp;\n\t\telse if(ret != tmp) {\n\t\t\treturn memo[now] = -2;\n\t\t}\n\t}\n\treturn memo[now] = (ret == -1 ? now : ret);\n}\n\nint main(){\n\tcin >> H >> W;\n\trep(i, H) rep(j, W) cin >> d[i][j];\n\n\tmemo.clear();\n\tmemo.resize(H*W, -1);\n\t\n\trep(y, H) rep(x, W) {\n\t\tint now = y * W + x;\n\t\trep(i, 4) {\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(isOutOfRange(ny, nx, H, W)) continue;\n\t\t\tint nxt = ny * W + nx;\n\t\t\tif(d[y][x] > d[ny][nx]) es[now].pb(nxt);\n\t\t}\n\t}\n\tdump(H);dump(W);\n\tdump(es[1].size());\n\tLINE;\n\t// rep(i, H) rep(j, W) {\n\t// \tdump(i*W+j);\n\t// \tdfs(i*W+j);\n\t// }\n\tfor(int i = H -1; i >= 0; i--) {\n\t\tfor(int j = W - 1; j >= 0; j--) {\n\t\t\tdump(i*W+j);\n\t\t\tdfs(i*W+j);\n\t\t}\n\t}\n\tLINE;\n\t\n\tint ans = 0;\n\trep(i, memo.size()) if(memo[i] == -2) ans++;\n\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint x[1000000];\nint y[1000000];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nint b[1000][1000];\nint one[1000000];\nint to[1000000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint W, H;\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++) {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tint h;\n\t\t\tcin >> h;\n\t\t\th--;\n\t\t\tb[i][j] = h;\n\t\t\tx[h] = j;\n\t\t\ty[h] = i;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int h = 0; h < H * W; h++) {\n\t\tset<int> s;\n\t\tfor(int k = 0; k < 4; k++) {\n\t\t\tint nx = x[h] + dx[k];\n\t\t\tint ny = y[h] + dy[k];\n\t\t\tif(nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n\t\t\tint th = b[ny][nx];\n\t\t\tif(th < h) {\n\t\t\t\tif(one[th]) one[h] = 1;\n\t\t\t\telse s.insert(to[th]);\n\t\t\t}\n\t\t}\n\t\tif(one[h]) {\n\t\t\tans++;\n\t\t}\n\t\telse {\n\t\t\tif(s.size() == 0) {\n\t\t\t\tto[h] = h;\n\t\t\t}\n\t\t\telse if(s.size() == 1) {\n\t\t\t\tto[h] = *s.begin();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tone[h] = 1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nvoid fanc(int,int,int);\nvoid lo();\nint a,s,d[1001][1001],f,g[4]={0,-1,0,1},h[4]={-1,0,1,0},z,x,c,v,q,w,e,aa,zz;\nint flg[1001][1001];\nint main(void)\n{\n\tint i,j;\n\tscanf(\"%d %d\",&a,&s);\n\tfor(i=0;i<a;i++){\n\t\tfor(j=0;j<s;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tf=0;\n\tw=-1;\n\tfor(i=0;i<a;i++){\n\t\tfor(j=0;j<s;j++){\n\t\t\tfanc(i,j,d[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f);\n\treturn 0;\n}\nvoid fanc(int z,int x,int q)\n{\n\tint i,j;\n\tif(q!=w){\n\t\tw=q;\n\t\tv=0;\n\t\te=0;\n\t\tlo();\n\t}\n\tfor(i=0;i<4;i++){\n\t\tif(z+g[i]<a&&z+g[i]>=0&&d[z+g[i]][x]<d[z][x]){\n\t\t\tif(flg[z+g[i]][x]==0)\n\t\t\t//\tflg[z][x]=0;\n\t\t\t\tflg[z+g[i]][x]=1;\n\t\t\t\tfanc(z+g[i],x,w);\n\t\t}\n\t\tif(x+h[i]<s&&x+h[i]>=0&&d[z][x+h[i]]<d[z][x]){\n\t\t\tif(flg[z][x+h[i]]==0){\n\t\t\t//\tflg[z][x]=0;\n\t\t\t\tflg[z][x+h[i]]=1;\n\t\t\t\tfanc(z,x+h[i],w);\n\t\t\t}\n\t\t}\n\t}\n\taa=0;\n\tzz=0;\n\tfor(i=0;i<a;i++){\n\t\tfor(j=0;j<s;j++){\n\t\t\tif(flg[i][j]==1){\n\t\t\t\tif(i!=a-1) if(d[i][j]>d[i+1][j]) zz=1;\n\t\t\t\tif(j!=s-1) if(d[i][j]>d[i][j+1]) zz=1;\n\t\t\t\tif(i!=0) if(d[i][j]>d[i-1][j]) zz=1;\n\t\t\t\tif(j!=0) if(d[i][j]>d[i][j-1]) zz=1;\n\t\t\t\tif(zz==0){\n\t\t\t\t\tflg[i][j]=2;\n\t\t\t//\t\tprintf(\"%d %d\\n\",w,d[i][j]);\n\t\t\t\t\tv++;\n\t\t\t\t\taa=1;\n\t\t\t\t}\n\t\t\t\telse flg[i][j]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(aa==1) break;\n\t}\n\tif(v>=2&&e==0){\n\t\tf++;\n\t\te=1;\n\t\t//printf(\"%d\\n\",w);\n\t}\n}\nvoid lo(){\n\tint i,j;\n\tfor(i=0;i<a;i++){\n\t\tfor(j=0;j<s;j++) flg[i][j]=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Ridge\n#include <iostream>\n\nusing namespace std;\n\nstatic const int drow[4] = {1, 0, -1, 0};\nstatic const int dcol[4] = {0, 1, 0, -1};\nstatic const int NIL = -1;\nstatic const int RIDGE = -2;\n\nstruct Area {\n    int h, type;\n    Area() {}\n    Area(int h, int type): h(h), type(type) {}\n};\n\n\nint main() {\n    int H, W, h;\n    cin >> H >> W;\n    Area A[H][W];\n    int order[H * W];\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            cin >> h;\n            A[i][j] = Area(h, i * W + j);\n            order[A[i][j].h - 1] = i * W + j;\n        }\n    }\n\n    for(int k = 0; k < H * W; k++) {\n        int i = order[k] / W;\n        int j = order[k] % W;\n        int cnt = 0;\n        int type = NIL;\n        for(int l = 0; l < 4; l++) {\n            int si = i + drow[l];\n            int sj = j + dcol[l];\n            if(si >= 0 && sj >= 0 && si < H && sj < W) {\n                if(A[i][j].h > A[si][sj].h) {\n                    if(A[si][sj].type == RIDGE) {\n                        type = RIDGE;\n                        break;\n                    } else if(type != NIL && type != A[si][sj].type) {\n                        type = RIDGE;\n                        break;\n                    } else {\n                        type = A[si][sj].type;\n                    }\n                }\n            }\n        }\n        if(type != NIL) A[i][j].type = type;\n    }\n\n    int cnt = 0;\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            if(A[i][j].type == RIDGE) cnt++;\n        }\n    }\n\n    cout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\nusing namespace std;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nint h,w,res = 0,pos = 0;\nint field[1000][1000];\nset<int> cnt[1000][1000];\n\nvoid dfs(int x,int y){\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] > field[x][y]){\n\t\t\tif(!cnt[nx][ny].count(pos)) cnt[nx][ny].insert(pos);\n\t\t\tif(cnt[nx][ny].size() < 2) dfs(nx,ny);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) scanf(\"%d\",&field[i][j]);\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\tint nx = i + dx[k],ny = j + dy[k];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] < field[i][j]) flag = false;\n\t\t\t}\n\t\t\tif(flag) dfs(i,j);\n\t\t\tpos++;\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++) if(cnt[i][j].size() >= 2) res++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint a[1000][1000];\t\nint main(void){\n\tint h,w,i,j,c,ans;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++)\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t}\n\tans=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tc=0;\n\t\t\tif(i>0&&a[i][j]>a[i-1][j])\n\t\t\t\tc++;\n\t\t\tif(i<h-1&&a[i][j]>a[i+1][j])\n\t\t\t\tc++;\n\t\t\tif(j>0&&a[i][j]>a[i][j-1])\n\t\t\t\tc++;\n\t\t\tif(j<w-1&&a[i][j]>a[i][j+1])\n\t\t\t\tc++;\n\t\t\tif(c>1)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint wher[1000 * 1000]; // 0-indexed!! n = wa+b\nint caru[1000 * 1000]; // 0-indexed!!\nint roofer[1000 * 1000];\n\nint h, w;\n\nvoid deb(){\n\tint i;\n\tfor (i = 0; i < h * w; i++) {\n\t\tprintf(\"%d: %d\\n\", i, roofer[i]);\n\t}\n\treturn;\n}\n\nint findes(int i, int j, int dest) {\n\tif (i < j || dest == -1 || dest == roofer[j]) return dest;\n\n\tif (dest == i) {\n\t\treturn roofer[j];\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nint solve(){\n\tint i;\n\tint result = 0;\t\n\tfor (i = 0; i < h * w; i++) {\n\t\tint ih, iw, dest = i;\n\t\tih = wher[i] / w;\n\t\tiw = wher[i] % w;\n\t\t\t// printf(\"%2d: \", i);\n\t\tif (ih > 0) {\n\t\t\tint j = caru[wher[i] - w];\n\t\t\tdest = findes(i, j, dest);\n\t\t}\n\t\t\t// printf(\"%2d \", dest);\n\t\tif (ih < h-1) {\n\t\t\tint j = caru[wher[i] + w];\n\t\t\tdest = findes(i, j, dest);\n\t\t}\n\t\t\t// printf(\"%2d \", dest);\n\t\tif (iw > 0) {\n\t\t\tint j = caru[wher[i] - 1];\n\t\t\tdest = findes(i, j, dest);\n\t\t}\n\t\t\t// printf(\"%2d \", dest);\n\t\tif (iw < w-1) {\n\t\t\tint j = caru[wher[i] + 1];\n\t\t\tdest = findes(i, j, dest);\n\t\t}\n\t\t\t// printf(\"%2d\\n\", dest);\n\t\troofer[i] = dest;\n\t\tif (dest == -1) result++;\n\t}\n\n\t// deb();\n\n\treturn (int)printf(\"%d\\n\", result);\n}\n\nint main(void){\n\tint i;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (i = 0; i < h * w; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\twher[x - 1] = i;\n\t\tcaru[i] = x - 1;\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ \t0634: Ridge\n// 2018.1.5 bal4u@uu\n// 解答するプログラムのために考案された問題。高さがすべて異なる？\n// Kヶ所以内に限定すれば、もっと実用的な問題となろう。\n\n#include <stdio.h>\n#include <string.h>\n\nint map[1002][1002];\nint memo[1002][1002];\nint hi2r[1000002], hi2c[1000002];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint h, w, m, i, r, c, r2, c2, f, max, ans;\n\t\n\th = in(), w = in();\n\tmax = 0;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tm = in(); if (m > max) max = m;\n\t\tmap[r][c] = m, hi2r[m] = r, hi2c[m] = c;\n\t}\n\n\tans = 0;\n\tfor (m = 1; m <= max; m++)\n\t{\n\t\tf = 0, r = hi2r[m], c = hi2c[m];\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w) continue;\n\t\t\tif (map[r2][c2] < m) {\n\t\t\t\tif (!f) f = memo[r2][c2];\t\t\t// (r,c)周りの低い区域が１ヶ所だけか\n\t\t\t\telse if (f != memo[r2][c2]) f = -1;\n\t\t\t}\n\t\t}\n\t\tif (f == 0) f = m;\t// (r,c)の周りに低い区域がないケース\n\t\tmemo[r][c] = f;\t\t// (r,c)の周りの低い区域の高さか(r,c)の高さが記録される。\n\t\tif (f < 0) ans++;\t// 複数の低い区域が周りにあるケースでは、尾根とカウントされる。\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nconst int d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nint H, W;\nint M[1024][1024];\n\nint count = 0;\nint counted[1024][1024];\nint visited[1024][1024];\n\nint queue[1024 * 1024][2];\n\nvoid nuru(int sy, int sx, int num) {\n\tint queue_start, queue_end;\n\tint i;\n\tqueue_start = 0;\n\tqueue_end = 1;\n\tqueue[0][0] = sy;\n\tqueue[0][1] = sx;\n\tif (visited[sy][sx] != 0 && counted[sy][sx] == 0) {\n\t\tcount++;\n\t\tcounted[sy][sx] = 1;\n\t}\n\tvisited[sy][sx] = num;\n\twhile (queue_start < queue_end) {\n\t\tint y = queue[queue_start][0];\n\t\tint x = queue[queue_start][1];\n\t\tqueue_start++;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + d[i][0];\n\t\t\tint nx = x + d[i][1];\n\t\t\tif (M[y][x] < M[ny][nx] && visited[ny][nx] != num) {\n\t\t\t\tint already_one = 0;\n\t\t\t\tif (visited[ny][nx] != 0 && counted[ny][nx] == 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tcounted[ny][nx] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (counted[ny][nx]) already_one = 1;\n\t\t\t\t}\n\t\t\t\tvisited[ny][nx] = num;\n\t\t\t\tif (!already_one) {\n\t\t\t\t\tqueue[queue_end][0] = ny;\n\t\t\t\t\tqueue[queue_end][1] = nx;\n\t\t\t\t\tqueue_end++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tint i, j, k;\n\tif (scanf(\"%d%d\", &H, &W) != 2) return 1;\n\tfor (i = 1; i <= H; i++) {\n\t\tfor (j = 1; j <= W; j++) {\n\t\t\tif (scanf(\"%d\", &M[i][j]) != 1) return 1;\n\t\t}\n\t}\n\n\tfor (i = 1; i <= H; i++) {\n\t\tfor (j = 1; j <= W; j++) {\n\t\tint tomatuharuka = 0;\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tint y = i + d[k][0];\n\t\t\t\tint x = j + d[k][1];\n\t\t\t\tif (M[y][x] == 0 || M[i][j] < M[y][x]) {\n\t\t\t\t\ttomatuharuka++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tomatuharuka == 4) {\n\t\t\t\tnuru(i, j, M[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", count);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint dx[9]={0,-1,0,1},dy[9]={-1,0,1,0},hw[1000][1000],cnt,x,y,h,w,fcnt,f[1000][1000];\nvoid func(int y,int x){\n\tint i,xx,yy,flg;\n\tflg=0;\n\tfor(i=0;i<4;i++){\n\t\txx=x+dx[i]; yy=y+dy[i];\n\t\tif(xx<w&&yy<h&&xx>=0&&yy>=0){\n\t\t\tif(hw[yy][xx]<hw[y][x]){\n\t\t\t\tflg=1;\n\t\t\t\tfunc(yy,xx);\n\t\t\t}\n\t\t}\n\t}\n\tif(flg==0&&f[y][x]!=1){\n\t\tf[y][x]=1;\n\t\tfcnt++;\n\t}\n}\nint main(void){\n\tint i,j,ii,jj;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++) scanf(\"%d\",&hw[i][j]);\n\t}\n\tcnt=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tfcnt=0;\n\t\t\tfor(ii=0;ii<h;ii++){\n\t\t\t\tfor(jj=0;jj<w;jj++) f[ii][jj]=0;\n\t\t\t}\n\t\t\tfunc(i,j);\n\t\t\tif(fcnt>=2)\tcnt++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n\tint h,w,a[1000][1000],i,j,c,ans;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++)\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t}\n\tans=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tc=0;\n\t\t\tif(i>0&&a[i][j]>a[i-1][j])\n\t\t\t\tc++;\n\t\t\tif(i<h-1&&a[i][j]>a[i+1][j])\n\t\t\t\tc++;\n\t\t\tif(j>0&&a[i][j]>a[i][j-1])\n\t\t\t\tc++;\n\t\t\tif(j<w-1&&a[i][j]>a[i][j+1])\n\t\t\t\tc++;\n\t\t\tif(c>1)\n\t\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\n\n\nfun main(args: Array<String>?) {\n    fun Pair<Int, Int>.neighbor(): List<Pair<Int, Int>> {\n        return listOf<Pair<Int, Int>>(first + 1 to second, first - 1 to second, first to second + 1, first to second - 1)\n    }\n    val (height, width) = readLine()!!.trim().split(' ').map(String::toInt)\n    val state = Array(height){ readLine()!!.trim().split(' ').map(String::toInt)}\n    val areas = (0 until height).flatMap{y -> (0 until width).map{x -> Pair(y, x)}}.sortedBy { state[it.first][it.second] }\n    val memo = Array(height){Array(width){null as Pair<Int, Int>?} }\n    var count = 0\n    for (current in areas) {\n        val neighbor = current.neighbor().filter{(i, j) -> i in 0 until height && j in 0 until width && state[current.first][current.second] > state[i][j] }.map{(i, j) -> memo[i][j] }\n        if (neighbor.contains(null) || neighbor.distinct().size > 1) {\n            ++count\n        }else {\n            memo[current.first][current.second] = neighbor.firstOrNull() ?: current\n        }\n    }\n    println(count)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint[][] height = new int[h][w];\n\t\t\tint[][] area = new int[h][w];\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\theight[i][j] = sc.nextInt();\n\t\t\t\t\tif (j!=0) {  //横比較\n\t\t\t\t\t\tif (height[i][j-1] > height[i][j]) area[i][j-1]++;\n\t\t\t\t\t\telse area[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t\tif (i!=0) {  //横比較\n\t\t\t\t\t\tif (height[i-1][j] > height[i][j]) area[i-1][j]++;\n\t\t\t\t\t\telse area[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\t//System.out.print(area[i][j] + \"  \");\n\t\t\t\t\tif (area[i][j]>1) {\n\t\t\t\t\t\tint now = area[i][j];\n\t\t\t\t\t\tif (j!=0) {\n\t\t\t\t\t\t\tif (area[i][j-1] == 1) {  //左\n\t\t\t\t\t\t\t\tif (i!=0) {\n\t\t\t\t\t\t\t\t\tif (area[i-1][j]==1) now--;  //上\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (i!=h-1) {\n\t\t\t\t\t\t\t\t\tif (area[i+1][j]==1) now--;  //下\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j!=w-1) {\n\t\t\t\t\t\t\tif (area[i][j+1] == 1) {  //右\n\t\t\t\t\t\t\t\tif (i!=0) {\n\t\t\t\t\t\t\t\t\tif (area[i-1][j]==1) now--;  //上\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (i!=h-1) {\n\t\t\t\t\t\t\t\t\tif (area[i+1][j]==1) now--;  //下\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (now > 1) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic static HashMap<String,String> map = new HashMap<>();\n\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\t\n\t\tint[][] map = new int[H][W];\n\t\tint[] x = new int[H * W];\n\t\tint[] y = new int[H * W];\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tmap[i][j] = sc.nextInt()-1;\n\t\t\t\tx[map[i][j]] = j;\n\t\t\t\ty[map[i][j]] = i;\n\t\t\t}\n\t\t}\n\t\tboolean[][] ok = new boolean[H][W];\n\t\tint[][] last   = new int[H][W];\n\t\tint[] vx = {1,0,-1,0};\n\t\tint[] vy = {0,1,0,-1};\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < H * W; i++) {\n\t\t\tint X = x[i];\n\t\t\tint Y = y[i];\n\t\t\tint pre = -1;\n\t\t\tboolean isOk = false;\n\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\tint tx = X + vx[j];\n\t\t\t\tint ty = Y + vy[j];\n\t\t\t\tif(ty < 0 || tx < 0 || tx >= W || ty >= H) continue;\n\t\t\t\tif(map[ty][tx] < map[Y][X]) {\n\t\t\t\t\tisOk |= ok[ty][tx];\n\t\t\t\t\tif(pre != -1 && pre != last[ty][tx]) isOk = true;\n\t\t\t\t\telse pre = last[ty][tx];\n\t\t\t\t} \n\t\t\t}\n\t\t\tif(isOk) ok[Y][X] = true;\n\t\t\tif(pre == -1) last[Y][X] = i;\n\t\t\telse last[Y][X] = pre;\n\t\t\tif(ok[Y][X]) ans++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package extra;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint[][] height = new int[h][w];\n\t\t\tint[][] area = new int[h][w];\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\theight[i][j] = sc.nextInt();\n\t\t\t\t\tif (j!=0) {  //横比較\n\t\t\t\t\t\tif (height[i][j-1] > height[i][j]) area[i][j-1]++;\n\t\t\t\t\t\telse area[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t\tif (i!=0) {  //横比較\n\t\t\t\t\t\tif (height[i-1][j] > height[i][j]) area[i-1][j]++;\n\t\t\t\t\t\telse area[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\t//System.out.print(area[i][j] + \"  \");\n\t\t\t\t\tif (area[i][j]>1) {\n\t\t\t\t\t\tint now = area[i][j];\n\t\t\t\t\t\tif (j!=0) {\n\t\t\t\t\t\t\tif (area[i][j-1] == 1) {  //左\n\t\t\t\t\t\t\t\tif (i!=0) {\n\t\t\t\t\t\t\t\t\tif (area[i-1][j]==1) now--;  //上\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (i!=h-1) {\n\t\t\t\t\t\t\t\t\tif (area[i+1][j]==1) now--;  //下\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j!=w-1) {\n\t\t\t\t\t\t\tif (area[i][j+1] == 1) {  //右\n\t\t\t\t\t\t\t\tif (i!=0) {\n\t\t\t\t\t\t\t\t\tif (area[i-1][j]==1) now--;  //上\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (i!=h-1) {\n\t\t\t\t\t\t\t\t\tif (area[i+1][j]==1) now--;  //下\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (now > 1) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception{\n        Scanner sc = new Scanner(System.in);\n        int h = sc.nextInt();\n        int w = sc.nextInt();\n        int[][] field = new int[h + 2][w + 2];\n        int[] arr = new int[h * w];\n        for (int i = 0; i < h * w; i++) {\n            int x = sc.nextInt();\n            arr[x - 1] = i;\n        }\n        int count = 0;\n        for (int i = 0; i < h * w; i++) {\n            int hh = arr[i] / w + 1;\n            int ww = arr[i] % w + 1;\n            int[] besides = new int[]{field[hh - 1][ww], field[hh][ww - 1], field[hh + 1][ww], field[hh][ww + 1]};\n            Arrays.sort(besides);\n            if (besides[0] == -1) {\n                field[hh][ww] = -1;\n                count++;\n            } else {\n                int x = besides[0];\n                for (int j = 1; j < 4; j++) {\n                    if (x == 0) {\n                        x = besides[j];\n                    } else {\n                        if (x != besides[j]) {\n                            field[hh][ww] = -1;\n                            count++;\n                            break;\n                        }\n                    }\n                }\n                if (field[hh][ww] == -1) {\n                    continue;\n                }\n                if (x == 0) {\n                    field[hh][ww] = i + 1;\n                } else {\n                    field[hh][ww] = x;\n                }\n            }\n        }\n        System.out.println(count);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint[][] height = new int[h][w];\n\t\t\tint[][] area = new int[h][w];\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\theight[i][j] = sc.nextInt();\n\t\t\t\t\tif (j!=0) {  //横比較\n\t\t\t\t\t\tif (height[i][j-1] > height[i][j]) area[i][j-1]++;\n\t\t\t\t\t\telse area[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t\tif (i!=0) {  //横比較\n\t\t\t\t\t\tif (height[i-1][j] > height[i][j]) area[i-1][j]++;\n\t\t\t\t\t\telse area[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\t//System.out.print(area[i][j] + \"  \");\n\t\t\t\t\tif (area[i][j]>1) {\n                         count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\t\n\t\tint[][] m = new int[h + 2][w+ 2];\n\t\tint[][] fin = new int[h + 2][w + 2];\n\t\tint[] x = new int[h * w + 1];\n\t\tint[] y = new int[h * w + 1];\n\t\tfor(int i = 0; i < h + 2; i++) {\n\t\t\tfor(int j = 0; j < w + 2; j++) {\n\t\t\t\tm[i][j] = 100000000;\n\t\t\t\tfin[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tm[i + 1][j + 1] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= h; i++) {\n\t\t\tfor(int j = 1; j <= w; j++) {\n\t\t\t\tx[m[i][j]] = i;\n\t\t\t\ty[m[i][j]] = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint[] dx = {1, 0, -1, 0};\n\t\tint[] dy = {0, 1, 0, -1};\n\t\tfor(int k = 1; k <= h * w; k++) {\n\t\t\tint r = 0;\n\t\t\tfor(int v = 0; v < 4; v++) {\n\t\t\t\tint nx = x[k] + dx[v];\n\t\t\t\tint ny = y[k] + dy[v];\n\t\t\t\t\n\t\t\t\tif(nx >= 0 && nx <= h && ny >= 0 && ny <= w && m[nx][ny] < k) {\n\t\t\t\t\tif(r == 0) {\n\t\t\t\t\t\tr = fin[nx][ny];\n\t\t\t\t\t}else if(r != fin[nx][ny]) {\n\t\t\t\t\t\tr = -1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(r == 0) {\n\t\t\t\tfin[x[k]][y[k]] = k;\n\t\t\t}else {\n\t\t\t\tfin[x[k]][y[k]] = r;\n\t\t\t}\n\t\t\t\n\t\t\tif(r == -1) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nh, w = gets.split.map(&:to_i)\na = (1..h).map { gets.split.map(&:to_i) }\npos = {}\n(0..h-1).each do |i|\n    (0..w-1).each do |j|\n        pos[a[i][j]] = [i, j]\n    end\nend\n\ngoal = {}\n(1..h*w).each do |k|\n    i, j = pos[k]\n    if i - 1 >= 0 and a[i-1][j] < k\n        goal[k] ||= Set.new\n        goal[k] += goal[a[i-1][j]]\n    end\n    if i + 1 < h and a[i+1][j] < k\n        goal[k] ||= Set.new\n        goal[k] += goal[a[i+1][j]]\n    end\n    if j - 1 >= 0 and a[i][j-1] < k\n        goal[k] ||= Set.new\n        goal[k] += goal[a[i][j-1]]\n    end\n    if j + 1 < w and a[i][j+1] < k\n        goal[k] ||= Set.new\n        goal[k] += goal[a[i][j+1]]\n    end\n    goal[k] ||= Set[k]\nend\n\np goal.select {|_, v| v.size > 1}.size\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.range;\nimport std.typecons;\n\nvoid main(){\n    int h, w;\n    while(~scanf(\"%d%d\", &h, &w)){\n        auto g = new int[][](h, w);\n        alias Tuple!(int,int,int) idx;\n        idx[] ds;\n        foreach(i; 0..h){\n            foreach(j; 0..w){\n                scanf(\"%d\", &g[i][j]);\n                ds ~= idx(g[i][j], i, j);\n            }\n        }\n        sort(ds);\n\n        auto to = new int[][](h, w);\n        foreach(r; to) r[] = -1;\n\n        int ans = 0;\n        foreach(t; ds){\n            int i = t[1], j = t[2];\n            int[] s = [];\n            foreach(d; [[0,1],[0,-1],[1,0],[-1,0]]){\n                int ni = i + d[0];\n                int nj = j + d[1];\n                if(0 <= ni && ni < h && 0 <= nj && nj < w){\n                    if(g[ni][nj] < g[i][j]){\n                        s ~= to[ni][nj];\n                    }\n                }\n            }\n            s = uniq(sort(s)).array;\n            if(s.length == 0){\n                to[i][j] = g[i][j];\n            } else if(s.canFind(-10)){\n                to[i][j] = -10;\n            } else {\n                to[i][j] = s.length == 1 ? s[0] : -10;\n            }\n            ans += to[i][j] == -10;\n        }\n        writeln(ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.range;\nimport std.typecons;\n\nvoid main(){\n    int h, w;\n    while(~scanf(\"%d%d\", &h, &w)){\n        int[1010][1010] to;\n        int[1010][1010] g;\n        alias Tuple!(int,int) idx;\n        idx[] ds;\n        foreach(i; 0..h){\n            foreach(j; 0..w){\n                scanf(\"%d\", &g[i][j]);\n                ds ~= idx(i, j);\n            }\n        }\n        ds.sort!((a, b) => g[a[0]][a[1]] < g[b[0]][b[1]]);\n\n        foreach(r; to) r[] = -1;\n\n        int ans = 0;\n        foreach(t; ds){\n            int i = t[0], j = t[1];\n            int[] s = [];\n            foreach(d; [[0,1],[0,-1],[1,0],[-1,0]]){\n                int ni = i + d[0];\n                int nj = j + d[1];\n                if(0 <= ni && ni < h && 0 <= nj && nj < w){\n                    if(g[ni][nj] < g[i][j]){\n                        s ~= to[ni][nj];\n                    }\n                }\n            }\n            s = uniq(sort(s)).array;\n            if(s.length == 0){\n                to[i][j] = g[i][j];\n            } else if(s.canFind(-10)){\n                to[i][j] = -10;\n            } else {\n                to[i][j] = s.length == 1 ? s[0] : -10;\n            }\n            ans += to[i][j] == -10;\n        }\n        writeln(ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.range;\nimport std.typecons;\n\nvoid main(){\n    int h, w;\n    while(~scanf(\"%d%d\", &h, &w)){\n        auto g = new int[][](h, w);\n        alias Tuple!(int,int) idx;\n        idx[] ds;\n        foreach(i; 0..h){\n            foreach(j; 0..w){\n                scanf(\"%d\", &g[i][j]);\n                ds ~= idx(i, j);\n            }\n        }\n        ds.sort!((a, b) => g[a[0]][a[1]] < g[b[0]][b[1]]);\n\n        auto to = new int[][](h, w);\n        foreach(r; to) r[] = -1;\n\n        foreach(t; ds){\n            int i = t[0], j = t[1];\n            int[] s = [];\n            foreach(d; [[0,1],[0,-1],[1,0],[-1,0]]){\n                int ni = i + d[0];\n                int nj = j + d[1];\n                if(0 <= ni && ni < h && 0 <= nj && nj < w){\n                    if(g[ni][nj] < g[i][j]){\n                        s ~= to[ni][nj];\n                    }\n                }\n            }\n            s = uniq(sort(s)).array;\n            if(s.length == 0){\n                to[i][j] = g[i][j];\n            } else if(s.canFind(-10)){\n                to[i][j] = -10;\n            } else {\n                to[i][j] = s.length == 1 ? s[0] : -10;\n            }\n        }\n        writeln(to.map!((x) => x.count(-10)).sum);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.range;\nimport std.typecons;\n\nvoid main(){\n    int h, w;\n    while(~scanf(\"%d%d\", &h, &w)){\n        auto g = new int[][](h, w);\n        alias Tuple!(int,int) idx;\n        idx[] ds;\n        foreach(i; 0..h){\n            foreach(j; 0..w){\n                scanf(\"%d\", &g[i][j]);\n                ds ~= idx(i, j);\n            }\n        }\n        ds.sort!((a, b) => g[a[0]][a[1]] < g[b[0]][b[1]]);\n\n        auto to = new int[][](h, w);\n        foreach(r; to) r[] = -1;\n\n        int ans = 0;\n        foreach(t; ds){\n            int i = t[0], j = t[1];\n            int[] s = [];\n            foreach(d; [[0,1],[0,-1],[1,0],[-1,0]]){\n                int ni = i + d[0];\n                int nj = j + d[1];\n                if(0 <= ni && ni < h && 0 <= nj && nj < w){\n                    if(g[ni][nj] < g[i][j]){\n                        s ~= to[ni][nj];\n                    }\n                }\n            }\n            s = uniq(sort(s)).array;\n            if(s.length == 0){\n                to[i][j] = g[i][j];\n            } else if(s.canFind(-10)){\n                to[i][j] = -10;\n            } else {\n                to[i][j] = s.length == 1 ? s[0] : -10;\n            }\n            ans += to[i][j] == -10;\n        }\n        writeln(ans);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def check(y,x):\n    if 0<=y<=h-1 and 0<=x<=w-1:\n        return True\n    return False\n\nh,w=map(int,raw_input().split())\ng=[map(int,raw_input().split()) for _ in xrange(h)]\npos=[[] for _ in xrange(h*w)]\nfor i in xrange(h):\n    for j in xrange(w):\n        pos[g[i][j]-1]=[i,j]\n\ndy=(1,0,-1,0)\ndx=(0,1,0,-1)\nstop=[[[] for _ in xrange(w)] for _ in xrange(h)]\nans=0\nfor i in xrange(h*w):\n    y,x=pos[i]\n    for j in xrange(4):\n        ny=y+dy[j];nx=x+dx[j]\n        if check(ny,nx):\n            if g[ny][nx]<g[y][x]:\n                for k in stop[ny][nx]:\n                    stop[y][x].append(k)\n    cnt=len(set(stop[y][x]))\n    if cnt>=2:\n        ans+=1\n    elif cnt==0:\n        stop[y][x].append(g[y][x])\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nM = [None]*(H*W)\nS = [list(map(int, input().split())) for i in range(H)]\nG = [[None]*W for i in range(H)]\nfor i in range(H):\n    s = S[i]\n    for j in range(W):\n        M[s[j]-1] = (i, j)\nD = 0,-1,0,1,0\n\nans = 0\nfor i in range(H*W):\n    y, x = M[i]\n    g = None\n    for k in range(4):\n        nx = x + D[k]; ny = y + D[k+1]\n        if not 0 <= nx < W or not 0 <= ny < H or i+1 < S[ny][nx]:\n            continue\n        if g is None:\n            g = G[ny][nx]\n        elif g != G[ny][nx]:\n            g = -1\n    if g == -1:\n        ans += 1\n    if g is None:\n        G[y][x] = i\n    else:\n        G[y][x] = g\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def check(y,x):\n    if 0<=y<=h-1 and 0<=x<=w-1:\n        return True\n    return False\n\nh,w=map(int,raw_input().split())\ng=[map(int,raw_input().split()) for _ in xrange(h)]\npos=[-1]*(h*w)\nfor i in xrange(h):\n    for j in xrange(w):\n        pos[g[i][j]-1]=[i,j]\n\ndy=(1,0,-1,0)\ndx=(0,1,0,-1)\nstop=[set() for _ in xrange(h*w)]\nans=0\nfor i in xrange(h*w):\n    y,x=pos[i]\n    for j in xrange(4):\n        ny=y+dy[j];nx=x+dx[j]\n        if check(ny,nx):\n            if g[ny][nx]<g[y][x]:\n                stop[i]=stop[i]|stop[g[ny][nx]-1]\n    cnt=len(stop[i])\n    if cnt>=2:\n        ans+=1\n    elif cnt==0:\n        stop[i].add(g[y][x])"
  },
  {
    "language": "Python",
    "code": "def main():\n    dx = [0,1,0,-1]\n    dy = [1,0,-1,0]\n    H,W = map(int,input().split())\n    a = [ list(map(int,input().split())) for _ in range(H) ]\n    b = [ W*[-1] for _ in range(H) ]\n    arr = []\n    for y in range(H):\n        for x in range(W):\n            arr.append((a[y][x],x,y))\n    arr = sorted(arr)\n    ans = 0\n    for i in range(len(arr)):\n        x,y = arr[i][1], arr[i][2]\n        b[y][x] = 0\n        for j in 4*[0]:\n            nx = x + dx[j]\n            ny = y + dy[j]\n            if not ( ( 0 <= nx and nx < W ) and ( 0 <= ny and ny < H ) ):\n                continue\n            if b[ny][nx] != -1:\n                b[y][x] += 1\n        if b[y][x] >= 2:\n            ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef main():\n  INF = 10 ** 7\n  h, w = map(int, input().split())\n  mp = [[INF] + list(map(int, input().split())) + [INF] for _ in range(h)]\n  mp.insert(0, [INF] * (w + 2))\n  mp.append([INF] * (w + 2))\n  ridge = [[None] * (w + 2) for _ in range(h + 2)]\n  vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n  \n  def is_ridge(x, y):\n    to_set = set()\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      temp = ridge[ny][nx]\n      if temp != None:\n        if temp is True:\n          ridge[y][x] = True\n          return True\n        else:\n          to_set.add(temp)\n    \n    if not to_set:\n      ridge[y][x] = (x, y)\n    elif len(to_set) == 1:\n      ridge[y][x] = list(to_set)[0]\n    else:\n      ridge[y][x] = True\n    return ridge[y][x]\n  \n  que = []\n  for y in range(1, h + 1):\n    for x in range(1, w + 1):\n      h = mp[y][x]\n      heappush(que, (h, x, y))\n  \n  ans = 0\n  while que:\n    _, x, y = heappop(que)\n    if is_ridge(x, y) is True:\n      ans += 1\n  print(ans)\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\n\ntmp_list = [list(map(int, input().split())) for i in range(H)]\nans_list = [[None for i in range(W)] for j in range(H)]\n\n\n\n# j: 横方向(0 ~ W-1)\n# i: 縦方向(0 ~ H-1)\ndef search_func(i, j):\n    \n    if not (not ans_list[i][j]):\n        return ans_list[i][j]\n    \n    # print(\"i =\", i, \",j =\", j)\n    # ４方向に探索する。\n    add_list = set()\n    if j != 0 and tmp_list[i][j] > tmp_list[i][j-1]:\n        add_list = add_list.union(search_func(i, j-1))\n    if j != (W-1) and tmp_list[i][j] > tmp_list[i][j+1]:\n        add_list = add_list.union(search_func(i, j+1))\n    if i != 0 and tmp_list[i][j] > tmp_list[i-1][j]:\n        add_list = add_list.union(search_func(i-1, j))\n    if i != (H-1) and tmp_list[i][j] > tmp_list[i+1][j]:\n        add_list = add_list.union(search_func(i+1, j))\n        \n    # ４方向は囲まれていた\n    if not add_list:\n        ans_list[i][j] = set({tmp_list[i][j]})\n    else:\n        ans_list[i][j] = add_list\n    return ans_list[i][j]\n    \n\nsort_list = []\nfor i in range(H):\n    for j in range(W):\n        sort_list.append([tmp_list[i][j], i, j])\n\n# キーにしたがってソートする。\nsort2_list = sorted(sort_list, key=lambda x: x[0])\n\nfinal_ans = 0\nfor item in sort2_list:\n    if len(search_func(item[1], item[2])) > 1:\n        final_ans += 1\nprint(final_ans)\n"
  },
  {
    "language": "Python",
    "code": "def check(y,x):\n    if 0<=y<=h-1 and 0<=x<=w-1:\n        return True\n    return False\n\nh,w=map(int,raw_input().split())\ng=[map(int,raw_input().split()) for _ in xrange(h)]\npos=[-1]*(h*w)\nfor i in xrange(h):\n    for j in xrange(w):\n        pos[g[i][j]-1]=[i,j]\n\ndy=(1,0,-1,0)\ndx=(0,1,0,-1)\nstop=[[] for _ in xrange(h*w)]\nans=0\nfor i in xrange(h*w):\n    y,x=pos[i]\n    for j in xrange(4):\n        ny=y+dy[j];nx=x+dx[j]\n        if check(ny,nx):\n            if g[ny][nx]<g[y][x]:\n                for k in stop[g[ny][nx]-1]:\n                    stop[i].append(k)\n    cnt=len(set(stop[i]))\n    if cnt>=2:\n        ans+=1\n    elif cnt==0:\n        stop[i].append(g[y][x])\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def check(y,x):\n    if 0<=y<=h-1 and 0<=x<=w-1:\n        return True\n    return False\n\nh,w=map(int,raw_input().split())\ng=[map(int,raw_input().split()) for _ in xrange(h)]\npos=[-1]*(h*w)\nfor i in xrange(h):\n    for j in xrange(w):\n        pos[g[i][j]-1]=[i,j]\n\ndy=(1,0,-1,0)\ndx=(0,1,0,-1)\nstop=[set() for _ in xrange(h*w)]\nans=0\nfor i in xrange(h*w):\n    y,x=pos[i]\n    for j in xrange(4):\n        ny=y+dy[j];nx=x+dx[j]\n        if check(ny,nx):\n            if g[ny][nx]<g[y][x]:\n                stop[i]=stop[i]|stop[g[ny][nx]-1]\n    cnt=len(stop[i])\n    if cnt>=2:\n        ans+=1\n    elif cnt==0:\n        stop[i].add(g[y][x])\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def check(y,x):\n    if 0<=y<=h-1 and 0<=x<=w-1:\n        return True\n    return False\n\nh,w=map(int,raw_input().split())\ng=[map(int,raw_input().split()) for _ in xrange(h)]\npos=[-1]*(h*w)\nfor i in xrange(h):\n    for j in xrange(w):\n        pos[g[i][j]-1]=[i,j]\n\ndy=(1,0,-1,0)\ndx=(0,1,0,-1)\nstop=[set() for _ in xrange(h*w)]\nans=0\nfor i in xrange(h*w):\n    y,x=pos[i]\n    for j in xrange(4):\n        ny=y+dy[j];nx=x+dx[j]\n        if check(ny,nx):\n            if g[ny][nx]<g[y][x]:\n                for k in list(stop[g[ny][nx]-1]):\n                    stop[i].add(k)\n    cnt=len(stop[i])\n    if cnt>=2:\n        ans+=1\n    elif cnt==0:\n        stop[i].add(g[y][x])\n\nprint(ans)"
  }
]