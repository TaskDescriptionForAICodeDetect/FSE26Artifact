[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int i, j;\n} Point;\n\nint H, W;\nint M[1001][1001];\nbool visited[1001][1001];\nint basins[1001][1001];\nPoint sorted[1000001];\nint di[] = {-1, 1, 0, 0};\nint dj[] = {0, 0, -1, 1};\n\nint compare(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return M[p2->i][p2->j] - M[p1->i][p1->j];\n}\n\nvoid dfs(int i, int j, int basin) {\n    if (visited[i][j]) return;\n    visited[i][j] = true;\n    basins[i][j] = basin;\n    for (int d = 0; d < 4; d++) {\n        int ni = i + di[d];\n        int nj = j + dj[d];\n        if (ni >= 1 && ni <= H && nj >= 1 && nj <= W && M[ni][nj] < M[i][j]) {\n            dfs(ni, nj, basin);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    int index = 0;\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            scanf(\"%d\", &M[i][j]);\n            sorted[index].i = i;\n            sorted[index].j = j;\n            index++;\n        }\n    }\n    qsort(sorted, H * W, sizeof(Point), compare);\n    for (int k = 0; k < H * W; k++) {\n        int i = sorted[k].i;\n        int j = sorted[k].j;\n        if (!visited[i][j]) {\n            dfs(i, j, k);\n        }\n    }\n    bool isRidge[1000001] = {false};\n    int count = 0;\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            int basin = basins[i][j];\n            if (!isRidge[basin]) {\n                bool hasMultiple = false;\n                for (int d = 0; d < 4; d++) {\n                    int ni = i + di[d];\n                    int nj = j + dj[d];\n                    if (ni >= 1 && ni <= H && nj >= 1 && nj <= W && M[ni][nj] < M[i][j]) {\n                        if (basins[ni][nj] != basin) {\n                            hasMultiple = true;\n                            break;\n                        }\n                    }\n                }\n                if (hasMultiple) {\n                    isRidge[basin] = true;\n                    count++;\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:53:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Ridge {\n    static int H, W;\n    static int[][] elevation;\n    static boolean[][] visited;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        H = Integer.parseInt(st.nextToken());\n        W = Integer.parseInt(st.nextToken());\n        \n        elevation = new int[H][W];\n        \n        for (int i = 0; i < H; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < W; j++) {\n                elevation[i][j] = Integer.parseInt(st.nextToken());\n            }\n        }\n        \n        int ridgeCount = 0;\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (isRidge(i, j)) {\n                    ridgeCount++;\n                }\n            }\n        }\n        \n        System.out.println(ridgeCount);\n    }\n    \n    static boolean isRidge(int startX, int startY) {\n        visited = new boolean[H][W];\n        Set<Integer> accumulationRegions = new HashSet<>();\n        \n        dfs(startX, startY, elevation[startX][startY], accumulationRegions);\n        \n        return accumulationRegions.size() > 1;\n    }\n    \n    static void dfs(int x, int y, int initialElevation, Set<Integer> accumulationRegions) {\n        visited[x][y] = true;\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            \n            if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n                if (!visited[nx][ny]) {\n                    if (elevation[nx][ny] < initialElevation) {\n                        dfs(nx, ny, initialElevation, accumulationRegions);\n                    } else if (elevation[nx][ny] == initialElevation) {\n                        continue;\n                    } else {\n                        accumulationRegions.add(elevation[nx][ny]);\n                    }\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:53:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int H, W;\n    cin >> H >> W;\n    vector<vector<int>> M(H, vector<int>(W));\n    vector<pair<int, pair<int, int>>> cells;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> M[i][j];\n            cells.emplace_back(M[i][j], make_pair(i, j));\n        }\n    }\n\n    sort(cells.rbegin(), cells.rend());\n\n    vector<vector<int>> parent(H, vector<int>(W, -1));\n    vector<vector<int>> size(H, vector<int>(W, 1));\n    vector<vector<bool>> is_ridge(H, vector<bool>(W, false));\n\n    for (const auto &cell : cells) {\n        int val = cell.first;\n        int x = cell.second.first;\n        int y = cell.second.second;\n        vector<pair<int, int>> neighbors;\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && M[nx][ny] < val) {\n                neighbors.emplace_back(nx, ny);\n            }\n        }\n\n        if (neighbors.empty()) {\n            parent[x][y] = x * W + y;\n        } else {\n            int min_val = M[neighbors[0].first][neighbors[0].second];\n            pair<int, int> min_pos = neighbors[0];\n            for (const auto &p : neighbors) {\n                if (M[p.first][p.second] < min_val) {\n                    min_val = M[p.first][p.second];\n                    min_pos = p;\n                }\n            }\n            parent[x][y] = parent[min_pos.first][min_pos.second];\n            size[min_pos.first][min_pos.second] += size[x][y];\n        }\n    }\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            int root = parent[i][j];\n            int root_x = root / W;\n            int root_y = root % W;\n            if (root_x == i && root_y == j) {\n                is_ridge[i][j] = (size[i][j] > 1);\n            }\n        }\n    }\n\n    int result = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (is_ridge[i][j]) {\n                result++;\n            }\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:54:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 1000\n\nint H, W;\nint elevation[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\nbool water_accumulated[MAX_SIZE][MAX_SIZE];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid reset_visited() {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            visited[i][j] = false;\n            water_accumulated[i][j] = false;\n        }\n    }\n}\n\nvoid dfs(int x, int y, int rain_x, int rain_y) {\n    visited[x][y] = true;\n    \n    for (int k = 0; k < 4; k++) {\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n        \n        if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n            if (!visited[nx][ny] && elevation[nx][ny] < elevation[rain_x][rain_y]) {\n                dfs(nx, ny, rain_x, rain_y);\n            }\n            \n            if (elevation[nx][ny] < elevation[rain_x][rain_y]) {\n                water_accumulated[nx][ny] = true;\n            }\n        }\n    }\n}\n\nbool is_ridge(int x, int y) {\n    reset_visited();\n    dfs(x, y, x, y);\n    \n    int accumulated_count = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (water_accumulated[i][j]) {\n                accumulated_count++;\n            }\n        }\n    }\n    \n    return accumulated_count > 1;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &elevation[i][j]);\n        }\n    }\n    \n    int ridge_count = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (is_ridge(i, j)) {\n                ridge_count++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", ridge_count);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:54:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\n\nbool isRidge(vector<vector<int>>& grid, int sx, int sy) {\n    int H = grid.size();\n    int W = grid[0].size();\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    vector<vector<bool>> waterAccumulated(H, vector<bool>(W, false));\n    int accumulationCount = 0;\n\n    queue<pair<int, int>> q;\n    q.push({sx, sy});\n    visited[sx][sy] = true;\n\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n\n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny]) {\n                if (grid[nx][ny] < grid[x][y]) {\n                    q.push({nx, ny});\n                    visited[nx][ny] = true;\n                } else if (grid[nx][ny] >= grid[x][y]) {\n                    waterAccumulated[nx][ny] = true;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            if (waterAccumulated[i][j])\n                accumulationCount++;\n\n    return accumulationCount > 1;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<int>> grid(H, vector<int>(W));\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            cin >> grid[i][j];\n\n    int ridgeCount = 0;\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            if (isRidge(grid, i, j))\n                ridgeCount++;\n\n    cout << ridgeCount << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:55:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Ridge {\n    static int H, W;\n    static int[][] grid;\n    static int[][] parent;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n\n    static class Region {\n        int x, y, val;\n        Region(int x, int y, int val) {\n            this.x = x;\n            this.y = y;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        H = Integer.parseInt(st.nextToken());\n        W = Integer.parseInt(st.nextToken());\n        grid = new int[H][W];\n        parent = new int[H][W];\n        List<Region> regions = new ArrayList<>();\n\n        for (int i = 0; i < H; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = Integer.parseInt(st.nextToken());\n                regions.add(new Region(i, j, grid[i][j]));\n                parent[i][j] = i * W + j;\n            }\n        }\n\n        Collections.sort(regions, (a, b) -> Integer.compare(b.val, a.val));\n\n        for (Region r : regions) {\n            int x = r.x;\n            int y = r.y;\n            int minVal = Integer.MAX_VALUE;\n            List<int[]> candidates = new ArrayList<>();\n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] < grid[x][y]) {\n                    if (grid[nx][ny] < minVal) {\n                        minVal = grid[nx][ny];\n                        candidates.clear();\n                        candidates.add(new int[]{nx, ny});\n                    } else if (grid[nx][ny] == minVal) {\n                        candidates.add(new int[]{nx, ny});\n                    }\n                }\n            }\n            if (!candidates.isEmpty()) {\n                for (int[] cand : candidates) {\n                    union(x, y, cand[0], cand[1]);\n                }\n            }\n        }\n\n        int[] count = new int[H * W];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                count[find(i, j)]++;\n            }\n        }\n\n        int result = 0;\n        for (Region r : regions) {\n            int root = find(r.x, r.y);\n            if (count[root] > 1) {\n                result++;\n            }\n        }\n        System.out.println(result);\n    }\n\n    static int find(int x, int y) {\n        int pos = x * W + y;\n        while (parent[x][y] != pos) {\n            pos = parent[x][y];\n            x = pos / W;\n            y = pos % W;\n        }\n        return pos;\n    }\n\n    static void union(int x1, int y1, int x2, int y2) {\n        int root1 = find(x1, y1);\n        int root2 = find(x2, y2);\n        if (root1 != root2) {\n            int r1x = root1 / W;\n            int r1y = root1 % W;\n            parent[r1x][r1y] = root2;\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:55:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ridge_regions(H, W, matrix):\n    from collections import deque\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def bfs(r, c):\n        queue = deque([(r, c)])\n        visited = set([(r, c)])\n        borders = set()\n        \n        while queue:\n            cr, cc = queue.popleft()\n            for dr, dc in directions:\n                nr, nc = cr + dr, cc + dc\n                if 0 <= nr < H and 0 <= nc < W:\n                    if (nr, nc) not in visited:\n                        if matrix[nr][nc] < matrix[r][c]:\n                            queue.append((nr, nc))\n                            visited.add((nr, nc))\n                            if (nr, nc) not in borders:\n                                borders.add((nr, nc))\n                        elif matrix[nr][nc] > matrix[r][c]:\n                            borders.add((cr, cc))\n        \n        return len(borders)\n\n    ridge_count = 0\n\n    for i in range(H):\n        for j in range(W):\n            if bfs(i, j) > 1:\n                ridge_count += 1\n\n    return ridge_count\n\n\nH, W = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(H)]\n\nresult = count_ridge_regions(H, W, matrix)\nprint(result)",
    "timestamp": "2025-08-13 01:20:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class RidgeCalculator {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int H = Integer.parseInt(st.nextToken());\n        int W = Integer.parseInt(st.nextToken());\n        \n        int[][] elevation = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < W; j++) {\n                elevation[i][j] = Integer.parseInt(st.nextToken());\n            }\n        }\n        \n        int ridgeCount = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (isRidge(elevation, H, W, i, j)) {\n                    ridgeCount++;\n                }\n            }\n        }\n        \n        System.out.println(ridgeCount);\n    }\n\n    private static boolean isRidge(int[][] elevation, int H, int W, int i, int j) {\n        int currentElevation = elevation[i][j];\n        boolean[][] visited = new boolean[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[] { i, j });\n        visited[i][j] = true;\n        \n        Set<int[]> accumulationRegions = new HashSet<>();\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int row = curr[0];\n            int col = curr[1];\n            \n            for (int[] dir : new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } }) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n                \n                if (newRow >= 0 && newRow < H && newCol >= 0 && newCol < W && !visited[newRow][newCol]) {\n                    visited[newRow][newCol] = true;\n                    if (elevation[newRow][newCol] < currentElevation) {\n                        queue.add(new int[] { newRow, newCol });\n                    }\n                    accumulationRegions.add(new int[] { newRow, newCol });\n                }\n            }\n        }\n        \n        return accumulationRegions.size() > 1;\n    }\n}",
    "timestamp": "2025-08-13 01:20:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint H, W;\nint elevations[1000][1000];\nint visited[1000][1000];\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nvoid find_accumulation_regions(int i, int j, int init_height, int *accum_count) {\n    visited[i][j] = 1;\n    \n    for (int d = 0; d < 4; d++) {\n        int ni = i + dx[d], nj = j + dy[d];\n        \n        if (ni >= 0 && ni < H && nj >= 0 && nj < W && !visited[ni][nj]) {\n            if (elevations[ni][nj] < init_height) {\n                if (!visited[ni][nj]) {\n                    find_accumulation_regions(ni, nj, init_height, accum_count);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &elevations[i][j]);\n        }\n    }\n    \n    int ridge_count = 0;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int accum_regions = 0;\n            \n            // Reset visited\n            for (int x = 0; x < H; x++) {\n                for (int y = 0; y < W; y++) {\n                    visited[x][y] = 0;\n                }\n            }\n            \n            // Start DFS flood simulation\n            find_accumulation_regions(i, j, elevations[i][j], &accum_regions);\n            \n            // Count regions where water would accumulate\n            for (int x = 0; x < H; x++) {\n                for (int y = 0; y < W; y++) {\n                    if (visited[x][y] && elevations[x][y] < elevations[i][j]) {\n                        accum_regions++;\n                    }\n                }\n            }\n            \n            // Check if it's a ridge\n            if (accum_regions >= 2) {\n                ridge_count++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", ridge_count);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 01:20:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_ridge(grid, h, w, row, col):\n    original_height = grid[row][col]\n    water_source_regions = set([(row, col)])\n    accumulated_regions = set()\n    \n    def trace_water(r, c, visited):\n        visited.add((r, c))\n        directions = [(0,1), (0,-1), (1,0), (-1,0)]\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w:\n                if grid[nr][nc] < original_height and (nr, nc) not in visited:\n                    trace_water(nr, nc, visited)\n                elif grid[nr][nc] < original_height:\n                    accumulated_regions.add((nr, nc))\n    \n    trace_water(row, col, water_source_regions)\n    return len(accumulated_regions) > 1\n\ndef solve_ridge(h, w, grid):\n    ridge_count = 0\n    for i in range(h):\n        for j in range(w):\n            if is_ridge(grid, h, w, i, j):\n                ridge_count += 1\n    return ridge_count\n\ndef main():\n    h, w = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(h)]\n    print(solve_ridge(h, w, grid))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:20:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = []\n    pos_map = {}\n    for i in range(H):\n        row = list(map(int, sys.stdin.readline().split()))\n        grid.append(row)\n        for j in range(W):\n            pos_map[grid[i][j]] = (i, j)\n    \n    sorted_heights = sorted(pos_map.keys(), reverse=True)\n    \n    parent = {}\n    size = {}\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            if size[root_u] > size[root_v]:\n                parent[root_v] = root_u\n                size[root_u] += size[root_v]\n            else:\n                parent[root_u] = root_v\n                size[root_v] += size[root_u]\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    ridge_count = 0\n    \n    for height in sorted_heights:\n        i, j = pos_map[height]\n        parent[(i, j)] = (i, j)\n        size[(i, j)] = 1\n        neighbors = set()\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] > height:\n                neighbors.add(find((ni, nj)))\n        if not neighbors:\n            pass  # no merging needed\n        else:\n            root_list = list(neighbors)\n            for root in root_list[1:]:\n                union(root_list[0], root)\n            if size[find(root_list[0])] > 1:\n                ridge_count += 1\n    \n    print(ridge_count)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 01:21:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint H,W;\n\nbool isRidge(int r, int c, vector<vector<int>> &elevation) {\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    visited[r][c] = true;\n\n    queue<pair<int,int>> q;\n    q.push({r, c});\n\n    int accumulations = 0;\n    while (!q.empty()) {\n        auto current = q.front(); q.pop();\n        int cr = current.first;\n        int cc = current.second;\n\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (auto &dir : directions) {\n            int nr = cr + dir.first;\n            int nc = cc + dir.second;\n            if (nr >= 0 && nr < H && nc >= 0 && nc < W) {\n                if (elevation[nr][nc] > elevation[cr][cc] && !visited[nr][nc]) {\n                    visited[nr][nc] = true;\n                    q.push({nr, nc});\n                } else if (elevation[nr][nc] < elevation[cr][cc] && !visited[nr][nc]) {\n                    visited[nr][nc] = true;\n                    accumulations++;\n                }\n            }\n        }\n    }\n\n    return accumulations > 1;\n}\n\nint main() {\n    cin >> H >> W;\n\n    vector<vector<int>> elevation(H, vector<int>(W));\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> elevation[i][j];\n        }\n    }\n\n    int ridgeCount = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (isRidge(i, j, elevation)) {\n                ridgeCount++;\n            }\n        }\n    }\n\n    cout << ridgeCount << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:59:43"
  }
]