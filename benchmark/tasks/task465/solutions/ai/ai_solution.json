[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_M 50\n#define MAX_N 50\n\nint m, n;\nint initial_state[MAX_M];\nint final_state[MAX_M];\nint switch_ops[MAX_N];\nint mapping[MAX_N];\n\nchar base36_char(int num) {\n    if (num < 10) return num + '0';\n    return (num - 10) + 'A';\n}\n\nbool solve() {\n    for (int i = 0; i < n; i++) mapping[i] = -1;\n    \n    for (int i = 0; i < m; i++) {\n        bool possible_switches[MAX_N];\n        memset(possible_switches, 0, sizeof(possible_switches));\n        \n        for (int j = 0; j < n; j++) {\n            if ((final_state[i] != initial_state[i]) == \n                ((switch_ops[j] & (1 << i)) > 0)) {\n                possible_switches[j] = true;\n            }\n        }\n        \n        int matched_switches = 0;\n        int match_index = -1;\n        for (int j = 0; j < n; j++) {\n            if (possible_switches[j]) {\n                matched_switches++;\n                match_index = j;\n            }\n        }\n        \n        if (matched_switches == 1) {\n            if (mapping[match_index] != -1 && mapping[match_index] != i) \n                return false;\n            mapping[match_index] = i;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    while (datasets--) {\n        scanf(\"%d %d\", &m, &n);\n        \n        for (int i = 0; i < m; i++)\n            scanf(\"%d\", &initial_state[i]);\n        \n        for (int i = 0; i < m; i++)\n            scanf(\"%d\", &final_state[i]);\n        \n        memset(switch_ops, 0, sizeof(switch_ops));\n        \n        for (int i = 0; i < n; i++) {\n            int k;\n            scanf(\"%d\", &k);\n            for (int j = 0; j < k; j++) {\n                int bulb;\n                scanf(\"%d\", &bulb);\n                switch_ops[i] |= (1 << (bulb - 1));\n            }\n        }\n        \n        if (solve()) {\n            for (int i = 0; i < n; i++) {\n                if (mapping[i] == -1)\n                    printf(\"?\");\n                else \n                    printf(\"%c\", base36_char(mapping[i]));\n            }\n            printf(\"\\n\");\n        } else {\n            for (int i = 0; i < n; i++)\n                printf(\"?\");\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_SWITCHES 50\n#define MAX_BULBS 1000\n#define MAX_OPERATIONS 100\n\nint M, N, K;\nint operations[MAX_OPERATIONS][MAX_SWITCHES]; // K operations, each is a bitmask of switches\nint bulb_states[MAX_OPERATIONS][MAX_BULBS];   // K observations, each is a bitmask of bulb states\nint known[MAX_BULBS];                         // known[i] is the switch controlling bulb i (or -1 if unknown)\nint possible[MAX_BULBS][MAX_SWITCHES];        // possible[i][j] is 1 if switch j can control bulb i\n\nvoid solve_dataset() {\n    int i, j, k;\n    memset(known, -1, sizeof(known));\n    memset(possible, 0, sizeof(possible));\n\n    // Initialize possible: all switches are possible for all bulbs\n    for (i = 0; i < M; i++) {\n        for (j = 0; j < N; j++) {\n            possible[i][j] = 1;\n        }\n    }\n\n    // Process each operation\n    for (k = 0; k < K; k++) {\n        int *op = operations[k];\n        int *state = bulb_states[k];\n\n        for (i = 0; i < M; i++) {\n            int expected = 0;\n            for (j = 0; j < N; j++) {\n                if (op[j]) {\n                    expected ^= possible[i][j];\n                }\n            }\n            if (expected != (state[i] & 1)) {\n                for (j = 0; j < N; j++) {\n                    if (op[j]) {\n                        possible[i][j] = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    // Determine known switches\n    for (i = 0; i < M; i++) {\n        int count = 0;\n        int last = -1;\n        for (j = 0; j < N; j++) {\n            if (possible[i][j]) {\n                count++;\n                last = j;\n            }\n        }\n        if (count == 1) {\n            known[i] = last;\n        }\n    }\n\n    // Output the result in base-36\n    for (i = 0; i < M; i++) {\n        if (known[i] != -1) {\n            if (known[i] < 10) {\n                printf(\"%c\", '0' + known[i]);\n            } else {\n                printf(\"%c\", 'a' + (known[i] - 10));\n            }\n        } else {\n            printf(\"?\");\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    while (scanf(\"%d %d %d\", &N, &M, &K) == 3) {\n        if (N == 0 && M == 0 && K == 0) break;\n\n        memset(operations, 0, sizeof(operations));\n        memset(bulb_states, 0, sizeof(bulb_states));\n\n        for (int k = 0; k < K; k++) {\n            char op_str[MAX_SWITCHES + 1];\n            scanf(\"%s\", op_str);\n            for (int j = 0; j < N; j++) {\n                operations[k][j] = (op_str[j] == '1');\n            }\n\n            char state_str[MAX_BULBS + 1];\n            scanf(\"%s\", state_str);\n            for (int i = 0; i < M; i++) {\n                bulb_states[k][i] = (state_str[i] == '1');\n            }\n        }\n\n        solve_dataset();\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nint to_int(char c) {\n    if (c >= '0' && c <= '9') return c - '0';\n    return c - 'a' + 10;\n}\n\nchar to_char(int x) {\n    if (x < 10) return '0' + x;\n    return 'a' + (x - 10);\n}\n\nvoid solve() {\n    int M, N, O, P;\n    while (cin >> M >> N >> O >> P, M) {\n        vector<vector<bool>> operations(O, vector<bool>(N));\n        vector<vector<bool>> states(O, vector<bool>(M));\n        \n        for (int i = 0; i < O; ++i) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < N; ++j) {\n                operations[i][j] = (s[j] == '1');\n            }\n            cin >> s;\n            for (int j = 0; j < M; ++j) {\n                states[i][j] = (s[j] == '1');\n            }\n        }\n        \n        vector<int> bulb_to_switch(M, -1);\n        vector<bool> determined(M, false);\n        \n        for (int b = 0; b < M; ++b) {\n            vector<int> candidates;\n            for (int s = 0; s < N; ++s) {\n                bool ok = true;\n                for (int i = 0; i < O; ++i) {\n                    bool expected = operations[i][s] ? !states[i][b] : states[i][b];\n                    bool actual = (i == 0) ? false : states[i-1][b];\n                    if (expected != actual) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) {\n                    candidates.push_back(s);\n                }\n            }\n            if (candidates.size() == 1) {\n                bulb_to_switch[b] = candidates[0];\n                determined[b] = true;\n            }\n        }\n        \n        string ans;\n        for (int b = 0; b < M; ++b) {\n            if (determined[b]) {\n                ans += to_char(bulb_to_switch[b]);\n            } else {\n                ans += '?';\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class LightBulbsAndSwitches {\n    static final int MAX_M = 100;\n    static final int MAX_N = 100;\n    static final int MAX_O = 1000;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null) {\n            if (line.trim().isEmpty()) continue;\n            StringTokenizer st = new StringTokenizer(line);\n            int M = Integer.parseInt(st.nextToken());\n            int N = Integer.parseInt(st.nextToken());\n            if (M == 0 && N == 0) break;\n\n            int O = Integer.parseInt(br.readLine().trim());\n            boolean[][] operations = new boolean[O][N];\n            for (int i = 0; i < O; i++) {\n                String op = br.readLine().trim();\n                for (int j = 0; j < N; j++) {\n                    operations[i][j] = op.charAt(j) == '1';\n                }\n            }\n\n            int B = Integer.parseInt(br.readLine().trim());\n            boolean[][] bulbs = new boolean[B][M];\n            for (int i = 0; i < B; i++) {\n                String bulb = br.readLine().trim();\n                for (int j = 0; j < M; j++) {\n                    bulbs[i][j] = bulb.charAt(j) == '1';\n                }\n            }\n\n            int[][] possible = new int[M][N];\n            for (int i = 0; i < M; i++) {\n                Arrays.fill(possible[i], 1);\n            }\n\n            for (int i = 0; i < M; i++) {\n                for (int j = 0; j < N; j++) {\n                    for (int k = 0; k < B; k++) {\n                        boolean expected = bulbs[k][i];\n                        boolean actual = false;\n                        for (int l = 0; l < N; l++) {\n                            if (operations[k][l]) {\n                                actual ^= (possible[i][l] == 1);\n                            }\n                        }\n                        if (actual != expected) {\n                            possible[i][j] = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            for (int i = 0; i < M; i++) {\n                int count = 0;\n                int last = -1;\n                for (int j = 0; j < N; j++) {\n                    if (possible[i][j] == 1) {\n                        count++;\n                        last = j;\n                    }\n                }\n                if (count == 1) {\n                    System.out.print(toBase36(last));\n                } else {\n                    System.out.print(\"?\");\n                }\n            }\n            System.out.println();\n        }\n    }\n\n    private static char toBase36(int num) {\n        if (num < 10) {\n            return (char) ('0' + num);\n        } else {\n            return (char) ('A' + num - 10);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:48:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LightBulbSwitchMapping {\n    public static void solve(int m, int n, List<String> operations) {\n        boolean[][] switchControl = new boolean[n][m];\n        boolean[] initialState = new boolean[m];\n        boolean[] finalState = new boolean[m];\n\n        // Parse initial state and final state\n        for (String op : operations) {\n            String[] parts = op.split(\" \");\n            int switchIndex = Integer.parseInt(parts[0]) - 1;\n            \n            for (int j = 1; j < parts.length; j++) {\n                int bulbIndex = Integer.parseInt(parts[j]) - 1;\n                switchControl[switchIndex][bulbIndex] = true;\n            }\n\n            if (parts[0].startsWith(\"-\")) {\n                // Initial state\n                for (int j = 1; j < parts.length; j++) {\n                    initialState[Integer.parseInt(parts[j]) - 1] = true;\n                }\n            } else {\n                // Final state\n                for (int j = 1; j < parts.length; j++) {\n                    finalState[Integer.parseInt(parts[j]) - 1] = true;\n                }\n            }\n        }\n\n        char[] result = new char[m];\n        Arrays.fill(result, '?');\n\n        for (int i = 0; i < m; i++) {\n            List<Integer> possibleSwitches = new ArrayList<>();\n            \n            for (int j = 0; j < n; j++) {\n                if (switchControl[j][i]) {\n                    if (initialState[i] ^ finalState[i]) {\n                        possibleSwitches.add(j);\n                    }\n                }\n            }\n\n            if (possibleSwitches.size() == 1) {\n                result[i] = toBase36(possibleSwitches.get(0));\n            }\n        }\n\n        System.out.println(new String(result));\n    }\n\n    private static char toBase36(int num) {\n        if (num < 10) {\n            return (char) ('0' + num);\n        }\n        return (char) ('A' + num - 10);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int datasets = scanner.nextInt();\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            int m = scanner.nextInt();\n            int n = scanner.nextInt();\n            int k = scanner.nextInt();\n            scanner.nextLine();\n\n            List<String> operations = new ArrayList<>();\n            for (int i = 0; i < k; i++) {\n                operations.add(scanner.nextLine());\n            }\n\n            solve(m, n, operations);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:48:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\nstring base36Encode(int num) {\n    const string base36 = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    string result;\n    while (num > 0) {\n        result = base36[num % 36] + result;\n        num /= 36;\n    }\n    return result.empty() ? \"0\" : result;\n}\n\nvoid solveDataset() {\n    int M, N, K;\n    cin >> M >> N >> K;\n\n    vector<bitset<100>> switchState(N);\n    vector<bitset<100>> bulbState(M);\n    \n    for (int i = 0; i < K; i++) {\n        string operation;\n        cin >> operation;\n        \n        bitset<100> currentSwitchState;\n        for (int j = 0; j < N; j++) {\n            if (operation[j] == '1') {\n                currentSwitchState[j] = 1;\n            }\n        }\n        \n        string resultBulbs;\n        cin >> resultBulbs;\n        \n        bitset<100> currentBulbState;\n        for (int j = 0; j < M; j++) {\n            if (resultBulbs[j] == '1') {\n                currentBulbState[j] = 1;\n            }\n        }\n        \n        switchState[i] = currentSwitchState;\n        bulbState[i] = currentBulbState;\n    }\n    \n    vector<vector<int>> controlMap(N, vector<int>(M, 0));\n    \n    for (int j = 0; j < M; j++) {\n        vector<int> possibleSwitches;\n        \n        for (int i = 0; i < N; i++) {\n            bool validSwitch = true;\n            for (int k = 0; k < K; k++) {\n                bool expectedState = bulbState[k][j] ^ switchState[k][i];\n                if (expectedState != bulbState[k][j]) {\n                    validSwitch = false;\n                    break;\n                }\n            }\n            \n            if (validSwitch) {\n                possibleSwitches.push_back(i);\n            }\n        }\n        \n        if (possibleSwitches.size() == 1) {\n            controlMap[possibleSwitches[0]][j] = 1;\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        bool hasSwitchControl = false;\n        for (int j = 0; j < M; j++) {\n            if (controlMap[i][j]) {\n                cout << base36Encode(j + 1);\n                hasSwitchControl = true;\n                break;\n            }\n        }\n        \n        if (!hasSwitchControl) {\n            cout << \"?\";\n        }\n    }\n    cout << endl;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    while (T--) {\n        solveDataset();\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_input(input_data):\n    datasets = input_data.strip().split(\"\\n\\n\")\n    parsed_datasets = []\n    for dataset in datasets:\n        lines = dataset.strip().split(\"\\n\")\n        M, N = map(int, lines[0].split())\n        operations = []\n        state_logs = []\n        for line in lines[1:]:\n            if 'S' in line:\n                operations.append(int(line.split()[1]) - 1)\n            elif 'B' in line:\n                state_logs.append(line.split()[1])\n        parsed_datasets.append((M, N, operations, state_logs))\n    return parsed_datasets\n\ndef deduce_correspondence(M, N, operations, state_logs):\n    base36_table = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    unknown = '?'\n    \n    if not operations or not state_logs:\n        return [unknown] * M\n\n    current_state = [False] * M\n    logs = [list(map(lambda x: x == '1', list(log))) for log in state_logs]\n    correspondence = [unknown] * M\n\n    for i in range(N):\n        if operations[i] < len(logs):\n            toggle_effect = logs[i]\n            for bulb in range(M):\n                if current_state[bulb] != toggle_effect[bulb]:\n                    correspondence[bulb] = base36_table[i]\n                current_state[bulb] = toggle_effect[bulb]\n        else:\n            break\n\n    return correspondence\n\ndef format_output(correspondence):\n    return ''.join(correspondence)\n\ndef restore_switch_correspondence(input_data):\n    datasets = parse_input(input_data)\n    results = []\n    for M, N, operations, state_logs in datasets:\n        correspondence = deduce_correspondence(M, N, operations, state_logs)\n        results.append(format_output(correspondence))\n    return results\n\n# Example usage:\ninput_data = \"\"\"3 2\nS 1\nB 110\nS 2\nB 001\n\n2 2\nS 1\nB 01\nS 2\nB 10\"\"\"\noutputs = restore_switch_correspondence(input_data)\nfor output in outputs:\n    print(output)",
    "timestamp": "2025-08-13 07:30:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class SwitchBulbMapping {\n\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(System.in);\n        while (in.hasNext()) {\n            int M = in.nextInt(); // Number of light bulbs\n            int N = in.nextInt(); // Number of switches\n            int P = in.nextInt(); // Number of operations\n\n            boolean[][] lightsState = new boolean[P][M];\n            for (int i = 0; i < P; i++) {\n                for (int j = 0; j < M; j++) {\n                    lightsState[i][j] = in.nextInt() == 1;\n                }\n            }\n\n            List<Integer>[] operations = new List[P];\n            for (int i = 0; i < P; i++) {\n                operations[i] = new ArrayList<>();\n                int numSwitches = in.nextInt();\n                for (int j = 0; j < numSwitches; j++) {\n                    operations[i].add(in.nextInt() - 1);\n                }\n            }\n\n            char[][] correspondence = new char[M][];\n            for (int i = 0; i < M; i++) {\n                Set<Integer> possibleSwitches = new HashSet<>();\n                for (int j = 0; j < N; j++) {\n                    possibleSwitches.add(j);\n                }\n                \n                for (int op = 0; op < P; op++) {\n                    boolean expectedState = false;\n                    for (int sw : operations[op]) {\n                        if (possibleSwitches.contains(sw)) {\n                            expectedState = !expectedState;\n                        }\n                    }\n                    if (lightsState[op][i] != expectedState) {\n                        Set<Integer> toRemove = new HashSet<>();\n                        for (int sw : possibleSwitches) {\n                            if (!operations[op].contains(sw)) {\n                                toRemove.add(sw);\n                            }\n                        }\n                        possibleSwitches.removeAll(toRemove);\n                    }\n                }\n\n                correspondence[i] = new char[possibleSwitches.size()];\n                int index = 0;\n                for (int sw : possibleSwitches) {\n                    if (possibleSwitches.size() > 1) {\n                        correspondence[i][index++] = '?';\n                    } else {\n                        correspondence[i][index++] = intToBase36(sw);\n                    }\n                }\n            }\n\n            for (char[] switches : correspondence) {\n                if (switches.length == 1) {\n                    System.out.print(switches[0]);\n                } else {\n                    System.out.print('?');\n                }\n            }\n            System.out.println();\n        }\n    }\n\n    private static char intToBase36(int num) {\n        if (num < 10) {\n            return (char) ('0' + num);\n        } else {\n            return (char) ('a' + num - 10);\n        }\n    }\n}",
    "timestamp": "2025-08-13 07:30:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SWITCHES 36\n#define MAX_BULBS 100\n\nvoid to_base36(int num, char *buf) {\n    char base36[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i = 0;\n    while (num > 0) {\n        buf[i++] = base36[num % 36];\n        num /= 36;\n    }\n    if (i == 0) {\n        buf[i++] = '0';\n    }\n    buf[i] = '\\0';\n    // Reverse the buffer\n    for (int j = 0; j < i / 2; j++) {\n        char temp = buf[j];\n        buf[j] = buf[i-j-1];\n        buf[i-j-1] = temp;\n    }\n}\n\nint main() {\n    int M, N, O;\n    while (scanf(\"%d %d %d\", &M, &N, &O) != EOF) {\n        int operations[MAX_SWITCHES][MAX_BULBS];\n        memset(operations, 0, sizeof(operations));\n\n        int bulb_initial_states[MAX_BULBS];\n        for (int m = 0; m < M; m++) {\n            scanf(\"%d\", &bulb_initial_states[m]);\n        }\n\n        for (int o = 0; o < O; o++) {\n            int s;\n            scanf(\"%d\", &s);\n            for (int m = 0; m < M; m++) {\n                int state;\n                scanf(\"%d\", &state);\n                operations[s][m] ^= state;\n            }\n        }\n\n        for (int n = 0; n < N; n++) {\n            char buf[MAX_BULBS + 1];\n            to_base36(n, buf);\n            printf(\"Switch %s: \", buf);\n\n            int uncertain = 0;\n            for (int m = 0; m < M; m++) {\n                if (operations[n][m] == 1) {\n                    printf(\"%d \", m);\n                } else if (operations[n][m] == -1) {\n                    uncertain = 1;\n                }\n            }\n            if (uncertain) {\n                printf(\"?\");\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 07:31:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_light_bulb_switch_mapping(M, N, operations):\n    # Initialize state matrices\n    initial_state = [0] * M\n    final_state = [0] * M\n    switch_matrix = [[0] * N for _ in range(M)]\n\n    # Record initial and final states from operations\n    for op in operations:\n        switch_id, state_after = op\n        for i in range(M):\n            if state_after[i] != initial_state[i]:\n                switch_matrix[i][switch_id] = 1\n\n    # Solve for unique mapping\n    result = ['?'] * N\n    for j in range(N):\n        controlled_bulbs = [i for i in range(M) if switch_matrix[i][j] == 1]\n        if len(controlled_bulbs) == 1:\n            result[j] = base36_encode(controlled_bulbs[0])\n\n    return ''.join(result)\n\ndef base36_encode(num):\n    return '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'[num]\n\n# Input parsing and main execution\ndef main():\n    T = int(input())\n    for _ in range(T):\n        M, N, K = map(int, input().split())\n        operations = []\n        for _ in range(K):\n            switch_id = int(input()) - 1\n            state_after = list(map(int, input().split()))\n            operations.append((switch_id, state_after))\n        \n        print(solve_light_bulb_switch_mapping(M, N, operations))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:31:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef to_base36(n):\n    if n < 10:\n        return str(n)\n    elif n < 36:\n        return chr(ord('a') + n - 10)\n    else:\n        return to_base36(n // 36) + to_base36(n % 36)\n\ndef solve():\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        M, N = map(int, line.strip().split())\n        S = int(sys.stdin.readline().strip())\n        operations = []\n        for _ in range(S):\n            parts = sys.stdin.readline().strip().split()\n            switch = int(parts[0])\n            state = parts[1]\n            operations.append((switch, state))\n        Q = int(sys.stdin.readline().strip())\n        queries = []\n        for _ in range(Q):\n            parts = sys.stdin.readline().strip().split()\n            time = int(parts[0])\n            bulb = int(parts[1])\n            state = parts[2]\n            queries.append((time, bulb, state))\n        \n        # Process each bulb\n        bulb_info = {}\n        for bulb in range(1, M+1):\n            bulb_info[bulb] = {'0': set(), '1': set()}\n        \n        for time, bulb, state in queries:\n            bulb_info[bulb][state].add(time)\n        \n        switch_to_bulbs = defaultdict(set)\n        bulb_to_switch = {}\n        for bulb in range(1, M+1):\n            on_times = bulb_info[bulb]['1']\n            off_times = bulb_info[bulb]['0']\n            possible_switches = set()\n            # The switch must be toggled at all times when bulb is on (odd number of toggles)\n            # and not toggled at times when bulb is off (even number of toggles)\n            # So the switch must be toggled exactly at the XOR of on_times\n            # But since we don't know, we need to find a switch that is toggled in all on_times and not in off_times\n            # So possible switches are those that are toggled in all on_times and none of the off_times\n            # Initialize possible switches as all switches that appear in any on_time\n            if not on_times and not off_times:\n                # No info, can be any switch or ?\n                bulb_to_switch[bulb] = '?'\n                continue\n            possible_switches = None\n            for time in on_times:\n                op_switch, op_state = operations[time-1]\n                if possible_switches is None:\n                    possible_switches = {op_switch}\n                else:\n                    possible_switches.intersection_update({op_switch})\n            if possible_switches is None:\n                possible_switches = set()\n            # Now check off_times: the switch must not be in any off_time\n            for time in off_times:\n                op_switch, op_state = operations[time-1]\n                possible_switches.discard(op_switch)\n            if len(possible_switches) == 1:\n                s = possible_switches.pop()\n                bulb_to_switch[bulb] = s\n                switch_to_bulbs[s].add(bulb)\n            else:\n                bulb_to_switch[bulb] = '?'\n        \n        # Prepare output\n        output = []\n        for bulb in range(1, M+1):\n            s = bulb_to_switch.get(bulb, '?')\n            if s == '?':\n                output.append('?')\n            else:\n                output.append(to_base36(s))\n        print(''.join(output))\n\nsolve()",
    "timestamp": "2025-08-13 07:31:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\nconst int MAX_M = 100; // Maximum number of light bulbs\nconst int MAX_N = 100; // Maximum number of switches\n\n// Function to convert an integer number to a base-36 string\nstring toBase36(int num) {\n    const string base36_chars = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    string result;\n    if (num == 0) return \"0\";\n    while (num > 0) {\n        result = base36_chars[num % 36] + result;\n        num /= 36;\n    }\n    return result;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    for (int dataset = 0; dataset < datasets; ++dataset) {\n        int M, N, operations;\n        cin >> M >> N >> operations;\n\n        // Initializing a vector of boolean to track the effects of each switch\n        vector<bitset<MAX_M>> switchEffects(N);\n\n        // Process each operation and update switch effects\n        for (int i = 0; i < operations; ++i) {\n            int switchIndex;\n            bitset<MAX_M> bulbStates;\n\n            cin >> switchIndex;\n            for (int j = 0; j < M; ++j) {\n                char state;\n                cin >> state;\n                bulbStates[j] = (state == '1');\n            }\n\n            // Toggle the effect of this switch operation\n            switchEffects[switchIndex - 1] ^= bulbStates;\n        }\n\n        // Determine switch to light bulb correspondence and output\n        for (int i = 0; i < N; ++i) {\n            if (switchEffects[i].any()) {\n                cout << toBase36(switchEffects[i].to_ulong()) << \" \";\n            } else {\n                cout << \"? \";\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:39:06"
  }
]