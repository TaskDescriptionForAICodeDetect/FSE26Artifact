[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint rows, cols;\nint **grid;\nint **visited;\nint target_color;\nint max_area = 0;\nint directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols;\n}\n\nvoid bfs(int start_x, int start_y) {\n    Point *queue = malloc(rows * cols * sizeof(Point));\n    int front = 0, rear = 0;\n    queue[rear++] = (Point){start_x, start_y};\n    visited[start_x][start_y] = 1;\n    int area = 1;\n\n    while (front < rear) {\n        Point current = queue[front++];\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + directions[i][0];\n            int ny = current.y + directions[i][1];\n            if (is_valid(nx, ny) && !visited[nx][ny] && grid[nx][ny] == target_color) {\n                visited[nx][ny] = 1;\n                queue[rear++] = (Point){nx, ny};\n                area++;\n            }\n        }\n    }\n\n    if (area > max_area) {\n        max_area = area;\n    }\n\n    free(queue);\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    grid = malloc(rows * sizeof(int *));\n    visited = malloc(rows * sizeof(int *));\n    for (int i = 0; i < rows; i++) {\n        grid[i] = malloc(cols * sizeof(int));\n        visited[i] = malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n            visited[i][j] = 0;\n        }\n    }\n    scanf(\"%d\", &target_color);\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (!visited[i][j] && grid[i][j] == target_color) {\n                bfs(i, j);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_area);\n\n    for (int i = 0; i < rows; i++) {\n        free(grid[i]);\n        free(visited[i]);\n    }\n    free(grid);\n    free(visited);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PanelFusion {\n    public static int maxUnifiedPanels(int[][] grid, int targetColor) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        int maxUnited = 0;\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (!visited[r][c]) {\n                    int currentMax = findMaxUnited(grid, r, c, targetColor, visited);\n                    maxUnited = Math.max(maxUnited, currentMax);\n                }\n            }\n        }\n        return maxUnited;\n    }\n\n    private static int findMaxUnited(int[][] grid, int r, int c, int targetColor, boolean[][] visited) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{r, c});\n        visited[r][c] = true;\n        int uniteSize = 0;\n        int maxChanges = 0;\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int currR = curr[0], currC = curr[1];\n            \n            if (grid[currR][currC] == targetColor) {\n                uniteSize++;\n            } else if (maxChanges < 5) {\n                grid[currR][currC] = targetColor;\n                maxChanges++;\n                uniteSize++;\n            }\n\n            int[][] directions = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n            for (int[] dir : directions) {\n                int newR = currR + dir[0];\n                int newC = currC + dir[1];\n\n                if (newR >= 0 && newR < rows && newC >= 0 && newC < cols && !visited[newR][newC]) {\n                    if (grid[newR][newC] == targetColor || maxChanges < 5) {\n                        queue.offer(new int[]{newR, newC});\n                        visited[newR][newC] = true;\n                    }\n                }\n            }\n        }\n        return uniteSize;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        int targetColor = 5;\n        System.out.println(maxUnifiedPanels(grid, targetColor));\n    }\n}",
    "timestamp": "2025-08-05 19:09:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint main() {\n    int H, W, K;\n    cin >> H >> W >> K;\n    vector<vector<int>> grid(H, vector<int>(W));\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    int max_area = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            vector<vector<bool>> visited(H, vector<bool>(W, false));\n            queue<pair<int, int>> q;\n            if (grid[i][j] != K) {\n                q.push({i, j});\n                visited[i][j] = true;\n            }\n            int area = 0;\n            vector<vector<bool>> temp_visited = visited;\n            queue<pair<int, int>> temp_q = q;\n            int changes_used = (grid[i][j] != K) ? 1 : 0;\n\n            while (!temp_q.empty()) {\n                int size = temp_q.size();\n                for (int s = 0; s < size; ++s) {\n                    auto p = temp_q.front();\n                    temp_q.pop();\n                    int x = p.first, y = p.second;\n                    area++;\n                    for (int d = 0; d < 4; ++d) {\n                        int nx = x + dx[d], ny = y + dy[d];\n                        if (nx >= 0 && nx < H && ny >= 0 && ny < W && !temp_visited[nx][ny]) {\n                            if (grid[nx][ny] == K) {\n                                temp_visited[nx][ny] = true;\n                                temp_q.push({nx, ny});\n                            } else if (changes_used < 5) {\n                                temp_visited[nx][ny] = true;\n                                temp_q.push({nx, ny});\n                                changes_used++;\n                            }\n                        }\n                    }\n                }\n            }\n            max_area = max(max_area, area);\n        }\n    }\n    cout << max_area << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:10:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n#define MAX_CHANGES 5\n\nint rows, cols, target_color;\nint grid[MAX_ROWS][MAX_COLS];\nint original_grid[MAX_ROWS][MAX_COLS];\nint max_united_panels = 0;\n\nvoid dfs(int r, int c, int color, int changes_left, int current_united_size) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return;\n    \n    if (grid[r][c] == color) {\n        current_united_size++;\n        max_united_panels = (current_united_size > max_united_panels) ? current_united_size : max_united_panels;\n    }\n    \n    if (changes_left == 0) return;\n    \n    for (int new_color = 1; new_color <= 5; new_color++) {\n        if (new_color != color) {\n            int temp = grid[r][c];\n            grid[r][c] = new_color;\n            \n            dfs(r+1, c, new_color, changes_left-1, current_united_size);\n            dfs(r-1, c, new_color, changes_left-1, current_united_size);\n            dfs(r, c+1, new_color, changes_left-1, current_united_size);\n            dfs(r, c-1, new_color, changes_left-1, current_united_size);\n            \n            grid[r][c] = temp;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &rows, &cols, &target_color);\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n            original_grid[i][j] = grid[i][j];\n        }\n    }\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            memcpy(grid, original_grid, sizeof(original_grid));\n            dfs(i, j, original_grid[i][j], MAX_CHANGES, 0);\n        }\n    }\n    \n    printf(\"%d\\n\", max_united_panels);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:10:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass PanelFusion {\nprivate:\n    vector<vector<int>> grid;\n    int rows, cols, target_color;\n\n    void dfs(int r, int c, int color, vector<vector<bool>>& visited) {\n        if (r < 0 || r >= rows || c < 0 || c >= cols || \n            visited[r][c] || grid[r][c] != color) return;\n        \n        visited[r][c] = true;\n        dfs(r+1, c, color, visited);\n        dfs(r-1, c, color, visited);\n        dfs(r, c+1, color, visited);\n        dfs(r, c-1, color, visited);\n    }\n\n    int countRegion(int color, vector<vector<bool>>& visited) {\n        int max_size = 0;\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (!visited[r][c] && grid[r][c] == color) {\n                    int prev_size = 0;\n                    for (int i = 0; i < rows; i++)\n                        for (int j = 0; j < cols; j++)\n                            visited[i][j] = false;\n                    \n                    dfs(r, c, color, visited);\n                    \n                    int curr_size = 0;\n                    for (int i = 0; i < rows; i++)\n                        for (int j = 0; j < cols; j++)\n                            if (visited[i][j]) curr_size++;\n                    \n                    max_size = max(max_size, curr_size);\n                }\n            }\n        }\n        return max_size;\n    }\n\npublic:\n    PanelFusion(vector<vector<int>>& panels, int target) {\n        grid = panels;\n        rows = grid.size();\n        cols = grid[0].size();\n        target_color = target;\n    }\n\n    int maxUnifiedPanels() {\n        int max_unified = 0;\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                for (int changes = 0; changes <= 5; changes++) {\n                    vector<vector<int>> original_grid = grid;\n                    \n                    // Try changing colors\n                    grid[r][c] = target_color;\n                    \n                    max_unified = max(max_unified, \n                        countRegion(target_color, visited));\n                    \n                    // Reset grid\n                    grid = original_grid;\n                }\n            }\n        }\n\n        return max_unified;\n    }\n};\n\nint main() {\n    vector<vector<int>> panels = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    int target_color = 5;\n    \n    PanelFusion solver(panels, target_color);\n    cout << solver.maxUnifiedPanels() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:10:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int rows, cols;\n    static int[][] grid;\n    static boolean[][] visited;\n    static int targetColor;\n    static int maxArea = 0;\n    static int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        rows = scanner.nextInt();\n        cols = scanner.nextInt();\n        grid = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        targetColor = scanner.nextInt();\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] != targetColor) {\n                    int originalColor = grid[i][j];\n                    grid[i][j] = targetColor;\n                    visited = new boolean[rows][cols];\n                    int currentArea = dfs(i, j);\n                    if (currentArea > maxArea) {\n                        maxArea = currentArea;\n                    }\n                    grid[i][j] = originalColor;\n                }\n            }\n        }\n\n        System.out.println(maxArea);\n    }\n\n    private static int dfs(int x, int y) {\n        visited[x][y] = true;\n        int area = 1;\n        for (int[] dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny] && grid[nx][ny] == targetColor) {\n                area += dfs(nx, ny);\n            }\n        }\n        return area;\n    }\n}",
    "timestamp": "2025-08-05 19:10:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef max_united_panels(n, m, grid, target_color):\n    # Directions for exploring up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def in_grid(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def bfs(start_x, start_y, original_color):\n        queue = deque([(start_x, start_y)])\n        visited = set((start_x, start_y))\n        size = 0\n        needed_changes = 0\n\n        while queue:\n            x, y = queue.popleft()\n            size += 1\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if in_grid(nx, ny) and (nx, ny) not in visited:\n                    if grid[nx][ny] == target_color:\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n                    elif grid[nx][ny] != original_color:\n                        needed_changes += 1\n                        if needed_changes <= 5:\n                            visited.add((nx, ny))\n                        else:\n                            continue\n        return size if needed_changes <= 5 else 0\n\n    max_size = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != target_color:\n                max_size = max(max_size, bfs(i, j, grid[i][j]))\n\n    return max_size\n\n# Example usage\nn, m = 3, 3\ngrid = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\ntarget_color = 1\n\nprint(max_united_panels(n, m, grid, target_color))",
    "timestamp": "2025-08-13 02:51:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class MaxUnifiedPanels {\n    \n    private static final int MAX_CHANGES = 5;\n    private static int rows, cols;\n    private static int[][] panelColors;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Input the number of rows and columns\n        rows = scanner.nextInt();\n        cols = scanner.nextInt();\n        \n        // Input the panel colors\n        panelColors = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                panelColors[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // Input the target color\n        int targetColor = scanner.nextInt();\n        \n        // Determine the largest unified panel size with the target color\n        System.out.println(getLargestUnifiedPanelSize(targetColor));\n        \n        scanner.close();\n    }\n    \n    private static int getLargestUnifiedPanelSize(int targetColor) {\n        int maxUnifiedSize = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                boolean[][] visited = new boolean[rows][cols];\n                maxUnifiedSize = Math.max(maxUnifiedSize, dfs(i, j, targetColor, MAX_CHANGES, visited));\n            }\n        }\n        \n        return maxUnifiedSize;\n    }\n    \n    private static int dfs(int x, int y, int targetColor, int remainingChanges, boolean[][] visited) {\n        if (x < 0 || y < 0 || x >= rows || y >= cols || visited[x][y]) return 0;\n        \n        int originalColor = panelColors[x][y];\n        if (originalColor != targetColor) {\n            if (remainingChanges <= 0) return 0;\n            remainingChanges--;  // use a color change\n        }\n        \n        visited[x][y] = true;\n        int size = 1;  // current panel is part of the group\n        \n        size += dfs(x + 1, y, targetColor, remainingChanges, visited);\n        size += dfs(x - 1, y, targetColor, remainingChanges, visited);\n        size += dfs(x, y + 1, targetColor, remainingChanges, visited);\n        size += dfs(x, y - 1, targetColor, remainingChanges, visited);\n        \n        visited[x][y] = false;  // backtrack for other calculations\n\n        return size;\n    }\n}",
    "timestamp": "2025-08-13 02:51:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n\nint original[MAX_N][MAX_N];\nint changed[MAX_N][MAX_N];\nint visited[MAX_N][MAX_N];\nint n, m, targetColor;\nint maxCount, currentCount;\nint directions[4][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n\nint isValid(int x, int y) {\n    return (x >= 0 && x < n && y >= 0 && y < m);\n}\n\nvoid dfs(int x, int y, int color) {\n    visited[x][y] = 1;\n    currentCount++;\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + directions[i][0];\n        int ny = y + directions[i][1];\n\n        if (isValid(nx, ny) && !visited[nx][ny] && changed[nx][ny] == color) {\n            dfs(nx, ny, color);\n        }\n    }\n}\n\nint simulate(int x, int y, int targetColor, int changesLeft, int currentColor) {\n    if (changesLeft < 0) return 0;\n\n    if (changed[x][y] != targetColor) {\n        changed[x][y] = targetColor;\n        changesLeft--;\n    }\n\n    memset(visited, 0, sizeof(visited));\n    currentCount = 0;\n    dfs(x, y, targetColor);\n    if (currentCount > maxCount) {\n        maxCount = currentCount;\n    }\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + directions[i][0];\n        int ny = y + directions[i][1];\n\n        if (isValid(nx, ny) && !visited[nx][ny]) {\n            int tempColor = changed[nx][ny];\n            changed[nx][ny] = targetColor;\n            simulate(nx, ny, targetColor, changesLeft - (tempColor != targetColor), currentColor);\n            changed[nx][ny] = tempColor;\n        }\n    }\n\n    return maxCount;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            scanf(\"%d\", &original[i][j]);\n\n    scanf(\"%d\", &targetColor);\n\n    maxCount = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            memcpy(changed, original, sizeof(original));\n            simulate(i, j, targetColor, 5, original[i][j]);\n        }\n    }\n\n    printf(\"%d\\n\", maxCount);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:51:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_united_panels(grid, target_color, max_shocks=5):\n    rows, cols = len(grid), len(grid[0])\n    max_united = 0\n\n    def count_connected(grid, color):\n        def dfs(r, c):\n            if (r < 0 or r >= rows or c < 0 or c >= cols or \n                grid[r][c] != color or visited[r][c]):\n                return 0\n            visited[r][c] = True\n            size = 1\n            for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:\n                size += dfs(r+dr, c+dc)\n            return size\n\n        visited = [[False]*cols for _ in range(rows)]\n        max_size = 0\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == color and not visited[r][c]:\n                    max_size = max(max_size, dfs(r, c))\n        return max_size\n\n    def backtrack(grid, shocks_left):\n        nonlocal max_united\n        max_united = max(max_united, count_connected(grid, target_color))\n        \n        if shocks_left == 0:\n            return\n        \n        for r in range(rows):\n            for c in range(cols):\n                for new_color in range(1, 6):\n                    if grid[r][c] != new_color:\n                        grid[r][c] = new_color\n                        backtrack(grid, shocks_left - 1)\n                        grid[r][c] = grid[r][c]  # backtrack\n\n    backtrack(grid, max_shocks)\n    return max_united\n\n# Example usage\ngrid = [\n    [1, 2, 3],\n    [2, 3, 1],\n    [3, 1, 2]\n]\ntarget_color = 1\nprint(max_united_panels(grid, target_color))",
    "timestamp": "2025-08-13 02:52:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    from collections import deque\n\n    h, w, c = map(int, sys.stdin.readline().split())\n    target = c\n    grid = []\n    for _ in range(h):\n        row = list(map(int, sys.stdin.readline().split()))\n        grid.append(row)\n    \n    max_size = 0\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == target:\n                visited = [[False for _ in range(w)] for _ in range(h)]\n                q = deque()\n                q.append((i, j))\n                visited[i][j] = True\n                current_size = 0\n                \n                while q:\n                    x, y = q.popleft()\n                    current_size += 1\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < h and 0 <= ny < w and not visited[nx][ny]:\n                            if grid[nx][ny] == target:\n                                visited[nx][ny] = True\n                                q.append((nx, ny))\n                            else:\n                                # Check if we can change the color (up to 5 changes)\n                                pass\n                if current_size > max_size:\n                    max_size = current_size\n    print(max_size)\n\nsolve()",
    "timestamp": "2025-08-13 02:52:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Panel {\n    int color;\n    int changeCount;\n};\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool isValid(int x, int y, int rows, int cols) {\n    return x >= 0 && x < rows && y >= 0 && y < cols;\n}\n\nint maxPanels(vector<vector<Panel>>& grid, int targetColor) {\n    int rows = grid.size(), cols = grid[0].size();\n    int maxPanels = 0;\n\n    for(int r = 0; r < rows; r++) {\n        for(int c = 0; c < cols; c++) {\n            if(grid[r][c].color == targetColor) {\n                vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n                queue<pair<int, int>> q;\n                q.push({r, c});\n                visited[r][c] = true;\n                int currentSize = 0;\n\n                while(!q.empty()) {\n                    int x = q.front().first;\n                    int y = q.front().second;\n                    q.pop();\n                    currentSize++;\n\n                    for(int i = 0; i < 4; i++) {\n                        int nx = x + dx[i];\n                        int ny = y + dy[i];\n                        \n                        if(isValid(nx, ny, rows, cols) && !visited[nx][ny] && grid[nx][ny].color == targetColor) {\n                            q.push({nx, ny});\n                            visited[nx][ny] = true;\n                        }\n                    }\n                }\n\n                maxPanels = max(maxPanels, currentSize);\n            } else if(grid[r][c].changeCount > 0) {\n                vector<vector<Panel>> originalGrid = grid;\n                queue<pair<int, int>> panelsToChange;\n                panelsToChange.push({r, c});\n                \n                while(!panelsToChange.empty()) {\n                    auto panel = panelsToChange.front();\n                    panelsToChange.pop();\n\n                    int x = panel.first, y = panel.second;\n                    if(grid[x][y].changeCount >= 0 && grid[x][y].color != targetColor) {\n                        grid[x][y].color = targetColor;\n                        grid[x][y].changeCount--;\n                        \n                        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n                        queue<pair<int, int>> q;\n                        q.push({x, y});\n                        visited[x][y] = true;\n                        int currentSize = 0;\n\n                        while(!q.empty()) {\n                            int cx = q.front().first;\n                            int cy = q.front().second;\n                            q.pop();\n                            currentSize++;\n\n                            for(int i = 0; i < 4; i++) {\n                                int nx = cx + dx[i];\n                                int ny = cy + dy[i];\n                                \n                                if(isValid(nx, ny, rows, cols) && !visited[nx][ny] && grid[nx][ny].color == targetColor) {\n                                    q.push({nx, ny});\n                                    visited[nx][ny] = true;\n                                }\n                            }\n                        }\n\n                        maxPanels = max(maxPanels, currentSize);\n\n                        for(int i = 0; i < 4; i++) {\n                            int nx = x + dx[i];\n                            int ny = y + dy[i];\n                            \n                            if(isValid(nx, ny, rows, cols) && grid[nx][ny].changeCount > 0) {\n                                panelsToChange.push({nx, ny});\n                            }\n                        }\n                    }\n\n                }\n\n                grid = originalGrid;\n            }\n        }\n    }\n\n    return maxPanels;\n}\n\nint main() {\n    int rows, cols, targetColor;\n    cin >> rows >> cols >> targetColor;\n    vector<vector<Panel>> grid(rows, vector<Panel>(cols));\n\n    for(int r = 0; r < rows; r++) {\n        for(int c = 0; c < cols; c++) {\n            cin >> grid[r][c].color >> grid[r][c].changeCount;\n        }\n    }\n\n    cout << maxPanels(grid, targetColor) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:07:57"
  }
]