[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvector<vector<int> > panel;\nvector<vector<int> > p;\nint h, w, c;\n\nvoid nuri(P roc, int col, int ori) {\n\tp[roc.first][roc.second] = col;\n\tREP(i, 4) {\n\t\tll nh = roc.first + dx[i];\n\t\tll nw = roc.second + dy[i];\n\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w && p[nh][nw] == ori) {\n\t\t\tnuri(P(nh, nw), col, ori);\n\t\t}\n\t}\n}\n\nint count(P roc) {\n\tint res = 1;\n\tp[roc.first][roc.second] = -1;\n\tREP(i, 4) {\n\t\tll nh = roc.first + dx[i];\n\t\tll nw = roc.second + dy[i];\n\t\tif(nh >= 0 && nh < h && nw >= 0 && nw < w && p[nh][nw] == c) {\n\t\t\tres += count(P(nh, nw));\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid init() {\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tp[i][j] = panel[i][j];\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>h>>w>>c;\n\t\tif(h == 0 && w == 0 && c == 0) break;\n\t\tpanel.resize(h);\n\t\tp.resize(h);\n\t\tREP(i, h) panel[i].resize(w);\n\t\tREP(i, h) p[i].resize(w);\n\t\tREP(i, h) {\n\t\t\tREP(j, w) cin>>panel[i][j];\n\t\t}\n\t\tinit();\n\t\tll ans = 0;\n\t\tFOR(i, 1, 7) {\n\t\t\tFOR(j, 1, 7) {\n\t\t\t\tFOR(k, 1, 7) {\n\t\t\t\t\tFOR(l, 1, 7) {\n\t\t\t\t\t\tFOR(m, 1, 7) {\n\t\t\t\t\t\t\tif(p[0][0] != i) nuri(P(0, 0), i, p[0][0]);\n\t\t\t\t\t\t\tif(i != j) nuri(P(0, 0), j, i);\n\t\t\t\t\t\t\tif(j != k) nuri(P(0, 0), k, j);\n\t\t\t\t\t\t\tif(k != l) nuri(P(0, 0), l, k);\n\t\t\t\t\t\t\tif(l != m) nuri(P(0, 0), m, l);\n\t\t\t\t\t\t\tans = max(ans, (ll)count(P(0, 0)));\n\t\t\t\t\t\t\tinit();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint h, w, c, p[16][16], q[16][16];\n\nint draw(int x, int y, int f, int t) {\n    if(f==t || x<0 || x>=h || y<0 || y>=w) return 0;\n    if(q[x][y]!=f) return 0;\n    q[x][y] = t;\n    int ans = 1;\n    rep(i, 4) ans += draw(x+dx[i], y+dy[i], f, t);\n    return ans;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d%d%d\", &h, &w, &c);\n        if(h==0 && w==0 && c==0) return 0;\n        rep(i, h) rep(j, w) scanf(\"%d\", p[i]+j);\n        int kk = 1;\n        rep(i, 4) kk *= 6;\n        int ans = 0;\n        rep(b, kk) {\n            rep(i, h) rep(j, w) q[i][j] = p[i][j];\n            int t = b;\n            rep(i, 4) {\n                draw(0, 0, q[0][0], t%6+1);\n                t /= 6;\n            }\n            draw(0, 0, q[0][0], c);\n            ans = max(ans, draw(0, 0, q[0][0], 0));\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint h, w, c;\nvector<vector<int> > p;\n\nint merged[8][8];\nbool check[8][8];\n\nint dfs(int i, int j) {\n\tif(check[i][j]) return 0;\n\tint res = 0;\n\tcheck[i][j] = true;\n\tres++;\n\n\tint dxy[] = {1,0,-1,0,1};\n\tfor(int k = 0; k < 4; k++) {\n\t\tint ii = i+dxy[k], jj=j+dxy[k+1];\n\t\tif(0 <= ii && ii < h && 0 <= jj && jj < w) {\n\t\t\tif(merged[ii][jj]) {\n\t\t\t\tres += dfs(ii,jj);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid mer(int i, int j, int col, vector<pii>&rv) {\n\tif(merged[i][j] == 2) return;\n\tif(merged[i][j] == 0) rv.push_back(pii(i,j));\n\tmerged[i][j] = 2;\n\n\tint dxy[] = {1,0,-1,0,1};\n\tfor(int k = 0; k < 4; k++) {\n\t\tint ii = i+dxy[k], jj=j+dxy[k+1];\n\t\tif(0 <= ii && ii < h && 0 <= jj && jj < w && (col == p[ii][jj] || merged[ii][jj])) {\n\t\t\tmer(ii,jj,col,rv);\n\t\t}\n\t}\n}\n\nint solve(int ii, int jj, int col, int d) {\n\tvector<pii> tmp;\n\tif(d == 5) {\n\t\tif(col != c) return 0;\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tcheck[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t\tmerged[i][j] = !!merged[i][j];\n\t\tmer(ii,jj,col,tmp);\n\t\tint res;\n\t\tres = dfs(ii,jj);\n\n\t\tfor(int i = 0; i < tmp.size(); i++)\n\t\t\tmerged[tmp[i].first][tmp[i].second] = 0;\n\n\t\treturn res;\n\t}\n\n\tfor(int i = 0; i < h; i++) {\n\t\tfor(int j = 0; j < w; j++) {\n\t\t\tmerged[i][j] = !!merged[i][j];\n\t\t}\n\t}\n\n\tmer(ii,jj,col,tmp);\n\n\tint res = 0;\n\tfor(int i = 0; i < 6; i++) {\n\t\tres = max(res,solve(ii,jj,i,d+1));\n\t}\n\n\tfor(int i = 0; i < h; i++) {\n\t\tfor(int j = 0; j < w; j++) {\n\t\t\tmerged[i][j] = !!merged[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < tmp.size(); i++)\n\t\tmerged[tmp[i].first][tmp[i].second] = 0;\n\treturn res;\n}\nvoid clear() {\n\tfor(int i = 0; i < 8; i++) {\n\t\tfor(int j = 0; j < 8; j++){\n\t\t\tmerged[i][j] = 0;\n\t\t\tcheck[i][j] = 0;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> h >> w >> c, h || w || c) {\n\t\tp.clear(); p.resize(h);\n\t\tc--;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tp[i].resize(w);\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> p[i][j]; p[i][j]--;\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tclear();\n\t\tres = max(res,solve(0,0,p[0][0],0));\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint h, w, c, p[9][9], q[9][9];\nint id = 7;\n\nvoid change(int x, int y, int color){\n\tint first = p[x][y];\n\tp[x][y] = color * (-1);\n\tif (x < h - 1 && p[x + 1][y] == first)\n\t\tchange(x + 1, y, color);\n\tif (x > 0 && p[x - 1][y] == first)\n\t\tchange(x - 1, y, color);\n\tif (y < w - 1 && p[x][y + 1] == first)\n\t\tchange(x, y + 1, color);\n\tif (y > 0 && p[x][y - 1] == first)\n\t\tchange(x, y - 1, color);\n}\n\nvoid pabs(){\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tp[i][j] = abs(p[i][j]);\n\t\t}\n\t}\n\n\n}\n\n\nint main()\n{\n\n\t//長方形サイズ，目標色の入力\n\twhile (cin >> h >> w >> c, (h || w || c)){\n\n\t\t//初期化\n\t\tfor (int i = 0; i < 9; i++){\n\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\tp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t//色の入力\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> p[i][j];\n\t\t}\n\n\t\t//パネルをコピーしておく\n\t\tfor (int a = 0; a < h; a++){\n\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\tq[a][b] = p[a][b];\n\t\t\t}\n\t\t}\n\n\t\t//全パターン\n\n\t\tint max = 0;\n\t\tint counter;\n\t\tfor (int i = 1; i < 7; i++){\n\t\t\tfor (int j = 1; j < 7; j++){\n\t\t\t\tfor (int k = 1; k < 7; k++){\n\t\t\t\t\tfor (int l = 1; l < 7; l++){\n\t\t\t\t\t\tfor (int m = 1; m < 7; m++){\n\n\t\t\t\t\t\t\t//パネルを初期状態に戻す\n\t\t\t\t\t\t\tfor (int a = 0; a < h; a++){\n\t\t\t\t\t\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\t\t\t\t\t\tp[a][b] = q[a][b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//5回色塗り\n\t\t\t\t\t\t\tchange(0, 0, i);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, j);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, k);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, l);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, m);\n\t\t\t\t\t\t\tpabs();\n\n\t\t\t\t\t\t\t//集計\n\t\t\t\t\t\t\tfor (int i = 0; i < h; i++){\n\t\t\t\t\t\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\t\t\t\t\t\tif (p[i][j] == c){\n\t\t\t\t\t\t\t\t\t\tchange(i, j, ++id);\n\t\t\t\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\t\t\t\tcounter = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int a = 0; a < h; a++){\n\t\t\t\t\t\t\t\t\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\t\t\t\t\t\t\t\t\tif (p[a][b] == id)\n\t\t\t\t\t\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (counter > max)\n\t\t\t\t\t\t\t\t\t\t\tmax = counter;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//出力\n\t\tcout << max << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[4] = {0,-1,1,0};\nint dy[4] = {-1,0,0,1};\nint w,h,c,ans,color_cnt;\n\nint colorConut(const vector<vector<int> >& a){\n\tint s=0;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( a[y][x] == -1 ) s++;\n\t\t}\n\t}\n\treturn s;\n}\n\nvoid change(vector<vector<int> >& a, int x, int y, int prev_c, int next_c){\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\tif( a[my][mx] == prev_c ){\n\t\t\ta[my][mx] = next_c;\n\t\t\tchange( a , mx , my , prev_c , next_c );\n\t\t}\n\t}\n}\n\nvoid solve(const vector<vector<int> >& a, int cnt){\n\tif( cnt == 6 ){\n\t\tvector<vector<int> > b = a;\n\t\tb[0][0] = -1;\n\t\tchange( b , 0 , 0 , c , -1 );\n\t\tans = max( ans , colorConut(b) );\n\t}else{\n\t\tfor(int i=1 ; i <= 6 ; i++ ){\n\t\t\tvector<vector<int> > b = a;\n\t\t\tif( a[0][0] == i ) continue;\n\t\t\tb[0][0] = i;\n\t\t\tchange( b , 0 , 0 , a[0][0] , i );\n\t\t\tsolve( b , cnt+1 );\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> h >> w >> c , h || w || c ){\n\t\tvector<vector<int> > a;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tvector<int> v;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tint e;\n\t\t\t\tcin >> e;\n\t\t\t\tv.push_back( e );\n\t\t\t}\n\t\t\ta.push_back( v );\n\t\t}\n\t\tans = 0;\n\t\tsolve( a , 1 );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct UnionFind {\n  const int n;\n  V<> t; // root ? -sz : par\n  UnionFind(int n) : n(n), t(n, -1) {}\n  int find(int v) { return t[v] < 0 ? v : t[v] = find(t[v]); }\n  void unite(int u, int v) {\n    if ((u = find(u)) == (v = find(v))) return;\n    if (-t[u] < -t[v]) swap(u, v);\n    t[u] += t[v];\n    t[v] = u;\n  }\n  bool same(int u, int v) { return find(u) == find(v); }\n  int size(int v) { return -t[find(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int h, w, c; cin >> h >> w >> c, --c;\n    if (!h) break;\n    VV<> p(h, V<>(w)); for (auto&& v : p) for (auto&& e : v) cin >> e, --e;\n    int res = 0;\n    V<> v;\n    V<> di{1, 0, -1, 0}, dj{0, 1, 0, -1};\n    auto in = [&](int i, int j) -> bool { return 0 <= i and i < h and 0 <= j and j < w; };\n    auto _ = [&](int i, int j) -> int { return i * w + j; };\n    auto dfs = [&](const auto& dfs) -> void {\n      if (v.size() == 5) {\n        if (v.back() != c) return;\n        UnionFind uf(h * w);\n        for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n          if (i + 1 < h and p[i][j] == p[i + 1][j]) uf.unite(_(i, j), _(i + 1, j));\n          if (j + 1 < w and p[i][j] == p[i][j + 1]) uf.unite(_(i, j), _(i, j + 1));\n        }\n        for (int e : v) {\n          for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) if (!uf.same(0, _(i, j)) and p[i][j] == e) {\n            for (int d = 0; d < 4; ++d) {\n              int ni = i + di[d], nj = j + dj[d];\n              if (!in(ni, nj)) continue;\n              if (uf.same(0, _(ni, nj))) {\n                uf.unite(0, _(i, j));\n                break;\n              }\n            }\n          }\n        }\n        res = max(res, uf.size(0));\n        return;\n      }\n      for (int i = 0; i < 6; ++i) {\n        v.push_back(i);\n        dfs(dfs);\n        v.pop_back();\n      }\n    };\n    dfs(dfs);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nconst int N = 6; // ティツ可イテ」ツ?ョテヲツ閉ー\nconst int M = 5; // テゥツ崢サテヲツーツ療」ツつキテ」ツδァテ」ツδε」ツつッテ」ツ?ョテ・ツ崢榲ヲツ閉ー\nint H, W, C;\n\nbool next_pattern(VI &pattern) {\n\tpattern[M - 2]++;\n\t\n\tfor (int i = M - 2; i >= 0; i--) {\n\t\tif (pattern[i] > N) {\n\t\t\tif (i == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpattern[i] = 1;\n\t\t\tpattern[i - 1]++;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid update(VVI &panel, int old_c, int new_c, VVI &done, int x, int y) {\n\tif (done[y][x]) {\n\t\treturn;\n\t}\n\n\tdone[y][x] = 1;\n\n\tfor (int d = 0; d < 4; d++) {\n\t\tint nx = x + dx[d];\n\t\tint ny = y + dy[d];\n\n\t\tif (nx < 0 || ny < 0 || nx >= W || ny >= H) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (panel[ny][nx] == old_c) {\n\t\t\tpanel[ny][nx] = new_c;\n\t\t\tupdate(panel, old_c, new_c, done, nx, ny);\n\t\t}\n\t}\n}\n\nvoid count_panel(VVI &panel, VVI &done, int &count, int x, int y) {\n\tif (done[y][x]) {\n\t\treturn;\n\t}\n\n\tdone[y][x] = 1;\n\tcount++;\n\n\tfor (int d = 0; d < 4; d++) {\n\t\tint nx = x + dx[d];\n\t\tint ny = y + dy[d];\n\n\t\tif (nx < 0 || ny < 0 || nx >= W || ny >= H) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (panel[ny][nx] == panel[y][x]) {\n\t\t\tcount_panel(panel, done, count, nx, ny);\n\t\t}\n\t}\n}\n\nint simu(VVI panel, VI pattern) {\n\tfor (auto &c : pattern) {\n\t\tVVI done(H, VI(W, 0));\n\t\tint old_c = panel[0][0];\n\t\tpanel[0][0] = c;\n\t\tupdate(panel, old_c, c, done, 0, 0);\n\t}\n\t\n\tVVI done(H, VI(W, 0));\n\tint cnt = 0;\n\tcount_panel(panel, done, cnt, 0, 0);\n\n\treturn cnt;\n}\n\nint main(void) {\n\t\n\twhile (cin >> H >> W >> C, H) {\n\t\tVVI panel(H, VI(W));\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> panel[i][j];\n\t\t\t}\n\t\t}\n\n\t\tVI pattern(M, 1);\n\t\tpattern[M - 1] = C;\n\n\t\tint ans = 0;\n\t\twhile (next_pattern(pattern)) {\n\t\t\tint t = simu(panel, pattern);\n\t\t\tans = max(ans, t);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint h,w,c;\nvector<vector<int> > g;\nint ans;\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\n\n\nbool r(int y, int x) {\n    if (y >= 0 && y < h && x >= 0 && x < w) return true;\n    else return false;\n}\n\nset<pii> func() {\n    set<pii> se;\n    se.insert(make_pair(0,0));\n    queue<pii> que;\n    que.push(make_pair(0,0));\n    \n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int ty = p.first, tx = p.second;\n        \n        for (int k = 0; k < 4; k++) {\n            int ny = ty+dy[k], nx = tx+dx[k];\n            if (se.count(make_pair(ny,nx))) continue;\n            \n            if (r(ny, nx) && g[ny][nx] == g[0][0]) {\n                se.insert(make_pair(ny,nx));\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n    \n    return se;\n}\n\nvoid solve(int cnt) {\n    set<pii> se = func();\n    \n    if (cnt == 5) {\n        ans = max(ans, (int)se.size());\n        return;\n    }\n    \n    vector<vector<int> > t(h, vector<int>(w));\n    t = g;\n    for (int i = 1; i < 7; i++) {\n        if (g[0][0] == i) continue;\n        if (cnt == 4 && i != c) continue;\n        \n        for (set<pii>::iterator it = se.begin(); it != se.end(); it++) {\n            pii p = *it;\n            int ty = p.first, tx = p.second;\n            g[ty][tx] = i;\n        }\n        solve(cnt+1);\n        g = t;\n    }\n}\n\nint main(void){\n    while (cin>>h>>w>>c && h) {\n        vector<vector<int> > t(h, vector<int>(w));\n        g = t;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> g[i][j];\n            }\n        }\n        ans = 0;\n        solve(0);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w, c;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nint cnt = 0, sy = 0, sx = 0;\nbool used[10][10];\nvector< vector<int> > v;\n\nvoid rec(int y, int x) {\n\tused[y][x] = true;\n\tcnt++;\n\n\trep(i, 4) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\n\t\tif(can(ny, nx) && !used[ny][nx] && v[ny][nx] == c) {\n\t\t\trec(ny, nx);\n\t\t}\n\t}\n}\n\nint target, change;\n\nvoid dfs(int y, int x) {\n\tv[y][x] = change;\n\trep(i, 4) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\n\t\tif(can(ny, nx) && v[ny][nx] == target) {\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n}\n\nint ans = 0;\nvoid func(vector< vector<int> > t, int id) {\n\t// cout << \" ------ func ---- :\" << id << endl;\n\t// rep(i, h) {\n\t// \trep(j, w) cout << t[i][j] << \" \";\n\t// \tcout << endl;\n\t// }\n\tif(id == 4) {\n\t\tv = t;\n\t\ttarget = t[sy][sx];\n\n\t\tif(target == c) return;\n\t\tchange = c;\n\t\tdfs(sy, sx);\n\n\t\tcnt = 0;\n\t\tmemset(used, 0, sizeof(used));\n\t\trec(sy, sx);\n\t\tans = max(ans, cnt);\n\t\treturn;\n\t}\n\n\tREP(i, 1, 7) {\n\t\tif(i == t[sy][sx]) continue;\n\t\tv = t;\n\t\ttarget = t[sy][sx]; change = i;\n\t\tdfs(sy, sx);\n\t\tfunc(v, id + 1);\n\t}\n}\n\nint main() {\n\twhile(cin >> h >> w >> c) {\n\t\tif(h == 0 && w == 0 && c == 0) break;\n\n\t\tv.resize(h);\n\t\trep(i, h) {\n\t\t\tv[i].resize(w);\n\t\t\trep(j, w) cin >> v[i][j];\n\t\t}\n\n\t\tans = 0;\n\t\tfunc(v, 0);\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <algorithm>\n#define H 8\n#define W 8\nusing namespace std;\n\nshort h,w,c;\n\nstruct P {\n  int a[H][W];\n  int n;\n};\n\nvoid pr( P p ){\n  for( int i=0;i<h;i++ ){\n    for( int j=0;j<w;j++ ) cout << p.a[i][j] << \" \";\n    cout << endl;\n  }\n}\n\nvoid change( int a[H][W],int i,int j,int c ){\n  int b = a[i][j];\n  if( a[i][j]==c ) return;\n  a[i][j] = c;\n  if( i-1>=0 && a[i-1][j]==b ) change( a,i-1,j,c );\n  if( j-1>=0 && a[i][j-1]==b ) change( a,i,j-1,c );\n  if( i+1<h && a[i+1][j]==b )  change( a,i+1,j,c );\n  if( j+1<w && a[i][j+1]==b )  change( a,i,j+1,c );\n}\n\nint count( int a[H][W], int i, int j ){\n  int r=1;\n  if( i<0 || j<0 ) return 0;\n  if( i>=h || j>=w ) return 0;\n\n  if( a[i][j]!=c ) return 0;\n  a[i][j] = -1;\n  r += count( a,i+1,j );\n  r += count( a,i-1,j );\n  r += count( a,i,j+1 );\n  r += count( a,i,j-1 );\n  return r;\n}\n\n\nint main(){\n  P p, q;\n  stack<P> st;\n  while( cin>>h>>w>>c && (h||w||c) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ )\n\tcin >> p.a[i][j];\n    p.n = 5;\n\n    while( !st.empty() ) st.pop();\n    st.push( p );\n\n    int mx=0;\n    while( !st.empty() ){\n      p = st.top(); st.pop();\n      if( p.n==0 ){\n\tint cnt = count(p.a,0,0);\n\tif( cnt>mx ){\n\t  //\t  cout << \"cnt=\" << cnt << endl;\n\t  change( p.a,0,0,c );\n\t  //\t  pr( p );\n\t}\n\tmx = max( mx,cnt );\n      }else{\n\tfor( int i=1;i<=6;i++ ){\n\t  q = p; q.n=p.n-1;\n\t  change( q.a,0,0,i );\n\t  st.push( q );\n\t}\n      }\n    }\n    cout << mx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nvoid paint(vector<vector<int>>& p, vector<vector<bool>>& use, int next)\n{\n\tint h = p.size();\n\tint w = p[0].size();\n\tqueue<pair<int, int>> q;\n\tREP(i, h)REP(j, w) if(use[i][j]){\n\t\tq.push({ i,j });\n\t}\n\n\n\twhile (!q.empty()) {\n\t\tauto now = q.front(); q.pop();\n\n\t\t//上\n\t\tif (0 < now.first && !use[now.first - 1][now.second] && p[now.first - 1][now.second] == next) {\n\t\t\tuse[now.first - 1][now.second] = true;\n\t\t\tq.push({ now.first - 1,now.second });\n\t\t}\n\t\t//下\n\t\tif (now.first < h - 1 && !use[now.first + 1][now.second] && p[now.first + 1][now.second] == next) {\n\t\t\tuse[now.first + 1][now.second] = true;\n\t\t\tq.push({ now.first + 1,now.second });\n\t\t}\n\t\t//左\n\t\tif (0 < now.second && !use[now.first][now.second - 1] && p[now.first][now.second-1] == next) {\n\t\t\tuse[now.first][now.second - 1] = true;\n\t\t\tq.push({ now.first,now.second - 1 });\n\t\t}\n\t\t//右\n\t\tif (now.second < w - 1 && !use[now.first][now.second + 1] && p[now.first][now.second+1] == next) {\n\t\t\tuse[now.first][now.second+1] = true;\n\t\t\tq.push({ now.first,now.second + 1 });\n\t\t}\n\t}\n}\n\nvoid debug2(vector<vector<bool>> use) {\n\tfor (auto row : use) {\n\t\tfor (bool col : row) {\n\t\t\tif (col)cout << \"#\";\n\t\t\telse cout << \".\";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n//routeの順に色を変更するので、\n//その時に、use=falseが①trueに隣接②routeの色と同じ　ならtrueにする\nint act(vector<vector<int>> p, vector<vector<bool>> use, vector<int> route)\n{\n\tint h = p.size();\n\tint w = p[0].size();\n\tuse[0][0] = true;\n\t//=================================\n\tfor (int next : route) {\n\t\tpaint(p, use, next);\n\t}\n\n\n\n\t//=================================\n\tint ans = 0;\n\tfor (auto row : use) {\n\t\tfor (auto col : row) {\n\t\t\tif (col)ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\n//計算\nvoid calc(vector<vector<int>> p, int c)\n{\n\tint ans = 0;\n\tvector<vector<bool>> use;\n\tREP(i, p.size())use.push_back(vector<bool>(p[0].size(), false));\n\n\t//色変化順\n\tREP(i, pow(6, 4)) {\n\t\tint j = i;\n\t\tvector<int> route;\n\t\troute.push_back(p[0][0]);\n\t\tREP(k, 4) {\n\t\t\troute.push_back(j % 6);\n\t\t\tj /= 6;\n\t\t}\n\t\troute.push_back(c);\n\t\tif (route[0] == route[1]\n\t\t\t|| route[1] == route[2]\n\t\t\t|| route[2] == route[3]\n\t\t\t|| route[3] == route[4]\n\t\t\t|| route[4] == route[5])continue;\n\t\tans = max(ans, act(p, use, route));\n\t}\n\tcerr << \"ans:\";\n\tcout << ans << endl;\n}\n\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tint h, w, c;\n\t\tvector<vector<int>> p;\n\t\tcin >> h >> w >> c;\n\t\tc--;\n\t\tif (h == 0)break;\n\n\t\tREP(i, h) {\n\t\t\tint tmp;\n\t\t\tvector<int> row;\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ttmp--;\n\t\t\t\trow.push_back(tmp);\n\t\t\t}\n\t\t\tp.push_back(row);\n\t\t}\n\t\tcalc(p, c);\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint change_color(vector<vector<int>>&fi, const int to_co) {\n\tqueue<pair<int, int>>que;\n\tconst int from_co = fi[1][1];\n\tque.push(make_pair(1, 1));\n\tfi[1][1] = -1;\n\twhile (!que.empty()) {\n\t\tconst auto p(que.front());\n\t\tque.pop();\n\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\tconst int nextx = p.first + dx[way];\n\t\t\tconst int nexty = p.second + dy[way];\n\t\t\tif (fi[nexty][nextx] == from_co) {\n\t\t\t\tfi[nexty][nextx] = -1;\n\t\t\t\tque.push(make_pair(nextx, nexty));\n\t\t\t}\n\t\t}\n\t}\n\tint num = 0;\n\tfor (auto& l : fi) {\n\t\tfor (auto& e : l) {\n\t\t\tif (e == -1) {\n\t\t\t\tnum++;\n\t\t\t\te = to_co;\n\t\t\t}\n\t\t}\n\t}\n\treturn num;\n}\n\nint solve(const vector<vector<int>>&ori_fi, const int rest) {\n\tif (!rest) {\n\t\tvector<vector<int>>n_fi(ori_fi);\n\t\treturn change_color(n_fi, -1);\n\t}\n\tint amax = 0;\n\tfor (int nc = 1; nc <= 6; ++nc) {\n\t\tvector<vector<int>>n_fi(ori_fi);\n\t\tchange_color(n_fi, nc);\n\t\tamax = max(amax, solve(n_fi, rest - 1));\n\t}\n\treturn amax;\n}\nint main() {\n\twhile (1) {\n\t\tint H, W, C; cin >> H >> W >> C;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> field[i + 1][j + 1];\n\t\t\t}\n\t\t}\n\t\tint ans = solve(field, C);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint data[8][8], odr[5], h, w, c, dy[] = {-1, 0, 1, 0}, dx[] = {0, 1, 0, -1}, tmp[8][8];\nbool vis[8][8];\n\nbool check(int y, int x){\n  if(y<0 || y>=h) return false;\n  if(x<0 || x>=w) return false;\n  return true;\n}\n\nvoid dfs(int y, int x, int p, int s){\n  vis[y][x] = true;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(!check(ny, nx)) continue;\n    if(tmp[ny][nx] != s) continue;\n    if(vis[ny][nx]) continue;\n    dfs(ny, nx, p, s);\n  }\n  tmp[y][x] = p;\n}\n\nint countPannel(int y, int x, int p){\n  int res = 1;\n  vis[y][x] = true;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(!check(ny, nx)) continue;\n    if(tmp[ny][nx] != p) continue;\n    if(vis[ny][nx]) continue;\n    res += countPannel(ny, nx, p);\n  }\n  return res;\n}\n\nint calc(){\n  for(int i=0;i<5;i++){\n    fill(vis[0], vis[8], false);\n    dfs(0, 0, odr[i], tmp[0][0]);\n  }\n  fill(vis[0], vis[8], false);\n  return countPannel(0, 0, odr[4]);\n}\n\nvoid init(){\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      tmp[i][j] = data[i][j];\n    }\n  }\n}\n\nmain(){\n  while(cin >> h >> w >> c && (h|w|c)){\n    odr[4] = c;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n      }\n    }\n    int ans = 0;\n    for(odr[0]=1;odr[0]<=6;odr[0]++){\n      for(odr[1]=1;odr[1]<=6;odr[1]++){\n        for(odr[2]=1;odr[2]<=6;odr[2]++){\n          for(odr[3]=1;odr[3]<=6;odr[3]++){\n            init();\n            ans = max(ans, calc());\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint h,w;\nint t[10][10];\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nbool in(int x, int y){\n    if(0 > x || x >= h) return false;\n    if(0 > y || y >= w) return false;\n    return true;\n}\n\nvoid change(int c){ //g[0][0]を色cに変える\n\n    int bef = t[0][0];\n    if(bef == c)return;\n    queue<pii> q;\n    q.push(pii(0,0));\n    while(q.size()){\n        int x = q.front().first;\n        int y = q.front().second;\n\n        t[x][y] = c;\n        q.pop();\n        rep(i,4){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(in(nx,ny) && t[nx][ny] == bef){\n                q.push(pii(nx,ny));\n            }\n        }\n    }\n}\n\nint count(int c){ //色cの連結成分の大きさを調べる\n\n    int ret = 0;\n    rep(i,h)rep(j,w)if(t[i][j] == c){\n        int cnt = 0;\n        queue<pii> q;\n        q.push(pii(i,j));\n        while(q.size()){\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            if(t[x][y] < 0)continue;\n\n            cnt++;\n            t[x][y] = -1;\n            rep(k,4){\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                if(in(nx,ny) && t[nx][ny] == c ){\n                    q.push(pii(nx,ny));\n                }\n            }\n        }\n\n        ret = max(ret, cnt);\n    }\n\n    return ret;\n}\n\nint main(void) {\n    int col;\n    while(cin >> h >> w >> col, h){\n        col--;\n        int g[10][10];\n        rep(i,h)rep(j,w)cin >> g[i][j],g[i][j]--;\n        int ans = 0;\n        rep(a,6)rep(b,6)rep(c,6)rep(d,6)rep(e,6){\n            rep(i,h)rep(j,w)t[i][j] = g[i][j];\n            change(a);\n            change(b);\n            change(c);\n            change(d);\n            change(e);\n            ans = max(ans, count(col));\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> Pos;\n\nint h,w,c;\nint ans;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nvector< vector<int> > change(vector< vector<int> > panel, int pre, int after)\n{\n  vector< vector<int> > visited(h+2,vector<int>(w+2,0));\n  queue<Pos> q;\n  q.push(Pos(1,1));\n  visited[1][1]=1;\n  while(!q.empty()){\n    Pos p=q.front();q.pop();\n    panel[p.first][p.second]=after;\n    for(int i=0;i<4;i++){\n      Pos next=p;\n      next.first+=dy[i];\n      next.second+=dx[i];\n      if(visited[next.first][next.second])continue;\n      if(panel[next.first][next.second]!=pre)continue;\n      q.push(next);\n      visited[next.first][next.second]=1;\n    }\n  }\n  return panel;\n}\n\nint count(vector< vector<int> > panel){\n  int cnt=1,color=panel[1][1];\n  vector< vector<int> > visited(h+2,vector<int>(w+2,0));\n  queue<Pos> q;\n  q.push(Pos(1,1));\n  visited[1][1]=1;\n  while(!q.empty()){\n    Pos p=q.front();q.pop();\n    for(int i=0;i<4;i++){\n      Pos next=p;\n      next.first+=dy[i];\n      next.second+=dx[i];\n      if(visited[next.first][next.second])continue;\n      if(panel[next.first][next.second]!=color)continue;\n      q.push(next);\n      visited[next.first][next.second]=1;\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\nvoid solve(vector< vector<int> > panel, int depth)\n{\n  if(depth==4){\n    ans=max(ans,count(change(panel,panel[1][1],c)));\n    return;\n  }\n  for(int i=1;i<=6;i++){\n    if(panel[1][1]==i)solve(panel,depth+1);\n    else solve(change(panel,panel[1][1],i),depth+1);\n  }\n  return;\n}\n\nint main()\n{\n  while(cin>>h>>w>>c,h|w|c){\n    vector< vector<int> > panel(h+2,vector<int>(w+2,-1));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>panel[i+1][j+1];\n      }\n    }\n    ans=0;\n    solve(panel,0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint map[9][9];\nint h,w,C;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nmain()\n{\n\twhile(cin>>h>>w>>C,h)\n\t{\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>map[i][j];\n\t\tint ans=0;\n\t\tfor(int a=1;a<7;a++)for(int b=1;b<7;b++)for(int c=1;c<7;c++)\n\t\t\tfor(int d=1;d<7;d++)\n\t\t\t{\n\t\t\t\tint now=0;\n\t\t\t\tbool used[9][9];\n\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)used[i][j]=0;\n\t\t\t\tused[0][0]=1;\n\t\t\t\tfor(int cnt=0;cnt<h;cnt++)\n\t\t\t\t{\n\t\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!used[i][j]&&map[i][j]==map[0][0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool flag=0;\n\t\t\t\t\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\t\t\t\t\tif(x>=0&&y>=0&&x<h&&y<w&&used[x][y])flag=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused[i][j]=flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int cnt=0;cnt<h;cnt++)\n\t\t\t\t{\n\t\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!used[i][j]&&map[i][j]==a)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool flag=0;\n\t\t\t\t\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\t\t\t\t\tif(x>=0&&y>=0&&x<h&&y<w&&used[x][y])flag=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused[i][j]=flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int cnt=0;cnt<h;cnt++)\n\t\t\t\t{\n\t\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!used[i][j]&&map[i][j]==b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool flag=0;\n\t\t\t\t\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\t\t\t\t\tif(x>=0&&y>=0&&x<h&&y<w&&used[x][y])flag=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused[i][j]=flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int cnt=0;cnt<h;cnt++)\n\t\t\t\t{\n\t\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!used[i][j]&&map[i][j]==c)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool flag=0;\n\t\t\t\t\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\t\t\t\t\tif(x>=0&&y>=0&&x<h&&y<w&&used[x][y])flag=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused[i][j]=flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int cnt=0;cnt<h;cnt++)\n\t\t\t\t{\n\t\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!used[i][j]&&map[i][j]==d)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool flag=0;\n\t\t\t\t\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\t\t\t\t\tif(x>=0&&y>=0&&x<h&&y<w&&used[x][y])flag=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused[i][j]=flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int cnt=0;cnt<h;cnt++)\n\t\t\t\t{\n\t\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!used[i][j]&&map[i][j]==C)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool flag=0;\n\t\t\t\t\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint x=i+dx[r],y=j+dy[r];\n\t\t\t\t\t\t\t\tif(x>=0&&y>=0&&x<h&&y<w&&used[x][y])flag=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused[i][j]=flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)now+=used[i][j];\n\t\t\t\tans=ans<now?now:ans;\n\t\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint h, w, c;\nvector<vi> fld;\nint ans;\n\nvoid paint(int col)\n{\n\tint tmp = fld[0][0];\n\tif (tmp == col) return;\n\tfld[0][0] = col;\n\tqueue<P> que;\n\tque.push(P(0, 0));\n\twhile (que.size())\n\t{\n\t\tint x = que.front().first, y = que.front().second;\n\t\tque.pop();\n\t\tREP(j, 4)\n\t\t{\n\t\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] == tmp)\n\t\t\t{\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t\tfld[nx][ny] = col;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(int i)\n{\n\tif (i == 4)\n\t{\n\t\tauto copy = fld;\n\t\tpaint(c);\n\t\tint cnt = 0;\n\t\tqueue<P> que;\n\t\tque.push(P(0, 0));\n\t\tfld[0][0] = -1;\n\t\twhile (que.size())\n\t\t{\n\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\tque.pop();\n\t\t\tcnt++;\n\t\t\tREP(j, 4)\n\t\t\t{\n\t\t\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] == c)\n\t\t\t\t{\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tfld[nx][ny] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchmax(ans, cnt);\n\t\tfld = copy;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tREP(j, 6)\n\t\t{\n\t\t\tauto copy = fld;\n\t\t\tpaint(j);\n\t\t\tsolve(i + 1);\n\t\t\tfld = copy;\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> h >> w >> c, h)\n\t{\n\t\tc--;\n\t\tans = 0;\n\t\tfld.clear();\n\t\tfld.resize(h, vi(w));\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tcin >> fld[i][j];\n\t\t\tfld[i][j]--;\n\t\t}\n\t\tsolve(0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define max(a,b) (a>b?a:b)\n\nint mv[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\nint ori[10][10];\nint map[10][10];\nint fa[100];\nint color[100];\n\nint x,y,tar;\n\nint find(int now){\n  if(fa[now]==-1)return now;\n  return fa[now] = find(fa[now]);\n}\n\nvoid chkun()\n{\n  int i,j,k;\n  int dx,dy;\n  for(i=0;i<x;i++){\n    for(j=0;j<y;j++){\n      for(k=0;k<4;k++){\n        dx = i + mv[k][0];\n        dy = j + mv[k][1];\n        if(0<=dx && dx<x && 0<=dy && dy<y){\n          if(find(map[dx][dy])!=find(map[i][j]) && color[find(map[dx][dy])]==color[find(map[i][j])]){\n            fa[find(map[dx][dy])] = find(map[i][j]);\n          }\n        }\n      }\n    }\n  }\n}\n\nint dfs(int a,int b, int c, int d, int e){\n\n    int i,j;\n\n    memset(fa,-1,sizeof(fa));\n    int cn = 0;\n    int tem,total;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n\n        tem = ori[i][j];\n        map[i][j] = cn;\n        color[cn] = tem;\n        cn++;\n      }\n    }\n    chkun();\n\n    color[find(map[0][0])] = a;\n    chkun();\n    color[find(map[0][0])] = b;\n    chkun();\n    color[find(map[0][0])] = c;\n    chkun();\n    color[find(map[0][0])] = d;\n    chkun();\n    color[find(map[0][0])] = e;\n    chkun();\n\n    tem = find(map[0][0]);\n    if(color[tem]!=tar)return 0;\n\n    total = 0;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        if(find(map[i][j])==tem)total++;\n      }\n    }\n    return total;\n\n}\n\nint main()\n{\n  int i,j,k,l,m;\n  int ans;\n  while(scanf(\"%d%d%d\",&x,&y,&tar)!=EOF){\n    if(!(x+y+tar))break;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        scanf(\"%d\",&ori[i][j]);\n      }\n    }\n\n    ans = 1;\n    for(i=1;i<=6;i++){\n      for(j=1;j<=6;j++){\n        for(k=1;k<=6;k++){\n          for(l=1;l<=6;l++){\n            for(m=1;m<=6;m++){\n              ans = max(ans,dfs(i,j,k,l,m));\n\n            }\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint w,h,Col;\ntypedef pair<int,int> C;\ntypedef vector<vector<int> > P;\nP V;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint res;\n\nvoid on(P N,int count,int c){\n\t\n\tif(count==6) return;\n\n\tint nc=N[0][0];\n\tqueue<C> Q;\n\tQ.push(make_pair(0,0));\n\tbool used[8][8];\n\tmemset(used,false,sizeof(used));\n\n\tint tres=0;\n\twhile(!Q.empty()){\n\t\tC now=Q.front();\n\t\tQ.pop();\n\t\tif(used[now.first][now.second]) continue;\n\t\tused[now.first][now.second]=true;\n\t\tN[now.first][now.second]=c;\n\t\ttres++;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint ny=now.first+dy[r],nx=now.second+dx[r];\n\t\t\tif(ny<0 || nx<0 || ny>=h || nx>=w) continue;\n\t\t\tif(N[ny][nx]==nc)\n\t\t\t\tQ.push(make_pair(ny,nx));\n\t\t}\n\t\tres=max(res,tres);\n\t}\n\n\tif(count!=4)\n\t\tfor(int i=1;i<=6;i++)\n\t\t\ton(N,count+1,i);\n\telse on(N,count+1,Col);\n}\n\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tV.resize(h);\n\n\tfor(int y=0;y<h;y++)\n\t\tfor(int x=0;x<w;x++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tV[y].push_back(t);\n\t\t}\n\t\n\tfor(int i=1;i<=6;i++){\n\t\t on(V,0,i);\n\t}\n\n\tcout<<res<<endl;\n\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w>>Col){\n\t\tif(w==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint h;\nint w;\nint c;\n\nint count(vector< vector<int> > &p, int b, int i, int j){\n  int cnt = 1;\n  for(int k = 0; k < 4; ++k){\n    if(i+dx[k] >= 0 && i+dx[k] < h && \n       j+dy[k] >= 0 && j+dy[k] < w &&\n       p[i+dx[k]][j+dy[k]] == b){\n      p[i+dx[k]][j+dy[k]] = -1;\n      cnt += count(p,b,i+dx[k],j+dy[k]);\n    }\n  }\n\n  return cnt;\n}\n\nvoid change(vector< vector<int> > &p, int b, int c, int i, int j){\n  for(int k = 0; k < 4; ++k){\n    if(i+dx[k] >= 0 && i+dx[k] < h && \n       j+dy[k] >= 0 && j+dy[k] < w &&\n       p[i+dx[k]][j+dy[k]] == b){\n      p[i+dx[k]][j+dy[k]] = c;\n      change(p, b, c, i+dx[k], j+dy[k]);\n    }\n  }\n}\n\nint solve(vector< vector<int> > p, int C[6]){\n  for(int i = 0; i < 5; ++i){\n    if(C[i] != C[i+1])\n      change(p,C[i],C[i+1],0,0);\n  }\n  p[0][0] = -1;\n  return count(p,C[5],0,0);\n}\n\nint main(){\n  while(cin >> h >> w >> c, h){\n    vector< vector<int> > p(h, vector<int>(w));\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j)\n\tcin >> p[i][j];\n\n    int ans = 0;\n    for(int a = 1; a < 7; ++a){\n      for(int b = 1; b < 7; ++b){\n\tfor(int d = 1; d < 7; ++d){\n\t  for(int e = 1; e < 7; ++e){\n\t    int C[6] = {p[0][0],a,b,d,e,c};\n\t    ans = max(ans, solve(p,C));\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint H,W,C;\nint board[8][8];\nint b[8][8];\nint check[8][8];\nint ord[5];\nint ans;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool in(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y, int color){\n    //cerr << x << \" \" << y << \" \" << color << endl;\n    check[y][x] = 1;\n    for(int k = 0; k < 4; k++){\n        int nx = x + dx[k], ny = y + dy[k];\n        if(!in(nx, ny) || b[ny][nx] != color || check[ny][nx]) continue;\n        dfs(nx, ny, color);\n    }\n}\n\nint calc(){\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            b[i][j] = board[i][j];\n        }\n    }\n    for(int t = 0; t < 5; t++){\n        //cout << ord[t] << endl;\n        memset(check, 0, sizeof check);\n        dfs(0, 0, b[0][0]);\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                if(check[i][j]) b[i][j] = ord[t];\n            }\n        }\n    }\n\n    memset(check, 0, sizeof check);\n    dfs(0, 0, b[0][0]);\n    int ret = 0;\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            if(check[i][j] && b[i][j] == C) ret++;\n        }\n    }\n    return ret;\n}\n\nvoid f(int n){\n    if(n == 5){\n        ans = max(ans, calc());\n        return;\n    }\n    for(int i = 1; i <= 6; i++){\n        ord[n] = i;\n        f(n + 1);\n    }\n}\n\nint main(){\n    while(cin >> H >> W >> C, H){\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                cin >> board[i][j];\n            }\n        }\n        ans = 0;\n        f(0);\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,c,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nvector<int> p(64);\n\nint nu(int x,int y,int cl,int t){\n  int res=1;\n  p[y*w+x]=cl;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||w<=nx||ny<0||h<=ny||p[ny*w+nx]!=t||p[ny*w+nx]==cl)continue;\n    res+=nu(nx,ny,cl,t);\n  }\n  return res;\n}\n\nint dfs(int d){\n  vector<int> tp=p;\n  int res=0;\n  if(d==4){\n    nu(0,0,c,p[0]);\n    return nu(0,0,7,p[0]);\n  }\n  for(int j=1;j<7;j++){\n    nu(0,0,j,p[0]);\n    res=max(res,dfs(d+1)),p=tp;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>h>>w>>c,h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>p[i*w+j];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG 1\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef long long ll;\n\nstruct UnionFind {\n    vector<int> par;\n    int cnt;\n    UnionFind(int size_) : par(size_, -1), cnt(size_) { }\n    bool merge(int x, int y){\n        x = find(x); y = find(y);\n        if (x != y) {\n            if (par[y] < par[x]) swap(x, y);\n            par[x] += par[y]; par[y] = x;\n            cnt--;\n        }\n        return x != y;\n    }\n    bool get(int x, int y){\n        return find(x) == find(y);\n    }\n    int find(int x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n    // optional\n    int size(int x){\n        return -par[find(x)];\n    }\n    // optional\n    int size(){\n        return cnt;\n    }\n};\n\n// UnionFind(size)\n// merge(x,y)\n// get(x,y)\n// find(x)\n// size(x)\n// size()\n\nint main(){\n    int h,w,c;\n    while(cin >> h >> w >> c && h){\n        c--;\n        int g[16][16], gg[16][16];\n        auto adrs = [&](int y, int x){ return x + y*w; };\n        rep(i,h)rep(j,w){\n            cin >> g[i][j];\n            g[i][j]--;\n        }\n        int const pat = 6*6*6*6*6;\n        int ans = 0;\n        rep(mask,pat){\n            rep(i,h)rep(j,w) gg[i][j] = g[i][j];\n            // g ha dame\n            int t = mask;\n            rep(i,5){\n                UnionFind uf(h*w);\n                rep(y,h)rep(x,w){\n                    int dx[] = {0,1};\n                    int dy[] = {1,0};\n                    rep(d,2){\n                        int nx = x+dx[d], ny = y+dy[d];\n                        if(nx >= w || ny >= h) continue;\n                        if(gg[y][x] == gg[ny][nx]) uf.merge(adrs(y,x), adrs(ny,nx));\n                    }\n                }\n                int cc = t%6;\n                rep(y,h)rep(x,w){\n                    if(uf.get(0, adrs(y,x))) gg[y][x] = cc;\n                }\n                t /= 6;\n            }\n            UnionFind uf(h*w);\n            {\n                int dx[] = {0,1};\n                int dy[] = {1,0};\n                rep(y,h)rep(x,w){\n                    rep(d,2){\n                        int nx = x+dx[d], ny = y+dy[d];\n                        if(nx == w || ny == h) continue;\n                        if(gg[y][x] == gg[ny][nx]) uf.merge(adrs(y,x), adrs(ny,nx));\n                    }\n                }\n            }\n            if(c == gg[0][0]) ans = max(ans, uf.size(0));\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int inf = 1e9;\n\nint h, w, c;\nint cnt;\nint ans;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nvoid change(VV &b, int oc, int nc, int i, int j) {\n    if (nc == oc) return;\n    if (!inside(i, j)) return;\n    if (b[i][j] != oc) return;\n    b[i][j] = nc;\n    cnt++;\n    rep(k, 4) {\n        change(b, oc, nc, i + dx[k], j + dy[k]);\n    }\n}\n\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> h >> w >> c, h) {\n        VV a(h, V(w));\n        rep(i, h) rep(j, w) cin >> a[i][j];\n\n        int ans = -1;\n\n        rep(s, pow(6, 4)) {\n            VV b = a;\n            int perm = s;\n            rep(step, 4) {\n                change(b, b[0][0], (perm % 6) + 1, 0, 0);\n                perm /= 6;\n            }\n            change(b, b[0][0], c, 0, 0);\n\n            cnt = 0;\n            change(b, b[0][0], 10, 0, 0);\n            ans = max(ans, cnt);\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int THUNDER=5;\nint h,w,c;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nbool isrange(int x,int y){return 0<=x && x<h && 0<=y && y<w;}\n\nint elec(int time,vector<vector<int>> p){\n  if(time==THUNDER){\n    queue<pair<int,int>> que;\n    int color=p[0][0];\n    if(color!=c) return 0;\n    int res=1;\n    que.push(make_pair(0,0));\n    p[0][0]=-1;\n    while(!que.empty()){\n      auto place=que.front();\n      que.pop();\n      for(int i=0;i<4;i++){\n\tint tox=place.first+dx[i];\n\tint toy=place.second+dy[i];\n\tif(isrange(tox,toy) && p[tox][toy]==color){\n\t  res++;\n\t  p[tox][toy]=-1;\n\t  que.push(make_pair(tox,toy));\n\t}\n      }\n     \n    }\n\n    return res;\n  }\n  int res=0;\n  for(int toc=0;toc<6;toc++){\n    vector<vector<int>> newp=p;\n    int color=p[0][0];\n    queue<pair<int,int>> que;\n    que.push(make_pair(0,0));\n    newp[0][0]=-1;\n    while(!que.empty()){\n      auto place=que.front();\n      que.pop();\n      for(int i=0;i<4;i++){\n\tint tox=place.first+dx[i];\n\tint toy=place.second+dy[i];\n\tif(isrange(tox,toy) && p[tox][toy]==color && newp[tox][toy]!=-1){\n\t  newp[tox][toy]=-1;\n\t  que.push(make_pair(tox,toy));\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(newp[i][j]==-1) newp[i][j]=toc;\n      }\n    }\n    res=max(res,elec(time+1,newp));\n    \n  }\n  \n  return res;\n}\n\nint main(){\n\n  while(cin>>h>>w>>c,h){\n    vector<vector<int>> p(h,vector<int>(w));\n    c--;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>p[i][j];\n\tp[i][j]--;\n      }\n    }\n    int res=elec(0,p);\n    cout<<res<<endl;\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint d1[4] = { 1,0,-1,0 };\nint d2[4] = { 0,1,0,-1 };\nint panel[10][10];\nint cop[10][10];\nvoid init() {\n\trep(i, 10) {\n\t\trep(j, 10) {\n\t\t\tcop[i][j] = panel[i][j];\n\t\t}\n\t}\n}\nvoid trans(int col) {\n\tqueue<P> q; q.push({ 1,1 });\n\tint used[10][10] = {}; int memo = cop[1][1];\n\tused[1][1] = 1; cop[1][1] = col;\n\twhile (!q.empty()) {\n\t\tP now = q.front(); q.pop();\n\t\trep(k, 4) {\n\t\t    int nx = now.first+d1[k]; int ny = now.second+d2[k];\n\t\t\tif (cop[nx][ny] == memo && used[nx][ny] == 0) {\n\t\t\t\tused[nx][ny] = 1;\n\t\t\t\tcop[nx][ny] = col;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n}\nint count(int col) {\n\tint res = 1;\n\tqueue<P> q; q.push({ 1,1 });\n\tint used[10][10] = {}; int memo = cop[1][1];\n\tused[1][1] = 1;\n\twhile (!q.empty()) {\n\t\tP now = q.front(); q.pop();\n\t\trep(k, 4) {\n\t\t\tint nx = now.first + d1[k]; int ny = now.second + d2[k];\n\t\t\tif (cop[nx][ny] == memo && used[nx][ny] == 0) {\n\t\t\t\tused[nx][ny] = 1;\n\t\t\t\tres++;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint h, w, c;\n\twhile (cin >> h >> w >> c, h) {\n\t\trep(i, 10) {\n\t\t\trep(j, 10) {\n\t\t\t\tpanel[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\trep1(i, h) {\n\t\t\trep1(j, w) {\n\t\t\t\tcin >> panel[i][j];\n\t\t\t}\n\t\t}\n\t\tint ma = 1;\n\t\trep1(i1, 6) {\n\t\t\tif (i1 == panel[1][1])continue;\n\t\t\trep1(i2, 6) {\n\t\t\t\tif (i2 == i1)continue;\n\t\t\t\trep1(i3, 6) {\n\t\t\t\t\tif (i3 == i2)continue;\n\t\t\t\t\trep1(i4, 6) {\n\t\t\t\t\t\tinit();\n\t\t\t\t\t\ttrans(i1); trans(i2); trans(i3); trans(i4); trans(c);\n\t\t\t\t\t\tma = max(ma, count(c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ma << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint H, W, c, f, a[9][9], b[9][9], g[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e; f++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nint solve(int d) {\n\tif (d == 4) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) g[i][j] = b[i][j];\n\t\t}\n\t\tf = 0; rec(0, 0, c);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) b[i][j] = g[i][j];\n\t\t}\n\t\treturn f;\n\t}\n\tint ret = 0;\n\tfor (int i = 1; i <= 6; i++) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) g[i][j] = b[i][j];\n\t\t}\n\t\tf = 0; rec(0, 0, c);\n\t\tret = max(ret, solve(d + 1));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) b[i][j] = g[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint paint(vector< vector<int> > &field, int x, int y, int c){\n\tint W = field[0].size(), H = field.size();\n\tif(x < 0 || x >= W || y < 0 || y >= H || field[y][x] != c){ return 0; }\n\tfield[y][x] = -1;\n\tint count = 1;\n\tcount += paint(field, x - 1, y, c);\n\tcount += paint(field, x + 1, y, c);\n\tcount += paint(field, x, y - 1, c);\n\tcount += paint(field, x, y + 1, c);\n\treturn count;\n}\n\nint solve(vector< vector<int> > field, int c, int depth = 4){\n\tint W = field[0].size(), H = field.size();\n\tint result = 0, prev = field[0][0];\n\tif(depth == 0){\n\t\tpaint(field, 0, 0, prev);\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tif(field[i][j] < 0){ field[i][j] = c; }\n\t\t\t}\n\t\t}\n\t\tresult = paint(field, 0, 0, c);\n\t}else{\n\t\tfor(int i = 1; i <= 6; ++i){\n\t\t\tif(i == prev){ continue; }\n\t\t\tvector< vector<int> > next = field;\n\t\t\tpaint(next, 0, 0, prev);\n\t\t\tfor(int j = 0; j < H; ++j){\n\t\t\t\tfor(int k = 0; k < W; ++k){\n\t\t\t\t\tif(next[j][k] < 0){ next[j][k] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = max(result, solve(next, c, depth - 1));\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\twhile(true){\n\t\tint h, w, c;\n\t\tcin >> h >> w >> c;\n\t\tif(h == 0 && w == 0 && c == 0){ break; }\n\t\tvector< vector<int> > p(h, vector<int>(w));\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){ cin >> p[i][j]; }\n\t\t}\n\t\tcout << solve(p, c) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[6][9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[y][x] == b[ty][tx] && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nvoid cpy(int d, int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[d][i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[d][i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0; cpy(d, 0);\n\tif (b[0][0] != c) rec(0, 0, c);\n\tcpy(0, 2), ret = rec1(0, 0), cpy(d, 1);\n\tif (d < 4) {\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(d, 0), rec(0, 0, i);\n\t\t\tret = max(ret, solve(d + 1)), cpy(d, 1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint bfs(vector<vector<int> >& grid, int c)\n{\n  const int H = grid.size(), W = grid[0].size();\n  vector<vector<int> > dist(H, vector<int>(W, false));\n  dist[0][0] = true;\n  queue<pair<int,int> > q;\n  q.push(make_pair(0, 0));\n  const int color = grid[0][0];\n  int cnt = 0;\n  while (!q.empty()) {\n    const int i = q.front().first, j = q.front().second;\n    q.pop();\n    ++cnt;\n    grid[i][j] = c;\n    for (int d = 0; d < 4; d++) {\n      static const int di[] = {-1, 1, 0, 0}, dj[] = {0, 0, -1, 1};\n      const int k = i + di[d], l = j + dj[d];\n      if (0 <= k && k < H && 0 <= l && l < W && grid[k][l] == color && !dist[k][l]) {\n        dist[k][l] = true;\n        q.push(make_pair(k, l));\n      }\n    }\n  }\n  return cnt;\n}\n\nint dfs(const vector<vector<int> >& grid, int depth, int C)\n{\n  if (depth == 0) {\n    if (grid[0][0] == C) {\n      vector<vector<int> > g(grid);\n      return bfs(g, C);\n    } else {\n      return 0;\n    }\n  } else {\n    int ans = 0;\n    for (int i = 1; i <= 6; i++) {\n      vector<vector<int> > g(grid);\n      bfs(g, i);\n      ans = max(ans, dfs(g, depth-1, C));\n    }\n    return ans;\n  }\n}\n\nint main()\n{\n  int H, W, C;\n  while (cin >> H >> W >> C && H != 0) {\n    vector<vector<int> > grid(H, vector<int>(W));\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        cin >> grid[i][j];\n      }\n    }\n    cout << dfs(grid, 5, C) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint repaint(vvi& grid,int before,int after,int i,int j)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]!=before)\n\t\treturn 0;\n\tgrid[i][j]=after;\n\tint di[]={-1,1,0,0},dj[]={0,0,-1,1},res=1;\n\trep(k,4)\n\t\tres+=repaint(grid,before,after,i+di[k],j+dj[k]);\n\treturn res;\n}\n\nint calc(vvi grid,vi seq)\n{\n\trep(i,5) if(seq[i]!=grid[0][0])\n\t\trepaint(grid,grid[0][0],seq[i],0,0);\n\treturn repaint(grid,grid[0][0],9,0,0);\n}\n\nint main()\n{\n\tfor(int h,w,c;cin>>h>>w>>c,h|w|c;){\n\t\tc--;\n\t\tvvi grid(h,vi(w));\n\t\trep(i,h) rep(j,w) cin>>grid[i][j];\n\t\trep(i,h) rep(j,w) grid[i][j]--;\n\t\t\n\t\tint res=0;\n\t\trep(i,6*6*6*6){\n\t\t\tvi seq(5,c);\n\t\t\tfor(int j=0,k=i;j<4;j++,k/=6)\n\t\t\t\tseq[j]=k%6;\n\t\t\tres=max(res,calc(grid,seq));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algotithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\nconst int dx[4] = {1,-1,1,-1};\nconst int dy[4] = {-1,-1,1,1};\nconst int NUMC = 6;\nint h,w,c;\nvector<vector<int> > mp;\nint dfs(int def_i,int def_j,int depth,int col){\n\tint num_panel[NUMC] = {};\n\tqueue<pair<int,int> > que;\n\tque.push(i,j);\n\twhile(!que.empty()){\n\t\tpair<int,int> P = que.top();\n\t\tque.push();\n\t\tREP(i,4){\n\t\t\tint y = P.first + dy[i];\n\t\t\tint x = P.second + dx[i];\n\t\t\tif(x<0 || y<0 || x>=w || \n\t\t}\n\t\t\t\n\tif(depth<5){\n\t\tREP(col_i,NUMC){\n\t\t\tif(depth == 4 && col_i+1 != c || depth == 3 && col_i+1 == c)continue;\n\t\t\tnum_panel[col_i] = dfs(i,j,depth+1,col_i+1);\n\t\t}\n\t\treturn *max_element(num_panel,num_panel+NUMC);\n\t}else if(depth == 5){\n\t\treturn ct;\n\t}\n}\n\nint main(){\n\n\twhile(cin >> h>>w>>c,h||w||c){\n\t\tmp.resize(h,vector<int>(w));\n\t\tREP(i,h)\n\t\t\tREP(j,w)cin >> mp[i][j];\n\t\tint ans = 0;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tREP(col_i,NUMC){\n\t\t\t\t\tans = max(ans,dfs(i,j,1,col_i+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint h, w, c, p[8][8];\nbool used[8][8];\n\nint search(int color) {\n  for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++) used[i][j] = false;\n  int before = p[0][0];\n  queue<P> que;\n  que.push(P(0, 0));\n  p[0][0] = color;\n  used[0][0] = true;\n  int counter = 1;\n  while (!que.empty()) {\n    P q = que.front(); que.pop();\n    int x = q.first, y = q.second;\n    for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n      if (used[ny][nx]) continue;\n      used[ny][nx] = true;\n      if (p[ny][nx] == before) {\n        counter++;\n        p[ny][nx] = color;\n        que.push(P(nx, ny));\n      }\n    }\n  }\n  return counter;\n}\n\nint dfs(int counter, int nowNumber) {\n  int copy[8][8];\n  for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++) copy[i][j] = p[i][j];\n  int ans = nowNumber;\n  for (int i = 1; i <= 6; i++) {\n    if (i == copy[0][0]) continue;\n    if (counter == 0 && i != c) continue;\n    for (int j = 0; j < h; j++)\n      for (int k = 0; k < w; k++) p[j][k] = copy[j][k];\n    search(i);\n    int temp = search(p[0][0]);\n    if (counter == 0) ans = max(ans, temp);\n    else if(temp != nowNumber) ans = max(ans, dfs(counter - 1, temp));\n  }\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d%d\", &h, &w, &c);\n    if (h == 0) break;\n    for (int i = 0; i < h; i++)\n      for (int j = 0; j < w; j++) scanf(\"%d\", &p[i][j]);\n    printf(\"%d\\n\", dfs(4, 0));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n\nint H, W, C;\nint panel[8][8];\nint ans;\nint used[8][8];\n\nint dfs2(int x, int y, int c) {\n\tint ret = 0;\n\tused[y][x] = 1;\t\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\tif ( nx < 0 || ny < 0 || nx >= W || ny >= H ||\n\t\t\t\t used[ny][nx] || panel[ny][nx] != c ) continue;\n\t\tret += dfs2(nx, ny, c); \n\t}\n\n\treturn ret+1;\t\n}\n\nvoid dfs3(int x, int y, int c, int d) {\n\tused[y][x] = 1;\n\tpanel[y][x] = d;\t\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\tif ( nx < 0 || ny < 0 || nx >= W || ny >= H ||\n\t\t\t\t used[ny][nx] || panel[ny][nx] != c ) continue;\n\t\tdfs3(nx, ny, c, d);\t\t\n\t}\n}\n\nvoid dfs(int cnt) {\n\tint tmp[8][8];\n\tfor ( int i = 0; i < H; i++ )\n\t\tfor ( int j = 0; j < W; j++ )\t\t\t\t\n\t\t\ttmp[i][j] = panel[i][j];\n\n\tif ( cnt == 5 ) {\n\t\tif ( panel[0][0] == C ) {\n\t\t\tfill_n(*used, 8*8, 0);\t\t\n\t\t\tans = max(ans, dfs2(0, 0, panel[0][0]));\n\t\t}\n\t} else {\n\t\tfor ( int i = 1; i <= 6; i++ ) {\n\t\t\t//if ( panel[0][0] == i ) continue;\n\t\t\tfill_n(*used, 8*8, 0);\t\t\n\t\t\tdfs3(0, 0, panel[0][0], i);\t\t\n\t\t\tdfs(cnt+1);\n\t\t\tfor ( int k = 0; k < H; k++ )\n\t\t\t\tfor ( int j = 0; j < W; j++ )\t\t\t\t\n\t\t\t\t\tpanel[k][j] = tmp[k][j];\n\t\t}\n\t}\n\t\n}\n\nint main() {\n\twhile ( cin >> H >> W >> C, H ) {\n\t\tans = 0;\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t\tfor ( int j = 0; j < W; j++ )\t\t\t\t\n\t\t\t\tcin >> panel[i][j];\n\n\t\tdfs(0);\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef vector<vector<int> > vvi; \ntypedef pair<int, int> P;\n\nint h, w, c;\nvector<vector<int> > p;\n\nint dy[4] = {1, -1 ,0, 0};\nint dx[4] = {0, 0, 1, -1};\n\nbool contain(int y, int x){\n\treturn (0 <= y && y < h && 0 <= x && x < w);\n}\n\nint ans = 0;\n\nvvi change(vvi a, int k, int y = 0, int x = 0){\n\tint color = a[y][x];\n\tbool f[10][10] = {};\n\tqueue<P> q;\n\tq.push(P(y, x));\n\tf[y][x] = true;\n\ta[y][x] = k;\n\tans = 1;\n\twhile(!q.empty()){\n\t\tP p = q.front(); q.pop();\n\t\trep(i, 0, 4){\n\t\t\tint ny = p.first + dy[i];\n\t\t\tint nx = p.second + dx[i];\n\t\t\tif(!contain(ny, nx) || f[ny][nx]) continue;\n\t\t\t// cout << 2 << endl;\n\t\t\tf[ny][nx] = true;\n\t\t\tif(a[ny][nx] != color) continue; \n\t\t\ta[ny][nx] = k;\n\t\t\tans++;\n\t\t\tq.push(P(ny, nx));\n\t\t}\n\t}\n\treturn a;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> h >> w >> c;\n\t\t// cout << h << w << c << endl;\n\t\tc--;\n\t\tif(h + w + c == -1) break;\n\t\tp.clear();\n\t\tp.resize(h, vector<int>(w));\n\t\trep(i, 0, h){\n\t\t\trep(j, 0, w){\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tp[i][j]--;\n\t\t\t}\n\t\t}\n\t\t// cout << 1 << endl;\n\t\tint MAX = 0;\n\t\trep(i, 0, 6){\n\t\t\tvvi a = change(p, i);\n\t\t\trep(j, 0, 6){\n\t\t\t\tvvi b = change(a, j);\n\t\t\t\trep(k, 0, 6){\n\t\t\t\t\tvvi d = change(b, k);\n\t\t\t\t\trep(l, 0, 6){\n\t\t\t\t\t\tvvi e = change(d, l);\n\t\t\t\t\t\tvvi g = change(e, c);\n\t\t\t\t\t\tvvi z = change(g, 0);\n\t\t\t\t\t\t// if(MAX < ans){\n\t\t\t\t\t\t// \trep(y, 0, h){\n\t\t\t\t\t\t// \t\trep(x, 0, w){\n\t\t\t\t\t\t// \t\t\tcout << z[y][x];\n\t\t\t\t\t\t// \t\t}\n\t\t\t\t\t\t// \t\tcout << endl;\n\t\t\t\t\t\t// \t}\n\t\t\t\t\t\t// \tcout << endl;\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tMAX = max(MAX, ans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << MAX << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint panel[8][8];\nint check[8][8][6];\nint h,w,c,color,cnt_max;\n\nint change( int mae, int ato, int x ) {\n  for( int i = 0; i < h; i++ ) {\n    for ( int j = 0; j < w; j++ ) {\n      if ( check[j][i][x] == mae ) check[j][i][x] = ato;\n    }\n  }\n  return 0;\n}\n\nint changep( int x, int y , int z ) {\n  if ( x != 0 ) {\n    if ( panel[x-1][y] == color && check[x-1][y][z] != check[x][y][z] ) {\n      change( check[x-1][y][z], check[x][y][z] , z );\n    }\n  }\n  if ( x != w-1 ) {\n    if ( panel[x+1][y] == color && check[x+1][y][z] != check[x][y][z] ) {\n      change( check[x+1][y][z], check[x][y][z] , z );\n    }\n  }\n  if ( y != 0 ) {\n    if ( panel[x][y-1] == color && check[x][y-1][z] != check[x][y][z] ) {\n      change( check[x][y-1][z], check[x][y][z] , z );\n    }\n  }\n  if ( y != h-1 ) {\n    if ( panel[x][y+1] == color && check[x][y+1][z] != check[x][y][z] ) {\n      change( check[x][y+1][z], check[x][y][z] , z );\n    }\n  }\n  return 0;\n}\n\nint count() {\n  int cnt = 0;\n  for ( int i = 0; i < h; i++ ) {\n    for ( int j = 0; j < w; j++ ) {\n      if ( check[j][i][5] == 0 ) cnt++;\n    }\n  }\n  cnt_max = max( cnt_max, cnt );\n  \n  return 0;\n}\n\nint saiki( int color_pre, int cnt ) {\n    for ( int k = 1; k < 7; k++ ) {\n      color = k;\n      if ( cnt == 4 ) color = c;\n      for ( int i = 0; i < h; i++ ) {\n\tfor ( int j = 0; j < w; j++ ) {\n\t  check[j][i][cnt+1] = check[j][i][cnt];\n\t}\n      }\n      for ( int i = 0; i < h; i++ ) {\n\tfor ( int j = 0; j < w; j++ ) {\n\t  if ( check[j][i][cnt+1] == 0 ) changep( j, i , cnt+1 );\n\t}\n      }\n      if ( cnt < 4 ) {\n\tsaiki( k, cnt+1 );\n      }else {\n\tcount();\n      }\n    }\n  return 0;\n}\n\nint main() {\n\n  while(true) {\n\n    cin >> h >> w >> c;\n    if ( h == 0 ) break;\n\n    int num = 0;\n    for ( int i = 0; i < h; i++ ) {\n      for ( int j = 0; j < w; j++ ) {\n\n\tcin >> panel[j][i];\n\tif ( i != 0 && j != 0 ) {\n\t  if ( panel[j-1][i] == panel[j][i] && panel[j][i-1] == panel[j][i] ) {\n\t    change( check[j-1][i][0] , check[j][i-1][0], 0 );\n\t    check[j][i][0] = check[j-1][i][0];\n\t    continue;\n\t  }\n\t}\n\tif ( i!= 0 ) {\n\t  if ( panel[j][i-1] == panel[j][i] ) {\n\t    check[j][i][0] = check[j][i-1][0];\n\t    continue;\n\t  }\n\t}\n\tif ( j!= 0 ) {\n\t  if ( panel[j-1][i] == panel[j][i] ) {\n\t    check[j][i][0] = check[j-1][i][0];\n\t    continue;\n\t  }\n\t}\n\tcheck[j][i][0] = num;\n\tnum++;\n\n      }\n    }\n\n    cnt_max = 0;\n    saiki( panel[0][0], 0 );\n    cout << cnt_max/*check[0][0]*/ << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint h, w, c;\n\ntypedef vector<vector<int> > matrix;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nmatrix bfs(matrix ba, int color) {\n  queue<pii> Q;\n  Q.push(pii(0,0));\n  bool visited[w][h];\n  memset(visited,0,sizeof(visited));\n\n  int hoge = ba[0][0] ;\n  \n  while(!Q.empty()) {\n    int x = Q.front().first;\n    int y = Q.front().second;\n    Q.pop();\n    if (visited[x][y]) continue;\n    visited[x][y] = 1;\n    ba[x][y] = color;\n    \n    REP(k,4) {\n      int xx = x+dx[k];\n      int yy = y+dy[k];\n\n      if (xx<0||xx>=w||yy<0||yy>=h) continue;\n      if (ba[xx][yy]!=hoge||visited[xx][yy])continue;\n      Q.push(pii(xx,yy));\n    }\n  }\n  return ba;\n}\n\nint bfs2(matrix ba) {\n  queue<pii> Q;\n  Q.push(pii(0,0));\n  bool visited[w][h];\n  memset(visited,0,sizeof(visited));\n\n  int hoge = ba[0][0] ;\n  int cnt = 0;\n  while(!Q.empty()) {\n    int x = Q.front().first;\n    int y = Q.front().second;\n    Q.pop();\n    if (visited[x][y]) continue;\n    visited[x][y] = 1;\n    cnt++;\n    \n    REP(k,4) {\n      int xx = x+dx[k];\n      int yy = y+dy[k];\n\n      if (xx<0||xx>=w||yy<0||yy>=h) continue;\n      if (ba[xx][yy] != hoge || visited[xx][yy])continue;\n      Q.push(pii(xx,yy));\n    }\n  }\n  return cnt;\n}\n\nint solve(matrix ba, int cnt) {\n  if (cnt == 5) {\n    int hoge = bfs2(ba);\n\n    return hoge;\n  }\n  if (cnt==4)\n    return bfs2(bfs(ba,c-1));\n  int res = 0;\n  REP(i,6) {\n    if (ba[0][0] == i) continue;\n    res = max(res, solve(bfs(ba, i), cnt+1));\n  }\n  return res;\n}\nint main() {\n  while(cin>>h>>w>>c, h) {\n    matrix ba(w,vector<int>(h));\n    REP(y,h)\n      REP(x,w) {\n      cin>>ba[x][y];\n      ba[x][y]--;\n    }\n    cout << solve(ba,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint h,w,c;\nint p[10][10];\nint ans;\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvoid ch(int x,int y,int z, int zz ){\n  if( x<0 || y<0 ) return;\n  if( x>=h || y>=w ) return;\n  if( p[x][y]!=zz ) return;\n  p[x][y]=z;\n\n  for( int lp=0;lp<4;lp++ ){\n    ch( x+dx[lp],y+dy[lp],z,zz );\n  }\n}\n\nint countC(int x,int  y,int z){\n  int ret=1, i,j;\n  if( x<0 || y<0 ) return 0;\n  if( x>=h || y>=w ) return 0;\n  if( p[x][y]!=z )    return 0;\n  \n  p[x][y]=0;\n  for( int lp=0;lp<4;lp++ ){\n    i=x+dx[lp]; j=y+dy[lp];\n    ret += countC( i,j,z );\n  }\n  return ret;\n}\n\n\nvoid rec(int n ){\n  int b[10][10];\n  if( n==0 ){\n    if( p[0][0]!=c ) return;\n\n    int aa=countC(0,0,p[0][0]);\n    if( aa>ans ){\n      ans=aa;\n      /*\n      cout << \"max=\"<<ans<<endl;\n      for( int i=0;i<h;i++ ){\n\tfor( int j=0;j<w;j++ )\n\t  cout << p[i][j] << \" \";\n\tcout << endl;\n      }\n      */\n    }\n    return;\n  }\n  --n;\n\n  for( int lp=1;lp<=6;lp++ ){\n    if( p[0][0]==lp ) continue;\n\n    for( int a=0;a<h;a++ ) for( int aa=0;aa<w;aa++ ) b[a][aa]=p[a][aa];\n    ch( 0,0,lp,p[0][0] );\n    rec( n );\n    for( int a=0;a<h;a++ ) for( int aa=0;aa<w;aa++ ) p[a][aa]=b[a][aa];\n  }\n}\n\n\nint main(){\n\n  while( cin>>h>>w>>c && (h|w|c) ){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ )\n\tcin >> p[i][j];\n\n    ans=0;\n    rec(5);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nnamespace ICPC {\n    array<array<int, 12>, 12> G{}, visited{};\n    int h, w, c;\n    int ans = 0;\n\n    void dfs(int depth){\n        for (int i = 1; i <= 6; ++i) {\n            int color = G[1][1];\n            if(color == i) continue;\n            queue<pair<int, int>> Q;\n            Q.emplace(1, 1);\n            array<int, 4> di{-1, 1, 0, 0}, dj{0, 0, 1, -1};\n            vector<pair<int, int>> v;\n            G[1][1] = i;\n            while(!Q.empty()){\n                auto p = Q.front(); Q.pop();\n                v.emplace_back(p);\n                int y, x; tie(y, x) = p;\n                for (int k = 0; k < 4; ++k) {\n                    if(G[y+di[k]][x+dj[k]] == color){\n                        G[y+di[k]][x+dj[k]] = i;\n                        Q.emplace(y+di[k], x+dj[k]);\n                    }\n                }\n            }\n            if(depth == 4 && i == c) {\n                for (int j = 0; j < h; ++j) {\n                    for (int k = 0; k < w; ++k) {\n                        visited[j+1][k+1] = 0;\n                    }\n                }\n                int cnt = 0;\n                Q.emplace(1, 1);\n                while(!Q.empty()){\n                    auto p = Q.front(); Q.pop();\n                    int y, x; tie(y, x) = p;\n                    visited[y][x] = 1;\n                    cnt++;\n                    for (int k = 0; k < 4; ++k) {\n                        if(G[y+di[k]][x+dj[k]] == i && !visited[y+di[k]][x+dj[k]]){\n                            Q.emplace(y+di[k], x+dj[k]);\n                            visited[y+di[k]][x+dj[k]] = 1;\n                        }\n                    }\n                }\n                ans = max(ans, cnt);\n            }else if(depth <= 3) {\n                dfs(depth+1);\n            }\n            for (auto &&j : v) {\n                G[j.first][j.second] = color;\n            }\n        }\n    }\n\n    void solve(int H, int W, int C){\n        h = H, w = W, c = C;\n        for (int i = 0; i <= h+1; ++i) {\n            for (int j = 0; j <= w+1; ++j) {\n                G[i][j] = -1;\n            }\n        }\n        for (int i = 1; i <= h; ++i) {\n            for (int j = 1; j <= w; ++j) {\n                cin >> G[i][j];\n            }\n        }\n        ans = 0;\n        dfs(0);\n        cout << ans << \"\\n\";\n    }\n}\n\nint main() {\n    int h, w, c;\n    while(cin >> h >> w >> c, h){\n        ICPC::solve(h, w, c);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[]={-1,0,1,0},dy[]={0,-1,0,1};\n\nint ans,h,w,c;\nint tmp;\nint flag[8][8];\n\nvoid print(int panel[8][8]){\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n\n      if(j) cout<<\" \";\n      cout<<panel[i][j];\n\n    }\n\n    cout<<endl;\n\n  }\n\n}\n\nvoid dfs2(int y,int x,int color,int next[8][8]){\n\n  flag[y][x]=1;\n\n  for(int i=0;i<4;i++){\n\n    int y1=y+dy[i];\n    int x1=x+dx[i];\n\n    if(y1<0 || y1>=h) continue;\n    if(x1<0 || x1>=w) continue;\n\n    if(next[y][x]==next[y1][x1])\n      if(!flag[y1][x1])\n\tdfs2(y1,x1,color,next);\n\n  }\n\n  next[y][x]=color;\n\n}\n\nvoid dfs3(int y,int x,int panel[8][8]){\n\n  flag[y][x]=1;\n\n  if(panel[y][x]!=c) return;\n\n  tmp++;\n\n  for(int i=0;i<4;i++){\n\n    int y1=y+dy[i];\n    int x1=x+dx[i];\n\n    if(y1<0 || y1>=h) continue;\n    if(x1<0 || x1>=w) continue;\n\n    if(!flag[y1][x1])\n      dfs3(y1,x1,panel);\n\n  }\n\n}\n\n\nvoid dfs1(int y,int x,int (&panel)[8][8],int how){\n\n  if(how==5){\n\n    tmp=0;\n    for(int j=0;j<h;j++) for(int k=0;k<w;k++) flag[j][k]=0;\n\n    dfs3(y,x,panel);\n    ans=max(ans,tmp);\n\n    return;\n\n  }\n\n  for(int i=1;i<=6;i++){\n\n    int next[8][8];\n    for(int j=0;j<h;j++) for(int k=0;k<w;k++) next[j][k]=panel[j][k],flag[j][k]=0;\n\n    dfs2(y,x,i,next);\n    dfs1(y,x,next,how+1);\n\n  }\n\n}\n\nsigned main(){\n\n  for(;;){\n\n  cin>>h>>w>>c;\n\n  if(!h) break;\n\n  int panel[8][8];\n\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin>>panel[i][j];\n\n  ans=0;\n\n  dfs1(0,0,panel,0);\n\n  cout<<ans<<endl;\n\n  }\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nint h,w,c;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\nint p[8][8];\nbool ck[8][8];\nbool valid(int x, int y){\n  return x>=0&&x<w&&y>=0&&y<h;\n}\nvoid check(int x, int y, int c){\n  if(ck[y][x]) return;\n  if(p[y][x]==c) ck[y][x] = true;\n  else return;\n  REP(r,4){\n    int nx = x+dx[r];\n    int ny = y+dy[r];\n    if(valid(nx,ny)){\n      check(nx,ny,c);\n    }\n  }\n}\nvoid printp(){\n  REP(y,h){\n    REP(x,w)printf(\"%d \",p[y][x]);\n    putchar('\\n');\n  }\n}\nint dfs(int t){\n  int ret = 0;\n  if(t==5){\n    memset(ck,0,sizeof(ck));\n    check(0,0,c);\n    REP(y,h)REP(x,w)if(ck[y][x])ret++;\n  }else{\n    int tmp[8][8];\n    memcpy(tmp,p,sizeof(p));\n    REP(nc,6){\n      memset(ck,0,sizeof(ck));\n      check(0,0,p[0][0]);\n      REP(y,h)REP(x,w)if(ck[y][x])p[y][x] = nc;\n      ret = max(ret,dfs(t+1));\n      memcpy(p,tmp,sizeof(tmp));\n    }\n  }\n  return ret;\n}\nint main(){\n  while(cin>>h>>w>>c,h){\n    c--;\n    REP(y,h)REP(x,w)cin>>p[y][x],p[y][x]--;\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint h, w, c;\nconst int dx[4] = {0,-1,0,1};\nconst int dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nint countDFS(vector< vector< int > >& p, int x, int y, int cur) {\n\tp[y][x] = -1;\n\tint res = 1;\n\tfor_(d,0,4) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (!in_range(nx, ny)) continue;\n\t\tif (p[ny][nx] == cur) res += countDFS(p, nx, ny, cur);\n\t}\n\treturn res;\n}\n\nvoid change(vector< vector< int > >& p, int x, int y, int cur, int nxt) {\n\tp[y][x] = nxt;\n\tfor_(d,0,4) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (!in_range(nx, ny)) continue;\n\t\tif (p[ny][nx] == cur) change(p, nx, ny, cur, nxt);\n\t}\n}\n\nvoid dfs(int i, vector< vector< int > > p, int& ans) {\n\tif (i == 5) {\n\t\tans = max(ans, countDFS(p, 0, 0, c));\n\t\treturn;\n\t}\n\t\n\tfor_(nxt,1,7) {\n\t\tif (i == 4 && nxt != c) continue;\n\t\tif (p[0][0] == nxt) continue;\n\t\tvector< vector< int > > nxt_p = p;\n\t\tchange(nxt_p, 0, 0, p[0][0], nxt);\n\t\tdfs(i + 1, nxt_p, ans);\n\t}\n}\n\nint main() {\n\twhile (cin >> h >> w >> c) {\n\t\tif (h == 0) break;\n\t\tvector< vector< int > > p(h, vector< int >(w));\n\t\tfor_(y,0,h) for_(x,0,w) cin >> p[y][x];\n\t\t\n\t\tint ans = 0;\n\t\tdfs(0, p, ans);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nll power(ll a,ll b/*,ll mod*/){\n    ll ret=1;\n    if(b>0){\n        ret = power(a,b/2/*,mod*/);\n        if(b%2==0)ret = (ret*ret)/*%mod*/;\n        else ret = (((ret*ret)/*%mod*/)*a)/*%mod*/;\n    }\n    return ret;\n}\n\n\nint h,w,c;\n\nint dfs(vector<vector<int>> &v,int y,int x,vector<vector<bool>> &used){\n    int ret = 1;\n    int dy[]={1,0,-1,0};\n    int dx[]={0,1,0,-1};\n\n    rep(i,4){\n        int ddy = y+dy[i];\n        int ddx = x+dx[i];\n        if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)continue;\n        if(used[ddy][ddx])continue;\n        if(v[y][x]==v[ddy][ddx]){\n            used[ddy][ddx]=true;\n            ret+=dfs(v,ddy,ddx,used);\n        }\n    }\n    return ret;\n}\n\nvoid paint(int y, int x, vector<vector<int>> &v, int color, int base){\n    if(base==color)return ;\n    v[y][x] = color;\n    rep(i,4){\n        int dy[]={1,0,-1,0};\n        int dx[]={0,1,0,-1};\n        int ddy = y+dy[i];\n        int ddx = x+dx[i];\n        \n        if(ddx<0 || ddy<0 || ddx>=w || ddy>=h)continue;\n        if(v[ddy][ddx]==base){\n            v[ddy][ddx]=color;\n            paint(ddy,ddx,v,color,base);\n        }\n    }\n}\n\nint exe(vector<vector<int>> v,vector<int> op){\n    rep(i,op.size()){\n        paint(0,0,v,op[i],v[0][0]);\n    }\n    \n    vector< vector<bool> > used(h,vector<bool>(w,false));\n    used[0][0]=true;\n    return dfs(v,0,0,used);\n    \n}\n\nint main(){\n    while(cin>>h>>w>>c&&(h||w||c)){\n        c--;\n        vector<vector<int>> v(h,vector<int>(w));\n        rep(i,h)rep(j,w)cin>>v[i][j];\n        rep(i,h)rep(j,w)v[i][j]--;\n        \n        int ans = 0;\n        int end = power(4,6);\n        rep(i,end){\n            vector<int> vec;\n            int num = i;\n            rep(j,4){\n                vec.pb(num%6);\n                num/=6;\n            }\n            vec.pb(c);\n            \n            ans = max(ans,exe(v,vec));\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = 1e-10;\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nint sim(vector<vector<int>> &field, vector<int> c, int H, int W) {\n    vector<vector<int>> v(H+2, vector<int>(W+2));\n    queue<pair<int, int>> que;\n    v[1][1] = 1;\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {-1, 0, 1, 0};\n    for (int k = 0; k <= 5; k++) {\n        for (int y = 1; y <= H; y++) {\n            for (int x = 1; x <= W; x++) {\n                if (v[y][x] == 1) {\n                    que.push({y, x});\n                }\n            }\n        }\n        while (!que.empty()) {\n            pair<int, int> crt = que.front();\n            que.pop();\n            for (int i = 0; i < 4; i++) {\n                int nx = crt.second + dx[i];\n                int ny = crt.first + dy[i];\n                if (field[ny][nx] == c[k] && v[ny][nx] == 0) {\n                    v[ny][nx] = 1;\n                    que.push({ny, nx});\n                }\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int y = 1; y <= H; y++) {\n        for (int x = 1; x <= W; x++) {\n            if (v[y][x] == 1) {\n                ret++;\n            }\n        }\n    }\n    return ret;\n}\n\nint solve(int H, int W, int C) {\n    vector<vector<int>> field(H+2, vector<int>(W+2));\n    for (int y = 1; y <= H; y++) {\n        for (int x = 1; x <= W; x++) {\n            cin >> field[y][x];\n        }\n    }\n    vector<int> c(6);\n    c[0] = field[1][1];\n    c[5] = C;\n    int ret = -1;\n    for (c[1] = 1; c[1] <= 6; c[1]++) {\n        for (c[2] = 1; c[2] <= 6; c[2]++) {\n            for (c[3] = 1; c[3] <= 6; c[3]++) {\n                for (c[4] = 1; c[4] <= 6; c[4]++) {\n                    ret = max(sim(field, c, H, W), ret);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main(void) {\n    int H, W, C;\n    vector<int> ans;\n    while (1) {\n        cin >> H >> W >> C;\n        if (!H && !W && !C) break;\n        ans.push_back(solve(H, W, C));\n    }\n    for (auto &i : ans) {\n        cout << i << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n//#include <queue>\nusing namespace std;\n#define MAX 10\ntypedef vector<int> vec;\n\nint w, h, c;\n//int model[MAX][MAX];\nint cnt;\n//queue<pair<int, int> > que;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\n\nint change( int cp[MAX][MAX], int x, int y, int prev, int color ){\n    cp[y][x] = color;\n    //cout << h << w << endl;\n    int count = 1;\n    for( int i = 0; i < 4; i++ ){\n        int nx = x+dx[i], ny = y+dy[i];\n        if( 0 <= nx && nx < w && 0 <= ny && ny < h && cp[ny][nx] == prev ){\n            count += change( cp, nx, ny, prev, color );\n        }\n    }\n    //cout << count <<endl;\n    return count;\n}\n\nvoid bfs( int cp[MAX][MAX], int n ){\n    //if( n > 5 ) return;\n    int ncp[MAX][MAX], count;\n    for( int i = 1; i <= 6; i++ ){\n        if( i == cp[0][0] ) continue;\n        if( n == 5 && i != c ) continue;\n        for( int j = 0; j < h; j++ ){\n            for( int k = 0; k < w; k++ ){\n                ncp[j][k] = cp[j][k];\n            }\n        }\n        change( ncp, 0, 0, ncp[0][0], i );\n        //cout << n << endl;\n        if( n < 5 ){\n            bfs( ncp, n+1 );\n        }else{\n            count = change( ncp, 0, 0, ncp[0][0], 0 );\n            //cout << count << endl;\n            if( cnt < count ) cnt = count;\n        }\n    }\n}\n\n\nint main(){\n    int map[MAX][MAX];\n    while(cin >> h >> w >> c, h || w || c){\n        for( int i = 0; i < h; i++ ){\n            for( int j = 0; j < w; j++ ){\n                cin >> map[i][j];\n            }\n        }\n        cnt = 0;\n        bfs( map, 1 );\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\nusing namespace std;\nstruct point_t { int x, y; };\ntemplate <typename T>\nbool on(point_t p, T const & xss) {\n    return 0 <= p.y and p.y < xss.size()\n        and 0 <= p.x and p.x < xss.front().size();\n}\nconst point_t directions[] = { {0,1},{0,-1},{1,0},{-1,0} };\npoint_t operator + (point_t a, point_t b) { return { a.x + b.x, a.y + b.y }; }\nvector<vector<int> > shock(int c, vector<vector<int> > const & p) {\n    assert (1 <= c and c <= 6);\n    vector<vector<int> > q = p;\n    stack<point_t> s;\n    s.push({ 0, 0 });\n    while (not s.empty()) {\n        point_t a = s.top(); s.pop();\n        if (q[a.y][a.x] == c) continue;\n        q[a.y][a.x] = c;\n        for (point_t b : directions) {\n            b = a + b;\n            if (on(b, p) and q[b.y][b.x] == p[0][0]) {\n                s.push(b);\n            }\n        }\n    }\n    return q;\n}\nint count(vector<vector<int> > const & p) {\n    vector<vector<bool> > used(p.size(), vector<bool>(p.front().size()));\n    int result = 0;\n    stack<point_t> s;\n    s.push({ 0, 0 });\n    while (not s.empty()) {\n        point_t a = s.top(); s.pop();\n        if (used[a.y][a.x]) continue;\n        used[a.y][a.x] = true;\n        result += 1;\n        for (point_t b : directions) {\n            b = a + b;\n            if (on(b, p) and not used[b.y][b.x] and p[b.y][b.x] == p[0][0]) {\n                s.push(b);\n            }\n        }\n    }\n    return result;\n}\nint solve(int i, vector<vector<int> > const & p, int c) {\n    if (i == 4) {\n        return count(shock(c, p));\n    }\n    int result = 0;\n    for (int j : { 1,2,3,4,5,6 }) {\n        result = max(result, solve(i+1, shock(j,p), c));\n    }\n    return result;\n}\nint main() {\n    while (true) {\n        int h, w, c; cin >> h >> w >> c;\n        if (h == 0 and w == 0 and c == 0) break;\n        vector<vector<int> > p(h, vector<int>(w));\n        repeat (y, h) {\n            repeat (x, w) {\n                cin >> p[y][x];\n            }\n        }\n        cout << solve(0,p,c) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint h,w,c;\nint p[10][10];\n\nint dfs(int y,int x,int prv,int nx){\n  p[y][x] = nx;\n  int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n  int res = 0;\n\n  for(int i=0;i<4;i++){\n    int ty = y+dy[i], tx = x+dx[i];\n    if(ty<0 || tx<0 || h<=ty || w<=tx)continue;\n    if(p[ty][tx]==prv)res += dfs(ty,tx,prv,nx);\n  }\n  return res + 1;\n}\n\nint rec(int n){\n  if(n==5){\n    if(p[0][0]!=c)return 0;\n    return dfs(0,0,c,(c+1)%6+1);\n  }\n\n  int res = 0;\n  int tmp[10][10];\n\n  for(int i=1;i<=6;i++){\n    if(p[0][0] == i)continue;\n    for(int j=0;j<h;j++)\n      for(int k=0;k<w;k++)tmp[j][k] = p[j][k];\n    \n    dfs(0,0,p[0][0],i);\n    \n    res = max(res,rec(n+1));\n\n    for(int j=0;j<h;j++)\n      for(int k=0;k<w;k++)p[j][k] = tmp[j][k];\n  }\n  return res;\n}\n\nint main(){\n  \n  while(cin >> h >> w >> c, w||h||c){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin >> p[i][j];\n\n    cout << rec(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i =0;i<n;++i)\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define FOR(it,a ) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\n\nint h,w,c;\n\nint in[10][10];\n\nint ans;\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\ntypedef pair<int,int> PI;\n\nvoid dfs(int a){\n  if(a == 5){\n    queue<PI> q;\n    bool vis[10][10] = {};\n    q.push(mp(0,0));\n    int tans=0;\n    \n    while(!q.empty()){\n      int cx = q.front().F;\n      int cy = q.front().S;\n      q.pop();\n      if(vis[cx][cy]) continue;\n      ++tans;\n      vis[cx][cy]=1;\n      rep(i,4){\n        int nx = cx + dx[i];\n        int ny = cy + dy[i];\n        if(min(nx,ny)<0 || nx>=h || ny>=w )continue;\n        if(in[nx][ny] != in[cx][cy]) continue;\n        q.push(mp(nx,ny));\n      }\n    }\n    ans=max(ans,tans);\n    return;\n  }\n  \n  int ba[10][10];\n  rep(i,h)rep(j,w) ba[i][j] = in[i][j];\n\n  queue<PI> q;\n  bool vis[10][10] = {};\n  q.push(mp(0,0));\n    \n  while(!q.empty()){\n    int cx = q.front().F;\n    int cy = q.front().S;\n    q.pop();\n    if(vis[cx][cy]) continue;\n    \n    vis[cx][cy]=1;\n    rep(i,4){\n      int nx = cx + dx[i];\n      int ny = cy + dy[i];\n      if(min(nx,ny)<0 || nx>=h || ny>=w )continue;\n      if(in[nx][ny] != in[cx][cy]) continue;\n      q.push(mp(nx,ny));\n    }\n  }\n  \n  rep(jj,6){\n    if(a==4 && jj+1!=c) continue;\n    rep(i,h)rep(j,w) if(vis[i][j]) in[i][j] = jj+1;\n    dfs(a+1);\n  }\n  \n  rep(i,h)rep(j,w) in[i][j] = ba[i][j];\n}\n\nvoid solve(){\n  rep(i,h)rep(j,w) cin >> in[i][j];\n  ans = 1;\n  dfs(0);\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> h >> w >> c,h) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> vint;\n\nint h, w, c, ans;\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvint bfs(const vector<vint> &p){\n\tvint ret;\n\tbool visit[10][10] = {};\n\tqueue<int> q;\n\tq.push(1 << 8 | 1);\n\tvisit[1][1] = true;\n\n\tint clr = p[1][1];\n\n\twhile(!q.empty()){\n\t\tret.push_back(q.front());\n\t\tint y = q.front() >> 8;\n\t\tint x = q.front() & 0xff;\n\t\tq.pop();\n\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\tif(!visit[ny][nx] && p[ny][nx] == clr){\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\tq.push(ny << 8 | nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nvoid recur(int k, vector<vint> &p){\n\tvint con = bfs(p);\n\n\tif(k == 0){\n\t\tans = max<int>(ans, con.size());\n\t}\n\telse{\n\t\tint lt = 1, rt = 6;\n\t\tif(k == 1){ lt = rt = c; }\n\n\t\tvector<vint> q = p;\n\t\tfor(int i = lt; i <= rt; ++i){\n\t\t\tfor(int j = 0; j < con.size(); ++j){\n\t\t\t\tq[con[j] >> 8][con[j] & 0xff] = i;\n\t\t\t}\n\t\t\trecur(k - 1, q);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d%d\", &h, &w, &c), h){\n\t\tans = 0;\n\n\t\tvector<vint> p(h + 2, vint(w + 2, -1));\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tscanf(\"%d\", &p[i][j]);\n\t\t}\n\n\t\trecur(5, p);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint h, w, c;\nint tab[16][16];\nbool vis[16][16];\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\nvoid change(int x, int y, int cf, int ct){\n  tab[y][x] = ct;\n  REP(i,4){\n\tint tx = x + dx[i], ty = y + dy[i];\n\tif(tab[ty][tx] == cf)\n\t  change(tx, ty, cf, ct);\n  }\n}\n\nint num(int x, int y){\n  if(vis[y][x] || tab[y][x] != c) return 0;\n  vis[y][x] = true;\n  int res = 1;\n  REP(i,4){\n\tint tx = x + dx[i], ty = y + dy[i];\n\tres += num(tx,ty);\n  }\n  return res;\n}\n\nint dfs(int idx){\n  if(idx == 4){\n\tif(tab[1][1] != c)\n\t  change(1,1,tab[1][1],c);\n\tfill((bool*)vis, (bool*)vis+16*16, false);\n\treturn num(1,1);\n  }\n\n  int res = 0;\n  int prv[16][16];\n  REP(y,h+2) REP(x,w+2) prv[y][x] = tab[y][x];\n  for(int i=1;i<=6;++i){\n\tif(tab[1][1] == i) continue;\n\tchange(1,1,tab[1][1],i);\n\tres = max(res, dfs(idx+1));\n\n\tREP(y,h+2) REP(x,w+2) tab[y][x] = prv[y][x];\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  while(cin>>h>>w>>c, h){\n\tfill((int*)tab, (int*)tab+16*16, -1);\n\tREP(y,h) REP(x,w) cin >> tab[y+1][x+1];\n\tcout << dfs(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <utility>\n\nusing namespace std;\n\nint h,w,c,ans;\n\nvoid dfs(int dep,int a[][8]){\n\tint x,y,dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\tif(dep==5){\n\t\tint t=1;\n\t\tif(c==a[0][0]){\n\t\t\tqueue<pair<int,int> > q;\n\t\t\tq.push(make_pair(0,0));\n\t\t\ta[0][0]=-1;\n\t\t\twhile(!q.empty()){\n\t\t\t\tx=q.front().first,y=q.front().second,q.pop();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h) continue;\n\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||a[ny][nx]!=c) continue;\n\t\t\t\t\tt++;\n\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\ta[ny][nx]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=max(ans,t);\n\t\treturn;\n\t}\n\tint tmp[8][8];\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) tmp[i][j]=a[i][j];\n\tfor(int col=1;col<=6;col++){\n\t\tif(a[0][0]==col) dfs(dep+1,a);\n\t\telse{\n\t\t\tint p = a[0][0];\n\t\t\ta[0][0]=col;\n\t\t\tqueue<pair<int,int> > q;\n\t\t\tq.push(make_pair(0,0));\n\t\t\twhile(!q.empty()){\n\t\t\t\tx=q.front().first,y=q.front().second,q.pop();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||a[ny][nx]!=p) continue;\n\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\ta[ny][nx]=col;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(dep+1,a);\n\t\t}\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) a[i][j]=tmp[i][j];\n\t\t//memcpy(tmp,a,sizeof(a));\n\t}\n\treturn;\n}\n\nint main(){\n\tint a[8][8];\n\twhile(cin>>h>>w>>c,h||w||c){\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) cin>>a[i][j];\n\t\tans=0;\n\t\tdfs(0,a);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct State{\n    vector<vector<int> > field;\n    int level;\n    State(vector<vector<int> > f,int l) : field(f),level(l) {};\n};\n\nint cntup(const vector<vector<int> > &field,const int c){\n    if(field[0][0] != c) return 0;\n    int h = field.size(),w = field[0].size();\n    queue<pii> que;\n    que.push(make_pair(0,0));\n    vector<vector<char> > used(h,vector<char>(w,false));\n    int ret = 0;\n    while(not que.empty()){\n        int y=que.front().first;\n        int x=que.front().second;\n        que.pop();\n        if(used[y][x]) continue;\n        used[y][x] = true;\n        ret++;\n        for(int i=0;i<4;i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(ny < 0 or ny >= h or nx < 0 or nx >= w) continue;\n            if(field[ny][nx] == c){\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n    return ret;\n}\n\nvector<vector<int> > go(const vector<vector<int> > &field,int c){\n    if(field[0][0] == c) return field;\n    vector<vector<int> > ret = field;\n    int h = field.size(),w = field[0].size();\n    queue<pii> que;\n    que.push(make_pair(0,0));\n    vector<vector<char> > used(h,vector<char>(w,false));\n\n    while(not que.empty()){\n        int y=que.front().first;\n        int x=que.front().second;\n        que.pop();\n        if(used[y][x]) continue;\n        used[y][x] = true;\n        ret[y][x] = c;\n        for(int i=0;i<4;i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(ny < 0 or ny >= h or nx < 0 or nx >= w) continue;\n            if(field[ny][nx] == field[0][0]){\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n        int h,w,c;\n        cin >> h >> w >> c;\n        if(h == 0 and w == 0 and c == 0) break;\n        vector<vector<int> > field(h,vector<int>(w));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> field[i][j];\n            }\n        }\n\n        stack<State> st;\n        st.push(State(field,0));\n        int ret = 0;\n        while(not st.empty()){\n            State s = st.top();\n            st.pop();\n            if(s.level == 5){\n                // for(int i=0;i<s.field.size();i++){\n                //     for(int j=0;j<s.field[i].size();j++){\n                //         cerr << s.field[i][j];\n                //     }\n                //     cerr << endl;\n                // }\n                // cerr << endl;\n                ret = max(ret,cntup(s.field,c));\n            }else{\n                for(int i=1;i<=6;i++){\n                    st.push(State(go(s.field,i),s.level+1));\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <memory.h>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n\n//FILE * in = freopen(\"input.txt\", \"r\" , stdin);\n\ntypedef unsigned int Color;\n\nstruct Point{\n\tPoint(unsigned int x, unsigned int y) : x(x), y(y){}\n\tunsigned int x;\n\tunsigned int y;\n\tbool operator < (const Point &p) const {\n\t\t//return x < p.x ? true : y < p.y ?  ;\n\t\treturn x == p.x ? y < p.y ? true : false : x < p.x;\n\t}\n};\n\nint surX[] = {0, 1, 0, -1};\nint surY[] = {1, 0, -1, 0};\n\nbool baketuTool(Point point, set<Point> * currentPoints, set<Point> * touchPoints, Color color, vector<vector<Color>> * table){\n\tif((*table)[point.y][point.x] == color){ // onazi color check\n\t\tcurrentPoints->insert(point);\n\t\tfor(unsigned int i=0; i<4; i++){ // sihou check\n\t\t\tunsigned y = point.y + surY[i];\n\t\t\tif(0 > y || y >= table->size()) continue;\n\t\t\tunsigned x = point.x + surX[i];\n\t\t\tif(0 > x || x >= (*table)[y].size()) continue;\n\t\t\tPoint p = Point(x,y);\n\t\t\tif(currentPoints->find(p)==currentPoints->end()){ // iranai\n\t\t\t\tif(baketuTool(p, currentPoints, touchPoints, color, table)){\n\t\t\t\t\ttouchPoints->insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nunsigned int recursion(set<Point> currentPoints, set<Point> touchPoints, map<set<Point>, unsigned int> * caches, vector<vector<Color>> * table, unsigned int count, Color lastColor){\n\tif(count > 5){\n\t\treturn currentPoints.size();\n\t}\n\tunsigned int max_size = 0;\n\tfor(Color color=1;color<=6;color++){\n\t\tif(count == 5 && color != lastColor) continue;\n\t\tauto new_currentPoints = currentPoints;\n\t\tset<Point> new_touchPoints;\n\t\tfor(auto it=touchPoints.begin(); it!=touchPoints.end();it++){\n\t\t\tif(baketuTool(*it, &new_currentPoints, &new_touchPoints, color, table)){\n\t\t\t\tnew_touchPoints.insert(*it);\n\t\t\t}\n\t\t}\n\t\tauto size = recursion(new_currentPoints, new_touchPoints, caches, table, count+1, lastColor);\n\t\tif((*caches)[new_currentPoints] < size){\n\t\t\t(*caches)[new_currentPoints] = size;\n\t\t}\n\t\tmax_size = max(max_size, size);\n\t}\n\treturn max_size;\n}\n\nvoid solution(unsigned int h, unsigned int w, Color c){\n\tmap<set<Point>, unsigned int> caches;\n\n\tvector<vector<Color>> table;\n\tColor p;\n\ttable.push_back(vector<Color>());\n\tfor(unsigned int i = 0; i < h*w; i++){\n\t\tcin >> p;\n\t\tif(table.back().size()==w) table.push_back(vector<Color>());\n\t\ttable.back().push_back(p);\n\t}\n\tunsigned int currentSize = 1;\n\tColor currentColor = table[0][0];\n\tset<Point> currentPoints;\n\tset<Point> touchPoints;\n\t\n\tbaketuTool(Point(0,0), &currentPoints, &touchPoints,  currentColor, &table);\n\n\n\tauto size = recursion(currentPoints, touchPoints, &caches, &table, 1, c);\n\tcout << size << endl;\n}\n\nint main() {\n\tunsigned int h,w,c;\n\twhile(true){\n\t\tcin >> h;\n\t\tcin >> w;\n\t\tcin >> c;\n\t\tif(h==0 && w==0 && c==0) break;\n\t\tsolution(h,w,c);\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\n#define ck(a,b) (0<=(a)&&(a)<(b))\nusing namespace std;\n\nint dpdx[4]={1,0,-1,0};\nint dpdy[4]={0,-1,0,1};\nint dph,dpw,dpc,ans;\nvector<int> vt,tmp;\n\nint dpcolor(int f[8][8],int nowc,int nextc,int x,int y){\n\tint cnt=1;\n\tf[y][x]=nextc;\n\tREP(k,0,4){\n\t\tint nextx=x+dpdx[k],nexty=y+dpdy[k];\n\t\tif(!ck(nextx,dpw)||!ck(nexty,dph))continue;\n\t\tif(f[nexty][nextx]!=nowc) continue;\n\t\tcnt+=dpcolor(f,nowc,nextc,nextx,nexty);\n\t}\n\treturn cnt;\n}\n\n\nvoid dpdfs(int f[8][8],int num){\n\tint nf[8][8];\n\tREP(color,1,7){\n\t\tif(f[0][0]==color) continue;\n\t\tif(num==5&&color!=dpc) continue;\n\t\tREP(i,0,dph) REP(j,0,dpw) nf[i][j]=f[i][j];\n\t\tdpcolor(nf,nf[0][0],color,0,0);//change color\n\t\tif(num<5) dpdfs(nf,num+1);\n\t\telse{\n\t\t\tans=max(ans,dpcolor(nf,nf[0][0],7,0,0));\n\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint field[8][8];\n\twhile(cin>>dph>>dpw>>dpc,dph){\n\t\tans=0;\n\t\tREP(i,0,dph) REP(j,0,dpw) cin>>field[i][j];\n\t\tdpdfs(field,1);\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint h, w, c;\nint p[8][8];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvoid print(int time){\n  printf(\"time %d\\n\", time);\n  REP(y, h){\n    REP(x, w) printf(\"%d \", p[y][x]);\n    cout<<endl;\n  }\n}\nint dfs(int time){\n  if(time != 5){\n    bool equal[8][8] = {};\n    queue<int> qx; queue<int> qy;\n    qx.push(0); qy.push(0);\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      equal[y][x] = true;\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && !equal[ny][nx] && p[y][x] == p[ny][nx]){\n          qx.push(nx); qy.push(ny);\n          equal[ny][nx] = true;\n        }\n      }\n    }\n    int res = 0;\n    int tmp[8][8];\n    REP(y, h)REP(x, w) tmp[y][x] = p[y][x];\n    for(int color = 1; color <= 6; color++){\n      REP(y, h)REP(x, w)if(equal[y][x]){\n        p[y][x] = color;\n      }\n      res = max(res, dfs(time + 1));\n      REP(y, h)REP(x, w) p[y][x] = tmp[y][x];\n    }\n    return res;\n  }\n  else if(time == 5){\n    if(p[0][0] != c) return 0;\n    bool equal[8][8] = {};\n    queue<int> qx; queue<int> qy;\n    qx.push(0); qy.push(0);\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      equal[y][x] = true;\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && !equal[ny][nx] && p[y][x] == p[ny][nx]){\n          qx.push(nx); qy.push(ny);\n          equal[ny][nx] = true;\n        }\n      }\n    }\n    int res = 0;\n    REP(y, h)REP(x, w) res += equal[y][x];\n    return res;\n  }\n}\n\nint main(){\n  while(cin>>h>>w>>c && h){\n    REP(y, h)REP(x, w) cin>>p[y][x];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\n// ??¶???????????????????§???????\nstruct status{\n\tint count, to;\n\tint p[10][10];\n\tstatus(int c=0, int t=0, status *old=NULL){\t//???????????????????????§??¨???????????????????????§???????????????????????????\n\t\tif( old ) *this = *old;\t\t// ??¨?????????(memcpy()???????\\???§?????????????°???????)\n\t\telse fill(p[0], p[0]+10*10, 0);\t//?????????????????????????????????????????????????????§\n\t\tcount = c;\n\t\tto = t;\n\t}\n};\n\nint main(){\n\tint h, w, c;\n\twhile(cin>>h>>w>>c, h|w|c){\n\t\t// ???????????§?????°??????????????¨??????????????°???????????§??????\n\t\tstack<status> st;\n\t\tint ans = 0;\n\t\t\n\t\t// ??????????????????\n\t\tstatus in;\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> in.p[i][j];\n\t\t\t}\n\t\t}\n\t\tin.to = in.p[1][1];\n\t\tin.p[1][1] = 8;\n\t\t\n\t\t// ??±???????????¢?´¢\n\t\tst.push( in );\n\t\twhile( !st.empty() ){\n\t\t\tstatus s = st.top(); st.pop();\n\t\t\t// s.to??????????????´\n\t\t\tvector< P > check;\t//stack??§???????????£??????ans?????°???????????????????????????vector????????´\n\t\t\tfor(int i=1; i<=h; i++){\t// (1,1)??¨??????????????¨????????¢???\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif( s.p[i][j] == 8 )\n\t\t\t\t\t\tcheck.push_back( make_pair(i, j) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( int i=0; i<check.size(); i++ ){\t// ??£??\\??¨???????????????\n\t\t\t\tint y = check[i].first, x = check[i].second;\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tif( s.p[ y+vy[k] ][ x+vx[k] ] == s.to ){\n\t\t\t\t\t\ts.p[ y+vy[k] ][ x+vx[k] ] = 8;\n\t\t\t\t\t\tcheck.push_back( make_pair( y+vy[k], x+vx[k] ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ?¬?????????????????????????\n\t\t\tif( s.count == 5 ){\t\t// ?????????\n\t\t\t\tans = max( ans, (int)check.size() );\t//?????§???????????´??°\n\t\t\t}else if( s.count == 4 ){\n\t\t\t\tst.push( status(s.count+1, c, &s) );\n\t\t\t}else{\n\t\t\t\tfor(int i=1; i<=6; i++){\n\t\t\t\t\tif( i != s.to ){\n\t\t\t\t\t\tst.push( status(s.count+1, i, &s) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ??????\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,c,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nvector<int> p(64);\n\nint nu(int x,int y,int cl,int t){\n  int res=1;\n  p[y*w+x]=cl;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||w<=nx||ny<0||h<=ny||p[ny*w+nx]!=t||p[ny*w+nx]==cl)continue;\n    res+=nu(nx,ny,cl,t);\n  }\n  return res;\n}\n\nint dfs(int d){\n  vector<int> tp=p;\n  int res=0;\n  if(d==5){\n    if(p[0]==c)res=nu(0,0,7,p[0]);\n    return res;\n  }\n  for(int j=1;j<7;j++){\n    nu(0,0,j,p[0]);\n    res=max(res,dfs(d+1)),p=tp;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>h>>w>>c,h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>p[i*w+j];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {-1, 0, 1, 0};\n\nint W, H, C;\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nint paint(vector< vector<int> >& p, int x, int y, int c, int c0) {\n\tif (c == c0) return 0;\n\tif ( !inRange(x, y) ) return 0;\n\tif (p[y][x] != c0) return 0;\n\tp[y][x] = c;\n\tint res = 1;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tres += paint(p, x+dx[i], y+dy[i], c, c0);\n\t}\n\treturn res;\n}\nvector< vector<int> > f(vector< vector<int> > p, int c) {\n\tpaint(p, 0, 0, c, p[0][0]);\n\treturn p;\n}\nint dfs(int n, vector< vector<int> > p) {\n\tif (n == 5) {\n\t\tif (p[0][0] != C) return 0;\n\t\treturn paint(p, 0, 0, 10, p[0][0]);\n\t}\n\telse {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tres = max(res, dfs(n+1, f(p, i)));\n\t\t}\n\t\treturn res;\n\t}\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile (cin >> H >> W >> C, H || W || C) {\n\t\t--C;\n\t\tvector< vector<int> > p(H, vector<int>(W));\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> p[y][x]; p[y][x]--;\n\t\t\t}\n\t\t}\n\t\tcout << dfs(0, p) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_SIZE = 8;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\ntypedef struct\n{\n  int x, y;\n} Point;\n\ntypedef struct\n{\n  Point p;\n  int color;\n} Log;\n\nbool visited[MAX_SIZE][MAX_SIZE];\nint h, w, c, panel[MAX_SIZE][MAX_SIZE], log_index[4];\nLog log[5][MAX_SIZE*MAX_SIZE];\n\nvoid init()\n{\n  for (int i = 0; i < MAX_SIZE; ++i) {\n    for (int j = 0; j < MAX_SIZE; ++j)\n      visited[i][j] = false;\n  }\n}\n\nvoid init(int change)\n{\n  for (int i = 0; i < MAX_SIZE; ++i) {\n    for (int j = 0; j < MAX_SIZE; ++j)\n      visited[i][j] = false;\n  }\n  log_index[change] = 0;\n}\n\nint solve(const int change)\n{\n  if (change == 4) {\n    int org_color = panel[0][0];\n    Point p;\n    p.x = p.y = 0;\n    queue<Point> que;\n    que.push(p);\n    init(change);\n    \n    while (!que.empty()) {\n      p = que.front();\n      que.pop();\n      \n      if (visited[p.y][p.x])\n\tcontinue;\n      \n      log[change][log_index[change]].p.x = p.x;\n      log[change][log_index[change]].p.y = p.y;\n      log[change][log_index[change]].color = panel[p.y][p.x];\n      ++log_index[change];\n\n      panel[p.y][p.x] = c;\n      visited[p.y][p.x] = true;\n      for (int d = 0; d < 4; ++d) {\n\tPoint pp = p;\n\tpp.x += dx[d];\n\tpp.y += dy[d];\n\t\n\tif (pp.x < 0 || pp.x >= w || pp.y < 0 || pp.y >= h ||\n\t    visited[pp.y][pp.x] || panel[pp.y][pp.x] != org_color)\n\t  continue;\n\tque.push(pp);\n      }\n    }\n\n    int cnt = 0;\n    p.x = p.y = 0;\n    que.push(p);\n    init();\n    while (!que.empty()) {\n      p = que.front();\n      que.pop();\n      \n      if (visited[p.y][p.x])\n\tcontinue;\n\n      ++cnt;\n      visited[p.y][p.x] = true;\n      for (int d = 0; d < 4; ++d) {\n\tPoint pp = p;\n\tpp.x += dx[d];\n\tpp.y += dy[d];\n\t\n\tif (pp.x < 0 || pp.x >= w || pp.y < 0 || pp.y >= h ||\n\t    visited[pp.y][pp.x] || panel[pp.y][pp.x] != c)\n\t  continue;\n\tque.push(pp);\n      }\n    }\n\n    for (int i = 0; i < log_index[change]; ++i)\n      panel[log[change][i].p.y][log[change][i].p.x] = log[change][i].color;\n\n    return cnt;\n  }\n\n  int ret = 0;\n  for (int i = 1; i <= 6; ++i) {\n    int org_color = panel[0][0];\n    Point p;\n    p.x = p.y = 0;\n    queue<Point> que;\n    que.push(p);\n    init(change);\n\n    while (!que.empty()) {\n      p = que.front();\n      que.pop();\n    \n      if (visited[p.y][p.x])\n\tcontinue;\n    \n      log[change][log_index[change]].p.x = p.x;\n      log[change][log_index[change]].p.y = p.y;\n      log[change][log_index[change]].color = panel[p.y][p.x];\n      ++log_index[change];\n\n      panel[p.y][p.x] = i;\n      visited[p.y][p.x] = true;\n      for (int d = 0; d < 4; ++d) {\n\tPoint pp = p;\n\tpp.x += dx[d];\n\tpp.y += dy[d];\n\t\n\tif (pp.x < 0 || pp.x >= w || pp.y < 0 || pp.y >= h ||\n\t    visited[pp.y][pp.x] || panel[pp.y][pp.x] != org_color)\n\t  continue;\n\tque.push(pp);\n      }\n    }\n    ret = max(ret, solve(change+1));\n\n    for (int j = 0; j < log_index[change]; ++j)\n      panel[log[change][j].p.y][log[change][j].p.x] = log[change][j].color;\n  }\n  return ret;\n}\n\nint main()\n{\n  while (~scanf(\"%d %d %d\", &h, &w, &c)) {\n    if (h == 0 && w == 0 && c == 0)\n      break;\n\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j)\n\tscanf(\"%d\", &panel[i][j]);\n    }\n    printf(\"%d\\n\", solve(0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<vector<int> > mat;\n\nint h,w,c;\n\nint dx[]={0,1,-1,0};\nint dy[]={1,0,0,-1};\n\nint change(mat& panel,int color) {\n\tint cnt=1;\n\tqueue<pair<int,int> > q;\n\tvector<vector<bool> > used(h,vector<bool>(w));\n\tused[0][0]=true;\n\tq.push({0,0});\n\twhile(!q.empty()) {\n\t\tpair<int,int> p=q.front(); q.pop();\n\t\tfor(int i=0;i<4;++i) {\n\t\t\tint nx=p.first+dx[i],ny=p.second+dy[i];\n\t\t\tif(nx<0||ny<0||nx>=h||ny>=w||used[nx][ny]) continue;\n\t\t\tused[nx][ny]=true;\n\t\t\tif(panel[nx][ny]==panel[0][0]) {\n\t\t\t\tpanel[nx][ny]=color;\n\t\t\t\tq.push({nx,ny});\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t}\n\tpanel[0][0]=color;\n\treturn cnt;\n}\n\nint solve(int cnt,mat panel) {\n\tint res=0;\n\tif(cnt==4) {\n\t\tchange(panel,c);\n\t\treturn change(panel,c);\n\t}\n\tfor(int i=1;i<=6;++i) {\n\t\tif(i==panel[0][0]) continue;\n\t\tmat tmp(panel);\n\t\tchange(tmp,i);\n\t\tres=max(res,solve(cnt+1,tmp));\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> h >> w >> c,h) {\n\t\tmat panel(h,vector<int>(w));\n\t\tfor(auto&v:panel)\n\t\t\tfor(auto&e:v)\n\t\t\t\tcin >> e;\n\t\tcout << solve(0,panel) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint h,w,c;\nvoid fill_map(int x,int y,vvi &map,int from,int to){\n\tmap[x][y]=to;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx>=0&&nx<w&&ny>=0&&ny<h){\n\t\t\tif(map[nx][ny]==from){\n\t\t\t\tfill_map(nx,ny,map,from,to);\n\t\t\t}\n\t\t}\n\t}\n}\nint search(int n,vvi &map){\n\tif(n==5){\n\t\tif(map[0][0]!=c)return 0;\n\t\tfill_map(0,0,map,map[0][0],7);\n\t\tint ret=0;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tif(map[i][j]==7){\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint best=0;\n\tfor(int i=1;i<=6;++i){\n\t\tif(map[0][0]==i)continue;\n\t\tvvi new_map(map);\n\t\tfill_map(0,0,new_map,map[0][0],i);\n\t\tbest=max(best,search(n+1,new_map));\n\t}\n\treturn best;\n}\nint main(){\n\twhile(cin>>h>>w>>c,h){\n\t\tvvi map(w,vi(h,0));\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>map[j][i];\n\t\t\t}\n\t\t}\n\t\tcout<<search(0,map)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nclass union_find {\npublic:\n\tvector<int> dat;\n\tunion_find(int n) {\n\t\tdat.assign(n, -1);\n\t}\n\t\n\tbool unite(int a, int b) {\n\t\tint da = find(a);\n\t\tint db = find(b);\n\t\tif (da != db){\n\t\t\tif (dat[da] > dat[db]) swap(da, db);\n\t\t\tdat[da] += dat[db];\n\t\t\tdat[db] = da;\n\t\t}\n\t\treturn (da != db);\n\t}\n\tbool check(int a, int b) {\n\t\treturn (find(a) == find(b));\n\t}\n\tint find(int a) {\n\t\treturn ((dat[a] < 0) ? a : (dat[a] = find(dat[a])));\n\t}\n\tint size(int a) {\n\t\treturn -dat[find(a)];\n\t}\n};\n\nint main(){\n\tfor (int h, w, c; cin >> h >> w >> c, (h | w | c) != 0; ) {\n\t\tvector<vi> m(h, vi(w));\n\t\trep(i, h) rep(j, w) cin >> m[i][j];\n\t\tint a[5];\n\t\tunion_find uf(h * w);\n\t\trep(i, h) rep(j, w) {\n\t\t\tif (j > 0) if (m[i][j] == m[i][j - 1]) uf.unite(i * w + j, i * w + j - 1);\n\t\t\tif (i > 0) if (m[i][j] == m[i - 1][j]) uf.unite(i * w + j, (i - 1) * w + j);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (a[0] = 1; a[0] <= 6; a[0]++) {\n\t\t\tfor (a[1] = 1; a[1] <= 6; a[1]++) {\n\t\t\t\tfor (a[2] = 1; a[2] <= 6; a[2]++) {\n\t\t\t\t\tfor (a[3] = 1; a[3] <= 6; a[3]++) {\n\t\t\t\t\t\ta[4] = c;\n\t\t\t\t\t\tunion_find tuf = uf;\n\t\t\t\t\t\trep(k, 5) rep(i, h) rep(j, w) {\n\t\t\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\t\t\tif (tuf.check(0, i * w + j)) if (a[k] == m[i][j - 1]) tuf.unite(i * w + j, i * w + j - 1);\n\t\t\t\t\t\t\t\tif (tuf.check(0, i * w + j - 1)) if (a[k] == m[i][j]) tuf.unite(i * w + j - 1, i * w + j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\tif (tuf.check(0, i * w + j)) if (a[k] == m[i - 1][j]) tuf.unite(i * w + j, (i - 1) * w + j);\n\t\t\t\t\t\t\t\tif (tuf.check(0, (i - 1) * w + j)) if (a[k] == m[i][j]) tuf.unite((i - 1) * w + j, i * w + j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = max(ans, tuf.size(0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <string>\n#include <map>\n#include <set>\nusing namespace std;\n\nint h, w, c;\nint p[10][10][10];\n\nint dfs(int y, int x, int depth, int from, int to) {\n  static const int dy[] = {-1, 0, 1, 0};\n  static const int dx[] = {0, -1, 0, 1};\n  p[depth][y][x] = to;\n  int count = 1;\n  for (int i = 0; i < 4; ++i) {\n    int ny = y + dy[i], nx = x + dx[i];\n    if (ny < 0 || ny >= h || nx < 0 || nx >= w) { continue; }\n    if (p[depth][ny][nx] != from) { continue; }\n    count += dfs(ny, nx, depth, from, to);\n  }\n  return count;\n}\n\nint calc(int depth) {\n  if (depth == 5) {\n    return dfs(0, 0, depth, c, 6);\n  } else {\n    int ret = 0;\n    for (int color = 0; color < 6; ++color) {\n      if (color == p[depth][0][0]) { continue; }\n      memcpy(p[depth+1], p[depth], sizeof(p[depth]));\n      dfs(0, 0, depth+1, p[depth+1][0][0], color);\n      ret = max(ret, calc(depth+1));\n    }\n    return ret;\n  }\n}\n\nint main() {\n  while (scanf(\"%d%d%d\", &h, &w, &c), h|w|c) {\n    --c;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        scanf(\"%d\", &p[0][i][j]);\n        --p[0][i][j];\n      }\n    }\n    printf(\"%d\\n\", calc(0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i, x) for(int i=0;i<(int)(x);i++)\n#define REPS(i, x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i, x) for(int i=(int)(x)-1;i>=0;i--)\n#define RREPS(i, x) for(int i=(int)(x);i>0;i--)\n#define FOR(it, x) for(auto it=x.begin();it!=x.end();++it)\n#define pb push_back\ntypedef long long ll;\ntypedef vector<int> vi;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v){\n        os << \"[\";\n        FOR(it, v) os << *it << \", \";\n        return os << \"]\";\n}\n\nint h, w, C;\nint d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nint s[10][10];\nint ans;\n\nint fill(vector<vi> &s, int x, int y, int c){\n        int sum = 1;\n        int p = s[y][x];\n        s[y][x] = c;\n        REP(i, 4){\n                int dx = x + d[i][0];\n                int dy = y + d[i][1];\n                if(s[dy][dx] != p) continue;\n                sum += fill(s, dx, dy, c);\n        }\n        return sum;\n}\n\nvoid solve(int r, vector<vi> s){\n        if(r == -1){\n                ans = max(ans, fill(s, 1, 1, 10));\n                return ;\n        }\n        REPS(c, 6)if(r || c == C){\n                auto t = s;\n                //cout << \"!\" << c << endl;\n                //FOR(it, t) cout << *it << endl;\n                if(c != t[1][1]) fill(t, 1, 1, c);\n                solve(r-1, t);\n        }\n}\n\nint main(){\n        while(cin >> h >> w >> C, h){\n                vector<vi> s(h+2, vi(w+2, -1));\n                REPS(i, h)REPS(j, w) cin >> s[i][j];\n                ans = 0;\n                solve(4, s);\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint dfs(int x, int y, int h, int w, int col, int st, vvi &p) {\n  int cnt = 1;\n  for(int i=0;i<4;++i) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(!(0 <= nx && nx < h && 0 <= ny && ny < w)) continue;\n    if(p[nx][ny] == st) {\n      p[nx][ny] = col;\n      cnt += dfs(nx, ny, h, w, col, st, p);\n    }\n  }\n  return cnt;\n}\nint solve(int h, int w, int c, int cnt, int col, vvi p) {\n  if(cnt == 0) {\n    int ma = 0;\n    for(int i=1;i<=6;++i) {\n      ma = max(ma, solve(h, w, c, cnt+1, i, p));\n    }\n    return ma;\n  } else if(cnt == 5) {\n    int st = p[0][0];\n    p[0][0] = c;\n    if(st != c) dfs(0, 0, h, w, c, st, p);\n    return dfs(0, 0, h, w, 0, c, p);\n  } else {\n    int st = p[0][0];\n    p[0][0] = col;\n    if(st != col) dfs(0, 0, h, w, col, st, p);\n    int ma = 0;\n    for(int i=1;i<=6;++i) {\n      ma = max(ma, solve(h, w, c, cnt+1, i, p));\n    }\n    return ma;\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int h, w ,c; cin >> h >> w >> c;\n    if(h == 0) break;\n    vvi p(h, vi(w, 0));\n    for(int i=0;i<h;++i) {\n      for(int j=0;j<w;++j) {\n        cin >> p[i][j];\n      }\n    }\n    if(h == 1 && w == 1) cout << 1 << endl;\n    else cout << solve(h, w, c, 0, 0, p) - 1 << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvvi in,visit,tmp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint n,m,k,col;\nint f(int a,int b,int cl){\n\ttmp[a][b]=col;\n\tvisit[a][b]=true;\n\tint sum=1;\n\trep(i,4){\n\t\tint nx=a+dx[i];\n\t\tint ny=b+dy[i];\n\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\tif(visit[nx][ny])continue;\n\t\tif(tmp[nx][ny]==cl){\n\t\t\tsum+=f(nx,ny,cl);\n\t\t}\n\t}\n\treturn sum;\n}\nint main(){\n\twhile(cin>>n>>m>>k,n+m+k){\n\t\tk--;\n\t\tin=vvi(n,vi(m));\n\t\trep(i,n)rep(j,m)cin>>in[i][j];\n\t\trep(i,n)rep(j,m)in[i][j]--;\n\t\tint out=0;\n\t\trep(i,pow(6,4)){\n\t\t\tint t=i;\n\t\t\ttmp=in;\n\t\t\trep(j,5){\n\t\t\t\tvisit=vvi(n,vi(m));\n\t\t\t\tcol=(j==4?k:t%6);\n\t\t\t\tf(0,0,tmp[0][0]);\n\t\t\t\tt/=6;\n//\t\t\t\trep(k,n){rep(l,m)cout<<\" \"<<tmp[k][l];cout<<endl;}\n\t\t\t}\n\t\t\tvisit=vvi(n,vi(m));\n\t\t\tout=max(out,f(0,0,tmp[0][0]));\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n \nusing namespace std;\n\nvoid changepanel(int ***p, int px, int py, int newc, int t);\nint count(int ***p, int t, int color, int x, int y);\nvoid simulate(int ***p, int t);\nbool isedge(int ***p, int x, int y, int t);\n\nint h, w, c;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ans;\n\nbool ischecked[8][8];\nbool ischanged[8][8];\nbool iscounted[8][8];\n\nint main()\n{\n    while(1){\n        cin >> h >> w >> c;\n        if(h == 0) break;\n        ans = 0;\n        int ***panel = new int**[h];\n        for(int i = 0; i < h; i++) panel[i] = new int*[w];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                panel[i][j] = new int[6];\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> panel[i][j][0];\n            }\n        }\n        simulate(panel, 1);\n        cout << ans << endl;\n        delete[] panel;\n    }\n    return 0;\n}\n\nvoid changepanel(int ***p, int px, int py, int newc, int t)\n{\n    int nextx, nexty;\n    int beforecolor = p[px][py][t];\n    p[px][py][t] = newc;\n    ischanged[px][py] = true;\n    for(int i = 0; i < 4; i++){\n        nextx = px + dx[i];\n        nexty = py + dy[i];\n        if(nextx >= h || nextx < 0 || nexty >= w || nexty < 0) continue;\n        if(p[nextx][nexty][t] == beforecolor && !ischanged[nextx][nexty]) changepanel(p, nextx, nexty, newc, t);\n    }\n    return;\n}\n\nint count(int ***p, int t, int color, int x, int y)\n{\n    int ans = 0;\n    if(iscounted[x][y]) ans++;\n    for(int i = 0; i < 4; i++){\n        int nextx = x + dx[i], nexty = y + dy[i];\n        if(nextx >= h || nextx < 0 || nexty >= w || nexty < 0) continue;\n        else if(p[nextx][nexty][t] == color && !iscounted[nextx][nexty]){\n            iscounted[nextx][nexty] = true;\n            ans += count(p, t, color, nextx, nexty);\n        }else if(p[nextx][nexty][t] == c && !iscounted[nextx][nexty]){\n            iscounted[nextx][nexty] = true;\n            ans += count(p, t, c, nextx, nexty);\n        }\n    }\n    return ans;\n}\n\nvoid simulate(int ***p, int t)\n{\n    if(w == 1 && h == 1){\n        ans = 1;\n        return;\n    }\n    if(t == 5) {\n        // for(int i = 0; i < h; i++){\n            // for(int j = 0; j < w; j++){\n                // cout << \" \" << p[i][j][t - 1];\n            // }\n       //     cout << endl;\n        // }\n        // cout << endl;\n        for(int i = 1; i < 7; i++){\n            for(int j = 0; j < h; j++){\n                for(int k = 0; k < w; k++){\n                    iscounted[j][k] = false;\n                }\n            }\n            if(p[0][0][t] == i) iscounted[0][0] = true;\n            int a = 0;\n            a = count(p, t - 1, i, 0, 0);\n            // cout << a << endl;\n            ans = max(ans, a);\n            }\n            // cout << ans << endl;\n        return;\n    }\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            p[i][j][t] = p[i][j][t - 1];\n        }\n    }\n    // for(int i = 0; i < h; i++){\n        // for(int j = 0; j < w; j++){\n            // cout << \" \" << p[i][j][t];\n            // }\n        // cout << endl;\n    // }\n    // cout << endl;\n    int x = 0, y = 0;\n    while(1){\n        // cout << x << \" \" << y << endl;\n        if(y == w) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                ischecked[i][j] = false;\n                ischanged[i][j] = false;\n            }\n        }\n        ischecked[x][y] = true;\n        if(p[x][y][t] != p[0][0][t] && isedge(p, x, y, t)){\n            for(int i = 0; i < h; i++){\n                for(int j = 0; j < w; j++){\n                    p[i][j][t] = p[i][j][t - 1];\n                }\n            }\n            // パネルを一つ前の状態に戻しておく\n            int newc = p[x][y][t];\n            changepanel(p, 0, 0, newc, t);\n            simulate(p, t + 1);\n        } else {\n            x++;\n            if(x == h){\n                y++;\n                x = 0;\n            }\n        }\n    }\n    return;\n}\n// あるパネルについて、隣り合ってるパネルの色以外の色でぬりかえることは無意味\n\nbool isedge(int ***p, int x, int y, int t)\n{\n    if(x == 0 && y == 0) return true;\n    bool ans = false;\n    for(int i = 0; i < 4; i++){\n        int nextx = x + dx[i];\n        int nexty = y + dy[i];\n        if(nextx >= h || nextx < 0 || nexty >= w || nexty < 0) continue;\n        if(p[nextx][nexty][t] == p[0][0][t] && !ischecked[nextx][nexty]){\n            ischecked[nextx][nexty] = true;\n            ans = isedge(p, nextx, nexty, t);\n            if(ans) break;\n        }\n    }\n    return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<functional>\n#include<numeric>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<utility>\n#include<sstream>\n#include<complex>\n#include<fstream>\n#include<bitset>\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nll h, w, c;\nint dx[4] = { 0,1 ,0 ,-1};\nint dy[4] = { 1,0 ,-1, 0};\n\n#define rep(i,n) for(int i = 0;i < n;++i)\n\nbool value(int x, int y, int w, int h) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nint ccount(int x, int y, int c,vector<vector<int>> &v,vector<vector<bool>> &f) {\n\tif (!value(x,y,h,w) || f[x][y]) return 0;\n\tf[x][y] = true;\n\tint res = 1;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (value(nx, ny, h, w) && c == v.at(nx).at(ny)) {\n\t\t\tres += ccount(nx, ny, c,v,f);\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid change(int x, int y, int c, int nc,vector<vector<int>> &v,vector<vector<bool>> &f) {\n\tif (!value(x,y,h,w) || f[x][y]) return;\n\tf[x][y] = true;\n  v[x][y] = nc;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (value(nx, ny, h, w) && c == v.at(nx).at(ny)) {\n      change(nx, ny, c, nc,v,f);\n\t\t}\n\t}\n}\n\nint ans = 0;\nvoid solve(int k, int c,vector<vector<int>> v,vector<vector<bool>> f) {\n\tif (k == 4) {\n    vector<vector<bool>> f2(h,vector<bool>(w,false));\n\t\tchange(0, 0, v[0][0], c,v,f2);\n      /* cout << \"F\" << endl;    */\n      /* rep(u,h){               */\n      /* rep(j,w){               */\n      /* cout << v[u][j] << ' '; */\n      /* }                       */\n      /* cout << endl;           */\n      /* }                       */\n    vector<vector<bool>> f3(h,vector<bool>(w,false));\n\t\tans = max(ans, ccount(0, 0, c,v,f3));\n\t}\n\telse if(k < 5){\n\t\tint C = v[0][0];\n    auto b = v;\n    auto u = f;\n\t\trep(i, 6) {\n\t\t\tif (i+1 == C) continue;\n      rep(i,h){\n        rep(j,w){\n          f[i][j] = false;\n        }\n      }\n\t\t\tchange(0, 0, C, i+1,v,f);\n      /* cout << endl;           */\n      /* rep(u,h){               */\n      /* rep(j,w){               */\n      /* cout << v[u][j] << ' '; */\n      /* }                       */\n      /* cout << endl;           */\n      /* }                       */\n\t\t\tsolve(k + 1, c,v,f);\n      v = b;\n      f = u;\n\t\t}\n\t}\n};\n\nint main() {\n\twhile (cin >> h >> w >> c, h + w + c) {\n    vector<vector<int> > v;\n    vector<vector<bool>> f(h,vector<bool>(w,false));\n\t\tv.resize(h);\n\t\tans = 0;\n\t\trep(i, h) {\n\t\t\tv[i].resize(w);\n\t\t\trep(j, w) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tf[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tsolve(0, c,v,f);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef struct a\n{\n\tint x; \n\tint y;\n}coordin;\n\nint h,w,c;\nint res = 0;\nint maze [8][8];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid changeColor(int tmp[8][8],int color)\n{\n\tint originColor = tmp[0][0];\n\tqueue <coordin> q;\n\tcoordin cc;\n\tcc.x = 0; cc.y = 0;\n\n\tq.push(cc);\n\ttmp[0][0] = color;\n\t\n\twhile (!q.empty())\n\t{\n\t\tcc = q.front();\n\t\tq.pop();\n\n\t\tfor (int i=0;i<4;++i)\n\t\t{\n\t\t\tint tmp_x = cc.x + dx[i];\n\t\t\tint tmp_y = cc.y + dy[i];\n\t\t\t\n\t\t\tif (0<= tmp_x && tmp_x < w && 0<= tmp_y && tmp_y < h)\n\t\t\t{\n\t\t\t\tif (tmp[tmp_x][tmp_y] == originColor)\n\t\t\t\t{\t\n\t\t\t\t\tcoordin tmp_cc;\n\t\t\t\t\ttmp_cc.x = tmp_x;\n\t\t\t\t\ttmp_cc.y = tmp_y;\n\t\t\t\t\tif (color != originColor) q.push(tmp_cc);\n\t\t\t\t\ttmp[tmp_x][tmp_y] = color;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n\t\n}\n\nint cnt(int m[8][8], int x, int y)\n{\n    int count=1;\n    int oc = m[x][y];\n    m[x][y] = 0;\n    for(int i=0; i<4; i++)\n    {\n        int tmp_x = x+dx[i];\n        int tmp_y = y+dy[i];\n        if(0<=tmp_x && tmp_x<w && 0<=tmp_y && tmp_y<h)\n        {\n            if(m[tmp_x][tmp_y]==oc) count+=cnt(m, tmp_x, tmp_y);\n        }\n    }\n    return count;\n}\n\nint dfs(int m[8][8],int depth)\n{\n\tif (depth == 4)\n\t{\n\t\tif(m[0][0]!=c) changeColor(m,c);\n\t\treturn cnt(m,0,0);\n\t}\n\t\n\tfor (int i=1;i<=6;++i)\n\t{\n\t\tint tmp_m[8][8];\n\t\tmemcpy(tmp_m,m,sizeof(tmp_m));\n\t\t\n\t\tif (tmp_m[0][0] != i) changeColor(tmp_m,i);\n\t\tres = max(res,dfs(tmp_m,depth+1));\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>h>>w>>c;\n\t\n\twhile (h!=0)\n\t{\n\t\tfor (int i=0;i<h;++i)\n\t\t\tfor (int j=0;j<w;++j)\n\t\t\t\tcin>>maze[j][i];\n\t\t\n\t\tcout<<dfs(maze,0)<<endl;\n\t\tres = 0;\n\t\tcin>>h>>w>>c;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint dfs(vector<vector<int>> p, int x, int c) {\n    int h = p.size(), w = p[0].size();\n    int ret = 0;\n    for(int i = 1; i <= 6; ++ i) {\n        if(x == 4 and c != i) continue;\n        vector<vector<int>> q = p;\n        queue<P> que;\n        que.push(P{1, 1});\n        vector<vector<bool>> used(h, vector<bool>(w, 0));\n        int col = q[1][1];\n        q[1][1] = i;\n        used[1][1] = 1;\n        while(que.size()) {\n            P p = que.front(); que.pop();\n            int xx = p.fr, y = p.sc;\n            rep(k, 4) {\n                int nx = xx + dx[k], ny = y + dy[k];\n                if(q[nx][ny] == col and !used[nx][ny]) {\n                    q[nx][ny] = i;\n                    used[nx][ny] = 1;\n                    que.push({nx, ny});\n                }\n            }\n        }\n        if(x == 4 and c == i) {\n            int cnt = 1;\n            que.push(P{1, 1});\n            used.assign(h, vector<bool>(w, 0));\n            used[1][1] = 1;\n            while(que.size()) {\n                P p = que.front(); que.pop();\n                int xx = p.fr, y = p.sc;\n                rep(k, 4) {\n                    int nx = xx + dx[k], ny = y + dy[k];\n                    if(q[nx][ny] == i and !used[nx][ny]) {\n                        used[nx][ny] = 1;\n                        ++ cnt;\n                        que.push({nx, ny});\n                    }\n                }\n            }\n            return cnt;\n        }\n        chmax(ret, dfs(q, x + 1, c));\n    }\n    return ret;\n}\n\nvoid solve() {\n    int h, w, c;\n\twhile(cin >> h >> w >> c) {\n        if(h == 0 and w == 0 and c == 0) break;\n        vector<vector<int>> p(h + 2, vector<int>(w + 2, 0));\n        rep(i, h) {\n            rep(j, w) {\n                cin >> p[i + 1][j + 1];\n            }\n        }\n        cout << dfs(p, 0, c) << endl;\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint p[10][10];\nint cp[10][10];\nint flag[10][10];\nint h,w,c;\n\nint sx[4]={0,1,0,-1};\nint sy[4]={1,0,-1,0};\nint col[7],res;\n\nint bfs(int cc){\n\tmemset(flag,0,sizeof(flag));\n\tqueue<P> que;\n\tque.push(P(1,1));\n\tflag[1][1]=1;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=sx[i]+x,ny=sy[i]+y;\n\t\t\tif(flag[nx][ny]==0){\n\t\t\t\tif(cp[x][y]==cp[nx][ny]){\n\t\t\t\t\tflag[nx][ny]=1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(flag[j][i]==1)cp[j][i]=cc;\n\t\t\tcnt+=flag[j][i];\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid dfs(int x){\n\tif(x<4){\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tcol[x]=i;\n\t\t\tdfs(x+1);\n\t\t}\n\t}else{\n\t\tcol[4]=c;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcp[j][i]=p[j][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tbfs(col[i]);\n\t\t}\n\t\tres=max(res,bfs(7));\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&c);\n\t\tif(h+w+c==0)break;\n\t\tres=0;\n\t\tmemset(p,0,sizeof(p));\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&p[j][i]);\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int dx[4] = {0,1,-1,0};\nconst int dy[4] = {-1,0,0,1};\nint ac = 0;\nint ans = 0;\nvoid print(vector<vector<int> > field){\n  cout << \"-------------------------\" <<endl;\n  for(int i = 0;i < field.size();i++){\n    for(int j = 0;j < field[0].size();j++){\n      cout << field[i][j] ;\n    }\n    cout << endl;\n  }\n  cout << \"-----------------------------------------------\" << endl;\n}\nvoid  change(int c,int nc,int x,int y,vector<vector<int> > &field){\n  field[y][x] = nc;\n  int nx,ny;\n  for(int i = 0;i < 4;i++){\n    nx = x+dx[i];\n    ny = y+dy[i];\n    if(nx >= 0 && nx < field[0].size() && ny >= 0 && ny < field.size()){\n      if(c == field[ny][nx]){\n\tchange(c,nc,nx,ny,field);\n      }\n    }\n  }\n\n}\nvoid bs(vector<vector<int> > field,int c){\n  assert(c == ac);\n  queue<pair<int,int> > que;\n  que.push(pair<int,int>(0,0));\n  field[0][0] = -1;\n  int cnt = 1;\n  while(!que.empty()){\n    pair<int,int> tmp = que.front();que.pop();\n    int x = tmp.first;\n    int y = tmp.second;\n    for(int i = 0;i < 4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx >= 0 && nx < field[0].size() && ny >= 0 && ny < field.size()){\n\tif(c == field[ny][nx]){\n\t  cnt++;\n\t  field[ny][nx] = -1;\n\t  que.push(pair<int,int>(nx,ny));\n\t}\n      }  \n    }\n  }\n  ans = max(ans,cnt);\n}\nvoid cal(int c,vector<vector<int> > field,int cnt){\n  assert(c == field[0][0]);\n  if(cnt == 4){\n    if(c != ac){\n      vector<vector<int> > tmp(field);\n      change(c,ac,0,0,tmp);\n      assert(tmp[0][0] == ac);\n      bs(tmp,ac);\n    }\n    return ;\n  }\n  cnt++;\n  for(int i = 0;i < 6;i++){\n    if(i == c)continue;\n    vector<vector<int> > tmp(field);\n    change(c,i,0,0,tmp);\n    assert(tmp[0][0] == i);\n    cal(tmp[0][0],tmp,cnt);\n  }\n}\n\nint main(){\n  int h,w;\n  while(cin >> h >> w >> ac && (h||w||ac)){\n    ans = 0;\n    ac--;\n    vector<vector< int> > field(h,vector<int>(w,0));\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\tcin >> field[i][j];\n\tfield[i][j]--;\n      }\n    }\n    cal(field[0][0],field,0);\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <string.h>\n#include <cassert>\n\n#ifdef _DEBUG\n#define typeof(X) std::identity<decltype(X)>::type //C++0x (for vs2010)\n#else\n#define typeof(X) __typeof__(X) // for gcc\n#endif\n\n#define sz(a)  int((a).size())\n#define FOREACH(it, c) for (typeof((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define FOR(i,count) for (int i = 0; i < (count); i++)\n#define V_CIN(v) do{for(int i = 0; i < sz(v); i++) cin >> (v)[i];}while(0)\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\nconst int MODULO = 1000000007;\n\ntypedef pair<int,int> Pii;\n\ntemplate<int size>\nclass UnionFind{\n\tint par[size];\n\tint rank[size];\npublic:\n\tUnionFind(){ reset(); }\n\n\tvoid reset(){\n\t\tFOR(i,size) par[i] = i,rank[i] = 0;\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x),y = find(y);\n\t\tif(x == y) return ;\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x,int y){return find(x) == find(y);}\n};\n\n// begin\n\nchar t[10][10];\nint h,w,c;\nint dh[] = {0,1,0,-1},dw[] = {1,0,-1,0};\n\nvoid unit(UnionFind<64>& u,char col)\n{\n\tFOR(j,h)FOR(k,w){\n\t\tFOR(i,4){\n\t\t\tint nh = dh[i] + j,nw = dw[i] + k;\n\t\t\tif(nh >= h || nw >= w) continue;\n\t\t\tif(u.same(0,j * w + k) && col == t[nh][nw])\n\t\t\t\tu.unite(j * w + k,nh * w + nw);\n\t\t}\n\t}\n}\n\nint color(char last_c,int count,UnionFind<64>& sor){\n\n\tif(count == 1){\n\t\tif(last_c != c) return 0;\n\t\tUnionFind<64> u(sor);\n\t\tunit(u,c);\n\t\tint ans = 0;\n\t\tFOR(j,h*w) ans += u.same(0,j);\n\t\treturn ans;\n\t} else {\n\t\tint ans = 0;\n\t\tfor(char i = '1'; i <= '6'; i++){\n\t\t\tif(last_c == i) continue;\n\t\t\tUnionFind<64> u(sor);\n\t\t\tunit(u,i);\n\t\t\tans = max(ans,color(i,count - 1,u));\n\t\t}\n\t\treturn ans;\n\t}\n}\n\nint main()\n{\n\twhile(cin>>h>>w>>c,h||w||c){\n\t\tc += '0';\n\t\tFOR(i,h) FOR(j,w) cin>>t[i][j];\n\n\t\tUnionFind<64> u;\n\t\tFOR(j,h)FOR(k,w){\n\t\t\tFOR(i,4){\n\t\t\t\tint nh = dh[i] + j,nw = dw[i] + k;\n\t\t\t\tif(nh >= h || nw >= w) continue;\n\t\t\t\tif(t[j][k] == t[nh][nw])\n\t\t\t\t\tu.unite(j * w + k,nh * w + nw);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tans = max(ans,color(t[0][0],6,u));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool vis[8][8];\nint mp[8][8];\nint h, w, c, prv;\nint dy[4] = {0, 1, 0, -1}, dx[4] = {1, 0, -1, 0};\n\nint ch(int y, int x)\n{\n    vis[y][x] = true;\n    int ret = 1;\n    \n    mp[y][x] = mp[0][0];\n    \n    for (int i = 0; i < 4; i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 <= ny && ny < h && 0 <= nx && nx < w && !vis[ny][nx] && mp[ny][nx] == prv){\n            ret += ch(ny, nx);\n        }\n    }\n    \n    return (ret);\n}\n\nint ct(int y, int x)\n{\n    if (mp[y][x] != prv) return (0);\n    \n    mp[y][x] = -1;\n    \n    int ret = 1;\n    for (int i = 0; i < 4; i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 <= ny && ny < h && 0 <= nx && nx < w){\n            ret += ct(ny, nx);\n        }\n    }\n    \n    return (ret);\n}\n\nint main()\n{\n    while (scanf(\"%d %d %d\", &h, &w, &c) && h){\n        c--;\n        int mp_[8][8];\n        memset(mp_, -1, sizeof(mp_));\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                scanf(\"%d\", &mp_[i][j]);\n                mp_[i][j]--;\n            }\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < 1296; i++){\n            memcpy(mp, mp_, sizeof(mp_));\n            int x = c * 1296 + i;\n            for (int j = 0; j < 5; j++){\n                prv = mp[0][0];\n                mp[0][0] = x % 6;\n                memset(vis, 0, sizeof(vis));\n                ans = max(ans, ch(0, 0));\n                x /= 6;\n            }\n            prv = mp[0][0];\n            ans = max(ans, ct(0, 0));\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint h, w, c;\n\nint dfs(vii a, int d) {\n  int now = a[1][1];\n  int res = 0;\n  rep1 (nex, 6) {\n    if (now == nex) continue;\n    if (d == 5 && nex != c) continue;\n    auto b = a;\n    queue<pii> qu;\n    qu.push(pii(1, 1));\n    b[1][1] = nex;\n    while (!qu.empty()) {\n      int i0 = qu.front().first, j0 = qu.front().second;\n      qu.pop();\n      rep (k, 4) {\n        int ni = i0 + dx[k], nj = j0 + dy[k];\n        if (b[ni][nj] == now) {\n          b[ni][nj] = nex;\n          qu.push(pii(ni, nj));\n        }\n      }\n    }\n\n    if (nex == c) {\n      vii used(h + 2, vi(w + 2));\n      qu.push(pii(1, 1));\n      int cnt = 1;\n      used[1][1] = true;\n      while (!qu.empty()) {\n        int i0 = qu.front().first, j0 = qu.front().second;\n        qu.pop();\n        rep (k, 4) {\n          int ni = i0 + dx[k], nj = j0 + dy[k];\n          if (b[ni][nj] == nex && !used[ni][nj]) {\n            cnt++;\n            qu.push(pii(ni, nj));\n            used[ni][nj] = true;\n          }\n        }\n      }\n      chmax(res, cnt);\n    }\n    \n    if (d != 5) chmax(res, dfs(b, d + 1));\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    cin >> h >> w >> c;\n    if (w == 0 && h == 0) return 0;\n    vii a(h + 2, vi(w + 2, -1));\n    int si, sj;\n    rep1 (i, h) {\n      rep1 (j, w) {\n        cin >> a[i][j];\n      }\n    }\n\n    cout << dfs(a, 1) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> mt;\n\nll h,w,c;\nmt p;\nvector<mt> dp;\nll dx[4] = {0, 1, 0, -1};\nll dy[4] = {1, 0, -1, 0};\nll ans;\n\nbool is_in(ll x, ll y){\n  return x >= 0 && x < h && y >= 0 && y < w;\n}\n\n\nvoid change(ll d, ll c){\n  ll orig = dp[d][0][0];\n  dp[d+1] = mt(h,vl(w));\n  mt visit = mt(h,vl(w));\n  queue<vl> q;\n  q.push(vl({0, 0}));\n  visit[0][0] = 1;\n  while(!q.empty()){\n    ll x = q.front()[0];\n    ll y = q.front()[1];\n    q.pop();\n\n    dp[d+1][x][y] = c;\n    visit[x][y] = 1;\n    for(ll i = 0;i < 4;i++){\n      ll next = x+dx[i];\n      ll neyt = y+dy[i];\n      if(!is_in(next, neyt)) continue;\n      if(visit[next][neyt] == 1) continue;\n      if(dp[d][next][neyt] == orig){\n        visit[next][neyt] = 1;\n        q.push(vl({next, neyt}));\n      }\n    }\n  }\n  for(ll i = 0;i < h;i++){\n    for(ll j = 0;j < w;j++){\n      if(dp[d+1][i][j] == 0) dp[d+1][i][j] = dp[d][i][j];\n    }\n  }\n}\n\nvoid calc(){\n  ll d = 5;\n  ll orig = dp[d][0][0];\n  if(orig != c) return;\n  mt visit = mt(h,vl(w));\n  queue<vl> q;\n  q.push(vl({0, 0}));\n  visit[0][0] = 1;\n  ll cnt = 0;\n  while(!q.empty()){\n    ll x = q.front()[0];\n    ll y = q.front()[1];\n    q.pop();\n    cnt++;\n    visit[x][y] = 1;\n    for(ll i = 0;i < 4;i++){\n      ll next = x+dx[i];\n      ll neyt = y+dy[i];\n      if(!is_in(next, neyt)) continue;\n      if(visit[next][neyt] == 1) continue;\n      if(dp[d][next][neyt] == orig){\n        visit[next][neyt] = 1;\n        q.push(vl({next, neyt}));\n      }\n    }\n  }\n  ans = max(ans,cnt);\n}\n\nvoid dfs(ll d){\n  if(d == 5){\n    calc();\n    return;\n  }\n  for(ll i = 1;i <= 6;i++){\n    change(d, i);\n    dfs(d+1);\n  }\n  return;\n}\n\nint main(){\n  while(cin >> h >> w >> c){\n    if(h == 0 && w == 0 && c == 0) return 0;\n    dp = vector<mt>(6);\n    dp[0] = mt(h,vl(w));\n    for(ll i = 0;i < h;i++){\n      for(ll j = 0;j < w;j++){\n        cin >> dp[0][i][j];\n      }\n    }\n    ans = 0;\n    dfs(0);\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h, w, c;\nint field[10][10][10];\nbool visit[10][10];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint dfs(int depth, int x, int y, int tc) {\n  if (visit[y][x]) { return 0; }\n  visit[y][x] = true;\n  const int ndepth = depth + 1;\n  const int pc = field[depth][0][0];\n  field[ndepth][y][x] = tc;\n  int ret = 1;\n  REP(dir, 4) {\n    int nx = x + dx[dir];\n    int ny = y + dy[dir];\n    if (nx < 0 || nx >= w || ny < 0 || ny >= h) { continue; }\n    if (field[depth][ny][nx] != pc) { continue; }\n    ret += dfs(depth, nx, ny, tc);\n  }\n  return ret;\n}\n\nint calc(int depth) {\n  if (depth == 5) {\n    if (field[depth][0][0] != c) { return 0; }\n    MEMSET(visit, false);\n    memcpy(field[depth + 1], field[depth], sizeof(field[depth]));\n    return dfs(depth, 0, 0, c);\n  }\n  int ret = 0;\n  FOREQ(i, 1, 6) {\n    if (i == field[depth][0][0]) { continue; }\n    if (depth == 4 && i != c) { continue; }\n    MEMSET(visit, false);\n    memcpy(field[depth + 1], field[depth], sizeof(field[depth]));\n    dfs(depth, 0, 0, i);\n    ret = max(ret, calc(depth + 1));\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &c), h|w|c) {\n    REP(y, h) {\n      REP(x, w) {\n        scanf(\"%d\", &field[0][y][x]);\n      }\n    }\n    cout << calc(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nint fill(char map[10][10], int y,int x, int c){\n\tint sum=0;\n\tint t=map[y][x];\n\tmap[y][x]=c;\n\tfor(int i=0;i<4;i++)\n\t\tif(map[y+dy[i]][x+dx[i]] == t){\n\t\t\tsum+=fill(map, y+dy[i], x+dx[i], c);\n\t\t}\n\treturn sum+1;\n}\nint count(char map[10][10], char c){\n\tchar tmp[10][10];\n\tmemcpy(tmp,map,sizeof(tmp));\n\tif(map[1][1]!=c) return 0;\n\treturn fill(tmp,1,1,0);\n}\n\nint solve(char map[10][10], int lim, char c){\n\tint ret,max=0;\n\tif(!lim) return count(map, c);\n\t\n\tfor(char i='1';i<='6';i++){\n\t\tchar tmp[10][10];\n\t\tmemcpy(tmp,map,sizeof(tmp));\n\t\tif(map[1][1]==i) continue;\n\t\tfill(tmp,1,1,i);\n\t\tret=solve(tmp, lim-1, c);\n\t\tif(ret>max) max=ret;\n\t}\n\treturn max;\n}\n\nint main(){\n\tint i,j,h,w;\n\tchar c;\n\twhile(cin>>h>>w>>c,h){\n\t\tchar map[10][10]={0};\n\t\tfor(i=1;i<=h;i++)\n\t\t\tfor(j=1;j<=w;j++) cin>>map[i][j];\n\t\tcout<<solve(map,5,c)<<endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n\nusing namespace std;\n\n#define MAX 8\n\nstruct S{\n\tint field[MAX][MAX];\n\tint cnt;\n};\n\nstruct S2{\n\tint x, y;\n};\n\nint main(){\n\n\tint h, w, c;\n\tS panel,tmp;\n\tstack<S> sv;\n\n\tS2 point,tmp2;\n\tstack<S2> n;\n\tint color;\n\tint dx[] = { 0, 0, 1, -1 };\n\tint dy[] = { 1, -1, 0, 0 };\n\tint cnt;\n\tint max;\n\twhile (1){\n\n\t\tcin >> h >> w >> c;\n\t\tif (h == 0 && w == 0 && c == 0) break;\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcin >> panel.field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmax = -1;\n\t\tpanel.cnt = 0;\n\n\t\tsv.push(panel);\n\n\t\twhile (!sv.empty()){\n\t\t\tpanel = sv.top();\n\t\t\tsv.pop();\n\n\t\t\tif (panel.cnt == 5){\n\t\t\t\tif (panel.field[0][0] != c) continue;\n\t\t\t\tpoint.x = 0, point.y = 0;\n\t\t\t\tpanel.field[0][0] = -1;\n\t\t\t\tcnt = 1;\n\t\t\t\tn.push(point);\n\t\t\t\twhile (!n.empty()){\n\t\t\t\t\tpoint = n.top();\n\t\t\t\t\tn.pop();\n\t\t\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\t\t\tif (point.x + dx[i] >= 0 && point.x + dx[i] < w && point.y + dy[i] >= 0 && point.y + dy[i] < h){\n\t\t\t\t\t\t\tif (panel.field[point.y + dy[i]][point.x + dx[i]] == c){\n\t\t\t\t\t\t\t\tpanel.field[point.y + dy[i]][point.x + dx[i]] = -1;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\ttmp2.x = point.x + dx[i], tmp2.y = point.y + dy[i];\n\t\t\t\t\t\t\t\tn.push(tmp2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt>max) max = cnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 6; i++){\n\t\t\t\ttmp = panel;\n\t\t\t\tpoint.x = 0, point.y = 0;\n\t\t\t\tn.push(point);\n\t\t\t\tcolor = tmp.field[0][0];\n\t\t\t\ttmp.field[0][0] = i;\n\t\t\t\tif (i == color) continue;\n\t\t\t\twhile (!n.empty()){\n\t\t\t\t\tpoint = n.top();\n\t\t\t\t\tn.pop();\n\t\t\t\t\tfor (int j = 0; j < 4; j++){\n\t\t\t\t\t\tif (point.x + dx[j] >= 0 && point.x + dx[j] < w && point.y + dy[j] >= 0 && point.y + dy[j] < h){\n\t\t\t\t\t\t\tif (tmp.field[point.y + dy[j]][point.x + dx[j]] == color){\n\t\t\t\t\t\t\t\ttmp.field[point.y + dy[j]][point.x + dx[j]] = i;\n\t\t\t\t\t\t\t\ttmp2.x = point.x + dx[j], tmp2.y = point.y + dy[j];\n\t\t\t\t\t\t\t\tn.push(tmp2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp.cnt = panel.cnt + 1;\n\t\t\t\tsv.push(tmp);\n\t\t\t}\n\t\t}\n\t\tcout << max << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-6;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nconst int64 mod = 1e9+7;\n\nint32 dx[4] = {-1, 1, 0, 0};\nint32 dy[4] = {0, 0, -1, 1};\n\nint main(void){\n\tint32 h, w, c;\n\twhile(cin >> h >> w >> c && h+w+c){\n\t\tauto in = [&](int32 y, int32 x){ return 0<=y&&y<h&&0<=x&&x<w; };\n\t\tvector<vector<int64>> p(h, vector<int64>(w));\n\t\tREP(i, h) REP(j, w) cin >> p[i][j];\n\t\tint32 res = 0;\n\t\tfunction<void(int32, int32)> dfs = [&](int32 cnt, int32 col){\n\t\t\tif(cnt == 5){\n\t\t\t\tvector<vector<bool>> visited(h, vector<bool>(w, 0));\n\t\t\t\tqueue<PII> q;\n\t\t\t\tq.push(PII(0, 0));\n\t\t\t\tvisited[0][0] = 1;\n\t\t\t\tint32 cnt = 0;\n\t\t\t\twhile(q.size()){\n\t\t\t\t\tint32 y, x;\n\t\t\t\t\ttie(y, x) = q.front(); q.pop();\n\t\t\t\t\tcnt++;\n\t\t\t\t\tREP(i, 4){\n\t\t\t\t\t\tint32 yy = y+dy[i], xx = x+dx[i];\n\t\t\t\t\t\tif(!in(yy, xx)) continue;\n\t\t\t\t\t\tif(!visited[yy][xx] && p[yy][xx] == p[y][x]){\n\t\t\t\t\t\t\tvisited[yy][xx] = 1;\n\t\t\t\t\t\t\tq.push(PII(yy, xx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres = max(res, cnt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvector<vector<int64>> tmp = p;\n\t\t\tint32 fc = p[0][0];\n\t\t\tvector<vector<bool>> visited(h, vector<bool>(w, 0));\n\t\t\tvisited[0][0] = 1;\n\t\t\tqueue<PII> q;\n\t\t\tq.push(PII(0, 0));\n\t\t\twhile(q.size()){\n\t\t\t\tint32 y, x;\n\t\t\t\ttie(y, x) = q.front(); q.pop();\n\t\t\t\tp[y][x] = col;\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tint32 yy = y+dy[i], xx = x+dx[i];\n\t\t\t\t\tif(!in(yy, xx)) continue;\n\t\t\t\t\tif(!visited[yy][xx] && p[yy][xx] == fc){\n\t\t\t\t\t\tvisited[yy][xx] = 1;\n\t\t\t\t\t\tq.push(PII(yy, xx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt < 3) REP(i, 6) dfs(cnt+1, i+1);\n\t\t\telse dfs(cnt+1, c);\n\t\t\tp = tmp;\n\t\t};\n\t\tREP(i, 6) dfs(0, i+1);\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[10010];string s;ll l;double d;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tdouble nextDouble(){scanf(\"%lf\", &d);return d;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nstruct UFT{\t//O(loga(n))\n\tint n;\n\tvi d, r;\n\tUFT(int n) : n(n), d(n, -1), r(n, 0){};\n\tint root(int i){\n\t\tif(d[i] < 0) return i;\n\t\treturn d[i] = root(d[i]);\n\t}\n\tbool same(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\tbool unite(int x, int y){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x == y) return false;\n\n\t\tif(r[x] < r[y]) swap(x, y);\n\t\telse if(r[x] == r[y]) r[x]++;\n\t\td[x] += d[y];\n\t\td[y] = x;\n\t\treturn true;\n\t}\n\tint size(int i){\n\t\treturn -d[root(i)];\n\t}\n};\n\nint ans = 0;\nint h, w, c;\nint d[10][10];\nbool isOutOfRange(int x, int y){\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\nint dx[] ={-1,0,1,0};\nint dy[] ={0,-1,0,1};\n\nvoid calc(int clr, int n, UFT uft){\n\trep(y, h) rep(x, w){\n\t\tif(!uft.same(0, y * w + x)) continue;\n\t\trep(i, 4){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\tif(d[ny][nx] == clr) uft.unite(0, ny * w + nx);\n\t\t}\n\t}\n\tif(n < 4) rep(i, 6) calc(i+1, n+1, uft);\n\tif(clr == c) ans = max(ans, uft.size(0));\n}\n\nint main(){\n\twhile(1){\n\t\th = in.nextInt(), w = in.nextInt(), c = in.nextInt();\n\t\t//cout<<h<<\" \"<<w<<\" \"<<c<<endl;\n\t\tif(h == 0 && w == 0 && c == 0) break;\n\t\trep(i, h) rep(j, w) d[i][j] = in.nextInt();\n\t\tUFT uft(h * w);\n\t\tans = 0;\n\t\trep(y, h) rep(x, w){\n\t\t\trep(i, 4){\n\t\t\t\tint nx =x +dx[i], ny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\t\tif(d[y][x] == d[ny][nx]) uft.unite(y*w + x, ny*w+nx);\n\t\t\t}\n\t\t\t//if(d[y][x] == c) ans = max(ans, uft.size(y * w + x));\n\t\t}\n\t\trep(i, 6) calc(i+1, 0, uft);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,b,e) for(int i=(b);i<(e);++i)\n#define rep(i,e) for(int i=0;i<(e);++i)\n\nstruct UnionFind{\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n, -1), rank(n, 0), sizes(n, 1){}\n\n  int find(int x){\n    if(par[x] < 0) return x;\n    else return par[x] = find(par[x]);\n  }\n\n  bool unite(int x, int y){\n    x = find(x); y = find(y);\n    if(x==y) return false;\n    else if(rank[x]<rank[y]){\n      par[x] = y;\n      sizes[y] += sizes[x];\n    }\n    else if(rank[x]>rank[y]){\n      par[y] = x;\n      sizes[x] += sizes[y];\n    }\n    else{\n      par[y] = x;\n      rank[x] += 1;\n      sizes[x] += sizes[y];\n    }\n    return true;\n  }\n\n  bool same(int x, int y){\n    return find(x)==find(y);\n  }\n\n  int size(int x){\n    return sizes[find(x)];\n  }\n};\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n  int h, w, c;\n  while(cin >> h >> w >> c){\n    if(h==0) return 0;\n\n    int ans=0;\n    UnionFind uf(h*w);\n    vector<vector<int>> board(h, vector<int>(w));\n\n    rep(i, h)rep(j, w){\n      int t; cin >> t;\n      board[i][j] = t;\n    }\n\n    rep(i, h)rep(j, w)rep(t, 4){\n      if(0<=i+dy[t] && i+dy[t]<h && 0<=j+dx[t] && j+dx[t]<w && board[i][j]==board[i+dy[t]][j+dx[t]]){\n        uf.unite(w*i+j, w*(i+dy[t])+j+dx[t]);\n      }\n    }\n\n    REP(c1, 1, 7)REP(c2, 1, 7)REP(c3, 1, 7)REP(c4, 1, 7){\n      if(c1==c2 || c2==c3 || c3==c4 || c4==c) continue;\n      int cs[] = {c1, c2, c3, c4, c};\n      UnionFind uft = uf;\n      rep(cc, 5)rep(i, h)rep(j, w){\n        int ct = cs[cc];\n        if(uft.same(w*i+j, 0)){\n          rep(t, 4){\n            if(0<=i+dy[t] && i+dy[t]<h && 0<=j+dx[t] && j+dx[t]<w && ct==board[i+dy[t]][j+dx[t]]){\n              uft.unite(w*i+j, w*(i+dy[t])+j+dx[t]);\n            }\n          }\n        }\n      }\n      ans = max(ans, uft.size(0));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w,c;\n\nstruct Panel{ int a[8][8]; };\nstruct Point{ int x,y; };\n\nint count(const Panel &pnl){\n\tint ans=1;\n\tbool visited[8][8]={}; visited[0][0]=true;\n\n\tqueue<Point> qu; qu.push((Point){0,0});\n\twhile(!qu.empty()){\n\t\tPoint p=qu.front(); qu.pop();\n\t\trep(i,4){\n\t\t\tPoint q={p.x+dx[i],p.y+dy[i]};\n\t\t\tif(0<=q.y && q.y<h && 0<=q.x && q.x<w\n\t\t\t&& !visited[q.y][q.x] && pnl.a[q.y][q.x]==c){\n\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\tans++;\n\t\t\t\tqu.push((Point){q.x,q.y});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint dfs(Panel pnl,int depth){\n\tif(depth==5) return count(pnl);\n\n\tint ans=0;\n\tchar prev=pnl.a[0][0];\n\tfor(int cc=1;cc<=6;cc++){\n\t\tif(cc==prev || (depth==4 && cc!=c)) continue;\n\t\tPanel tmp=pnl;\n\n\t\tpnl.a[0][0]=cc;\n\t\tbool visited[8][8]={}; visited[0][0]=true;\n\t\tqueue<Point> qu; qu.push((Point){0,0});\n\t\twhile(!qu.empty()){\n\t\t\tPoint p=qu.front(); qu.pop();\n\t\t\trep(i,4){\n\t\t\t\tPoint q={p.x+dx[i],p.y+dy[i]};\n\t\t\t\tif(0<=q.y && q.y<h && 0<=q.x && q.x<w\n\t\t\t\t&& !visited[q.y][q.x] && pnl.a[q.y][q.x]==prev){\n\t\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\t\tpnl.a[q.y][q.x]=cc;\n\t\t\t\t\tqu.push((Point){q.x,q.y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=max(ans,dfs(pnl,depth+1));\n\n\t\tpnl=tmp;\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&h,&w,&c),h;){\n\t\tPanel pnl;\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&pnl.a[i][j]);\n\n\t\tprintf(\"%d\\n\",dfs(pnl,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n\nusing namespace std;\n\ntypedef long long ll;\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nint panel[16][16];\nint backup[16][16];\nint vis[16][16];\nint h, w;\n\nvoid dump(){\n  return;\n  puts(\":::::::::\");\n  for (int y = 1; y <= h; y++){\n    for (int x = 1; x <= w; x++){\n      printf(\"%2d\", panel[y][x]);\n    }\n    puts(\"\");\n  }\n  puts(\":::::::::\");\n}\n\nvoid fill_panel(int x, int y, int a, int b){\n  if (vis[y][x]++) return;\n  int& p = panel[y][x];\n  if (p != a) return;\n  p = b;\n  for (int d = 0; d < 4; d++){\n    fill_panel(x + dx[d], y + dy[d], a, b);\n  }\n}\n\nint count_panel(int x, int y, int a)\n{\n  if (vis[y][x]++) return 0;\n  int p = panel[y][x];\n  if (p != a) return 0;\n  int res = 1;\n  for (int d = 0; d < 4; d++){\n    res += count_panel(x + dx[d], y + dy[d], a);\n  }\n  return res;\n}\n\nint simulate(int manip[5]){\n  int r;\n  for (int i = 0; i < 5; i++){\n    memset(vis, 0, sizeof(vis));\n    fill_panel(1, 1, panel[1][1], manip[i]);\n  }\n  memset(vis, 0, sizeof(vis));\n  return count_panel(1, 1, panel[1][1]);\n}\n\nint main()\n{\n  int c;\n  while (h = in(), w = in(), c = in()){\n    memset(panel, 0, sizeof(panel));\n    for (int y = 1; y <= h; y++){\n      for (int x = 1; x <= w; x++){\n        panel[y][x] = in();\n      }\n    }\n    memcpy(backup, panel, sizeof(backup));\n    int maxi = 0;\n    int manip[5];\n    manip[4] = c;\n    for (int i = 1; i <= 6; i++){\n      manip[0] = i;\n      for (int j = 1; j <= 6; j++){\n        manip[1] = j;\n        for (int k = 1; k <= 6; k++){\n          manip[2] = k;\n          for (int l = 1; l <= 6; l++){\n            manip[3] = l;\n            memcpy(panel, backup, sizeof(panel));\n            int r = simulate(manip);\n            maxi = max(maxi, r);\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\", maxi);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nvector<int> val(5,1);\nvector<vector<int>> tmpp;\nint h,w;\nvector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\nbool nextval(){\n  val[3]++;\n  if(val[3] == 7){\n    val[3] = 1;\n    val[2]++;\n    if(val[2] == 7){\n      val[2] = 1;\n      val[1]++;\n      if(val[1] == 7){\n\tval[1] = 1;\n\tval[0]++;\n\tif(val[0] == 7){\n\t  val[0] = 1;\n\t  return false;\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nbool isin(int x, int y){\n  bool ans;\n  if(0 <= x and x < h and 0 <= y and y < w) ans = true;\n  else ans = false;\n  return ans;\n}\n\nvoid changeto(int to){\n  queue<pair<int,int>> q;\n  int from = tmpp[0][0];\n\n  q.push(pair<int,int>(0,0));\n  tmpp[0][0] = to;\n\n  while(not q.empty()){\n    pair<int,int> p = q.front();\n    q.pop();\n\n    rep(i, dx.size()){\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(isin(nx,ny) and tmpp[nx][ny] == from){\n\tq.push(pair<int,int>(nx, ny));\n\ttmpp[nx][ny] = to;\n      }\n    }\n  }\n}\n\nint area(){\n  queue<pair<int,int>> q;\n\n  q.push(pair<int,int>(0,0));\n  int c = tmpp[0][0];\n  tmpp[0][0] = -1;\n  int res = 1;\n\n  while(not q.empty()){\n    pair<int,int> p = q.front();\n    q.pop();\n\n    rep(i, dx.size()){\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(isin(nx,ny) and tmpp[nx][ny] == c){\n\tq.push(pair<int,int>(nx, ny));\n\ttmpp[nx][ny] = -1;\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(void){\n  int c;\n  while(cin >> h >> w >> c, h){\n    vector<vector<int>> p(h,vector<int>(w));\n    rep(i,h) rep(j,w) cin >> p[i][j];\n    val[4] = c;\n\n    int res = 0;\n    do{\n      tmpp = p;\n      rep(i,5) if(tmpp[0][0] != val[i]) changeto(val[i]);\n      res = max(res, area());\n    }while(nextval());\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 8;\nconst int dy[4] = { 0,1,0,-1 };\nconst int dx[4] = { 1,0,-1,0 };\n\nint h, w, c;\n\nint solve(vector<vector<int>> grid, int p[])\n{\n\tint ans = 0;\n\n\tfor (int cnt = 0; cnt < 5; cnt++) {\n\t\tqueue<pair<int, int>> q;\n\t\tbool visited[MAX][MAX];\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tvisited[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tint num = grid[0][0];\n\t\tq.push({ 0,0 });\n\t\tvisited[0][0] = true;\n\n\t\twhile (q.empty() == false) {\n\t\t\tpair<int, int> now = q.front();\n\t\t\tq.pop();\n\n\t\t\tgrid[now.first][now.second] = p[cnt];\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ny = now.first + dy[i];\n\t\t\t\tint nx = now.second + dx[i];\n\n\t\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (grid[ny][nx] == num&&visited[ny][nx] == false) {\n\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool visited[MAX][MAX];\n\n\tfor (int i = 0; i < MAX; i++) {\n\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\tvisited[i][j] = false;\n\t\t}\n\t}\n\n\tfor (int y = 0; y < h; y++) {\n\t\tfor (int x = 0; x < w; x++) {\n\t\t\tint sum = 0;\n\t\t\tqueue<pair<int, int>> q;\n\n\t\t\tif (visited[y][x] == false) {\n\t\t\t\tq.push({ y,x });\n\t\t\t\tvisited[y][x] = true;\n\t\t\t}\n\n\t\t\twhile (q.empty() == false) {\n\t\t\t\tpair<int, int> now = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tsum++;\n\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint ny = now.first + dy[i];\n\t\t\t\t\tint nx = now.second + dx[i];\n\n\t\t\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (grid[ny][nx] == c&&visited[ny][nx] == false) {\n\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = max(ans, sum);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> h >> w >> c;\n\n\t\tif (h == 0 && w == 0 && c == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<vector<int>> grid(h, vector<int>(w, -1));\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> grid[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tfor (int j = 1; j <= 6; j++) {\n\t\t\t\tfor (int k = 1; k <= 6; k++) {\n\t\t\t\t\tfor (int l = 1; l <= 6; l++) {\n\t\t\t\t\t\tint p[5] = { i,j,k,l,c };\n\t\t\t\t\t\tans = max(ans, solve(grid, p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define ISIN(x, y, w, h) (x >= 0 && x < w && y >= 0 && y < h)\n\n#define f first\n#define s second\n\nusing namespace std;\n\npair<int, int> joint[70];\nint h, w, c;\nint p[8][8];\nbool f[8][8];\n\nconst int dx[4] = { 1,-1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1};\n\nint getInt(){ int r; scanf(\"%d\", &r); return r; }\n\nint solve(int now, int prev, int cnt){\n  int ret = 0;\n\n  //printf(\"solve(%d, %d, %d)\\n\", now, prev, cnt);\n\n  if(now == 6) return cnt;\n\n  for(int col = 1; col <= 6; col++){\n    int cc = cnt;\n    queue<pair<int, int> > q;\n\n    if(now == 5 && col != c) continue;\n    if(now != 5 && col == prev) continue;\n    if(now == 0 && col != prev) continue;\n\n    REP(i, cnt) q.push(joint[i]);\n\n    while(q.size()){\n      int x = q.front().s;\n      int y = q.front().f;\n\n      q.pop();\n\n      REP(i, 4){\n\tint xx = x + dx[i];\n\tint yy = y + dy[i];\n\n\tif(ISIN(xx, yy, w, h) && p[yy][xx] == col && !f[yy][xx]){\n\t  f[yy][xx] = true;\n\t  joint[cc].f = yy;\n\t  joint[cc].s = xx;\n\t  q.push(joint[cc++]);\n\t}\n      }\n    }\n\n    ret = max(ret, solve(now + 1, col, cc));\n    \n    for(int i = cnt; i < cc; i++){\n      int x = joint[i].s;\n      int y = joint[i].f;\n      \n      f[y][x] = false;\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    h = getInt();\n    w = getInt();\n    c = getInt();\n\n    if(h + w + c == 0) break;\n\n    REP(i, h) REP(j, w) p[i][j] = getInt();\n    f[0][0] = true;\n\n    printf(\"%d\\n\", solve(0, p[0][0], 1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint h,w,c;\n\nint search_union(vector<int> panels){\n  stack<int> s;\n  int color=panels[0];\n  vector<int> visited(h*w);\n  int cnt=1;\n  s.push(0);\n  while(!s.empty()){\n    int v=s.top();\n    s.pop();\n    int y=v/w,x=v%w;\n    visited[y*w+x]=1;\n    for(int i=0;i<4;++i){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(0<=nx&&nx<w&&0<=ny&&ny<h&&panels[ny*w+nx]==color&&!visited[ny*w+nx]){\n        s.push(ny*w+nx);\n        visited[ny*w+nx]=1;\n        cnt++;\n      }\n    }\n  }\n  return cnt;\n}\n\nvector<int> set_color(vector<int> panels,int target){\n  stack<int> s;\n  vector<int> new_panels=panels;\n  s.push(0);\n  vector<bool> visited(h*w);\n  int color=panels[0];\n  while(!s.empty()){\n    int v=s.top();\n    s.pop();\n    int y=v/w,x=v%w;\n    //cout<<\"set \"<<y<<\" \"<<x<<endl;\n    visited[y*w+x]=1;\n    new_panels[y*w+x]=target;\n    for(int i=0;i<4;++i){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(0<=nx&&nx<w&&0<=ny&&ny<h&&panels[ny*w+nx]==color&&!visited[ny*w+nx]){\n        s.push(ny*w+nx);\n      }\n    }\n  }\n  return new_panels;\n}\n\nvoid print_vector(vector<int> panels){\n  for(int i=0;i<h;++i){\n    for(int j=0;j<w;++j){\n      cout<<panels[i*w+j]<<\" \";\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n}\n\nint search(int rest,vector<int> panels){\n  int mx=0;\n  if(rest==0){\n    //cout<<search_union(panels)<<endl;\n    //print_vector(panels);\n    return search_union(panels);\n  }else if(rest==1){\n    return search(rest-1,set_color(panels,c));\n  }else{\n    for(int i=1;i<=6;++i){\n      if(i!=panels[0])mx=max(mx,search(rest-1,set_color(panels,i)));\n    }\n  }\n  return mx;\n}\n\nint main(){\n  cin>>h>>w>>c;\n  while(h!=0){\n    vector<int> panels(h*w);\n    for(int i=0;i<h;++i){\n      for(int j=0;j<w;++j){\n        cin>>panels[i*w+j];\n      }\n    }\n    cout<<search(5,panels)<<endl;\n    cin>>h>>w>>c;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#define MAX 8\n#define INF 1000000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint d[MAX][MAX];\nint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\nint h, w, color, res = 0;\n\nstruct F {\n     int field[8][8];\n     int times;\n};\n\nqueue<F> tmp;\n\nvoid dfs (F f, int colors) {\n     if (f.times == 5) colors = color;\n     int count = 1;\n     f.field[0][0] = 0;\n     queue<P> que;\n     que.push(P(0,0));\n\n     for (int i = 0; i < MAX; i++)\n\t  for (int j = 0; j < MAX; j++)\n\t       d[i][j] = INF;\n     d[0][0] = 0;\n     bool flag = false;\n\n     while (que.size()) {\n\t  P p = que.front(); que.pop();\n\t  for (int i = 0; i < 4; i++) {\n\t       int nx = p.first + dx[i], ny = p.second + dy[i];\n\n\t       if (0 <= nx && nx < w && 0 <= ny && ny < h && d[nx][ny] == INF) {\t    \n\t\t    if (f.field[nx][ny] == 0 || f.field[nx][ny] == colors) {\n\t\t\t flag = true;\n\t\t\t f.field[nx][ny] = 0;\n\t\t\t d[nx][ny] = 0;\n\t\t\t count++;\n\n\t\t\t que.push(P(nx,ny));\n\t\t    }\n\t       }\n\t  }\n     }\n     if (count > res) res = count;\n     if ((flag && f.times < 5) || f.times == 0) tmp.push(f);\n}\n\nvoid solve() {\n     while (tmp.size()) {\n\t  F f = tmp.front(); tmp.pop();\n\t  f.times++;\n\t  for (int i = 1; i < 7; i++) {\n\t       dfs(f, i);\n\t  }\n     }\n}\n\nint main ()\n{    \n     while (cin >> h >> w >> color, h) {\n\t  F f;\n\t  res = 0;\n\t  for (int i = 0; i < h; i++)\n\t       for (int j = 0; j < w; j++)\n\t\t    cin >> f.field[i][j];\n\n\t  f.times = 0;\n\t  dfs(f, f.field[0][0]);\n\t  solve();\n\t  \n\t  cout << res << endl;\n     }\n\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, from, to) for (int i = from; i < to; ++i)\n#define REP(i, from, to) for (int i = from; i <= to; ++i)\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint data[9][9];\nqueue<P> que;\nint dx[] = {-1, 0,1, 0};\nint dy[] = {0, -1, 0, 1};\nint x, y;\nint datax, datay, endC;\n\nvoid pData(int p[9][9]) {\n\tREP(i, 1, datay) {\n\t\tREP(j, 1, datax) {\n\t\t\tcout << p[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvoid copy(int p1[9][9], int p2[9][9]) {\n\tREP(i, 1, 8) {\n\t\tREP(j, 1, 8) {\n\t\t\tp1[i][j] = p2[i][j];\n\t\t}\n\t}\n}\n\nint countColor(int masu[9][9]) {\n\tbool isGone[9][9];\n\tREP(i, 1, 8) {\n\t\tREP(j, 1, 8) {\n\t\t\tisGone[i][j] = false;\n\t\t}\n\t}\n\tint num = 1;\n\tP p = P(1, 1);\n\tque.push(p);\n\tisGone[1][1] = true;\n\twhile(!que.empty()) {\n\t\tp = que.front();\n\t\tque.pop();\n\t\ty = p.first; x = p.second;\n\t\trep(i, 0, 4) {\n\t\t\tint tmpy = y + dy[i];\n\t\t\tint tmpx = x + dx[i];\n\t\t\tif (tmpy < 1 && tmpy > datay && tmpx < 1 && tmpx > datax) {\n\t\t\t\tcontinue;\n\t\t\t} else if (masu[tmpy][tmpx] == endC && !isGone[tmpy][tmpx]) {\n\t\t\t\tisGone[tmpy][tmpx] = true;\n\t\t\t\tque.push(make_pair(tmpy, tmpx));\n\t\t\t\t++num;\n\t\t\t}\n\t\t}\n\t}\n\treturn num;\n}\n\nvoid nuruColor(int masu[9][9], int c) {\n\tint now = masu[1][1];\n\tbool isGone[9][9];\n\tREP(i, 1, 8) {\n\t\tREP(j, 1, 8) {\n\t\t\tisGone[i][j] = false;\n\t\t}\n\t}\n\tisGone[1][1] = true;\n\tmasu[1][1] = c;\n\tP p = P(1, 1);\n\tque.push(p);\n\twhile(!que.empty()) {\n\t\tp = que.front();\n\t\tque.pop();\n\t\ty = p.first; x = p.second;\n\t\trep(i, 0, 4) {\n\t\t\tint tmpy = y + dy[i];\n\t\t\tint tmpx = x + dx[i];\n\t\t\tif (tmpy < 1 && tmpy > datay && tmpx < 1 && tmpx > datax) {\n\t\t\t\tcontinue;\n\t\t\t} else if (masu[tmpy][tmpx] == now && !isGone[tmpy][tmpx]) {\n\t\t\t\tisGone[tmpy][tmpx] = true;\n\t\t\t\tmasu[tmpy][tmpx] = c;\n\t\t\t\tque.push(make_pair(tmpy, tmpx));\n\t\t\t}\n\t\t}\n\t}\n}\t\n\nint data1[9][9], data2[9][9], data3[9][9], data4[9][9], data5[9][9];\nvoid solve() {\n\twhile(true) {\n\t\tint ans = -1;\n\t\tcin >> datay >> datax >> endC;\n\t\tif (datay == 0 || datax == 0 || endC == 0) return;\n\n\t\tREP(i, 1, datay) {\n\t\t\tREP(j, 1, datax) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i, 1, 6) {\n\t\t\tcopy(data1, data);\n\t\t\t//pData(data1);\n\t\t\tnuruColor(data1, i);\n\t\t\t//pData(data1);\n\t\t\tREP(i2, 1, 6) {\n\t\t\t\tcopy(data2, data1);\n\t\t\t\tnuruColor(data2, i2);\n\t\t\t\t//pData(data2);\n\t\t\t\tREP(i3, 1, 6) {\n\t\t\t\t\tcopy(data3, data2);\n\t\t\t\t\tnuruColor(data3, i3);\n\t\t\t\t\t//pData(data3);\n\t\t\t\t\tREP(i4, 1, 6) {\n\t\t\t\t\t\tcopy(data4, data3);\n\t\t\t\t\t\tnuruColor(data4, i4);\n\t\t\t\t\t\t//pData(data4);\n\n\t\t\t\t\t\tcopy(data5, data4);\n\t\t\t\t\t\tnuruColor(data5, endC);\n\t\t\t\t\t\tint tmp = countColor(data5);\n\t\t\t\t\t\t//if (ans < tmp) pData(data5);\n\t\t\t\t\t\tans = max(ans, tmp);\n\t\t\t\t\t\t//pData(data5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\nvoid test() {\n\trep(i, 0, 2) {\n\t\tdatay = 1;datax = 1;\n\t\tendC = 5;\n\t\tREP(i, 1, datay) {\n\t\t\tREP(j, 1, datax) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\t\tnuruColor(data, 5);\n\t\tpData(data);\n\t\tcout << countColor(data) << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n\t//test();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-14\n\n#define all(v) v.begin(),v.end()\n#define INF\n#define mp\n#define pb\n\n#define fi\n#define se\n\n#define each\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef long long ll;\nint ss[8][8];\nint main(){\n    rep(i,8){\n        rep(j,8){\n            ss[i][j]=0;\n        }\n    }\n\n    while(1){\n        int h,w,c;\n        int ss[8][8];\n        int p[8][8];\n        int cw[8];\n        int c_num;\n        cin >> h >> w >> c_num;\n        if(h==0) break;\n        rep(i,h){\n            rep(j,w){\n                cin >> ss[i][j];\n            }\n        }\n        cw[0] = ss[0][0];\n        cw[5] = c_num;\n        cw[6] = 9;\n        int ma=0;\n        for(cw[1]=1;cw[1]<7;cw[1]++){\n            for(cw[2]=1;cw[2]<7;cw[2]++){\n                for(cw[3]=1;cw[3]<7;cw[3]++){\n                    for(cw[4]=1;cw[4]<7;cw[4]++){\n         \n                            rep(i,h){\n                                rep(j,w){\n                                    p[i][j] = ss[i][j];\n                                }\n                            }\n                            const int dx[] = {1,0,-1,0};\n                            const int dy[] = {0,1,0,-1};\n                            int cnt;\n\n                            //??????????????????????????????\n                            rep(luc,6){\n                                queue <int> qx;\n                                queue <int> qy;\n                                qx.push(0);\n                                qy.push(0);\n                                cnt = 0;\n                                while(!qx.empty()){\n                                    p[qy.front()][qx.front()]=0;\n\n                                    rep(i,4){\n                                        int nx = qx.front() + dx[i];\n                                        int ny = qy.front() + dy[i];\n                                        if(nx >= 0 && nx < w &&\n                                           ny >= 0 && ny < h &&\n                                           p[ny][nx] == cw[luc]){\n                                            qx.push(nx);\n                                            qy.push(ny);\n                                        }\n                                    }\n                                    // cout << qx.front() << \" \" << qy.front() << endl;\n                                    qx.pop();qy.pop();\n                                }\n                                rep(y,h){\n                                \trep(x,w){\n\n                                \t\tif(p[y][x]==0){\n                                \t\t\tp[y][x] = cw[luc+1] ;\n                                \t\t\tcnt++;\n                                \t\t}\n\n                                \t}\n                                }\n                                ma = max(ma,cnt);\n                            }\n                            \n                            // if(cnt>7){\n                            // rep(y,h){\n                            //     rep(x,w){\n                            //         cout << p[y][x] << \" \";\n                            //     }\n                            //     cout << endl;\n                            // }\n                            // cout << \"-----------\"<<endl;\n                            // }\n\n                    }\n                }\n            }\n        }\n        cout << ma << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid printMap(int** map){\n\tfor(int y=0;y<8;y++){\n\t\tfor(int x=0;x<8;x++) printf(\"%4d\",map[y][x]);\n\t\tcout << endl;\n\t}\n\tgetchar();\n}\n\nint countUpPanel(int** map,int x,int y,int color,int w, int h){\n\tint sum=0;\n\tif(!(x>=0 && y>=0 && x<w && y<h)) return 0;\n\tif(map[y][x]!=color)return 0;\n\telse{\n\t\tmap[y][x]=0;\n\t\tsum++;\n\t}\n\tsum+=countUpPanel(map,x+1,y,color,w,h);\n\tsum+=countUpPanel(map,x-1,y,color,w,h);\n\tsum+=countUpPanel(map,x,y+1,color,w,h);\n\tsum+=countUpPanel(map,x,y-1,color,w,h);\n\t\n\treturn sum;\n}\n\nvoid exchangePanel(int** map,int x,int y,int color,int c,int w, int h){\n//\tprintf(\"nbb?,%d,%d,%d,%d\\n\",x,y,color,c);\n\tif(!(x>=0 && y>=0 && x<w && y<h)) return ;\n\tif(map[y][x]!=c)return ;\n\tif(map[y][x]==color)return ;\n\telse map[y][x]=color;\n\texchangePanel(map,x+1,y,color,c,w,h);\n\texchangePanel(map,x-1,y,color,c,w,h);\n\texchangePanel(map,x,y+1,color,c,w,h);\n\texchangePanel(map,x,y-1,color,c,w,h);\n\t\n}\n\nint solvePuzzle(int** map,int objectiveColor,int crrentColor,int round,int w,int h){\n\tint res=0;\n\tint resres=0;\n\t\n//\tcout << \"flop:\" << crrentColor << \"round:\" << round << endl;\n//\tprintMap(map);\n\n\n\tif(round>=5){\n\t\tres=0;\n\t\tres=countUpPanel(map,0,0,objectiveColor,w,h);\n/*\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==objectiveColor) res++;\n\t\t\t}\n\t\t}\n\t\tif(res==11){\n\t\t\tprintMap(map);\n\t\t\tgetchar();\n\t\t}*/\n\t\treturn res;\n\t}\n\telse{\n\t\tint **mapTemp = new int*[8];\n\t\tfor(int i=0;i<8;i++) mapTemp[i]=new int[8];\n\t\n\t\tif(round==4){\n\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\tfor(int x=0;x<8;x++) mapTemp[y][x]=map[y][x];\n\t\t\t}\n\t\n\t\t\texchangePanel(map,0,0,objectiveColor,map[0][0],w,h);\n\t\t\tres=solvePuzzle(map,objectiveColor,objectiveColor,round+1,w,h);\n\n\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\tfor(int x=0;x<8;x++) map[y][x]=mapTemp[y][x];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tresres=0;\n\t\t\tres=0;\n\t\t\tfor(int i=1;i<=6;i++){\n\t\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\t\tfor(int x=0;x<8;x++) mapTemp[y][x]=map[y][x];\n\t\t\t\t}\n//\t\t\t\tprintf(\"naa?,%d,%d,%d\\n\",i,map[0][0],objectiveColor);\n\t\t\t\texchangePanel(map,0,0,i,map[0][0],w,h);\n\t\t\t\tresres=solvePuzzle(map,objectiveColor,i,round+1,w,h);\n\t\t\t\tif(resres>=res) res=resres;\n\t\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\t\tfor(int x=0;x<8;x++) map[y][x]=mapTemp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<8;i++) delete [] mapTemp[i];\n\t\tdelete [] mapTemp;\n\n\n\t}\n\t\n\treturn res;\n}\n\nint main(void){\n\tint scale=8;\n\tint h,w,c;\n\tint status;\n\n\tint** map = new int*[8];\n\tfor(int i=0;i<8;i++) map[i]=new int[8];\n\twhile(true){\n\t\tcin >> h;\n\t\tcin >> w;\n\t\tcin >> c;\n\t\tif(h==0) break;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tmap[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tcin >> map[j][i];\n\t\t\t}\n\t\t}\n\n\t\tint res=0;\n\t\t\n\t\tres=solvePuzzle(map,c,0,0,w,h);\n\t\tcout << res << endl;\n\t}\n\n\tfor(int i=0;i<8;i++) delete [] map[i];\n\tdelete [] map;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n2017_02_27_AC\n??????????????????\n????????°??¢??°??§?????????????????°???????????¨????????????????§???????????????????\n????????????????????¨?????§??????????????£??????????????¶???????????£????????????????????????\n??????????????????dfs()?????§paint()????????¶?????????paint()???????????????????????¨???\n????????????????????£??????????????????????????¨??????????????§????????????????????????????????????????????????\n  ??????????????????????§??????????????????????????????????check????????°?????????????????????????????????????????????????????????\n?????¢??°???????????§????????°???(x, y)????????????????????????????????¶??¨??????(i(=y),j(=x))??§??????????????????\n???-> ???????????¨?????§???((y(=i),x(=j)))????????§??????????????????????¬??????????????????????????????????\n????????????\n??????????????¨????????????????????£??¨???????????????????????????????????£????????????\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nstruct S{\n  int A[9][9];\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h, w, c, p[9][9], colcnt, ans;\nbool visit[9][9];\n\nvoid paint(int bfcolor, int x, int y,int color, int tp[9][9]){\n  visit[y][x] = true;\n  bfcolor = tp[y][x];\n  tp[y][x] = color;\n  REP(k,0,4){\n    int posx = x + dx[k];\n    int posy = y + dy[k];\n    if(!CH(posx,0,w) || !CH(posy,0,h)) continue;\n    if(tp[posy][posx] != bfcolor || visit[posy][posx]) continue;\n    paint(bfcolor, posx, posy, color, tp);\n  }\n  return ;\n}\n\nvoid check(int x, int y, int color, struct S s){\n  visit[y][x] = true;\n  colcnt++;\n  REP(k,0,4){\n    int posx = x + dx[k];\n    int posy = y + dy[k];\n    if(!CH(posx,0,w) || !CH(posy,0,h)) continue;\n    if(s.A[posy][posx] != color || visit[posy][posx]) continue;\n    check(posx, posy, color, s);\n  }\n  return ;\n}\n\nvoid dfs(int k, int turn, struct S s){\n\n  //??????\n  int tp[9][9];\n  REP(i,0,h)REP(j,0,w) tp[i][j] = s.A[i][j];  //??????????????§??????????????¨???????????????\n  REP(i,0,h)REP(j,0,w) visit[i][j] = false;\n  paint(s.A[0][0],0,0,k,tp);\n  REP(i,0,h)REP(j,0,w) s.A[i][j] = tp[i][j]; //??????????????????????????????\n\n  //??????????????????????????§???????????????\n  /*\n  REP(i,0,h)REP(j,0,w){\n    colcnt = 0;\n    if(s.A[i][j]==c){\n      REP(ii,0,h)REP(jj,0,w) visit[ii][jj] = false;\n      check(j,i,c,s);\n    }\n    ans = max(ans, colcnt);\n  }\n  if(turn == 5){\n    return;\n  }\n  */\n  if(turn == 5){\n    REP(i,0,h)REP(j,0,w){\n      colcnt = 0;\n      if(s.A[i][j]==c){\n        REP(ii,0,h)REP(jj,0,w) visit[ii][jj] = false;\n        check(j,i,c,s);\n      }\n      ans = max(ans, colcnt);\n    }\n    return;\n  }\n\n\n\n  REP(kk,1,7){ //??????????????????????????????\n    int bcol = s.A[0][0];\n    dfs(kk,turn + 1,s);\n  }\n\n  return;\n}\n\nint main() {\n\nwhile(1){\n    cin>>h>>w>>c;\n    if(h==0 && w==0 && c==0) break;\n    REP(i,0,h)REP(j,0,w) cin>>p[i][j];\n\n    ans = 0;\n    S sc;\n    REP(i,0,h)REP(j,0,w) sc.A[i][j] = p[i][j];\n\n    REP(k,1,7) dfs(k,1,sc);\n\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define ISIN(x, y, w, h) (x >= 0 && x < w && y >= 0 && y < h)\n\n#define f first\n#define s second\n\nusing namespace std;\n\npair<int, int> joint[70];\nint h, w, c;\nint p[8][8];\nbool f[8][8];\n\nconst int dx[4] = { 1,-1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1};\n\nint getInt(){ int r; scanf(\"%d\", &r); return r; }\n\nint solve(int now, int prev, int cnt){\n  int ret = 0;\n\n  //printf(\"solve(%d, %d, %d)\\n\", now, prev, cnt);\n\n  if(now == 6) return cnt;\n\n  for(int col = 1; col <= 6; col++){\n    int cc = cnt;\n    queue<pair<int, int> > q;\n\n    if(now == 5 && col != c) continue;\n    if(now == 0 && col != prev) continue;\n\n    REP(i, cnt) q.push(joint[i]);\n\n    while(q.size()){\n      int x = q.front().s;\n      int y = q.front().f;\n\n      q.pop();\n\n      REP(i, 4){\n\tint xx = x + dx[i];\n\tint yy = y + dy[i];\n\n\tif(ISIN(xx, yy, w, h) && p[yy][xx] == col && !f[yy][xx]){\n\t  f[yy][xx] = true;\n\t  joint[cc].f = yy;\n\t  joint[cc].s = xx;\n\t  q.push(joint[cc++]);\n\t}\n      }\n    }\n\n    ret = max(ret, solve(now + 1, col, cc));\n    \n    for(int i = cnt; i < cc; i++){\n      int x = joint[i].s;\n      int y = joint[i].f;\n      \n      f[y][x] = false;\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    h = getInt();\n    w = getInt();\n    c = getInt();\n\n    if(h + w + c == 0) break;\n\n    REP(i, h) REP(j, w) p[i][j] = getInt();\n    f[0][0] = true;\n\n    printf(\"%d\\n\", solve(0, p[0][0], 1));\n  }\n  return 20;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dx[4]={1,0,0,-1};\nint dy[4]={0,-1,1,0};\n\nint change(int panel[10][10], int y, int x, int c){\n\tint sum=1;\n\tint color=panel[y][x];\n\tpanel[y][x]=c;\n\tfor(int i=0; i<4; i++)\n\t\tif(panel[y+dy[i]][x+dx[i]] == color){\n\t\t\tsum+=change(panel, y+dy[i], x+dx[i], c);\n\t\t}\n\treturn sum;\n}\n\nint solve(int panel[10][10], int depth, int c){\n\tif(depth >= 5) {\n\t\tif(panel[1][1] != c) return 0;\n\t\telse return change(panel, 1, 1, 0);\n\t}\n\tint ans=0;\n\tfor(int i=1; i<=6; i++){\n\t\tint tmp[10][10];\n\t\tif(panel[1][1]==i) continue;\n\t\tfor(int j=0; j<10; j++){\n\t\t\tfor(int k=0; k<10; k++){\n\t\t\t\ttmp[j][k] = panel[j][k];\n\t\t\t}\n\t\t}\n\t\tchange(tmp, 1, 1, i);\n\t\tans = max(ans, solve(tmp, depth+1, c));\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint h, w, c; cin >>h>>w>>c;\n\t\tif(!h && !w) break;\n\n\t\tint panel[10][10]={0};\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin>>panel[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<solve(panel, 0, c)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>pii;\n\nconst int MAX_N = 8;\nconst int dx[] = {1,-1,0,0};\nconst int dy[] = {0,0,1,-1};\n\nint h,w,c,opt;\n\nvoid dfs(int cnt,vector<vector<int> >& fd)\n{\n    if(cnt == 5){\n        int res = 0;\n        int flag[MAX_N][MAX_N];\n        rep(i,h){\n            rep(j,w){\n                flag[i][j] = INF;\n            }\n        }\n        queue<pii> que;\n        res++;\n        que.push(pii(P(0,0),0));\n        flag[0][0] = 0;\n        while(!que.empty()){\n            pii p = que.front();\n            que.pop();\n            int x = (p.first).first;\n            int y = (p.first).second;\n            rep(i,4){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 <= nx && nx < h && 0 <= ny && ny < w){\n                    if(fd[nx][ny] == c && flag[nx][ny] > p.second + 1){\n                        que.push(pii(P(nx,ny),p.second + 1));\n                        flag[nx][ny] = p.second + 1;\n                        res++;\n                    }\n                }\n            }\n        }\n        opt = max(opt,res);\n        return;\n    }\n    for(int i=1;i<=6;i++){\n        if(cnt != 4 || i == c){\n            vector<P> trans;\n            int flag[MAX_N][MAX_N];\n            int bf[MAX_N][MAX_N];\n            queue<pii> que;\n            rep(j,h){\n                rep(k,w){\n                    flag[j][k] = INF;\n                }\n            }\n            que.push(pii(P(0,0),0));\n            flag[0][0] = 0;\n            trans.push_back(P(0,0));\n            while(!que.empty()){\n                pii p = que.front();\n                que.pop();\n                int x = (p.first).first;\n                int y = (p.first).second;\n                rep(j,4){\n                    int nx = x + dx[j];\n                    int ny = y + dy[j];\n                    if(0 <= nx && nx < h && 0 <= ny && ny < w){\n                        if(fd[nx][ny] == fd[0][0] && flag[nx][ny] > p.second + 1){\n                            que.push(pii(P(nx,ny),p.second+1));\n                            flag[nx][ny] = p.second + 1;\n                            trans.push_back(P(nx,ny));\n                        }\n                    }\n                }\n            }\n            rep(j,trans.size()){\n                int x = trans[j].first;\n                int y = trans[j].second;\n                bf[x][y] = fd[x][y];\n                fd[x][y] = i;\n            }\n            dfs(cnt+1,fd);\n            rep(j,trans.size()){\n                int x = trans[j].first;\n                int y = trans[j].second;\n                fd[x][y] = bf[x][y];\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d%d\",&h,&w,&c);\n        if(h == 0 && w == 0 && c == 0){\n            break;\n        }\n        opt = 0;\n        vector<vector<int> > a;\n    \trep(i,h){\n            vector<int> vec;\n            int hoge;\n            rep(j,w){\n                scanf(\"%d\",&hoge);\n                vec.push_back(hoge);\n            }\n            a.push_back(vec);\n    \t}\n        dfs(0,a);\n        printf(\"%d\\n\",opt);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint h, w, c;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint count(vector<vector<int> > p, int c)\n{\n\tvector<vector<bool> > ischecked(h, vector<bool>(w, false));\n\tint result = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(ischecked[i][j] || p[i][j] != c) continue;\n\t\t\tischecked[i][j] = true;\n\t\t\tint cnt = 1;\n\t\t\tqueue<pair<int, int> > qu;\n\t\t\tqu.push(make_pair(i, j));\n\t\t\twhile(!qu.empty()){\n\t\t\t\tint x = (qu.front()).first;\n\t\t\t\tint y = (qu.front()).second;\n\t\t\t\tqu.pop();\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tint nx = x + dx[k];\n\t\t\t\t\tint ny = y + dy[k];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= h || ny >= w || ischecked[nx][ny]) continue;\n\t\t\t\t\tischecked[nx][ny] = true;\n\t\t\t\t\tif(p[nx][ny] == c){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tqu.push(make_pair(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = max(result, cnt);\n\t\t}\n\t}\n\treturn result;\n}\n\nvector<vector<int> > change(vector<vector<int> > p, int c)\n{\n\tint beforec = p[0][0];\n\tvector<vector<int> > newp = p;\n\tnewp[0][0] = c;\n\tqueue<pair<int, int> > qu;\n\tqu.push(make_pair(0, 0));\n\twhile(!qu.empty()){\n\t\tint x = (qu.front()).first;\n\t\tint y = (qu.front()).second;\n\t\tqu.pop();\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tint nx = x + dx[k];\n\t\t\tint ny = y + dy[k];\n\t\t\tif(nx < 0 || ny < 0 || nx >= h || ny >= w || newp[nx][ny] != beforec) continue;\n\t\t\tnewp[nx][ny] = c;\n\t\t\tqu.push(make_pair(nx, ny));\n\t\t}\n\t}\n\treturn newp;\n}\n\nint solve(vector<vector<int> > p, int c, int cnt)\n{\n\tif(cnt == 5) return count(p, c);\n\tint result = 0;\n\tfor(int i = 1; i <= 6; i++){\n\t\tif(p[0][0] == i) continue;\n\t\tvector<vector<int> > np = change(p, i);\n\t\tresult = max(result, solve(np, c, cnt + 1));\n\t}\n\treturn result;\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin >> h >> w >> c;\n\t\tif(h == 0 && w == 0 && c == 0) break;\n\t\tvector<vector<int> > p(h, vector<int>(w));\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> p[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve(p, c, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H,W,C,diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\n\nstruct Info{\n\tint table[8][8],count;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tInfo first;\n\tfirst.count = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&first.table[i][k]);\n\t}\n\n\tqueue<Info> Q;\n\n\tQ.push(first);\n\n\tqueue<Data> D;\n\n\tint maximum = 1,self_color,num,next_row,next_col,new_color;\n\n\tbool tonari_color[7],check[8][8];\n\tInfo work;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().count == 5){\n\n\t\t\tnum = 0;\n\n\t\t\tD.push(Data(0,0));\n\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int k = 0; k < W; k++)check[i][k] = false;\n\t\t\t}\n\n\t\t\tcheck[0][0] = true;\n\n\t\t\twhile(!D.empty()){\n\n\t\t\t\tQ.front().table[D.front().row][D.front().col] = 9;\n\t\t\t\tnum++;\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tnext_row = D.front().row + diff_row[i];\n\t\t\t\t\tnext_col = D.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && Q.front().table[next_row][next_col] == C && check[next_row][next_col] == false){\n\t\t\t\t\t\tcheck[next_row][next_col] = true;\n\t\t\t\t\t\tD.push(Data(next_row,next_col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tD.pop();\n\t\t\t}\n\n\t\t\tmaximum = max(maximum,num);\n\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tQ.front().count++;\n\n\t\t\tif(Q.front().count <= 4){\n\n\t\t\t\tself_color = Q.front().table[0][0];\n\t\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\t\ttonari_color[i] = false;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\t\twork.table[i][k] = Q.front().table[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tD.push(Data(0,0));\n\t\t\t\tcheck[0][0] = true;\n\n\t\t\t\twhile(!D.empty()){\n\t\t\t\t\twork.table[D.front().row][D.front().col] = 9;\n\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tnext_row = D.front().row + diff_row[i];\n\t\t\t\t\t\tnext_col = D.front().col + diff_col[i];\n\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\t\t\t\tif(work.table[next_row][next_col] != self_color && work.table[next_row][next_col] != 9){\n\t\t\t\t\t\t\t\ttonari_color[work.table[next_row][next_col]] = true;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(work.table[next_row][next_col] == self_color){\n\t\t\t\t\t\t\t\t\tD.push(Data(next_row,next_col));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tD.pop();\n\t\t\t\t}\n\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\t\tif(tonari_color[i] == true){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num == 0){\n\t\t\t\t\tmaximum = H*W;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\t\tif(i == self_color || tonari_color[i] == false)continue;\n\n\t\t\t\t\tInfo next;\n\t\t\t\t\tnext.count = Q.front().count;\n\t\t\t\t\tfor(int a = 0; a < H; a++){\n\t\t\t\t\t\tfor(int b = 0; b < W; b++){\n\t\t\t\t\t\t\tnext.table[a][b] = Q.front().table[a][b];\n\t\t\t\t\t\t\tcheck[a][b] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnew_color = i;\n\n\t\t\t\t\tcheck[0][0] = true;\n\n\t\t\t\t\tD.push(Data(0,0));\n\n\t\t\t\t\twhile(!D.empty()){\n\t\t\t\t\t\tnext.table[D.front().row][D.front().col] = new_color;\n\n\t\t\t\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\t\t\t\tnext_row = D.front().row + diff_row[a];\n\t\t\t\t\t\t\tnext_col = D.front().col + diff_col[a];\n\n\t\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && check[next_row][next_col] == false && next.table[next_row][next_col] == self_color){\n\t\t\t\t\t\t\t\tcheck[next_row][next_col] = true;\n\t\t\t\t\t\t\t\tD.push(Data(next_row,next_col));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tD.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\n\t\t\t\tQ.pop();\n\n\t\t\t}else{\n\n\t\t\t\tself_color = Q.front().table[0][0];\n\n\t\t\t\tD.push(Data(0,0));\n\n\t\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\t\tfor(int k = 0; k < W; k++)check[i][k] = false;\n\t\t\t\t}\n\n\t\t\t\tcheck[0][0] = true;\n\n\t\t\t\twhile(!D.empty()){\n\t\t\t\t\tQ.front().table[D.front().row][D.front().col] = C;\n\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tnext_row = D.front().row + diff_row[i];\n\t\t\t\t\t\tnext_col = D.front().col + diff_col[i];\n\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && check[next_row][next_col] == false && Q.front().table[next_row][next_col] == self_color){\n\t\t\t\t\t\t\tcheck[next_row][next_col] = true;\n\t\t\t\t\t\t\tD.push(Data(next_row,next_col));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tD.pop();\n\t\t\t\t}\n\n\t\t\t\tQ.push(Q.front());\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",maximum);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&C);\n\t\tif(H == 0 && W == 0 && C == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w,c;\n\nstruct Panel{ int a[8][8]; };\nstruct Point{ int x,y; };\n\nint count(const Panel &pnl){\n\tint ans=1;\n\tbool visited[8][8]={}; visited[0][0]=true;\n\n\tqueue<Point> qu; qu.push((Point){0,0});\n\twhile(!qu.empty()){\n\t\tPoint p=qu.front(); qu.pop();\n\t\trep(i,4){\n\t\t\tPoint q={p.x+dx[i],p.y+dy[i]};\n\t\t\tif(0<=q.y && q.y<h && 0<=q.x && q.x<w\n\t\t\t&& !visited[q.y][q.x] && pnl.a[q.y][q.x]==c){\n\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\tans++;\n\t\t\t\tqu.push((Point){q.x,q.y});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint dfs(Panel pnl,int depth){\n\tif(depth==5) return count(pnl);\n\n\tint ans=0;\n\tchar prev=pnl.a[0][0];\n\tfor(int cc=1;cc<=6;cc++){\n\t\tif(cc==prev || (depth==3 && cc==c) || (depth==4 && cc!=c)) continue;\n\t\tPanel tmp=pnl;\n\n\t\tpnl.a[0][0]=cc;\n\t\tbool visited[8][8]={}; visited[0][0]=true;\n\t\tqueue<Point> qu; qu.push((Point){0,0});\n\t\twhile(!qu.empty()){\n\t\t\tPoint p=qu.front(); qu.pop();\n\t\t\trep(i,4){\n\t\t\t\tPoint q={p.x+dx[i],p.y+dy[i]};\n\t\t\t\tif(0<=q.y && q.y<h && 0<=q.x && q.x<w\n\t\t\t\t&& !visited[q.y][q.x] && pnl.a[q.y][q.x]==prev){\n\t\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\t\tpnl.a[q.y][q.x]=cc;\n\t\t\t\t\tqu.push((Point){q.x,q.y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=max(ans,dfs(pnl,depth+1));\n\n\t\tpnl=tmp;\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&h,&w,&c),h;){\n\t\tPanel pnl;\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&pnl.a[i][j]);\n\n\t\tprintf(\"%d\\n\",dfs(pnl,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nvoid cdfs(int y,int x,int fromcolor,int tocolor,int &count,vector<vector<int> >&p){\n    //printf(\"  y: %d, x: %d, %d -> %d\\n\", y, x, fromcolor, tocolor);\n\n\n    p[y][x]=tocolor;\n    count++;\n\n    for(int i = 0; i < 4; i++){\n        int nexty = y + dy[i];\n        int nextx = x + dx[i];\n        if(nexty<0||nexty>p.size()-1||nextx<0||nextx>p[0].size()-1)continue;\n        //printf(\"[%d][%d]\\n\", nexty, nextx);\n        if(p[nexty][nextx]==fromcolor)cdfs(nexty,nextx,fromcolor,tocolor,count,p);\n\n    }\n}\n\nint dfs(int depth,int color,vector<vector<int> >p){\n    int ans=0;\n    int h = p.size();\n    int w = p[0].size();\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            //printf(\"[%d][%d] = %d\\n\", i, j, p[i][j]);\n            if(p[i][j]==color) {\n                int count = 0;\n                cdfs(i, j, color, 0, count, p);\n                //printf(\"count : %d\\n\", count);\n                ans=ans<count?count:ans;\n            }\n        }\n    }\n\n    //printf(\"OK?\\n\");\n    if(depth==5)return ans;\n    //printf(\"OK?\\n\");\n\n    for(int i=0;i<h;i++) {\n        for (int j = 0; j < w; j++) {\n            //printf(\"[%d][%d] = %d\\n\", i, j, p[i][j]);\n            if(p[i][j]==0) {\n                int count = 0;\n                cdfs(i, j, 0,color, count, p);\n            }\n        }\n    }\n\n\n    vector<vector<int> > q = p;\n    for(int i=1;i<=6;i++){\n        p = q;\n        //printf(\"depth: %d, i: %d\\n\", depth, i);\n        if(i == p[0][0]){ continue; }\n        //printf(\"GOGO %d -> %d\\n\", p[0][0], i);\n        int count = 0;\n        cdfs(0, 0, p[0][0], i, count, p);\n        //printf(\"GOGO?\\n\");\n        int temp=dfs(depth+1,color,p);\n        ans=ans<temp?temp:ans;\n    }\n    return ans;\n}\n\n\n\n\nint main(void){\n    int h,w,c;\n    vector<vector<int> >p;\n    while(true){\n        cin>>h>>w>>c;\n        if(h==0)break;\n        p=vector<vector<int> >(h,vector<int>(w));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>p[i][j];\n            }\n        }\n        //printf(\"OK\\n\");\n        cout<<dfs(0,c,p)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define ISIN(x, y, w, h) (x >= 0 && x < w && y >= 0 && y < h)\n\n#define f first\n#define s second\n\nusing namespace std;\n\npair<int, int> joint[70];\nint h, w, c;\nint p[8][8];\nbool f[8][8];\n\nconst int dx[4] = { 1,-1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1};\n\nint getInt(){ int r; scanf(\"%d\", &r); return r; }\n\nint solve(int now, int prev, int cnt){\n  int ret = cnt;\n\n  //printf(\"solve(%d, %d, %d)\\n\", now, prev, cnt);\n\n  if(now == 6) return cnt;\n\n  for(int col = 1; col <= 6; col++){\n    int cc = cnt;\n    queue<pair<int, int> > q;\n\n    if(now == 5 && col != c) continue;\n    if(now == 0 && col != prev) continue;\n\n    REP(i, cnt) q.push(joint[i]);\n\n    while(q.size()){\n      int x = q.front().s;\n      int y = q.front().f;\n\n      q.pop();\n\n      REP(i, 4){\n\tint xx = x + dx[i];\n\tint yy = y + dy[i];\n\n\tif(ISIN(xx, yy, w, h) && p[yy][xx] == col && !f[yy][xx]){\n\t  f[yy][xx] = true;\n\t  joint[cc].f = yy;\n\t  joint[cc].s = xx;\n\t  q.push(joint[cc++]);\n\t}\n      }\n    }\n\n    if(now == 0 || cc != cnt){\n      ret = max(ret, solve(now + 1, col, cc));\n      \n      for(int i = cnt; i < cc; i++){\n\tint x = joint[i].s;\n\tint y = joint[i].f;\n\t\n\tf[y][x] = false;\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    h = getInt();\n    w = getInt();\n    c = getInt();\n\n    if(h + w + c == 0) break;\n\n    REP(i, h) REP(j, w) p[i][j] = getInt();\n    f[0][0] = true;\n\n    printf(\"%d\\n\", solve(0, p[0][0], 1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct UnionFind {\n  const int n;\n  V<> t; // root ? -sz : par\n  UnionFind(int n) : n(n), t(n, -1) {}\n  int find(int v) { return t[v] < 0 ? v : t[v] = find(t[v]); }\n  void unite(int u, int v) {\n    if ((u = find(u)) == (v = find(v))) return;\n    if (-t[u] < -t[v]) swap(u, v);\n    t[u] += t[v];\n    t[v] = u;\n  }\n  bool same(int u, int v) { return find(u) == find(v); }\n  int size(int v) { return -t[find(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int h, w, c; cin >> h >> w >> c, --c;\n    if (!h) break;\n    VV<> p(h, V<>(w)); for (auto&& v : p) for (auto&& e : v) cin >> e, --e;\n    int res = 0;\n    V<> v;\n    V<> di{1, 0, -1, 0}, dj{0, 1, 0, -1};\n    auto in = [&](int i, int j) -> bool { return 0 <= i and i < h and 0 <= j and j < w; };\n    auto _ = [&](int i, int j) -> int { return i * w + j; };\n    UnionFind uf(h * w);\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n      if (i + 1 < h and p[i][j] == p[i + 1][j]) uf.unite(_(i, j), _(i + 1, j));\n      if (j + 1 < w and p[i][j] == p[i][j + 1]) uf.unite(_(i, j), _(i, j + 1));\n    }\n    auto dfs = [&](const auto& dfs) -> void {\n      if (v.size() == 5) {\n        if (v.back() != c) return;\n        auto nuf = uf;\n        for (int e : v) {\n          for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) if (!nuf.same(0, _(i, j)) and p[i][j] == e) {\n            for (int d = 0; d < 4; ++d) {\n              int ni = i + di[d], nj = j + dj[d];\n              if (!in(ni, nj)) continue;\n              if (nuf.same(0, _(ni, nj))) {\n                nuf.unite(0, _(i, j));\n                break;\n              }\n            }\n          }\n        }\n        res = max(res, nuf.size(0));\n        return;\n      }\n      for (int i = 0; i < 6; ++i) {\n        v.push_back(i);\n        dfs(dfs);\n        v.pop_back();\n      }\n    };\n    dfs(dfs);\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nbool solve(){\n\n    int h, w, c;\n    input(h, w, c);\n    if(!h)\n        return false;\n\n    vector<vector<int>> p(h, vector<int>(w));\n    input(p);\n\n    for(auto& x : p)\n        for(auto& y : x)\n            --y;\n\n    vector<int> t(1, 1);\n    for(int i = 0; i < 4; ++i)\n        t.emplace_back(t.back() * 6);\n\n    int ans = 0;\n\n    vector<int> dx{1, 0, -1, 0};\n    vector<int> dy{0, 1, 0, -1};\n\n    for(int i = 0; i < t.back(); ++i){\n\n        auto v = p;\n        vector<vector<int>> l;\n        function<int(int,int,int,int)> f = [&](int x, int y, int from, int to){\n            int cnt = 1;\n            for(int d = 0; d < 4; ++d){\n                int xx = x + dx[d];\n                int yy = y + dy[d];\n                if(0 <= xx && xx < h && 0 <= yy && yy < w && (v[xx][yy] == from || v[xx][yy] == to) && !l[xx][yy]){\n                    l[xx][yy] = 1;\n                    if(v[xx][yy] == from){\n                        v[xx][yy] = to;\n                        cnt += f(xx, yy, from, to);\n                    }else\n                        ++cnt;\n                }\n            }\n            return cnt;\n        };\n        function<int(int,int,int)> g = [&](int x, int y, int cc){\n            int cnt = 1;\n            for(int d = 0; d < 4; ++d){\n                int xx = x + dx[d];\n                int yy = y + dy[d];\n                if(0 <= xx && xx < h && 0 <= yy && yy < w && v[xx][yy] == cc &&  !l[xx][yy]){\n                    l[xx][yy] = 1;\n                    cnt += g(xx, yy, cc);\n                }\n            }\n            return cnt;\n        };\n        int i_ = i;\n        for(int j = 0; j < 5; ++j){\n            int va = (j == 4 ? c - 1 : i_ % 6);\n            int fr = v[0][0];\n            l.assign(h, vector<int>(w, 0));\n            v[0][0] = va;\n            l[0][0] = 1;\n            f(0, 0, fr, va);\n            i_ /= 6;\n        }\n        l.assign(h, vector<int>(w, 0));\n        l[0][0] = 1;\n        chmax(ans, g(0, 0, c - 1));\n    }\n\n    cout << ans << endl;\n\n    return true;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint ans;\nint H,W,C;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid change(vector<vector<int> > &panels,vector<vector<bool> > &done,int x,int y,int color,int before_color){\n\tif(x<0 || y<0 || x>=W || y>=H) return;\n\tif(done[y][x]) return;\n\tdone[y][x]=true;\n\tif(panels[y][x]!=before_color) return;\n\tpanels[y][x]=color;\n\tfor(int r=0;r<4;r++){\n\t\tchange(panels,done,x+dx[r],y+dy[r],color,before_color);\n\t}\n}\n\nvoid count(vector<vector<int> > &panels,vector<vector<bool> > &done,int x,int y,int &num){\n\tif(x<0 || y<0 || x>=W || y>=H) return;\n\tif(done[y][x]) return;\n\tdone[y][x]=true;\n\tif(panels[y][x]==C) num++;\n\telse return;\n\tfor(int r=0;r<4;r++){\n\t\tcount(panels,done,x+dx[r],y+dy[r],num);\n\t}\n}\n\nvoid check(int time,vector<vector<int> > panels){\n\tif(time==5){\n\t\tint num=0;\n\t\tvector<vector<bool> > done(H,vector<bool>(W,false));\n\t\tcount(panels,done,0,0,num);\n\t\tans=max(ans,num);\n\t\treturn;\n\t}\n\tfor(int color=1;color<=6;color++){\n\t\tif(time==4 && color!=C) continue;\n\t\tvector<vector<bool> > done(H,vector<bool>(W,false));\n\t\tvector<vector<int> > copy=panels;\n\t\tchange(copy,done,0,0,color,copy[0][0]);\n\t\tcheck(time+1,copy);\n\t}\n}\n\nint main()\n{\n\twhile(cin>>H>>W>>C){\n\t\tif(H==0) return 0;\n\t\tvector<vector<int> > panels(H,vector<int>(W));\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tcin>>panels[y][x];\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tcheck(0,panels);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,c,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nvector<int> p(64);\n\nint nu(int x,int y,int cl,int t){\n  int res=1;\n  p[y*w+x]=cl;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||w<=nx||ny<0||h<=ny||p[ny*w+nx]!=t||p[ny*w+nx]==cl)continue;\n    res+=nu(nx,ny,cl,t);\n  }\n  return res;\n}\n\nint dfs(int d){\n  vector<int> tp=p;\n  int res=0;\n  if(d==4){\n    nu(0,0,c,p[0]);\n    return nu(0,0,7,p[0]);\n  }\n  for(int j=1;j<7;j++){\n    nu(0,0,j,p[0]);\n    res=max(res,dfs(d+1)),p=tp;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>h>>w>>c,h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>p[i*w+j];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push\nusing namespace std;\n\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint anss=0;\n\nvoid play(int h, int w, int c,int mas[10][10],int cnt){\n    //cout << \"x\" << endl;\n    //cout << endl;\n    int con[10][10]={0};\n\n    int ans=0;\n\n    con[0][0] = 1;\n\n    queue < pair <int,int> > qu;\n\n    qu.pb(mp(0,0));\n\n    while(qu.size() > 0){\n        int xx = qu.front().xx;\n        int yy = qu.front().yy;\n\n        qu.pop();\n\n        for(int i = 0 ; i < 4 ; i++){\n            int xxx = xx + dx[i];\n            int yyy = yy + dy[i];\n\n            if(xxx >=0 && xxx < h && yyy >=0 && yyy < w){\n                if(mas[xxx][yyy] == mas[xx][yy] && con[xxx][yyy] == 0){\n                    con[xxx][yyy] = 1;\n                    qu.pb(mp(xxx,yyy));\n                }\n            }\n        }\n        //cout << qu.size() << endl;\n    }\n    for(int i = 0 ; i < h ; i++){\n        for(int j= 0 ; j < w ;j++){\n            if(con[i][j] == 1) ans++;\n        }\n    }\n\n    /*\n    for(int i = 0 ; i < h ; i++){\n        for(int j= 0 ; j < w ;j++){\n            cout << con[i][j] << \" \";\n        }\n\n        cout << \" | \";\n        for(int j= 0 ; j < w ;j++){\n            cout << mas[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n    if(cnt == 5){\n        if(mas[0][0] == c){\n            anss = max(anss,ans);\n        }\n        return;\n    }\n\n    int poss[10] = {0};\n\n    for(int i = 0 ; i < h ; i++){\n        for(int j = 0 ; j < w ; j++){\n            if(con[i][j] == 1){\n                for(int k = 0 ; k < 4 ; k++){\n                    int xx = i +dx[k];\n                    int yy = j + dy[k];\n\n                    if(xx >= 0 && xx < h && yy >=0 && yy < w){\n                        if(mas[xx][yy] != mas[i][j]) poss[mas[xx][yy]] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    int m[10][10];\n\n    for(int col = 1 ; col <= 6 ; col++){\n        for(int i = 0 ; i < h ; i++){\n            for(int j = 0 ; j < w ; j++){\n                m[i][j] = mas[i][j];\n            }\n        }\n\n        if(poss[col] == 1){\n            for(int i = 0 ; i < h ; i++){\n                for(int j = 0 ; j < w ; j++){\n                    if(con[i][j] == 1) m[i][j] = col;\n                }\n            }\n\n            int cntt = cnt;\n            cntt++;\n            play(h,w,c,m,cntt);\n        }\n    }\n\n}\nmain(){\n    int h,w,c;\n\n    while(cin >> h >> w >> c,h!=0){\n        int mas[10][10];\n\n        for(int i = 0 ; i < h ; i++){\n            for(int j = 0 ; j < w ; j++){\n                cin >> mas[i][j];\n            }\n        }\n\n        anss = 0;\n        play(h,w,c,mas,0);\n\n        cout << anss << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nint h, w, c;\nint ans;\nmap<pair<int, int>, bool> visited;\n\nvoid dfs(vector<vector<int>> &p, int y, int x, int now, int next)\n{\n    if (visited[{y, x}] == true)\n    {\n        return;\n    }\n    visited[{y, x}] = true;\n    p[y][x] = next;\n    rep(i, 4)\n    {\n        if (p[y + dy[i]][x + dx[i]] == now)\n        {\n            dfs(p, y + dy[i], x + dx[i], now, next);\n        }\n    }\n}\n\nint count(vector<vector<int>> &p, int y, int x, int col)\n{\n    if (visited[{y, x}] == true)\n        return 0;\n    visited[{y, x}] = true;\n\n    int ret = 0;\n    //  cerr << y << \",\" << x << endl;\n    // cerr << p.size() << \",\" << p[0].size() << endl;\n    //cerr << \"start if\" << endl;\n    if (p[y][x] == col)\n    {\n        ret++;\n    }\n    else\n    {\n        return 0;\n    }\n    //  cerr << \"end if\" << endl;\n\n    rep(i, 4)\n    {\n        //   cerr << \"loop\" << i << endl;\n        //cerr << y + dy[i] << \",\" << x + dx[i] << \",\" << c << endl;\n        //cerr << p[y + dy[i]][x + dx[i]] << endl;\n        //  if (y + dy[i] >= 0 && y + dy[i] < p.size() && x + dx[i] >= 0 && x + dx[i] < p[0].size())\n        ret += count(p, y + dy[i], x + dx[i], col);\n\n        //   cerr << \"ok\" << i << endl;\n    }\n\n    return ret;\n}\n\nint dfs2(vector<vector<int>> p, int n)\n{\n    if (n == 4)\n    {\n        visited.clear();\n        dfs(p, 1, 1, p[1][1], c);\n        visited.clear();\n        return count(p, 1, 1, c);\n    }\n    auto back = p;\n    int ret = -1;\n    rep(i, 6)\n    {\n        visited.clear();\n        dfs(p, 1, 1, p[1][1], i + 1);\n        ret = max(ret, dfs2(p, n + 1));\n        p = back;\n    }\n    return ret;\n}\n\nint main()\n{\n    while (true)\n    {\n        ans = -1;\n        cin >> h >> w >> c;\n        if (h == 0 && w == 0 && c == 0)\n            break;\n        vector<vector<int>> p(10, vector<int>(10, -1));\n        rep(i, h)\n            rep(j, w)\n        {\n            int t;\n            cin >> t;\n            p[i + 1][j + 1] = t;\n        }\n        cout << dfs2(p, 0) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\nint ans;\nint h,w,c;\n\nvoid showv(vector<vint> vv){\n\trep(i,vv.size()){\n\t\trep(j,vv[0].size()){\n\t\t\tcout<<vv[i][j];\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n}\n\nint dfs(vector<vint> v,int r){\n\t//showv(v);\n\tif(r==0){\n\t\t//showv(v);\n\t\tqueue<pii> q;\n\t\tq.push(mkp(0,0));\n\t\tint S=0;\n\t\twhile(!q.empty()){\n\t\t\tpii t=q.front();\n\t\t\tq.pop();\n\t\t\tif(v[t.F][t.S]==c){\n\t\t\t\tS++;\n\t\t\t\tv[t.F][t.S]=0;\n\t\t\t\tint vec[4][2]={0,1,1,0,0,-1,-1,0};\n\t\t\t\trep(i,4){\n\t\t\t\t\tint x=t.F+vec[i][0],y=t.S+vec[i][1];\n\t\t\t\t\tif(x>=0&&y>=0&&x<h&&y<w){\n\t\t\t\t\t\tq.push(mkp(x,y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//showv(v);\n\t\tans=max(ans,S);\n\t\t//if(ans==S) showv(v);\n\t}\n\telse{\n\t\tfor(int i=1;i<7;i++){\n\t\t\tvector<vint> tv=v,tt=v;;\n\t\t\tqueue<pii> q;\n\t\t\tq.push(mkp(0,0));\n\t\t\ttt[0][0]=0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii tp = q.front();\n\t\t\t\tq.pop();\n\t\t\t\ttv[tp.F][tp.S]=i;\n\t\t\t\tint vec[4][2]={0,1,1,0,-1,0,0,-1};\n\t\t\t\trep(j,4){\n\t\t\t\t\tint x=tp.F+vec[j][0],y=tp.S+vec[j][1];\n\t\t\t\t\tif(x>=0&&y>=0&&x<h&&y<w){\n\t\t\t\t\t\tif(tv[x][y]==v[0][0]&&tt[x][y]!=0){\n\t\t\t\t\t\t\tq.push(mkp(x,y));\n\t\t\t\t\t\t\ttt[x][y]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(tv,r-1);\n\t\t}\n\t}\n\treturn 0;\n}\n\t\t\t\t\n\n\nint main(){\n\twhile(cin>>h>>w>>c,h||w||c){\n\t\t//cout<<\"hoge\"<<endl;\n\t\tans=0;\n\t\tvector<vint> vv(h);\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t//cout<<a<<endl;\n\t\t\t\tvv[i].PB(a);\n\t\t\t}\n\t\t}\n\t\t//showv(vv);\n\t\tdfs(vv,5);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma gcc optimize(\"Ofast\")\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint h, w, c, ans = 0;\n\nconst int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nint grid[8][8];\n\ntemplate<class T>\nstruct Queue {\n    T qs[64];\n    int head = 0, tail = 0;\n    const inline bool empty() const { return head == tail; }\n    T front() { return qs[head]; }\n    inline void push(T p) { qs[tail++] = p; }\n    inline void pop() { head++; }\n};\n\nvoid dfs(int dep) {\n\tint gridbackup[8][8];\n\tint mask[8][8];\n\n\t/*rep(i, 0, h) {\n\t\trep(j, 0, 5 - dep) printf(\" \");\n\t\trep(j, 0, w) printf(\"%d \", grid[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\trep(i, 0, h) rep(j, 0, w) gridbackup[i][j] = grid[i][j], mask[i][j] = 0;\n\t\n\t// bfs generate mask\n\tmask[0][0] = 1;\n\tQueue<pair<int, int>> q;\n\tq.push({0, 0});\n\twhile (!q.empty()) {\n\t\tint i, j; tie(i, j) = q.front(); q.pop();\n\t\tfor (int d = 0; d < 4; d++) {\n\t\t\tint ni = i + dir[d][0], nj = j + dir[d][1];\n\t\t\tif (ni >= 0 && ni < h && nj >= 0 && nj < w && !mask[ni][nj] && grid[ni][nj] == grid[0][0]) {\n\t\t\t\tmask[ni][nj] = 1;\n\t\t\t\tq.push({ni, nj});\n\t\t\t} \n\t\t}\n\t}\n\n\tif (dep == 0) {\n\t\tint cnt = 0;\n\t\trep(i, 0, h) rep(j, 0, w) if (mask[i][j] == 1 && grid[0][0] == c) cnt++;\n\t\t\n\t\t/*if (cnt > ans) {\n\t\t\trep(i, 0, h) {\n\t\t\t\trep(j, 0, w) printf(\"%d(%d) \", grid[i][j], mask[i][j]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}*/\n\t\tans = max(ans, cnt);\n\t\treturn;\n\t}\n\n\tfor (int cc = 1; cc <= 6; cc++) {\n\t    if (cc == grid[0][0]) continue;\n\t\trep(i, 0, h) rep(j, 0, w) grid[i][j] = mask[i][j] == 1 ? cc : grid[i][j];\n\t\tdfs(dep - 1);\n\n\t\t// restore\n\t\trep(i, 0, h) rep(j, 0, w) grid[i][j] = gridbackup[i][j];\n\t}\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n\tfor (;;) {\n\t\tcin >> h >> w >> c;\n\t\tif (!h && !w && !c) break;\n\n\t\trep(i, 0, h) rep(j, 0, w) cin >> grid[i][j];\n\n        ans = 0;\n        dfs(5);\n\t\tcout << ans << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing P = pair<int, int>;\n\tfor (int h, w, c; cin >> h >> w >> c&&h;) {\n\t\tint ans = 1;\n\t\tstatic int p[10][10];\n\t\trep(i, 0, h)rep(j, 0, w) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t\tauto inrange = [&](int i, int j) { return i >= 0 && i < h && j >= 0 && j < w; };\n\t\tstatic const int di[] = { 1,0,-1,0 };\n\t\tstatic const int dj[] = { 0,1,0,-1 };\n\t\trep(i, 0, 6 * 6 * 6 * 6 * 6) {\n\t\t\tstatic bool f[10][10];\n\t\t\tmemset(f, 0, sizeof(f));\n\t\t\tset<P> st;\n\t\t\tst.emplace(0, 0);\n\t\t\tf[0][0] = true;\n\t\t\tqueue<P> q;\n\t\t\tq.emplace(0, 0);\n\t\t\twhile (q.size()) {\n\t\t\t\tint ci, cj;\n\t\t\t\ttie(ci, cj) = q.front(); q.pop();\n\t\t\t\tint color = p[ci][cj];\n\t\t\t\trep(k, 0, 4) {\n\t\t\t\t\tint ni = ci + di[k], nj = cj + dj[k];\n\t\t\t\t\tif (!inrange(ni, nj))continue;\n\t\t\t\t\tif (p[ni][nj] != p[ci][cj])continue;\n\t\t\t\t\tif (f[ni][nj])continue;\n\t\t\t\t\tq.emplace(ni, nj);\n\t\t\t\t\tst.emplace(ni, nj);\n\t\t\t\t\tf[ni][nj] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tdump(st);\n\t\t\t}\n\t\t\tint ti = i;\n\t\t\trep(j, 0, 5) {\n\t\t\t\tint color = ti % 6 + 1;\n\t\t\t\tif (j == 4)if (color != c) {\n\t\t\t\t\tst.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tti /= 6;\n\n\t\t\t\tqueue<P> q;\n\t\t\t\tfor (auto &e : st)\n\t\t\t\t\tq.emplace(e);\n\t\t\t\twhile (q.size()) {\n\t\t\t\t\tint ci, cj;\n\t\t\t\t\ttie(ci, cj) = q.front(); q.pop();\n\t\t\t\t\trep(k, 0, 4) {\n\t\t\t\t\t\tint ni = ci + di[k], nj = cj + dj[k];\n\t\t\t\t\t\tif (!inrange(ni, nj))continue;\n\t\t\t\t\t\tif (p[ni][nj] != color)continue;\n\t\t\t\t\t\tif (f[ni][nj])continue;\n\t\t\t\t\t\tst.emplace(ni, nj);\n\t\t\t\t\t\tq.emplace(ni, nj);\n\t\t\t\t\t\tf[ni][nj] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchmax(ans, (int)st.size());\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n#include<cstdint>\n//#include<>\nusing namespace std;\n\ntypedef vector< vector<int> > Mat;\ntypedef pair<int,int> pii;\n\ntypedef int64_t i64;typedef int32_t i32;\ntypedef int16_t i16;typedef int8_t i8;\ntypedef uint64_t ui64;typedef uint32_t ui32;\ntypedef uint16_t ui16;typedef uint8_t ui8;\n\ntypedef i32 int__;\n#define rep(i,j) for(int__ i=0;i<j;i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);i++)\n#define repeat_eq(i,j,k) for(int__ i=(j);i<=(k);i++)\n#define all(v) begin(v),end(v)\n\nconst i32 INF=1<<30;//=10E10\n\nint h,w,c;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint count_same(Mat& vv){\n  stack<pii> stk;\n  vector<vector<bool> > used(h,vector<bool>(w,false));\n  used[0][0]=true;\n  stk.push(pii(0,0));\n\n  int ans=0;\n  while(!stk.empty()){\n    int x=stk.top().second;\n    int y=stk.top().first;\n    stk.pop();\n    ans++;\n    rep(i,4){\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if( 0<=ny && ny<h && 0<=nx && nx<w ){\n\tif(vv[ny][nx]==vv[0][0] && !used[ny][nx]){\n\t  stk.push(pii(ny,nx));\n\t}\n\tused[ny][nx]=true;\n      }\n    }\n  }\n  return ans;\n}\n\nvoid change(Mat &vv,int col){\n  stack<pii> stk;\n  vector<vector<bool> > used(h,vector<bool>(w,false));\n  \n  int precol=vv[0][0];\n  vv[0][0]=col;\n  used[0][0]=true;\n  stk.push(pii(0,0));\n  \n  while(!stk.empty()){\n    int x=stk.top().second;\n    int y=stk.top().first;\n    stk.pop();\n    \n    rep(i,4){\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if( 0<=ny && ny<h && 0<=nx && nx<w ){\n\tif(vv[ny][nx]==precol && !used[ny][nx]){\n\t  vv[ny][nx]=col;\n\t  stk.push(pii(ny,nx));\n\t}\n\tused[ny][nx]=true;\n      }\n    }\n  }\n}\n\nint rec(Mat vv,int col,int cnt){\n  if(col>0)change(vv,col);\n\n  int ans=0;\n  if(cnt==4){\n    change(vv,c);\n    ans=count_same(vv);    \n  }\n  else{\n    repeat_eq(i,1,6){\n      if(vv[0][0]!=i){\n\tans=max(ans,rec(vv,i,cnt+1));      \t      \n      }\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  while(true){\n    cin>>h>>w>>c;\n    if(!h && !w && !c)break;\n    Mat vv(h,vector<int>(w));\n    rep(i,h)rep(j,w)cin>>vv[i][j];\n    cout<<rec(vv,-1,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint search(const vector< vector<int> > cur, int target, int depth){\n\tint res = 0;\n\tint h = cur.size(), w = cur[0].size();\n\tfor(int i=1;i<=6;i++){\n\t\tif(depth==5&&i!=target) continue;\n\t\tif(cur[0][0]==i) continue;\n\t\tint col = cur[0][0];\n\t\tvector< vector<int> > nxt = cur;\n\t\tqueue< pair<int,int> > qu; qu.push(make_pair(0,0));\n\t\tint cnt = 0;\n\t\twhile(!qu.empty()){\n\t\t\tpair<int,int> pr = qu.front(); qu.pop();\n\t\t\tint x = pr.first, y = pr.second;\n\t\t\tif(nxt[x][y]!=col) continue;\n\t\t\tnxt[x][y] = i;\n\t\t\tcnt++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif(nx<0||h<=nx||ny<0||w<=ny) continue;\n\t\t\t\tqu.push(make_pair(nx,ny));\n\t\t\t}\n\t\t}\n\t\tif(depth==6) return cnt;\n\t\tres = max(res, search(nxt, target, depth+1));\n\t}\n\treturn res;\n}\n\nint main(){\n\tint h, w, c;\n\twhile(cin >> h >> w >> c, h){\n\t\tvector< vector<int> > vi(h, vector<int>(w,0));\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcin >> vi[i][j];\n\t\tcout << search(vi, c, 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<vector<int> > vvi;\n\nint h, w, color;\nbool checked[10][10];\n\nvoid fill(int x, int y, int f, int t, vvi& panel) {\n\tpanel[y][x] = t;\n\tif( 0<=x-1 && panel[y][x-1]==f ) {\n\t\tfill(x-1, y, f, t, panel);\n\t}\n\tif( x+1<w && panel[y][x+1]==f ) {\n\t\tfill(x+1, y, f, t, panel);\n\t}\n\tif( 0<=y-1 && panel[y-1][x]==f ) {\n\t\tfill(x, y-1, f, t, panel);\n\t}\n\tif( y+1<h && panel[y+1][x]==f ) {\n\t\tfill(x, y+1, f, t, panel);\n\t}\n}\n\nint count(int x, int y, vvi& p) {\n\tint cnt = 1;\n\tchecked[y][x] = true;\n\tif( 0<=x-1 && p[y][x-1]==p[y][x] && !checked[y][x-1] ) {\n\t\tcnt += count(x-1, y, p);\n\t}\n\tif( x+1<w && p[y][x+1]==p[y][x] && !checked[y][x+1] ) {\n\t\tcnt += count(x+1, y, p);\n\t}\n\tif( 0<=y-1 && p[y-1][x]==p[y][x] && !checked[y-1][x] ) {\n\t\tcnt += count(x, y-1, p);\n\t}\n\tif( y+1<h && p[y+1][x]==p[y][x] && !checked[y+1][x] ) {\n\t\tcnt += count(x, y+1, p);\n\t}\n\treturn cnt;\n}\n\nint dfs(int lp, vector< vector<int> >& panel) {\n\tif( lp==0 ) {\n\t\tvvi p = panel;\n\t\tif(color == p[0][0]) return 0;\n\t\tfill(0, 0, p[0][0], color, p);\n\t\tmemset(checked, 0, sizeof(checked));\n\t\treturn count(0, 0, p);\n\t}\n\tint res = 0;\n\tfor(int c=1; c<=6; c++) {\n\t\tif(c == panel[0][0]) continue;\n\t\tvvi p = panel;\n\t\tfill(0, 0, p[0][0], c, p);\n\t\tres = max(res, dfs(lp-1, p));\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile( cin >> h >> w >> color, h||w||color ) {\n\t\tvvi panel(h);\n\t\trep(y, h) {\n\t\t\tpanel[y].resize(w);\n\t\t\trep(x, w) {\n\t\t\t\tcin >> panel[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << dfs(4, panel) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<vector>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair<string,int> P;\nint h,w,c,ans,d[]={0,1,0,-1},cnt;\nbool used[8][8];\nvector<vector<int> > kgym_map;\nvoid kgym_cnt(int x,int y){\n  used[x][y] = true;\n  cnt++;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + d[i] , ny = y + d[3 - i];\n    if(nx < 0 || nx >= h || ny < 0 || ny >= w || used[nx][ny] ) continue;\n    if(kgym_map[nx][ny] == kgym_map[0][0]) kgym_cnt(nx,ny);\n  }\n  return;\n}\nvoid KGYM(int color,int to,int x,int y){\n  kgym_map[x][y] = to;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + d[i] , ny = y + d[3 - i];\n    if(nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n    if(kgym_map[nx][ny] == color) KGYM(color,to,nx,ny);\n  }\n}\nvoid search(vector< vector<int> > tmp , int n){\n  if(n == 5){\n    memset(used,false,sizeof(used));\n    kgym_map = tmp;\n    if(kgym_map[0][0] != c) return;\n    cnt = 0;\n    kgym_cnt(0,0);\n    ans = max( cnt , ans );\n    return;\n  }\n  for(int i = 1 ; i <= 6 ; i++ ){\n    if( i == tmp[0][0] ) continue;\n    kgym_map = tmp;\n    KGYM(tmp[0][0],i,0,0);\n    search(kgym_map,n + 1);\n  }\n}\nint main(){\n  vector< vector<int> > tmp;\n  while(cin >> h >> w >> c && h){\n    tmp.resize(h);\n    for(int i = 0 ; i < h ; i++ ){\n      tmp[i].resize(w);\n      for(int j = 0 ; j < w ; j++ ){\n        cin >> tmp[i][j];\n      }\n    }\n    ans = 0;\n    search(tmp,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n\nint cngPanel(vvi&f, int t){\n\tint p=f[0][0];\n\tqueue<pii> q;\n\tq.emplace(0,0);\n\twhile(!q.empty()){\n\t\tint x=q.front().fs;\n\t\tint y=q.front().sc;\n\t\tq.pop();\n\t\tf[y][x]=-1;\n\t\tvi v={1,0,-1,0,1};\n\t\trep(i,4){\n\t\t\tint nx=x+v[i];\n\t\t\tint ny=y+v[i+1];\n\t\t\tif(min(nx,ny)<0 or nx==f[0].size() or ny==f.size())\n\t\t\t\tcontinue;\n\t\t\tif(f[ny][nx]==p){\n\t\t\t\tf[ny][nx]=-1;\n\t\t\t\tq.emplace(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(auto&&l:f)for(auto&&i:l){\n\t\tif(i==-1){\n\t\t\tret++;\n\t\t\ti=t;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint solve(vvi f, vi r){\n\tfor(auto i:r){\n\t\tcngPanel(f,i);\n\t}\n\treturn cngPanel(f,f[0][0]);\n}\n\n\nint main(){\n\tint h,w,c;\n\twhile(cin>>h>>w>>c, h){\n\t\tint ans=0;\n\t\tvvi f(h,vi(w));\n\t\tfor(auto &&l:f)for(auto &&i:l){\n\t\t\tcin>>i; i--;\n\t\t}\n\t\trep(i,1296){\n\t\t\tans=max(ans,solve(f,{i%6,i/6%6,i/36%6,i/216%6,c-1}));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint h,w,c;\nint in[8][8];\nint ans;\nvoid dfs(int de, int p[8][8]){\n  int np[8][8];\n  rep(k,6){\n    if(de==4 && k!=c) continue;\n    rep(i,8)rep(j,8) np[i][j]=p[i][j];\n    bool vis[8][8]={};\n    queue<PI> q;\n    q.push(mp(0,0));\n    int tans=0;\n    int s=np[0][0];\n    while(!q.empty()){\n      int cx=q.front().F;\n      int cy=q.front().S;\n      q.pop();\n      if(vis[cx][cy]) continue;\n      vis[cx][cy] = true;\n      np[cx][cy]=k;\n      ++tans;\n      rep(i,4){\n        int nx=cx+dx[i];\n        int ny=cy+dy[i];\n        if(min(nx,ny)<0 || nx>=h || ny>=w || s!=np[nx][ny])\n          continue;\n        q.push(mp(nx,ny));\n      }\n    }\n    if(de<4) dfs(de+1,np);\n    else{\n      queue<PI> q;\n      bool vis[8][8]={};      \n      q.push(mp(0,0));\n      int tans=0;\n      while(!q.empty()){\n        int cx=q.front().F;\n        int cy=q.front().S;\n        q.pop();\n        if(vis[cx][cy]) continue;\n        vis[cx][cy] = true;\n        ++tans;\n        rep(i,4){\n          int nx=cx+dx[i];\n          int ny=cy+dy[i];\n          if(min(nx,ny)<0 || nx>=h || ny>=w)\n            continue;\n          if(np[nx][ny]!=np[0][0]) continue;\n          q.push(mp(nx,ny));\n        }\n      }\n      ans=max(ans,tans);\n    }\n  }\n}\n\nvoid solve(){\n  --c;\n  rep(i,h)rep(j,w){\n    cin >> in[i][j];\n    --in[i][j];\n  }\n  ans = 0;\n  dfs(0,in);\n  cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> h >> w >> c && h) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<algorithm>\n#define FOR(i,s,e) for(int i=(s);i<(e);i++)\nusing namespace std;\n\nint h,w,c;\nint ans;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nbool canmove(int x,int y){\n  return (0 <= x && x < w && 0 <= y && y < h);\n}\n\nvoid copy(int from[8][8],int to[8][8]){\n  FOR(i,0,h) FOR(j,0,w) to[i][j]=from[i][j];\n}\n\nint count(int table[8][8]){\n  int cnt=0;\n  int color[8][8]={{0}};\n  queue<pair<int,int> > q;\n  q.push(make_pair(0,0));\n  while(!q.empty()){\n    pair<int,int> pii=q.front();\n    q.pop();\n    if(color[pii.second][pii.first]) continue;\n    color[pii.second][pii.first]=1;\n    cnt++;\n    FOR(i,0,4){\n      if(canmove(pii.first+dx[i],pii.second+dy[i]) && table[0][0]==table[pii.second+dy[i]][pii.first+dx[i]]){\n\tq.push(make_pair(pii.first+dx[i],pii.second+dy[i]));\n      }\n    }\n  }\n  return cnt;\n}\n\nvoid dfs(int table[8][8],int cnt){\n  if(cnt > 5) return;\n  if(cnt == 5 && table[0][0]==c){\n    ans=max(ans,count(table));\n    return;\n  }\n  for(int i=1;i<=6;i++){\n    int t[8][8];\n    int color[8][8]={{0}};\n    copy(table,t);\n    queue<pair<int,int> > q;\n    q.push(make_pair(0,0));\n    while(!q.empty()){\n      pair<int,int> pii=q.front();\n      q.pop();\n      if(color[pii.second][pii.first]) continue;\n      color[pii.second][pii.first]=1;\n      t[pii.second][pii.first]=i;\n      FOR(k,0,4){\n\tif(canmove(pii.first+dx[k],pii.second+dy[k]) && table[0][0]==t[pii.second+dy[k]][pii.first+dx[k]]){\n\t  q.push(make_pair(pii.first+dx[k],pii.second+dy[k]));\n\t}\n      }\n    }\n    dfs(t,cnt+1);\n  }\n}\n\nint main(){\n  while(cin>>h>>w>>c , h+w+c){\n    int table[8][8];\n    FOR(i,0,h) FOR(j,0,w) cin>>table[i][j];\n    ans=0;\n    dfs(table,0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);i++)\nint h, w,c;\nint max_n = 0;\nstruct Area{ int c, f; };\nArea area[8][8] = { 0 };\ntypedef pair <int,int>P;\n\nvoid solve(int cr, int level){\n\n\tqueue<P> que;\n\tbool color[6] = { false };\n\tbool check[8][8] = { false };\n\tque.push(P(0, 0));\n\twhile (!que.empty()){\n\t\tP pos = que.front();\n\t\tque.pop();\n\t\tint y = pos.first;\n\t\tint x = pos.second;\n\t\tarea[y][x].f++;\n\t\tif (y > 0)if (!check[y - 1][x]){\n\t\t\tif (area[y - 1][x].c == cr)que.push(P(y - 1, x));\n\t\t\telse color[area[y - 1][x].c] = true;\n\t\t\tcheck[y - 1][x] = true;\n\t\t}\n\t\tif (x > 0)if (!check[y][x - 1]){\n\t\t\tif (area[y][x - 1].c == cr)que.push(P(y, x - 1));\n\t\t\telse color[area[y][x - 1].c] = true;\n\t\t\tcheck[y][x - 1] = true;\n\t\t}\n\t\tif (y < h - 1)if (!check[y + 1][x]){\n\t\t\tif (area[y + 1][x].c == cr)que.push(P(y + 1, x));\n\t\t\telse color[area[y + 1][x].c] = true;\n\t\t\tcheck[y + 1][x] = true;\n\t\t}\n\t\tif (x < w - 1)if (!check[y][x + 1]){\n\t\t\tif (area[y][x + 1].c == cr)que.push(P(y, x + 1));\n\t\t\telse color[area[y][x + 1].c] = true;\n\t\t\tcheck[y][x + 1] = true;\n\t\t}\n\t}\n\t\n\tif (level<5){\n\t\trep(k, 0, 6)if (color[k]){\n\t\t\trep(i, 0, h)rep(j, 0, w)if (area[i][j].f>0)area[i][j].c = k;\n\t\t\tsolve(k, level + 1);\n\t\t}\n\t}\n\tif(cr==c){\n\t\tint n = 0;\n\t\trep(i, 0, h)rep(j, 0, w)if (area[i][j].f > 0)n++;\n\t\tif (max_n<n)max_n = n;\n\t}\n\trep(i, 0, h)rep(j, 0, w)if (area[i][j].f>0)area[i][j].c = cr, area[i][j].f--;\n\t\t\n\t\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> h >> w >> c;\n\t\tif (h == 0)\n\t\treturn(0);\n\t\tc--;\n\t\tmax_n = 0;\n\t\t//input\n\t\trep(i, 0, h)rep(j, 0, w){\n\t\t\tArea input;\n\t\t\tcin >> input.c;\n\t\t\tinput.c--;\n\t\t\tinput.f = 0;\n\t\t\tarea[i][j] = input;\n\n\t\t}\n\t\tsolve(area[0][0].c, 0);\n\t\tcout << max_n << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\n\n#define For(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define Rep(i,n) For(i,0,n)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF 1000000000\n\nint H, W, C;\nint p[100][8][8];\n\nvoid draw(int x, int y, int c, int pc, int bn){\n\tp[bn][x][y] = c;\n\tFor(dx,-1,2)For(dy,-1,2){\n\t\tif((dx != 0 && dy != 0) || (dx == 0 && dy == 0)) continue;\n\t\tif(x+dx >= 0 && x+dx < W && y+dy >= 0 && y+dy < H && p[bn][x+dx][y+dy] == pc) draw(x+dx,y+dy,c,pc,bn);\n\t}\n}\n\nint count_color(int x, int y, int bn){\n\tif(p[bn][x][y] != C) return 0;\n\telse{\n\t\tint res = 1;\n\t\tp[bn][x][y] = -1;\n\t\tFor(dx,-1,2)For(dy,-1,2){\n\t\t\tif((dx != 0 && dy != 0) || (dx == 0 && dy == 0)) continue;\n\t\t\tif(x+dx >= 0 && x+dx < W && y+dy >= 0 && y+dy < H) res += count_color(x+dx,y+dy,bn);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nvoid change_board(int bn, int c){\n\tdraw(0, 0, c, p[bn][0][0], bn);\n}\n\nint dfs(int t){//?????§????????£????????´?????°\n\tint res = 0;\n\t//printf(\"%d\\n\", t);\n\tif(t == 5){\n\t\tres = count_color(0, 0, t);\n\t}else{\n\t\tif(t == 4){\n\t\t\tRep(i,H)Rep(j,W) p[t+1][j][i] = p[t][j][i];\n\t\t\tif(p[t+1][0][0] != C) change_board(t+1, C);\n\t\t\tres = dfs(t+1);\n\t\t}else{\n\t\t\tRep(i,6){\n\t\t\t\tif(i != p[t][0][0]){\n\t\t\t\t\t//printf(\"t=%d i=%d\\n\", t, i);\n\t\t\t\t\tRep(j,H)Rep(k,W) p[t+1][k][j] = p[t][k][j];\n\t\t\t\t\tchange_board(t+1, i);\n\t\t\t\t\tres = max(res, dfs(t+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d %d\", &H, &W, &C);\n\t\tif(H == 0 && W == 0) break;\n\t\tC--;\n\t\tRep(i,H)Rep(j,W){\n\t\t\tscanf(\"%d\", &p[0][j][i]);\n\t\t\tp[0][j][i]--;\n\t\t}\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h,w,c;\nint dy[4]={-1,1,0,0},dx[4]={0,0,-1,1};\nvector<vector<int>> tile(10,vector<int>(10));\n\nint BFS(vector<vector<int>> &T, int color){\n\tqueue< pair<int,int> > Q;\n\tQ.push({0,0});\n\n\tvector<vector<bool>> visited(10,vector<bool>(10));\n\tvisited[0][0]=1;\n\n\tint cnt=1;\n\twhile(Q.empty()==false){\n\t\tint y=Q.front().first, x=Q.front().second;\n\t\t//cout<<x<<\":\"<<y<<endl;\n\t\tQ.pop();\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nY=y+dy[i], nX=x+dx[i];\n\n\t\t\tif(nX<0 || nX>=w || nY<0 || nY>=h)continue;\n\t\t\telse if(visited[nY][nX])continue;\n\t\t\tvisited[nY][nX]=true;\n\n\t\t\tif(T[nY][nX]==T[0][0]){\n\t\t\t\tcnt++;\n\t\t\t\tT[nY][nX]=color;\n\t\t\t\tQ.push({nY,nX});\n\t\t\t}\n\t\t}\n\t}\n\tT[0][0]=color;\n\t//cout<<endl;\n\treturn cnt;\n}\n\nint Solve(int cnt, vector<vector<int>>T){\n\tvector<vector<int>> tmp(T);\n\tif(cnt==4){\n\t\ttmp=T;\n\t\tBFS(tmp,c);\n\t\tint ret=BFS(tmp,c);\n\n\t\treturn ret;\n\t}\n\n\tint ret=0;\n\tfor(int i=1; i<=6; i++){\n\t\tif(T[0][0]==i)continue;\n\n\t\ttmp=T;\n\t\tBFS(tmp,i);\n\t\tret=max(ret,Solve(cnt+1,tmp));\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>h>>w>>c, h&&w&&c){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>tile[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<Solve(0,tile)<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\n\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table &state, int from, int to) {\n\tif (from==to) return;\n\tvector<pair<int,int>> stack;\n\tstack.emplace_back(1,1);\n\twhile (!stack.empty()) {\n\t\tint x,y; tie(x, y) = stack.back();\n\t\tstack.pop_back();\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == from) {\n\t\t\t\tstack.emplace_back(nx,ny);\n\t\t\t\tstate[ny][nx] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint countColor(Table & state) {\n\tvector<pair<int, int>> stack;\n\tstack.emplace_back(1, 1);\n\tint cnt = 0;\n\twhile (!stack.empty()) {\n\t\tint x,y; tie(x, y) = stack.back();\n\t\tstack.pop_back();\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == g_c) {\n\t\t\t\tstack.emplace_back(nx, ny);\n\t\t\t\tcnt++;\n\t\t\t\tstate[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(state);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w \n\t\tif (h == 0) break;\n\t\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << recursion(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint w,h,tc;\nint dat[10][10];\n\nint gone[10][10];\n\nint dd[5]={1,0,-1,0,1};\n\nvoid df(int y,int x,int fc,int c){\n\tif(gone[y][x])return;\n\tgone[y][x]=1;\n\tdat[y][x]=c;\n\trep(i,4){\n\t\tint ty=y+dd[i],\n\t\t\ttx=x+dd[i+1];\n\t\tif(ty<0 || ty>=h || tx<0 || tx>=w)continue;\n\t\tif((!gone[ty][tx]) && dat[ty][tx]==fc){\n\t\t\tdf(ty,tx,fc,c);\n\t\t}\n\t}\n}\n\n\t\nvoid flp(int c){\n\tmemset(gone,0,sizeof(gone));\n\tdf(0,0,dat[0][0],c);\n}\n\nint dfs(int d){\n\t\n\tint res=0;\n\tint md[10][10];\n\treg(i,1,6){\n\t\tif(d==5){\n\t\t\tif(i!=tc)continue;\n\t\t}\n\t\trep(y,h){\n\t\t\trep(x,w){\n\t\t\t\tmd[y][x]=dat[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tflp(i);\n\t\t\n\t\tif(d==5){\n\t\t\tflp(-2);\n\t\t\tint na=0;\n\t\t\trep(y,h){\n\t\t\t\trep(x,w){\n\t\t\t\t\tif(dat[y][x]==-2)na++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=max(res,na);\n\t\t}\n\t\telse{\n\t\t\tres=max(res,dfs(d+1));\n\t\t}\n\t\t\n\t\trep(y,h){\n\t\t\trep(x,w){\n\t\t\t\tdat[y][x]=md[y][x];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\t\n\tfor(;;){\n\t\tscanf(\"%d%d%d\",&h,&w,&tc);\n\t\tmemset(dat,0,sizeof(dat));\n\t\tif(h<=0)break;\n\t\trep(y,h){\n\t\t\trep(x,w){\n\t\t\t\tscanf(\"%d\",&dat[y][x]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",dfs(1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\n// ??¶???????????????????§???????\nstruct status{\n\tint count, to;\n\tint p[10][10];\n\tstatus(int c=0, int t=0, status *old=NULL){\t//???????????????????????§??¨???????????????????????§???????????????????????????\n\t\tif( old ) *this = *old;\t\t// ??¨?????????(memcpy()???????\\???§?????????????°???????)\n\t\telse fill(p[0], p[0]+10*10, 0);\t//?????????????????????????????????????????????????????§\n\t\tcount = c;\n\t\tto = t;\n\t}\n};\n\nint main(){\n\tint h, w, c;\n\twhile(cin>>h>>w>>c, h|w|c){\n\t\t// ???????????§?????°??????????????¨??????????????°???????????§??????\n\t\tstack<status> st;\n\t\tint ans = 0;\n\t\t\n\t\t// ??????????????????\n\t\tstatus in;\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> in.p[i][j];\n\t\t\t}\n\t\t}\n\t\tin.to = in.p[1][1];\n\t\tin.p[1][1] = 8;\n\t\t\n\t\t// ??±???????????¢?´¢\n\t\tst.push( in );\n\t\twhile( !st.empty() ){\n\t\t\tstatus s = st.top(); st.pop();\n\t\t\t// s.to??????????????´\n\t\t\tvector< P > check;\t//stack??§???????????£??????ans?????°???????????????????????????vector????????´\n\t\t\tfor(int i=1; i<=h; i++){\t// (1,1)??¨?????????8?????¨????????¢???\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif( s.p[i][j] == 8 )\n\t\t\t\t\t\tcheck.push_back( make_pair(i, j) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( int i=0; i<check.size(); i++ ){\t// ??£??\\??¨???????????????\n\t\t\t\tint y = check[i].first, x = check[i].second;\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tif( s.p[ y+vy[k] ][ x+vx[k] ] == s.to ){\n\t\t\t\t\t\ts.p[ y+vy[k] ][ x+vx[k] ] = 8;\n\t\t\t\t\t\tcheck.push_back( make_pair( y+vy[k], x+vx[k] ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ?¬?????????????????????????\n\t\t\tif( s.count == 5 ){\t\t// ?????????\n\t\t\t\tans = max( ans, (int)check.size() );\t//?????§???????????´??°\n\t\t\t}else if( s.count == 4 ){\n\t\t\t\tst.push( status(s.count+1, c, &s) );\n\t\t\t}else{\n\t\t\t\tfor(int i=1; i<=6; i++){\n\t\t\t\t\tif( i != s.to ){\n\t\t\t\t\t\tst.push( status(s.count+1, i, &s) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ??????\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 8;\nbool vis[N][N];\nconst int dx[]={0,0,1,-1};\nconst int dy[]={1,-1,0,0};\nint ans;\n\nvoid countup(int r,int c,int y,int x,int &cnt,int tar,\n             int m[N][N]){\n  if (vis[y][x])return;\n  vis[y][x]=true;\n  cnt++;\n  rep(i,4){\n    int nex=x+dx[i],ney=y+dy[i];\n    if (nex == -1 || nex == c || ney == -1 || ney == r ||\n        m[ney][nex] != tar)continue;\n    countup(r,c,ney,nex,cnt,tar,m);\n  }\n}\n\nvoid coloring(int r,int c,int y,int x,int tar,int prev,int m[N][N]){\n  if (vis[y][x])return;\n  vis[y][x]=true;\n  rep(i,4){\n    int nex=x+dx[i],ney=y+dy[i];\n    if (nex == -1 || nex == c || ney == -1 || ney == r)continue;\n    if (m[ney][nex] != prev)continue;\n    m[ney][nex]=tar;\n    coloring(r,c,ney,nex,tar,prev,m);\n  }\n}\n\n\nvoid search(int r,int c,int now,int tar,int m[N][N]){\n  if (now == 5){\n    //cout << m[0][0] <<\" \" << tar << endl;\n    if (m[0][0] != tar)return;\n    /*\n    rep(i,r){\n      rep(j,c){\n        cout << m[i][j]<<\" \";\n      }\n    }\n    cout << endl;\n    */\n    int cnt=0;\n    rep(ii,r)rep(jj,c)vis[ii][jj]=false;\n    countup(r,c,0,0,cnt,tar,m);\n    ans=max(ans,cnt);\n    return;\n  }\n  REP(i,1,7){\n    int tmp[N][N];\n    rep(ii,r)rep(jj,c)tmp[ii][jj]=m[ii][jj];\n    rep(ii,r)rep(jj,c)vis[ii][jj]=false;\n    tmp[0][0]=i;\n    coloring(r,c,0,0,i,m[0][0],tmp);\n    search(r,c,now+1,tar,tmp);\n  }\n}\n\nmain(){\n  int r,c,tar;\n  while(cin>>r>>c>> tar && r){\n    int in[8][8];\n    rep(i,r){\n      rep(j,c){\n        cin>>in[i][j];\n      }\n    }\n    ans=0;\n    search(r,c,0,tar,in);\n    cout << ans << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF 1000000010\n#define EPS 1e-9\n#define F first\n#define S second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\ntypedef pair<int,int> PII;\ntypedef pair<int,string> PIS;\ntypedef pair<string,int> PSI;\n\nint h,w,c;\nint mp[8][8];\nint bmp[8][8];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint bfs(deque<int> x){\n  int ans=0;\n  rep(i,h){\n    rep(j,w){\n      bmp[i][j]=mp[i][j];\n    }\n  }\n  //cout<<'a'<<endl;\n  int st;\n  queue<PII> bfs;\n  while(!x.empty() ){\n    int nex=x.front();\n    x.pop_front();\n    if(nex==bmp[0][0]) continue;\n    bfs.push(make_pair(0,0));\n    st=bmp[0][0];\n    bmp[0][0]=nex;\n    while(!bfs.empty() ){\n      \n      PII p=bfs.front();\n      bfs.pop();\n      rep(i,4){\n\tint X=p.F+dx[i],Y=p.S+dy[i];\n\tif(X>=0 && X<h && Y>=0 && Y<w){\n \t  if(bmp[X][Y]==st){\n \t    bfs.push(make_pair(X,Y));\n \t    bmp[X][Y]=nex;\n \t  }\n \t}\n      }\n    }\n    //cout<<'a'<<endl;\n   //    rep(i,h){\n   //      rep(j,w){\n   //      cout<<bmp[i][j]<<\" \";\n   //      }\n   //     cout<<endl;\n   //     }\n   //     cout<<endl;\n    }\n   st=bmp[0][0];\n   ans=1;\n   bfs.push(make_pair(0,0));\n   bmp[0][0]=INF;\n   while(!bfs.empty() ){\n     PII p=bfs.front();\n     bfs.pop();\n     rep(i,4){\n       int X=p.F+dx[i],Y=p.S+dy[i];\n       if(X>=0 && X<h && Y>=0 && Y<w){\n \tif(bmp[X][Y]==st){\n \t  bfs.push(make_pair(X,Y));\n \t  bmp[X][Y]=INF;\n \t  ans++;\n \t}\n       }\n     }\n   }\n   return ans;\n  \n }\n int solve(int cnt,deque<int> v){\n   int num=0;\n   if(cnt==4){\n     v.push_back(c);\n     num=max(num,solve(cnt+1,v));\n     return num;\n   }\n   if(cnt==5){\n     rep(i,5){\n       // cout<<v[i]<<\" \";\n     }\n     // cout<<endl;\n     num=bfs(v);\n     return num;\n   }else{\n     rep(i,6){\n      \n \tv.push_back(i+1);\n \tnum=max(num,solve(cnt+1,v));\n \tv.pop_back();\n       \n     }\n     return num;\n   }\n }\n\n\n\n\n signed main(){\n   cin.tie(0);\t\n   //ios::sync_with_stdio(false);\n   while(1){\n     cin>>h>>w>>c;\n     if(h==0) break;\n     rep(i,h){\n       rep(j,w){\n \tcin>>mp[i][j];\n       }\n     }\n     //ans=0;\n     deque<int> v={};\n     cout<<solve(0,v)<<endl;\n     \n     // cout<<bfs({2,5,4,6,1})<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nint n,m,c;\nbool vis[11][11];\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\nint ans;\n\nvoid change(int x, int y, int cur, int to, vector< vector<int> > &B) {\n\tB[x][y]=to;\n\tvis[x][y]=1;\n\tfor(int i=0;i<4;++i) {\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx<0||nx>=n||ny<0||ny>=m) continue;\n\t\tif(vis[nx][ny]) continue;\n\t\tif(B[nx][ny]==cur) change(nx,ny,cur,to,B);\n\t}\n}\n\nint get(int x, int y, int cc, vector< vector<int> > &B) {\n\tvis[x][y]=1;\n\tint ret=1;\n\tfor(int i=0;i<4;++i) {\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx<0||nx>=n||ny<0||ny>=m) continue;\n\t\tif(vis[nx][ny]) continue;\n\t\tif(B[nx][ny]==cc)\n\t\t\tret+=get(nx,ny,cc,B);\n\t} return ret;\n}\n\nvoid backtr(int cnt, vector< vector<int> > &B) {\n\tif(cnt==5) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tans=max(ans,get(0,0,c,B));\n\t}\n\telse {\n\t\tfor(int i=1;i<=6;++i) {\n\t\t\tvector< vector<int> > nB=B;\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tchange(0,0,B[0][0],i,nB);\n\t\t\tbacktr(cnt+1,nB);\n\t\t}\n\t}\n}\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\twhile(scanf(\"%d%d%d\",&n,&m,&c),n) {\n\t\tvector< vector<int> > B(n,vector<int>(m));\n\t\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j)\n\t\t\tscanf(\"%d\",&B[i][j]);\n\t\tans=0,backtr(0,B);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint e(int a[][10],int d[][10],int x,int y,int c){\n  if(a[x][y]==c&&d[x][y]==0){\n    d[x][y]=1;\n    return 1+e(a,d,x-1,y,c)+e(a,d,x,y-1,c)+e(a,d,x+1,y,c)+e(a,d,x,y+1,c);\n  }else\n    return 0;\n}\nvoid g(int a[][10],int x,int y,int c,int d){\n  if(a[x][y]==d){\n    a[x][y]=c;\n    g(a,x-1,y,c,d);\n    g(a,x,y-1,c,d);\n    g(a,x+1,y,c,d);\n    g(a,x,y+1,c,d);\n  }\n  return;\n}\nint f(int a[][10],int c,int p){\n  int i;\n  int b[10][10],d[10][10];\n  int mx=0;\n  if(0){\n  }else if(p<3){\n    for(i=1;i<7;i++){\n      if(i!=a[1][1]){\n\tmemcpy(b,a,sizeof(b));\n\tg(b,1,1,i,a[1][1]);\n\tint t;\n\tt=f(b,c,p+1);\n\tif(mx<t)\n\t  mx=t;\n      }\n    }\n  }else if(p==3){\n    for(i=1;i<7;i++){\n      if(i!=a[1][1]&&i!=c){\n\tmemcpy(b,a,sizeof(b));\n\tg(b,1,1,i,a[1][1]);\n\tint t;\n\tt=f(b,c,p+1);\n\tif(mx<t)\n\t  mx=t;\n      }\n    }\n  }else if(p==4){\n    memcpy(b,a,sizeof(b));\n    g(b,1,1,c,a[1][1]);\n    memset(d,0,sizeof(d));\n    mx=e(b,d,1,1,b[1][1]);\n  }\n  return mx;\n}\nint main(){\n  int i,j;\n  int a[10][10],w,h,c;\n  while(cin>>h>>w>>c&&h+w+c){\n    memset(a,0,sizeof(a));\n    for(i=1;i<h+1;i++)\n      for(j=1;j<w+1;j++)\n\tcin>>a[j][i];\n    cout<<f(a,c,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w, c;\nvector<vector<int>> original_field;\n\nint vx[4] = { 0,1,0,-1 }, vy[4] = { 1,0,-1,0 };\n\nint ans = 0;\nint ans1 = 0;\n\nbool used[8][8];\n\nvoid dfs3(vector<vector<int>> &f) {\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++)used[i][j] = false;\n\t}\n\n\tint i = 0, j = 0;\n\n\tif (!used[i][j] && f[i][j] == c) {\n\t\tint cnt = 1;\n\t\tstack<P> s;\n\t\ts.push(P(i, j));\n\t\tused[i][j] = true;\n\t\twhile (s.size()) {\n\t\t\tauto tmp = s.top(); s.pop();\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint nx = tmp.first + vx[k], ny = tmp.second + vy[k];\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w)continue;\n\t\t\t\tif (!used[nx][ny] && f[nx][ny] == c) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\ts.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = max(ans, cnt);\n\t\t\n\t}\n}\n\nvoid dfs2(int c, vector<vector<int>> &f) {\n\tfor (int i = 0; i < 8; i++)for (int j = 0; j < 8; j++)used[i][j] = false;\n\tstack<P> s;\n\tint d = f[0][0];\n\ts.push(P(0, 0));\n\tused[0][0] = true;\n\tf[0][0] = c;\n\n\twhile (s.size()) {\n\t\tauto tmp = s.top(); s.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx, ny;\n\t\t\tnx = tmp.first + vx[i], ny = tmp.second + vy[i];\n\t\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w)continue;\n\t\t\tif ((f[nx][ny] == d) && !used[nx][ny]) {\n\t\t\t\t//これから決めていく色と同じもしくは、今までの色と同じ\n\t\t\t\tf[nx][ny] = c;\n\t\t\t\tused[nx][ny] = true;\n\t\t\t\ts.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs1(int cnt, vector<vector<int>>& filed) {\n\n\tif (cnt == 5) {\n\t\tdfs3(filed);\n\t}\n\telse {\n\t\tfor (int color = 1; color <= 6; color++) {\n\t\t\tif (color == filed[0][0])continue;\n\t\t\tauto cpy_f = filed;\n\t\t\tdfs2(color, cpy_f);\n\t\t\tdfs1(cnt + 1, cpy_f);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> h >> w >> c;\n\t\tif (!(h + w + c))break;\n\t\toriginal_field.resize(h);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\toriginal_field[i].resize(w);\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> original_field[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs1(0, original_field);\n\n\t\tcout << ans << endl;\n\t\toriginal_field.clear();\n\t\tans = 0;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int MAX = 8;\nconst int COLOR = 6;\n\nint h,w,c;\nint M[MAX][MAX];\nint tmp[MAX][MAX];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nvoid input(){\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++) cin >> M[i][j];\n}\n\nbool isInside(int x, int y){return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid dfs(int x, int y, const int& col, const int& col2){\n  if(!isInside(x,y)) return;\n  if(tmp[y][x] != col) return;\n  tmp[y][x] = col2;\n  for(int i = 0; i < 4; i++) dfs(x+dx[i],y+dy[i],col,col2);\n}\n\nvoid count_panel(int x, int y, const int& col, int& cnt){\n  if(!isInside(x,y)) return;\n  if(tmp[y][x] != col) return;\n  tmp[y][x] = -1;\n  cnt++;\n  for(int i = 0; i < 4; i++) count_panel(x+dx[i],y+dy[i],col,cnt);\n}\n\nint check(int c0, int c1, int c2, int c3, int c4, int c5){\n \n  for(int i = 0; i < h; i++) \n    for(int j = 0; j < w; j++) tmp[i][j] = M[i][j];\n\n  int col[] = {c0,c1,c2,c3,c4,c5};\n\n  for(int i = 0; i < 5; i++){\n    if(col[i] == col[i+1]) return 0;\n    dfs(0,0,col[i],col[i+1]);\n  }\n\n  int cnt = 0;\n\n  count_panel(0,0,c5,cnt);\n  return cnt;\n}\n\nvoid solve(){\n  int ans = 0;\n\n  for(int i = 1; i <= COLOR; i++)\n    for(int j = 1; j <= COLOR; j++)\n      for(int k = 1; k <= COLOR; k++)\n\tfor(int l = 1; l <= COLOR; l++)\n\t  ans = max(ans, check(M[0][0],i,j,k,l,c));\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> h >> w >> c && h+w+c){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint h, w, c;\nint p[8][8];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvoid print(int time){\n  printf(\"time %d\\n\", time);\n  REP(y, h){\n    REP(x, w) printf(\"%d \", p[y][x]);\n    cout<<endl;\n  }\n}\nint dfs(int time){\n  if(time != 5){\n    bool equal[8][8] = {};\n    queue<int> qx; queue<int> qy;\n    qx.push(0); qy.push(0);\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      equal[y][x] = true;\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && !equal[ny][nx] && p[y][x] == p[ny][nx]){\n          qx.push(nx); qy.push(ny);\n          equal[ny][nx] = true;\n        }\n      }\n    }\n    int res = 0;\n    int tmp[8][8];\n    REP(y, h)REP(x, w) tmp[y][x] = p[y][x];\n    for(int color = 1; color <= 6; color++){\n      REP(y, h)REP(x, w)if(equal[y][x]){\n        p[y][x] = color;\n      }\n      res = max(res, dfs(time + 1));\n      REP(y, h)REP(x, w) p[y][x] = tmp[y][x];\n    }\n    return res;\n  }\n  else if(time == 5){\n    if(p[0][0] != c) return 0;\n    bool equal[8][8] = {};\n    queue<int> qx; queue<int> qy;\n    qx.push(0); qy.push(0);\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      equal[y][x] = true;\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && !equal[ny][nx] && p[y][x] == p[ny][nx]){\n          qx.push(nx); qy.push(ny);\n          equal[ny][nx] = true;\n        }\n      }\n    }\n    int res = 0;\n    REP(y, h)REP(x, w) res += equal[y][x];\n    return res;\n  }\n}\n\nint main(){\n  while(cin>>h>>w>>c){\n    REP(y, h)REP(x, w) cin>>p[y][x];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint board[8][8];\n// int tempBoard[8][8];\nint h, w, c;\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\nint ans;\n\nclass preBoard {\npublic:\n  int tempBoard[8][8];\n};\npreBoard tBoard[5];\n\nbool is_in(int x, int y) {\n  return x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint countS() {\n  bool vis[8][8];\n  memset(vis, false, sizeof(vis));\n\n  int ret = 1;\n  vis[0][0] = true;\n  stack <int> st;\n  st.push(0);\n  st.push(0);\n  while(!st.empty()) {\n    int x = st.top(); st.pop();\n    int y = st.top(); st.pop();\n\n    for (int i = 0; i < 4; i++) {\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n\n      if (!is_in(nx, ny) ||\n\t  vis[nx][ny] || board[nx][ny] != c) continue;\n      vis[nx][ny] = true;\n      st.push(ny);\n      st.push(nx);\n      ret++;\n    }\n  }\n\n  return ret;\n}\n\n// 左上角のパネルを色ncに変える\nvoid changeC(int nc) {\n  bool vis[8][8];\n  memset(vis, false, sizeof(vis));\n\n  int pc = board[0][0];\n  board[0][0] = nc;\n  vis[0][0] = true;\n  stack <int> st;\n  st.push(0);\n  st.push(0);\n  while(!st.empty()) {\n    int x = st.top(); st.pop();\n    int y = st.top(); st.pop();\n\n    for (int i = 0; i < 4; i++) {\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n\n      if (!is_in(nx, ny) ||\n\t  board[nx][ny] != pc ||\n\t  vis[nx][ny]) {\n\tcontinue;\n      }\n      vis[nx][ny] = true;\n      st.push(ny);\n      st.push(nx);\n      board[nx][ny] = nc;\n    }\n  }\n}\n\nvoid rec(int n) {\n  int pc = board[0][0];\n  if (n == 5) {\n    changeC(c);\n\n    ans = max(ans, countS());\n    memcpy(board, tBoard[n-1].tempBoard, sizeof(board));\n  }else if (n == 4) {\n    for (int i = 1; i <= 6; i++) {\n      if (i == c || i == pc) continue;\n      memcpy(tBoard[n-1].tempBoard, board, sizeof(board));\n      changeC(i);\n      rec(n+1);\n      memcpy(board, tBoard[n-1].tempBoard, sizeof(board));\n    }\n  }else {\n    for (int i = 1; i <= 6; i++) {\n      if (i == pc) continue;\n      memcpy(tBoard[n-1].tempBoard, board, sizeof(board));\n      changeC(i);\n\n      rec(n+1);\n      memcpy(board, tBoard[n-1].tempBoard, sizeof(board));\n    }\n  } \n}\n\nint main() {\n  while(true) {\n    cin >> h >> w >> c;\n    if (h == 0 && w == 0 && c == 0) break;\n\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n\tcin >> board[j][i];\n      }\n    }\n\n    // changeC(1);\n    // changeC(2);\n    // changeC(3);\n    // changeC(4);\n    // changeC(6);\n    // for (int i = 0; i < h; i++) {\n    //   for (int j = 0; j < w; j++) {\n    // \tstd::cout << board[j][i] << \" \";\n    //   }\n    //   std::cout << \"\" << std::endl;\n    // }\n    // std::cout << countS() << std::endl;\n    // int resetBoard[8][8];\n    ans = 0;\n    rec(1);\n\n    std::cout << ans << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n\nint h, w, color, pl[9][9];\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nvoid solve() {\n  rep(i,h) rep(j,w) cin>>pl[i][j];\n  \n  int res = 0;\n  rep(a,6) rep(b,6) rep(c,6) rep(d,6) rep(e,6) {\n    // copy\n    int c_pl[9][9];\n    rep(i,h) rep(j,w) c_pl[i][j] = pl[i][j];\n    \n    int cc[5] = {a+1, b+1, c+1, d+1, e+1};\n    rep(z,5){\n      // record before color\n      int rbc = c_pl[0][0];\n      // if another panel will be change\n      bool used[9][9];\n      memset(used, false, sizeof used);\n      vector<P> clist; clist.pb(P(0,0));\n      queue<P> que;\n      que.push(P(0,1)); que.push(P(1,0));\n      while(!que.empty()) {\n        P p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n        if (used[y][x]) continue;\n        used[y][x] = true;\n        if (c_pl[y][x] == rbc) {\n          // list add\n          clist.pb(P(x, y));\n          // search\n          rep(zz,4) {\n            int tx = x + dx[zz], ty = y + dy[zz];\n            if (tx < 0 || ty < 0 || tx >= w || ty >= h) continue;\n            if (used[ty][tx]) continue;\n            if (c_pl[ty][tx] == rbc) que.push(P(tx, ty));\n          }\n        }\n      }\n      // change color\n      rep(zz,clist.size()) {\n        int x = clist[zz].first, y = clist[zz].second;\n        c_pl[y][x] = cc[z];\n      }\n      \n      // count color C\n      if (cc[z] == color) {\n        int t_res = 0;\n        bool used[9][9];\n        memset(used, false, sizeof used);\n        queue<P> que2;\n        que2.push(P(0,0));\n        while (!que2.empty()) {\n          P p = que2.front(); que2.pop();\n          int x = p.first, y = p.second;\n          if (used[y][x]) continue;\n          used[y][x] = true;\n          t_res++;\n          rep(zz,4) {\n            int tx = x + dx[zz], ty = y + dy[zz];\n            if (tx < 0 || ty < 0 || tx >= w || ty >= h) continue;\n            if (used[ty][tx]) continue;\n            if (c_pl[ty][tx] == color) que2.push(P(tx,ty));\n          }\n        }\n        res = max(t_res, res);\n      }\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>h>>w>>color, h||w||color) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef struct a\n{\n\tint x; \n\tint y;\n}coordin;\n\nint h,w,c;\nint res = 0;\nint maze [8][8];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid changeColor(int tmp[8][8],int color)\n{\n\tint originColor = tmp[0][0];\n\tqueue <coordin> q;\n\tcoordin cc;\n\tcc.x = 0; cc.y = 0;\n\n\tq.push(cc);\n\ttmp[0][0] = color;\n\t\n\twhile (!q.empty())\n\t{\n\t\tcc = q.front();\n\t\tq.pop();\n\n\t\tfor (int i=0;i<4;++i)\n\t\t{\n\t\t\tint tmp_x = cc.x + dx[i];\n\t\t\tint tmp_y = cc.y + dy[i];\n\t\t\t\n\t\t\tif (0<= tmp_x && tmp_x < w && 0<= tmp_y && tmp_y < h)\n\t\t\t{\n\t\t\t\tif (tmp[tmp_x][tmp_y] == originColor)\n\t\t\t\t{\t\n\t\t\t\t\tcoordin tmp_cc;\n\t\t\t\t\ttmp_cc.x = tmp_x;\n\t\t\t\t\ttmp_cc.y = tmp_y;\n\t\t\t\t\tif (color != originColor) q.push(tmp_cc);\n\t\t\t\t\ttmp[tmp_x][tmp_y] = color;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n\t\n}\n\nint cnt(int m[8][8], int x, int y)\n{\n    int count=1;\n    int oc = m[x][y];\n    m[x][y] = 0;\n    for(int i=0; i<4; i++)\n    {\n        int tmp_x = x+dx[i];\n        int tmp_y = y+dy[i];\n        if(0<=tmp_x && tmp_x<w && 0<=tmp_y && tmp_y<h)\n        {\n            if(m[tmp_x][tmp_y]==oc) count+=cnt(m, tmp_x, tmp_y);\n        }\n    }\n    return count;\n}\n\nint dfs(int m[8][8],int depth)\n{\n\tif (depth == 4)\n\t{\n\t\tif(m[0][0]!=c) changeColor(m,c);\n\t\treturn cnt(m,0,0);\n\t}\n\t\n\tfor (int i=1;i<=6;++i)\n\t{\n\t\tint tmp_m[8][8];\n\t\tmemcpy(tmp_m,m,sizeof(tmp_m));\n\t\t\n\t\tif (tmp_m[0][0] != i) changeColor(tmp_m,i);\n\t\tres = max(res,dfs(tmp_m,depth+1));\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>h>>w>>c;\n\t\n\twhile (h!=0)\n\t{\n\t\tfor (int i=0;i<h;++i)\n\t\t\tfor (int j=0;j<w;++j)\n\t\t\t\tcin>>maze[j][i];\n\t\t\n\t\tcout<<dfs(maze,0)<<endl;\n\t\tres = 0;\n\t\tcin>>h>>w>>c;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint w,h,c,ans;\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n\nvoid debug(vector< vector<int> >& p){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << p[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid dfs_2(vector< vector<int> >& p , int x , int y , int a ){\n\tp[y][x] = 0;\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\n\t\tif( p[my][mx] == a ){\n\t\t\tdfs_2( p , mx , my , a );\n\t\t}\n\t}\n}\n\nint check(vector<vector<int> >& p){\n\tdfs_2( p , 0 , 0 , p[0][0] );\n\tint result = 0;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( p[y][x] == 0 ) result++;\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid dfs(vector< vector<int> >& p , int x , int y , int a , int b ){\n\tp[y][x] = b;\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\n\t\tif( p[my][mx] == a ){\n\t\t\tdfs( p , mx , my , a , b );\n\t\t}\n\t}\n}\n\nvoid solve(vector< vector<int> >& p, int cnt ){\n\tif( cnt == 6 ){\n\t\tint num = check(p);\n\t\tans = max( ans , num );\n\t\treturn;\n\t}\n\t\n\tfor(int i=1 ; i <= 6 ; i++ ){\n\t\tif( p[0][0] == i ) continue;\n\t\tif( cnt == 5 && i != c ) continue;\n\t\t\n\t\tvector< vector<int> > next = p;\n\t\tdfs( next , 0 , 0 , p[0][0] , i );\n\t\tsolve( next , cnt+1 );\n\t}\n}\n\nint main(){\n\twhile( cin >> h >> w >> c, w || h || c ){\n\t\tvector< vector<int> > p(h);\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tp[y] = vector<int>(w);\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tcin >> p[y][x];\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tsolve( p , 1 );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef struct a\n{\n\tint x; \n\tint y;\n}coordin;\n\nint h,w,c;\nint res = 0;\nint maze [8][8];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid changeColor(int tmp[8][8],int color)\n{\n\tint originColor = tmp[0][0];\n\tqueue <coordin> q;\n\tcoordin cc;\n\tcc.x = 0; cc.y = 0;\n\n\tq.push(cc);\n\ttmp[0][0] = color;\n\t\n\twhile (!q.empty())\n\t{\n\t\tcc = q.front();\n\t\tq.pop();\n\n\t\tfor (int i=0;i<2;++i)\n\t\t{\n\t\t\tint tmp_x = cc.x + dx[i];\n\t\t\tint tmp_y = cc.y + dy[i];\n\t\t\t\n\t\t\tif (0<= tmp_x && tmp_x < w && 0<= tmp_y && tmp_y < h)\n\t\t\t{\n\t\t\t\tif (tmp[tmp_x][tmp_y] == originColor)\n\t\t\t\t{\t\n\t\t\t\t\tcoordin tmp_cc;\n\t\t\t\t\ttmp_cc.x = tmp_x;\n\t\t\t\t\ttmp_cc.y = tmp_y;\n\t\t\t\t\tif (color != originColor) q.push(tmp_cc);\n\t\t\t\t\ttmp[tmp_x][tmp_y] = color;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n\t\n}\n\nint cnt(int m[8][8], int x, int y)\n{\n    int count=1;\n    int oc = m[x][y];\n    m[x][y] = 0;\n    for(int i=0; i<2; i++)\n    {\n        int tmp_x = x+dx[i];\n        int tmp_y = y+dy[i];\n        if(0<=tmp_x && tmp_x<w && 0<=tmp_y && tmp_y<h)\n        {\n            if(m[tmp_x][tmp_y]==oc) count+=cnt(m, tmp_x, tmp_y);\n        }\n    }\n    return count;\n}\n\nint dfs(int m[8][8],int depth)\n{\n\tif (depth == 4)\n\t{\n\t\tif(m[0][0]!=c) changeColor(m,c);\n\t\treturn cnt(m,0,0);\n\t}\n\t\n\tfor (int i=1;i<=6;++i)\n\t{\n\t\tint tmp_m[8][8];\n\t\tmemcpy(tmp_m,m,sizeof(tmp_m));\n\t\t\n\t\tif (tmp_m[0][0] != i) changeColor(tmp_m,i);\n\t\tres = max(res,dfs(tmp_m,depth+1));\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>h>>w>>c;\n\t\n\twhile (h!=0)\n\t{\n\t\tfor (int i=0;i<h;++i)\n\t\t\tfor (int j=0;j<w;++j)\n\t\t\t\tcin>>maze[j][i];\n\t\t\n\t\tcout<<dfs(maze,0)<<endl;\n\t\tres = 0;\n\t\tcin>>h>>w>>c;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\nusing pii = pair<int, int>;\nusing vi=vector<int>;\nusing vvi=vector<vector<int>>;\n\nint h,w,c;\nint mx=0;\nvvi last_cond;\nint dfs(vvi p,int color,int depth){\n\n    int base = p[0][0];\n    queue<pii>q;\n    p[0][0]=color;\n    q.push(pii(0,0));\n    vvi visited(h,vi(w));\n    visited[0][0]=true;\n    int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n    auto inrange=[&](int x,int y){ return 0<=x and x<h and 0<=y and y<w;};\n    while(q.size()){\n        pii v=q.front();\n        q.pop();\n        int x=v.first,y=v.second;\n        rep(k,0,4){\n            int xx=x+dx[k],yy=y+dy[k];\n            if(not inrange(xx,yy) or visited[xx][yy])continue;\n            if(p[xx][yy]==base){\n                p[xx][yy]=color;\n                visited[xx][yy]=1;\n                q.emplace(xx,yy);\n            }\n        }\n    }\n\n    if(depth==4){\n        if(color!=c)return 0;\n        q.emplace(0,0);\n        visited=vvi(h,vi(w));\n        visited[0][0]=1;\n        while(q.size()){\n           pii v=q.front();\n            q.pop();\n            int x=v.first,y=v.second;\n            rep(k,0,4){\n                int xx=x+dx[k],yy=y+dy[k];\n                if(not inrange(xx,yy) or visited[xx][yy])continue;\n                if(p[xx][yy]==c){\n                    visited[xx][yy]=1;\n                    q.emplace(xx,yy);\n                }\n            }\n        }\n        int ret=0;\n        rep(i,0,h){\n            rep(j,0,w)ret+=visited[i][j];\n        }\n        return ret;\n    }\n    else {\n        int ret=0;\n        rep(i,1,6+1){\n            ret=max(ret,dfs(p,i,depth+1));\n        }\n        return ret;\n    }\n}\n\nsigned main() {\n    while(cin>>h>>w>>c, h or w or c){\n        vvi p(h,vi(w));\n        rep(i,0,h){\n            rep(j,0,w){\n                cin>>p[i][j];\n            }\n        }\n        int ans=0;\n        rep(i,1,6+1){\n            ans=max(ans,dfs(p,i,0));\n        }\n        cout<<ans<<endl;\n\n        // rep(i,0,h){\n        //     rep(j,0,w)cout<<last_cond[i][j]<<(j==w-1?'\\n':' ');\n        // }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint n, m, c;\nint p[16][16], f[16][16];\nint a[16], vis[16][16];\n\nvoid draw(int x, int y, int c, int to) {\n    if (vis[x][y]) return ;\n    vis[x][y] = 1;\n    if (f[x][y] != c) return ;\n    f[x][y] = to;\n    rep (d, 4) draw(x+dx[d], y+dy[d], c, to);\n}\n\nint kount(int x, int y, int c) {\n    if (vis[x][y]) return 0;\n    vis[x][y] = 1;\n    if (f[x][y] != c) return 0;\n    int ans = 1;\n    rep (d, 4) ans += kount(x+dx[d], y+dy[d], c);\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d%d\", &n, &m, &c);\n        if (n == 0 && m == 0 && c == 0) return 0;\n        memset(p, -1, sizeof(p));\n        rep (i, n) rep (j, m) scanf(\"%d\", p[i+1]+j+1);\n        n += 2, m += 2;\n        int ans = 0;\n        rep (b, 6*6*6*6) {\n            int t = b;\n            rep (i, 4) { a[i] = t%6+1; t /= 6; }\n            a[4] = c;\n            rep (i, n) rep (j, m) f[i][j] = p[i][j];\n            rep (i, 5) {\n                memset(vis, 0, sizeof(vis));\n                draw(1, 1, f[1][1], a[i]);\n            }\n            memset(vis, 0, sizeof(vis));\n            ans = max(ans, kount(1, 1, f[1][1]));\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    while (true) {\n        int h;\n        int w;\n        int c;\n        scanf(\"%d %d %d\", &h, &w, &c);\n        if (h == 0 && w == 0 && c == 0) {\n            break;\n        }\n\n        vector<vector<int>> cp;\n        cp.resize(h);\n        for (auto i = 0; i < h; ++i) {\n            for (auto j = 0; j < w; ++j) {\n                int pp;\n                scanf(\"%d\", &pp);\n                cp[i].push_back(pp);\n            }\n        }\n        const auto p = move(cp);\n        // ??£??\\????????§?¨??????????\n        auto getAdjacency = [w, h](int i, int j) {\n            vector<pair<int, int>> r;\n            if (i - 1 >= 0) {\n                r.push_back(make_pair(i - 1, j));\n            }\n            if (i + 1 < h) {\n                r.push_back(make_pair(i + 1, j));\n            }\n            if (j - 1 >= 0) {\n                r.push_back(make_pair(i, j - 1));\n            }\n            if (j + 1 < w) {\n                r.push_back(make_pair(i, j + 1));\n            }\n            return r;\n        };\n\n        // ????????????????????????????????§?????????????????????????????°???????????????\n        auto f = [getAdjacency, &p, w, h](const vector<int>& colors) {\n            auto pp = p;\n            for (size_t n = 0; n < colors.size(); ++n) {\n                const auto ccc = colors[n];\n\n                // ??????????????????????????¨????????¢?´¢\n                stack<pair<int, int>> s;\n                s.push(make_pair(0, 0));\n                vector<vector<bool>> v;\n                v.resize(h);\n                for (auto&& r : v) {\n                    r.resize(w);\n                }\n                auto init = pp[0][0];\n                while (!s.empty()) {\n                    auto t = s.top();\n                    s.pop();\n                    // ??°?????§????????????????????????\n                    v[t.first][t.second] = true;\n                    pp[t.first][t.second] = ccc;\n                    auto r = getAdjacency(t.first, t.second);\n                    for (auto&& i : r) {\n                        // ??£??\\???????????????????????????????????¨?????????????????£????????¢?´¢????±?\n                        if (!v[i.first][i.second] &&\n                            init == pp[i.first][i.second]) {\n                            s.push(i);\n                        }\n                    }\n                }\n            }\n\n            // ???????????????????????????????????°??????\n            stack<pair<int, int>> s;\n            s.push(make_pair(0, 0));\n            vector<vector<bool>> v;\n            v.resize(h);\n            for (auto&& r : v) {\n                r.resize(w);\n            }\n            auto count = 0;\n            while (!s.empty()) {\n                auto t = s.top();\n                s.pop();\n                auto r = getAdjacency(t.first, t.second);\n                for (auto&& i : r) {\n                    if (!v[i.first][i.second] &&\n                        pp[i.first][i.second] == pp[0][0]) {\n                        // ??£????????£??????????????????\n                        v[i.first][i.second] = true;\n                        ++count;\n                        s.push(i);\n                    }\n                }\n            }\n            return count == 0 ? 1 : count;\n        };\n\n        vector<int> colors;\n        colors.resize(5);\n        auto max = 0;\n        for (auto a = 1; a <= 6; ++a) {\n            for (auto b = 1; b <= 6; ++b) {\n                for (auto e = 1; e <= 6; ++e) {\n                    for (auto d = 1; d <= 6; ++d) {\n                        colors[0] = a;\n                        colors[1] = b;\n                        colors[2] = e;\n                        colors[3] = d;\n                        colors[4] = c;\n                        auto r = f(colors);\n                        if (r > max) {\n                            max = r;\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", max);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nint c;\nint ans;\n\nvoid dfs(int n, vector<vector<int>> grid){\n    int x = (int)grid.size();\n    int y = (int)grid[0].size();\n    vector<vector<bool>> connect(x, vector<bool>(y, false));\n    queue<P> que;\n    connect[0][0] = true;\n    que.push({0, 0});\n    vector<int> dx = {0, 0, 1, -1};\n    vector<int> dy = {1, -1, 0, 0};\n    while (que.size()){\n        int nx = que.front().first;\n        int ny = que.front().second;\n        que.pop();\n        for (int i = 0; i < 4; i++){\n            if (0 <= nx + dx[i] && nx + dx[i] < x && 0 <= ny + dy[i] && ny + dy[i] < y){\n                if (grid[nx + dx[i]][ny + dy[i]] == grid[0][0] && !connect[nx + dx[i]][ny + dy[i]]){\n                    connect[nx + dx[i]][ny + dy[i]] = true;\n                    que.push({nx + dx[i], ny + dy[i]});\n                }\n            }\n        }\n    }\n    if (n == 4){\n        que.push({0, 0});\n        vector<int> dx = {0, 0, 1, -1};\n        vector<int> dy = {1, -1, 0, 0};\n        vector<vector<bool>> nconnect(x, vector<bool>(y, false));\n        nconnect[0][0] = true;\n        while (que.size()){\n            int nx = que.front().first;\n            int ny = que.front().second;\n            que.pop();\n            for (int i = 0; i < 4; i++){\n                if (0 <= nx + dx[i] && nx + dx[i] < x && 0 <= ny + dy[i] && ny + dy[i] < y){\n                    if ((grid[nx + dx[i]][ny + dy[i]] == c || connect[nx + dx[i]][ny + dy[i]]) && !nconnect[nx + dx[i]][ny + dy[i]]){\n                        nconnect[nx + dx[i]][ny + dy[i]] = true;\n                        que.push({nx + dx[i], ny + dy[i]});\n                    }\n                }\n            }\n        }\n        int tmp = 0;\n        for (int i = 0; i < x; i++){\n            for (int j = 0; j < y; j++){\n                if (nconnect[i][j]) tmp++;\n            }\n        }\n        ans = max(ans, tmp);\n    }\n    else{\n        for (int nc = 1; nc < 7; nc++){\n            vector<vector<int>> ngrid(x, vector<int>(y));\n            vector<vector<bool>> nconnect(x, vector<bool>(y, false));\n            nconnect[0][0] = true;\n            ngrid = grid;\n            que.push({0, 0});\n            vector<int> dx = {0, 0, 1, -1};\n            vector<int> dy = {1, -1, 0, 0};\n            while (que.size()){\n                int nx = que.front().first;\n                int ny = que.front().second;\n                que.pop();\n                for (int i = 0; i < 4; i++){\n                    if (0 <= nx + dx[i] && nx + dx[i] < x && 0 <= ny + dy[i] && ny + dy[i] < y){\n                        if ((ngrid[nx + dx[i]][ny + dy[i]] == nc || connect[nx + dx[i]][ny + dy[i]]) && !nconnect[nx + dx[i]][ny + dy[i]]){\n                            nconnect[nx + dx[i]][ny + dy[i]] = true;\n                            que.push({nx + dx[i], ny + dy[i]});\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < x; i++){\n                for (int j = 0; j < y; j++){\n                    if (nconnect[i][j]) ngrid[i][j] = nc;\n                }\n            }\n            dfs(n+1, ngrid);\n        }\n    }\n}\n\nint main(){\n    while (1){\n        ans = 0;\n        int h, w;\n        cin >> h >> w >> c;\n        if (h == 0 && w == 0 && c == 0) break;\n        vector<vector<int>> grid(h, vector<int>(w));\n        for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) cin >> grid[i][j];\n        dfs(0, grid);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 8;\nconst int dy[4] = { 0,1,0,-1 };\nconst int dx[4] = { 1,0,-1,0 };\n\nint h, w, c;\n\nint solve(vector<vector<int>> grid, int p[])\n{\n\tint ans = 0;\n\n\tfor (int cnt = 0; cnt < 5; cnt++) {\n\t\tqueue<pair<int, int>> q;\n\t\tbool visited[MAX][MAX];\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tvisited[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tint num = grid[0][0];\n\t\tq.push({ 0,0 });\n\t\tvisited[0][0] = true;\n\n\t\twhile (q.empty() == false) {\n\t\t\tpair<int, int> now = q.front();\n\t\t\tq.pop();\n\n\t\t\tgrid[now.first][now.second] = p[cnt];\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ny = now.first + dy[i];\n\t\t\t\tint nx = now.second + dx[i];\n\n\t\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (grid[ny][nx] == num&&visited[ny][nx] == false) {\n\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool visited[MAX][MAX];\n\n\tfor (int i = 0; i < MAX; i++) {\n\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\tvisited[i][j] = false;\n\t\t}\n\t}\n\n\tfor (int y = 0; y < h; y++) {\n\t\tfor (int x = 0; x < w; x++) {\n\t\t\tint sum = 0;\n\t\t\tqueue<pair<int, int>> q;\n\n\t\t\tif (visited[y][x] == false) {\n\t\t\t\tq.push({ y,x });\n\t\t\t\tvisited[y][x] = true;\n\t\t\t}\n\n\t\t\twhile (q.empty() == false) {\n\t\t\t\tpair<int, int> now = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tsum++;\n\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint ny = now.first + dy[i];\n\t\t\t\t\tint nx = now.second + dx[i];\n\n\t\t\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (grid[ny][nx] == c&&visited[ny][nx] == false) {\n\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = max(ans, sum);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> h >> w >> c;\n\n\t\tif (h == 0 && w == 0 && c == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<vector<int>> grid(h, vector<int>(w, -1));\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> grid[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int a = 1; a <= 6; a++) {\n\t\t\tfor (int b = 1; b <= 6; b++) {\n\t\t\t\tfor (int c = 1; c <= 6; c++) {\n\t\t\t\t\tfor (int d = 1; d <= 6; d++) {\n\t\t\t\t\t\tfor (int e = 1; e <= 6; e++) {\n\t\t\t\t\t\t\tint p[5] = { a,b,c,d,e };\n\t\t\t\t\t\t\tans = max(ans, solve(grid, p));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nstruct P {\n    int p[8][8];\n};\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\nint h, w, c;\n\nbool contain(int y, int x) {\n    return y >= 0 && y < h && x >= 0 && x < w;\n}\n\nP change(int col, P curr) {\n    queue<pii> que;\n    que.emplace(0, 0);\n    int used[8][8] = {};\n    used[0][0]++;\n    while (!que.empty()) {\n        int y, x;\n        tie(y, x) = que.front();\n        que.pop();\n        for (int i = 0; i < 4; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (contain(ny, nx) && curr.p[ny][nx] == curr.p[y][x] && !used[ny][nx]) {\n                que.emplace(ny, nx);\n                used[ny][nx]++;\n            }\n        }\n    }\n    P res = curr;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (used[i][j]) {\n                res.p[i][j] = col;\n            }\n        }\n    }\n    return res;\n}\n\nint solve(int lev, P curr) {\n    if (lev == 4) {\n        curr = change(c, curr);\n        queue<pii> que;\n        que.emplace(0, 0);\n        int used[8][8] = {};\n        used[0][0]++;\n        while (!que.empty()) {\n            int y, x;\n            tie(y, x) = que.front();\n            que.pop();\n            for (int i = 0; i < 4; i++) {\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if (contain(ny, nx) && curr.p[ny][nx] == curr.p[y][x] && !used[ny][nx]) {\n                    que.emplace(ny, nx);\n                    used[ny][nx]++;\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                res += used[i][j];\n            }\n        }\n        return res;\n    }\n    int res = 0;\n    for (int i = 1; i <= 6; i++) {\n        if (i == curr.p[0][0]) continue;\n        P next = change(i, curr);\n        res = max(res, solve(lev + 1, next));\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> h >> w >> c, h) {\n        int p[8][8];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> p[i][j];\n            }\n        }\n\n        P curr;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                curr.p[i][j] = p[i][j];\n            }\n        }\n        cout << solve(0, curr) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nint panel_loc[8][8];\nint visit[8][8];\nint color[5];\nint maxcolor[5];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint getarea(const vector<vector<int>> panel,int h, int w){\n  int c,c_before,sum=0,tmp;\n  queue<pair<int,int>> que;\n  for(int y=0;y<h;y++){\n    for(int x=0;x<w;x++){\n      panel_loc[y][x] = panel[y][x];\n    }\n  }\n  for(int i=0;i<5;i++){\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n        visit[y][x]=0;\n      }\n    }\n    c = color[i];\n    c_before = panel_loc[0][0];\n    panel_loc[0][0] = c;\n    visit[0][0] = 1;\n    que.push(make_pair(0,0));\n    while (not que.empty()){\n      //cin >> tmp;\n      pair<int,int> pan = que.front();\n      que.pop();\n      for(int j=0;j<4;j++){\n        if (pan.first+dy[j]>=0 && pan.first+dy[j]<h && pan.second+dx[j]>=0 && pan.second+dx[j]<w && panel_loc[pan.first+dy[j]][pan.second+dx[j]]==c_before && !visit[pan.first+dy[j]][pan.second+dx[j]]){\n          panel_loc[pan.first+dy[j]][pan.second+dx[j]] = c;\n          visit[pan.first+dy[j]][pan.second+dx[j]] = 1;\n          que.push(make_pair(pan.first+dy[j],pan.second+dx[j]));\n        }\n      }\n    }\n  }\n  //count\n  for(int y=0;y<h;y++){\n    for(int x=0;x<w;x++){\n      visit[y][x] = 0;\n    }\n  }\n  que.push(make_pair(0,0));\n  visit[0][0] = 1;\n  while(not que.empty()){\n    pair<int,int> pan = que.front();\n    ++sum;\n    que.pop();\n    for(int i=0;i<4;i++){\n      if (pan.first+dy[i]>=0 && pan.first+dy[i]<h && pan.second+dx[i]>=0 && pan.second+dx[i]<w && panel_loc[pan.first+dy[i]][pan.second+dx[i]]==color[4] && !visit[pan.first+dy[i]][pan.second+dx[i]]){\n        que.push(make_pair(pan.first+dy[i],pan.second+dx[i]));\n        visit[pan.first+dy[i]][pan.second+dx[i]]=1;\n      }\n    }\n  }\n  return sum;\n}\n\nint main(){\n  int h,w;\n  while (1){\n    cin >> h >> w >> color[4];\n    --color[4];\n    if (h == 0){\n      break;\n    }\n    vector<vector<int>> panel(h,vector<int>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> panel[i][j];\n        --panel[i][j];\n      }\n    }\n    int maxarea = 0;\n    int tmp;\n    for(int i=0;i<1296;i++){\n      color[0] = i-(i/6)*6;\n      color[1] = ((i-(i/36)*36)-color[0])/6;\n      color[2] = ((i-(i/216)*216)-color[0]-color[1]*6)/36;\n      color[3] = ((i-(i/1296)*1296)-color[0]-color[1]*6-color[2]*36)/216;\n      tmp = getarea(panel,h,w);\n      if (tmp>maxarea){\n        maxarea=tmp;\n        maxcolor[0] = color[0];\n        maxcolor[1] = color[1];\n        maxcolor[2] = color[2];\n        maxcolor[3] = color[3];\n        maxcolor[4] = color[4];\n      }\n    }\n    cout << maxarea << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n\nint H, W, C;\nint field[8][8];\nint dh[] = {0, 0, 1, -1};\nint dw[] = {1, -1, 0, 0};\n\nvoid dfs2(int h, int w, int pc, int nc){\n    field[h][w] = nc;\n    for(int i=0; i<4; i++){\n        int nh = h + dh[i];\n        int nw = w + dw[i];\n        if(0<=nh&&nh<H && 0<=nw&&nw<W && field[nh][nw]==pc && field[nh][nw]!=nc){\n            dfs2(nh, nw, pc, nc);\n        }\n    }\n}\n\n\nint dfs(int deepth, int changes[]){\n    int res;\n    int tfield[8][8];\n    \n    memcpy(tfield, field, sizeof(field));\n    dfs2(0, 0, field[0][0], changes[deepth]);\n    \n    if(deepth < 5){\n        res = dfs(deepth+1, changes);\n    }else{\n        res = 0;\n        for(int h=0; h<H; h++){\n            for(int w=0; w<W; w++){\n                if(field[h][w] == changes[deepth]){\n                    res ++;\n                }\n            }\n        }\n    }\n    memcpy(field, tfield, sizeof(field));\n    \n    return res;\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i1=1; i1<=6; i1++){\n        for(int i2=1; i2<=6; i2++){\n            for(int i3=1; i3<=6; i3++){\n                for(int i4=1; i4<=6; i4++){\n                    int i5 = C;\n                    int chnges[] = {i1, i2, i3, i4, i5};\n                    ans = max(ans, dfs(0, chnges));\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    while(cin >>H>>W>>C, H|W|C){\n        for(int h=0; h<H; h++){\n            for(int w=0; w<W; w++){\n                cin >> field[h][w];\n            }\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep0(i,n) for(i=0;i<(n);i++)\n#define repn(i,m,n) for(int i=(m);i<=(n);i++)\n\n#define PUTLINE cout<<__LINE__<<endl;\n\nint result;\nint h,w,c;\n\nvoid value(int a[10][10]){\n\tint used[10][10]={};\n\tint r;\n\trep(i,h)rep(j,w){\n\t\tif(used[i][j]||a[i][j]!=c)continue;\n\t\tr=0;\n\t\tstack<pint> st;\n\t\tst.push(mp(i,j));\n\t\twhile(!st.empty()){\n\t\t\tpint pos=st.top();\n\t\t\tst.pop();\n\t\t\tif(pos.first<0||h<=pos.first||pos.second<0||w<=pos.second)continue;\n\t\t\tif(used[pos.first][pos.second]||a[pos.first][pos.second]!=c)continue;\n\t\t\tused[pos.first][pos.second]=1;\n\t\t\t++r;\n\t\t\tint xx[]={1,-1,0,0};\n\t\t\tint yy[]={0,0,1,-1};\n\t\t\trep(k,4){\n\t\t\t\tpint next=pos;\n\t\t\t\tnext.first+=xx[k];\n\t\t\t\tnext.second+=yy[k];\n\t\t\t\tst.push(next);\n\t\t\t}\n\t\t}\n\t\tchmax(result,r);\n\t}\n}\n\nvoid solve(int a[10][10],int n){\n\tif(n==0){\n\t\tvalue(a);\n\t\treturn;\n\t}\n\tint color=a[0][0];\n\tint next[10][10];\n\trepn(i,1,6){\n\t\tif(i==color)continue;\n\t\trep(j,h)rep(k,w)next[j][k]=a[j][k];\n\t\tstack<pint> st;\n\t\tst.push(mp(0,0));\n\t\twhile(!st.empty()){\n\t\t\tpint pos=st.top();\n\t\t\tst.pop();\n\t\t\tif(pos.first<0||h<=pos.first||pos.second<0||w<=pos.second)continue;\n\t\t\tif(next[pos.first][pos.second]==color){\n\t\t\t\tnext[pos.first][pos.second]=i;\n\t\t\t\tint xx[]={1,-1,0,0};\n\t\t\t\tint yy[]={0,0,1,-1};\n\t\t\t\trep(k,4){\n\t\t\t\t\tpint next=pos;\n\t\t\t\t\tnext.first+=xx[k];\n\t\t\t\t\tnext.second+=yy[k];\n\t\t\t\t\tst.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(next,n-1);\n\t}\n}\n\nint main() {\n\tint a[10][10];\n\tfor(;;){\n\t\tcin>>h>>w>>c;\n\t\tif(h==0)break;\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>a[i][j];\n\t\t}\n\t\tresult=0;\n\t\tsolve(a,5);\n\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define reps(i,j,k) for(int i=(j); i<(k); i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define fr fs\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint h,w,c;\nint inp[9][9], bd[10][9][9];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nvoid pbd(int n){\n\t\trep(i, h){\n\t\t\trep(j, w) cout << 1+bd[n][i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n}\nint dfs(int n){\n\tint d = bd[n+1][0][0];\n//\tcout << n << endl;\n\tif(n<0){\n\tqueue<pii> q;\n\tq.push(pii(0,0));\n\t\t// count\n//\t\tcout << d << \", \" << c << endl;\n\t\tif(d != c) return 0;\n\t\tint cnt = 0;\n\t\twhile(!q.empty()){\n\t\t\tpii p = q.front();\n\t\t\tq.pop();\n\t\t\tint x = p.sc, y = p.fs;\n\t\t\tif(bd[n+1][y][x] != d) continue;\n\t\t\tcnt ++;\n\t\t\tbd[n+1][y][x] = -1;\n\t\t\trep(i,4){\n\t\t\t\tint cx = x + dx[i], cy = y + dy[i];\n\t\t\t\tif(cx < 0 || cy < 0 || cx >= w || cy >= h) continue;\n\t\t\t\tif(bd[n+1][cy][cx] == d) q.push(pii(cy, cx));\n\t\t\t}\n\t\t}\n//\t\tcout << \"cnt : \" <<cnt << endl;\n\t\treturn cnt;\n\t}\n\tint ans = 0;\n\trep(cur, 6){\n\t\tif(d == cur) continue;\n\tqueue<pii> q;\n\tq.push(pii(0,0));\n\t\tmemcpy(bd[n], bd[n+1], 9*9*sizeof(int));\n//\t\tpbd(n);\n\t\twhile(!q.empty()){\n\t\t\tpii p = q.front();\n\t\t\tq.pop();\n\t\t\tint x=p.sc, y = p.fs;\n\t\t\tif(bd[n][y][x] != d) continue;\n\t\t\tbd[n][y][x] = cur;\n\t\t\trep(i,4){\n\t\t\t\tint cx = x + dx[i], cy = y + dy[i];\n\t\t\t\tif(cx < 0 || cy < 0 || cx >= w || cy >= h) continue;\n\t\t\t\tif(bd[n][cy][cx] == d){\n\t\t\t\t\tq.push(pii(cy, cx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tpbd(n);\n\t\tans = max(ans, dfs(n-1));\n\t}\n\treturn ans;\n\n}\nint main(){\n\twhile(cin >> h >> w >> c, c--){\n\t\trep(i,h)rep(j,w){\n\t\t\tcin >> inp[i][j];\n\t\t\tinp[i][j]--;\n\t\t}\n\t\tmemcpy(bd[5], inp, 9*9*sizeof(int));\n//\t\tpbd(5);\n\t\tint ans = dfs(4);\n\t\tcout << ans <<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n\nint Y,X,obj,cnt;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nvoid dfs2(int y, int x, int now, int next, vector< vector<int> >& state){\n  int i;\n\n  cnt++;\n  state[y][x] = next;\n  REP(i,4){\n    int my = y + dy[i];\n    int mx = x + dx[i];\n    if(0 <= my && my < Y && 0 <= mx && mx < X && state[my][mx] == now) dfs2(my,mx,now,next,state);\n  }\n}\n\nint dfs(int now, int next, int depth, vector< vector<int> > state){\n  int res=0,i;\n\n  cnt = 0;\n  dfs2(0,0,now,next,state);\n\n  if(now == obj && depth == 5) return cnt;\n  if(depth >= 6) return 0;\n  // if(depth == 5) return cnt;\n\n  REP(i,7) if(i != 0 && i != next) res = max(res, dfs(next,i,depth+1,state));\n\n  return res;\n}\n\nint main(){\n  int i,j;\n  vector< vector<int> > board;\n\n  while(1){\n    cin >> Y >> X >> obj;\n    if(X == 0 && Y == 0 && obj == 0) break;\n\n    board.resize(Y);\n    REP(i,Y) board[i].resize(X);\n    REP(i,Y) REP(j,X) cin >> board[i][j];\n\n    int res = 0, now = board[0][0];\n    REP(i,7) if(i != 0 && now != i) res = max(res,dfs(now,i,0,board));\n\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {1, 0, -1, 0};\nvoid change(int b[8][8], bool vis[8][8], int h, int w, int s, int t, int c)\n{\n  for(int i = 0; i < 4; i++){\n    int dx = t+xdir[i], dy = s+ydir[i];\n    if(0 <= dx && dx < w && 0 <= dy && dy < h && vis[dy][dx] && b[s][t] == b[dy][dx]){\n      vis[dy][dx] = false;\n      change(b, vis, h, w, dy, dx, c);\n    }\n  }\n  b[s][t] = c;\n\n  return ;\n}\n\nvoid cp_ary(int p[8][8], int b[8][8], int h, int w, int c)\n{\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++)\n      b[i][j] = p[i][j];\n\n  bool vis[8][8];\n  fill(&vis[0][0], &vis[8][0], true);\n  vis[0][0] = false;\n  change(b, vis, h, w, 0, 0, c);\n\n  return ;\n}\n\nint check(int p[8][8], bool vis[8][8], int h, int w, int s, int t, int c)\n{\n  int cnt = 1;\n\n  for(int i = 0; i < 4; i++){\n    int dx = t+xdir[i], dy = s+ydir[i];\n    if(0 <= dx && dx < w && 0 <= dy && dy < h && vis[dy][dx] && p[dy][dx] == c){\n      vis[dy][dx] = false;\n      cnt += check(p, vis, h, w, dy, dx, c);\n    }\n  }\n\n  return cnt;\n}\n\nint cfunc(int p[8][8], int h, int w, int c)\n{\n  int cnt = 0;\n  bool vis[8][8];\n  fill(&vis[0][0], &vis[8][0], true);\n\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++)\n      if(vis[i][j]){\n\tvis[i][j] = false;\n\tcnt = max(cnt, check(p, vis, h, w, i, j, c));\n      }\n\n  return cnt;\n}\n\nint dfs(int p[8][8], int h, int w, int c, int cnt)\n{\n  if(cnt == 5) return cfunc(p, h, w, c);\n\n  int mx = 0, b[8][8];\n  for(int i = 1; i <= 6; i++){\n    cp_ary(p, b, h, w, i);\n    mx = max(mx, dfs(b, h, w, c, cnt+1));\n  }\n\n  return mx;\n}\n\nint main()\n{\n  int h, w, c, p[8][8];\n\n  while(cin>>h>>w>>c && (h+c+w)){\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tcin >> p[i][j];\n\n    cout << dfs(p, h, w, c, 0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\ntypedef complex<double> P;\ntypedef long long ll;\n\nint h,w,c;\nint field[10][10];\nint maxCnt;\nint ct=0;\nbool passed[10][10];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\n\nvoid rePaint(int x,int y,int oc,int nc){\n  if(field[y][x]==oc&&!passed[y][x]){\n    passed[y][x]=true;\n    field[y][x]=nc;\n    for(int i = 0; i < 4; i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny>=0&&nx>=0&&ny<h&&nx<w\n\t &&!passed[ny][nx]&&field[ny][nx]==oc)\n\trePaint(nx,ny,oc,nc);\n    }\n  }\n}\n\n\nvoid Cnt(int x,int y,int c){\n  if(field[y][x]==c&&!passed[y][x]){\n    passed[y][x]=true;\n    ct++;\n    for(int i = 0; i < 4; i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny>=0&&nx>=0&&ny<h&&nx<w&&!passed[ny][nx]&&field[ny][nx]==c){\n\tCnt(nx,ny,c);\n      }\n    }\n  }\n}\n\nvoid change(int n){\n  if(n==0){\n    // ¶ãÌplÆ¯¶FÉÈéplÌ\n    int t=field[0][0];\n    if(t!=c)return;\n    ct=0;\n    memset(passed,0,sizeof(passed));\n    Cnt(0,0,t);\n    maxCnt=max(ct,maxCnt);\n    return;\n  }\n  for(int i = 1; i <= 6; i++){\n    if(field[0][0]==i)continue;\n    int tmp[10][10];\n    for(int j = 0; j < 10; j++)\n      for(int k = 0; k < 10; k++)\n\ttmp[j][k]=field[j][k];\n    memset(passed,0,sizeof(passed));\n    // ¶ãÆ¯¶FðàÂàÌðiÌFÅhèÖ¦\n    rePaint(0,0,field[0][0],i);\n    // ÄA\n    change(n-1);\n    for(int j = 0; j < 10; j++)\n      for(int k = 0; k < 10; k++)\n\tfield[j][k]=tmp[j][k];\n  }\n}\n\nint main(){\n  while(cin>>h>>w>>c&&!(h==0&&c==0&&w==0)){\n    maxCnt=0;\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tcin>>field[i][j];\n    change(5);\n    cout<<maxCnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nint h, w, c;\n\nint dfs(int x, int y, vector<vector<int>>& used, const vector<vector<int>>& b) {\n\tused[x][y] = 1;\n\tint res = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < h && 0 <= ty && ty < w && used[tx][ty] == 0 && b[tx][ty] == c) {\n\t\t\tres += dfs(tx, ty, used, b);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w >> c, h | w | c) {\n\t\tc--;\n\t\tvector<vector<int>> col(h, vector<int>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> col[i][j]; col[i][j]--;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 6 * 6 * 6 * 6 * 6; i++) {\n\t\t\tint t = i;\n\t\t\tauto b = col;\n\t\t\tfor (int j = 0; j < 5; j++, t /= 6) {\n\t\t\t\tint to = t % 6;\n\t\t\t\tint lu = b[0][0];\n\t\t\t\tif (to == lu) continue;\n\t\t\t\tqueue<pii> q;\n\t\t\t\tq.emplace(0, 0);\n\t\t\t\tb[0][0] = to;\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tauto p = q.front(); q.pop();\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tint tx = p.first + dx[i], ty = p.second + dy[i];\n\t\t\t\t\t\tif (0 <= tx && tx < h && 0 <= ty && ty < w && b[tx][ty] == lu) {\n\t\t\t\t\t\t\tq.emplace(tx, ty);\n\t\t\t\t\t\t\tb[tx][ty] = to;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[0][0] == c) {\n\t\t\t\tvector<vector<int>> used(h, vector<int>(w));\n\t\t\t\tres = max(res, dfs(0, 0, used, b));\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n\nbool pass(const int h, const int w, pair<int,int> &next) {\n\n  if (next.first < 0 || next.first >= h)\n    return false;\n  if (next.second < 0 || next.second >= w)\n    return false;\n\n  return true;\n}\n\nint search(const int h, const int w, const int c, int **p)\n{\n  queue<pair<int,int> > q;\n  pair<int,int> start = make_pair(0,0);\n  q.push(start);\n  int max = 0;\n  \n  int **tmp;\n  tmp = (int **)malloc(sizeof(int*)*h);\n  for (size_t i = 0; i < h; i++)\n    tmp[i] = (int *)malloc(sizeof(int)*w);\n  for (size_t i = 0; i < h; i++)\n    for (size_t j = 0; j < w; j++)\n      tmp[i][j]  = 0;\n  \n  while (!q.empty()) {\n    pair<int,int> cur = q.front(); q.pop();\n    if (!tmp[cur.first][cur.second]) {\n      tmp[cur.first][cur.second] = 1;\n      max++;\n      int a1[] = { -1, 0, 1, 0 };\n      int a2[] = { 0, 1, 0, -1 };\n      for (size_t i = 0; i < 4; i++) {\n\tpair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\tif (pass(h,w,next))\n\t  if (c == p[next.first][next.second] && tmp[next.first][next.second] != 1) {\n\t    q.push(next);\n\t  }\n      }  \n    }\n  }\n  for (size_t i = 0; i < h; i++)\n    free(tmp[i]);\n  free(tmp);\n\n  return max;\n}\n\n\nint rec(const int h, const int w, const int c, int **p, const int times) {\n  \n  int now, max;\n  max = 0;\n  pair<int,int> start = make_pair(0,0);\n  \n\n  int **tmp;\n  tmp = (int **)malloc(sizeof(int*)*h);\n  for (size_t i = 0; i < h; i++)\n    tmp[i] = (int *)malloc(sizeof(int)*w);\n  \n  if (times < 5) {\n    for (size_t k = 1; k <= 6; k++) {\n      \n      for (size_t i = 0; i < h; i++)\n\tfor (size_t j = 0; j < w; j++)\n\t  tmp[i][j] = p[i][j];\n      \n      int fig = tmp[start.first][start.second];\n      if (fig != k) {\n\ttmp[start.first][start.second] = k;\n\tqueue<pair<int,int> > q;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t  pair<int,int> cur = q.front(); q.pop();\n\t  int a1[] = { -1, 0, 1, 0 };\n\t  int a2[] = { 0, 1, 0, -1 };\n\t  for (size_t i = 0; i < 4; i++) {\n\t    pair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\t    if (pass(h,w,next))\n\t      if (fig == tmp[next.first][next.second]) {\n\t\ttmp[next.first][next.second] = k;\n\t\tq.push(next);\n\t      }\n\t  }\n\t}\n\tnow = rec(h,w,c,tmp,times+1);\n\tif (now > max)\n\t  max = now;\n      }\n    }\n  } else if (times == 5) {\n    for (size_t i = 0; i < h; i++)\n      for(size_t j = 0; j < w; j++)\n\ttmp[i][j] = p[i][j];\n    queue<pair<int,int> > q;\n    q.push(start);\n    int fig = tmp[start.first][start.second];\n    if (fig != c) {\n      tmp[start.first][start.second] = c;\n      while (!q.empty()) {\n\tpair<int,int> cur = q.front(); q.pop();\n\tint a1[] = { -1, 0, 1, 0 };\n\tint a2[] = { 0, 1, 0, -1 };\n\tfor (size_t i = 0; i < 4; i++) {\n\t  pair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\t  if (pass(h,w,next))\n\t    if (fig == tmp[next.first][next.second]) {\n\t      tmp[next.first][next.second] = c;\n\t      q.push(next);\n\t    }\n\t}\n      }\n      max = search(h,w,c,tmp);\n    } \n  }\n  \n  for (size_t i = 0; i < h; i++)\n    free(tmp[i]);\n  free(tmp);\n  \n  return max;\n}\n\n\n    \nint main(int argc, char *argv[])\n{\n  while (true) {\n  int h, w, c;\n  cin >> h >> w >> c;\n  if (h == 0 && w == 0 && c == 0) break;\n  int **p;\n  p = (int**)malloc(sizeof(int *)*h);\n  for (size_t i = 0; i < h; i++)\n    p[i] = (int*)malloc(sizeof(int)*w);\n  for (size_t i = 0; i < h; i++)\n    for (size_t j = 0; j < w; j++)\n      cin >> p[i][j];\n\n  int max;\n  max = rec(h,w,c,p,1);\n\n  cout << max << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid printMap(int** map){\n\tfor(int y=0;y<8;y++){\n\t\tfor(int x=0;x<8;x++) printf(\"%4d\",map[y][x]);\n\t\tcout << endl;\n\t}\n\tgetchar();\n}\n\nint countUpPanel(int** map,int x,int y,int color,int w, int h){\n\tint sum=0;\n\tif(!(x>=0 && y>=0 && x<w && y<h)) return 0;\n\tif(map[y][x]!=color)return 0;\n\telse{\n\t\tmap[y][x]=0;\n\t\tsum++;\n\t}\n\tsum+=countUpPanel(map,x+1,y,color,w,h);\n\tsum+=countUpPanel(map,x-1,y,color,w,h);\n\tsum+=countUpPanel(map,x,y+1,color,w,h);\n\tsum+=countUpPanel(map,x,y-1,color,w,h);\n\t\n\treturn sum;\n}\n\nvoid exchangePanel(int** map,int x,int y,int color,int c,int w, int h){\n//\tprintf(\"nbb?,%d,%d,%d,%d\\n\",x,y,color,c);\n\tif(!(x>=0 && y>=0 && x<w && y<h)) return ;\n\tif(map[y][x]!=c)return ;\n\tif(map[y][x]==color)return ;\n\telse map[y][x]=color;\n\texchangePanel(map,x+1,y,color,c,w,h);\n\texchangePanel(map,x-1,y,color,c,w,h);\n\texchangePanel(map,x,y+1,color,c,w,h);\n\texchangePanel(map,x,y-1,color,c,w,h);\n\t\n}\n\nint solvePuzzle(int** map,int objectiveColor,int crrentColor,int round,int w,int h){\n\tint res=0;\n\tint resres=0;\n\t\n//\tcout << \"flop:\" << crrentColor << \"round:\" << round << endl;\n//\tprintMap(map);\n\n\n\tif(round>=5){\n\t\tres=0;\n\t\tres=countUpPanel(map,0,0,objectiveColor,w,h);\n/*\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==objectiveColor) res++;\n\t\t\t}\n\t\t}\n\t\tif(res==11){\n\t\t\tprintMap(map);\n\t\t\tgetchar();\n\t\t}*/\n\t\treturn res;\n\t}\n\telse{\n\t\tint **mapTemp = new int*[8];\n\t\tfor(int i=0;i<8;i++) mapTemp[i]=new int[8];\n\t\n\t\tif(round==4){\n\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\tfor(int x=0;x<8;x++) mapTemp[y][x]=map[y][x];\n\t\t\t}\n\t\n\t\t\texchangePanel(map,0,0,objectiveColor,map[0][0],w,h);\n\t\t\tres=solvePuzzle(map,objectiveColor,objectiveColor,round+1,w,h);\n\n\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\tfor(int x=0;x<8;x++) map[y][x]=mapTemp[y][x];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tresres=0;\n\t\t\tres=0;\n\t\t\tfor(int i=1;i<=6;i++){\n\t\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\t\tfor(int x=0;x<8;x++) mapTemp[y][x]=map[y][x];\n\t\t\t\t}\n//\t\t\t\tprintf(\"naa?,%d,%d,%d\\n\",i,map[0][0],objectiveColor);\n\t\t\t\texchangePanel(map,0,0,i,map[0][0],w,h);\n\t\t\t\tresres=solvePuzzle(map,objectiveColor,i,round+1,w,h);\n\t\t\t\tif(resres>=res) res=resres;\n\t\t\t\tfor(int y=0;y<8;y++){\n\t\t\t\t\tfor(int x=0;x<8;x++) map[y][x]=mapTemp[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<8;i++) delete [] mapTemp[i];\n\t\tdelete [] mapTemp;\n\n\n\t}\n\t\n\treturn res;\n}\n\nint main(void){\n\tint scale=8;\n\tint h,w,c;\n\tint status;\n\n\tint** map = new int*[8];\n\tfor(int i=0;i<8;i++) map[i]=new int[8];\n\twhile(true){\n\t\tcin >> h;\n\t\tcin >> w;\n\t\tcin >> c;\n\t\tif(h==0) break;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tmap[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tcin >> map[j][i];\n\t\t\t}\n\t\t}\n\n\t\tint res=0;\n\t\t\n\t\tres=solvePuzzle(map,c,0,0,w,h);\n\t\tcout << res << endl;\n\t}\n\n\tfor(int i=0;i<8;i++) delete [] map[i];\n\tdelete [] map;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstdlib>\n#define _A_ true\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 10\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,c;\nint p[MAX][MAX];\nint Ans;\n\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\n\nvoid Display(){\n  rep(i,h){\n    rep(j,w){\n      printf(\"%d \",p[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\nvoid ColorCount(){\n  queue<P> CQ;\n  CQ.push(P(0,0));\n  bool used[h][w];\n  rep(i,h)rep(j,w)used[i][j] = false;\n  used[0][0] = true;\n  int count = 1;\n  //Display();\n\n  while(CQ.size()){\n    P pi = CQ.front(); CQ.pop();\n\n    rep(i,4){\n      int nx = pi.first + dx[i], ny = pi.second + dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && !used[ny][nx] && p[ny][nx] == c){\n      count++;\t\n      CQ.push(P(nx,ny));\n      used[ny][nx] = true;    \n      }\n      \n    }\n    \n  }\n  //cout << \"Color = \" << count << endl;\n  Ans = max(Ans,count);\n\n}\n\n\n\nvoid FiveRec(){\n  //cout << \"In\" << endl;\n  queue<P> que;\n  bool used[h][w];\n  rep(i,h)rep(j,w)used[i][j] = false;\n  //bool pre\n  que.push(P(0,0));\n  used[0][0] = true;\n  int ThisColor = p[0][0];\n  p[0][0] = c;\n\n  while(que.size()){\n    P pi = que.front(); que.pop();\n    //cout << \"pi.first = \" << pi.first << \", pi.second = \" << pi.second << endl;\n    rep(i,4){\n      int nx = pi.first + dx[i],ny = pi.second + dy[i];   \n      if(0<= nx && nx < w && 0<= ny && ny < h && !used[ny][nx] &&  p[ny][nx] == ThisColor){       \n\t//cout << \"In \" << endl; \n\tque.push(P(nx,ny));\n\t//cout << \"w = \" << w << \", h = \" << h << endl;\n\tp[ny][nx] = c;\n\tused[ny][nx] = true;\n      }\n    }\n  }\n  //cout << \"Five Fin \" << endl;\n}\n\n\nvoid rec(int color,int count){\n  //cout << \"count = \" << count << endl;\n  if(count == 5){\n    //printf(\"Five Count --------------\\n\");\n    FiveRec();\n    //Display();\n    ColorCount();\n    //printf(\"Fin Five Count ---------- %d\\n\",Ans);\n    return;\n  }\n\n  //cout << \"normal disp --------\" << endl;\n  //Display();\n  //cout << \"FF----------------FF\" << endl;\n  queue<P> que;\n  bool used[h][w];\n  rep(i,h)rep(j,w)used[i][j] = false;\n \n  int ThisColor = p[0][0];\n  int pb[h][w];\n  rep(i,h)rep(j,w)pb[i][j] = p[i][j];\n  que.push(P(0,0));\n  used[0][0] = true;\n  p[0][0] = color;\n\n\n  while(que.size()){\n    P pi = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = pi.first + dx[i],ny = pi.second + dy[i];   \n      if(0<= nx && nx < w && 0<= ny && ny < h && !used[ny][nx] &&  p[ny][nx] == ThisColor){ \n\tque.push(P(nx,ny));\n\tp[ny][nx] = color;\n\tused[ny][nx] = true;\n      }\n    }\n  }\n\n\n  //koko ra hennde syuukei siteha douda roka\n  REP(i,1,7){\n    //if(i != color)\n    rec(i,count+1);\n  }\n  //printf(\"-----------------------\\n\");\n  rep(i,h)rep(j,w)p[i][j] = pb[i][j];\n  \n}\n\n\n\nint main(){\n  while(_A_){\n    scanf(\"%d %d %d\",&h,&w,&c);\n    if(!(h|w|c))break;\n    Ans = -1;\n    rep(i,h)rep(j,w)scanf(\"%d\",&p[i][j]);\n    REP(i,1,7){\n      //if(i != p[0][0])\n\trec(i,1);\n    }\n    printf(\"%d\\n\",Ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define all(a) (a).begin(),(a).end()\n#define lb(s,x) lower_bound(all(s),x)-s.begin()\n#define ub(s,x) upper_bound(all(s),x)-s.begin()\n#define uniq(a) a.erase(unique(all(a)),a.end())\n#define debug(x) cout<<#x<<\": \"<<x<<endl\ntemplate<class T,class U>\nostream& operator<<(ostream& o, const pair<T,U> &p){\n    o<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n    return o;\n}\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\ntypedef long long ll;\n\nusing VII = vector<vector<int>>;\n\nint Y,X,C;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nvoid coloring(int y,int x,int c1,int c2,VII &s){\n    if(y<0 || x<0 || x>=X || y>=Y) return;\n    if(s[y][x] == c2) return;\n    if(s[y][x] == c1){\n        s[y][x] = c2;\n        rep(i,4){\n            coloring(y+dy[i],x+dx[i],c1,c2,s);\n        }\n    }\n}\n\nint dfs(int limit,VII cur){\n    if(limit == 1){\n        coloring(0,0,cur[0][0],C,cur);\n        coloring(0,0,C,0,cur);\n        int res = 0;\n        rep(y,Y)rep(x,X){\n            if(cur[y][x] == 0){\n                res++;\n            }\n        }\n        return res;\n    }\n\n    int res = 0;\n    rep1(c,6)if(c != cur[0][0]){\n        VII nxt = cur;\n        coloring(0,0,cur[0][0],c,nxt);\n        res = max(res,dfs(limit-1,nxt));\n    }\n    return res;\n}\n\nint main(void){\n    while(cin>>Y>>X>>C, Y|X|C){\n        VII s(Y);\n        rep(y,Y){\n            s[y].resize(X);\n            rep(x,X){\n                cin>>s[y][x];\n            }\n        }\n        cout<<dfs(5,s)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<pair<int,int> > bfs(const vector<vector<int> >& grid)\n{\n  const int H = grid.size(), W = grid[0].size();\n  vector<vector<int> > dist(H, vector<int>(W, false));\n  dist[0][0] = true;\n  queue<pair<int,int> > q;\n  q.push(make_pair(0, 0));\n  const int color = grid[0][0];\n  vector<pair<int,int> > ans;\n  while (!q.empty()) {\n    ans.push_back(q.front());\n    const int i = q.front().first, j = q.front().second;\n    q.pop();\n    for (int d = 0; d < 4; d++) {\n      static const int di[] = {-1, 1, 0, 0}, dj[] = {0, 0, -1, 1};\n      const int k = i + di[d], l = j + dj[d];\n      if (0 <= k && k < H && 0 <= l && l < W && grid[k][l] == color && !dist[k][l]) {\n        dist[k][l] = true;\n        q.push(make_pair(k, l));\n      }\n    }\n  }\n  return ans;\n}\n\nint dfs(const vector<vector<int> >& grid, int depth, int C)\n{\n  const vector<pair<int,int> > c = bfs(grid);\n  if (depth == 0) {\n    if (grid[0][0] == C) {\n      return c.size();\n    } else {\n      return 0;\n    }\n  } else {\n    int ans = 0;\n    for (int i = 1; i <= 6; i++) {\n      vector<vector<int> > g(grid);\n      for (vector<pair<int,int> >::const_iterator it = c.begin(); it != c.end(); ++it) {\n        g[it->first][it->second] = i;\n      }\n      ans = max(ans, dfs(g, depth-1, C));\n    }\n    return ans;\n  }\n}\n\nint main()\n{\n  int H, W, C;\n  while (cin >> H >> W >> C && H != 0) {\n    vector<vector<int> > grid(H, vector<int>(W));\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        cin >> grid[i][j];\n      }\n    }\n    cout << dfs(grid, 5, C) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w, c;\nvector<vector<int>> grid;\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nvector<vector<int>> change(const vector<vector<int>>& g, int color) {\n    // cout<<\"change start\"<<endl;\n    // cout<<\"color=\"<<color<<endl;\n    vector<vector<int>> v = g;\n    vector<pair<int, int>> vertices;\n    bool visited[8][8] = {false}; \n    queue<pair<int, int>> que;\n    que.push(make_pair(0, 0));\n    int target = v[0][0];\n    // cout<<\"target=\"<<target<<endl;\n    while (!que.empty()) {\n        auto vec = que.front();\n        que.pop();\n        // printf(\"vec(%d, %d)\\n\", vec.first, vec.second);\n        for (int i = 0; i < 4; ++i) {\n            int nx = vec.first + dx[i];\n            int ny = vec.second + dy[i];\n            if (0 <= nx && nx < w && 0 <= ny && ny < h \n                && !visited[ny][nx] && v[ny][nx] == target) {\n                visited[ny][nx] = true;\n                vertices.push_back(make_pair(nx, ny));\n                que.push(make_pair(nx, ny));\n            }\n        }\n    }\n    // cout<<\"change end\"<<endl;\n    v[0][0] = color;\n    for (auto ver : vertices) {\n        v[ver.second][ver.first] = color;\n    }\n    return v;\n}\n\nint count(const vector<vector<int>>& g) {\n    int count = 1;\n    bool visited[8][8] = {false}; \n    visited[0][0] = true;\n    queue<pair<int, int>> que;\n    que.push(make_pair(0, 0));\n    int target = g[0][0];\n    while (!que.empty()) {\n        auto vec = que.front();\n        que.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = vec.first + dx[i];\n            int ny = vec.second + dy[i];\n            if (0 <= nx && nx < w && 0 <= ny && ny < h \n                && !visited[ny][nx] && g[ny][nx] == target) {\n                visited[ny][nx] = true;\n                que.push(make_pair(nx, ny));\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint solve() {\n    int ans = 0;\n    queue<pair<vector<vector<int>> , int>> que;\n    que.push(make_pair(grid, 0));\n    while(!que.empty()) {\n        // cout<<\"----while----\"<<endl;\n        auto front = que.front();\n        que.pop();\n        auto g = front.first;\n        int depth = front.second;\n        // cout<<\"--\"<<depth<<\"--\"<<endl;\n        // for (int y = 0; y < h; ++y) {\n        //     for (int x = 0; x < w; ++x) {\n        //         cout<<g[y][x]<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n        if (depth < 4) {\n            for (int i = 1; i < 7; ++i) {\n                auto tmp_grid = change(g, i);\n                que.push(make_pair(tmp_grid, depth+1));\n            }\n        }\n        else {\n            auto tmp_grid = change(g, c);\n            // if (count(tmp_grid) > ans) {\n            //     cout<<\"----\"<<endl;\n            //     for (int y = 0; y < h; ++y) {\n            //         for (int x = 0; x < w; ++x) {\n            //             cout<<tmp_grid[y][x]<<\" \";\n            //         }\n            //         cout<<endl;\n            //     }\n            // }\n            ans = max(ans, count(tmp_grid));\n        }\n    }\n    cout<<ans<<endl;\n}\n\nint main (int argc, char *argv[]) {\n    while (cin>>h>>w>>c, h||w||c) {\n        for (int y = 0; y < h; ++y) {\n            vector<int> tmp;\n            for (int x = 0; x < w; ++x) {\n                int t;\n                cin>>t;\n                tmp.push_back(t);\n            }\n            grid.push_back(tmp);\n        }\n        solve();\n        grid.clear();\n        // cout<<\"finish\"<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\nconst int INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\ntypedef pair<int, int> P;\n\nint h, w, c;\nint d[10][10];\n\nint dfs(int n){\n\tint ret = 0;\n\tif (n == 6){\n\t\tif (d[0][0] != c)return 0;\n\t\tqueue<P> q;\n\t\tq.push(P(0, 0));\n\t\tbool f[10][10]; clr(f);\n\t\tf[0][0] = true;\n\t\tret = 1;\n\t\twhile (q.size()){\n\t\t\tint y = q.front().first, x = q.front().second;\n\t\t\tq.pop();\n\t\t\trep(i, 4){\n\t\t\t\tint ty = y + dy[i], tx = x + dx[i];\n\t\t\t\tif (cheak(tx, ty, w, h) && d[ty][tx] == c && !f[ty][tx]){\n\t\t\t\t\tq.push(P(ty, tx));\n\t\t\t\t\tf[ty][tx] = true;\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tFor(i, 1, 7){\n\n\t\tint pr = d[0][0];\n\t\tqueue<P> q;\n\t\tq.push(P(0, 0));\n\t\tbool f[10][10]; clr(f);\n\t\tf[0][0] = true;\n\t\td[0][0] = i;\n\t\twhile (q.size()){\n\t\t\tint y = q.front().first, x = q.front().second;\n\t\t\tq.pop();\n\t\t\trep(j, 4){\n\t\t\t\tint ty = y + dy[j], tx = x + dx[j];\n\t\t\t\tif (cheak(tx, ty, w, h) && !f[ty][tx]){\n\t\t\t\t\tif (d[ty][tx] == pr){\n\t\t\t\t\t\tq.push(P(ty, tx));\n\t\t\t\t\t\tf[ty][tx] = true;\n\t\t\t\t\t\td[ty][tx] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = max(ret,dfs(n + 1));\n\n\t\trep(y, h)rep(x, w){\n\t\t\tif (f[y][x])d[y][x] = pr;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\twhile (cin >> h >> w >> c && (h || w || c)){\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> d[y][x];\n\t\t}\n\t\tcout << dfs(1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Problem     : AOJ1174\n * Title       : The Balance of the World (世界の天秤)\n * Author      : mizo0203\n * Copyright   : Your copyright free\n * Description : やるだけ\n */\n\n#include <stdio.h>\n#include <memory.h>\n#include <algorithm>\nusing namespace std;\n\nint h, w, c, maxc;\nint p[8][8];\n\nbool input() {\n  int i, j;\n\n  scanf(\"%d %d %d\", &h, &w, &c);\n  if (!h && !w && !c)\n    return false;\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      scanf(\"%d\", &p[i][j]);\n    }\n  }\n\n  return true;\n}\n\nvoid changeColor2(int a[8][8], int x, int y, int b, int c) {\n\n  if (x < 0 || w <= x || y < 0 || h <= y)\n    return;\n  if (a[y][x] != b)\n    return;\n\n  a[y][x] = c;\n  changeColor2(a, x + 1, y, b, c);\n  changeColor2(a, x, y + 1, b, c);\n  changeColor2(a, x - 1, y, b, c);\n  changeColor2(a, x, y - 1, b, c);\n\n}\n\nint changeColor3(int a[8][8], int x, int y) {\n  int cnt = 0;\n\n  if (x < 0 || w <= x || y < 0 || h <= y)\n    return 0;\n  if (a[y][x] != c)\n    return 0;\n\n  a[y][x] = 0;\n  cnt++;\n\n  cnt += changeColor3(a, x + 1, y);\n  cnt += changeColor3(a, x, y + 1);\n  cnt += changeColor3(a, x - 1, y);\n  cnt += changeColor3(a, x, y - 1);\n\n  return cnt;\n}\n\nvoid changeColor1(int a[8][8], int n) {\n  int i;\n  int tmp[8][8];\n\n  if (n == 4) {\n    changeColor2(a, 0, 0, a[0][0], c);\n    i = changeColor3(a, 0, 0);\n    if (maxc < i)\n      maxc = i;\n    return;\n  }\n\n  memcpy(tmp, a, sizeof(int) * 8 * 8);\n\n  for (i = 1; i <= 6; i++) {\n    if (tmp[0][0] == i)\n      continue;\n    if (i == c && n == 3)\n      continue;\n    changeColor2(tmp, 0, 0, tmp[0][0], i);\n\n    changeColor1(tmp, n + 1);\n    memcpy(tmp, a, sizeof(int) * 8 * 8);\n  }\n}\n\nint main() {\n\n  while (input()) {\n    maxc = 0;\n    changeColor1(p, 0);\n    printf(\"%d\\n\", maxc);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <queue>\nusing namespace std;\n\nconst int H = 8, W = 8, C = 6;\n\nstruct State{\n\tint board[H + 2][W + 2];\n};\n\ntypedef pair<int, int> P;\n\nState duplicate(State& s){\n\tState d;\n\tfor(int i = 0;i <= H + 1;++i){\n\t\tfor(int j = 0;j <= W + 1;++j){\n\t\t\td.board[i][j] = s.board[i][j];\n\t\t}\n\t}\n\treturn d;\n}\n\nvoid paint(State& s, int c){\n\tint cc = s.board[1][1];\n\tint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, 1, -1};\n\tint visited[H + 2][W + 2] = { { 0 } };\n\tstack<P> st;\n\tst.push(make_pair(1, 1));\n\twhile(!st.empty()){\n\t\tP p = st.top();\n\t\tst.pop();\n\t\ts.board[p.first][p.second] = c;\n\t\tvisited[p.first][p.second]++;\n\t\tfor(int i = 0;i < 4;++i){\n\t\t\tint y = p.first + dy[i], x = p.second + dx[i];\n\t\t\tif(!visited[y][x] && s.board[y][x] == cc) st.push(make_pair(y, x));\n\t\t}\n\t}\n\treturn;\n}\n\nint count(State& s){\n\tint c = s.board[1][1];\n\tint count = 0;\n\tint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, 1, -1};\n\tint visited[H + 2][W + 2] = { { 0 } };\n\tstack<P> st;\n\tst.push(make_pair(1, 1));\n\twhile(!st.empty()){\n\t\tP p = st.top();\n\t\tst.pop();\n\t\tvisited[p.first][p.second]++;\n\t\tfor(int i = 0;i < 4;++i){\n\t\t\tint y = p.first + dy[i], x = p.second + dx[i];\n\t\t\tif(!visited[y][x] && s.board[y][x] == c) st.push(make_pair(y, x));\n\t\t}\n\t}\n\tfor(int i = 1;i <= H;++i){\n\t\tfor(int j = 1;j <= W;++j){\n\t\t\tcount += visited[i][j] > 0;\n\t\t}\n\t}\n\treturn count;\n}\n\nint search(State init, int t){\n\t// P(area nuber, process count)\n\tint c = 0;\n\tqueue<pair<State, int> > q;\n\tq.push(make_pair(init, 0));\n\twhile(!q.empty()){\n\t\tpair<State, int> p = q.front();\n\t\tq.pop();\n\t\tState s = p.first;\n\t\tint now = p.second;\n\t\tif(now < 5){\n\t\t\tfor(int i = 0;i < C;++i){\n\t\t\t\tState n = duplicate(s);\n\t\t\t\tpaint(n, i + 1);\n\t\t\t\tq.push(make_pair(n, now + 1));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(s.board[1][1] == t){\n\t\t\t\tint cnt = count(s);\n\t\t\t\tc = max(c, cnt);\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\n\nint main(){\n\tint h, w, c;\n\tState s;\n\twhile(cin >> h >> w >> c, h){\n\t\tfill(s.board[0], s.board[W + 2], -1);\n\t\tfor(int i = 1;i <= h;++i){\n\t\t\tfor(int j = 1;j <= w;++j){\n\t\t\t\tcin >> s.board[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << search(s, c) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define vi vector<int>\n#define pb push_back\n\nvector<vector<int>> data(10,vi(10));\nint ans=0;\nint h,w,c;\n\nvoid paint(int y, int x, vector<vi> &tmp,int color, int origin_color){\n    tmp[y][x] = color;\n    int dy[]={1,0,-1,0}, dx[]={0,1,0,-1};\n    \n    rep(i,4){\n        int ddy = y+dy[i], ddx = x+dx[i];\n        if( ddx<0 || ddy<0 || ddx>=w || ddy>=h || tmp[ddy][ddx]!=origin_color )continue;\n        paint( ddy, ddx, tmp, color, origin_color );\n    }\n}\n\n\nint count(int y,int x, vector<vi> tmp,vector<vector<bool>> &used, int color){\n    used[y][x]=true;\n    int c=1;\n    int dy[]={1,0,-1,0}, dx[]={0,1,0,-1};\n    \n    rep(i,4){\n        int ddy = y+dy[i], ddx = x+dx[i];\n        if( ddx<0 || ddy<0 || ddx>=w || ddy>=h || used[ddy][ddx] || tmp[ddy][ddx]!=color )continue;\n        c+=count( ddy, ddx, tmp, used, color);\n    }\n    return c;\n}\n\n\nvoid solve(vi changed){\n    vector<vi> tmp = data;\n    \n    rep(i,changed.size()){\n        if( tmp[0][0]==changed[i] )continue;\n        paint(0,0,tmp,changed[i],tmp[0][0]);\n    }\n    \n    vector<vector<bool>> used(10,vector<bool>(10,false));\n    ans = max( count(0,0,tmp,used,tmp[0][0]) , ans );\n}\n\n\nvoid dfs(int f,vi changed){\n    if(f>=4){\n        changed.pb(c);\n        solve(changed);\n        return ;\n    }\n    rep(i,6){\n        changed.pb(i);\n        dfs(f+1,changed);\n        changed.pop_back();\n    }\n}\n\n\nint main(){\n    while(cin>>h>>w>>c&&(h||w||c)){\n        c--;\n        ans=0;\n        rep(i,10)rep(j,10)data[i][j]=-1;\n        rep(i,h) rep(j,w){\n            cin>>data[i][j];\n            data[i][j]--;\n        }\n        \n        vi changed;\n        dfs(0,changed);\n        \n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint dfs(vector<vector<int>> p, int s, int c){\n  int ans = 0;\n  int H = p.size();\n  int W = p[0].size();\n  for (int i = 1; i <= 6; i++){\n    if (s == 4 && c != i){\n      continue;\n    }\n    vector<vector<int>> q = p;\n    queue<pair<int, int>> Q;\n    Q.push(make_pair(1, 1));\n    vector<vector<bool>> used(H, vector<bool>(W, false));\n    used[1][1] = true;\n    int cnt = 0;\n    while (!Q.empty()){\n      int y = Q.front().first;\n      int x = Q.front().second;\n      Q.pop();\n      cnt++;\n      for (int j = 0; j < 4; j++){\n        if (p[y][x] == p[1][1] && q[y + dy[j]][x + dx[j]] == p[1][1] || q[y + dy[j]][x + dx[j]] == i){\n          if (!used[y + dy[j]][x + dx[j]]){\n            used[y + dy[j]][x + dx[j]] = true;\n            q[y + dy[j]][x + dx[j]] = i;\n            Q.push(make_pair(y + dy[j], x + dx[j]));\n          }\n        }\n      }\n    }\n    q[1][1] = i;\n    if (s == 4){\n      ans = max(ans, cnt);\n    } else {\n      ans = max(ans, dfs(q, s + 1, c));\n    }\n  }\n  return ans;\n}\nint main(){\n  while (1){\n    int h, w, c;\n    cin >> h >> w >> c;\n    if (h == 0 && w == 0 && c == 0){\n      break;\n    }\n    vector<vector<int>> p(h + 2, vector<int>(w + 2, 0));\n    for (int i = 1; i <= h; i++){\n      for (int j = 1; j <= w; j++){\n        cin >> p[i][j];\n      }\n    }\n    cout << dfs(p, 0, c) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint H,W,C;\nint ti[4000][5] = {};\nint F[10][10] = {};\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\nint con[10][10] = {};\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\n\nint main(){\n    int cnt = 1;\n    for(int a=1;a<=6;a++){\n        for(int b=1;b<=6;b++){\n            for(int c=1;c<=6;c++){\n                for(int d=1;d<=6;d++){\n                    ti[cnt][0] = a;\n                    ti[cnt][1] = b;\n                    ti[cnt][2] = c;\n                    ti[cnt][3] = d;\n                    cnt++;\n                }\n            }\n        }\n    }\n    while(true){\n        cin >> H;\n        if(H==0) break;\n        cin >> W >> C;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> F[i][j];\n            }\n        }\n        int ans = 0;\n        for(int t=1;t<cnt;t++){\n            ti[t][4] = C;\n            int now = 1;\n            for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) con[i][j] = 0;\n            con[1][1] = 1;\n            for(int i=1;i<=H;i++){\n                for(int j=1;j<=W;j++){\n                    if(F[i][j]!=F[1][1]) continue;\n                    if(i==1 && j==1) continue;\n                    for(int l=0;l<4;l++){\n                        int nx = i+dx[l],ny = j+dy[l];\n                        if(in(nx,ny) && con[nx][ny]==1 && F[i][j]==F[1][1]){\n                            con[i][j] = 1;\n                            now++;\n                            break;\n                        }\n                    }\n                }\n            }\n            for(int k=0;k<5;k++){\n                queue<pair<int,int>> Q;\n                for(int i=1;i<=H;i++){\n                    for(int j=1;j<=W;j++){\n                        if(con[i][j]==1) Q.push({i,j});\n                    }\n                }\n                while(!Q.empty()){\n                    pair<int,int> p = Q.front(); Q.pop();\n                    int x = p.first,y = p.second;\n                    for(int l=0;l<4;l++){\n                        int nx = x+dx[l],ny = y+dy[l];\n                        if(in(nx,ny) && F[nx][ny]==ti[t][k] && con[nx][ny]==0){\n                            con[nx][ny] = 1;\n                            now++;\n                            Q.push({nx,ny});\n                        }\n                    }\n                }\n            }\n            ans = max(ans,now);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nint ans,h,e,w,dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint bfs(int s[10][10]){\n\tint cnp=1;\n\tbool visit[10][10];\n\tmemset(visit,0,sizeof(visit));\n\tqueue<P> que;\n\tque.push(P(0,0));\n\tvisit[0][0]=1;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\trep(i,4){\n\t\t\tint nx=p.second+dx[i];\n\t\t\tint ny=p.first+dy[i];\n\t\t\tif(!(nx>=0&&nx<w&&ny>=0&&ny<h)||!(s[ny][nx]==s[0][0])||visit[ny][nx])\n\t\t\tcontinue;\n\t\t\tque.push(P(ny,nx));\n\t\t\tcnp++;\n\t\t\tvisit[ny][nx]=1;\n\t\t}\n\t}\n\treturn cnp;\n}\nvoid func(int s[10][10],int now){\n\tif(now==5){\n\t\tif(s[0][0]==e){\n\t\t\tans=max(ans,bfs(s));\n\t\t}\n\t\treturn;\n\t}\n\tint c[10][10];\n\tbool visit[10][10];\n\n\tfor(int i=1;i<=6;i++){\n\t\tif(i!=s[0][0]){\n\t\t\trep(k,h)\n\t\t\t\trep(j,w)\n\t\t\t\t\tc[k][j]=s[k][j];\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(0,0));\n\t\t\tvisit[0][0]=1;\n\tmemset(visit,0,sizeof(visit));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tc[p.first][p.second]=i;\n\t\t\t\trep(z,4){\n\t\t\t\t\tint nx=p.second+dx[z];\n\t\t\t\t\tint ny=p.first+dy[z];\n\t\t\t\t\tif(!(nx>=0&&nx<w&&ny>=0&&ny<h)||!(c[ny][nx]==s[0][0])||visit[ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t\tvisit[ny][nx]=1;\n\t\t\t\t\tc[ny][nx]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunc(c,now+1);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>h>>w>>e,w||h||e){\n\t\tint s[10][10];\n\t\tans=0;\n\t\trep(i,h)\n\t\t\trep(j,w)\n\t\t\t\tcin>>s[i][j];\n\t\t\n\t\tfunc(s,0);\n\t\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint f[10][10];\nint h,w,c;\nint ret=-1;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\n\nvoid pr(){\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nvoid bfs(int count, int color){\n    int orig,cnt=1;\n    vector<pair<int,int> > vec;\n    deque<pair<int ,int> > q;\n    bool visited[10][10];\n    \n    memset(visited, false, sizeof(visited));\n    orig = f[1][1];\n    q.push_back(make_pair(1,1));\n    visited[1][1] = true;\n    vec.push_back(make_pair(1,1));\n    int tx,ty,nx,ny;\n    while(!q.empty()){\n        ty = q.front().first;\n        tx = q.front().second;\n        q.pop_front();\n\n        for(int i=0;i<4;i++){\n            ny = ty + dy[i];\n            nx = tx + dx[i];\n\n            if(f[ny][nx] == orig && visited[ny][nx] == false){\n                visited[ny][nx] = true;\n                vec.push_back(make_pair(ny,nx));\n                q.push_back(make_pair(ny,nx));\n                if(orig == c)cnt++;\n            }\n        }\n    }\n    \n    if(count == 5){\n        ret = max(ret, cnt);\n        return;\n    }\n\n    for(int i=0;i<vec.size();i++){\n        f[vec[i].first][vec[i].second] = color;\n    }\n\n    for(int i=1;i<=6;i++){\n        bfs(count+1,i);\n    }\n\n    for(int i=0;i<vec.size();i++){\n        f[vec[i].first][vec[i].second] = orig;\n    }\n}\n\nint main(){\n    while(cin >> h >> w >> c){\n        if((h|w|c) == 0) break;\n        ret = -1;\n        memset(f, -1, sizeof(f));\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> f[i][j];\n            }\n        }\n        for(int i=1;i<=6;i++){\n            bfs(0,i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <utility>\n\nusing namespace std;\n\nint h,w,c,ans;\n\nvoid dfs(int dep,int a[][8]){\n\tint x,y,dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\tif(dep==5){\n\t\tint t=1;\n\t\tif(c==a[0][0]){\n\t\t\tqueue<pair<int,int> > q;\n\t\t\tq.push(make_pair(0,0));\n\t\t\ta[0][0]=-1;\n\t\t\twhile(!q.empty()){\n\t\t\t\tx=q.front().first,y=q.front().second,q.pop();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h) continue;\n\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||a[ny][nx]!=c) continue;\n\t\t\t\t\tt++;\n\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\ta[ny][nx]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=max(ans,t);\n\t\treturn;\n\t}\n\tint tmp[8][8];\n\tmemcpy(tmp,a,sizeof(a));\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) tmp[i][j]=a[i][j];\n\tfor(int col=1;col<=6;col++){\n\t\tif(a[0][0]==col) dfs(dep+1,a);\n\t\telse{\n\t\t\tint p = a[0][0];\n\t\t\ta[0][0]=col;\n\t\t\tqueue<pair<int,int> > q;\n\t\t\tq.push(make_pair(0,0));\n\t\t\twhile(!q.empty()){\n\t\t\t\tx=q.front().first,y=q.front().second,q.pop();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||a[ny][nx]!=p) continue;\n\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\ta[ny][nx]=col;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(dep+1,a);\n\t\t}\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) a[i][j]=tmp[i][j];\n\t\t//memcpy(tmp,a,sizeof(a));\n\t}\n\treturn;\n}\n\nint main(){\n\tint a[8][8];\n\twhile(cin>>h>>w>>c,h||w||c){\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) cin>>a[i][j];\n\t\tans=0;\n\t\tdfs(0,a);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,c,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nvector<int> p(64);\n\nint nu(int x,int y,int cl,int t){\n  int res=1;\n  p[y*w+x]=cl;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||w<=nx||ny<0||h<=ny||p[ny*w+nx]!=t||p[ny*w+nx]==cl)continue;\n    res+=nu(nx,ny,cl,t);\n  }\n  return res;\n}\n\nint dfs(int d){\n  vector<int> tp=p;\n  int res=0;\n  if(d==4){\n    res=nu(0,0,c,p[0]);\n    return nu(0,0,7,p[0]);\n  }\n  for(int j=1;j<7;j++){\n    nu(0,0,j,p[0]);\n    res=max(res,dfs(d+1)),p=tp;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>h>>w>>c,h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>p[i*w+j];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, f, a[9][9], b[9][9], g[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e; f++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tfor (int k = 1; k <= 6; k++) {\n\t\tif (d == 4) k = c;\n\t\tif (b[0][0] == k) continue;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) g[i][j] = b[i][j];\n\t\t}\n\t\tf = 0; rec(0, 0, k);\n\t\tret = max(ret, d != 4 ? max(f, solve(d + 1)) : f);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) b[i][j] = g[i][j];\n\t\t}\n\t\tif (d == 4) break;\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nint H, W, c;\nvector<vector<int>> a;\nint dh[] = { 1,0,-1,0 };\nint dw[] = { 0,1,0,-1 };\nvoid init(int h, int w) {\n    a.clear(); a.assign(h, vector<int>(w));\n}\n\nint dfs(int cur, vector<vector<int>> a) {\n    if (cur == 5) {\n        if (a[0][0] != c) return 0;\n        int res = 0;\n        queue<pair<int, int>> q;\n        vector<vector<bool>> used(H, vector<bool>(W));\n        q.emplace(0, 0);\n        used[0][0] = true;\n        int t = a[0][0];\n        while (!q.empty()) {\n            res++;\n            int h, w; tie(h, w) = q.front();\n            q.pop();\n            for (int j = 0; j < 4; j++) {\n                int nh = h + dh[j];\n                int nw = w + dw[j];\n                if (nh < 0 or nh >= H or nw < 0 or nw >= W) continue;\n                if (used[nh][nw]) continue;\n                if (a[nh][nw] == t) {\n                    q.emplace(nh, nw);\n                    used[nh][nw] = true;\n                }\n            }\n        }\n        return res;\n    }\n    int res = 0;\n    for (int i = 0; i < 6; i++) {\n        auto ta = a;\n        if (a[0][0] != i) {\n            int t = a[0][0];\n            ta[0][0] = i;\n            queue<pair<int, int>> q;\n            q.emplace(0, 0);\n            while (!q.empty()) {\n                int h, w; tie(h, w) = q.front();\n                q.pop();\n                for (int j = 0; j < 4; j++) {\n                    int nh = h + dh[j];\n                    int nw = w + dw[j];\n                    if (nh < 0 or nh >= H or nw < 0 or nw >= W) continue;\n                    if (ta[nh][nw] == t) {\n                        ta[nh][nw] = i;\n                        q.emplace(nh, nw);\n                    }\n                }\n            }\n        }\n        chmax(res, dfs(cur + 1, ta));\n    }\n    return res;\n}\nvoid solve() {\n    scanf(\"%d %d %d\", &H, &W, &c); if (H == 0) exit(0);\n    c--;\n    init(H, W);\n    for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), a[i][j]--;\n    printf(\"%d\\n\", dfs(0, a));\n}\n\nint main()\n{\n\t/*\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    */\n    int kkt = 89;\n    while (kkt) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\nusing namespace std;\n\nint pan[10][10];\n\nint H, W, C;\n\nint change(int c0, int c1, int x, int y, int panel[10][10]) {\n\t\n\tif ( x > 9 || y > 9 ) { return 0; }\n\tif ( x < 0 || y < 0 ) { return 0; }\n\t\n\tif ( panel[x][y] == c0 ) {\n\t\tpanel[x][y] = c1;\n\t\t\n\t\tint ret = 1;\n\t\tret += change(c0, c1, x+1, y, panel);\n\t\tret += change(c0, c1, x, y+1, panel);\n\t\tret += change(c0, c1, x-1, y, panel);\n\t\tret += change(c0, c1, x, y-1, panel);\n\t\t\n\t\treturn ret;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n\nint main(void) {\n\t\n\twhile(true) {\n\t\t\n\t\tscanf(\"%d %d %d\", &H, &W, &C);\n\t\t\n\t\tif ( H==0 && W==0 && C==0 ) { break; }\n\t\t\n\t\tfill(pan[0], pan[0]+10*10, -1);\n\t\tfor(int x=0; x<H; x++) {\n\t\t\tfor(int y=0; y<W; y++ ) {\n\t\t\t\tscanf(\"%d\", &pan[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint maax = 0;\n\t\t\n\t\tfor(int col=0; col<(6*6*6*6); col++) {\n\t\t\tint prevcolor = pan[0][0];\n\t\t\t\n\t\t\tint nowpan[10][10];\n\t\t\t//TODO std::copy\n\t\t\tmemcpy(nowpan, pan, 10*10*sizeof(int));\n\t\t\t\n\t\t\t\n\t\t\tint colordiv = col;\n\t\t\tint ret = -1;\n\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\tint nowcolor = (colordiv%6)+1;\n\t\t\t\tcolordiv /= 6;\n\t\t\t\t\n\t\t\t\t//printf(\"%d->\", nowcolor);\n\t\t\t\t\n\t\t\t\tif ( prevcolor == nowcolor ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tchange(nowpan[0][0], nowcolor, 0, 0, nowpan);\n\t\t\t\tprevcolor = nowcolor;\n\t\t\t}\n\t\t\t\n\t\t\tif ( prevcolor != C ) {\n\t\t\t\tchange(nowpan[0][0], C, 0, 0, nowpan);\n\t\t\t}\n\t\t\tret = change(C, 0, 0, 0, nowpan);\n\t\t\t\n\t\t\t/*\n\t\t\tmemcpy(nowpan, pan, 10*10*sizeof(int));\n\t\t\tchange(nowpan[0][0], 6, 0, 0, nowpan);\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(int x=0; x<H; x++) {\n\t\t\t\tfor(int y=0; y<W; y++ ) {\n\t\t\t\t\tprintf(\"%d \", nowpan[x][y]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tchange(nowpan[0][0], 3, 0, 0, nowpan);\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(int x=0; x<H; x++) {\n\t\t\t\tfor(int y=0; y<W; y++ ) {\n\t\t\t\t\tprintf(\"%d \", nowpan[x][y]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tchange(nowpan[0][0], 4, 0, 0, nowpan);\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(int x=0; x<H; x++) {\n\t\t\t\tfor(int y=0; y<W; y++ ) {\n\t\t\t\t\tprintf(\"%d \", nowpan[x][y]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tchange(nowpan[0][0], 2, 0, 0, nowpan);\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(int x=0; x<H; x++) {\n\t\t\t\tfor(int y=0; y<W; y++ ) {\n\t\t\t\t\tprintf(\"%d \", nowpan[x][y]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tchange(nowpan[0][0], 5, 0, 0, nowpan);\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(int x=0; x<H; x++) {\n\t\t\t\tfor(int y=0; y<W; y++ ) {\n\t\t\t\t\tprintf(\"%d \", nowpan[x][y]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t*/\n\t\t\t\n\t\t\tif ( maax < ret ) { maax = ret;\n\n\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", maax );\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 8;\n\nint h, w, c;\nint field[6][MAX_N][MAX_N];\nint old;\n/*\nint field1[MAX_N][MAX_N];\nint field2[MAX_N][MAX_N];\nint field3[MAX_N][MAX_N];\nint field4[MAX_N][MAX_N];\nint field5[MAX_N][MAX_N];\n*/\n\nvoid debug(int m) {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tcout << field[m][i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"----------\" << endl;\n}\n\nvoid dfs(int x, int y, int n, int m) {\n\tint dx[4] = {1, 0, -1, 0};\n\tint dy[4] = {0, 1, 0, -1};\n\t\n\tfield[m][y][x] = n;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && field[m][ny][nx] == old) {\n\t\t\tdfs(nx, ny, n, m);\n\t\t}\n\t}\n}\n\n// 左上とつながっているマスをすべて色nに変える, mは回数(1〜5)\nvoid change(int n, int m) {\n\tmemcpy(field[m], field[m-1], sizeof(field[m-1]));\n\told = field[m][0][0];\n\tdfs(0, 0, n, m);\n}\n\nint check() {\n\tint ans = 0;\n\told = field[5][0][0];\n\tdfs(0, 0, -1, 5);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (field[5][i][j] == -1) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n\nvoid solve() {\n\tint ans = 0;\n\tfor (int i = 1; i <= 6; i++) {\n\t\tif (field[0][0][0] == i) {\n\t\t\tcontinue;\n\t\t}\n\t\tchange(i, 1);\n\t\tfor (int j = 1; j <= 6; j++) {\n\t\t\tif (field[1][0][0] == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchange(j, 2);\n\t\t\tfor (int k = 1; k <= 6; k++) {\n\t\t\t\tif (field[2][0][0] == k) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tchange(k, 3);\n\t\t\t\tfor (int l = 1; l <= 6; l++) {\n\t\t\t\t\tif (field[3][0][0] == l || c == l) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchange(l, 4);\n\t\t\t\t\tchange(c, 5);\n\t\t\t\t\t//debug(5);\n\t\t\t\t\tans = max(ans, check());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> h >> w >> c;\n\t\t\n\t\tif (h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(field, 0, sizeof(field));\n\t\t\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> field[0][i][j];\n\t\t\t}\n\t\t}\n\t\t//cout << \"初期状態\" << endl;\n\t\t//debug(0);\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint h, w, c, ans;\nusing board = vector<vector<int>>;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nboard b[4];\nbool used[10][10];\n\nvoid paint(board &a, int x, int y, int px, int py, int before, int after){\n    used[x][y] = true;\n    a[x][y] = after;\n    rep(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx == px && ny == py) continue;\n        if(0<=nx && nx<h && 0<=ny && ny<w && a[nx][ny] == before && !used[nx][ny]){\n            paint(a, nx, ny, x, y, before, after);\n        }\n    }\n}\n\nint cnt(board &a, int x, int y, int px, int py, int col){\n    used[x][y] = true;\n    int ret = 1;\n    rep(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx == px && ny == py) continue;\n        if(0<=nx && nx<h && 0<=ny && ny<w && a[nx][ny] == col && !used[nx][ny]){\n            ret += cnt(a, nx, ny, x, y, col);\n        }\n    }\n    return ret;\n}\n\nvoid dfs(int cur, board &a){\n    if(cur == 4){\n        rep(i, h)rep(j, w) used[i][j] = false;\n        paint(a, 0, 0, -1, -1, a[0][0], c);\n        rep(i, h)rep(j, w) used[i][j] = false;\n        chmax(ans, cnt(a, 0, 0, -1, -1, c));\n        return;\n    }\n    rep(i, h)rep(j, w) b[cur][i][j] = a[i][j];\n    For(col, 1, 7){\n        rep(i, h)rep(j, w) used[i][j] = false;\n        rep(i, h)rep(j, w) a[i][j] = b[cur][i][j];\n        paint(a, 0, 0, -1, -1, a[0][0], col);\n        dfs(cur + 1, a);\n    }\n}\n\nvoid solve(){\n    board a(h, vector<int>(w));\n    rep(i, h)rep(j, w) scanf(\"%d\", &a[i][j]);\n    rep(i, 4){\n        b[i].resize(h);\n        rep(x, h) b[i][x].resize(w);\n    }\n    ans = 0;\n    dfs(0, a);\n    printf(\"%d\\n\", ans);\n}\n\nint main(){\n    while(scanf(\"%d%d%d\", &h, &w, &c) && h){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#define f first\n#define s second\nusing namespace std;\n\nint h,w,p[8][8],rast,ans,map[8][8];\nint x[4]={1,-1,0,0};\nint y[4]={0,0,1,-1};\nbool color[6];\nvector<pair<int,pair<int,int> >  > V;\n\nbool in(int i,int j)\n{\n  if(i<0 || j<0 || i>=h || j>=w)return false;\n  return true;\n}\n\nvoid Erase(int n)\n{\n  for(int i=n;i<V.size();i++){\n    map[V[i].s.f][V[i].s.s]=0;\n    V.erase(V.begin()+i);\n    i--;\n  }\n}\n\nint count()\n{\n  int a=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(map[i][j]!=0)a++;\n    }\n  }\n  return a;\n}\n\nvoid Connect(int n,int num)\n{\n  int s=V.size();\n  queue<pair<int,int> > Q;\n  for(int i=0;i<V.size();i++){\n    Q.push(make_pair(V[i].s.f,V[i].s.s));\n    while(!Q.empty()){\n      pair<int,int> u=Q.front();Q.pop();\n      for(int k=0;k<4;k++){\n\tint a=u.f+x[k],b=u.s+y[k];\n\tif(in(a,b)){\n\t  if(map[a][b]==0 && p[a][b]==n){\n\t    map[a][b]=1;\n\t    if(num==0)map[a][b]=2;\n\t    Q.push(make_pair(a,b));\n\t    V.push_back(make_pair(n,make_pair(a,b)));\n\t  }\n\t}\n      }\n    }\n  }\n  if(num==5 && n==rast){\n    ans=max(ans,count());\n    Erase(s);\n    return;\n  }\n  if(num==5){\n    Erase(s);\n    return;\n  }\n  for(int i=0;i<6;i++)Connect(i,num+1);\n  Erase(s);\n}\nint main()\n{\n  while(1){\n    cin>>h>>w>>rast;\n    if(h+w+rast==0)break;\n    rast--;\n    V.clear();\n    for(int i=0;i<6;i++)color[i]=false;\n    for(int i=0;i<8;i++){\n      for(int j=0;j<8;j++)map[i][j]=0;\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>p[i][j];\n\tp[i][j]--;\n      }\n    }\n    ans=0;\n    map[0][0]=2;\n    V.push_back(make_pair(p[0][0],make_pair(0,0)));\n    Connect(p[0][0],0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint h,w,c,P[9][9],p[9][9],a,dy[]={0,1,0,-1},dx[]={1,0,-1,0},X;\n\nvoid f(int y,int x,int b,int C){\n\tif(p[y][x]==C)return;\n\tp[y][x]=C;\n\trep(i,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(0<=ny&&ny<h&&0<=nx&&nx<w&&p[ny][nx]==b)f(ny,nx,b,C);\n\t}\n}\n\nvoid g(int y,int x){\n\tX++;\n\tp[y][x]=-1;\n\trep(i,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(0<=ny&&ny<h&&0<=nx&&nx<w&&p[ny][nx]==c)g(ny,nx);\n\t}\n}\n\nint main(){\n\twhile(cin>>h>>w>>c,h){\n\t\tc--;\n\t\trep(i,h)rep(j,w)cin>>P[i][j],P[i][j]--;\n\t\ta=0;\n\t\trep(i,6)rep(j,6)rep(k,6)rep(l,6){\n\t\t\trep(m,h)rep(n,w)p[m][n]=P[m][n];\n\t\t\tf(0,0,p[0][0],i),f(0,0,p[0][0],j),f(0,0,p[0][0],k),f(0,0,p[0][0],l),f(0,0,p[0][0],c);\n\t\t\tX=0;\n\t\t\tg(0,0);\n\t\t\ta=max(a,X);\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector< vector<int> > change(vector< vector<int> > p, int c) {\n\tint cc = p[0][0];\n\tint h = p.size();\n\tint w = p[0].size();\n\tint dx[] = { 1,0,-1,0 };\n\tint dy[] = { 0,1,0,-1 };\n\tvector< vector<int> > p2(h, vector<int>(w, 0));\n\tqueue<P> q;\n\tq.push(P(0, 0));\n\tp[0][0] = c;\n\tp2[0][0] = 1;\n\twhile (!q.empty()) {\n\t\tP pp = q.front();\n\t\tq.pop();\n\t\tint x = pp.first;\n\t\tint y = pp.second;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (0 <= x + dx[i] && x + dx[i] < w && 0 <= y + dy[i] && y + dy[i] < h) {\n\t\t\t\tif (p2[y + dy[i]][x + dx[i]] == 0) {\n\t\t\t\t\tif (p[y + dy[i]][x + dx[i]] == cc) {\n\t\t\t\t\t\tp[y + dy[i]][x + dx[i]] = c;\n\t\t\t\t\t\tp2[y + dy[i]][x + dx[i]] = 1;\n\t\t\t\t\t\tq.push(P(x + dx[i], y + dy[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}\n\nint calcpanel(vector< vector<int> >p) {\n\tint cc = p[0][0];\n\tint h = p.size();\n\tint w = p[0].size();\n\tint dx[] = { 1,0,-1,0 };\n\tint dy[] = { 0,1,0,-1 };\n\tvector< vector<int> > p2(h, vector<int>(w, 0));\n\tqueue<P> q;\n\tq.push(P(0, 0));\n\tp2[0][0] = 1;\n\tint count = 1;\n\twhile (!q.empty()) {\n\t\tP pp = q.front();\n\t\tq.pop();\n\t\tint x = pp.first;\n\t\tint y = pp.second;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (0 <= x + dx[i] && x + dx[i] < w && 0 <= y + dy[i] && y + dy[i] < h) {\n\t\t\t\tif (p2[y + dy[i]][x + dx[i]] == 0) {\n\t\t\t\t\tif (p[y + dy[i]][x + dx[i]] == cc) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tp2[y + dy[i]][x + dx[i]] = 1;\n\t\t\t\t\t\tq.push(P(x + dx[i], y + dy[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nint calc(vector< vector<int> > p, int limit, int c) {\n\tint h = p.size();\n\tint w = p[0].size();\n\tif (limit == 0) {\n\t\treturn calcpanel(p);\n\t}\n\tint MAX = 0;\n\tfor (int i = 1; i <= 6; i++) {\n\t\tif (limit > 1) {\n\t\t\tMAX = max(MAX, calc(change(p, i), limit - 1, c));\n\t\t}\n\t}\n\tif (limit == 1) {\n\t\tMAX = calc(change(p, c), limit-1, c);\n\t}\n\treturn MAX;\n}\n\nint main() {\n\tint h, w, c;\n\twhile (cin >> h >> w >> c) {\n\t\tif (h == 0 && w == 0 && c == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<int> > p(h, vector<int>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> p[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << calc(p, 5, c) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nint H, W, C;\nVVI p;\n\nint const dx[] = {-1,0,1,0};\nint const dy[] = {0,-1,0,1};\n\nint ans;\n\ninline bool inF(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nvoid dfs2(int x, int y, int now, int next) {\n  \n  p[y][x] = next;\n    \n  for(int i=0; i<4; i++) {\n    int nx = x+dx[i], ny = y+dy[i];\n    if(inF(nx, ny) && p[ny][nx] == now) {\n      dfs2(nx, ny, now, next);\n    }\n  }\n}\n\nvector<vector<bool> > vis;\nint cnt_panel(int x, int y) {\n  int res = 0;\n  vis[y][x] = true;\n  for(int i=0; i<4; i++) {\n    int nx = x+dx[i], ny = y+dy[i];\n    if(inF(nx, ny) && !vis[ny][nx] && p[ny][nx] == C) {\n      res += cnt_panel(nx, ny);\n    }\n  }\n  return res+1;\n}\n\nvoid change(int cnt) {\n  if(cnt == 5) {\n    vis.clear(); vis.resize(H); for(int i=0; i<H; i++) vis[i].resize(W);\n    ans = max(ans, cnt_panel(0, 0));\n    return;\n  }\n  \n  if(cnt == 4) {\n    if(p[0][0] == C) return;\n    dfs2(0, 0, p[0][0], C);\n    change(cnt+1);\n  }\n  else {\n    VVI tmp(p);\n    for(int next=1; next<=6; next++) {\n      if(p[0][0] == next) continue;\n      dfs2(0, 0, p[0][0], next);\n      change(cnt+1);\n      p = tmp;\n    }\n  }\n  \n}\n\nint main() {\n  \n  for(;cin >> H >> W >> C && (H|W|C);) {\n    p.clear();\n    p.resize(H); for(int i=0; i<H; i++) p[i].resize(W);\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n        cin >> p[i][j];\n    \n    ans = 0;\n    change(0);\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> point;\n#define X first\n#define Y second\n\nconstexpr int NUMBER_OF_COLORS = 6;\nconstexpr int dx[] = {1, -1, 0, 0};\nconstexpr int dy[] = {0, 0, 1, -1};\n\nint h, w, c;\n\ninline bool out(int x, int y) {\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\n\nint calc(const vector<vector<int>> &panel) {\n\tqueue<point> que;\n\tque.push({0, 0});\n\n\tconst int color = panel[0][0];\n\tvector<vector<bool>> visited(h, vector<bool>(w, false));\n\tvisited[0][0] = true;\n\tint res = 0;\n\n\twhile(!que.empty()) {\n\t\tconst auto cp = que.front();\n\t\tque.pop();\n\n\t\t++res;\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = cp.X + dx[d];\n\t\t\tconst int ny = cp.Y + dy[d];\n\n\t\t\tif(out(nx, ny) || visited[ny][nx]) continue;\n\t\t\tif(panel[ny][nx] == color) {\n\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\tque.push({nx, ny});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvector<vector<int>> change(const vector<vector<int>> &panel, int to) {\n\tconst int from = panel[0][0];\n\tvector<vector<int>> res(panel);\n\tif(from == to) return res;\n\n\tqueue<point> que;\n\tque.push({0, 0});\n\tres[0][0] = to;\n\n\twhile(!que.empty()) {\n\t\tconst auto cp = que.front();\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = cp.X + dx[d];\n\t\t\tconst int ny = cp.Y + dy[d];\n\n\t\t\tif(out(nx, ny)) continue;\n\t\t\tif(res[ny][nx] == from) {\n\t\t\t\tres[ny][nx] = to;\n\t\t\t\tque.push({nx, ny});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint rec(const vector<vector<int>> &panel, int rest) {\n\tif(rest == 1) return calc(change(panel, c));\n\n\tint res = 0;\n\tfor(int i = 0; i < NUMBER_OF_COLORS; ++i) {\n\t\tres = max(res, rec(change(panel, i), rest - 1));\n\t}\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w >> c && h) {\n\t\t--c;\n\t\tvector<vector<int>> panel(h, vector<int>(w));\n\t\tfor(auto &row : panel) for(auto &e : row) cin >> e, --e;\n\t\tcout << rec(panel, 5) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, f, a[9][9], b[9][9], g[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e; f++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tfor (int k = 1; k <= 6; k++) {\n\t\tif (b[0][0] == k) continue;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) g[i][j] = b[i][j];\n\t\t}\n\t\tf = 0; rec(0, 0, k);\n\t\tret = max(ret, d != 4 ? max(f, solve(d + 1)) : f);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) b[i][j] = g[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef vector<vector<int> > Panel;\n\nint dx[4] = {0,-1,1,0};\nint dy[4] = {-1,0,0,1};\nint w,h,c,ans,color_cnt;\n\nvoid debug(const Panel& a){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << a[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint colorConut(const Panel& a){\n\tint s=0;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( a[y][x] == -1 ) s++;\n\t\t}\n\t}\n\treturn s;\n}\n\nvoid change(Panel& a, int x, int y, int prev_c, int next_c){\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\tif( a[my][mx] == prev_c ){\n\t\t\ta[my][mx] = next_c;\n\t\t\tchange( a , mx , my , prev_c , next_c );\n\t\t}\n\t}\n}\n\nvoid solve(const Panel& a, int cnt){\n\tif( cnt == 6 ){\n\t\tPanel b = a;\n\t\tb[0][0] = -1;\n\t\tchange( b , 0 , 0 , c , -1 );\n\t\tans = max( ans , colorConut(b) );\n\t}else{\n\t\tfor(int i=1 ; i <= 6 ; i++ ){\n\t\t\tPanel b = a;\n\t\t\tif( a[0][0] == i ) continue;\n\t\t\tb[0][0] = i;\n\t\t\tchange( b , 0 , 0 , a[0][0] , i );\n\t\t\tsolve( b , cnt+1 );\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> h >> w >> c , h||w||c ){\n\t\tPanel a;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tvector<int> v;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tint e;\n\t\t\t\tcin >> e;\n\t\t\t\tv.push_back( e );\n\t\t\t}\n\t\t\ta.push_back( v );\n\t\t}\n\t\tans = 0;\n\t\tsolve( a , 1 );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n \nusing namespace std;\n \n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n \nint Y,X,obj,cnt;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n \nvoid dfs2(int y, int x, int now, int next, vector< vector<int> >& state){\n  int i;\n \n  cnt++;\n  state[y][x] = next;\n  REP(i,4){\n    int my = y + dy[i];\n    int mx = x + dx[i];\n    if(0 <= my && my < Y && 0 <= mx && mx < X && state[my][mx] == now) dfs2(my,mx,now,next,state);\n  }\n}\n \nint dfs(int now, int next, int depth, vector< vector<int> > state){\n  int res=0,i;\n\n  cnt = 0;\n  dfs2(0,0,now,next,state);\n \n  if(now == obj && depth == 5) return cnt;\n \n  REP(i,7) if(i != 0 && i != next){\n    if(depth == 5) continue;\n    res = max(res, dfs(next,i,depth+1,state));\n  }\n \n  return res;\n}\n \nint main(){\n  int i,j;\n  vector< vector<int> > board;\n \n  while(1){\n    cin >> Y >> X >> obj;\n    if(X == 0 && Y == 0 && obj == 0) break;\n \n    board.resize(Y);\n    REP(i,Y) board[i].resize(X);\n    REP(i,Y) REP(j,X) cin >> board[i][j];\n \n    int res = 0, now = board[0][0];\n    REP(i,7) if(i != 0 && now != i) res = max(res,dfs(now,i,0,board));\n \n    cout << res << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define F first\n#define S second\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef pair<int,int>pii;\nstruct data{\n    int cnt;\n    vvi fld;\n    data(){}\n    data(int a,vvi b):cnt(a),fld(b){}\n\n};\ndata check(vvi fld,int to){\n    int c=fld[0][0];\n    int h=fld.size();\n    int w=fld[0].size();\n    int dx[]={0,-1,0,1};\n    int dy[]={-1,0,1,0};\n    queue<pii>Q;\n    Q.push(pii(0,0));\n    int cnt=0;\n    while(Q.size()){\n        int y=Q.front().F,x=Q.front().S;\n        Q.pop();\n        if(y<0||y>=h||x<0||x>=w)continue;\n        if(fld[y][x]!=c)continue;\n        fld[y][x]=-1;\n        cnt++;\n        for(int i=0;i<4;i++)Q.push(pii(y+dy[i],x+dx[i]));\n    }\n\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            if(fld[i][j]==-1)fld[i][j]=to;\n    return data(cnt,fld);\n}\nint main(){\n    int h,w,c;\n    while(cin>>h>>w>>c,h||w||c){\n        vvi fld(h,vi(w));\n        c--;\n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++){\n                cin>>fld[i][j];\n                fld[i][j]--;\n            }\n\n        int ma=0;\n        queue<data>Q;\n        Q.push(data(0,fld));\n        while(Q.size()){\n            data d=Q.front();\n            Q.pop();\n            if(d.cnt>=5){\n                if(d.fld[0][0]==c){\n                    ma=max(ma,check(d.fld,c).cnt);\n                }\n                continue;\n            }\n            for(int i=0;i<6;i++){\n                Q.push(data(d.cnt+1,(check(d.fld,i)).fld));\n            }\n        }\n        cout<<ma<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 10\n#define MAXW 10\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint h, w, c;\nint p[MAXH][MAXW], buf[MAXH][MAXW];\nint ret = 0;\nint hairetu[4] = {1, 1, 1, 1};\n\nvoid dfs(int cur) {\n    if (cur == 4) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                buf[i][j] = p[i][j];\n            }\n        }\n        for (int i = 0; i < 5; i++) {\n            bool done[MAXH][MAXW] = {false};\n            int color; \n            if (i < 4) color = hairetu[i];\n            else color = c;\n            int origin = buf[0][0];\n            queue<int> X;\n            queue<int> Y;\n            X.push(0); Y.push(0);\n            while (!X.empty()) {\n                int x = X.front(); X.pop();\n                int y = Y.front(); Y.pop();\n                done[y][x] = true;\n                buf[y][x] = color;\n                for (int j = 0; j < 4; j++) {\n                    int nx = x + dx[j];\n                    int ny = y + dy[j];\n                    if (0 <= nx && nx < w && 0 <= ny && ny < h && buf[ny][nx] == origin && !done[ny][nx]) {\n                        X.push(nx); Y.push(ny);\n                    }\n                }\n            }\n        }\n        // 連続している島で一番大きい物を探す\n        bool done[MAXH][MAXW] = {false};\n        for (int j = 0; j < h; j++) {\n            for (int k = 0; k < w; k++) {\n                if (buf[j][k] == c && !done[j][k]) {\n                    int ans = 0;\n                    queue<int> X; queue<int> Y;\n                    X.push(k); Y.push(j);\n                    while (!X.empty()) {\n                        int x = X.front(); X.pop();\n                        int y = Y.front(); Y.pop();\n                        ans++;\n                        done[y][x] = true;\n                        for (int l = 0; l < 4; l++) {\n                            int nx = x + dx[l];\n                            int ny = y + dy[l];\n                            if (0 <= nx && nx < w && 0 <= ny && ny < h && !done[ny][nx] && buf[ny][nx] == c) {\n                                X.push(nx); Y.push(ny);\n                                done[ny][nx] = true;\n                            }\n                        }\n                    }\n                    ret = max(ret, ans);\n                }\n            }\n        }\n        return;\n    }\n    for (int i = 1; i <= 6; i++) {\n        hairetu[cur] = i;\n        dfs(cur+1);\n    }\n}\n\n\nint main(void) {\n    while (1) {\n        cin >> h >> w >> c;\n        if (h == 0 && w == 0 && c == 0) break;\n        ret = 0;\n        for (int i = 0; i < 4; i++) hairetu[i] = 1;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> p[i][j];\n            }\n        }\n        dfs(0);\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n\nint h, w, c;\n\nint Cnt(vector< vector<int> > &f, int y, int x, int color){\n    f[y][x] = -1;\n    int ret = 1;\n    int my[] = {0, 0, 1, -1};\n    int mx[] = {1, -1, 0, 0};\n    REP(i, 4){\n        int ny = y + my[i], nx = x + mx[i];\n        if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n        if(f[ny][nx] == color){\n            ret += Cnt(f, ny, nx, color);\n        }\n    }\n    return ret;\n}\n\nvoid changeColor(vector< vector<int> > &f, int aft_color, int bef_color, int y, int x){\n    f[y][x] = aft_color;\n    int my[] = {0, 0, 1, -1};\n    int mx[] = {1, -1, 0, 0};\n    REP(i, 4){\n        int ny = y + my[i], nx = x + mx[i];\n        if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n        if(f[ny][nx] == bef_color){\n            changeColor(f, aft_color, bef_color, ny, nx);\n        }\n    }\n}\n\nint dfs(vector< vector<int> > &f, int cnt){\n    //debug\n    //cout <<cnt <<endl;\n    //REP(i, f.size()){\n    //    REP(j, f[i].size()) cout <<f[i][j] <<\" \";\n    //    cout <<endl;\n    //}\n    //cout <<endl;\n    if(cnt >= 5){\n        if(f[0][0] == c){\n            vector< vector<int> > tmp_f = f;\n            return Cnt(tmp_f, 0, 0, f[0][0]);\n        }\n        else return 0;\n    }\n    int ret = 0;\n    FOR(color, 1, 7){\n        if(color == f[0][0]) continue;\n        vector< vector<int> > tmp_f = f;\n        changeColor(tmp_f, color, f[0][0], 0, 0);\n        ret = max(ret, dfs(tmp_f, cnt + 1));\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >>h >>w >>c && (h || w || c)){\n        vector< vector<int> > f(h, vector<int>(w));\n        REP(i, h) REP(j, w) cin >>f[i][j];\n        cout <<dfs(f, 0) <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nint panel_loc[8][8];\nint visit[8][8];\nint color[5];\nint maxcolor[5];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint getarea(const vector<vector<int>> panel,int h, int w){\n  int c,c_before,sum=0,tmp;\n  queue<pair<int,int>> que;\n  for(int y=0;y<h;y++){\n    for(int x=0;x<w;x++){\n      panel_loc[y][x] = panel[y][x];\n    }\n  }\n  for(int i=0;i<5;i++){\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n        visit[y][x]=0;\n      }\n    }\n    c = color[i];\n    c_before = panel_loc[0][0];\n    panel_loc[0][0] = c;\n    visit[0][0] = 1;\n    que.push(make_pair(0,0));\n    while (not que.empty()){\n      //cin >> tmp;\n      pair<int,int> pan = que.front();\n      que.pop();\n      for(int j=0;j<4;j++){\n        if (pan.first+dy[j]>=0 && pan.first+dy[j]<h && pan.second+dx[j]>=0 && pan.second+dx[j]<w && panel_loc[pan.first+dy[j]][pan.second+dx[j]]==c_before && !visit[pan.first+dy[j]][pan.second+dx[j]]){\n          panel_loc[pan.first+dy[j]][pan.second+dx[j]] = c;\n          visit[pan.first+dy[j]][pan.second+dx[j]] = 1;\n          que.push(make_pair(pan.first+dy[j],pan.second+dx[j]));\n        }\n      }\n    }\n  }\n  //count\n  for(int y=0;y<h;y++){\n    for(int x=0;x<w;x++){\n      visit[y][x] = 0;\n    }\n  }\n  que.push(make_pair(0,0));\n  visit[0][0] = 1;\n  while(not que.empty()){\n    pair<int,int> pan = que.front();\n    ++sum;\n    que.pop();\n    for(int i=0;i<4;i++){\n      if (pan.first+dy[i]>=0 && pan.first+dy[i]<h && pan.second+dx[i]>=0 && pan.second+dx[i]<w && panel_loc[pan.first+dy[i]][pan.second+dx[i]]==color[4] && !visit[pan.first+dy[i]][pan.second+dx[i]]){\n        que.push(make_pair(pan.first+dy[i],pan.second+dx[i]));\n        visit[pan.first+dy[i]][pan.second+dx[i]]=1;\n      }\n    }\n  }\n  return sum;\n}\n\nint main(){\n  int h,w;\n  while (1){\n    cin >> h >> w >> color[4];\n    --color[4];\n    if (h == 0){\n      break;\n    }\n    vector<vector<int>> panel(h,vector<int>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> panel[i][j];\n        --panel[i][j];\n      }\n    }\n    int maxarea = 0;\n    int tmp;\n    for(int i=0;i<1296;i++){\n      color[0] = i-(i/6)*6;\n      color[1] = ((i-(i/36)*36)-color[0])/6;\n      color[2] = ((i-(i/216)*216)-color[0]-color[1]*6)/36;\n      color[3] = ((i-(i/1296)*1296)-color[0]-color[1]*6-color[2]*36)/216;\n      tmp = getarea(panel,h,w);\n      if (tmp>maxarea){\n        maxarea=tmp;\n        maxcolor[0] = color[0];\n        maxcolor[1] = color[1];\n        maxcolor[2] = color[2];\n        maxcolor[3] = color[3];\n        maxcolor[4] = color[4];\n      }\n    }\n    cout << maxarea << endl;\n  }\n  return 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h, w, c;\nint field[10][10][10];\nbool visit[10][10];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint dfs(int depth, int x, int y, int tc) {\n  if (visit[y][x]) { return 0; }\n  visit[y][x] = true;\n  const int ndepth = depth + 1;\n  const int pc = field[depth][0][0];\n  field[ndepth][y][x] = tc;\n  int ret = 1;\n  REP(dir, 4) {\n    int nx = x + dx[dir];\n    int ny = y + dy[dir];\n    if (nx < 0 || nx >= w || ny < 0 || ny >= h) { continue; }\n    if (field[depth][ny][nx] != pc) { continue; }\n    ret += dfs(depth, nx, ny, tc);\n  }\n  return ret;\n}\n\nint calc(int depth) {\n  if (depth == 5) {\n    if (field[depth][0][0] != c) { return 0; }\n    MEMSET(visit, false);\n    memcpy(field[depth + 1], field[depth], sizeof(field[depth]));\n    return dfs(depth, 0, 0, c);\n  }\n  int ret = 0;\n  FOREQ(i, 1, 6) {\n    if (depth == 4 && i != c) { continue; }\n    MEMSET(visit, false);\n    memcpy(field[depth + 1], field[depth], sizeof(field[depth]));\n    dfs(depth, 0, 0, i);\n    ret = max(ret, calc(depth + 1));\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &c), h|w|c) {\n    REP(y, h) {\n      REP(x, w) {\n        scanf(\"%d\", &field[0][y][x]);\n      }\n    }\n    cout << calc(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint field[10][10];\nint H, W, C;\n\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint count_field() {\n  int c = field[1][1];\n  bool visit[10][10];\n  fill(&visit[0][0], &visit[9][10], false);\n  visit[1][1] = true;\n  int cnt = 1;\n  queue<P> Q;\n  Q.push(P(1, 1));\n  while (!Q.empty()) {\n    P cur = Q.front();\n    int x = cur.first;\n    int y = cur.second;\n    Q.pop();\n    \n    for (int i = 0; i < 4; i++) {\n      int tx = x + dx[i];\n      int ty = y + dy[i];\n      // printf(\"%d, %d = %d\\n\",tx, ty,  field[ty][tx]);\n      if (field[ty][tx] > 0 && !visit[ty][tx] && field[ty][tx] == C) {\n        visit[ty][tx] = true;\n        cnt++;\n        Q.push(P(tx, ty));\n      }\n    }\n  }\n  return cnt;\n}\n\nint fill_color(int color, vector<P>& filled) {\n  queue<P> Q;\n  Q.push(P(1, 1));\n  bool visit[10][10];\n  fill(&visit[0][0], &visit[9][10], false);\n  visit[1][1] = true;\n  int bc = field[1][1];\n  field[1][1] = color;\n  filled.push_back(P(1,1));\n  while (!Q.empty()) {\n    P cur = Q.front();\n    int x = cur.first;\n    int y = cur.second;\n    Q.pop();\n\n    for (int i = 0; i < 4; i++) {\n      int tx = x + dx[i];\n      int ty = y + dy[i];\n      if (field[ty][tx] > 0 && !visit[ty][tx] && field[ty][tx] == bc) {\n        visit[ty][tx] = true;\n        field[ty][tx] = color;\n        Q.push(P(tx, ty));\n        filled.push_back(P(tx, ty));\n      }\n    }\n  }\n}\n\nvoid reverse_color(int c, vector<P> & filled) {\n  for (int i = 0; i < filled.size(); i++) {\n    int x = filled[i].first;\n    int y = filled[i].second;\n    field[y][x] = c;\n  }\n}\n\nvoid print_field() {\n  for (int i = 1; i <= H; i++) {\n    for (int j = 1; j <= W; j++) {\n      printf(\"%d \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint _solve(int depth) {\n  // print_field();\n  if (depth == 4) {\n    int c = field[1][1];\n    vector<P> filled;\n    fill_color(C, filled);\n    int res = count_field();\n    reverse_color(c, filled);\n    return res;\n  }\n  /*\n  if (depth == 5) {\n    return count_field();\n  }\n  */\n  int c = field[1][1];\n  int mx = 0;\n  for (int i = 1; i <= 6; i++) {\n    if (c != i) {\n      vector<P> prev;\n      fill_color(i, prev);\n      mx = max(_solve(depth + 1), mx);\n      reverse_color(c, prev);\n    }\n  }\n  return mx;\n}\n\nvoid solve() {\n  printf(\"%d\\n\", _solve(0));\n}\n\nvoid init() {\n  for (int i = 0; i <= H + 1; i++) {\n    for (int j = 0; j <= W + 1; j++) {\n      field[i][j] = 0;\n    }\n  }\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d %d \", &H, &W, &C);\n    init();\n    if (H == 0 && W == 0 && C == 0) {\n      return 0;\n    }\n    for (int i = 1; i <= H; i++) {\n      for (int j = 1; j <= W; j++) {\n        scanf(\"%d \", &field[i][j]);\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w,c;\n\nstruct Panel{ int a[8][8]; };\nstruct Point{ int x,y; };\n\nint count(const Panel &pnl){\n\tint ans=1;\n\tbool visited[8][8]={}; visited[0][0]=true;\n\n\tqueue<Point> qu; qu.push((Point){0,0});\n\twhile(!qu.empty()){\n\t\tPoint p=qu.front(); qu.pop();\n\t\trep(i,4){\n\t\t\tPoint q={p.x+dx[i],p.y+dy[i]};\n\t\t\tif(0<=q.y && q.y<h && 0<=q.x && q.x<w\n\t\t\t&& !visited[q.y][q.x] && pnl.a[q.y][q.x]==c){\n\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\tans++;\n\t\t\t\tqu.push((Point){q.x,q.y});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint dfs(Panel pnl,int depth){\n\tif(depth==5) return count(pnl);\n\n\tint ans=0;\n\tchar prev=pnl.a[0][0];\n\tfor(int cc=1;cc<=6;cc++) if(cc!=prev) {\n\t\tPanel tmp=pnl;\n\n\t\tpnl.a[0][0]=cc;\n\t\tbool visited[8][8]={}; visited[0][0]=true;\n\t\tqueue<Point> qu; qu.push((Point){0,0});\n\t\twhile(!qu.empty()){\n\t\t\tPoint p=qu.front(); qu.pop();\n\t\t\trep(i,4){\n\t\t\t\tPoint q={p.x+dx[i],p.y+dy[i]};\n\t\t\t\tif(0<=q.y && q.y<h && 0<=q.x && q.x<w\n\t\t\t\t&& !visited[q.y][q.x] && pnl.a[q.y][q.x]==prev){\n\t\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\t\tpnl.a[q.y][q.x]=cc;\n\t\t\t\t\tqu.push((Point){q.x,q.y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=max(ans,dfs(pnl,depth+1));\n\n\t\tpnl=tmp;\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&h,&w,&c),h;){\n\t\tPanel pnl;\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&pnl.a[i][j]);\n\n\t\tprintf(\"%d\\n\",dfs(pnl,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint x,y,c;\nint field[10][10];\nbool is_field[10][10];\n\nvoid initis_field()\n{\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tis_field[i][j] = false;\n\t\t}\n\t}\n}\n\nvoid check_field(int x,int y)\n{\n\tif(field[x][y] == c)\n\t\tis_field[x][y] = true;\n\tint vx[4] = {-1,0,1,0};\n\tint vy[4] = {0,-1,0,1};\n\tfor(int i=0;i<4;i++){\n\t\tif(is_field[x+vx[i]][y+vy[i]]==false && c == field[x+vx[i]][y+vy[i]] )\n\t\t\tcheck_field(x+vx[i],y+vy[i]);\n\t}\n}\n\nint counting()\n{\n\tint count = 0;\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(is_field[i][j] == true)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid change_tile(int id,int x,int y,int before)\n{\n\tfield[x][y] = id;\n\tint vx[4] = {-1,0,1,0};\n\tint vy[4] = {0,-1,0,1};\n\tfor(int i=0;i<4;i++){\n\t\tif(field[x+vx[i]][y+vy[i]]==before)\n\t\t\tchange_tile(id,x+vx[i],y+vy[i],before);\n\t}\n}\n\nint change(int id,int depth)\n{\n\tint tile_num = 0;\n\tinitis_field();\n\tcheck_field(1,1);\n\ttile_num = counting();\n\tfor(int id=1;id<=6;id++){\n\t\tif(field[1][1] != id && depth != 0){\n\t\t\tint beforefield[10][10];\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tbeforefield[i][j] = field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tchange_tile(id,1,1,field[1][1]);\n\t\t\ttile_num = max(tile_num,change(id,depth-1));\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tfield[i][j] = beforefield[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn tile_num;\n}\n\nint main()\n{\n\twhile(cin >> x >> y >> c){\n\t\tif(x==0 && y==0 && c==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=x;i++){\n\t\t\tfor(int j=1;j<=y;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint maxtile = 0;\n\t\tmaxtile = max(maxtile,change(0,5));\n\t\t\t\t\n\t\tcout << maxtile << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w, c;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool can(int y,int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nint cnt = 0, sy = 0, sx = 0;\nbool used[10][10];\nvector< vector<int> > v;\n\nvoid rec(int y, int x) {\n\tused[y][x] = true;\n\tcnt++;\n\n\trep(i, 4) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\n\t\tif(can(ny, nx) && !used[ny][nx] && v[ny][nx] == v[sy][sx]) {\n\t\t\trec(ny, nx);\n\t\t}\n\t}\n}\n\nint target, change;\n\nvoid dfs(int y, int x) {\n\tv[y][x] = change;\n\trep(i, 4) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\n\t\tif(can(ny, nx) && v[ny][nx] == target) {\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n}\n\nint ans = 0;\nvoid func(vector< vector<int> > t, int id) {\n\t// cout << \" ------ func ---- :\" << id << endl;\n\t// rep(i, h) {\n\t// \trep(j, w) cout << t[i][j] << \" \";\n\t// \tcout << endl;\n\t// }\n\tif(id == 4) {\n\t\tv = t;\n\t\ttarget = t[sy][sx];\n\n\t\tif(target == c) return;\n\t\tchange = c;\n\t\tdfs(sy, sx);\n\n\t\tcnt = 0;\n\t\tmemset(used, 0, sizeof(used));\n\t\trec(sy, sx);\n\t\tans = max(ans, cnt);\n\t\treturn;\n\t}\n\n\tREP(i, 1, 7) {\n\t\tif(i == t[sy][sx]) continue;\n\t\tv = t;\n\t\ttarget = t[sy][sx]; change = i;\n\t\tdfs(sy, sx);\n\t\tfunc(v, id + 1);\n\t}\n}\n\nint main() {\n\twhile(cin >> h >> w >> c) {\n\t\tif(h == 0 && w == 0 && c == 0) break;\n\n\t\tv.resize(h);\n\t\trep(i, h) {\n\t\t\tv[i].resize(w);\n\t\t\trep(j, w) cin >> v[i][j];\n\t\t}\n\n\t\tans = 0;\n\t\tfunc(v, 0);\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nconst Vector<Int> dx({-1, 0, 0, 1}), dy({0, -1, 1, 0});\n\nVector<Tuple<Int, Int>> connected(const Matrix<Int>& p) {\n    Int h = p.size(), w = p.front().size();\n    Matrix<Bool> used = genv<Bool>(h, w, false);\n\n    Vector<Tuple<Int, Int>> ret;\n    Queue<Tuple<Int, Int>> que;\n    que.emplace(0, 0);\n\n    while (!que.empty()) {\n        Int x, y;\n        std::tie(x, y) = que.front();\n        que.pop();\n\n        if (used[x][y]) continue;\n        ret.emplace_back(x, y);\n        used[x][y] = true;\n\n        for (Int i = 0; i < 4; ++i) {\n            Int nx = x + dx[i], ny = y + dy[i];\n            if (nx < 0 || h <= nx || ny < 0 || w <= ny ||\n                p[nx][ny] != p[x][y] || used[nx][ny]) continue;\n            que.emplace(nx, ny);\n        }\n    }\n\n    return ret;\n}\n\nBool solve() {\n    Int h, w, c;\n    std::cin >> h >> w >> c;\n    if (h == 0) return false;\n    --c;\n\n    Matrix<Int> p = genv<Int>(h, w, 0LL);\n    for (auto& b : p) {\n        for (auto& e : b) {\n            std::cin >> e;\n            --e;\n        }\n    }\n\n    Int ans = 0;\n    Vector<Int> v(5);\n    v[4] = c;\n    for (v[0] = 0; v[0] < 6; ++v[0]) {\n        for (v[1] = 0; v[1] < 6; ++v[1]) {\n            for (v[2] = 0; v[2] < 6; ++v[2]) {\n                for (v[3] = 0; v[3] < 6; ++v[3]) {\n                    auto cp = p;\n\n                    for (Int i = 0; i < 5; ++i) {\n                        auto idxs = connected(cp);\n                        for (auto t : idxs) {\n                            Int x, y;\n                            std::tie(x, y) = t;\n                            cp[x][y] = v[i];\n                        }\n                    }\n\n                    ans = std::max(ans, Int(connected(cp).size()));\n                }\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\n// #define DEBUG\n\nusing namespace std;\n\nint h, w, c;\nint p[9][9];\n\nvoid Coloring(int y, int x, int c, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      Coloring(ny, nx, c, checked);\n    }\n  }\n  p[y][x] = c;\n  checked[y][x] = false;\n}\n\nint Count(int y, int x, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return 0;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      ret += Count(ny, nx, checked);\n    }\n  }\n\n  return ret + 1; \n}\n\nint dfs(int limit, int c, int* pv = nullptr) {\n  if (limit == 0) {\n    bool checked[9][9] = { false };\n    return Count(0, 0, checked);\n  }\n  int ret = 0;\n  for (int i = 1; i <= 6; i++) {\n    if (limit == 1 && i != c) {\n      continue;\n    }\n    // ?????????\n    if (p[0][0] == i) {\n      continue;\n    }\n    int tmp[9][9];\n    memcpy(tmp, p, sizeof(p));\n    bool checked[9][9] = { false };\n    Coloring(0, 0, i, checked);\n    int tpv[10] = { 0 };\n    int d = dfs(limit - 1, c, tpv);\n    memcpy(p, tmp, sizeof(p)); // UNDO\n    if (d > ret) {\n      ret = d;\n      if (pv != nullptr) {\n        pv[limit] = i;\n        for (int j = 0; j < limit; j++) {\n          pv[j] = tpv[j];\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> h >> w >> c;\n    if (h + w + c == 0) {\n      break;\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> p[i][j];\n      }\n    }\n    int pv[10] = { 0 };\n    cout << dfs(5, c) << endl;\n   \n#ifdef DEBUG\n    for (int i = 0; i < 10; i++) {\n      cout << pv[i] << \" \\n\"[i == 9];\n    }\n#endif\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,k,n) for(int i=k;i<(int)(n);i++)\n\n#define vi vector<int>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n\ntypedef long long ll;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nint main(){\n//    ifstream in(\"cin.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int h,w,c;\n    while(cin >> h >> w >> c,h){\n        int ma = 0;\n        int p[10][10] = {};\n        rep(y,h)rep(x,w) cin >> p[y][x];\n        int a[6] = {};\n        rep(bit,pow(6,4)){\n            int tmp_bit = bit;\n            rep(i,4){\n                a[i] = tmp_bit%6;\n                tmp_bit/=6;\n                a[i]+=1;\n                if(a>0 && a[i-1] == a[i]) a[0] = -1;\n//                cout << a[i] << \" \";\n            }\n            if(a[0] == -1 || a[3] == c) continue;\n//            cout << endl;\n            a[4] = c;\n//            rep(i,c) cout << a[i] << \" \";\n//            cout << endl;\n            int t[10][10];\n            rep(y,h)rep(x,w) t[y][x] = p[y][x];\n\n            rep(i,5){\n\n                queue<pii> que;\n                que.push(pii(0,0));1\n                int now_color = t[0][0];\n                bool u[10][10] = {};\n                while(!que.empty()){\n                    int x,y;\n                    tie(x,y) = que.front();\n                    que.pop();\n                    if(u[y][x]) continue;\n                    u[y][x] = true;\n                    t[y][x] = a[i];\n                    rep(d,4){\n                        int nx = x + dx[d];\n                        int ny = y + dy[d];\n                        if(nx < 0 || w <= nx ||\n                                ny < 0 || h <= ny) continue;\n                        if(u[ny][nx] || t[ny][nx] != now_color) continue;\n                        que.push(pii(nx,ny));\n                    }\n                }\n            }\n            int cnt = 0;\n            queue<pii> qe;\n            qe.push(pii(0,0));\n            bool uu[10][10] = {};\n\n            while(!qe.empty()) {\n                int xp, yp;\n\n                tie(xp, yp) = qe.front();\n                qe.pop();\n                if(uu[yp][xp]) continue;\n                cnt += 1;\n                uu[yp][xp] = true;\n                rep(d, 4) {\n                    int nx = xp + dx[d];\n                    int ny = yp + dy[d];\n                    if (nx < 0 || w <= nx ||\n                        ny < 0 || h <= ny)\n                        continue;\n                    if(uu[ny][nx]) continue;\n                    if(t[ny][nx] != c) continue;\n                    qe.push(pii(nx, ny));\n                }\n            }\n            ma = max(ma,cnt);\n        };\n        cout << ma << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<vector>\n#include<algorithm>\n#include<functional>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int h, w, c;\n    cin >> h >> w >> c;\n    if(h == 0) break;\n    int fld[64];\n    for(int i = 0; i < 8; i++) {\n      for(int j = 0; j < 8; j++) {\n        if(i < h && j < w) {\n          int p;\n          cin >> p;\n          fld[i*8+j] = p;\n        } else {\n          fld[i*8+j] = 0;\n        }\n      }\n    }\n    auto switching = [w,h](int d, int *f) {\n        bool visited[64];\n        for(int i = 0; i < 64; i++) visited[i] = false;\n        visited[0] = true;\n        vector<int> st;\n        st.push_back(0);\n        int di[] = {-1, 0, 1, 0};\n        int dj[] = {0, 1, 0, -1};\n        while(st.size()>0) {\n          int q = st.back();\n          st.pop_back();\n          int i = q / 8;\n          int j = q % 8;\n          for(int k = 0; k < 4; k++) {\n            int ii = i + di[k];\n            int jj = j + dj[k];\n            int qq = ii * 8 + jj;\n            if(ii >= 0 && jj >= 0 && ii < h && jj < w && f[qq] == f[0] && !visited[qq]) {\n              visited[qq] = true;\n              st.push_back(qq);\n            }\n          }\n        }\n        int cnt = 0;\n        for(int i = 0; i < 64; i++) {\n          if(visited[i]) {\n            f[i] = d;\n            cnt++;\n          }\n        }\n        return cnt;\n    };\n    auto print = [w,h](const int *f) {\n      for(int i = 0; i < h; i++) {\n        for(int j = 0; j < w; j++) {\n          cout << f[i*8+j] << \" \";\n        }\n        cout << endl;\n      }\n    };\n    int mx = 0;\n    std::function<void(const int*, int)> trying = [c,w,h,&mx,&trying,&switching,&print](const int *f, int did) {\n      //cout << \"--\" << did << endl;\n      //print(f);\n      //cout << endl;\n      if(did == 4) {\n        if(f[0] == c) return; // no change X(\n        int ff[64];\n        for(int i = 0; i < 64; i++) ff[i] = f[i];\n        switching(c, ff);\n        int cnt = switching(9, ff);\n        //print(ff);\n        //cout << \"cnt = \" << cnt << endl;\n        //cout << endl;\n        if(mx < cnt) mx = cnt;\n      } else {\n        for(int d = 1; d <= 6; d++) {\n          if(f[0] != d) {\n            int ff[64];\n            for(int i = 0; i < 64; i++) ff[i] = f[i];\n            switching(d, ff);\n            trying(ff, did+1);\n          }\n        }\n      }\n    };\n    trying(fld, 0);\n    cout << mx << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\n\tint dx[] = { 1,0,-1,0 };\n\tint dy[] = { 0,1,0,-1 };\n\n\tint h, w, c;\n\twhile (cin >> h >> w >> c) {\n\t\tif (h == 0 && w == 0 && c == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<int> > mp(h, vector<int>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> mp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tset<long long int> st;\n\t\tmap<long long int, vector< vector<int> > > mpp;\n\t\tmpp[0] = mp;\n\t\tvector<int> num(5, 0);\n\t\tfor (long long int i = 1; i <= 7 * 7 * 7 * 7 * 7; i++) {\n\t\t\tnum[0]++;\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tif (num[j] > 6) {\n\t\t\t\t\tnum[j + 1]++;\n\t\t\t\t\tnum[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long int nn = 0;\n\t\t\tint cc = 0;\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tnn *= 10;\n\t\t\t\tnn += num[j];\n\t\t\t\tif (num[j] > 0) {\n\t\t\t\t\tcc = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long int cc2 = 0;\n\t\t\tif (cc == 0) {\n\t\t\t\tcc2 = 10000;\n\t\t\t}\n\t\t\telse if (cc == 1) {\n\t\t\t\tcc2 = 1000;\n\t\t\t}\n\t\t\telse if (cc == 2) {\n\t\t\t\tcc2 = 100;\n\t\t\t}\n\t\t\telse if (cc == 3) {\n\t\t\t\tcc2 = 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcc2 = 1;\n\t\t\t}\n\t\t\t//cout << nn << ' ' << i << endl;\n\t\t\t//cout << nn << ' ' << nn - num[cc] * cc2 << endl;\n\t\t\tvector< vector<int> > mp2 = mpp[nn - num[cc] * cc2];\n\t\t\t//cout << mp2.size() << endl;\n\t\t\tint ss = mp2[0][0];\n\t\t\t//cout << ss << endl;\n\t\t\tqueue<P> q;\n\t\t\tmp2[0][0] = num[cc];\n\n\t\t\tif (ss != num[cc]) {\n\t\t\t\tq.push(P(0, 0));\n\t\t\t}\n\n\t\t\t//cout << q.size() << endl;\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tP pp = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (0 <= pp.first + dx[j] && pp.first + dx[j] < w && 0 <= pp.second + dy[j] && pp.second + dy[j] < h) {\n\t\t\t\t\t\tif (mp2[pp.second + dy[j]][pp.first + dx[j]] == ss) {\n\t\t\t\t\t\t\tmp2[pp.second + dy[j]][pp.first + dx[j]] = num[cc];\n\t\t\t\t\t\t\tq.push(P(pp.first + dx[j], pp.second + dy[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tmpp[nn] = mp2;\n\t\t\tif (nn == 66666) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//cout << -1 << endl;\n\n\t\tint ans = 0;\n\t\tnum = vector<int>(5, 0);\n\t\tfor (long long int i = 1; i <= 7 * 7 * 7 * 7 * 7; i++) {\n\t\t\tnum[0]++;\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tif (num[j] > 6) {\n\t\t\t\t\tnum[j + 1]++;\n\t\t\t\t\tnum[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long int nn = 0;\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tnn *= 10;\n\t\t\t\tnn += num[j];\n\t\t\t}\n\t\t\t//cout << i << ' ' << nn << endl;\n\t\t\tint ans2 = 0;\n\t\t\tvector< vector<int> > mp3 = mpp[nn];\n\t\t\tqueue<P> q;\n\t\t\tif (mp3[0][0] == c) {\n\t\t\t\tq.push(P(0, 0));\n\t\t\t\tans2++;\n\t\t\t\tmp3[0][0] = 0;\n\t\t\t}\n\t\t\twhile (!q.empty()) {\n\t\t\t\tP pp = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (0 <= pp.first + dx[j] && pp.first + dx[j] < w && 0 <= pp.second + dy[j] && pp.second + dy[j] < h) {\n\t\t\t\t\t\tif (mp3[pp.second + dy[j]][pp.first + dx[j]] == c) {\n\t\t\t\t\t\t\tmp3[pp.second + dy[j]][pp.first + dx[j]] = 0;\n\t\t\t\t\t\t\tq.push(P(pp.first + dx[j], pp.second + dy[j]));\n\t\t\t\t\t\t\tans2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if (ans2 == 11) {\n\t\t\t\tcout << nn << endl;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\t\tcout << mp3[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tans = max(ans, ans2);\n\t\t\tif (nn == 66666) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint h,w,c;\nint table[10][10];\n\nint nt[10][10];\n\nvoid copy(){\n\trep(i,h)rep(j,w)nt[i][j] = table[i][j];\n}\n\nvector<int> vi;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nbool used[10][10];\n\nvoid clear(){\n\trep(i,h)rep(j,w)used[i][j]=false;\n}\n\nvoid change(int y,int x,int pc,int nc){\n\tused[y][x] = true;\t\n\tnt[y][x] = nc;\n\trep(i,4){\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif(ny>=0 && ny<h && nx>=0 && nx<w){\n\t\t\tif(!used[ny][nx] && pc == nt[ny][nx])change(ny,nx,pc,nc);\n\t\t}\n\t}\n\t// rep(i,h){\n\t// \trep(j,w)cout<<nt[i][j]<<\" \";\n\t// \tcout<<endl;\n\t// }\n}\n\n\nvoid calc(int y,int x){\n\tused[y][x] = true;\n\trep(i,4){\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif(ny>=0 && ny<h && nx>=0 && nx<w){\n\t\t\tif(used[ny][nx])continue;\n\t\t\tif(nt[ny][nx] == nt[y][x])calc(ny,nx);\n\t\t}\n\t}\n}\n\nll solve(int cnt){\n\tif(cnt==5){\n\t\t// cout<<\"!!!\"<<endl;\n\t\tclear();\n\t\tcalc(0,0);\n\t\tll res = 0;\n\t\trep(i,h)rep(j,w)res+=used[i][j];\n\t\treturn res;\n\t} \n\t// cout<<\"!!!\"<<cnt<<endl;\n\tclear();\n\tchange(0,0,nt[0][0],vi[cnt]);\n\treturn solve(cnt+1);\n}\n\nint main(){\n\twhile(cin>>h>>w>>c && h+w+c){\n\t\trep(i,h)rep(j,w)cin>>table[i][j];\n\t\tll ans = 0;\n\t\trep(i,6){\n\t\t\tvi.push_back(i+1);\n\t\t\trep(j,6){\n\t\t\t\tvi.push_back(j+1);\n\t\t\t\trep(k,6){\n\t\t\t\t\tvi.push_back(k+1);\n\t\t\t\t\trep(l,6){\n\t\t\t\t\t\tvi.push_back(l+1);\n\t\t\t\t\t\tvi.push_back(c);\n\t\t\t\t\t\tcopy();\n\t\t\t\t\t\t// cout<<\"!\";\n\t\t\t\t\t\t// rep(ii,vi.size())cout<<vi[ii];\n\t\t\t\t\t\t// cout<<endl;\n\t\t\t\t\t\tans = max(ans,solve(0));\n\t\t\t\t\t\tvi.pop_back();\n\t\t\t\t\t\tvi.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tvi.pop_back();\n\t\t\t\t}\n\t\t\t\tvi.pop_back();\n\t\t\t}\n\t\t\tvi.pop_back();\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_WID = 8;\nint W, H, C;\nint board[MAX_WID][MAX_WID];\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint count(int y, int x){\n\tint ret = 0;\n\tif(board[y][x] == C){\n\t\tboard[y][x] = 0;\n\t\tret++;\n\t}\n\tfor(int k=0; k<4; k++){\n\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\tif(0<=ny && ny<H && 0<=nx && nx<W && board[ny][nx] == C){\n\t\t\tret += count(ny, nx);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid draw(int y, int x, int cur, int tar){\n\tboard[y][x] = tar;\n\tfor(int k=0; k<4; k++){\n\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\tif(0<=ny && ny<H && 0<=nx && nx<W && board[ny][nx] == cur){\n\t\t\tdraw(ny, nx, cur, tar);\n\t\t}\n\t}\n}\n\nint dfs(int depth){\n\tint tmp_board[MAX_WID][MAX_WID];\n\tmemcpy(tmp_board, board, sizeof(board));\n\n\tint ret = 0;\n\n\tif(depth == 4){\n\t\tif(C!=board[0][0]){\n\t\t\tdraw(0,0,board[0][0], C);\n\t\t\tret = count(0,0);\n\t\t\tmemcpy(board, tmp_board, sizeof(board));\n\t\t}\n\t}\n\telse{\n\t\tfor(int k=1; k<=6; k++)if(k!=board[0][0]){\n\t\t\tdraw(0,0,board[0][0], k);\n\t\t\tret = max(ret, dfs(depth+1));\n\t\t\tmemcpy(board, tmp_board, sizeof(board));\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\twhile(scanf(\"%d%d%d\",&H,&W,&C),H){\n\t\tfor(int i=0; i<H; i++)for(int j=0; j<W; j++){\n\t\t\tscanf(\"%d\", board[i]+j);\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint h,w,c;\nint map[8][8];\nint ans,cnt;\n\nvoid dfs(int y,int x,int now, int color){\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,1,0,-1};\n  int sx,sy;\n\n  map[y][x] = color;\n  cnt++;\n\n  for(int i=0;i<4;i++){\n    sx = x + dx[i];\n    sy = y + dy[i];\n    if(sx < 0 || sx >= w || sy < 0 || sy >= h)continue;\n    if(map[sy][sx] == now)dfs(sy,sx,now,color);\n  }\n}\n\nvoid rec(int time){\n  int tmp[8][8];\n\n  if(time==4){\n    if(map[0][0] != c)dfs(0,0,map[0][0],c);\n    cnt = 0;\n    dfs(0,0,c,0);\n    ans = max(ans,cnt);\n  }else{\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)tmp[i][j] = map[i][j];\n    }\n    \n    for(int i=1;i<=6;i++){\n      if(i!=map[0][0]){\n\tdfs(0,0,map[0][0],i);\n\trec(time+1);\n\tfor(int j=0;j<h;j++){\n\t  for(int k=0;k<w;k++)map[j][k] = tmp[j][k];\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin >> h >> w >> c;\n    if(!h && !w && !c)break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> map[i][j];\n    }\n\n    ans = 0;\n    rec(0);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAXH=8;\nconst int MAXCOL=6;\nconst int MAXT=7;\nconst int dx[4]={-1,1,0,0};\nconst int dy[4]={0,0,-1,1};\nint H,W,C;\nint map[MAXH][MAXH][MAXT];\nbool visited[MAXH][MAXH];\n\nvoid copymap(int moto,int to){\n     for(int i=0;i<H;i++){\n\t  for(int j=0;j<W;j++){\n\t       map[i][j][to]=map[i][j][moto];\n\t  }\n     }\n}\n\nvoid recmap(int x,int y,int col,int tocol,int t){\n     //cout<<col<<\":\"<<tocol<<endl;\n     if(x>H-1||y>W-1||x<0||y<0)return;\n     if(visited[x][y])return;\n     if(map[x][y][t]!=col)return;\n     map[x][y][t]=tocol;\n     visited[x][y]=true;\n     for(int i=0;i<4;i++){\n\t  recmap(x+dx[i],y+dy[i],col,tocol,t);\n     }\n     return;\n}\n\nint countup(int x,int y,int col,int t){\n     if(x>H-1||y>W-1||x<0||y<0)return 0;\n     if(visited[x][y])return 0;\n     if(map[x][y][t]!=col)return 0;\n     visited[x][y]=true;\n     int sum=0;\n     for(int i=0;i<4;i++){\n\t  sum+=countup(x+dx[i],y+dy[i],col,t);\n     }\n     return sum+1;\n}\n\nint ans=0;\nvoid rec(int tocol,int t){\n     //if(map[0][0][t]==tocol)return;\n     for(int i=0;i<H;i++){\n\t  for(int j=0;j<W;j++){\n\t       visited[i][j]=false;\n\t  }\n     }\n     recmap(0,0,map[0][0][t],tocol,t);\n     if(t+1==6){\n\t  copymap(t,t+1);\n\t  recmap(0,0,map[0][0][t+1],C,t+1);\n\t  for(int i=0;i<H;i++){\n\t       for(int j=0;j<W;j++){\n\t\t    visited[i][j]=false;\n\t       }\n\t  }\n\t  ans=max(ans,countup(0,0,C,t+1));\n\t  return;\n     }\n     for(int i=0;i<MAXCOL;i++){\n\t  copymap(t,t+1);\n\t  rec(i,t+1);\n     }\n}\n\nvoid solve(){\n     ans=0;\n     for(int i=0;i<MAXCOL;i++){\n\t  copymap(0,1);\n\t  rec(i,1);\n     }\n}\n     \nint main(){\n     while(cin>>H>>W>>C,H||W||C){\n\t  --C;\n\t  for(int i=0;i<H;i++){\n\t       for(int j=0;j<W;j++){\n\t\t    int t;\n\t\t    cin>>t;\n\t\t    --t;\n\t\t    map[i][j][0]=t;\n\t       }\n\t  }\n\t  solve();\n\t  cout<<ans<<endl;\n\t  /*for(int i=0;i<H;i++){\n\t    for(int j=0;j<W;j++){\n\t    cout<<map[i][j][3]+1;\n\t    }\n\t    cout<<endl;\n\t    }\n\t    cout<<endl;*/\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int h,w,c;\n    cin >> h >> w >> c;\n    if(h==0) return 0;\n    vector<vector<int>> p(h,vector<int>(w)),f(h,vector<int>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> p[i][j];\n        p[i][j]--;\n      }\n    }\n    vector<int> hen(5);\n    queue<pair<int,int>> bfs;\n    pair<int,int> now;\n    int sc;\n    int ans=0,count;\n    int nx,ny;\n    int hou[5]={0,1,0,-1,0};\n    for(hen[0]=0;hen[0]<6;hen[0]++){\n      for(hen[1]=0;hen[1]<6;hen[1]++){\n        for(hen[2]=0;hen[2]<6;hen[2]++){\n          for(hen[3]=0;hen[3]<6;hen[3]++){\n            hen[4]=c-1;\n            for(int i=0;i<h;i++){\n              for(int j=0;j<w;j++){\n                f[i][j]=p[i][j];\n              }\n            }\n            for(int i=0;i<5;i++){\n              sc=f[0][0];\n              if(sc!=hen[i]){\n                bfs.push({0,0});\n                f[0][0]=hen[i];\n                while(!bfs.empty()){\n                  now=bfs.front();\n                  bfs.pop();\n                  for(int j=0;j<4;j++){\n                    nx=now.first+hou[j];\n                    ny=now.second+hou[j+1];\n                    if(0<=nx&&nx<w&&0<=ny&&ny<h){\n                      if(f[ny][nx]==sc){\n                        bfs.push({nx,ny});\n                        f[ny][nx]=hen[i];\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            sc=f[0][0];\n            bfs.push({0,0});\n            count=1;\n            f[0][0]=-1;\n            while(!bfs.empty()){\n              now=bfs.front();\n              bfs.pop();\n              for(int j=0;j<4;j++){\n                nx=now.first+hou[j];\n                ny=now.second+hou[j+1];\n                if(0<=nx&&nx<w&&0<=ny&&ny<h){\n                  if(f[ny][nx]==sc){\n                    bfs.push({nx,ny});\n                    f[ny][nx]=-1;\n                    count++;\n                  }\n                }\n              }\n            }\n            ans=max(ans,count);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n\nconst int MAX_HW = 8 + 2;\nconst int MAX_C  = 6;\nint dy[] = { -1, 0, 1, 0 };\nint dx[] = { 0, -1, 0, 1 };\n\nint H, W, C;\nint fd[MAX_HW][MAX_HW];\nint tp[MAX_HW][MAX_HW];\nbool used[MAX_HW][MAX_HW];\n\nvoid dfs ( int x, int y, int dest, int src, int m[MAX_HW][MAX_HW] )\n{\n\tif (dest == src || m[y][x] == -1 || m[y][x] != dest) { return; }\n\tm[y][x] = src;\n\tfor (int d = 0; d < 4; ++d) {\n\t\tdfs(x+dx[d], y+dy[d], dest, src, m);\n\t}\n}\n\nint bfs ( int x, int y, int color, int m[MAX_HW][MAX_HW] )\n{\n\tint count = 0;\n\tfor (int i = 0; i < MAX_HW; ++i) {\n\t\tfill(used[i], used[i]+MAX_HW, false);\n\t}\n\tqueue<PII> que;\n\tque.push(PII(x, y));\n\twhile(!que.empty()) {\n\t\tPII p = que.front(); que.pop();\n\t\tif (!used[p.Y][p.X]) { ++count; }\n\t\tused[p.Y][p.X] = true;\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tint mx = p.X + dx[d], my = p.Y + dy[d];\n\t\t\tif (!used[my][mx] && m[my][mx] == color) {\n\t\t\t\tque.push(PII(mx, my));\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid copy2dArray ( int h, int w, int d[MAX_HW][MAX_HW], int s[MAX_HW][MAX_HW] )\n{\n\tfor (int y = 0; y < h; ++y) {\n\t\tfor (int x = 0; x < w; ++x) {\n\t\t\td[y][x] = s[y][x];\n\t\t}\n\t}\n}\n\nint main ( void )\n{\n\twhile (cin >> H >> W >> C, H|W|C) {\n\t\tfor (int i = 0; i < MAX_HW; ++i) {\n\t\t\tfill(fd[i], fd[i]+MAX_HW, -1);\n\t\t\tfill(tp[i], tp[i]+MAX_HW, -1);\n\t\t}\n\t\tfor (int y = 1; y <= H; ++y) {\n\t\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\t\tcin >> fd[y][x];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int a = 1; a <= MAX_C; ++a) {\n\t\t\tfor (int b = 1; b <= MAX_C; ++b) {\n\t\t\t\tif (b == a) { continue; }\n\t\t\t\tfor (int c = 1; c <= MAX_C; ++c) {\n\t\t\t\t\tif (b == c) { continue; }\n\t\t\t\t\tfor (int d = 1; d <= MAX_C; ++d) {\n\t\t\t\t\t\tif (c == d) { continue; }\n\t\t\t\t\t\tcopy2dArray(MAX_HW, MAX_HW, tp, fd);\n\t\t\t\t\t\tint &color = tp[1][1];\n\t\t\t\t\t\tdfs(1, 1, color, a, tp);\n\t\t\t\t\t\tdfs(1, 1, color, b, tp);\n\t\t\t\t\t\tdfs(1, 1, color, c, tp);\n\t\t\t\t\t\tdfs(1, 1, color, d, tp);\n\t\t\t\t\t\tdfs(1, 1, color, C, tp);\n\t\t\t\t\t\tans = max(ans, bfs(1, 1, C, tp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pi;\n\nvvi f;\nint h,w,c;\n\nint dx[]={1,-1,0,0}, dy[]={0,0,1,-1};\n\nmap<pair<pi,vvi>,int> dp;\n\nint dfs(int col, int num, const vvi &field)\n{\n    pair<pi,vvi> d(pi(col,num),field);\n    if(dp.find(d) != dp.end()) return dp[d];\n\n    //BFS\n    vvi vis(h,vi(w,0));\n    //?????????????????????\n    int lu=field[0][0];\n    queue<pi> que;\n    vis[0][0]=1;\n    que.push(pi(0,0));\n    while(!que.empty())\n    {\n        pi now=que.front();\n        que.pop();\n        rep(i,4)\n        {\n            int nx=now.se+dx[i], ny=now.fi+dy[i];\n            if(0<=nx&&nx<w && 0<=ny&&ny<h)\n            {\n                if(!vis[ny][nx] && field[ny][nx]==lu)\n                {\n                    vis[ny][nx]=1;\n                    que.push(pi(ny,nx));\n                }\n            }\n        }\n    }\n\n    //????????????\n    vvi nf(field);\n    rep(i,h)rep(j,w)\n    {\n        if(vis[i][j]) nf[i][j]=col;\n    }\n\n    int ret=0;\n    if(num==6)\n    {\n        //???????????????\n        int ct=0;\n        rep(i,h)rep(j,w) ct+=vis[i][j];\n        return ct;\n    }\n    else if(num==5)\n    {\n        //???????????????\n        //???????????§dfs\n        ret=max(ret,dfs(col,num+1,nf));\n    }\n    else if(num==4)\n    {\n        //????????????c??????????????¨????????????\n        ret=max(ret,dfs(c,num+1,nf));\n    }\n    else\n    {\n        //?¬???????????????¶\n        for(int i=1; i<=6; ++i)\n        {\n            //????????????????§?\n            if(i==col) continue;\n\n            ret=max(ret,dfs(i,num+1,nf));\n        }\n    }\n\n    return dp[d]=ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d %d\",&h,&w,&c),h|w|c)\n    {\n        f=vvi(h,vi(w));\n        rep(i,h)rep(j,w) scanf(\" %d\", &f[i][j]);\n\n        dp.clear();\n\n        int ans=0;\n        for(int i=1; i<=6; ++i) ans=max(ans,dfs(i,1,f));\n\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm> \n#include <map> \n#include <set>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{\"; for(auto nth : list){ cout << nth << \" \";}cout << \"}\" << endl;\n\nusing namespace std;\n\ntemplate<class T> T MIN(const T& a, const T& b) { return a < b ? a : b; }\ntemplate<class T> T MAX(const T& a, const T& b) { return a > b ? a : b; }\ntemplate<class T> void MIN_UPDATE(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void MAX_UPDATE(T& a, const T& b) { if (a < b) a = b; }\n\n\nint h,w,c;\n\nint panel[8][8];\nint c_panel[8][8];\nint ans;\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nvoid c_dfs(int y,int x,int p_c,int c_c){\n\tif(x < 0 || x >= w || y < 0 || y >= h) return;\n\tif(c_panel[y][x]!=p_c) return;\n\n\t//cout << x << \",\" << y << endl;\n\n\tc_panel[y][x] = c_c;\n\tans++;\n\n\trep(i,4){\n\t\tc_dfs(y+dy[i],x+dx[i],p_c,c_c);\t\n\t}\n}\n\nvoid init(){\n\trep(i,h) rep(j,w) c_panel[i][j] = panel[i][j];\n\tans=0;\n}\n\nvoid print(){\n\t\n\tcout << \"--------------\" << endl;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tcout << c_panel[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"--------------\" << endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> h >> w >> c;\t\n\t\tif(h==0&&w==0&&c==0) break;\n\t\tfill_n((int *)panel,sizeof(panel)/sizeof(int),-1);\t\n\t\tfill_n((int *)c_panel,sizeof(c_panel)/sizeof(int),-1);\t\t\n\t\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin >> panel[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint output=0;\n\t\trep(i,6) rep(j,6) rep(k,6) rep(l,6){\n\t\t\tinit();\n\t\t\tif(c_panel[0][0]==i+1) continue;\n\t\t\tc_dfs(0,0,c_panel[0][0],i+1);\n\t\t\tif(c_panel[0][0]==j+1) continue;\n\t\t\tc_dfs(0,0,c_panel[0][0],j+1);\n\t\t\tif(c_panel[0][0]==k+1) continue;\n\t\t\tc_dfs(0,0,c_panel[0][0],k+1);\n\t\t\tif(c_panel[0][0]==l+1) continue;\n\t\t\tc_dfs(0,0,c_panel[0][0],l+1);\n\t\t\tif(c_panel[0][0]==c) continue;\n\t\t\tc_dfs(0,0,c_panel[0][0],c);\t\n\t\t\tans=0;\n\t\t\tc_dfs(0,0,c_panel[0][0],8);\n\t\t\toutput = max(output,ans);\n\t\t}\n\n\n\t\tcout << output << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint h, w, c, s[8][8], res;\n\nint p(int d) {\n\td += c*10000;\n\tint t[8][8] = {};\n\trep(i,h) rep(j,w) t[i][j] = s[i][j];\n\trep(k,5) {\n\t\tint l = t[0][0], r = d%10;\n\t\td /= 10;\n\t\tif (l==r) continue;\n\t\tqueue<pii> q;\n\t\tq.push({0,0});\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front().fi, y = q.front().se; q.pop();\n\t\t\tt[x][y] = r;\n\t\t\trep(i,4) {\n\t\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\t\tif (ool(xx,yy,h,w) || t[xx][yy]!=l) continue;\n\t\t\t\tq.push({xx,yy});\n\t\t\t}\n\t\t}\n\t}\n\tqueue<pii> q;\n\tq.push({0,0});\n\tbool u[8][8] = {};\n\twhile (!q.empty()) {\n\t\tint x = q.front().fi, y = q.front().se; q.pop();\n\t\tu[x][y] = 1;\n\t\trep(i,4) {\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\tif (ool(xx,yy,h,w) || t[xx][yy]!=c || u[xx][yy]) continue;\n\t\t\tq.push({xx,yy});\n\t\t}\n\t}\n\tint sum = 0;\n\trep(i,h) rep(j,w) sum += u[i][j];\n\treturn sum;\n}\n\nvoid cal(int d, int t) {\n\tif (t==4) chmax(res,p(d));\n\telse repst(i,1,6) cal(d*10+i, t+1);\n}\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> c;\n\t\tif (h==0) break;\n\t\trep(i,h) rep(j,w) cin >> s[i][j];\n\t\tres = 0;\n\t\tcal(0,0);\n\t\tcout << res << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\n// #define DEBUG\n\nusing namespace std;\n\nint h, w, c;\nint p[9][9];\n\nvoid Coloring(int y, int x, int c, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      Coloring(ny, nx, c, checked);\n    }\n  }\n  p[y][x] = c;\n  checked[y][x] = false;\n}\n\nint Count(int y, int x, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return 0;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      ret += Count(ny, nx, checked);\n    }\n  }\n\n  return ret + 1; \n}\n\nint dfs(int limit, int c, int pv[10]) {\n  if (limit == 0) {\n    if (p[0][0] != c) {\n      return 0;\n    }\n    bool checked[9][9] = { false };\n    return Count(0, 0, checked);\n  }\n  int ret = 0;\n  for (int i = 1; i <= 6; i++) {\n    int tmp[9][9];\n    memcpy(tmp, p, sizeof(p));\n    bool checked[9][9] = { false };\n    Coloring(0, 0, i, checked);\n    int tpv[10] = { 0 };\n    int d = dfs(limit - 1, c, tpv);\n    memcpy(p, tmp, sizeof(p)); // UNDO\n    if (d > ret) {\n      ret = d;\n      pv[limit] = i;\n      for (int j = 0; j < limit; j++) {\n        pv[j] = tpv[j];\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> h >> w >> c;\n    if (h + w + c == 0) {\n      break;\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> p[i][j];\n      }\n    }\n    int pv[10] = { 0 };\n    cout << dfs(5, c, pv) << endl;\n   \n#ifdef DEBUG\n    for (int i = 0; i < 10; i++) {\n      cout << pv[i] << \" \\n\"[i == 9];\n    }\n#endif\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 8;\nconst int W = 8;\nconst int C = 6;\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nint h,w,c;\nint v[H][W];\n\nvoid init_next(int field[H][W], int next[H][W]){\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) next[i][j] = field[i][j];\n}\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nvoid area_dfs(const int &y, const int &x, bool f[H][W], int &res, int field[H][W]){\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(!check(ny, nx) || f[ny][nx] || field[ny][nx] != field[0][0]) continue;\n    f[ny][nx] = true;\n    res++;\n    area_dfs(ny, nx, f, res, field);\n  }\n}\n\nint area(int res[H][W]){\n  bool f[H][W];\n  int ans = 1;\n  fill(f[0], f[h], false);\n  f[0][0] = true;\n  area_dfs(0, 0, f, ans, res);\n  return ans;\n}\n\nvoid fill(const int &y, const int &x, int field[H][W], const int &num){\n  assert(num != field[0][0]);\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(!check(ny, nx) || (ny == 0 && nx == 0) || field[ny][nx] != field[0][0]) continue;\n    field[ny][nx] = num;\n    fill(ny, nx, field, num);\n  }\n}\n\nint func(int cnt, int field[H][W]){\n  int next[H][W], res = 0;\n  \n  init_next(field, next);  \n  if(next[0][0] != c) {\n    fill(0, 0, next, c);\n    next[0][0] = c;\n  }\n  res = area(next);\n  \n  if(cnt < 4){\n    for(int i=1;i<=6;i++){\n      if(i == field[0][0]) continue;\n      init_next(field, next);\n      fill(0, 0, next, i);\n      next[0][0] = i;\n      res = max(res, func(cnt+1, next));\n    }\n  }\n\n  return res;\n}\n\nvoid solve(){\n  cout << func(0, v) << endl;\n}\n\nint main(){\n  while(cin >> h >> w >> c && (h|w|c)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> v[i][j];\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint h, w, c;\n\ntypedef vector<vector<int> > matrix;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nmatrix bfs(matrix ba, int color) {\n  queue<pii> Q;\n  Q.push(pii(0,0));\n  bool visited[w][h];\n  memset(visited,0,sizeof(visited));\n\n  int hoge = ba[0][0] ;\n  \n  while(!Q.empty()) {\n    int x = Q.front().first;\n    int y = Q.front().second;\n    Q.pop();\n    if (visited[x][y]) continue;\n    visited[x][y] = 1;\n    ba[x][y] = color;\n    \n    REP(k,4) {\n      int xx = x+dx[k];\n      int yy = y+dy[k];\n\n      if (xx<0||xx>=w||yy<0||yy>=h) continue;\n      if (ba[xx][yy]!=hoge||visited[xx][yy])continue;\n      Q.push(pii(xx,yy));\n    }\n  }\n  return ba;\n}\n\nint bfs2(matrix ba) {\n  queue<pii> Q;\n  Q.push(pii(0,0));\n  bool visited[w][h];\n  memset(visited,0,sizeof(visited));\n\n  int hoge = ba[0][0] ;\n  int cnt = 0;\n  while(!Q.empty()) {\n    int x = Q.front().first;\n    int y = Q.front().second;\n    Q.pop();\n    if (visited[x][y]) continue;\n    visited[x][y] = 1;\n    cnt++;\n    \n    REP(k,4) {\n      int xx = x+dx[k];\n      int yy = y+dy[k];\n\n      if (xx<0||xx>=w||yy<0||yy>=h) continue;\n      if (ba[xx][yy] != hoge || visited[xx][yy])continue;\n      Q.push(pii(xx,yy));\n    }\n  }\n  return cnt;\n}\n\nint solve(matrix ba, int cnt) {\n  if (cnt == 5) {\n    int hoge = bfs2(ba);\n\n    return hoge;\n  }\n  int res = 0;\n  REP(i,6) {\n    if (cnt == 4)\n      res = max(res, solve(bfs(ba, c-1), cnt+1));\n    else\n      res = max(res, solve(bfs(ba, i), cnt+1));\n  }\n  return res;\n}\nint main() {\n  while(cin>>h>>w>>c, h) {\n    matrix ba(w,vector<int>(h));\n    REP(y,h)\n      REP(x,w) {\n      cin>>ba[x][y];\n      ba[x][y]--;\n    }\n    cout << solve(ba,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostReam>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint H,W,C;\nint board[8][8];\nint b[8][8];\nint check[8][8];\nint ord[5];\nint ans;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool in(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y, int color){\n    //cerr << x << \" \" << y << \" \" << color << endl;\n    check[y][x] = 1;\n    for(int k = 0; k < 4; k++){\n        int nx = x + dx[k], ny = y + dy[k];\n        if(!in(nx, ny) || b[ny][nx] != color || check[ny][nx]) continue;\n        dfs(nx, ny, color);\n    }\n}\n\nint calc(){\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            b[i][j] = board[i][j];\n        }\n    }\n    for(int t = 0; t < 5; t++){\n        //cout << ord[t] << endl;\n        memset(check, 0, sizeof check);\n        dfs(0, 0, b[0][0]);\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                if(check[i][j]) b[i][j] = ord[t];\n            }\n        }\n    }\n\n    memset(check, 0, sizeof check);\n    dfs(0, 0, b[0][0]);\n    int ret = 0;\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            if(check[i][j] && b[i][j] == C) ret++;\n        }\n    }\n    return ret;\n}\n\nvoid f(int n){\n    if(n == 5){\n        ans = max(ans, calc());\n        return;\n    }\n    for(int i = 1; i <= 6; i++){\n        ord[n] = i;\n        f(n + 1);\n    }\n}\n\nint main(){\n    while(cin >> H >> W >> C, H){\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                cin >> board[i][j];\n            }\n        }\n        ans = 0;\n        f(0);\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int N = 10;\n\nint h, w, c;\n\nstruct Point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nint bfs(vector<vector<int>> &M, int color, Point p = Point{0,0}){\n    int dis[N][N];\n    queue<Point> q;\n    rep(i,N) rep(j,N) dis[i][j] = 1e8;\n\n    dis[p.y][p.x] = 0;\n    q.push(p);\n\n    Point u;\n    int cur = M[0][0];\n    int ret = 0;\n    while(not q.empty()){\n        u = q.front(); q.pop();\n        ret++;\n        M[u.y][u.x] = color;\n        rep(i,4){\n            Point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.x < 0 || next.x >= w || next.y < 0 || next.y >= h) continue;\n            if(dis[next.y][next.x] == 1e8 && M[next.y][next.x] == cur){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                q.push(next);\n            }\n        }\n    }\n        //cout << endl;\n        //rep(i,h){ rep(j,w){ cout << M[i][j]<<' '; } cout << endl; }\n    return ret;\n}\nint dfs(vector<vector<int>> v, int k){\n    if(k == 4){\n        bfs(v,c);\n        return bfs(v,8);\n    }\n\n    int ret = 0;\n    range(i,1,7){\n        vector<vector<int>> tmp = v;\n        bfs(tmp, i);\n        ret = max(ret,dfs(tmp,k + 1));\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> h >> w >> c, h){\n\n        vector<vector<int>> v(10, vector<int>(10));\n        rep(i,h){\n            rep(j,w){\n                cin >> v[i][j];\n            }\n        }\n\n        cout << dfs(v, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint h,w,c;\nint data[8][8];\n\n\nint done[8][8];\nint change(int x,int y,int color,int to){\n\tif(y >= h || x < 0 || y < 0 || x >= w) return 0;\n\t\n\tif(data[y][x] != color) return 0;\n\telse data[y][x] = to;\n\t\n\tif(done[y][x] == true) return 0;\n\telse done[y][x] = true;\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,1,0,-1};\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tchange(x+dx[i] , y+dy[i] , color , to);\n}\nint count(int x,int y,int color){\n\tif(y >= h || x < 0 || y < 0 || x >= w) return 0;\n\tif(data[y][x] != color) return 0;\n\tif(done[y][x] == true) return 0;\n\telse done[y][x] = true;\n\tint ans = 0;\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,1,0,-1};\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tans += count(x+dx[i] , y+dy[i] , color);\n\treturn ans+1;\n}\nint ans = 0;\nint dfs(int n){\n\tif(n == 5){\n\t\tfor(int x = 0 ; x < 8 ; x++)\n\t\t\tfor(int y = 0 ; y < 8 ; y++)\n\t\t\t\tdone[x][y] = 0;\n\t\tans = max(ans,count(0,0,c));\n\t\treturn 0;\n\t}\n\tint tmp[8][8];\n\t\n\tfor(int i = 0 ; i < 6 ; i++){\n\t\tfor(int x = 0 ; x < 8 ; x++)\n\t\t\tfor(int y = 0 ; y < 8 ; y++)\n\t\t\t\ttmp[x][y] = data[x][y] ,done[x][y] = 0;\n\t\tchange(0,0,data[0][0],i);\n\t\tdfs(n+1);\n\t\t\n\t\tfor(int x = 0 ; x < 8 ; x++)\n\t\t\tfor(int y = 0 ; y < 8 ; y++)\n\t\t\t\tdata[x][y] = tmp[x][y], done[x][y] = 0;\n\t\t\n\t}\n\t\n}\nint main(){\n\twhile(cin >> h >> w >> c , h){\n\t\tc--;\n\t\tfor(int i = 0 ; i < h ; i++)\n\t\t\tfor(int j = 0; j < w ; j++)\n\t\t\t\tcin >> data[i][j] , data[i][j]--;\n\t\tans = 0;\n\t\tdfs(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll h,w,c;\n\nll field[2][10][10];\nbool used[10][10];\nll dx[] = {0,1,0,-1};\nll dy[] = {1,0,-1,0};\n\nvoid init(){\n\trep(i,h)rep(j,w){\n\t\tfield[1][i][j] = field[0][i][j];\n\t\tused[i][j] = true;\n\t}\n}\n\nvoid make(ll y,ll x,ll c){\n\t// cout << \"!!\" << y << \" \" << x << endl;\n\t// if(c == field[1][y][x])return;\n\tll cc = field[1][y][x];\n\t// cout << \"!\" << c << \" \" << field[1][y][x] << endl;\n\tfield[1][y][x] = c;\n\t// cout << cc << endl;\n\trep(i,4){\n\t\tll ny = y + dy[i];\n\t\tll nx = x + dx[i];\n\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w)continue;\n\t\t// cout << ny << \" \" << nx << \" \" << field[1][ny][nx] << endl;\n\t\tif(field[1][ny][nx] == cc)make(ny,nx,c);\n\t}\n}\n\nll count(ll y,ll x, ll c){\n\tll res = 1;\n\tused[y][x] = false;\n\trep(i,4){\n\t\tll ny = y + dy[i];\n\t\tll nx = x + dx[i];\n\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w)continue;\n\t\tif(field[1][ny][nx] == c && used[ny][nx])res += count(ny,nx,c);\n\t}\n\treturn res;\n}\n\nvoid print(){\n\trep(i,h){\n\t\trep(j,w)cout << field[1][i][j] << \" \";\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\twhile(cin >> h >> w >> c && h){\n\t\trep(i,h)rep(j,w)cin >> field[0][i][j];\n\t\tll ans = 0;\n\t\tvector<ll> v;\n\t\t// rep(i,6)v.push_back(i+1);\n\t\tFOR(i,1,6+1){\n\t\t\tv.push_back(i);\n\t\t\tFOR(j,1,6+1){\n\t\t\t\tv.push_back(j);\n\t\t\t\tFOR(k,1,6+1){\n\t\t\t\t\tv.push_back(k);\n\t\t\t\t\tFOR(l,1,6+1){\n\t\t\t\t\t\tv.push_back(l);\n\t\t\t\t\t\tv.push_back(c);\n\t\t\t\t\t\tinit();\n\t\t\t\t\t\trep(m,v.size()){\n\t\t\t\t\t\t\tif(field[1][0][0] == v[m])continue;\n\t\t\t\t\t\t\tmake(0,0,v[m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// print();\n\t\t\t\t\t\t// cout << endl;\n\t\t\t\t\t\tans = max(ans,count(0,0,c));\n\t\t\t\t\t\tv.pop_back();\n\t\t\t\t\t\tv.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tv.pop_back();\n\t\t\t\t}\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\tv.pop_back();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint h,w,c;\nint dis[10][10];\nint ans;\nint count;\nstruct po{\n  int mp[10][10];\n};\n\nstruct xy{\n  int x,y;\n};\n\nvoid deb(po t) {\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++)\n      cout << t.mp[i][j] << \" \";\n    cout << endl;\n  }\n  cout <<\"-----------------\"<<endl;\n\n}\n\n\nvoid saiki(po sta,int d){\n  // for(int i=0;i<6;i++) cout <<sta.flg[i];\n  //cout << endl;\n  count++;\n  po t = sta;\n  if(d <= 6 ) {\n    for(int i=0;i<6;i++){\n      if(t.mp[0][0] != i+1) {\n\tif(d == 5 && i != c-1) continue;\n\tqueue <xy> Q;\n\tQ.push((xy){0,0});\n\tfor(int j=0;j<h;j++) for(int k=0;k<w;k++) dis[j][k] = 0;\n\tdis[0][0] = 1;\n\tint tf = 0;\n\tint sum = 1;\n\twhile(!Q.empty()){\n\t  int dx[4] = {0,0,1,-1},dy[4] = {1,-1,0,0};\n\t  xy u = Q.front();\n\t  Q.pop();\n\t  for(int j=0;j<4;j++) {\n\t    int tx = u.x+dx[j] , ty = u.y+dy[j];\n\t    if(tx>=0 && tx<w && ty>=0 && ty<h){\n\t      if(t.mp[ty][tx]==t.mp[0][0] && dis[ty][tx]==0) {\n\t\tQ.push((xy){tx,ty});\n\t\tdis[ty][tx] = 1;\n\t\tsum++;\n\t      }\n\t      if(t.mp[ty][tx]==i+1 && d!=6) tf = 1;\n\t    }\n\t  }\n\t}\n\tpo tmp = t;\n\tif(tf == 1 && d != 6) {\n\t  for(int j=0;j<h;j++)\n\t    for(int k=0;k<w;k++)\n\t      if(dis[j][k] == 1) t.mp[j][k] = i+1;\n\t}\n\telse if(d != 6) t.mp[0][0] = i+1;\n\n\tif(t.mp[0][0] == c && d!=6) saiki(t,6); \n\tif(sum > ans && t.mp[0][0] == c )   ans = sum;\n\t      \n\tsaiki(t,d+1);\n\tt = tmp;\n      }\n    }\n  }\n}   \n\n\n\nint main() {\n\n  while(1) {\n\n    cin >> h >> w  >> c;\n    if(h == 0 && w == 0 && c == 0) break;\n    \n    po in;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin >> in.mp[i][j];\n    \n    ans = 0;\n    saiki(in,1);\n\n    cout << ans << endl;   \n    //cout <<count << endl;\n\n  }    \n\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\n\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table &state, int from, int to) {\n\tif (from==to) return;\n\tvector<pair<int,int>> stack;\n\tstack.emplace_back(1,1);\n\twhile (!stack.empty()) {\n\t\tint x,y; tie(x, y) = stack.back();\n\t\tstack.pop_back();\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == from) {\n\t\t\t\tstack.emplace_back(nx,ny);\n\t\t\t\tstate[ny][nx] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint countColor(Table & state) {\n\tvector<pair<int, int>> stack;\n\tstack.emplace_back(1, 1);\n\tint cnt = 0;\n\twhile (!stack.empty()) {\n\t\tint x,y; tie(x, y) = stack.back();\n\t\tstack.pop_back();\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == g_c) {\n\t\t\t\tstack.emplace_back(nx, ny);\n\t\t\t\tcnt++;\n\t\t\t\tstate[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(state);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w;\n\t\tif (h == 0) break;\n\t\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << recursion(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_MATRIX = 8;\ntypedef enum __COLOR{YELLOW=1, PEACH, RED, PURPLE, GREEN, BLUE, NONE_COLOR} COLOR;\ntypedef enum __CONNECT{NO_CONNECT, UP, DOWN = UP<<1,\n\tLEFT= DOWN<<1, RIGHT = LEFT<<1} CONNECT;\n\nclass PANEL{\npublic:\n\tCOLOR col;\n\tint connect;\n\tbool check;\n\tPANEL(){\n\t\tcol=NONE_COLOR;\n\t\tconnect=NO_CONNECT;\n\t\tcheck = false;\n\t}\n};\n\nint h, w;\nCOLOR dest;\n\nvoid input(PANEL **p);\nvoid output(PANEL **p);\nvoid connectCheck(PANEL ** p);\nint colChange(PANEL ** chp, COLOR chcol);\nint colChange(PANEL ** chp, COLOR chcol, int row, int column);\nint search(PANEL **p);\n\nint main()\n{\n\tint c;\n\tPANEL **p;\n\twhile(true){\n\t\tcin.clear();\n\t\tcin >> h >> w >> c;//???????????????????????\\???\n\t\tif(h==w && w==c && c==0){\n\t\t\tbreak;\n\t\t}\n\t\t//??????????????????\n\t\tp = new PANEL *[h];\n\t\tfor(int i=0; i<h; i++){\n\t\t\tp[i] = new PANEL[w];\n\t\t}\n\t\t//??????????????????\n\t\tdest = static_cast<COLOR>(c);\n\t\tinput(p);\t\t\t//???????????\\???\n\t\tconnectCheck(p);\t//????????????????????????????¢????\n\t\tcout << search(p) << endl;\n\t\tfor(int i=0; i<h; i++) delete[] p[i];\t//??????????????????\n\t\tdelete[] p;\t\t\t\t\t\t\t\t//\n\t}\n\treturn 0;\n}\n\nvoid input(PANEL **p)\n{\n\tint panel[MAX_MATRIX][MAX_MATRIX];\n\tfor(int i=0; i<h; i++){\n\t\tswitch(w){//????????°????????£?????\\???????????´\n\t\tcase 1:\n\t\t\tcin >> panel[i][0];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcin >> panel[i][0] >> panel[i][1];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3];\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4];\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5];\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5] >> panel[i][6];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5] >> panel[i][6] >> panel[i][7];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tCOLOR col = static_cast<COLOR>(panel[i][j]);\n\t\t\tif(0 <= col && col < NONE_COLOR)\n\t\t\t\tp[i][j].col = col;//????????????\n\t\t\telse\n\t\t\t\tp[i][j].col = NONE_COLOR;\n\t\t}\n\t}\n}\n\nvoid output(PANEL **p)\n{\n\tbool *downside = new bool[w],\n\t\t*rightside = new bool[w];\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tdownside[j] = rightside[j] = false;\n\t\t\tif(p[i][j].connect == NO_CONNECT) continue;\n\t\t\tif((p[i][j].connect & DOWN)!=0) downside[j] = true;\n\t\t\tif((p[i][j].connect & RIGHT)!=0) rightside[j] = true;\n\t\t}\n\t\tfor(int j=0; j<w; j++){\n\t\t\tcout << p[i][j].col;\n\t\t\tif(rightside[j]){\n\t\t\t\tcout << \"-\";\n\t\t\t}else{\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t\tfor(int j=0; j<w; j++){\n\t\t\tif(downside[j]){\n\t\t\t\tcout << \"| \";\n\t\t\t} else {\n\t\t\t\tcout << \"  \";\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tdelete[] downside;\n\tdelete[] rightside;\n}\n\nvoid connectCheck(PANEL **p)\n{\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tp[i][j].connect = NO_CONNECT;\n\t\t\t//????????°????????????\n\t\t\tif(i!=0){\n\t\t\t\t//???????????????????????´???????????£?????????\n\t\t\t\tif((p[i-1][j].connect & DOWN)!=0){\n\t\t\t\t\tp[i][j].connect |= UP;//???????????°????????????\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<h-1){\n\t\t\t\tif(p[i+1][j].col == p[i][j].col){//?????????????????¨????????????\n\t\t\t\t\tp[i][j].connect |= DOWN;//???????????°????????????\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j!=0){\n\t\t\t\t//???????????????????????´???????????£?????????\n\t\t\t\tif((p[i][j-1].connect & RIGHT)!=0){\n\t\t\t\t\tp[i][j].connect |= LEFT;//???????????°????????????\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j<w-1){\n\t\t\t\tif(p[i][j+1].col == p[i][j].col){//?????????????????¨????????????\n\t\t\t\t\tp[i][j].connect |= RIGHT;//???????????°????????????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint colChange(PANEL **chp, COLOR chcol)\n{\n\tchp[0][0].col = chcol;\n\t//?????????????????????????????¨??????????????£??????????????´???????????????\n\tif(chp[0][0].connect == NO_CONNECT) return 1;\n\tint changenum=colChange(chp, chcol, 0, 0);\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tchp[i][j].check = false;//????§????\n\t\t}\n\t}\n\treturn changenum;\n}\nint colChange(PANEL **chp, COLOR chcol, int row, int column)\n{\n\tif(chp[row][column].check) return 0;\n\tint chpanels = 1;\n\tchp[row][column].check = true;\n\tchp[row][column].col = chcol;\n\tif(chp[row][column].connect == NO_CONNECT) return chpanels;\n\tif((chp[row][column].connect & UP) != 0)\n\t\tchpanels += colChange(chp, chcol, row-1, column);\n\tif((chp[row][column].connect & DOWN) != 0)\n\t\tchpanels += colChange(chp, chcol, row+1, column);\n\tif((chp[row][column].connect & LEFT) != 0)\n\t\tchpanels += colChange(chp, chcol, row, column-1);\n\tif((chp[row][column].connect & RIGHT) != 0)\n\t\tchpanels += colChange(chp, chcol, row, column+1);\n\treturn chpanels;\n}\n\nint search(PANEL **p)\n{\n\tint ans=0;\n\tPANEL **chp1,\n\t\t**chp2,\n\t\t**chp3,\n\t\t**chp4;\n\tfor(int i=YELLOW; i<NONE_COLOR; i++){\n\t\tchp1 = new PANEL*[h];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tchp1[j]=new PANEL[w];\n\t\t\tfor(int k=0; k<w; k++) chp1[j][k] = p[j][k];\n\t\t}\n\t\tcolChange(chp1, (COLOR)i);//1??????\n\t\tconnectCheck(chp1);\n\n\t\tfor(int j=YELLOW; j<NONE_COLOR; j++){\n\t\t\tif(i==j) continue;\n\n\t\t\tchp2 = new PANEL*[h];\n\t\t\tfor(int k=0; k<h; k++){\n\t\t\t\tchp2[k]=new PANEL[w];\n\t\t\t\tfor(int l=0; l<w; l++) chp2[k][l] = chp1[k][l];\n\t\t\t}\n\t\t\tcolChange(chp2, (COLOR)j);//2??????\n\t\t\tconnectCheck(chp2);\n\n\t\t\tfor(int k=YELLOW; k<NONE_COLOR; k++){\n\t\t\t\tif(k==j) continue;\n\n\t\t\t\tchp3 = new PANEL*[h];\n\t\t\t\tfor(int l=0; l<h; l++){\n\t\t\t\t\tchp3[l]=new PANEL[w];\n\t\t\t\t\tfor(int m=0; m<w; m++) chp3[l][m] = chp2[l][m];\n\t\t\t\t}\n\t\t\t\tcolChange(chp3, (COLOR)k);//3??????\n\t\t\t\tconnectCheck(chp3);\n\n\t\t\t\tfor(int l=YELLOW; l<NONE_COLOR; l++){\n\t\t\t\t\tif(l==k) continue;\n\t\t\t\t\tif(l==dest) continue;\n\t\t\t\t\tchp4 = new PANEL*[h];\n\t\t\t\t\tfor(int m=0; m<h; m++){\n\t\t\t\t\t\tchp4[m]=new PANEL[w];\n\t\t\t\t\t\tfor(int n=0; n<w; n++) chp4[m][n] = chp3[m][n];\n\t\t\t\t\t}\n\t\t\t\t\tcolChange(chp4, (COLOR)l);//4??????\n\t\t\t\t\tconnectCheck(chp4);\n\n\t\t\t\t\tcolChange(chp4, dest);//5??????\n\t\t\t\t\tconnectCheck(chp4);\n\n\t\t\t\t\tint pnum = colChange(chp4, dest);//??°????¢????\n\t\t\t\t\tif(ans < pnum) ans=pnum;\n\n\t\t\t\t\tfor(int m=0; m<h; m++){\n\t\t\t\t\t\tdelete[] chp4[m];\n\t\t\t\t\t}\n\t\t\t\t\tdelete[] chp4;\n\n\t\t\t\t}\n\n\t\t\t\tfor(int l=0; l<h; l++){\n\t\t\t\t\tdelete[] chp3[l];\n\t\t\t\t}\n\t\t\t\tdelete[] chp3;\n\n\t\t\t}\n\n\t\t\tfor(int k=0; k<h; k++){\n\t\t\t\tdelete[] chp2[k];\n\t\t\t}\n\t\t\tdelete[] chp2;\n\n\t\t}\n\n\t\tfor(int j=0; j<h; j++){\n\t\t\tdelete[] chp1[j];\n\t\t}\n\t\tdelete[] chp1;\n\n\t}\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "//8:45\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nint dx[]={0,-1,0,1};\nint dy[]={1,0,-1,0};\n\nvoid ff(int (*p)[8],int c,int y,int x){\n  if(c==p[y][x])return;\n  int b=p[y][x];\n  p[y][x]=c;\n  for(int i=0;i<4;i++){\n    if(0<=y+dy[i]&&y+dy[i]<8&&0<=x+dx[i]&&x+dx[i]<8&&b==p[y+dy[i]][x+dx[i]]){\n      ff(p,c,y+dy[i],x+dx[i]);\n    }\n  }\n}\n\nint fc(int (*p)[8],int c,int y,int x){\n  int sum=0;\n  if(p[y][x]==c){\n    p[y][x]=0;\n    sum++;\n    for(int i=0;i<4;i++){\n      if(0<=y+dy[i]&&y+dy[i]<8&&0<=x+dx[i]&&x+dx[i]<8){\n\tsum+=fc(p,c,y+dy[i],x+dx[i]);\n      }\n    }\n  }\n  return sum;\n}\n\nint cc(int (*p)[8],int c,int r){\n  if(r>1){\n    int mc=0;\n    for(int i=1;i<=6;i++){\n      int tp[8][8];\n      memcpy(tp,p,sizeof(tp));\n      ff(tp,i,0,0);\n      mc=max(mc,cc(tp,c,r-1));\n    }\n    return mc;\n  }else{\n    int tp[8][8];\n    memcpy(tp,p,sizeof(tp));\n    ff(tp,c,0,0);\n    return fc(tp,c,0,0);\n  }\n}\n\n\nint main(){\n  for(int h,w,c;cin>>h>>w>>c,h|w|c;){\n    int panel[8][8]={};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>panel[i][j];\n      }\n    }\n    cout<<cc(panel,c,5)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint h, w, x;\n\nbool isin(int i, int j){\n\treturn i >= 0 && j >= 0 && i < h && j < w;\n}\n\nint count(VVI p, VVI &c){\n\tREP(i,h) REP(j,w) c[i][j] = 0;\n\tc[0][0] = 1;\n\tqueue<P> que;\n\tque.push(P(0,0));\n\tint res = 1;\n\tint di[] = {1, -1, 0, 0}, dj[] = {0, 0, 1, -1};\n\twhile (!que.empty()){\n\t\tP a = que.front();\n\t\tque.pop();\n\t\tint i = a.first, j = a.second;\n\t\tREP(k,4){\n\t\t\tint ii = i+di[k], jj = j+dj[k];\n\t\t\tif (!isin(ii,jj) || p[ii][jj] != p[0][0] || c[ii][jj]) continue;\n\t\t\tc[ii][jj] = 1;\n\t\t\tres++;\n\t\t\tque.push(P(ii,jj));\n\t\t}\n\t}\n\treturn res;\n}\n\nint dfs(VVI p, int t){\n\tVVI c(p);\n\tint res = count(p, c);\n\tif (t == 0) return res;\n\tif (t == 1){\n\t\tREP(i,h) REP(j,w) if (c[i][j]) p[i][j] = x;\n\t\treturn dfs(p, 0);\n\t}\n\tFOR(k,1,6){\n\t\tVVI p_temp(p);\n\t\tREP(i,h) REP(j,w) if (c[i][j]) p_temp[i][j] = k;\n\t\tres = max(res, dfs(p_temp, t-1));\n\t}\n\treturn res;\n}\n\n\nint main(){\n\twhile (cin >> h >> w >> x && h){\n\t\tVVI p(h, VI(w));\n\t\tREP(i,h) REP(j,w) cin >> p[i][j];\n\t\tcout << dfs(p, 5) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = k; i < (int)(n); i++)\n\n#define vi vector<int>\n#define pb push_back\n#define pii pair<int, int>\n#define fi first\n#define se second\n\ntypedef long long ll;\nconst int         dx[] = {0, 1, 0, -1};\nconst int         dy[] = {1, 0, -1, 0};\n\nint main() {\n    // ifstream in(\"cin.txt\");\n    // cin.rdbuf(in.rdbuf());\n    int h, w, c;\n    int prob_num = 0;\n    while (cin >> h >> w >> c, h) {\n\n        int ma = 0;\n        int p[10][10] = {};\n        rep(y, h) rep(x, w) cin >> p[y][x];\n        // prob_num += 1;\n        // if (prob_num == 23) {\n        //     cout << h << \" \" << w << \" \" << c << endl;\n        //     rep(y, h) {\n        //         rep(x, w) cout << p[y][x] << \" \";\n        //         cout << endl;\n        //     }\n        // }\n        int a[6] = {};\n        rep(bit, pow(6, 4)) {\n            int tmp_bit = bit;\n            rep(i, 4) {\n                a[i] = tmp_bit % 6;\n                tmp_bit /= 6;\n                a[i] += 1;\n                if (i > 0 && a[i - 1] == a[i]) a[0] = -1;\n                //                cout << a[i] << \" \";\n            }\n            if (a[0] == -1 || a[3] == c) continue;\n            //            cout << endl;\n            a[4] = c;\n            //            rep(i,c) cout << a[i] << \" \";\n            //            cout << endl;\n            int t[10][10];\n            rep(y, h) rep(x, w) t[y][x] = p[y][x];\n\n            rep(i, 5) {\n\n                queue<pii> que;\n                que.push(pii(0, 0));\n                int  now_color = t[0][0];\n                bool u[10][10] = {};\n                while (!que.empty()) {\n                    int x, y;\n                    tie(x, y) = que.front();\n                    que.pop();\n                    if (u[y][x]) continue;\n                    u[y][x] = true;\n                    t[y][x] = a[i];\n                    rep(d, 4) {\n                        int nx = x + dx[d];\n                        int ny = y + dy[d];\n                        if (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n                        if (u[ny][nx] || t[ny][nx] != now_color) continue;\n                        que.push(pii(nx, ny));\n                    }\n                }\n            }\n            int        cnt = 0;\n            queue<pii> qe;\n            qe.push(pii(0, 0));\n            bool uu[10][10] = {};\n\n            while (!qe.empty()) {\n                int xp, yp;\n\n                tie(xp, yp) = qe.front();\n                qe.pop();\n\n\n                if (uu[yp][xp]) continue;\n                uu[yp][xp] = true;\n                // if (cnt > 1000) {\n                //     // cout << qe.front().fi << \" : \" << qe.front().se << endl;\n                //     // rep(y, h) {\n                //     //     rep(x, w) { cout << uu[y][x] << \" \"; }\n                //     //     cout << endl;\n                //     // }\n                // }\n                cnt += 1;\n                //                memset(uu,1,sizeof(uu));\n                rep(d, 4) {\n                    int nx = xp + dx[d];\n                    int ny = yp + dy[d];\n                    if (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n                    if (uu[ny][nx]) continue;\n                    if (t[ny][nx] != c) continue;\n                    qe.push(pii(nx, ny));\n                }\n            }\n            // if (cnt == 9) cout << bit << endl;\n            ma = max(ma, cnt);\n        };\n        cout << ma << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint w, h, c;\nint field[8][8];\nint field2[8][8];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvoid change(int from, int to){\n  if(from == to) return ;\n  queue<P> que;\n  int cnt = 0;\n  que.push(P(0, 0));\n  field2[0][0] = to;\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    int x = p.first;\n    int y = p.second;\n  \n    for(int i = 0; i < 4; i++){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      if(0 <= x2 && x2 < w && 0 <= y2 && y2 < h && field2[y2][x2] == from){\n\tfield2[y2][x2] = to;\n\tque.push(P(x2, y2));\n      }\n    }\n  }\n}\n\n\nint cntr(int c){\n  int cnt = 1;\n  queue<P> que;\n  bool used[8][8];\n  memset(used, false, sizeof(used));\n  que.push(P(0, 0));\n  used[0][0] = true;\n  \n  \n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    int x = p.first;\n    int y= p.second;\n    for(int i = 0; i < 4; i++){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      if(0 <= x2 && x2 < w && 0 <= y2 && y2 < h){\n\tif(field2[y2][x2] == c && !used[y2][x2]){\n\t  cnt++;\n\t  used[y2][x2] = true;\n\t  que.push(P(x2, y2));\n\t}\n      }\n    }\n  }\n  \n  return cnt;\n}\n\nvoid cop(){\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      field2[i][j] = field[i][j];\n\n    }\n\n  }\n}\nint main(){\n  while(cin >> h >> w >> c && (h || w || c)){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tcin >> field[i][j];\n\n      }\n    }\n    int res = 0;\n    for(int i = 1; i <= 6; i++){\n      for(int j = 1; j <= 6; j++){\n\tfor(int k = 1; k <= 6; k++){\n\t  for(int l = 1; l <= 6; l++){\n\t    cop();\n\t    change(field2[0][0], i);\n\t\n\t    change(field2[0][0], j);\n\t\n\t    change(field2[0][0], k);\n\t\n\t    change(field2[0][0], l);\n\t    //    cout << 4 << endl;\n\t    change(field2[0][0], c);\n\t    //\t    cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n\t    res = max(res, cntr(c));\n\t  }\t\t   \n\t}\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int inf = 1e9;\n\nint h, w, c;\nint cnt;\nint ans;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nvoid change(VV &b, const int oc, const int nc, const int i, const int j) {\n    if (nc == oc) return;\n    if (!inside(i, j)) return;\n    if (b[i][j] != oc) return;\n    // cout << i << \" \" << j << endl;\n    b[i][j] = nc;\n    cnt++;\n    rep(k, 4) {\n        change(b, oc, nc, i + dx[k], j + dy[k]);\n    }\n}\n\n// void dfs(VV b, int nc, int step) {\n//     cout << nc << \" \" << step << endl;\n//     change(b, b[0][0], nc, 0, 0);\n//     if (step == 5) {\n//         if (b[0][0] == c) {\n//             cnt = 0;\n//             change(b, b[0][0], -1, 0, 0);\n//             ans = max(ans, cnt);\n//         }\n//         return;\n//     }\n//     rep2(nc, 1, 6 + 1) {\n//         if (nc == b[0][0]) continue;\n//         dfs(b, nc, step + 1);\n//     }\n// }\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> h >> w >> c, h) {\n        VV a(h, V(w));\n        rep(i, h) rep(j, w) cin >> a[i][j];\n\n        int ans = -1;\n        // dfs(a, a[0][0], 0);\n\n        rep(s, pow(6, 4)) {\n            // cout << s << endl;\n            VV b = a;\n            int perm = s;\n            rep(step, 4) {\n                cnt = 0;\n                change(b, b[0][0], (perm % 6) + 1, 0, 0);\n                perm /= 6;\n            }\n            cnt = 0;\n            change(b, b[0][0], c, 0, 0);\n\n            cnt = 0;\n            change(b, b[0][0], 10, 0, 0);\n            ans = max(ans, cnt);\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  Identically Colored Panels Connection\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1174&lang=jp\n*/\n\n#include <iostream>\n\nusing namespace std;\n\nint h,w,c;\nint pre[8][8];\nint p[8][8];\nint ans[4][4][4][4];\n\n// ???????????????\nvoid adj(int x, int y, int c, int tc){\n  p[x][y] = c;\n  if(tc != c){\n    if(x > 0     && p[x - 1][y] != c && p[x - 1][y] == tc){ adj(x - 1, y, c, tc); }\n    if(y > 0     && p[x][y - 1] != c && p[x][y - 1] == tc){ adj(x, y - 1, c, tc); }\n    if(x < h - 1 && p[x + 1][y] != c && p[x + 1][y] == tc){ adj(x + 1, y, c, tc); }\n    if(y < w - 1 && p[x][y + 1] != c && p[x][y + 1] == tc){ adj(x, y + 1, c, tc); }\n  }\n}\n\n// ??°??????\nint num(int x, int y, int c){\n  int a = 1;\n  p[x][y] = 7;\n\n  if(x > 0     && p[x - 1][y] == c){ a += num(x - 1, y, c); }\n  if(y > 0     && p[x][y - 1] == c){ a += num(x, y - 1, c); }\n  if(x < h - 1 && p[x + 1][y] == c){ a += num(x + 1, y, c); }\n  if(y < w - 1 && p[x][y + 1] == c){ a += num(x, y + 1, c); }\n\n  return a;\n}\n\n\nvoid printMat(){\n  for(int i = 0 ; i < h ; i++){\n    for(int j = 0 ; j < w ; j++){\n      cout << p[i][j];\n    }\n    cout << endl;\n  }\n}\n\n\nint main(void){\n  while(1){\n    cin >> h;\n    cin >> w;\n    cin >> c;\n\n    if(h == 0 && w == 0 && c == 0) break;\n\n    for(int i = 0 ; i < h ; i++){\n      for(int j = 0 ; j < w ; j++){\n        cin >> pre[i][j];\n        pre[i][j] -= 1;\n      }\n    }\n\n    int max = -1;\n    for(int c1 = 0 ; c1 < 6 ; c1++){\n      for(int c2 = 0 ; c2 < 6 ; c2++){\n        for(int c3 = 0 ; c3 < 6 ; c3++){\n          for(int c4 = 0 ; c4 < 6 ; c4++){\n\n            for(int i = 0 ; i < h ; i++){\n              for(int j = 0 ; j < w ; j++){\n                p[i][j] = pre[i][j];\n              }\n            }\n\n            adj(0,0,c1,p[0][0]);\n            adj(0,0,c2,p[0][0]);\n            adj(0,0,c3,p[0][0]);\n            adj(0,0,c4,p[0][0]);\n            adj(0,0,c-1,p[0][0]);\n//            printMat(); cout << endl;\n\n\n            int a = num(0,0,p[0][0]);\n\n            if(max < a){\n              max = a;\n            }\n          }\n        }\n      }\n    }\n\n    cout << max << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint h,w,c;\n\ninline bool in(int x, int y){\n    return 0<=x&&0<=y&&y<h&&x<w;\n}\n\nint dfs_c(vvi& g, int x, int y){\n    if(!in(x,y)) return 0;\n    if(g[y][x]==c){\n        int res=1;\n        g[y][x]=-1;\n        rep(i,4){\n            res+=dfs_c(g,x+dx[i],y+dy[i]);\n        }\n        return res;\n    } else return 0;\n}\n\nint count(vvi g){\n    return dfs_c(g,0,0);\n}\n\nvoid dfs_f(vvi& g, int ic, int fc, int x, int y){\n    if(!in(x,y)) return;\n    if(g[y][x]==ic){\n        if(g[y][x]==fc) return;\n        g[y][x]=fc;\n        rep(i,4){\n            dfs_f(g, ic, fc, x+dx[i],y+dy[i]);\n        }\n    }\n}\n\nvoid flip(vvi& g, int fc){\n    dfs_f(g,g[0][0],fc,0,0);\n}\n\nvoid print(vvi const& v){\n    rep(i,v.size()){\n        rep(j,v[0].size()){\n            cout << v[i][j]+1 << \" \";\n        }cout << endl;\n    }cout << endl;\n}\n\nint main(){\n    while(cin>>h>>w>>c && h+w+c){\n        c--;\n        vvi g(h,vi(w));\n        rep(i,h)rep(j,w){\n            cin>>g[i][j];\n            g[i][j]--;\n        }\n        int end = 7776; // 6**5\n\n        int m = 0;\n        rep(mask,end){\n            int t=mask;\n            vvi h=g;\n            // cout << mask << endl;\n            rep(i,5){\n                if(h[0][0]!=t%6){\n                    flip(h,t%6);\n                }\n                // print(h);\n                t/=6;\n            }\n            m = max(m,count(h));\n        }\n        cout << m << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint p[10][10]={0};\nint h,w,c;\nint count_max=0;\nint maxx;\n\nvoid count_panel(int x, int y, int p[10][10]){\n\tint prev=p[x][y];\n\tp[x][y] = 0;\n\tmaxx++;\n\tif(p[x-1][y]==prev) count_panel(x-1,y,p);\n\tif(p[x][y-1]==prev) count_panel(x,y-1,p);\n\tif(p[x+1][y]==prev) count_panel(x+1,y,p);\n\tif(p[x][y+1]==prev) count_panel(x,y+1,p);\n}\n\nvoid change_color(int color, int x, int y, int p[10][10]){\n\tint prev=p[x][y];\n\tp[x][y]=color;\n\tif(p[x-1][y]==prev) change_color(color,x-1,y,p);\n\tif(p[x][y-1]==prev) change_color(color,x,y-1,p);\n\tif(p[x+1][y]==prev) change_color(color,x+1,y,p);\n\tif(p[x][y+1]==prev) change_color(color,x,y+1,p);\n}\n\nvoid change_panel(int color, int p[10][10],int count){\n\tint p2[10][10]={0};\n  int i,j;\n\tfor(i=1;i<=h;i++) for(j=1;j<=w;j++) p2[i][j]=p[i][j];\n\tif(!count){\n\t\tmaxx=0;\n\t\tif(p2[1][1]!=c)change_color(c,1,1,p2);\n\t\tcount_panel(1,1,p2);\n\t\tif(count_max<maxx) count_max=maxx;\n\t\treturn;\n\t}\n  if(p2[1][1]!=color) change_color(color,1,1,p2);\n\tfor(i=1;i<=6;i++) change_panel(i,p2,(count-1));\n}\n\n\nint main(){\n\tint i,j;\n\n\twhile(cin>>h, cin>>w,\tcin>>c, h!=0){\n\t \tcount_max=0;\n\t\tfor(i=0;i<10;i++) for(j=0;j<10;j++) p[i][j]=0;\n\t\tfor(i=1;i<=h;i++) for(j=1;j<=w;j++) cin>>p[i][j];\n\t\tfor(i=1;i<=6;i++) change_panel(i,p,4);\n\t\tcout<<count_max<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > VVI;\n\nstruct State{\n  int x, y;\n  State(int x, int y): x(x), y(y){}\n};\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint H, W, c;\nint org[10][10];\nint field[10][10];\nVVI pattern;\n\nvoid dfs(vector<int> v, int color){  \n  v.push_back(color);\n  if(v.size() == 4){\n    pattern.push_back(v);\n    return;\n  }\n  for(int i = 1 ; i <= 6 ; i++){\n    dfs(v, i);\n  }\n}\n\nint bfs(vector<int> pat){\n  int tmp[10][10];\n  \n  int ret = 0;\n  \n  for(int i = 0 ; i < (int)pat.size() ; i++){\n    for(int j = 0 ; j < H ; j++)\n      for(int k = 0 ; k < W ; k++) tmp[j][k] = field[j][k];            \n\n    int color = tmp[0][0];    \n    tmp[0][0] = pat[i];\n    \n    queue<State> que;\n    que.push(State(0, 0));\n    bool used[10][10];\n    memset(used, false, sizeof(used));   \n    while(!que.empty()){\n      State q = que.front(); que.pop();    \n      \n      if(used[q.y][q.x]) continue;            \n      \n      used[q.y][q.x] = true;      \n      field[q.y][q.x] = pat[i];\n      for(int d = 0 ; d < 4 ; d++){\n\tint nx = q.x + dx[d], ny = q.y + dy[d];\n\t\n\tif(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n\tif(color == tmp[ny][nx]) que.push(State(nx, ny));\n      }      \n    }\n  }\n  \n  queue<State> que;\n  que.push(State(0, 0));\n  bool used[10][10];\n  memset(used, false, sizeof(used));\n  while(!que.empty()){\n    State q = que.front(); que.pop();\n    if(used[q.y][q.x]) continue;\n    if(field[q.y][q.x] == c) ret++;\n    used[q.y][q.x] = true;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = q.x + dx[i], ny = q.y + dy[i];\n      if(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n      if(field[ny][nx] == c) que.push(State(nx, ny));\n    }\n  }\n  return ret;  \n}\n\nvoid init(){\n  for(int i = 0 ; i < 10 ; i++)\n    for(int j = 0 ; j < 10 ; j++) org[i][j] = field[i][j] = 0;\n}\n\nint main(){ \n  \n  vector<int> v;\n  for(int i = 1 ; i <= 6 ; i++) dfs(v, i);\n\n  while(cin >> H >> W >> c, H|W|c){\n    init();\n    \n    for(int i = 0 ; i < H ; i++)\n      for(int j = 0 ; j < W ; j++) cin >> org[i][j];        \n\n    int ans = 0;    \n    for(int i = 0 ; i < (int)pattern.size() ; i++){      \n      for(int j = 0 ; j < H ; j++)\n\tfor(int k = 0 ; k < W ; k++) field[j][k] = org[j][k];\n      \n      vector<int> pat = pattern[i];\n      pat.push_back(c);\n      \n      ans = max(ans, bfs(pat));\n    }\n    \n    cout << ans << endl;\n    \n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define p(s) cout<<(s)<<endl\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint H, W, C, P[10][10];\nint tans = 0, ans = 0;\n\nbool flag[10][10], visited[10][10];\n\nvoid drow(int y, int x, int col){\n\tint precol = P[y][x];\n\tP[y][x] = col;\n\n\tvisited[y][x] = true;\n\n\tREP(k,0,4){\n\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\tif(!ck(ny,0,H) || !ck(nx,0,W)) continue;\n\t\tif(P[ny][nx] == precol && !visited[ny][nx]){\n\t\t\tdrow(ny, nx, col);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid cnt(int y, int x, int col){\n\tif(P[y][x] != col) return;\n\ttans++;\n\tvisited[y][x] = true;\n\tREP(k,0,4){\n\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\tif(!ck(ny,0,H) || !ck(nx,0,W)) continue;\n\t\tif(P[ny][nx] == col && !visited[ny][nx]){\n\t\t\t//p('e');\n\t\t\tcnt(ny, nx, col);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid dfs(int step, int col){\n\n\tif(step == 5){\n\t\ttans = 0;\n\t\tREP(i,0,H)REP(j,0,W) visited[i][j] = false;\n\t\tcnt(0,0,C);\n\t\tans = max(ans, tans);\n\t\treturn;\n\t}\n\n\tREP(i,1,7){\n\t\t//?????¶???????????£????????????\n\t\tint cp[10][10];\n\t\tREP(k,0,H)REP(l,0,W){\n\t\t\tcp[k][l] = P[k][l];\n\t\t}\n\t\tREP(k,0,H) REP(l,0,W) visited[k][l] = false;\n\t\tdrow(0,0,i);\n\t\tdfs(step+1, i);\n\t\t//????????????\n\t\tREP(k,0,H)REP(l,0,W){\n\t\t\tP[k][l] = cp[k][l];\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile(1){\n\t\tcin>>H>>W>>C;\n\t\tif(H==0) break;\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tcin>>P[i][j];\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tdfs(0,C);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//tempaa\n//#pragma GCC optimize (\"-O3\")\n#ifdef _DEBUG\n#include<cassert>\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#define r_ return\n#define v_ vector\n#define t_T template<class T>\n\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n#define over4(o1, o2, o3, o4, name, ...) name\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec v_\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\nusing vi = v_<ll>;\nusing vb = v_<bool>;\nusing vs = v_<string>;\nusing vd = v_<double>;\nusing vc = v_<char>;\nusing vp = v_<P>;\n\n//#define V v_\n#define vvt0(t) v_<v_<t>>\n#define vvt1(t, a) v_<v_<t>>a\n#define vvt2(t, a, b) v_<v_<t>>a(b)\n#define vvt3(t, a, b, c) v_<v_<t>> a(b,v_<t>(c))\n#define vvt4(t, a, b, c, d) v_<v_<t>> a(b,v_<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\n\n#define v3i(a, b, c, d) v_<v_<vi>> a(b, v_<vi>(c, vi(d)))\n#define v3d(a, b, c, d) v_<v_<vd>> a(b, v_<vd>(c, vd(d)))\n#define v3m(a, b, c, d) v_<v_<vm>> a(b, v_<vm>(c, vm(d)))\n\n\n#define PQ priority_queue<ll, v_<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nt_T T MAX() { r_ numeric_limits<T>::max(); }\nt_T T MIN() { r_ numeric_limits<T>::min(); }\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nt_T T INF() { r_ MAX<T>() / 2; }\ntemplate<> signed INF() { r_ inf; }\ntemplate<> ll INF() { r_ linf; }\ntemplate<> double INF() { r_ (double) linf * linf; }\n\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n/*@formatter:off*/\ninline void sort(string &a) { sort(all(a)); }\nt_T inline void sort(v_<T> &a) { sort(all(a)); };\nt_T inline void rsort(v_<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U> inline void sortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    sort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;;    }};//F = T<T>\n//例えばr_ p.fi + p.se;\ntemplate<class U> inline void rsortp(v_<U> &a, v_<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    rsort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;    }};\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {xx = vall;}\ntemplate<typename V, typename T>\nvoid fill(v_<V> &vecc, const T vall) {for (auto &&vx: vecc) fill(vx, vall);}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {T x;cin >> x;r_ (x);}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n\n\nstring sin() { r_ _in<string>(); }\nll lin() { r_ _in<ll>(); }\nt_T void na(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\nt_T void nad(v_<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(v_<T> &a, v_<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U, class W> void na3(v_<T> &a, v_<U> &b, v_<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\nt_T string out_m2(v_<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 20ll);    if (sz(a) == 0)r_ ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            int v = a[h][W[wi]];            str s = tos(v);            if (abs(v) == inf || abs(v) == INF<T>())s = \"e\";            lens[wi] = max(lens[wi], sz(s) + 1);            lens[wi] = max(lens[wi], sz(tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(_, lens[i]) ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            str s = tos(a[h][w]);            if (abs(a[h][w]) == inf || abs(a[h][w]) == INF<T>())s = \"e\";            ss << std::right << std::setw(lens[wi]) << s;            wi++;        }        ss << \"\" << endl;    }    r_ ss.str();}\nt_T string out_m2(v_<v_<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    r_ out_m2(a, hs, ws, key);}\nt_T string out_m2(v_<v_<v_<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    r_ ss.str();}\nstring out_m2(int a) {    stringstream ss;    ss << a;    r_ ss.str();}\nt_T string out_m2(T &a) {    stringstream ss;    ss << a;    r_ ss.str();}\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<out_m2(x) << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<out_m2(x)<<\", \"<< debugName(y)<<\" = \"<<out_m2(y)<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<out_m2(x)  << \", \" <<  debugName(y)<<\" = \"<<out_m2(y) <<\", \" debugName(z)<<\" = \"<<out_m2(z) <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<out_m2(x) <<\", \" <<   debugName(y)<<\" = \"<<out_m2(y) <<\", \" <<  debugName(z)<<\" = \"<<out_m2(z) <<\", \" <<  debugName(a)<<\" = \"<<out_m2(a)<<\", \" <<  debugName(b)<<\" = \"<<out_m2(b)<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nll gcd(ll a, ll b) { r_ b ? gcd(b, a % b) : a; }\nll gcd(vi b) {ll res = b[0];for (auto &&v :b)res = gcd(v, res);r_ res;}\nll lcm(ll a, ll b) { r_ a / gcd(a, b) * b; }\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    r_ res;}\nt_T v_<T> rev(v_<T> &a) {    auto b = a;    reverse(all(b));    r_ b;}\nstr rev(str &a) {str s = a;reverse(all(s));r_ s;}\nll ceil(ll a, ll b) {if (b == 0) {cerr<<\"ceil\"<<endl;exit(1);r_ -1;} else r_ (a + b - 1) / b;}\nll sqrt(ll a) {    if (a < 0) {        cerr<<\"sqrt\"<<endl;        exit(1);    }    ll res = (ll) std::sqrt(a);    while (res * res < a)res++;    r_ res;}\ndouble log(double e, double x) { r_ log(x) / log(e); }\nll sig(ll t) { r_ (1 + t) * t / 2; }\nll sig(ll s, ll t) { r_ (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {    vi res;    double lim = std::sqrt(v);    rep(i, 1, lim+1){        if (v % i == 0) {            res.pb(i);            if (i != v / i)res.pb(v / i);        }    }    r_ res;}\nvb isPrime;\nvi primes;\n\nvoid setPrime() {    int len = 4010101;    isPrime.resize(4010101);    fill(isPrime, true);    isPrime[0] = isPrime[1] = false;    for (int i = 2; i <= sqrt(len) + 5; ++i) {        if (!isPrime[i])continue;        for (int j = 2; i * j < len; ++j) {            isPrime[i * j] = false;        }    }    rep(i, len)if (isPrime[i])primes.pb(i);}\n\nvi factorization(int v) {    int tv = v;    vi res;    if (isPrime.size() == 0)setPrime();    for (auto &&p :primes) {        if (v % p == 0)res.push_back(p);        while (v % p == 0) {            v /= p;        }        if (v == 1 || p * p > tv)break;    }    if (v > 1)res.pb(v);    r_ res;}\ninline bool inside(int h, int w, int H, int W) { r_ h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { r_ l <= v && v < r; }\n\n\nt_T v_<T> ruiv(v_<T> &a) {    v_<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    r_ ret;}\n//imoは0-indexed\n//ruiは1-indexed\nt_T v_<T> imo(v_<T> &v) {    v_<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    r_ ret;}\n\n#define ins inside\nll u0(ll a) { r_ a < 0 ? 0 : a; }\nt_T v_<T> u(const v_<T> &a) {\n    v_<T> ret = a;fora(v, ret)v = u0(v);r_ ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    r_ a;\n}\ntemplate<class T, class U> v_<T> &operator+=(v_<T> &a, U v) {\n    a.push_back(v);\n    r_ a;\n}\ntemplate<class T> v_<T>& operator+=(v_<T> & a,const v_<T> & b){\n    fora(v, b)a += v;\n    return a;\n}\nt_T T sum(v_<T> &v, int s = 0, int t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    r_ ret;}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    r_ ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    r_ ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, v_<T> &m) {    for (auto &&v:m) os << v << \" \";    r_ os;}\nconstexpr bool bget(ll m, int keta) { r_ (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);r_ m % sinsuu;}\nll bit(int n) { r_ (1LL << (n)); }\nll bit(int n, int sinsuu) { r_ (ll) pow(sinsuu, n); }\nint mask(int n) { r_ (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {if (a < b) {a = b;r_ true;}r_ false;}\ntemplate<class U> inline bool chma(const U &b) { r_ chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        r_ true;    }    r_ false;}\ntemplate<class U> inline bool chmi(const U &b) { r_ chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {    int res = a[0];    fora(v, a) {        res = max(res, v);    }    r_ res;}\nint min(vi &a) {    int res = a[0];    fora(v, a) {        res = min(res, v);    }    r_ res;}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { r_ T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { r_ fixed_point<T>{std::forward<T>(t)}; }\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))r_ i; }r_ i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))r_ i;    }    r_ i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))r_ i; }    r_ i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\nvi compress(vi &A) {    vi B = A;    sort(B);    unique(B);    vi inds(sz(B));    rep(i, sz(A)) {        int ind = lower_bound(all(B), A[i]) - B.begin();        inds[ind] = A[i];        A[i] = ind;    }    return inds;}\nvi compress(vi &A, umapi& map){    vi i_v = compress(A);    rep(i, sz(i_v)){        map[i_v[i]] = i;    }    return i_v;}\n\nt_T void out2(T head) {    cout << head;}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";      out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";        out2(tail...);    cout << \"\" << endl;}\nt_T void out(T head) {    cout << head << endl; }\nt_T void out(const vector<T>& A) {    rep(i, sz(A)-1){        cout<<A[i]<<\" \";    }    cout<<A[sz(A)-1]<< endl;}\nvoid out() { cout << \"\" << endl; }\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\nvi iota(ll s, ll len) {    vi ve(len);    iota(all(ve), s);    return ve;}\n\n\n/*@formatter:on*/\nint N, M, H, W;\nvi A, B, C;\n//14:40\n//temp\nvoid solve() {\n    while (1) {\n        din(H, W, C);\n        if (!H && !W && !C)break;\n        vvi(S);\n        nt(S, H, W);\n//        vi p = iota(1, 6);\n        int ma=0;\n        deb(H, W, C);\n//        do {\n        rep(mas, (int)pow(6, 5)){\n            auto get=[&](int i){\n                return bget(mas, i, 6)+1;\n            };\n            auto T = S;\n//            deb(p);\n#define S !not_use!\n            rep(ni, 5) {\n                int i = get(ni);\n                vvb(was, H, W);\n                fix([&](auto ds, int h, int w, int fc, int tc) -> void {\n//                    deb(h, w, fc, tc);\n                    if (T[h][w] != fc)return;\n                    if(was[h][w])return;\n                    was[h][w]=true;\n                    T[h][w] = tc;\n                    mei(nh, nw, h, w) {\n                        ds(nh, nw, fc, tc);\n                    }\n                })(0, 0, T[0][0], i);\n            }\n            int su=\n            fix([&](auto cou, int h, int w, int c) -> int {\n                if (T[h][w] != c)return 0;\n                T[h][w]=-1;\n                int res = 1;\n                mei(nh, nw, h, w) {\n                    res += cou(nh, nw, c);\n                }\n                return res;\n            })(0,0,C);\n//            deb(su);\n            chma(ma, su);\n        }\n        out(ma);\n    }\n\n}\n\n\nsigned main() {\n    solve();\n    r_ 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\nint h, w, c;\nint visited[8][8];\n\nvoid change(vector<vector<int> >& board, const int to, const int prev, int x = 0, int y = 0) {\n\tboard[y][x] = to;\n\tfor(int i = 0; i < 4; ++i) {\n\t\tconst int nx = x + dx[i], ny = y + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h)\n\t\t\tcontinue;\n\n\t\tif(board[ny][nx] == prev)\n\t\t\tchange(board, to, prev, nx, ny);\n\t}\n}\n\nint dfs(const vector<vector<int> >& board, int x, int y) {\n\tvisited[y][x] = true;\n\tint res = 1;\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tconst int nx = x + dx[i], ny = y + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h)\n\t\t\tcontinue;\n\n\t\tif(!visited[ny][nx] && board[ny][nx] == board[y][x])\n\t\t\tres += dfs(board, nx, ny);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w >> c, h) {\n\t\tvector<vector<int> > board(h, vector<int>(w));\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tcin >> board[i][j];\n\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= 6; ++i) {\n\t\t\tif(i == board[0][0])\n\t\t\t\tcontinue;\n\n\t\t\tvector<vector<int> > one(board);\n\t\t\tchange(one, i, board[0][0]);\n\t\t\tfor(int j = 1; j <= 6; ++j) {\n\t\t\t\tif(j == i)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tvector<vector<int> > two(one);\n\t\t\t\tchange(two, j, two[0][0]);\n\t\t\t\tfor(int k = 1; k <= 6; ++k) {\n\t\t\t\t\tif(k == j)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tvector<vector<int> > three(two);\n\t\t\t\t\tchange(three, k, three[0][0]);\n\t\t\t\t\tfor(int l = 1; l <= 6; ++l) {\n\t\t\t\t\t\tif(l == k || l == c)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tvector<vector<int> > four(three);\n\t\t\t\t\t\tchange(four, l, four[0][0]);\n\t\t\t\t\t\tchange(four, c, four[0][0]);\n\t\t\t\t\t\tmemset(visited, false, sizeof(visited));\n\t\t\t\t\t\tchmax(ans, dfs(four, 0, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=10005,INF=1<<29;\ntypedef vector<vector<int>> mat;\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\nint ans,H,W,X;\nvoid DFS(mat S,int turn){\n    if(turn==4){\n        mat cha(H,vector<int>(W));\n        cha[0][0]=1;\n        queue<pair<int,int>> Q;\n        Q.push({0,0});\n        \n        while(!Q.empty()){\n            int i=Q.front().first,j=Q.front().second;\n            Q.pop();\n            for(int k=0;k<4;k++){\n                int h=i+dh[k],w=j+dw[k];\n                if(h<0||h>=H||w<0||w>=W) continue;\n                if(cha[h][w]) continue;\n                if(S[h][w]==S[i][j]){\n                    cha[h][w]=1;\n                    Q.push({h,w});\n                }\n            }\n        }\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(cha[i][j]) S[i][j]=X;\n                cha[i][j]=0;\n            }\n        }\n        \n        int cnt=0;\n        \n        cha[0][0]=1;\n        Q.push({0,0});\n        \n        while(!Q.empty()){\n            int i=Q.front().first,j=Q.front().second;\n            Q.pop();\n            for(int k=0;k<4;k++){\n                int h=i+dh[k],w=j+dw[k];\n                if(h<0||h>=H||w<0||w>=W) continue;\n                if(cha[h][w]) continue;\n                if(S[h][w]==S[i][j]){\n                    cha[h][w]=1;\n                    Q.push({h,w});\n                }\n            }\n        }\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(cha[i][j]) cnt++;\n            }\n        }\n        \n        ans=max(ans,cnt);\n    }else{\n        for(int to=1;to<=6;to++){\n            mat cha(H,vector<int>(W)),T(H,vector<int>(W));\n            \n            queue<pair<int,int>> Q;\n            cha[0][0]=1;\n            Q.push({0,0});\n            while(!Q.empty()){\n                int i=Q.front().first,j=Q.front().second;\n                Q.pop();\n                for(int k=0;k<4;k++){\n                    int h=i+dh[k],w=j+dw[k];\n                    if(h<0||h>=H||w<0||w>=W) continue;\n                    if(cha[h][w]) continue;\n                    if(S[h][w]==S[i][j]){\n                        cha[h][w]=1;\n                        Q.push({h,w});\n                    }\n                }\n            }\n            \n            for(int i=0;i<H;i++){\n                for(int j=0;j<W;j++){\n                    if(cha[i][j]) T[i][j]=to;\n                    else T[i][j]=S[i][j];\n                }\n            }\n            \n            DFS(T,turn+1);\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin>>H>>W>>X;\n        if(H+W+X==0) break;\n        ans=0;\n        mat S(H,vector<int>(W));\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>S[i][j];\n            }\n        }\n        DFS(S,0);\n        \n        cout<<ans<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// IdenticallyColoredPanelsConnection.cpp\n#include <iostream>\nusing namespace std;\n\n#define SCAST(type, data) static_cast<type>((data))\n\nconst int MAX_MATRIX = 8;//??????????????§??°\n\ntypedef enum __COLOR{//???\n\tYELLOW=1, PEACH, RED, PURPLE, GREEN, BLUE, NONE_COLOR\n} COLOR;\ntypedef enum __CONNECT{//????????????????????°\n\tNO_CONNECT, UP=1, DOWN = 1<<1, LEFT= 1<<2, RIGHT = 1<<3\n} CONNECT;\n\nclass PANEL{\npublic:\n\tCOLOR col;//???????????????\n\tint connect;//????????£?????????\n\tbool check;//?????????????????§??????????????????????´?\n\tPANEL(){\n\t\tcol=NONE_COLOR;//????????¶???????????????\n\t\tconnect=NO_CONNECT;\n\t\tcheck = false;//????????§??????\n\t}\n};\n\nint h, w;\nCOLOR dest;\n\nvoid input(PANEL **p);\nint connectCheck(PANEL ** p);\nvoid colChange(PANEL ** chp, COLOR chcol);\nvoid colChange(PANEL ** chp, COLOR chcol, int row, int column);\nint search(PANEL **p);\n\nint main()\n{\n\tint c;\n\tPANEL **p;\n\twhile(true){\n\t\tcin.clear();//??\\??????????????????????????¢??????\n\t\tcin >> h >> w >> c;//???????????????????????\\???\n\t\tif(h==w && w==c && c==0){\n\t\t\tbreak;\n\t\t}\n\t\t//??????????????????\n\t\tp = new PANEL *[h];// h ????????????\n\t\tfor(int i=0; i<h; i++){\n\t\t\tp[i] = new PANEL[w];// i ????????¨??? w ?????????????????????\n\t\t}\n\t\t//??????????????????\n\t\tdest = SCAST(COLOR, c);\n\t\tinput(p);\t\t\t//???????????\\???\n\t\tconnectCheck(p);\t//????????????????????????????¢????\n\t\tcout << search(p) << endl;//?????°?????????\n\t\tfor(int i=0; i<h; i++) delete[] p[i];\t//??????????????????\n\t\tdelete[] p;\t\t\t\t//\n\t}\n\treturn 0;\n}\n\nvoid input(PANEL **p)\n\t/*????????????????????\\?????????\n\t* p ??\\?????????????????????????????????\n\t*/\n{\n\tint panel[MAX_MATRIX][MAX_MATRIX];\n\tfor(int i=0; i<h; i++){\n\t\tswitch(w){//????????°????????£?????\\???????????´\n\t\tcase 1:\n\t\t\tcin >> panel[i][0];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcin >> panel[i][0] >> panel[i][1];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3];\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4];\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5];\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5] >> panel[i][6];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5] >> panel[i][6] >> panel[i][7];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tCOLOR col = SCAST(COLOR, panel[i][j]);\n\t\t\tif(0 < col && col < NONE_COLOR)\n\t\t\t\tp[i][j].col = col;//????????????\n\t\t\telse\n\t\t\t\tp[i][j].col = NONE_COLOR;//???????????\\????????´???????????????\n\t\t}\n\t}\n}\n\nint connectCheck(PANEL **p)\n\t/*?????????????£?????????????????????§????????????\n\t* p ?????§????????????????????????????????????\n\t*/\n{\n\tint cnum = 1;\n\tbool lineCheck = false, connect00 = true;\n\tif(p[0][0].col == dest) p[0][0].check = true;\n\tfor(int i=0; i<h; i++){\n\t\tlineCheck = false;\n\t\tfor(int j=0; j<w; j++){\n\t\t\tp[i][j].connect = NO_CONNECT;\n\t\t\t//????????°????????????\n\t\t\tif(i!=0){\n\t\t\t\t//???????????????????????´???????????£?????????\n\t\t\t\tif((p[i-1][j].connect & DOWN)!=0){\n\t\t\t\t\tp[i][j].connect |= UP;//???????????°????????????\n\t\t\t\t\tif(connect00 && p[i-1][j].col == dest && !p[i-1][j].check){\n\t\t\t\t\t\tcnum++;\n\t\t\t\t\t\tp[i-1][j].check = true;\n\t\t\t\t\t\tlineCheck = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<h-1){\n\t\t\t\tif(p[i+1][j].col == p[i][j].col){//?????????????????¨????????????\n\t\t\t\t\tp[i][j].connect |= DOWN;//???????????°????????????\n\t\t\t\t\tif(connect00 && p[i+1][j].col == dest && !p[i+1][j].check){\n\t\t\t\t\t\tcnum++;\n\t\t\t\t\t\tp[i+1][j].check = true;\n\t\t\t\t\t\tlineCheck = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j!=0){\n\t\t\t\t//???????????????????????´???????????£?????????\n\t\t\t\tif((p[i][j-1].connect & RIGHT)!=0){\n\t\t\t\t\tp[i][j].connect |= LEFT;//???????????°????????????\n\t\t\t\t\tif(connect00 && p[i][j-1].col == dest && !p[i][j-1].check){\n\t\t\t\t\t\tcnum++;\n\t\t\t\t\t\tp[i][j-1].check = true;\n\t\t\t\t\t\tlineCheck = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j<w-1){\n\t\t\t\tif(p[i][j+1].col == p[i][j].col){//?????????????????¨????????????\n\t\t\t\t\tp[i][j].connect |= RIGHT;//???????????°????????????\n\t\t\t\t\tif(connect00 && p[i][j+1].col == dest && !p[i][j+1].check){\n\t\t\t\t\t\tcnum++;\n\t\t\t\t\t\tp[i][j+1].check = true;\n\t\t\t\t\t\tlineCheck = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!lineCheck) connect00 = false;\n\t}\n\tfor(int i=0; i<h; i++)\n\t\tfor(int j=0; j<w; j++)\n\t\t\tp[i][j].check = false;\n\treturn cnum;\n}\n\nvoid colChange(PANEL **chp, COLOR chcol)\n\t/*?????????????????????????????????????????????\n\t* chp\t????????????????????????\n\t* chcol\t??????????????????\n\t*/\n{\n\tchp[0][0].col = chcol;\n\t//?????????????????????????????¨??????????????£??????????????´???????????????\n\tif(chp[0][0].connect == NO_CONNECT) return;\n\tcolChange(chp, chcol, 0, 0);//?????°??¨??? colChange ???????????????\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tchp[i][j].check = false;//????§????\n\t\t}\n\t}\n}\nvoid colChange(PANEL **chp, COLOR chcol, int row, int column)\n\t/*?????????????????????????????????????????°??¨??????\n\t* chp\t\t????????????????????????\n\t* chcol\t\t??????????????????\n\t* row\t\t?????¨??????\n\t* column\t   ??????\n\t*/\n{\n\tif(chp[row][column].check) return;//?????§?????????????????????????????¨??????????????????\n\tchp[row][column].check = true;\t//?????§?????????????????????\n\tchp[row][column].col = chcol;\t//?????¨????????????????????????????????????\n\n\tif((chp[row][column].connect & UP) != 0)\n\t\tcolChange(chp, chcol, row-1, column);\n\n\tif((chp[row][column].connect & DOWN) != 0)\n\t\tcolChange(chp, chcol, row+1, column);\n\n\tif((chp[row][column].connect & LEFT) != 0)\n\t\tcolChange(chp, chcol, row, column-1);\n\n\tif((chp[row][column].connect & RIGHT) != 0)\n\t\tcolChange(chp, chcol, row, column+1);\n}\n\nint search(PANEL **p)\n\t/*5??????????????????????????¨???????????????????????§?????°???????????????????????????\n\t* p ?????????????????????\n\t* ?????§?????°?????????\n\t*/\n{\n\tint ans=0;//??????\n\tPANEL **chp1,\n\t\t**chp2,\n\t\t**chp3,\n\t\t**chp4;//????????????????????????\n\tfor(int i=YELLOW; i<NONE_COLOR; i++){\n\t\tchp1 = new PANEL*[h];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tchp1[j]=new PANEL[w];\n\t\t\tfor(int k=0; k<w; k++)chp1[j][k] = p[j][k];//????????¶???????????????????????????\n\t\t}\n\t\tcolChange(chp1, SCAST(COLOR, i));//1??????\n\t\tconnectCheck(chp1);//?????????????????????????¢????\n\n\t\tfor(int j=YELLOW; j<NONE_COLOR; j++){\n\t\t\tif(i==j) continue;\n\n\t\t\tchp2 = new PANEL*[h];\n\t\t\tfor(int k=0; k<h; k++){\n\t\t\t\tchp2[k]=new PANEL[w];\n\t\t\t\tfor(int l=0; l<w; l++) chp2[k][l] = chp1[k][l];\n\t\t\t}\n\t\t\tcolChange(chp2, SCAST(COLOR, j));//2??????\n\t\t\tconnectCheck(chp2);\n\n\t\t\tfor(int k=YELLOW; k<NONE_COLOR; k++){\n\t\t\t\tif(k==j) continue;\n\n\t\t\t\tchp3 = new PANEL*[h];\n\t\t\t\tfor(int l=0; l<h; l++){\n\t\t\t\t\tchp3[l]=new PANEL[w];\n\t\t\t\t\tfor(int m=0; m<w; m++) chp3[l][m] = chp2[l][m];\n\t\t\t\t}\n\t\t\t\tcolChange(chp3, SCAST(COLOR, k));//3??????\n\t\t\t\tconnectCheck(chp3);\n\n\t\t\t\tfor(int l=YELLOW; l<NONE_COLOR; l++){\n\t\t\t\t\tif(l==k) continue;\n\t\t\t\t\tif(l==dest) continue;\n\t\t\t\t\tchp4 = new PANEL*[h];\n\t\t\t\t\tfor(int m=0; m<h; m++){\n\t\t\t\t\t\tchp4[m]=new PANEL[w];\n\t\t\t\t\t\tfor(int n=0; n<w; n++) chp4[m][n] = chp3[m][n];\n\t\t\t\t\t}\n\t\t\t\t\tcolChange(chp4, SCAST(COLOR, l));//4??????\n\t\t\t\t\tconnectCheck(chp4);\n\n\t\t\t\t\tcolChange(chp4, dest);//5???????????????????????????????????????\n\n\t\t\t\t\tint pnum = connectCheck(chp4);//5???????????\\?¶??¢??????¨??°????¢????\n\t\t\t\t\tif(ans < pnum) {//?????¨????????§?????°??¨?????????\n\t\t\t\t\t\tans=pnum;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int m=0; m<h; m++){\n\t\t\t\t\t\tdelete[] chp4[m];\n\t\t\t\t\t}\n\t\t\t\t\tdelete[] chp4;\n\n\t\t\t\t}\n\n\t\t\t\tfor(int l=0; l<h; l++){\n\t\t\t\t\tdelete[] chp3[l];\n\t\t\t\t}\n\t\t\t\tdelete[] chp3;\n\n\t\t\t}\n\n\t\t\tfor(int k=0; k<h; k++){\n\t\t\t\tdelete[] chp2[k];\n\t\t\t}\n\t\t\tdelete[] chp2;\n\n\t\t}\n\n\t\tfor(int j=0; j<h; j++){\n\t\t\tdelete[] chp1[j];\n\t\t}\n\t\tdelete[] chp1;\n\n\t}\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <vector>\n#include <numeric>\n#include <iterator>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n\n#define FF first\n#define SS second\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n/*\n#define SIZE 500000\nvector<ll> table(SIZE);\n\n\n\nvoid sieve_of_eratosthenes() {\n\tiota(ALL(table), 0);\n\tfor (int i = 2; i < SIZE; ++i)\n\t\ttable[i] = i;\n\tfor (int i = 2; i*i < SIZE; ++i)\n\tif (table[i])\n\tfor (int j = i*i; j < SIZE; j += i)\n\t\ttable[j] = 0;\n}*/\n\ntypedef array<array<int, 10>, 10> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid dd(Table &state, int from, int to) {\n\tif (from==to) return;\n\tvector<pair<int,int>> stack;\n\tstack.emplace_back(1,1);\n\twhile (!stack.empty()) {\n\t\tauto p = stack.back();\n\t\tstack.pop_back();\n\t\tint x = p.FF;\n\t\tint y = p.SS;\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == from) {\n\t\t\t\tstack.emplace_back(nx,ny);\n\t\t\t\tstate[ny][nx] = to;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint g_c;\n\nint cc(Table & state) {\n\tvector<pair<int, int>> stack;\n\tstack.emplace_back(1, 1);\n\tint cnt = 0;\n\twhile (!stack.empty()) {\n\t\tauto p = stack.back();\n\t\tstack.pop_back();\n\t\tint x = p.FF;\n\t\tint y = p.SS;\n\n\t\tREP(i, 4) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (state[ny][nx] == g_c) {\n\t\t\t\tstack.emplace_back(nx, ny);\n\t\t\t\tcnt++;\n\t\t\t\tstate[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint walk(int depth, Table state) {\n\tif (depth == 5) {\n\t\tTable ntable = state;\n\t\tntable[1][1] = g_c;\n\t\tdd(ntable, state[1][1], g_c);\n\t\treturn cc(ntable);\n\t}\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tdd(ntable, state[1][1], i); //色変\n\t\tcnt = max(walk(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\n\nint main() {\n\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w >> g_c;\n\t\tif (h == 0) break;\n\t\tg_c--;\n\t\tTable table;\n\t\tREP(y, 10) REP(x, 10) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) {\n\t\t\tcin >> table[y + 1][x + 1];\n\t\t\ttable[y + 1][x + 1]--;\n\t\t}\n\n\t\tcout << walk(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint h,w,c;\n\nbool used[10][10];\n\nvvi coloring(int color,vvi v){\n    int c=v[0][0];\n    vector<vector<bool>> used(h,vector<bool>(w,true));\n    queue<pii> que;\n    que.push(make_pair(0,0));\n    while(!que.empty()){\n        auto q=que.front();\n        que.pop();\n        int x=q.first;\n        int y=q.second;\n\n        used[x][y]=false;\n        v[x][y]=color;\n        rep(i,4){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(nx>=0 and nx<h and ny>=0 and ny<w and v[nx][ny]==c and used[nx][ny]){\n                que.push(make_pair(nx,ny));\n            }\n        }\n    }\n    return v;\n}\n\nint counter(vvi v,int val=0){\n    int ret=0;\n    vector<vector<bool>> used(h,vector<bool>(w,true));\n    queue<pii> que;\n    que.push(make_pair(0,0));\n    used[0][0]=false;\n    while(!que.empty()){\n        auto q=que.front();\n        que.pop();\n        ret++;\n        if(val==1) cerr << q << endl;\n        int x=q.first,y=q.second;\n        rep(i,4){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(0<=nx and nx<h and 0<=ny and ny<w and used[nx][ny] and v[nx][ny]==v[0][0]){\n                used[nx][ny]=false;\n                que.push(make_pair(nx,ny));\n            }\n        }\n    }\n    return ret;\n}\n\nvoid solve(){\n    vvi p(h,vi(w));\n    rep(i,h) rep(j,w) cin>>p[i][j];\n    rep(i,h) rep(j,w) p[i][j]--;\n\n    int ans=0;\n    rep(i,6){\n        if(i==p[0][0]) continue;\n        rep(j,6) rep(k,6) rep(l,6){\n            auto v = coloring(i,p);\n//            if(i==1 and j==2 and k==3 and l==4){\n//                cerr << \"---after i-------\" << endl;\n//                rep(hoge,h) cerr << v[hoge] << endl;\n//            }\n            v = coloring(j,v);\n//           if(i==1 and j==2 and k==3 and l==4){\n//               cerr << \"---after j-------\" << endl;\n//               rep(hoge,h) cerr << v[hoge] << endl;\n//           }\n            v = coloring(k,v);\n//          if(i==1 and j==2 and k==3 and l==4){\n//              cerr << \"----after k------\" << endl;\n//              rep(hoge,h) cerr << v[hoge] << endl;\n//          }\n            v = coloring(l,v);\n//           if(i==1 and j==2 and k==3 and l==4){\n//               cerr << \"-----after l-----\" << endl;\n//               rep(hoge,h) cerr << v[hoge] << endl;\n//           }\n            v = coloring(c,v);\n//           if(i==1 and j==2 and k==3 and l==4){\n//               cerr << \"-----last -----\" << endl;\n//               rep(hoge,h) cerr << v[hoge] << endl;\n//           }\n//            int tmp;\n//            if(i==1 and j==2 and k==3 and l==4) tmp=counter(v,1);\n//            else tmp=counter(v);\n            int tmp=counter(v);\n\n            ans = max(ans,tmp);\n//            if(tmp==6) cerr << i << \" \" << j << \" \" << k << \" \" << l << endl;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>h>>w>>c){\n        if(h==0 and w==0 and c==0) break;\n        c--;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n\nconst int MAX_HW = 8 + 2;\nconst int MAX_C  = 6;\nint dy[] = { -1, 0, 1, 0 };\nint dx[] = { 0, -1, 0, 1 };\n\nint H, W, C;\nint fd[MAX_HW][MAX_HW];\nint tp[MAX_HW][MAX_HW];\nbool used[MAX_HW][MAX_HW];\n\nvoid dfs ( int x, int y, int dest, int src, int m[MAX_HW][MAX_HW] )\n{\n\tif (dest == src || m[y][x] == -1 || m[y][x] != dest) { return; }\n\tm[y][x] = src;\n\tfor (int d = 0; d < 4; ++d) {\n\t\tdfs(x+dx[d], y+dy[d], dest, src, m);\n\t}\n}\n\nint bfs ( int x, int y, int color, int m[MAX_HW][MAX_HW] )\n{\n\tint count = 0;\n\tfor (int i = 0; i < MAX_HW; ++i) {\n\t\tfill(used[i], used[i]+MAX_HW, false);\n\t}\n\tqueue<PII> que;\n\tque.push(PII(x, y));\n\twhile(!que.empty()) {\n\t\tPII p = que.front(); que.pop();\n\t\tif (!used[p.Y][p.X]) { ++count; }\n\t\tused[p.Y][p.X] = true;\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tint mx = p.X + dx[d], my = p.Y + dy[d];\n\t\t\tif (!used[my][mx] && m[my][mx] == color) {\n\t\t\t\tque.push(PII(mx, my));\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid copy2dArray ( int h, int w, int d[MAX_HW][MAX_HW], int s[MAX_HW][MAX_HW] )\n{\n\tfor (int y = 0; y < h; ++y) {\n\t\tfor (int x = 0; x < w; ++x) {\n\t\t\td[y][x] = s[y][x];\n\t\t}\n\t}\n}\n\nint main ( void )\n{\n\twhile (cin >> H >> W >> C, H|W|C) {\n\t\tfor (int i = 0; i < MAX_HW; ++i) {\n\t\t\tfill(fd[i], fd[i]+MAX_HW, -1);\n\t\t\tfill(tp[i], tp[i]+MAX_HW, -1);\n\t\t}\n\t\tfor (int y = 1; y <= H; ++y) {\n\t\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\t\tcin >> fd[y][x];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int a = 1; a <= MAX_C; ++a) {\n\t\t\tfor (int b = 1; b <= MAX_C; ++b) {\n\t\t\t\tfor (int c = 1; c <= MAX_C; ++c) {\n\t\t\t\t\tfor (int d = 1; d <= MAX_C; ++d) {\n\t\t\t\t\t\tcopy2dArray(MAX_HW, MAX_HW, tp, fd);\n\t\t\t\t\t\tint &color = tp[1][1];\n\t\t\t\t\t\tdfs(1, 1, color, a, tp);\n\t\t\t\t\t\tdfs(1, 1, color, b, tp);\n\t\t\t\t\t\tdfs(1, 1, color, c, tp);\n\t\t\t\t\t\tdfs(1, 1, color, d, tp);\n\t\t\t\t\t\tdfs(1, 1, color, C, tp);\n\t\t\t\t\t\tans = max(ans, bfs(1, 1, C, tp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <tuple>\n\nstatic size_t di[] = {size_t(-1), 0, 1, 0};\nstatic size_t dj[] = {0, size_t(-1), 0, 1};\n\nstd::vector<std::vector<int>> paint(std::vector<std::vector<int>> p, int c) {\n  size_t h = p.size();\n  size_t w = p[0].size();\n  std::queue<std::pair<size_t, size_t>> q;\n  int c0 = p[0][0];\n  if (c0 == c) return p;\n  q.emplace(0, 0);\n  while (!q.empty()) {\n    size_t i, j;\n    std::tie(i, j) = q.front();\n    q.pop();\n    if (p[i][j] == c) continue;\n    p[i][j] = c;\n    for (size_t k = 0; k < 4; ++k) {\n      size_t ni = i + di[k];\n      size_t nj = j + dj[k];\n      if (!(ni < h && nj < w)) continue;\n      if (p[ni][nj] != c0) continue;\n      q.emplace(ni, nj);\n    }\n  }\n  return p;\n}\n\nint count(std::vector<std::vector<int>> p) {\n  size_t h = p.size();\n  size_t w = p[0].size();\n  std::queue<std::pair<size_t, size_t>> q;\n  int c0 = p[0][0];\n  q.emplace(0, 0);\n  int res = 0;\n  while (!q.empty()) {\n    size_t i, j;\n    std::tie(i, j) = q.front();\n    q.pop();\n    if (p[i][j] == 0) continue;\n    p[i][j] = 0;\n    ++res;\n    for (size_t k = 0; k < 4; ++k) {\n      size_t ni = i + di[k];\n      size_t nj = j + dj[k];\n      if (!(ni < h && nj < w)) continue;\n      if (p[ni][nj] != c0) continue;\n      q.emplace(ni, nj);\n    }\n  }\n  return res;\n}\n\nint paint(std::vector<std::vector<int>> p, int r, int c) {\n  if (r == 0) {\n    return count(paint(p, c));\n  }\n\n  int res = 1;\n  for (int i = 1; i <= 6; ++i)\n    res = std::max(res, paint(paint(p, i), r-1, c));\n  return res;\n}\n\nint testcase_ends() {\n  size_t h, w;\n  int c;\n  scanf(\"%zu %zu %d\", &h, &w, &c);\n  if (h == 0 && w == 0 && c == 0) return 1;\n\n  std::vector<std::vector<int>> p(h, std::vector<int>(w));\n  for (size_t i = 0; i < h; ++i)\n    for (size_t j = 0; j < w; ++j)\n      scanf(\"%d\", &p[i][j]);\n\n  printf(\"%d\\n\", paint(p, 4, c));\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint h, w, c, p[9][9], q[9][9];\nint id = 7;\n\nvoid change(int x, int y, int color){\n\tint first = p[x][y];\n\tp[x][y] = color * (-1);\n\tif (x < h - 1 && p[x + 1][y] == first)\n\t\tchange(x + 1, y, color);\n\tif (x > 0 && p[x - 1][y] == first)\n\t\tchange(x - 1, y, color);\n\tif (y < w - 1 && p[x][y + 1] == first)\n\t\tchange(x, y + 1, color);\n\tif (y > 0 && p[x][y - 1] == first)\n\t\tchange(x, y - 1, color);\n}\n\nvoid pabs(){\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tp[i][j] = abs(p[i][j]);\n\t\t}\n\t}\n\n\n}\n\nvoid show(){\n\tcout << endl;\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tcout << p[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main()\n{\n\n\t//長方形サイズ，目標色の入力\n\twhile (cin >> h >> w >> c, (h || w || c)){\n\n\t\t//初期化\n\t\tfor (int i = 0; i < 9; i++){\n\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\tp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t//色の入力\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> p[i][j];\n\t\t}\n\n\t\t//パネルをコピーしておく\n\t\tfor (int a = 0; a < h; a++){\n\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\tq[a][b] = p[a][b];\n\t\t\t}\n\t\t}\n\n\t\t//全パターン\n\n\t\tint max = 0;\n\t\tint counter;\n\t\tfor (int i = 1; i < 7; i++){\n\t\t\tfor (int j = 1; j < 7; j++){\n\t\t\t\tfor (int k = 1; k < 7; k++){\n\t\t\t\t\tfor (int l = 1; l < 7; l++){\n\t\t\t\t\t\tfor (int m = 1; m < 7; m++){\n\n\t\t\t\t\t\t\t//パネルを初期状態に戻す\n\t\t\t\t\t\t\tfor (int a = 0; a < h; a++){\n\t\t\t\t\t\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\t\t\t\t\t\tp[a][b] = q[a][b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//5回色塗り\n\t\t\t\t\t\t\tchange(0, 0, i);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, j);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, k);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, l);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, m);\n\t\t\t\t\t\t\tpabs();\n\n\t\t\t\t\t\t\t//集計\n\t\t\t\t\t\t\tfor (int i = 0; i < h; i++){\n\t\t\t\t\t\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\t\t\t\t\t\tif (p[i][j] == c){\n\t\t\t\t\t\t\t\t\t\tchange(i, j, ++id);\n\t\t\t\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\t\t\t\tcounter = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int a = 0; a < h; a++){\n\t\t\t\t\t\t\t\t\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\t\t\t\t\t\t\t\t\tif (p[a][b] == id)\n\t\t\t\t\t\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (counter > max)\n\t\t\t\t\t\t\t\t\t\t\tmax = counter;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//出力\n\t\tcout << max << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n// #define DEBUG\n\nusing namespace std;\n\nint h, w, c;\nint p[9][9];\n\nvoid Coloring(int y, int x, int c, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      Coloring(ny, nx, c, checked);\n    }\n  }\n  p[y][x] = c;\n  checked[y][x] = false;\n}\n\nint Count(int y, int x, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return 0;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      ret += Count(ny, nx, checked);\n    }\n  }\n\n  return ret + 1; \n}\n\nint dfs(int limit, int c, int pv[10]) {\n  if (limit == 0) {\n    if (p[0][0] != c) {\n      return 0;\n    }\n    bool checked[9][9] = { false };\n    return Count(0, 0, checked);\n  }\n  int ret = 0;\n  for (int i = 1; i <= 6; i++) {\n    int tmp[9][9];\n    memcpy(tmp, p, sizeof(p));\n    bool checked[9][9] = { false };\n    Coloring(0, 0, i, checked);\n    int tpv[10] = { 0 };\n    int d = dfs(limit - 1, c, tpv);\n    memcpy(p, tmp, sizeof(p)); // UNDO\n    if (d > ret) {\n      ret = d;\n      pv[limit] = i;\n      for (int j = 0; j < limit; j++) {\n        pv[j] = tpv[j];\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> h >> w >> c;\n    if (h + w + c == 0) {\n      break;\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> p[i][j];\n      }\n    }\n    int pv[10] = { 0 };\n    cout << dfs(5, c, pv) << endl;\n   \n#ifdef DEBUG\n    for (int i = 0; i < 10; i++) {\n      cout << pv[i] << \" \\n\"[i == 9];\n    }\n  }\n#endif\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define X first\n#define Y second\n#define R(i, n) for(i = 1; i <= n; i ++)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 10;\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {-1, 0, 1, 0};\n\nint w, h, cnt = 0;\nint dm[N][N], m[N][N];\nbool visited[N][N];\n\nvoid dfs(pii, int, int);\nvoid countM(pii, int);\n\nint main(void){\n    for(vi a(5); cin >> h >> w >> a[4], h;){\n\n        rep(y, h) rep(x, w) cin >> dm[y][x];\n        \n        int res = 0;\n        \n        R(a[0], 6){\n            if(dm[0][0] == a[0]) continue;\n            R(a[1], 6){\n                if(a[0] == a[1]) continue;\n                R(a[2], 6){\n                    if(a[1] == a[2]) continue;\n                    R(a[3], 6){\n                        if(a[2] == a[3] || a[3] == a[4]) continue;\n                        rep(y, h) rep(x, w) m[y][x] = dm[y][x];\n                        rep(i, 5){\n                            MEMSET(visited, false);\n                            cnt = 0;\n                            dfs(mp(0, 0), m[0][0], a[i]);\n                        }\n                        MEMSET(visited, false);\n                        countM(mp(0, 0), m[0][0]);\n                        res = max(res, cnt);\n                    }\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n    \n    return 0;\n}\n\nvoid dfs(pii p, int bc, int ac){\n    if(p.X < 0 || w <= p.X ||\n       p.Y < 0 || h <= p.Y)\n        return;\n    \n    if(!visited[p.Y][p.X] && m[p.Y][p.X] == bc) m[p.Y][p.X] = ac;\n    else return;\n\n    visited[p.Y][p.X] = true;\n    rep(i, 4) dfs(mp(p.X + dx[i], p.Y + dy[i]), bc, ac);\n}\n\nvoid countM(pii p, int c){\n    if(p.X < 0 || w <= p.X ||\n       p.Y < 0 || h <= p.Y)\n        return;\n    \n    if(!visited[p.Y][p.X] && m[p.Y][p.X] == c) cnt ++;\n    else return;\n\n    visited[p.Y][p.X] = true;\n    rep(i, 4) countM(mp(p.X + dx[i], p.Y + dy[i]), c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nint h, w, c;\nint p[10][10];\nint q[10][10];\nbool visited[10][10];\n\nvoid change(int i, int j, int c) {\n    if(visited[i][j]) return;\n    visited[i][j] = true;\n    if(i>0 && q[i-1][j]==q[i][j]) change(i-1, j, c);\n    if(j>0 && q[i][j-1]==q[i][j]) change(i, j-1, c);\n    if(i<h-1 && q[i+1][j]==q[i][j]) change(i+1, j, c);\n    if(j<w-1 && q[i][j+1]==q[i][j]) change(i, j+1, c);\n    q[i][j] = c;\n}\n\nint count(int i, int j) {\n    if(visited[i][j]) return 0;\n    visited[i][j] = true;\n    int ret = 1;\n    if(i>0 && q[i-1][j]==q[i][j]) ret += count(i-1, j);\n    if(j>0 && q[i][j-1]==q[i][j]) ret += count(i, j-1);\n    if(i<h-1 && q[i+1][j]==q[i][j]) ret += count(i+1, j);\n    if(j<w-1 && q[i][j+1]==q[i][j]) ret += count(i, j+1);\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\twhile(cin>>h>>w>>c, h+w+c) {\n\t    rep(i, h) rep(j, w) cin >> p[i][j];\n\t    int ans = -1;\n\t    REP(c1, 1, 7) REP(c2, 1, 7) REP(c3, 1, 7) REP(c4, 1, 7) {\n\t        rep(i, h) rep(j, w) q[i][j] = p[i][j];\n\t        memset(visited, false, sizeof(visited)); change(0, 0, c1);\n\t        memset(visited, false, sizeof(visited)); change(0, 0, c2);\n\t        memset(visited, false, sizeof(visited)); change(0, 0, c3);\n\t        memset(visited, false, sizeof(visited)); change(0, 0, c4);\n\t        memset(visited, false, sizeof(visited)); change(0, 0, c);\n\t        memset(visited, false, sizeof(visited)); ans = max(ans, count(0, 0));\n\t    }\n\t    cout << ans << endl;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostReam>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint H,W,C;\nint board[8][8];\nint b[8][8];\nint check[8][8];\nint ord[5];\nint ans;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool in(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y, int color){\n    //cerr << x << \" \" << y << \" \" << color << endl;\n    check[y][x] = 1;\n    for(int k = 0; k < 4; k++){\n        int nx = x + dx[k], ny = y + dy[k];\n        if(!in(nx, ny) || b[ny][nx] != color || check[ny][nx]) continue;\n        dfs(nx, ny, color);\n    }\n}\n\nint calc(){\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            b[i][j] = board[i][j];\n        }\n    }\n    for(int t = 0; t < 5; t++){\n        //cout << ord[t] << endl;\n        memset(check, 0, sizeof check);\n        dfs(0, 0, b[0][0]);\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                if(check[i][j]) b[i][j] = ord[t];\n            }\n        }\n    }\n\n    memset(check, 0, sizeof check);\n    dfs(0, 0, b[0][0]);\n    int ret = 0;\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            if(check[i][j] && b[i][j] == C) ret++;\n        }\n    }\n    return ret;\n}\n\nvoid f(int n){\n    if(n == 5){\n        ans = max(ans, calc());\n        return;\n    }\n    for(int i = 1; i <= 6; i++){\n        ord[n] = i;\n        f(n + 1);\n    }\n}\n\nint main(){\n    while(cin >> H >> W >> C, H){\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                cin >> board[i][j];\n            }\n        }\n        ans = 0;\n        f(0);\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint h, w, c, Max;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a;\nvoid mark(int x, int y, int b, int c) {\n\ta[x][y] = c;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&a[nx][ny] == b)mark(nx, ny, b, c);\n\t}\n}\nint cnt = 0;\nvoid dfs(int t) {\n\tif (t == 0) {\n\t\tif (a[0][0] != c)mark(0, 0, a[0][0], c);\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (a[i][j] != c)continue;\n\t\t\tmark(i, j, c, 10);\n\t\t\tint cnt = 0;\n\t\t\trep(l, h)rep(k, w)if (a[l][k] == 10)Max = max(Max, ++cnt);\n\t\t\tmark(i, j, 10, c);\n\t\t}\n\t\treturn;\n\t}\n\tvector<vector<int>>b = a;\n\trep(i, 6) {\n\t\tif (a[0][0] == i)continue;\n\t\tmark(0, 0, a[0][0], i);\n\t\tdfs(t - 1); a = b;\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &h, &w, &c), h) {\n\t\ta = vector<vector<int>>(h, vector<int>(w)); c--;\n\t\trep(i, h)rep(j, w)scanf(\"%d\", &a[i][j]), a[i][j]--;\n\t\tMax = 0; dfs(4);\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,k,n) for(int i=k;i<(int)(n);i++)\n\n#define vi vector<int>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n\ntypedef long long ll;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nint main(){\n//    ifstream in(\"cin.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int h,w,c;\n    while(cin >> h >> w >> c,h){\n        int ma = 0;\n        int p[10][10] = {};\n        rep(y,h)rep(x,w) cin >> p[y][x];\n        int a[6] = {};\n        rep(bit,pow(6,4)){\n            int tmp_bit = bit;\n            rep(i,4){\n                a[i] = tmp_bit%6;\n                tmp_bit/=6;\n                a[i]+=1;\n                if(a>0 && a[i-1] == a[i]) a[0] = -1;\n//                cout << a[i] << \" \";\n            }\n            if(a[0] == -1 || a[3] == c) continue;\n//            cout << endl;\n            a[4] = c;\n//            rep(i,c) cout << a[i] << \" \";\n//            cout << endl;\n            int t[10][10];\n            rep(y,h)rep(x,w) t[y][x] = p[y][x];\n\n            rep(i,5){\n\n                queue<pii> que;\n                que.push(pii(0,0));\n                int now_color = t[0][0];\n                bool u[10][10] = {};\n                while(!que.empty()){\n                    int x,y;\n                    tie(x,y) = que.front();\n                    que.pop();\n                    if(u[y][x]) continue;\n                    u[y][x] = true;\n                    t[y][x] = a[i];\n                    rep(d,4){\n                        int nx = x + dx[d];\n                        int ny = y + dy[d];\n                        if(nx < 0 || w <= nx ||\n                                ny < 0 || h <= ny) continue;\n                        if(u[ny][nx] || t[ny][nx] != now_color) continue;\n                        que.push(pii(nx,ny));\n                    }\n                }\n            }\n            int cnt = 0;\n            queue<pii> qe;\n            qe.push(pii(0,0));\n            bool uu[10][10] = {};\n\n            while(!qe.empty()) {\n                int xp, yp;\n\n                tie(xp, yp) = qe.front();\n                qe.pop();\n                if(uu[yp][xp]) continue;\n                cnt += 1;\n                uu[yp][xp] = true;\n                rep(d, 4) {\n                    int nx = xp + dx[d];\n                    int ny = yp + dy[d];\n                    if (nx < 0 || w <= nx ||\n                        ny < 0 || h <= ny)\n                        continue;\n                    if(uu[ny][nx]) continue;\n                    if(t[ny][nx] != c) continue;\n                    qe.push(pii(nx, ny));\n                }\n            }\n            ma = max(ma,cnt);\n        };\n        cout << ma << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint h, w, c;\nint panel[2][8][8];\nint visit[8][8];\nint sq, ans;\n\nvoid bfs(int x, int y, int cl, int pg)\n{\n\tif( x < 0 || x >= w || y < 0 || y >= h || visit[y][x] == 1 || panel[pg][y][x] != cl )\n\t\treturn;\n\telse\n\t{\n\t\tvisit[y][x] = 1;\n\t\tsq++;\n\t\tbfs(x+1, y, cl, pg);\n\t\tbfs(x-1, y, cl, pg);\n\t\tbfs(x, y+1, cl, pg);\n\t\tbfs(x, y-1, cl, pg);\n\t}\n\treturn;\n}\n\nvoid paint(int x, int y, int befc, int aftc, int pg)\n{\n\tif( x < 0 || x >= w || y < 0 || y >= h || panel[pg][y][x] != befc || visit[y][x] == 1 )\n\t\treturn;\n\telse\n\t{\n\t\tvisit[y][x] = 1;\n\t\tpanel[pg][y][x] = aftc;\n\t\tpaint(x+1, y, befc, aftc, pg);\n\t\tpaint(x-1, y, befc, aftc, pg);\n\t\tpaint(x, y+1, befc, aftc, pg);\n\t\tpaint(x, y-1, befc, aftc, pg);\n\t}\n\n\treturn;\n}\n\nvoid setpanel(int pg)\n{\n\t\tfor(int j = 0; j < h; j++ )\n\t\t\tfor(int i = 0; i < w; i++)\n\t\t\t\tpanel[pg][j][i] = panel[pg-1][j][i];\n\n\t\treturn;\n}\n\nint main()\n{\n\tint i,j,k,l,befc;\n\n\twhile( cin >> h >> w >> c, (h||w||c))\n\t{\n\t\tans = 0;\n\n\t\tfor( j = 0; j < h ; j++)\n\t\t\tfor( i = 0; i < w ; i++)\n\t\t\t\tcin >> panel[0][j][i];\n\n\t\tfor( i = 1; i <= 6 ; i++)\n\t\t\tfor( j = 1; j <= 6; j++ )\n\t\t\t\tfor( k = 1; k <= 6; k++)\n\t\t\t\t\tfor( l = 1; l <= 6; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif( i == j || j == k || k == l )\n\n\t\t\t\t\t\tsetpanel(1);\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, i, 1);\n\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, j, 1);\n\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, k, 1);\n\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, l, 1);\n\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, c, 1);\n\n\t\t\t\t\t\tsq = 0;\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tbfs(0, 0, c, 1);\n\t\t\t\t\t\tans = max(sq, ans);\n\t\t\t\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint w,h,Col;\ntypedef pair<int,int> C;\ntypedef vector<vector<int> > P;\nP V;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint res;\n\nvoid on(P N,int count,int c){\n\n\tint nc=N[0][0];\n\tqueue<C> Q;\n\tQ.push(make_pair(0,0));\n\tbool used[8][8];\n\tmemset(used,false,sizeof(used));\n\n\tint tres=0;\n\twhile(!Q.empty()){\n\t\tC now=Q.front();\n\t\tQ.pop();\n\t\tif(used[now.first][now.second]) continue;\n\t\tused[now.first][now.second]=true;\n\t\tN[now.first][now.second]=c;\n\t\ttres++;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint ny=now.first+dy[r],nx=now.second+dx[r];\n\t\t\tif(ny<0 || nx<0 || ny>=h || nx>=w) continue;\n\t\t\tif(N[ny][nx]==nc)\n\t\t\t\tQ.push(make_pair(ny,nx));\n\t\t}\n\t\tres=max(res,tres);\n\t}\n\tif(count==5) return;\n\n\tif(count!=4)\n\t\tfor(int i=1;i<=6;i++)\n\t\t\ton(N,count+1,i);\n\telse on(N,count+1,Col);\n}\n\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tV.resize(h);\n\n\tfor(int y=0;y<h;y++)\n\t\tfor(int x=0;x<w;x++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tV[y].push_back(t);\n\t\t}\n\t\n\tfor(int i=1;i<=6;i++){\n\t\t on(V,0,i);\n\t}\n\n\tcout<<res<<endl;\n\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w>>Col){\n\t\tif(w==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,c,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nvector<int> p(64);\n\nint nu(int x,int y,int cl,int t){\n  int res=1;\n  p[y*w+x]=cl;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||w<=nx||ny<0||h<=ny||p[ny*w+nx]!=t||p[ny*w+nx]==cl)continue;\n    res+=nu(nx,ny,cl,t);\n  }\n  return res;\n}\n\nint dfs(int d){\n  if(d==4){\n    nu(0,0,c,p[0]);\n    return nu(0,0,7,p[0]);\n  }\n  vector<int> tp=p;\n  int res=0;\n  for(int j=1;j<7;j++){\n    nu(0,0,j,p[0]);\n    res=max(res,dfs(d+1)),p=tp;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>h>>w>>c,h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>p[i*w+j];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vi = std::vector<int>;\n\tusing vvi = std::vector<vi>;\n\n\tusing vb = std::vector<bool>;\n\tusing vvb = std::vector<vb>;\n\n\tint H, W, C;\n\n\tint calcSize(vvi &board, int h, int w)\n\t{\n\t\tvvb visited(H + 2, vb(W + 2));\n\t\tstd::stack<std::pair<int, int>> previsit;\n\t\tprevisit.push({h, w});\n\n\t\tint count{};\n\t\twhile (!previsit.empty())\n\t\t{\n\t\t\tauto now{previsit.top()};\n\t\t\tprevisit.pop();\n\t\t\tif (visited[now.first][now.second]) continue;\n\t\t\tif (board[now.first][now.second] != C) continue;\n\t\t\tcount++;\n\t\t\tvisited[now.first][now.second] = true;\n\t\t\tprevisit.push({now.first + 1, now.second});\n\t\t\tprevisit.push({now.first - 1, now.second});\n\t\t\tprevisit.push({now.first, now.second + 1});\n\t\t\tprevisit.push({now.first, now.second - 1});\n\t\t}\n\t\treturn count;\n\t}\n\n\tint rc(int turn, vvi &board)\n\t{\n\t\tint ret{};\n\t\tif (turn == 5)\n\t\t\treturn calcSize(board, 1, 1);\n\t\tfor (int c_i{1}; c_i <= 6; c_i++)\n\t\t{\n\t\t\tvvi next_board{board};\n\t\t\tif (c_i != board[1][1])\n\t\t\t\tchangeColor(next_board, c_i);\n\t\t\tret = std::max(ret, rc(turn + 1, next_board));\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid changeColor(vvi &board, int new_color)\n\t{\n\t\tstd::stack<std::pair<int, int>> previsit;\n\t\tprevisit.push({1, 1});\n\n\t\tint pre_color{board[1][1]};\n\t\twhile (!previsit.empty())\n\t\t{\n\t\t\tauto now{previsit.top()};\n\t\t\tprevisit.pop();\n\t\t\tif (board[now.first][now.second] != pre_color) continue;\n\n\t\t\tboard[now.first][now.second] = new_color;\n\n\t\t\tprevisit.push({now.first + 1, now.second});\n\t\t\tprevisit.push({now.first - 1, now.second});\n\t\t\tprevisit.push({now.first, now.second + 1});\n\t\t\tprevisit.push({now.first, now.second - 1});\n\t\t}\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tscanf(\"%d%d%d\", &H, &W, &C);\n\t\tif (H == 0 && W == 0 && C == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tvvi board(H + 2, vi(W + 2));\n\t\tfor (int h_i{1}; h_i <= H; h_i++)\n\t\t\tfor (int w_i{1}; w_i <= W; w_i++)\n\t\t\t\tscanf(\"%d\", &board[h_i][w_i]);\n\t\tint ans{};\n\t\tfor (int i{1}; i <= H; i++)\n\t\t\tfor (int j{1}; j <= W; j++)\n\t\t\t\tans = std::max(ans, calcSize(board, i, j));\n\n\t\tans = std::max(ans, rc(0, board));\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define F first\n#define S second\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef pair<int,int>pii;\nstruct data{\n    int cnt;\n    vvi fld;\n    data(){}\n    data(int a,vvi b):cnt(a),fld(b){}\n\n};\ndata check(vvi fld){\n    int c=fld[0][0];\n    int h=fld.size();\n    int w=fld[0].size();\n    int dx[]={0,-1,0,1};\n    int dy[]={-1,0,1,0};\n    queue<pii>Q;\n    Q.push(pii(0,0));\n    int cnt=0;\n    while(Q.size()){\n        int y=Q.front().F,x=Q.front().S;\n        Q.pop();\n        if(y<0||y>=h||x<0||x>=w)continue;\n        if(fld[y][x]!=c)continue;\n        fld[y][x]=-1;\n        cnt++;\n        for(int i=0;i<4;i++)Q.push(pii(y+dy[i],x+dx[i]));\n    }\n\n    return data(cnt,fld);\n}\n\nvvi chenge(vvi fld,int to){\n    int h=fld.size();\n    int w=fld[0].size();\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            if(fld[i][j]==-1)fld[i][j]=to;\n\n    return fld;\n}\nint main(){\n    int h,w,c;\n    while(cin>>h>>w>>c,h||w||c){\n        vvi fld(h,vi(w));\n        c--;\n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++){\n                cin>>fld[i][j];\n                fld[i][j]--;\n            }\n\n        int ma=0;\n        queue<data>Q;\n        Q.push(data(0,fld));\n        while(Q.size()){\n            data d=Q.front();\n            Q.pop();\n            if(d.cnt>=5){\n                if(d.fld[0][0]==c){\n                    ma=max(ma,check(d.fld).cnt);\n                }\n                continue;\n            }\n            vvi next=d.fld;\n            next=check(next).fld;\n            for(int i=0;i<6;i++){\n                Q.push(data(d.cnt+1,chenge(next,i)));\n            }\n        }\n        cout<<ma<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nvector<int> val(5,1);\nvector<vector<int>> tmpp;\nint h,w;\nvector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\nbool nextval(){\n  val[3]++;\n  if(val[3] == 7){\n    val[3] = 1;\n    val[2]++;\n    if(val[2] == 7){\n      val[2] = 1;\n      val[1]++;\n      if(val[1] == 7){\n\tval[1] = 1;\n\tval[0]++;\n\tif(val[0] == 7){\n\t  val[0] = 1;\n\t  return false;\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nbool isin(int x, int y){\n  bool ans;\n  if(0 <= x and x < h and 0 <= y and y < w) ans = true;\n  else ans = false;\n  return ans;\n}\n\nvoid changeto(int to){\n  queue<pair<int,int>> q;\n  int from = tmpp[0][0];\n\n  q.push(pair<int,int>(0,0));\n  tmpp[0][0] = to;\n\n  while(not q.empty()){\n    pair<int,int> p = q.front();\n    q.pop();\n\n    rep(i, dx.size()){\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(isin(nx,ny) and tmpp[nx][ny] == from){\n\tq.push(pair<int,int>(nx, ny));\n\ttmpp[nx][ny] = to;\n      }\n    }\n  }\n}\n\nint area(){\n  queue<pair<int,int>> q;\n\n  q.push(pair<int,int>(0,0));\n  int c = tmpp[0][0];\n  tmpp[0][0] = -1;\n  int res = 1;\n\n  while(not q.empty()){\n    pair<int,int> p = q.front();\n    q.pop();\n\n    rep(i, dx.size()){\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(isin(nx,ny) and tmpp[nx][ny] == c){\n\tq.push(pair<int,int>(nx, ny));\n\ttmpp[nx][ny] = -1;\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(void){\n  int c;\n  while(cin >> h >> w >> c, h){\n    vector<vector<int>> p(h,vector<int>(w));\n    rep(i,h) rep(j,w) cin >> p[i][j];\n    val[4] = c;\n\n    int res = 0;\n    do{\n      tmpp = p;\n      rep(i,5) if(tmpp[0][0] != val[i]) changeto(val[i]);\n      res = max(res, area());\n    }while(nextval());\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n\nint h, w, color, pl[9][9];\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nvoid solve() {\n  rep(i,h) rep(j,w) cin>>pl[i][j];\n  \n  int res = 0;\n  rep(a,6) rep(b,6) rep(c,6) rep(d,6) {\n  //rep(a,6) rep(b,6) rep(c,6) rep(d,6) rep(e,6) {\n    // copy\n    int c_pl[9][9];\n    rep(i,h) rep(j,w) c_pl[i][j] = pl[i][j];\n    \n    //int cc[5] = {a+1, b+1, c+1, d+1, e+1};\n    int cc[5] = {a+1, b+1, c+1, d+1, color};\n    rep(z,5){\n      if (z > 0 && cc[z] == cc[z-1]) continue;\n      // record before color\n      int rbc = c_pl[0][0];\n      // if another panel will be change\n      bool used[9][9];\n      memset(used, false, sizeof used);\n      vector<P> clist; clist.pb(P(0,0));\n      queue<P> que;\n      que.push(P(0,1)); que.push(P(1,0));\n      while(!que.empty()) {\n        P p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n        if (used[y][x]) continue;\n        used[y][x] = true;\n        if (c_pl[y][x] == rbc) {\n          // list add\n          clist.pb(P(x, y));\n          // search\n          rep(zz,4) {\n            int tx = x + dx[zz], ty = y + dy[zz];\n            if (tx < 0 || ty < 0 || tx >= w || ty >= h) continue;\n            if (used[ty][tx]) continue;\n            if (c_pl[ty][tx] == rbc) que.push(P(tx, ty));\n          }\n        }\n      }\n      // change color\n      rep(zz,clist.size()) {\n        int x = clist[zz].first, y = clist[zz].second;\n        c_pl[y][x] = cc[z];\n      }\n      \n      // count color C\n      if (z == 4 && cc[z] == color) {\n        int t_res = 0;\n        bool used[9][9];\n        memset(used, false, sizeof used);\n        queue<P> que2;\n        que2.push(P(0,0));\n        while (!que2.empty()) {\n          P p = que2.front(); que2.pop();\n          int x = p.first, y = p.second;\n          if (used[y][x]) continue;\n          used[y][x] = true;\n          t_res++;\n          rep(zz,4) {\n            int tx = x + dx[zz], ty = y + dy[zz];\n            if (tx < 0 || ty < 0 || tx >= w || ty >= h) continue;\n            if (used[ty][tx]) continue;\n            if (c_pl[ty][tx] == color) que2.push(P(tx,ty));\n          }\n        }\n        res = max(t_res, res);\n      }\n    }\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>h>>w>>color, h||w||color) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\ntypedef string::const_iterator State;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tint h, w, c;\n\t\tint maxi = 0;\n\t\tint point;\n\t\tint first;\n\t\tint p[9][9] = {};\n\t\tint save[9][9] = {};\n\t\tqueue< pair<int, int> > que;//y,x \n\t\tpair<int, int> now;\n\t\tint x, y;\n\n\t\tcin >> h >> w >> c;\n\t\tif (h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tFOR(i, 1, h) {\n\t\t\tFOR(j, 1, w) {\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tsave[i][j] = p[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfirst = p[1][1];\n\n\t\tFOR(i, 1, 6) {\n\t\t\tif (i != first) {\n\t\t\t\tFOR(j, 1, 6) {\n\t\t\t\t\tif (j != i) {\n\t\t\t\t\t\tFOR(k, 1, 6) {\n\t\t\t\t\t\t\tif (k != j) {\n\t\t\t\t\t\t\t\tFOR(l, 1, 6) {\n\t\t\t\t\t\t\t\t\tif (l != c&&l!=k) {\n\n\t\t\t\t\t\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << \" \" << c << endl;\n\n\t\t\t\t\t\t\t\t\t\tFOR(m, 1, h) {\n\t\t\t\t\t\t\t\t\t\t\tFOR(n, 1, w) {\n\t\t\t\t\t\t\t\t\t\t\t\tp[m][n] = save[m][n];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\t\t\t\t\t\t\tque.push(make_pair(1,1));\n\t\t\t\t\t\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\t\t\t\t\t\tnow = que.front();\n\t\t\t\t\t\t\t\t\t\t\ty = now.first;\n\t\t\t\t\t\t\t\t\t\t\tx = now.second;\n\t\t\t\t\t\t\t\t\t\t\tque.pop();\n\n\t\t\t\t\t\t\t\t\t\t\tFOR(m, 0, 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (y + dy[m] >= 1 && y + dy[m] <= h && x + dx[m] >= 1 && x + dx[m] <= w) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (p[y + dy[m]][x + dx[m]] == first) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tque.push(make_pair(y + dy[m], x + dx[m]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tp[y][x] = i;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t//cout << \"b\" << endl;\n\t\t\t\t\t\t\t\t\t\tque.push(make_pair(1, 1));\n\t\t\t\t\t\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\t\t\t\t\t\tnow = que.front();\n\t\t\t\t\t\t\t\t\t\t\ty = now.first;\n\t\t\t\t\t\t\t\t\t\t\tx = now.second;\n\t\t\t\t\t\t\t\t\t\t\tque.pop();\n\n\t\t\t\t\t\t\t\t\t\t\tFOR(m, 0, 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (y + dy[m] >= 1 && y + dy[m] <= h && x + dx[m] >= 1 && x + dx[m] <= w) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (p[y + dy[m]][x + dx[m]] == i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tque.push(make_pair(y + dy[m], x + dx[m]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tp[y][x] = j;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t//cout << \"c\" << endl;\n\t\t\t\t\t\t\t\t\t\tque.push(make_pair(1, 1));\n\t\t\t\t\t\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\t\t\t\t\t\tnow = que.front();\n\t\t\t\t\t\t\t\t\t\t\ty = now.first;\n\t\t\t\t\t\t\t\t\t\t\tx = now.second;\n\t\t\t\t\t\t\t\t\t\t\tque.pop();\n\n\t\t\t\t\t\t\t\t\t\t\tFOR(m, 0, 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (y + dy[m] >= 1 && y + dy[m] <= h && x + dx[m] >= 1 && x + dx[m] <= w) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (p[y + dy[m]][x + dx[m]] == j) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tque.push(make_pair(y + dy[m], x + dx[m]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tp[y][x] = k;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t//cout << \"d\" << endl;\n\t\t\t\t\t\t\t\t\t\tque.push(make_pair(1, 1));\n\t\t\t\t\t\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\t\t\t\t\t\tnow = que.front();\n\t\t\t\t\t\t\t\t\t\t\ty = now.first;\n\t\t\t\t\t\t\t\t\t\t\tx = now.second;\n\t\t\t\t\t\t\t\t\t\t\tque.pop();\n\n\t\t\t\t\t\t\t\t\t\t\tFOR(m, 0, 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (y + dy[m] >= 1 && y + dy[m] <= h && x + dx[m] >= 1 && x + dx[m] <= w) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (p[y + dy[m]][x + dx[m]] == k) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tque.push(make_pair(y + dy[m], x + dx[m]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tp[y][x] = l;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t//cout << \"e\" << endl;\n\t\t\t\t\t\t\t\t\t\tque.push(make_pair(1, 1));\n\t\t\t\t\t\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\t\t\t\t\t\tnow = que.front();\n\t\t\t\t\t\t\t\t\t\t\ty = now.first;\n\t\t\t\t\t\t\t\t\t\t\tx = now.second;\n\t\t\t\t\t\t\t\t\t\t\tque.pop();\n\n\t\t\t\t\t\t\t\t\t\t\tFOR(m, 0, 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (y + dy[m] >= 1 && y + dy[m] <= h && x + dx[m] >= 1 && x + dx[m] <= w) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (p[y + dy[m]][x + dx[m]] == l) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tque.push(make_pair(y + dy[m], x + dx[m]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tp[y][x] = c;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\t\t/*FOR(m, 1, h) {\n\t\t\t\t\t\t\t\t\t\t\tFOR(n, 1, w) {\n\t\t\t\t\t\t\t\t\t\t\t\tcout << p[m][n] << \" \";\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t\t\t\t\t}*/\n\n\t\t\t\t\t\t\t\t\t\tpoint = 0;\n\t\t\t\t\t\t\t\t\t\t//cout << \"f\" << endl;\n\t\t\t\t\t\t\t\t\t\tque.push(make_pair(1, 1));\n\t\t\t\t\t\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\t\t\t\t\t\tnow = que.front();\n\t\t\t\t\t\t\t\t\t\t\ty = now.first;\n\t\t\t\t\t\t\t\t\t\t\tx = now.second;\n\t\t\t\t\t\t\t\t\t\t\tque.pop();\n\n\t\t\t\t\t\t\t\t\t\t\t//cout << y << \" \" << x << endl;\n\t\t\t\t\t\t\t\t\t\t\tpoint++;\n\n\t\t\t\t\t\t\t\t\t\t\tFOR(m, 0, 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (y + dy[m] >= 1 && y + dy[m] <= h && x + dx[m] >= 1 && x + dx[m] <= w) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (p[y + dy[m]][x + dx[m]] == c) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tque.push(make_pair(y + dy[m], x + dx[m]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tp[y + dy[m]][x + dx[m]] = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tp[y][x] = -1;\n\n\t\t\t\t\t\t\t\t\t\t\t/*FOR(n, 1, h) {\n\t\t\t\t\t\t\t\t\t\t\t\tFOR(o, 1, w) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcout << p[n][o] << \" \";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t\t\t\t\t\t}*/\n\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t//cout << maxi << endl;\n\t\t\t\t\t\t\t\t\t\t//cout << endl;\n\n\n\t\t\t\t\t\t\t\t\t\t//cout << \"g\" << endl;\n\t\t\t\t\t\t\t\t\t\tif (maxi < point) {\n\t\t\t\t\t\t\t\t\t\t\tmaxi = point;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << maxi << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint h,w,z;\nvector<vi> now;\nvoid f(int p){\n    int t = now[0][0];\n    if(t == p)return;\n    queue<pii> q;\n    q.push(pii(0,0));\n    now[0][0] = p;\n    while(q.size()){\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        rep(i,4){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || nx >= h || ny < 0 || ny >= w)continue;\n            if(now[nx][ny] == t)q.push(pii(nx,ny)),now[nx][ny] = p;\n        }\n    }\n\n}\n\nsigned main(void) {\n    while(cin >> h >> w >> z, h){\n        z--;\n        vector<vi> in(h,vi(w));\n        rep(i,h)rep(j,w)cin >> in[i][j],in[i][j]--;\n        int ans = 0;\n        rep(a,6)rep(b,6)rep(c,6)rep(d,6){\n            now = in;\n            f(a);\n            f(b);\n            f(c);\n            f(d);\n            f(z);\n\n            rep(i,h){\n                //rep(j,w)cout << \" \" << now[i][j];cout << endl;\n            }\n\n\n\n            int sum = 0;\n            queue<pii> q;\n            q.push(pii(0,0));\n            now[0][0] = -1;\n            //cout << endl;\n            while(q.size()){\n                int x = q.front().first;\n                int y = q.front().second;\n                //cout << x << \" \" << y << endl;\n                sum++;\n                q.pop();\n                rep(i,4){\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if(nx < 0 || nx >= h || ny < 0 || ny >= w)continue;\n                    if(now[nx][ny] == z)q.push(pii(nx,ny)),now[nx][ny] = -1;\n                }\n            }\n            //cout << a << \" \" << b << \" \" << c << \" \" << d << \" \" << sum << endl;\n\n            ans = max(ans,sum);\n        }\n        cout << ans << endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nstruct state{\n\tint table[8][8];\n};\n\nint h,w,c;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint change(state tmp,int num,int col){\n\tint cmax=0;\n\tif(num==5){\n\t\tif(col==c){\n\t\t\tqueue<P> q;\n\t\t\tint count=0;\n\t\t\tP cur;\n\t\t\tcur.first=0,cur.second=0;\n\t\t\tq.push(cur);\n\t\t\twhile(!q.empty()){\n\t\t\t\tcur=q.front();q.pop();\n\t\t\t\tif(tmp.table[cur.first][cur.second]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\ttmp.table[cur.first][cur.second]=0;\n\t\t\t\tcount++;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint cx=cur.first+dx[i],cy=cur.second+dy[i];\n\t\t\t\t\tif(0<=cx&&cx<w&&0<=cy&&cy<h&&tmp.table[cx][cy]==c)\n\t\t\t\t\t\tq.push(make_pair(cx,cy));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t}else\n\t\t\treturn 0;\n\t}\n\n\tfor(int i=1;i<=6;i++){\n\t\tstate next;\n\t\tnext=tmp;\n\t\tif(i==col)\n\t\t\tcontinue;\n\t\tqueue<P> q;\n\t\tP cur;\n\t\tcur.first=0,cur.second=0;\n\t\tq.push(cur);\n\t\twhile(!q.empty()){\n\t\t\tcur=q.front();q.pop();\n\t\t\tnext.table[cur.first][cur.second]=i;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint cx=cur.first+dx[j],cy=cur.second+dy[j];\n\t\t\t\tif(0<=cx&&cx<w&&0<=cy&&cy<h&&next.table[cx][cy]==col)\n\t\t\t\t\tq.push(make_pair(cx,cy));\n\t\t\t}\n\t\t}\n\t\tcmax=max(cmax,change(next,num+1,i));\n\t}\n\n\treturn cmax;\n}\n\nint main(void){\n\tstate init;\n\twhile(cin >> h >> w >> c,h|w|c){\n\t\tfor(int y=0;y<h;y++)\n\t\t\tfor(int x=0;x<w;x++)\n\t\t\t\tcin >> init.table[x][y];\n\t\tint ans=change(init,0,init.table[0][0]);\n\t\tcout << ans  << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <utility>\n\nusing namespace std;\ntypedef vector<vector<int>> mat;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nvector<pii> d(4);\n\nint solve();\nint getCols( const int target, const mat & m );\nvoid setColor( const int col, mat &m );\nvoid search( int &ans, int target, mat &orig );\n\nint main(void) {\n\t\n\twhile(solve()){}\n\n\treturn 0;\n}\n\nvoid setColor( const int col, mat &m ) {\n\n\t//?????¨?????¨??????\n\tconst int orig = m[0][0];\n\n\tqueue<pii> q;\n\tq.push(pii(0,0));\n\tmat visited( m.size(), vi( m[0].size(), 0 ) );\n\tvisited[0][0] = 1;\n\n\twhile(!q.empty()) {\n\n\t\tpii p = q.front();\n\t\tq.pop();\n\t\tm[p.first][p.second] = col;\t\n\n\t\tfor( int i = 0; i < d.size(); i++ ) {\n\t\t\tpii n;\n\t\t\t\tn.first = p.first + d[i].first;\n\t\t\t\tn.second = p.second + d[i].second;\n\t\t\tif( n.first >= 0 && n.first < m.size() \n\t\t\t\t&& n.second >= 0 && n.second < m[0].size()\n\t\t\t\t&& visited[n.first][n.second] == 0\n\t\t\t\t&& m[n.first][n.second] == orig ) {\n\t\t\t\t\tvisited[n.first][n.second] = 1;\n\t\t\t\t\tq.push(n);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t\n\n}\n\nint getCols( const int target, const mat& m) {\n\n\tint ret = 0;\n\tqueue<pii> q;\n\tq.push(pii(0,0));\n\tmat visited( m.size(), vi( m[0].size(), 0 ) );\n\tvisited[0][0] = 1;\n\n\twhile(!q.empty()){\n\n\t\tpii p = q.front();\n\t\tq.pop();\n\t\tret ++;\n\t\tfor( int i = 0; i < d.size(); i++ ) {\n\n\t\t\tpii n;\n\t\t\t\tn.first = p.first + d[i].first;\n\t\t\t\tn.second = p.second + d[i].second;\n\n\t\t\tif( n.first >= 0 && n.first < m.size() \n\t\t\t\t&& n.second >= 0 && n.second < m[0].size()\n\t\t\t\t&& visited[n.first][n.second] == 0\n\t\t\t\t&& m[n.first][n.second] == target ) {\n\t\t\t\t\tvisited[n.first][n.second] = 1;\n\t\t\t\t\tq.push(n);\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid search( int &ans, int target, mat &orig ) {\n\n\tfor( int i = 0; i < 1296; i++ ) {\n\n\t\tbool b = false;\n\t\tint t[5];\n\t\tint k = i;\n\n\t\tfor( int j = 0; j < 4; j++ ) {\n\t\t\tt[j] = k % 6 + 1;\n\t\t\tk /= 6;\n\t\t\tif( t[0] == orig[0][0] ) { b = true; break; }\n\t\t\tif( j > 0 && t[j] == t[j-1] ){ b = true; break; }\n\t\t}\n\t\tt[4] = target;\n\t\tif( t[3]  == target ) { b = true; }\n\t\tif( t[4] != target ) { b = true; }\n\n\t\tif(b){ continue; }\n\n\t\tmat m = orig;\n\n\t\tfor( int j = 0; j < 5; j++ ) {\n\n\t\t\tsetColor( t[j],m);\n\t\t\t\n\t\t}\n\n\n\t\tans = max( ans, getCols( target, m ) );\n\t}\n\n}\n\nint solve() {\n\n\tint h, w, c;\n\n\tcin >> h >> w >> c;\n\n\tif(!(h|w|c)){ return 0; }\n\n\tmat p(h,vector<int>(w,0));\n\n\td[0] = pii(0,1);\n\td[1] = pii(0,-1);\n\td[2] = pii(1,0);\n\td[3] = pii(-1,0);\n\n\tfor( int i = 0; i < h; i++ ) {\n\t\tfor( int j = 0; j < w; j++ ) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tsearch( ans, c, p );\n\tcout << ans << endl;\n\n\treturn 1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint h, w, c;\nint ans = 0;\nint pc = 0;\nvector< vector<int> > cp;\nint flag = 0;\n\nvoid change(vector< vector<int> > &p, int color, int y, int x, int tmp) {\n\tp[y][x] = color;\n\n\tif(x+1 < w) if(tmp == p[y][x+1])\n\t\tchange(p, color, y, x+1, tmp);\n\n\tif(y+1 < h) if(tmp == p[y+1][x])\n\t\tchange(p, color, y+1, x, tmp);\n\n\tif(x-1 >= 0) if(tmp == p[y][x-1])\n\t\tchange(p, color, y, x-1, tmp);\n\n\tif(y-1 >= 0) if(tmp == p[y-1][x])\n\t\tchange(p, color, y-1, x, tmp);\n\n\n}\n\nvoid pcount(vector< vector<int> > &p, int color, int y, int x) {\n\tp[y][x] = -1;\n\tpc++;\n\n\tif(ans < pc) ans = pc;\n\n\tif(x+1 < w) if(color == p[y][x+1])\n\t\tpcount(p, color, y, x+1);\n\n\tif(y+1 < h) if(color == p[y+1][x])\n\t\tpcount(p, color, y+1, x);\n\n\tif(x-1 >= 0) if(color == p[y][x-1])\n\t\tpcount(p, color, y, x-1);\n\n\tif(y-1 >= 0) if(color == p[y-1][x])\n\t\tpcount(p, color, y-1, x);\n\n}\n\nvoid solve(vector< vector<int> > p, int color, int count) {\n\tif( p[0][0] != color ) change(p, color, 0, 0, p[0][0]);\n\n\tif( count < 5 ) {\n\t\tif( count < 4  ) {\n\t\t\tfor(int i = 1; i <= 6 ; i++) {\n\t\t\t\tif( p[0][0] == i ) continue;\n\t\t\t\tsolve(p, i, count+1);\n\t\t\t}\n\t\t} else {\n\t\t\tsolve(p, c, count+1);\n\t\t}\n\t}else {\n\t\tcp = p;\n\t\tpc = 0;\n\t\tpcount(p, p[0][0], 0, 0);\n\t\tflag = 1;\n\t}\n\n}\n\nint main(void) {\n\tvector< vector<int> > p;\n\tint i, j;\n\n\twhile(1) {\n\t\tp.clear();\n\t\tans = 0;\n\t\tscanf(\"%d %d %d\", &h, &w, &c);\n\n\t\tif(h == 0 && w == 0 && c == 0) break;\n\n\t\tfor(i = 0; i < h; i++) {\n\t\t\tvector<int> v_tmp;\n\t\t\tint tmp;\n\t\t\tfor(j = 0; j < w; j++) {\n\t\t\t\tscanf(\"%d\", &tmp);\n\t\t\t\tv_tmp.push_back(tmp);\n\t\t\t}\n\t\t\tp.push_back(v_tmp);\n\t\t}\n\n\t\tfor(i = 1; i <= 6; i++) {\n\t\t\tif( p[0][0] == i ) continue;\n\t\t\tsolve(p, i, 1);\n\t\t}\n/*\t\t\nfor(int aa=1;aa<=6;aa++){\nfor(i=0;i<p.size();i++){\nfor(j=0;j<p[0].size();j++){\ncout<<p[i][j]<<\" \";\n}cout<<endl;\n}\tcout<<endl;\ncout<<\"change to \"<<(p[0][0])%6+1 <<endl;\nchange(p,(p[0][0])%6+1,0,0,p[0][0]);\n}\n*/\n\t\tprintf(\"%d\\n\", ans);\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define MAX_N 8\n#define MAX_M 8\n#define MAX_C 6\n#define INF 1000000\nusing namespace std;\n\nint N, M, C, ans = 1, nd, flag = 0;\nint field[MAX_N][MAX_M], d[MAX_N][MAX_M], dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nclass Graphs\n{\npublic:\n\tint g[MAX_N][MAX_M];\n\tint sum;\n\tint node;\n\tint intialize(int x[MAX_N][MAX_M]);\n\tint ingrh(int x[MAX_N][MAX_M]);\n\tvoid outgrh();\n\tint outNode();\n};\n\nint Graphs::intialize(int x[MAX_N][MAX_M])\n{\n\tnode = 0;\n\tsum = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tg[i][j] = field[i][j];\n\t\t\tif (g[i][j] == 7) sum++;\n\t\t}\n\t}\n\tif (ans < sum) ans = sum;\n\n\treturn node;\n}\n\nint Graphs::ingrh(int x[MAX_N][MAX_M])\n{\n\tsum = 0;\n\tnode++;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tg[i][j] = x[i][j];\n\t\t\tif (g[i][j] == 7) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans < sum) ans = sum;\n\n\treturn node;\n}\n\nvoid Graphs::outgrh()\n{\n\tfor (int i = 0; i < N; i++) \n\t\tfor (int j = 0; j < M; j++)  field[i][j] = g[i][j];\n}\n\ntypedef Graphs G;\ntypedef pair<int, int> P;\n\nG grh;\nqueue<G> que;\n\nvoid initINF(){\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\td[0][0] = 0; \n}\n\nvoid bfs(int color) {\n\tqueue<P> qg;\n\tqg.push(P(0, 0));\n\tinitINF();\n\twhile(qg.size()) {\n\t\tP p = qg.front();\n\t\tqg.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && (field[nx][ny] == 7 || field[nx][ny] == color) && d[nx][ny] == INF) {\n\t\t\t\tif (field[nx][ny] == color) flag = 1;\n\t\t\t\tqg.push(P(nx, ny));\n\t\t\t\td[nx][ny] = 0;\n\t\t\t\tfield[nx][ny] = 7;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint Graphs::outNode() { return node; }\n\nvoid solve()\n{\n\tint color;\n\tcolor = field[0][0];\n\tfield[0][0] = 7;\n\tbfs(color);\t\n\tgrh.intialize(field);\n\tnd = grh.outNode();\n\tque.push(grh);\n\tfor (int i = 0; nd < 4; i++) {\n\t\tfor (int j = 0; j < MAX_C+1; j++) {\n\t\t\tgrh = que.front();\n\t\t\tgrh.outgrh();\n\t\t\tflag = 0;\n\t\t\tbfs(j);\n\t\t\tif (flag == 1) {\n\t\t\t\tgrh.ingrh(field);\n\t\t\t\tque.push(grh);\n\t\t\t}\n\t\t}\n\t\tque.pop();\n\t\tif (que.size()) {\n\t\t\tgrh = que.front();\n\t\t\tnd = grh.outNode();\n\t\t}else break;\n\t}\n\twhile (que.size()) {\n\t\tgrh = que.front();\n\t\tque.pop();\n\t\tgrh.outgrh();\n\t\tbfs(C);\n\t\tgrh.ingrh(field);\n\t}\n}\n\nint main(void)\n{\n\twhile (cin >> N >> M >> C) {\n\t\tif (N == 0) break;\n\t\tans = 1;\n\t\tfor (int i = 0; i < N; i++) \n\t\t\tfor (int j = 0; j < M; j++) cin >> field[i][j];\n\t\tsolve();\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint H,W,C;\nconst int dx[] = {+1, 0,-1, 0};\nconst int dy[] = { 0,+1, 0,-1};\n\nvoid dfs(int data[8][8], int x, int y, int c)\n{\n\tint tc = data[x][y];\n\tdata[x][y] = c;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(0<=nx && nx<W && 0<=ny && ny<H)\n\t\t{\n\t\t\tif(data[nx][ny]==tc) dfs(data, nx, ny, c);\n\t\t}\n\t}\n}\n\nint cnt(int data[8][8], int x, int y)\n{\n\tint res=1;\n\tint tc = data[x][y];\n\tdata[x][y] = 0;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(0<=nx && nx<W && 0<=ny && ny<H)\n\t\t{\n\t\t\tif(data[nx][ny]==tc) res+=cnt(data, nx, ny);\n\t\t}\n\t}\n\treturn res;\n}\n\nint func(int data[8][8], int t)\n{\n\tif(t==4)\n\t{\n\t\tif(data[0][0]!=C) dfs(data, 0, 0, C);\n\t\treturn cnt(data, 0, 0);\n\t}\n\n\tint res=0;\n\tfor(int i=1; i<=6; i++)\n\t{\n\t\tint tmp[8][8];\n\t\tmemcpy(tmp, data, sizeof(tmp));\n\t\tif(tmp[0][0]!=i) dfs(tmp, 0, 0, i);\n\t\tres = max(res, func(tmp, t+1));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>H>>W>>C, H||W||C)\n\t{\n\t\tint data[8][8];\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\t{\n\t\t\tcin>>data[x][y];\n\t\t}\n\n\t\tcout << func(data, 0) << endl;\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint h, w, color;\nint ps[256];\n\nvoid fill(int r, int c, int p, int xs[256], int y) {\n  int i = (r << 4) | c;\n  if( xs[i] != p ) return;\n  xs[i] = y;\n  int dr[4] = {1, 0, -1, 0};\n  int dc[4] = {0, 1, 0, -1};\n  for(int k = 0; k < 4; ++k) {\n    int nr = r + dr[k];\n    int nc = c + dc[k];\n    if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n    fill(nr, nc, p, xs, y);\n  }\n}\n\nbool fs[256];\nint count2(int r, int c, int p, int xs[256]) {\n  int i = (r << 4) | c;\n  if( xs[i] != p ) return 0;\n  if( fs[i] ) return 0;\n  fs[i] = true;\n  int dr[4] = {1, 0, -1, 0};\n  int dc[4] = {0, 1, 0, -1};\n  int res = 1;\n  for(int k = 0; k < 4; ++k) {\n    int nr = r + dr[k];\n    int nc = c + dc[k];\n    if( not ( 0 <= nr and nr < h and 0 <= nc and nc < w ) ) continue;\n    res += count2(nr, nc, p, xs);\n  }\n  return res;\n}\n\nint count(int r, int c, int p, int xs[256]) {\n  for(int i = 0; i < 256; ++i) fs[i] = false;\n  return count2(r, c, p, xs);\n}\n\n\nint solve(int x, int xs[256]) {\n  if( x == 0 ) return count(0, 0, xs[0], xs);\n  int res = -1;\n  for(int i = 1; i <= 6; ++i) {\n    if( x == 1 and i != color ) continue;\n    if( xs[0] == i ) continue;\n    int ys[256];\n    for(int j = 0; j < 256; ++j) ys[j] = xs[j];\n    fill(0, 0, ys[0], ys, i);\n    res = std::max(res, solve(x - 1, ys));\n  }\n  return res;\n}\n\nint main() {\n  for(;;) {\n    scanf(\"%d %d %d\", &h, &w, &color);\n    if( h == 0 and w == 0 and color == 0 ) break;\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        scanf(\"%d\", &ps[(i<<4)|j]);\n      }\n    }\n    int res = solve(5, ps);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n\nusing namespace std;\n\n#define fin cin\n\nint panel[8][8];\nint h, w, last;\n\nbool come[8][8];\n\nvoid come_init() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcome[i][j] = false;\n\t\t}\n\t}\n}\n\n//????????????????????????????????£??\\????????????????¨????\nint getCount(int map[][8], int y, int x) {\n\n\t//??????????????¨NullPo??????\n\tif (x < 0 || y < 0 || x >= 8 || y >= 8)return 0;\n\t\n\tif (map[y][x] != map[0][0] || come[y][x])return 0;\n\n\tcome[y][x] = true;\n\n\tint count = 1;\n\tcount += getCount(map, y + 1, x);\n\tcount += getCount(map, y, x + 1);\n\tcount += getCount(map, y - 1, x);\n\tcount += getCount(map, y, x - 1);\n\n\treturn count;\n}\n\nvoid change(int map[][8], bool (*f_change)[8], int y, int x) {\n\tif (x < 0 || y < 0 || x >= 8 || y >= 8)return;\n\n\tif (map[y][x] != map[0][0] || f_change[y][x])return;\n\n\tf_change[y][x] = true;\n\n\tchange(map, f_change, y + 1, x);\n\tchange(map, f_change, y, x + 1);\n\tchange(map, f_change, y - 1, x);\n\tchange(map, f_change, y, x - 1);\n\n\t//cout << f_change[0][1];\n\n}\n\n\n//search(????????????????????????????????????????????????)\nint search(int map[][8], int level, int color) {\n\tstatic int max = 0;\n\tif (level == 0)max = 0;\n\n\t\n\t//??£??\\??????????????????color????????????\n\n\tbool f_change[8][8] = {};\n\t//f_change[0][0] = true;\n\n\tchange(map, f_change, 0, 0);\n\n\t/*\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\n\t\t\tif (map[i][j] == map[0][0]) {\n\t\t\t\tif (\n\t\t\t\t\t(i < 7 && map[i][j] == map[i + 1][j] && f_change[i + 1][j]) ||\n\t\t\t\t\t(j < 7 && map[i][j] == map[i][j + 1] && f_change[i][j + 1]) ||\n\t\t\t\t\t(i > 0 && map[i][j] == map[i - 1][j] && f_change[i - 1][j]) ||\n\t\t\t\t\t(j > 0 && map[i][j] == map[i][j - 1] && f_change[i][j - 1])\n\t\t\t\t\t)\n\t\t\t\t\tf_change[i][j] = true;\n\t\t\t}\n\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif(f_change[i][j])map[i][j] = color;\n\t\t}\n\t}\n\tlevel++;\n\n\tif (level < 4) {\n\n\t\tfor (int i = 1; i <= 6; i++) {\n\n\t\t\tint map_tmp[8][8];\n\n\t\t\t//copy\n\t\t\tfor (int y = 0; y < 8; y++) {\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tmap_tmp[y][x] = map[y][x];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint tmp = search(map_tmp, level, i);\n\t\t\tif (max < tmp)max = tmp;\n\n\t\t}\n\t}\n\t//4??????????????????5??????\n\telse if (level == 4) {\n\t\tint map_tmp[8][8];\n\n\t\t//copy\n\t\tfor (int y = 0; y < 8; y++) {\n\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\tmap_tmp[y][x] = map[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint tmp = search(map_tmp, level, last);\n\t\tif (max < tmp)max = tmp;\n\t\n\t}\n\t//5??????????????????\n\telse if (level == 5) {\n\t\tcome_init();\n\t\tint tmp = getCount(map, 0, 0);\n\t\tif (max < tmp) {\n\t\t\tmax = tmp;\n\n\t\t\tif(0)\n\t\t\t{\n\t\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\t\tcout << map[y][x] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tcout << \"   :   \" << level << \" \" << color << endl;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn max;\n}\n\n\nint main() {\n\t//ifstream fin(\"in.txt\");\n\n\twhile (true) {\n\t\tfin >> h >> w >> last;\n\t\tif ((h | w) == 0)break;\n\n\t\t//initialize\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tpanel[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\t//input\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfin >> panel[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tint panel_tmp[8][8];\n\t\t\t\n\t\t\t//copy\n\t\t\tfor (int y = 0; y < 8; y++) {\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tpanel_tmp[y][x] = panel[y][x];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint tmp = search(panel_tmp, 0, i);\n\t\t\tif (max < tmp)max = tmp;\n\t\t}\n\n\t\tcout << max << endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define REP(i,n) for(int i = 0;i<(n);i++)\n#define FOR(i,j,n) for(int i = (j);i<(n);i++)\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nusing namespace std;\n\nint ans = 0;\nconst int Col = 6;\n  int h,w;\nint TargetCol;\n\ninline bool isRange(int y,int x){\n  return y>=0&&y<h&&x>=0&&x<w;\n}\nvoid solve(int depth,vector<vector<int> > mp,int zeroc){\n  int pre_c = mp[0][0];\n  mp[0][0] = zeroc;\n  queue<pair<int,int> > que;\n  que.push(make_pair(0,0));\n\n  vector<vector<bool> > stepped(h,vector<bool>(w,false));\n  stepped[0][0] = true;\n  while(!que.empty()){\n    pair<int,int> now = que.front();\n    que.pop();\n    REP(i,4){\n      int y = now.first+dy[i];\n      int x = now.second+dx[i];\n      if(isRange(now.first+dy[i],now.second+dx[i]) \n      && mp[now.first+dy[i]][now.second+dx[i]] == pre_c && !stepped[y][x]){\n        mp[y][x] = zeroc;\n        stepped[y][x] = true;\n        que.push(make_pair(now.first+dy[i],now.second+dx[i]));\n      }\n    }\n  }\n  if(depth>=5){\n    int res = 1;\n    queue<pair<int,int> > q;\n    q.push(make_pair(0,0));\n    vector<vector<bool> > st(h,vector<bool>(w,false));\n    st[0][0] = true;\n    \n    while(!q.empty()){\n        pair<int,int> now = q.front();\n      q.pop();\n     REP(i,4){\n        int y = now.first+dy[i];\n        int x = now.second+dx[i];\n        if(isRange(y,x) && !st[y][x] && mp[y][x] == TargetCol){\n          res++;\n          st[y][x] = true;\n          q.push(make_pair(y,x));\n        }\n     }\n    }\n    ans = max(res,ans);\n  }else{\n    FOR(i,1,Col+1)solve(depth+1,mp,i);\n  }\n}\n\nint main(){\n  while(cin>>h>>w>>TargetCol,h){\n    ans = 0;\n    vector<vector<int> > mp(h,vector<int>(w));\n    REP(i,h)REP(j,w)cin>>mp[i][j];\n    FOR(i,1,Col+1)\n    solve(1,mp,i);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostReam>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint H,W,C;\nint board[8][8];\nint b[8][8];\nint check[8][8];\nint ord[5];\nint ans;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool in(int x, int y){\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y, int color){\n    //cerr << x << \" \" << y << \" \" << color << endl;\n    check[y][x] = 1;\n    for(int k = 0; k < 4; k++){\n        int nx = x + dx[k], ny = y + dy[k];\n        if(!in(nx, ny) || b[ny][nx] != color || check[ny][nx]) continue;\n        dfs(nx, ny, color);\n    }\n}\n\nint calc(){\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            b[i][j] = board[i][j];\n        }\n    }\n    for(int t = 0; t < 5; t++){\n        //cout << ord[t] << endl;\n        memset(check, 0, sizeof check);\n        dfs(0, 0, b[0][0]);\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                if(check[i][j]) b[i][j] = ord[t];\n            }\n        }\n    }\n\n    memset(check, 0, sizeof check);\n    dfs(0, 0, b[0][0]);\n    int ret = 0;\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            if(check[i][j] && b[i][j] == C) ret++;\n        }\n    }\n    return ret;\n}\n\nvoid f(int n){\n    if(n == 5){\n        ans = max(ans, calc());\n        return;\n    }\n    for(int i = 1; i <= 6; i++){\n        ord[n] = i;\n        f(n + 1);\n    }\n}\n\nint main(){\n    while(cin >> H >> W >> C, H){\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                cin >> board[i][j];\n            }\n        }\n        ans = 0;\n        f(0);\n        cout << ans <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\nvector<vector<int>> data(10,vi(10));\nll ans=0;\nint h,w,c;\n\nvoid paint(int y, int x, vector<vi> &tmp,int color, int origin_color){\n    tmp[y][x] = color;\n    int dy[]={1,0,-1,0}, dx[]={0,1,0,-1};\n    \n    rep(i,4){\n        int ddy = y+dy[i], ddx = x+dx[i];\n        if( ddx<0 || ddy<0 || ddx>=w || ddy>=h || tmp[ddy][ddx]!=origin_color )continue;\n        paint( ddy, ddx, tmp, color, origin_color );\n    }\n}\n\n\nint count(int y,int x, vector<vi> tmp,vector<vector<bool>> &used, int color){\n    used[y][x]=true;\n    int c=1;\n    int dy[]={1,0,-1,0}, dx[]={0,1,0,-1};\n    \n    rep(i,4){\n        int ddy = y+dy[i], ddx = x+dx[i];\n        if( ddx<0 || ddy<0 || ddx>=w || ddy>=h || used[ddy][ddx] || tmp[ddy][ddx]!=color )continue;\n        c+=count( ddy, ddx, tmp, used, color);\n    }\n    return c;\n}\n\n\nvoid solve(vi changed){\n    vector<vi> tmp = data;\n    \n    rep(i,changed.size()){\n        if( tmp[0][0]==changed[i] )continue;\n        paint(0,0,tmp,changed[i],tmp[0][0]);\n    }\n    \n\n    vector<vector<bool>> used(10,vector<bool>(10,false));\n    ans = max<ll>( count(0,0,tmp,used,tmp[0][0]) , ans );\n}\n\n\nvoid dfs(int f,vi changed){\n    if(f>=4){\n        changed.pb(c);\n        solve(changed);\n        return ;\n    }\n    rep(i,6){\n        changed.pb(i);\n        dfs(f+1,changed);\n        changed.pop_back();\n    }\n}\n\nint main(){\n    while(cin>>h>>w>>c&&(h||w||c)){\n        c--;\n        ans=0;\n        rep(i,10)rep(j,10)data[i][j]=-1;\n        rep(i,h) rep(j,w){\n            cin>>data[i][j];\n            data[i][j]--;\n        }\n        \n        vi changed;\n        dfs(0,changed);\n        \n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,k,n) for(int i=k;i<(int)(n);i++)\n\n#define vi vector<int>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n\ntypedef long long ll;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nint main(){\n    ifstream in(\"cin.txt\");\n    cin.rdbuf(in.rdbuf());\n    int h,w,c;\n    while(cin >> h >> w >> c,h||w||c){\n        int ma = 0;\n        int p[10][10] = {};\n        rep(y,h)rep(x,w) cin >> p[y][x];\n        int a[6] = {};\n        rep(bit,pow(6,4)){\n            int tmp_bit = bit;\n            rep(i,4){\n                a[i] = tmp_bit%6;\n                tmp_bit/=6;\n                a[i]+=1;\n                if(a>0 && a[i-1] == a[i]) a[0] = -1;\n//                cout << a[i] << \" \";\n            }\n            if(a[0] == -1) continue;\n//            cout << endl;\n            a[4] = c;\n//            rep(i,c) cout << a[i] << \" \";\n//            cout << endl;\n            int t[10][10];\n            rep(y,h)rep(x,w) t[y][x] = p[y][x];\n\n            rep(i,5){\n\n                queue<pii> que;\n                que.push(make_pair(0,0));\n                int now_color = t[0][0];\n                bool u[10][10] = {};\n                while(!que.empty()){\n                    int x,y;\n                    tie(x,y) = que.front();\n                    que.pop();\n                    u[y][x] = true;\n                    t[y][x] = a[i];\n                    rep(d,4){\n                        int nx = x + dx[d];\n                        int ny = y + dy[d];\n                        if(nx < 0 || w <= nx ||\n                                ny < 0 || h <= ny) continue;\n                        if(u[ny][nx] || t[ny][nx] != now_color) continue;\n                        que.push(make_pair(nx,ny));\n                    }\n                }\n            }\n            int cnt = 0;\n            queue<pii> qe;\n            qe.push(make_pair(0,0));\n            bool uu[10][10] = {};\n\n            while(!qe.empty()) {\n                int xp, yp;\n\n                tie(xp, yp) = qe.front();\n                qe.pop();\n                if(uu[yp][xp]) continue;\n                cnt += 1;\n                uu[yp][xp] = true;\n                rep(d, 4) {\n                    int nx = xp + dx[d];\n                    int ny = yp + dy[d];\n                    if (nx < 0 || w <= nx ||\n                        ny < 0 || h <= ny)\n                        continue;\n                    if(uu[ny][nx]) continue;\n                    if(t[ny][nx] != c) continue;\n                    qe.push(make_pair(nx, ny));\n                }\n            }\n            ma = max(ma,cnt);\n        };\n        cout << ma << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[10][10], y[10][10], z[10][10], p[6] = { 1,6,36,216,1296,7776 };\nint a[6], H, W, C, cnt, res; queue<pair<int, int>>Q;\nvoid h(int A, int B, int C) { if (z[A][B] == 0 && y[A][B] == C) { z[A][B] = 1; Q.push(make_pair(A, B)); } }\nint main() {\n\twhile (true) {\n\t\tfor (int j = 0; j < 100; j++) { x[j / 10][j % 10] = -1; }\n\t\tcin >> H >> W >> C; C--; if (H == 0 && W == 0 && C == -1) { break; }res = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j]; x[i][j]--;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < p[5]; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) { a[j] = (i / p[j]) % 6; }a[4] = C;\n\t\t\tfor (int j = 0; j < 100; j++) { y[j / 10][j % 10] = x[j / 10][j % 10]; }\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tQ.push(make_pair(1, 1));\n\t\t\t\tfor (int k = 0; k < 100; k++) { z[k / 10][k % 10] = 0; }z[1][1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpair<int, int>a0 = Q.front(); Q.pop(); int a1 = a0.first, a2 = a0.second, a3 = y[a1][a2];\n\t\t\t\t\th(a1 + 1, a2, a3); h(a1 - 1, a2, a3); h(a1, a2 - 1, a3); h(a1, a2 + 1, a3);\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 100; k++) { if (z[k / 10][k % 10] == 1) { y[k / 10][k % 10] = a[j];} }\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\tQ.push(make_pair(1, 1));\n\t\t\tfor (int k = 0; k < 100; k++) { z[k / 10][k % 10] = 0; }z[1][1] = 1;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tpair<int, int>a0 = Q.front(); Q.pop(); int a1 = a0.first, a2 = a0.second, a3 = y[a1][a2];\n\t\t\t\th(a1 + 1, a2, a3); h(a1 - 1, a2, a3); h(a1, a2 - 1, a3); h(a1, a2 + 1, a3);\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\tfor (int k = 0; k < 100; k++) { if (z[k / 10][k % 10] == 1) { cnt++; } }\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,k,n) for(int i=k;i<(int)(n);i++)\n\n#define vi vector<int>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n\ntypedef long long ll;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nint main(){\n    ifstream in(\"cin.txt\");\n    cin.rdbuf(in.rdbuf());\n    int h,w,c;\n    while(cin >> h >> w >> c,h){\n        int ma = 0;\n        int p[10][10] = {};\n        rep(y,h)rep(x,w) cin >> p[y][x];\n        int a[6] = {};\n        rep(bit,pow(6,4)){\n            int tmp_bit = bit;\n            rep(i,4){\n                a[i] = tmp_bit%6;\n                tmp_bit/=6;\n                a[i]+=1;\n                if(a>0 && a[i-1] == a[i]) a[0] = -1;\n//                cout << a[i] << \" \";\n            }\n            if(a[0] == -1 || a[3] == c) continue;\n//            cout << endl;\n            a[4] = c;\n//            rep(i,c) cout << a[i] << \" \";\n//            cout << endl;\n            int t[10][10];\n            rep(y,h)rep(x,w) t[y][x] = p[y][x];\n\n            rep(i,5){\n\n                queue<pii> que;\n                que.push(pii(0,0));\n                int now_color = t[0][0];\n                bool u[10][10] = {};\n                while(!que.empty()){\n                    int x,y;\n                    tie(x,y) = que.front();\n                    que.pop();\n                    if(u[y][x]) continue;\n                    u[y][x] = true;\n                    t[y][x] = a[i];\n                    rep(d,4){\n                        int nx = x + dx[d];\n                        int ny = y + dy[d];\n                        if(nx < 0 || w <= nx ||\n                                ny < 0 || h <= ny) continue;\n                        if(u[ny][nx] || t[ny][nx] != now_color) continue;\n                        que.push(pii(nx,ny));\n                    }\n                }\n            }\n            int cnt = 0;\n            queue<pii> qe;\n            qe.push(pii(0,0));\n            bool uu[10][10] = {};\n\n            while(!qe.empty()) {\n                int xp, yp;\n\n                tie(xp, yp) = qe.front();\n                qe.pop();\n                if(uu[yp][xp]) continue;\n                cnt += 1;\n                uu[yp][xp] = true;\n                rep(d, 4) {\n                    int nx = xp + dx[d];\n                    int ny = yp + dy[d];\n                    if (nx < 0 || w <= nx ||\n                        ny < 0 || h <= ny)\n                        continue;\n                    if(uu[ny][nx]) continue;\n                    if(t[ny][nx] != c) continue;\n                    qe.push(pii(nx, ny));\n                }\n            }\n            ma = max(ma,cnt);\n        };\n        cout << ma << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\nint h, w, c, f[8][8], p[8][8], dy[] = {-1,0,1,0}, dx[] = {0,-1,0,1};\n\nvoid count(int y, int x){\n  //  fprintf(stderr, \"%d %d\\n\", y, x);\n  f[y][x] = 1;\n  rep(d, 4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny < 0 || nx < 0 || ny >= h || nx >= w || p[ny][nx] != c || f[ny][nx]) continue;\n    count(ny, nx);\n  }\n}\n\nvoid change(int y, int x, int to, int from){\n  //  printf(\"%d %d %d %d\\n\", y, x, to, from);\n  f[y][x] = 1;\n  p[y][x] = to;\n  rep(d, 4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny < 0 || nx < 0 || ny >= h || nx >= w || p[ny][nx] != from || f[ny][nx]) continue;\n    change(ny, nx, to, from);\n  }\n}\n\nint dfs(int n){\n  //  fprintf(stderr, \"%d\\n\", n);\n  int res = 0;\n  if(n == 4){\n    //    rep(i, 8) printf(\"%d\", p[i][0]); puts(\"\");\n    //    fprintf(stderr, \"change\\n\");\n    memset(f, 0, sizeof(f));\n    change(0, 0, c, p[0][0]);\n    memset(f, 0, sizeof(f));\n    //    fprintf(stderr, \"count\\n\");\n    count(0, 0);\n    rep(y, h) rep(x, w) if(f[y][x]) res++;\n    //    fprintf(stderr, \"%d\\n\", res);\n    return res;\n  }\n  int tmp[8][8];\n  rep(i, 6){\n    //    fprintf(stderr, \"i %d\\n\", i);\n    rep(y, h) rep(x, w) tmp[y][x] = p[y][x];\n\n    memset(f, 0, sizeof(f));\n    change(0, 0, i, p[0][0]);\n    //    fprintf(stderr, \"change\\n\");\n    res = max(res, dfs(n+1));\n    //    fprintf(stderr, \"%d\\n\", res);\n    rep(y, h) rep(x, w) p[y][x] = tmp[y][x];\n  }\n  //  printf(\"%d\\n\", res);\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &h, &w, &c) && h+w+c){\n    c--;\n    rep(i, h) rep(j, w){\n      scanf(\"%d\", &p[i][j]);\n      p[i][j]--;\n    }\n    printf(\"%d\\n\", dfs(0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define MAX_N 8\n#define MAX_M 8\n#define MAX_C 6\n#define INF 1000000\nusing namespace std;\n\nint N, M, C, ans = 1, nd, flag = 0;\nint field[MAX_N][MAX_M], d[MAX_N][MAX_M], dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nclass Graphs\n{\npublic:\n\tint g[MAX_N][MAX_M];\n\tint sum;\n\tint node;\n\tint intialize(int x[MAX_N][MAX_M]);\n\tint ingrh(int x[MAX_N][MAX_M]);\n\tvoid outgrh();\n\tint outNode();\n};\n\nint Graphs::intialize(int x[MAX_N][MAX_M])\n{\n\tnode = 0;\n\tfor (int i = 0; i < N; i++) \n\t\tfor (int j = 0; j < M; j++) g[i][j] = field[i][j];\n\n\treturn node;\n}\n\nint Graphs::ingrh(int x[MAX_N][MAX_M])\n{\n\tsum = 0;\n\tnode++;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tg[i][j] = x[i][j];\n\t\t\tif (g[i][j] == 7) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\tif (node == 5 && ans < sum) ans = sum;\n\n\treturn node;\n}\n\nvoid Graphs::outgrh()\n{\n\tfor (int i = 0; i < N; i++) \n\t\tfor (int j = 0; j < M; j++)  field[i][j] = g[i][j];\n}\n\ntypedef Graphs G;\ntypedef pair<int, int> P;\n\nG grh;\nqueue<G> que;\n\nvoid initINF(){\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\td[0][0] = 0; \n}\n\nvoid bfs(int color) {\n\tqueue<P> qg;\n\tqg.push(P(0, 0));\n\tinitINF();\n\twhile(qg.size()) {\n\t\tP p = qg.front();\n\t\tqg.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && (field[nx][ny] == 7 || field[nx][ny] == color) && d[nx][ny] == INF) {\n\t\t\t\tif (field[nx][ny] == color) flag = 1;\n\t\t\t\tqg.push(P(nx, ny));\n\t\t\t\td[nx][ny] = 0;\n\t\t\t\tfield[nx][ny] = 7;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint Graphs::outNode() { return node; }\n\nvoid solve()\n{\n\tint color;\n\tcolor = field[0][0];\n\tfield[0][0] = 7;\n\tbfs(color);\t\n\tgrh.intialize(field);\n\tnd = grh.outNode();\n\tque.push(grh);\n\tfor (int i = 0; nd < 4; i++) {\n\t\tfor (int j = 0; j < MAX_C+1; j++) {\n\t\t\tgrh = que.front();\n\t\t\tgrh.outgrh();\n\t\t\tif (j == C) continue;\n\t\t\tflag = 0;\n\t\t\tbfs(j);\n\t\t\tif (flag == 1) {\n\t\t\t\tgrh.ingrh(field);\n\t\t\t\tque.push(grh);\n\t\t\t}\n\t\t}\n\t\tque.pop();\n\t\tif (que.size()) {\n\t\t\tgrh = que.front();\n\t\t\tnd = grh.outNode();\n\t\t}else break;\n\t}\n\twhile (que.size()) {\n\t\tgrh = que.front();\n\t\tque.pop();\n\t\tgrh.outgrh();\n\t\tbfs(C);\n\t\tgrh.ingrh(field);\n\t}\n}\n\nint main(void)\n{\n\twhile (cin >> N >> M >> C) {\n\t\tif (N == 0) break;\n\t\tans = 1;\n\t\tfor (int i = 0; i < N; i++) \n\t\t\tfor (int j = 0; j < M; j++) cin >> field[i][j];\n\t\tsolve();\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[4] = {0,-1,1,0};\nint dy[4] = {-1,0,0,1};\nint w,h,c,ans,color_cnt;\n\nint colorConut(const vector<vector<int> >& a){\n\tint s=0;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( a[y][x] == -1 ) s++;\n\t\t}\n\t}\n\treturn s;\n}\n\nvoid change(vector<vector<int> >& a, int x, int y, int prev_c, int next_c){\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\tif( a[my][mx] == prev_c ){\n\t\t\ta[my][mx] = next_c;\n\t\t\tchange( a , mx , my , prev_c , next_c );\n\t\t}\n\t}\n}\n\nvoid solve(const vector<vector<int> >& a, int cnt){\n\tif( cnt == 6 ){\n\t\tvector<vector<int> > b = a;\n\t\tb[0][0] = -1;\n\t\tchange( b , 0 , 0 , c , -1 );\n\t\tans = max( ans , colorConut(b) );\n\t}else{\n\t\tfor(int i=1 ; i <= 6 ; i++ ){\n\t\t\tvector<vector<int> > b = a;\n\t\t\tif( a[0][0] == i ) continue;\n\t\t\tb[0][0] = i;\n\t\t\tchange( b , 0 , 0 , a[0][0] , i );\n\t\t\tsolve( b , cnt+1 );\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> h >> w >> c , h || w || c ){\n\t\tvector<vector<int> > a;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tvector<int> v;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tint e;\n\t\t\t\tcin >> e;\n\t\t\t\tv.push_back( e );\n\t\t\t}\n\t\t\ta.push_back( v );\n\t\t}\n\t\tans = 0;\n\t\tsolve( a , 1 );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\nconst int dx[]={0,0,-1,1};\nconst int dy[]={-1,1,0,0};\n\npair<int,int> joint[70];\nint h,w,c;\nint p[8][8];\nbool f[8][8];\n\nint solve(int now,int prev,int cnt){\n\tint ret=cnt;\n\t\n\tif(now==6){\n\t\treturn cnt;\n\t}\n\t\n\tfor(int color=1;color<=6;color++){\n\t\tint cc=cnt;\n\t\tqueue<pair<int,int> > q;\n\t\t\n\t\tif((now==5 && color!=c)||(now==0 && color!=prev)){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tq.push(joint[i]);\n\t\t}\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tint x=q.front().second;\n\t\t\tint y=q.front().first;\n\t\t\t\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i];\n\t\t\t\tint yy=y+dy[i];\n\t\t\t\t\n\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h && p[yy][xx]==color && !f[yy][xx]){\n\t\t\t\t\tf[yy][xx]=true;\n\t\t\t\t\tjoint[cc].first=yy;\n\t\t\t\t\tjoint[cc].second=xx;\n\t\t\t\t\tq.push(joint[cc++]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(now==0 || cc!=cnt){\n\t\t\tret=max(ret,solve(now+1,color,cc));\n\t\t\t\n\t\t\tfor(int i=cnt;i<cc;i++){\n\t\t\t\tint x=joint[i].second;\n\t\t\t\tint y=joint[i].first;\n\t\t\t\tf[y][x]=false;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\t\n\twhile(cin>>h>>w>>c,h||w||c){\n\t\t\t\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tcin>>p[y][x];\n\t\t\t\tf[y][x]=false;\n\t\t\t}\n\t\t}\n\t\tf[0][0]=true;\n\t\t\n\t\tcout<<solve(0,p[0][0],1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n\nint Y,X,obj,cnt;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nvoid dfs2(int y, int x, int now, int next, vector< vector<int> >& state){\n  int i;\n\n  cnt++;\n  state[y][x] = next;\n  REP(i,4){\n    int my = y + dy[i];\n    int mx = x + dx[i];\n    if(0 <= my && my < Y && 0 <= mx && mx < X && state[my][mx] == now) dfs2(my,mx,now,next,state);\n  }\n}\n\nint dfs(int now, int next, int depth, vector< vector<int> > state){\n  int res=0,i;\n\n  cnt = 0;\n  dfs2(0,0,now,next,state);\n\n  if(now == obj && depth != 0) return cnt;\n  if(depth == 5) return 0;\n\n  REP(i,7) if(i != 0 && i != next) res = max(res, dfs(next,i,depth+1,state));\n\n  return res;\n}\n\nint main(){\n  int i,j;\n  vector< vector<int> > board;\n\n  while(1){\n    cin >> Y >> X >> obj;\n    if(X == 0 && Y == 0 && obj == 0) break;\n\n    board.resize(Y);\n    REP(i,Y) board[i].resize(X);\n    REP(i,Y) REP(j,X) cin >> board[i][j];\n\n    int res = 0, now = board[0][0];\n    REP(i,7) if(i != 0 && now != i) res = max(res,dfs(now,i,0,board));\n\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define L(a,d) ((a)<<((d)*3))\n#define R(a,d) (((a)>>((d)*3))&7)\nint h,w,c,f[16][16],ofs[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nvoid P(int d){int m=~L(7,d+1);rep(i,h)rep(j,w){f[i][j]&=m;f[i][j]|=L(R(f[i][j],d),d+1);}}\nint F(int x,int y, int d, int C){int n=1;int a=R(f[y][x],d);int m=~L(7,d+1);f[y][x]&=m;f[y][x]|=L(C,d+1);for(auto l:ofs){int s=x+l[0];int t=y+l[1];if(0<=s&&s<w&&0<=t&&t<h&&R(f[t][s],d)==a&&R(f[t][s],d+1)!=C)n+=F(s,t,d,C);}return n;}\nint D(int d){if(d&4){P(d);F(0,0,d,c);P(d+1);return F(0,0,d+1,7);}int x=0;for(int r=1;r<=6;++r){P(d);F(0,0,d,r);int v=D(d+1);x=x>v?x:v;}return x;}\nint main(){while(cin>>h>>w>>c,h){rep(i,h)rep(j,w)cin>>f[i][j];cout<<D(0)<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint H, W, C, P[7][8][8];\n\nint isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint color(int n, int c, int d, int y, int x) {\n  if(P[n + 1][y][x] != d) return 0;\n\n  int dd[5] = { 0, 1, 0, -1, 0 };\n  int ret = 1;\n  P[n + 1][y][x] = c;\n  REP(i, 0, 4) {\n    int ny = y + dd[i], nx = x + dd[i + 1];\n    if(!isin(ny, nx)) continue;\n    ret += color(n, c, d, ny, nx);\n  }\n\n  return ret;\n}\n\nint dfs(int n) {\n  if(n == 5) {\n    REP(i, 0, H) REP(j, 0, W) P[n + 1][i][j] = P[n][i][j];\n    return color(n, 100, C, 0, 0);\n  }\n\n  int ret = 0;\n  REP(i, 1, 7) {\n    if(P[n][0][0] == i) continue;\n    REP(i, 0, H) REP(j, 0, W) P[n + 1][i][j] = P[n][i][j];\n    color(n, i, P[n][0][0], 0, 0);\n    ret = max(ret, dfs(n + 1));\n  }\n  return ret;\n}\n\nint main(void) {\n  while(cin >> H >> W >> C, H) {\n    REP(i, 0, H) REP(j, 0, W) {\n      cin >> P[0][i][j];\n      REP(k, 1, 7) P[k][i][j] = 0;\n    }\n    cout << dfs(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// IdenticallyColoredPanelsConnection.cpp\n#include <iostream>\nusing namespace std;\n\n#define SCAST(type, data) static_cast<type>((data))\n\nconst int MAX_MATRIX = 8;//??????????????§??°\n\ntypedef enum __COLOR{//???\n\tYELLOW=1, PEACH, RED, PURPLE, GREEN, BLUE, NONE_COLOR\n} COLOR;\ntypedef enum __CONNECT{//????????????????????°\n\tNO_CONNECT, UP=1, DOWN = 1<<1, LEFT= 1<<2, RIGHT = 1<<3\n} CONNECT;\n\nclass PANEL{\npublic:\n\tCOLOR col;//???????????????\n\tint connect;//????????£?????????\n\tbool check;//?????????????????§??????????????????????´?\n\tPANEL(){\n\t\tcol=NONE_COLOR;//????????¶???????????????\n\t\tconnect=NO_CONNECT;\n\t\tcheck = false;//????????§??????\n\t}\n};\n\nint h, w;\nCOLOR dest;\n\nvoid input(PANEL **p);\nvoid connectCheck(PANEL ** p);\nint colChange(PANEL ** chp, COLOR chcol);\nint colChange(PANEL ** chp, COLOR chcol, int row, int column);\nint search(PANEL **p);\n\nint main()\n{\n\tint c;\n\tPANEL **p;\n\twhile(true){\n\t\tcin.clear();//??\\??????????????????????????¢??????\n\t\tcin >> h >> w >> c;//???????????????????????\\???\n\t\tif(h==w && w==c && c==0){\n\t\t\tbreak;\n\t\t}\n\t\t//??????????????????\n\t\tp = new PANEL *[h];// h ????????????\n\t\tfor(int i=0; i<h; i++){\n\t\t\tp[i] = new PANEL[w];// i ????????¨??? w ?????????????????????\n\t\t}\n\t\t//??????????????????\n\t\tdest = SCAST(COLOR, c);\n\t\tinput(p);\t\t\t//???????????\\???\n\t\tconnectCheck(p);\t//????????????????????????????¢????\n\t\tcout << search(p) << endl;//?????°?????????\n\t\tfor(int i=0; i<h; i++) delete[] p[i];\t//??????????????????\n\t\tdelete[] p;\t\t\t\t\t\t\t\t//\n\t}\n\treturn 0;\n}\n\nvoid input(PANEL **p)\n\t/*????????????????????\\?????????\n\t* p ??\\?????????????????????????????????\n\t*/\n{\n\tint panel[MAX_MATRIX][MAX_MATRIX];\n\tfor(int i=0; i<h; i++){\n\t\tswitch(w){//????????°????????£?????\\???????????´\n\t\tcase 1:\n\t\t\tcin >> panel[i][0];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcin >> panel[i][0] >> panel[i][1];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3];\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4];\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5];\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5] >> panel[i][6];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tcin >> panel[i][0] >> panel[i][1] >> panel[i][2] >> panel[i][3]\n\t\t\t>> panel[i][4] >> panel[i][5] >> panel[i][6] >> panel[i][7];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tCOLOR col = SCAST(COLOR, panel[i][j]);\n\t\t\tif(0 < col && col < NONE_COLOR)\n\t\t\t\tp[i][j].col = col;//????????????\n\t\t\telse\n\t\t\t\tp[i][j].col = NONE_COLOR;//???????????\\????????´???????????????\n\t\t}\n\t}\n}\n\nvoid connectCheck(PANEL **p)\n\t/*?????????????£?????????????????????§????????????\n\t* p ?????§????????????????????????????????????\n\t*/\n{\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tp[i][j].connect = NO_CONNECT;\n\t\t\t//????????°????????????\n\t\t\tif(i!=0){\n\t\t\t\t//???????????????????????´???????????£?????????\n\t\t\t\tif((p[i-1][j].connect & DOWN)!=0){\n\t\t\t\t\tp[i][j].connect |= UP;//???????????°????????????\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<h-1){\n\t\t\t\tif(p[i+1][j].col == p[i][j].col){//?????????????????¨????????????\n\t\t\t\t\tp[i][j].connect |= DOWN;//???????????°????????????\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j!=0){\n\t\t\t\t//???????????????????????´???????????£?????????\n\t\t\t\tif((p[i][j-1].connect & RIGHT)!=0){\n\t\t\t\t\tp[i][j].connect |= LEFT;//???????????°????????????\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j<w-1){\n\t\t\t\tif(p[i][j+1].col == p[i][j].col){//?????????????????¨????????????\n\t\t\t\t\tp[i][j].connect |= RIGHT;//???????????°????????????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint colChange(PANEL **chp, COLOR chcol)\n\t/*?????????????????????????????????????????????\n\t* chp\t????????????????????????\n\t* chcol\t??????????????????\n\t* ????????????????????°?????????\n\t*/\n{\n\tchp[0][0].col = chcol;\n\t//?????????????????????????????¨??????????????£??????????????´???????????????\n\tif(chp[0][0].connect == NO_CONNECT) return 1;\n\tint changenum=colChange(chp, chcol, 0, 0);//?????°??¨??? colChange ???????????????\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tchp[i][j].check = false;//????§????\n\t\t}\n\t}\n\treturn changenum;\n}\nint colChange(PANEL **chp, COLOR chcol, int row, int column)\n\t/*?????????????????????????????????????????°??¨??????\n\t* chp\t\t????????????????????????\n\t* chcol\t\t??????????????????\n\t* row\t\t?????¨??????\n\t* column\t   ??????\n\t* ????????????????????°?????????\n\t*/\n{\n\tif(chp[row][column].check) return 0;//?????§?????????????????????????????¨??????????????????\n\tint chpanels = 1;\t\t\t\t//?????¨???????????????????????????????????????1??????\n\tchp[row][column].check = true;\t//?????§?????????????????????\n\tchp[row][column].col = chcol;\t//?????¨????????????????????????????????????\n\n\tif((chp[row][column].connect & UP) != 0)\n\t\tchpanels += colChange(chp, chcol, row-1, column);\n\n\tif((chp[row][column].connect & DOWN) != 0)\n\t\tchpanels += colChange(chp, chcol, row+1, column);\n\n\tif((chp[row][column].connect & LEFT) != 0)\n\t\tchpanels += colChange(chp, chcol, row, column-1);\n\n\tif((chp[row][column].connect & RIGHT) != 0)\n\t\tchpanels += colChange(chp, chcol, row, column+1);\n\n\treturn chpanels;//????????????????????°?????????\n}\n\nint search(PANEL **p)\n\t/*5??????????????????????????¨???????????????????????§?????°???????????????????????????\n\t* p ?????????????????????\n\t* ?????§?????°?????????\n\t*/\n{\n\tint ans=0;//??????\n\tPANEL **chp1,\n\t\t**chp2,\n\t\t**chp3,\n\t\t**chp4;//????????????????????????\n\tfor(int i=YELLOW; i<NONE_COLOR; i++){\n\t\tchp1 = new PANEL*[h];\n\t\tfor(int j=0; j<h; j++){\n\t\t\tchp1[j]=new PANEL[w];\n\t\t\tfor(int k=0; k<w; k++)chp1[j][k] = p[j][k];//????????¶???????????????????????????\n\t\t}\n\t\tcolChange(chp1, SCAST(COLOR, i));//1??????\n\t\tconnectCheck(chp1);//?????????????????????????¢????\n\n\t\tfor(int j=YELLOW; j<NONE_COLOR; j++){\n\t\t\tif(i==j) continue;\n\n\t\t\tchp2 = new PANEL*[h];\n\t\t\tfor(int k=0; k<h; k++){\n\t\t\t\tchp2[k]=new PANEL[w];\n\t\t\t\tfor(int l=0; l<w; l++) chp2[k][l] = chp1[k][l];\n\t\t\t}\n\t\t\tcolChange(chp2, SCAST(COLOR, j));//2??????\n\t\t\tconnectCheck(chp2);\n\n\t\t\tfor(int k=YELLOW; k<NONE_COLOR; k++){\n\t\t\t\tif(k==j) continue;\n\n\t\t\t\tchp3 = new PANEL*[h];\n\t\t\t\tfor(int l=0; l<h; l++){\n\t\t\t\t\tchp3[l]=new PANEL[w];\n\t\t\t\t\tfor(int m=0; m<w; m++) chp3[l][m] = chp2[l][m];\n\t\t\t\t}\n\t\t\t\tcolChange(chp3, SCAST(COLOR, k));//3??????\n\t\t\t\tconnectCheck(chp3);\n\n\t\t\t\tfor(int l=YELLOW; l<NONE_COLOR; l++){\n\t\t\t\t\tif(l==k) continue;\n\t\t\t\t\tif(l==dest) continue;\n\t\t\t\t\tchp4 = new PANEL*[h];\n\t\t\t\t\tfor(int m=0; m<h; m++){\n\t\t\t\t\t\tchp4[m]=new PANEL[w];\n\t\t\t\t\t\tfor(int n=0; n<w; n++) chp4[m][n] = chp3[m][n];\n\t\t\t\t\t}\n\t\t\t\t\tcolChange(chp4, SCAST(COLOR, l));//4??????\n\t\t\t\t\tconnectCheck(chp4);\n\n\t\t\t\t\tcolChange(chp4, dest);//5??????\n\t\t\t\t\tconnectCheck(chp4);\n\n\t\t\t\t\tint pnum = colChange(chp4, dest);//??°????¢????\n\t\t\t\t\tif(ans < pnum){\n\t\t\t\t\t\tans=pnum;//?????¨????????§?????°??¨?????????\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int m=0; m<h; m++){\n\t\t\t\t\t\tdelete[] chp4[m];\n\t\t\t\t\t}\n\t\t\t\t\tdelete[] chp4;\n\n\t\t\t\t}\n\n\t\t\t\tfor(int l=0; l<h; l++){\n\t\t\t\t\tdelete[] chp3[l];\n\t\t\t\t}\n\t\t\t\tdelete[] chp3;\n\n\t\t\t}\n\n\t\t\tfor(int k=0; k<h; k++){\n\t\t\t\tdelete[] chp2[k];\n\t\t\t}\n\t\t\tdelete[] chp2;\n\n\t\t}\n\n\t\tfor(int j=0; j<h; j++){\n\t\t\tdelete[] chp1[j];\n\t\t}\n\t\tdelete[] chp1;\n\n\t}\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\nbool used[10][10];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nint dfs(vector<vector<int> > &grid, int bef, int aft, int x = 0, int y = 0){\n  int res = 0;\n  used[y][x] = true;\n  grid[y][x] = aft; \n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(not (0 <= nx and nx < grid[0].size() and \n            0 <= ny and ny < grid.size()))continue;\n    if(used[ny][nx] or grid[ny][nx] != bef)continue;\n    res += dfs(grid, bef, aft, nx, ny) + 1;\n  }\n  return res;\n}\n\nint check(vector<vector<int> > grid, vector<int> &perm){\n  for (int i = 0; i < perm.size(); i++) {\n    memset(used, false, sizeof(used));\n    dfs(grid, grid[0][0], perm[i]);\n  }\n  memset(used, false, sizeof(used));\n  return dfs(grid, perm.back(), perm.back()) + 1;\n}\n\nint solve(vector<vector<int> > &grid, vector<int> &perm, int d=0){\n  int res = 0;\n  if(d == 4)return check(grid, perm); \n  for (int i = 0; i < 6; i++){\n    perm[d] = i;\n    res = max(res ,solve(grid, perm, d + 1));\n  } \n  return res;\n}\n          \n\nint main(){\n  int h, w, c;\n  while(std::cin >> h >> w >> c, h){\n    c--;\n    vector<vector<int> > grid(h, vector<int>(w));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        std::cin >> grid[i][j];\n        grid[i][j]--;\n      }\n    }\n    vector<int> perm(5);\n    perm[4] = c;\n    std::cout << solve(grid, perm) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint f[10][10];\nint h,w,c;\nint ret=-1;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\n\nvoid pr(){\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nvoid bfs(int count, int color){\n    int orig,cnt=1;\n    vector<pair<int,int> > vec;\n    deque<pair<int ,int> > q;\n    bool visited[10][10];\n    \n    memset(visited, false, sizeof(visited));\n    orig = f[1][1];\n    q.push_back(make_pair(1,1));\n    visited[1][1] = true;\n    vec.push_back(make_pair(1,1));\n    int tx,ty,nx,ny;\n    while(!q.empty()){\n        ty = q.front().first;\n        tx = q.front().second;\n        q.pop_front();\n\n        for(int i=0;i<4;i++){\n            ny = ty + dy[i];\n            nx = tx + dx[i];\n\n            if(f[ny][nx] == orig && visited[ny][nx] == false){\n                visited[ny][nx] = true;\n                vec.push_back(make_pair(ny,nx));\n                q.push_back(make_pair(ny,nx));\n                if(orig == c)cnt++;\n            }\n        }\n    }\n    \n    if(count == 5){\n        ret = max(ret, cnt);\n        return;\n    }\n\n    for(int i=0;i<vec.size();i++){\n        f[vec[i].first][vec[i].second] = color;\n    }\n\n    for(int i=1;i<=6;i++){\n        if(i != color){\n            bfs(count+1,i);\n        }\n    }\n\n    for(int i=0;i<vec.size();i++){\n        f[vec[i].first][vec[i].second] = orig;\n    }\n}\n\nint main(){\n    while(cin >> h >> w >> c){\n        if((h|w|c) == 0) break;\n        ret = -1;\n        memset(f, -1, sizeof(f));\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> f[i][j];\n            }\n        }\n        for(int i=1;i<=6;i++){\n            if(f[1][1] != i){\n                bfs(0,i);\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\ntypedef struct{\n\tchar mp[10][10];\n}M;\nM zero,flg,ch;\n\nvector<string>V;\nvoid init(string s){\n\tif(s.size()==5){\n\t\tV.push_back(s);\n\t\treturn;\n\t}\n\tfor(char c='1';c<='6';c++){\n\t\tinit(s+c);\n\t}\n}\n\nvoid saiki(int x,int y){\n\tif(flg.mp[x][y]=='0'){\n\t\tflg.mp[x][y]='1';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(ch.mp[x][y]==ch.mp[x+dx[i]][y+dy[i]] && flg.mp[x+dx[i]][y+dy[i]]=='0'){\n\t\t\t\tsaiki(x+dx[i],y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid draw(char c){\n\tfor(int i=0;i<100;i++){\n\t\tif(flg.mp[i/10][i%10]=='1'){\n\t\t\tch.mp[i/10][i%10]=c;\n\t\t}\n\t}\n}\n\nint cnt(){\n\tint p=0;\n\tfor(int i=0;i<100;i++){\n\t\tif(flg.mp[i/10][i%10]=='1'){\n\t\t\tp++;\n\t\t}\n\t}\n\treturn p;\n}\n\n\nint main(){\n\tinit(\"\");\n\t\n\tfor(int i=0;i<100;i++)zero.mp[i/10][i%10]='0';\n\t\n\tfor(int h,w,c;cin>>h>>w>>c,c;){\n\t\tint ans=0;\n\t\tM in = zero;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcin>>in.mp[j][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<V.size();i++){\n\t\t\tM tmp=in;\n\t\t\tM tmp2=tmp;\n\t\t\tfor(int j=0;j<V[i].size();j++){\n\t\t\t\tflg=zero;\n\t\t\t\tch=tmp;\n\t\t\t\tsaiki(1,1);\n\t\t\t\tdraw(V[i][j]);\n\t\t\t\ttmp=ch;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tflg=zero;\n\t\t\tch=tmp;\n\t\t\tsaiki(1,1);\n\t\t\tif(ch.mp[1][1]==(c+'0')){\n\t\t\t\tans=max(ans,cnt());\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nint ret;\nchar ct;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nvoid change(int depth, vector<string> board) {\n\tqueue<int> q;\n\tvector<int> v;\n\tq.push(0);\n\tbool visit[8][8];\n\tmemset(visit, false, sizeof(visit));\n\tvisit[0][0] = true;\n\twhile (!q.empty()) {\n\t\tint now = q.front(); q.pop();\n\n\t\tint y = now / 10;\n\t\tint x = now % 10;\n\n\t\tv.push_back(now);\n\n\t\trep(dir, 4) {\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (nx < 0 || nx >= board[0].size() || ny < 0 || ny >= board.size()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board[y][x] != board[ny][nx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (visit[ny][nx]) continue;\n\n\t\t\tvisit[ny][nx] = true;\n\n\t\t\tq.push(ny * 10 + nx);\n\t\t}\n\t}\n\tif (depth == 0) {\n\t\tif (board[0][0] != ct) return;\n\t\tret = max(ret, (int) v.size());\n\t\treturn;\n\t}\n\n\tfor (char c = '1'; c <= '6'; c++) {\n\t\tfor (int e : v) {\n\t\t\tboard[e / 10][e % 10] = c;\n\t\t}\n\t\tchange(depth - 1, board);\n\t}\n}\n\nsigned main() {\n\twhile (true) {\n\t\tint h, w;\n\t\tcin >> h >> w >> ct;\n\n\t\tif (h == 0) break;\n\n\t\tret = 0;\n\n\t\tvector<string> board;\n\n\t\trep(y, h) {\n\t\t\tstring tmp = \"\";\n\t\t\trep(x, w) {\n\t\t\t\ttmp += nextChar();\n\t\t\t}\n\t\t\tboard.push_back(tmp);\n\t\t}\n\n\t\tchange(5, board);\n\n\t\tcout << ret << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint w,h,Col;\ntypedef pair<int,int> C;\ntypedef vector<vector<int> > P;\nP V;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint res;\n\nP temp;\nint tres=0;\n\n\nvoid calc(int y,int x){\n\tif(y<0 || x<0 || x>=w || y>=h) return;\n\tif(temp[y][x]==Col){tres++;temp[y][x]=0;\n\tfor(int r=0;r<4;r++)\n\t\tcalc(y+dy[r],x+dx[r]);\n\t}\n}\n\nvoid on(P N,int count,int c){\n\n\tif(count==5){temp=N;tres=0;calc(0,0);res=max(res,tres);return;}\n\n\tint nc=N[0][0];\n\tqueue<C> Q;\n\tQ.push(make_pair(0,0));\n\tbool used[8][8];\n\tmemset(used,false,sizeof(used));\n\n\tint tres=0;\n\twhile(!Q.empty()){\n\t\tC now=Q.front();\n\t\tQ.pop();\n\t\tif(used[now.first][now.second]) continue;\n\t\tused[now.first][now.second]=true;\n\t\tN[now.first][now.second]=c;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint ny=now.first+dy[r],nx=now.second+dx[r];\n\t\t\tif(ny<0 || nx<0 || ny>=h || nx>=w) continue;\n\t\t\tif(N[ny][nx]==nc)\n\t\t\t\tQ.push(make_pair(ny,nx));\n\t\t}\n\t}\n\n\tif(count!=4){\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tif(c!=i)\n\t\t\t\ton(N,count+1,i);\n\t\t}\n\t}\n\telse on(N,count+1,Col);\n}\n\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tV.resize(h);\n\n\tfor(int y=0;y<h;y++)\n\t\tfor(int x=0;x<w;x++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tV[y].push_back(t);\n\t\t}\n\t\n\tfor(int i=1;i<=6;i++){\n\t\tif(V[0][0]!=i)\n\t\t on(V,0,i);\n\t}\n\n\tcout<<res<<endl;\n\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w>>Col){\n\t\tif(w==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nint dpanel[8][10][10];\nint h,w,pmax,lastcol;\nint dx[]={-1,0,1,0};\nint dy[]={0,1,0,-1};\n\n\nint _count(const int panel[10][10], int visit[10][10], int col, int x,int y){\n\tint sum = 0;\n\tif(x<0 || y<0 || x>=w || y>=h)return sum;\n\t\n\tif(visit[y][x]==1)return sum;\n\tvisit[y][x]=1;\n\t\n\tif(panel[y][x]==col){\n\t\tsum++;\n\t\trep(i,4){\n\t\t\tsum += _count(panel, visit, col, x+dx[i], y+dy[i]);\n\t\t}\n\t}\n\treturn sum;\n}\nint count(const int panel[10][10]){\n\tint visit[10][10];\n\trep(i,10)rep(j,10)visit[i][j]=0;\n\t\n\treturn _count(panel, visit, panel[0][0], 0, 0);\n}\nvoid _change(int panel[10][10], int first, int col,int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h)return;\n\t\n\tif(panel[y][x]==first){\n\t\tpanel[y][x]=col;\n\t\trep(i,4){\n\t\t\t_change(panel ,first,col,x+dx[i],y+dy[i]);\n\t\t}\n\t}\n}\nvoid change(int panel[10][10], int col){\n\tif(panel[0][0]==col)return;\n\t_change(panel, panel[0][0], col, 0, 0);\n}\n\nvoid copy(int b1[10][10], int b2[10][10]){\n\trep(i,10)rep(j,10)b1[i][j]=b2[i][j];\n}\n\nvoid print(int b[10][10]){\n\tstatic int c = 0;\n\tprintf(\"c=%d\\n\",c);\n\tc++;\n\t\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tprintf(\"%d \",b[i][j]);\n\t\t}puts(\"\");\n\t}puts(\"\");\n}\n\nint saiki(int depth){\n\tcopy(dpanel[depth] ,dpanel[depth-1]);\n\t\n\tif(depth == pmax+1){\n\t\tif(dpanel[depth][0][0]!=lastcol)return 0;\n\t\treturn count(dpanel[depth]);\n\t}\n\t\n\tint maxi = 0;\n\treps(col,1,7){\n\t\tchange(dpanel[depth], col);\n\t\tint ret = saiki(depth+1);\n\t\tmaxi = max(maxi, ret);\n\t\t\n\t\tcopy(dpanel[depth] ,dpanel[depth-1]);\n\t}\n\t\n\treturn maxi;\n}\n\n\nint main(){\n\twhile(1){\n\t\tpmax = 5;\n\t\tcin>>h>>w>>lastcol;\n\t\tif(h==0)break;\n\t\t\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>dpanel[0][i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = saiki(1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[y][x] == b[ty][tx] && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nvoid cpy(int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tif (b[0][0] != c) cpy(0), rec(0, 0, c);\n\tcpy(2), ret = rec1(0, 0), cpy(1);\n\tif (d < 4) {\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(0), rec(0, 0, i);\n\t\t\tret = max(ret, solve(d + 1)), cpy(1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint w,h,Col;\ntypedef pair<int,int> C;\ntypedef vector<vector<int> > P;\nP V;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint res;\n\nvoid on(P N,int count,int c){\n\t\n\tif(count==6) return;\n\n\tint nc=N[0][0];\n\tqueue<C> Q;\n\tQ.push(make_pair(0,0));\n\tbool used[8][8];\n\tmemset(used,false,sizeof(used));\n\n\tint tres=0;\n\twhile(!Q.empty()){\n\t\tC now=Q.front();\n\t\tQ.pop();\n\t\tif(used[now.first][now.second]) continue;\n\t\tused[now.first][now.second]=true;\n\t\tN[now.first][now.second]=c;\n\t\ttres++;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint ny=now.first+dy[r],nx=now.second+dx[r];\n\t\t\tif(ny<0 || nx<0 || ny>=h || nx>=w) continue;\n\t\t\tif(N[ny][nx]==nc)\n\t\t\t\tQ.push(make_pair(ny,nx));\n\t\t}\n\t\tres=max(res,tres);\n\t}\n\n\tfor(int i=1;i<=6;i++)\n\t\ton(N,count+1,i);\n}\n\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tV.resize(h);\n\n\tfor(int y=0;y<h;y++)\n\t\tfor(int x=0;x<w;x++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tV[y].push_back(t);\n\t\t}\n\t\n\tfor(int i=1;i<=6;i++){\n\t\t on(V,0,i);\n\t}\n\n\tcout<<res<<endl;\n\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w>>Col){\n\t\tif(w==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint f[10][10];\nint h,w,c;\nint ret=-1;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\n\nvoid pr(){\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cout << f[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nvoid bfs(int count, int color){\n    int orig,cnt=1;\n    vector<pair<int,int> > vec;\n    deque<pair<int ,int> > q;\n    bool visited[10][10];\n    \n    memset(visited, false, sizeof(visited));\n    orig = f[1][1];\n    q.push_back(make_pair(1,1));\n    visited[1][1] = true;\n    vec.push_back(make_pair(1,1));\n    int tx,ty,nx,ny;\n    while(!q.empty()){\n        ty = q.front().first;\n        tx = q.front().second;\n        q.pop_front();\n\n        for(int i=0;i<4;i++){\n            ny = ty + dy[i];\n            nx = tx + dx[i];\n\n            if(f[ny][nx] == orig && visited[ny][nx] == false){\n                visited[ny][nx] = true;\n                vec.push_back(make_pair(ny,nx));\n                q.push_back(make_pair(ny,nx));\n                if(orig == c)cnt++;\n            }\n        }\n    }\n    \n    if(count == 5){\n        ret = max(ret, cnt);\n        return;\n    }\n\n    for(int i=0;i<vec.size();i++){\n        f[vec[i].first][vec[i].second] = color;\n    }\n\n    for(int i=1;i<=6;i++){\n        if(i != color){\n            bfs(count+1,i);\n        }\n    }\n\n    for(int i=0;i<vec.size();i++){\n        f[vec[i].first][vec[i].second] = orig;\n    }\n}\n\nint main(){\n    while(cin >> h >> w >> c){\n        if((h|w|c) == 0) break;\n        ret = -1;\n        memset(f, -1, sizeof(f));\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> f[i][j];\n            }\n        }\n        for(int i=1;i<=6;i++){\n            if(f[1][1] != 1){\n                bfs(0,i);\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> point;\n\nint h, w;\nint p[8][8], q[8][8];\nconst int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nvoid change(int c)\n{\n    stack<point> s;\n\n    int b = q[0][0];\n    s.push(point(0, 0));\n    q[0][0] = c;\n    while (!s.empty()) {\n        int x = s.top().first, y = s.top().second;\n        s.pop();\n\n        for (int i = 0; i < 4; ++i) {\n            int xx = x + d[i][0], yy = y + d[i][1];\n            if (xx >= 0 && xx < w && yy >= 0 && yy < h && q[xx][yy] == b) {\n                s.push(point(xx, yy));\n                q[xx][yy] = c;\n            }\n        }\n    }\n}\n\nint count()\n{\n    stack<point> s;\n    bool v[8][8] = {};\n\n    int c = 0;\n    int b = q[0][0];\n    s.push(point(0, 0));\n    v[0][0] = true;\n    while (!s.empty()) {\n        int x = s.top().first, y = s.top().second;\n        s.pop();\n\n        ++c;\n        for (int i = 0; i < 4; ++i) {\n            int xx = x + d[i][0], yy = y + d[i][1];\n            if (xx >= 0 && xx < w && yy >= 0 && yy < h && !v[xx][yy] && q[xx][yy] == b) {\n                s.push(point(xx, yy));\n                v[xx][yy] = true;\n            }\n        }\n    }\n\n    return c;\n}\n\nint main()\n{\n    for (;;) {\n        int c;\n\n        scanf(\"%d %d %d\", &h, &w, &c);\n        if (h == 0 && w == 0 && c == 0)\n            break;\n\n        for (int i = 0; i < h; ++i)\n            for (int j = 0; j < w; ++j)\n                scanf(\"%d\", &p[j][i]);\n\n        int m = 0;\n        // 519 or 520 color patterns\n        for (int i = 0; i < 6 * 6 * 6 * 6; ++i) {\n            int b[5];\n            b[0] = i / (6 * 6 * 6) % 6 + 1;\n            b[1] = i / (6 * 6) % 6 + 1;\n            b[2] = i / 6 % 6 + 1;\n            b[3] = i % 6 + 1;\n            b[4] = c;\n\n            if (b[0] == p[0][0])\n                continue;\n            if (b[3] == c)\n                continue;\n            if (b[0] == b[1] || b[1] == b[2] || b[2] == b[3] || b[3] == b[4])\n                continue;\n\n            for (int i = 0; i < 8; ++i)\n                for (int j = 0; j < 8; ++j)\n                    q[i][j] = p[i][j];\n\n            for (int j = 0; j < 5; ++j)\n                change(b[j]);\n\n            m = max(count(), m);\n        }\n\n        printf(\"%d\\n\", m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint h,w,c,ans;\nint dw[4]={1,0,-1,0},dh[4]={0,1,0,-1};\n\nvoid dfs(int cell[8][8],int rank){\n\trank++;\n\tif(rank==5){\n\t\tif(cell[0][0]!=c){\n\t\t\tint tmp=cell[0][0];\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(0,0));\n\t\t\tcell[0][0]=c;\n\t\t\twhile(que.size()){\n\t\t\t\tint ph=que.front().first,pw=que.front().second;que.pop();\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(0<=ph+dh[j]&&ph+dh[j]<h&&0<=pw+dw[j]&&pw+dw[j]<w&&cell[ph+dh[j]][pw+dw[j]]==tmp){\n\t\t\t\t\t\tcell[ph+dh[j]][pw+dw[j]]=c;\n\t\t\t\t\t\tque.push(P(ph+dh[j],pw+dw[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=1;\n\t\tqueue<P> que;\n\t\tque.push(P(0,0));\n\t\tcell[0][0]=-1;\n\t\twhile(que.size()){\n\t\t\tint ph=que.front().first,pw=que.front().second;que.pop();\n\t\t\trep(j,4){\n\t\t\t\tif(0<=ph+dh[j]&&ph+dh[j]<h&&0<=pw+dw[j]&&pw+dw[j]<w&&cell[ph+dh[j]][pw+dw[j]]==c){\n\t\t\t\t\tcell[ph+dh[j]][pw+dw[j]]=-1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tque.push(P(ph+dh[j],pw+dw[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=max(ans,cnt);\n\t\treturn;\n\t}\n\trep(i,6){\n\t\tint z[8][8];\n\t\trep(j,8)rep(k,8)z[j][k]=cell[j][k];\n\t\tif(cell[0][0]==i)continue;\n\t\tqueue<P> que;\n\t\tque.push(P(0,0));\n\t\tint tmp=cell[0][0];\n\t\tcell[0][0]=i;\n\t\twhile(que.size()){\n\t\t\tint ph=que.front().first,pw=que.front().second;que.pop();\n\t\t\trep(j,4){\n\t\t\t\tif(0<=ph+dh[j]&&ph+dh[j]<h&&0<=pw+dw[j]&&pw+dw[j]<w&&cell[ph+dh[j]][pw+dw[j]]==tmp){\n\t\t\t\t\tcell[ph+dh[j]][pw+dw[j]]=i;\n\t\t\t\t\tque.push(P(ph+dh[j],pw+dw[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(cell,rank);\n\t\trep(j,8)rep(k,8)cell[j][k]=z[j][k];\n\t}\n}\n\nint main(){\n\tint cell[8][8];\n\twhile(cin>>h>>w>>c,h||w||c){\n\t\tans=0;\n\t\tc--;\n\t\trep(i,h)rep(j,w)cin>>cell[i][j];\n\t\trep(i,h)rep(j,w)cell[i][j]--;\n\t\tdfs(cell,0);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <utility>\n\nusing namespace std;\ntypedef vector<vector<int>> mat;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nvector<pii> d(4);\n\nint solve();\nint getCols( const int target, const mat & m );\nvoid setColor( const int col, mat &m );\nvoid search( int &ans, int target, mat &orig );\n\nint main(void) {\n\t\n\twhile(solve()){}\n\n\treturn 0;\n}\n\nvoid setColor( const int col, mat &m ) {\n\n\t//?????¨?????¨??????\n\tconst int orig = m[0][0];\n\n\tqueue<pii> q;\n\tq.push(pii(0,0));\n\tmat visited( m.size(), vi( m[0].size(), 0 ) );\n\tvisited[0][0] = 1;\n\n\twhile(!q.empty()) {\n\n\t\tpii p = q.front();\n\t\tq.pop();\n\t\tm[p.first][p.second] = col;\t\n\n\t\tfor( int i = 0; i < d.size(); i++ ) {\n\t\t\tpii n;\n\t\t\t\tn.first = p.first + d[i].first;\n\t\t\t\tn.second = p.second + d[i].second;\n\t\t\tif( n.first >= 0 && n.first < m.size() \n\t\t\t\t&& n.second >= 0 && n.second < m[0].size()\n\t\t\t\t&& visited[n.first][n.second] == 0\n\t\t\t\t&& m[n.first][n.second] == orig ) {\n\t\t\t\t\tvisited[n.first][n.second] = 1;\n\t\t\t\t\tq.push(n);\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t\n\n}\n\nint getCols( const int target, const mat& m) {\n\n\tint ret = 0;\n\tqueue<pii> q;\n\tq.push(pii(0,0));\n\tmat visited( m.size(), vi( m[0].size(), 0 ) );\n\tvisited[0][0] = 1;\n\n\twhile(!q.empty()){\n\n\t\tpii p = q.front();\n\t\tq.pop();\n\t\tret ++;\n\t\tfor( int i = 0; i < d.size(); i++ ) {\n\n\t\t\tpii n;\n\t\t\t\tn.first = p.first + d[i].first;\n\t\t\t\tn.second = p.second + d[i].second;\n\n\t\t\tif( n.first >= 0 && n.first < m.size() \n\t\t\t\t&& n.second >= 0 && n.second < m[0].size()\n\t\t\t\t&& visited[n.first][n.second] == 0\n\t\t\t\t&& m[n.first][n.second] == target ) {\n\t\t\t\t\tvisited[n.first][n.second] = 1;\n\t\t\t\t\tq.push(n);\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid search( int &ans, int target, mat &orig ) {\n\n\tstack<vi> s;\n\n\tfor( int i = 1; i <= 6; i++ ) {\n\t\ts.push(vi(1,i));\n\t}\n\n\twhile( !s.empty() ){\n\t\tvi t = s.top();\n\t\ts.pop();\n\t\t/*\n\t\tfor( int i = 0; i < t.size(); i++ )\n\t\t\tcout << t[i] << \" \";\n\t\tcout << endl;\n\t\t*/\n\t\tif( t.size() < 5 ) {\n\t\t\tt.push_back(0);\n\t\t\tfor( int i = 1; i <= 6; i++ ) {\n\t\t\t\tt[t.size()-1] = i;\n\t\t\t\ts.push(t);\n\t\t\t}\n\t\t} else if( t.size() == 5 ){\n\t\t\tmat m = orig;\n\t\t\tfor( int i = 0; i < t.size(); i++ ) {\n\t\t\t\tsetColor( t[i], m );\n\t\t\t}\n\t\t\tans = max( getCols( target, m ), ans);\n\t\t}\n\n\t}\n\n}\n\nint solve() {\n\n\tint h, w, c;\n\n\tcin >> h >> w >> c;\n\n\tif(!(h|w|c)){ return 0; }\n\n\tmat p(h,vector<int>(w,0));\n\n\td[0] = pii(0,1);\n\td[1] = pii(0,-1);\n\td[2] = pii(1,0);\n\td[3] = pii(-1,0);\n\n\tfor( int i = 0; i < h; i++ ) {\n\t\tfor( int j = 0; j < w; j++ ) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tsearch( ans, c, p );\n\tcout << ans << endl;\n\n\treturn 1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mkp make_pair \n\nint H,W,C;\n\nint P[10][10];\nint ans;\n\nvoid draw(int col){\n    int tar=P[0][0];\n    bool used[10][10]={};\n    queue<pair<int,int>> Q;\n    Q.push(mkp(0,0));\n    used[0][0]=true;\n    while(!Q.empty()){\n        int x,y;\n        tie(x,y)=Q.front();\n        Q.pop();\n\n        P[x][y]=col;\n\n        if(x+1<H&&used[x+1][y]==false&&P[x+1][y]==tar){\n            used[x+1][y]=true;\n            Q.push(mkp(x+1,y));\n        }\n        if(y+1<W&&used[x][y+1]==false&&P[x][y+1]==tar){\n            used[x][y+1]=true;\n            Q.push(mkp(x,y+1));\n        }\n        if(x-1>=0&&used[x-1][y]==false&&P[x-1][y]==tar){\n            used[x-1][y]=true;\n            Q.push(mkp(x-1,y));\n        }\n        if(y-1>=0&&used[x][y-1]==false&&P[x][y-1]==tar){\n            used[x][y-1]=true;\n            Q.push(mkp(x,y-1));\n        }\n    }\n}\n\nint count(){\n    int tar=P[0][0];\n    bool used[10][10]={};\n    queue<pair<int,int>> Q;\n    Q.push(mkp(0,0));\n    used[0][0]=true;\n    int res=0;\n    while(!Q.empty()){\n        int x,y;\n        tie(x,y)=Q.front();\n        Q.pop();\n\n        res++;\n\n        if(x+1<H&&used[x+1][y]==false&&P[x+1][y]==tar){\n            used[x+1][y]=true;\n            Q.push(mkp(x+1,y));\n        }\n        if(y+1<W&&used[x][y+1]==false&&P[x][y+1]==tar){\n            used[x][y+1]=true;\n            Q.push(mkp(x,y+1));\n        }\n        if(x-1>=0&&used[x-1][y]==false&&P[x-1][y]==tar){\n            used[x-1][y]=true;\n            Q.push(mkp(x-1,y));\n        }\n        if(y-1>=0&&used[x][y-1]==false&&P[x][y-1]==tar){\n            used[x][y-1]=true;\n            Q.push(mkp(x,y-1));\n        }\n    }\n    return res;\n}\n\nvoid rec(int num){\n    int pre[10][10]={};\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) pre[i][j]=P[i][j];\n\n    if(num==5){\n        draw(C);\n        ans=max(ans,count());\n    }else{\n        for(int k=1;k<=6;k++){\n            draw(k);\n            rec(num+1);\n            for(int i=0;i<H;i++) for(int j=0;j<W;j++) P[i][j]=pre[i][j];\n\n        }\n    }\n\n    for(int i=0;i<H;i++) for(int j=0;j<W;j++) P[i][j]=pre[i][j];\n}\n\nvoid solve(){\n    ans=0;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>P[i][j];\n        }\n    }\n\n    rec(1);\n    cout<<ans<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>H>>W>>C;\n      if(H==0&&W==0&&C==0) break;\n      solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint h,w,c;\nint in[8][8];\nint ans;\nvoid dfs(int de, int p[8][8]){\n  int np[8][8];\n  rep(k,6){\n    if(de==5 && k!=c) continue;\n    if(k==np[0][0]) continue;\n    rep(i,8)rep(j,8) np[i][j]=p[i][j];\n    bool vis[8][8]={};\n    queue<PI> q;\n    q.push(mp(0,0));\n    int tans=0;\n    int s=np[0][0];\n    while(!q.empty()){\n      int cx=q.front().F;\n      int cy=q.front().S;\n      q.pop();\n      if(vis[cx][cy]) continue;\n      vis[cx][cy] = true;\n      np[cx][cy]=k;\n      ++tans;\n      rep(i,4){\n        int nx=cx+dx[i];\n        int ny=cy+dy[i];\n        if(min(nx,ny)<0 || nx>=h || ny>=w || s!=np[nx][ny])\n          continue;\n        q.push(mp(nx,ny));\n      }\n    }\n    if(de<5) dfs(de+1,np);\n    if(s==c) ans=max(ans,tans);\n  }\n}\n\nvoid solve(){\n  --c;\n  rep(i,h)rep(j,w){\n    cin >> in[i][j];\n    --in[i][j];\n  }\n  ans = 0;\n  dfs(0,in);\n  cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> h >> w >> c && h) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// type {{{\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int,int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvll = vector<vector<ll>>;\n// }}}\n\n\n// macro {{{\n#define REP(i,n) for (int i=0; i<(n); ++i)\n#define RREP(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i,a,n) for (int i=(a); i<(n); ++i)\n#define RFOR(i,a,n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n// }}}\n\n\n// debug {{{\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    REP (i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n// }}}\n\n\n// chmax, chmin {{{\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// }}}\n\n\n// constants {{{\n#define inf(T) (numeric_limits<T>::max() / 2)\nconst ll MOD = 1e9+7;\nconst ld EPS = 1e-9;\nconst int dy[] = {0, 1, 0, -1},\n          dx[] = {-1, 0, 1, 0};\n// }}}\n\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int H, W, C;\n        cin >> H >> W >> C;\n        --C;\n        if (H == 0) break;\n\n        vvi p(H, vi(W));\n        REP (i, H) {\n            REP (j, W) {\n                cin >> p[i][j];\n                --p[i][j];\n            }\n        }\n\n        const int MAX = 5, COLORS = 6;\n\n        int ans = 0;\n\n        vector<int> a(MAX+1);\n        while (!a[MAX]) {\n\n            vvi board = p;\n            int ret = 0;\n\n            vvi used(H, vi(W));\n            used[0][0] = 1;\n\n            for (int color : a) {\n                queue<pair<int,int>> que;\n                REP (i, H) {\n                    REP (j, W) {\n                        if (used[i][j]) {\n                            que.emplace(i, j);\n                        }\n                    }\n                }\n\n                while (!que.empty()) {\n                    int i, j; tie(i, j) = que.front(); que.pop();\n                    REP (k, 4) {\n                        int y = i + dy[k], x = j + dx[k];\n                        if (y < 0 or H <= y or x < 0 or W <= x) continue;\n\n                        if (board[y][x] == board[i][j] and !used[y][x]) {\n                            used[y][x] = 1;\n                            que.emplace(y, x);\n                        }\n                    }\n                }\n\n                REP (i, H) {\n                    REP (j, W) {\n                        if (used[i][j]) {\n                            board[i][j] = color;\n                        }\n                    }\n                }\n            }\n\n            if (a[MAX-1] == C) {\n                int cnt = 0;\n                REP (i, H) {\n                    REP (j, W) {\n                        cnt += used[i][j];\n                    }\n                }\n                chmax(ans, cnt);\n            }\n\n            for (int i = 0; ++a[i] == COLORS; ++i) a[i] = 0;\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint p[10][10];\nint cp[10][10];\nint flag[10][10];\nint h,w,c;\n\nint sx[4]={0,1,0,-1};\nint sy[4]={1,0,-1,0};\nint col[7],res;\n\nint bfs(int cc){\n\tmemset(flag,0,sizeof(flag));\n\tqueue<P> que;\n\tque.push(P(1,1));\n\tflag[1][1]=1;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tint x=q.first,y=q.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=sx[i]+x,ny=sy[i]+y;\n\t\t\tif(flag[nx][ny]==0){\n\t\t\t\tif(cp[x][y]==cp[nx][ny]){\n\t\t\t\t\tflag[nx][ny]=1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(flag[j][i]==1)cp[j][i]=cc;\n\t\t\tcnt+=flag[j][i];\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid dfs(int x){\n\tif(x<4){\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tcol[x]=i;\n\t\t\tdfs(x+1);\n\t\t}\n\t}else{\n\t\tcol[4]=c;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcp[j][i]=p[j][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tbfs(col[i]);\n\t\t}\n\t\tres=max(res,bfs(7));\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&c);\n\t\tif(h+w+c==0)break;\n\t\tres=0;\n\t\tmemset(p,0,sizeof(p));\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&p[j][i]);\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nstruct S{\n  int A[9][9];\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h, w, c, p[9][9], colcnt, ans;\nbool visit[9][9];\n\nvoid paint(int bfcolor, int x, int y,int color, int tp[9][9]){\n  visit[y][x] = true;\n  bfcolor = tp[y][x];\n  tp[y][x] = color;\n  REP(k,0,4){\n    int posx = x + dx[k];\n    int posy = y + dy[k];\n    if(!CH(posx,0,w) || !CH(posy,0,h)) continue;\n    if(tp[posy][posx] != bfcolor || visit[posy][posx]) continue;\n    paint(bfcolor, posx, posy, color, tp);\n  }\n  return ;\n}\n\nvoid check(int x, int y, int color, struct S s){\n  visit[y][x] = true;\n  colcnt++;\n  REP(k,0,4){\n    int posx = x + dx[k];\n    int posy = y + dy[k];\n    if(!CH(posx,0,w) || !CH(posy,0,h)) continue;\n    if(s.A[posy][posx] != color || visit[posy][posx]) continue;\n    check(posx, posy, color, s);\n  }\n  return ;\n}\n\nvoid dfs(int k, int turn, struct S s){\n\n  //??????\n  int tp[9][9];\n  REP(i,0,h)REP(j,0,w) tp[i][j] = s.A[i][j];  //??????????????§??????????????¨???????????????\n  REP(i,0,h)REP(j,0,w) visit[i][j] = false;\n  paint(s.A[0][0],0,0,k,tp);\n  REP(i,0,h)REP(j,0,w) s.A[i][j] = tp[i][j]; //??????????????????????????????\n\n  //??????????????????????????§???????????????\n  //int maxpanel = 0;\n  REP(i,0,h)REP(j,0,w){\n    colcnt = 0;\n    if(s.A[i][j]==c){\n      REP(ii,0,h)REP(jj,0,w) visit[ii][jj] = false;\n      check(j,i,c,s);\n    }\n    //maxpanel = max(maxpanel, colcnt);\n    ans = max(ans, colcnt);\n  }\n  //ans = max(ans, maxpanel);\n\n  if(turn == 5){\n    return;\n  }\n\n\n  REP(kk,1,7){ //??????????????????????????????\n    int bcol = s.A[0][0];\n    dfs(kk,turn + 1,s);\n  }\n\n  return;\n}\n\nint main() {\n\nwhile(1){\n    cin>>h>>w>>c;\n    if(h==0 && w==0 && c==0) break;\n    REP(i,0,h)REP(j,0,w) cin>>p[i][j];\n\n    ans = 0;\n    S sc;\n    REP(i,0,h)REP(j,0,w) sc.A[i][j] = p[i][j];\n\n    REP(k,1,7) dfs(k,1,sc);\n\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint h,w,c,grid[8][8];\nbool vis[8][8];\n\n\nint Count(int x,int y, int col){\n\tint cnt=1;\n\tvis[y][x]=true;\n\t\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx && 0<=ny && nx<w && ny<h &&\n\t\t\tgrid[ny][nx]==col && !vis[ny][nx])cnt+=Count(nx,ny,col);\n\t}\n\treturn cnt;\n}\n\n\nvoid rec(int x,int y, int col){\n\tint tmp=grid[y][x],cnt=1;\n\tgrid[y][x]=col;\n\t\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx && 0<=ny && nx<w && ny<h && grid[ny][nx]==tmp)rec(nx,ny,col);\n\t}\n}\n\nint solve(int n){\n\tint ans=0;\n\tif(n==5){\n\t\tif(grid[0][0]!=c)rec(0,0,c);\n\t\tfill(vis[0],vis[8],false);\n\t\treturn Count(0,0,c);\n\t}\n\t\n\tint tmp[8][8];\n\trep(i,8)rep(j,8)tmp[i][j]=grid[i][j];\n\tfor(int i=1;i<7;i++){\n\t\tif(grid[0][0]!=i)rec(0,0,i);\n\t\tans=max(ans,solve(n+1));\n\t\t\n\t\trep(j,8)rep(k,8)grid[j][k]=tmp[j][k];\n\t}\n\treturn ans;\n}\n\nint main(void){\n\t\n\twhile(cin >> h >> w >> c,h|w|c){\n\t\tfill(grid[0],grid[8],0);\n\t\trep(i,h)rep(j,w)cin >> grid[i][j];\n\t\t\n\t\tcout << solve(1) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <random>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 1000000007;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\n// bool debug=false;\n\n/*---------------------------------------------------*/\n\nint h, w, c;\n\nvoid debug(vector<vector<int>>& p) {\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      cout << p[i][j];\n    }\n    cout << endl;\n  }\n}\n\nbool in(int x, int y) {\n  return (0 <= x && x < w && 0 <= y && y < h);\n}\n\nint count_color(vector<vector<int>>& p) {\n  int ret = 0;\n  //cout << \"======evaluata======\" << endl;\n  //debug(p);\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      int cnt = 0;\n      if(p[i][j] == c) {\n\tp[i][j] = -1;\n\tcnt = 1;\n\tqueue<int> que;\n\tque.push(j), que.push(i);\n\twhile(que.size()) {\n\t  int x = que.front(); que.pop();\n\t  int y = que.front(); que.pop();\n\t  for(int i = 0; i < 4; i++) {\n\t    int nx = x + dx[i], ny = y + dy[i];\n\t    if(in(nx, ny) && p[ny][nx] == c) {\n\t      cnt++;\n\t      p[ny][nx] = -1;\n\t      que.push(nx); que.push(ny);\n\t    }\n\t  }\n\t}\n      }\n      ret = max(ret, cnt);\n    }\n  }\n  //cout << \"count: \" << ret << endl;\n  return ret;\n}\n\nvector<vector<int>> paint(vector<vector<int>> p, int _x, int _y, int color) {\n  int pos_color = p[_y][_x];\n  if(pos_color == color) return p;\n  p[_y][_x] = color;\n  queue<int> que;\n  que.push(_x), que.push(_y);\n  // //cerr << \"start\" << endl;\n  while(que.size()) {\n    int x = que.front(); que.pop();\n    int y = que.front(); que.pop();\n    for(int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(in(nx, ny) && p[ny][nx] == pos_color) {\n\tp[ny][nx] = color;\n\tque.push(nx); que.push(ny);\n      }\n    }\n  }\n  // //cerr << \"end\" << endl;\n  return p;\n}\n\nint dfs(vector<vector<int>> p, int cnt) {\n  int ret = 0;\n  if(cnt == 0) {\n    return count_color(p);\n  }\n  for(int i = 1; i <= 6; i++) {\n    vector<vector<int>> new_p = paint(p, 0, 0, i);\n    ret = max(ret, dfs(new_p, cnt - 1));\n  }\n  return ret;\n}\n\nvoid solve() {\n  vector<vector<int>> p = vector<vector<int>>(h, vector<int>(w));\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      cin >> p[i][j];\n    }\n  }\n  cout << dfs(p, 5) << endl;\n}\n\nint main() {\n  while(cin >> h >> w >>c) {\n    if(h == 0 && w == 0 && c == 0) break;\n    solve();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint h,w,c;\nint data[100][100];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nint ans;\n\nint check(int grid[100][100]){\n\tint issearched[100][100] = {0};\n\tissearched[0][0] = 1;\n\tint cnt = 1;\n\tqueue<int> qx,qy;\n\tqx.push(0); qy.push(0);\n\twhile(!qx.empty()){\n\t\tint x = qx.front(); int y = qy.front();\n\t\tqx.pop(); qy.pop();\n\t\tREP(i,4){\n\t\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\t\tif(nx > -1 && ny > -1 && nx < h && ny < w && issearched[nx][ny] == 0){\n\t\t\t\tissearched[nx][ny] = 1;\n\t\t\t\tif(grid[nx][ny] == c){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tqx.push(nx); qy.push(ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid change(int col,int grid[100][100]){\n\tint issearched[100][100] = {0};\n\tqueue<int> qx,qy;\n\tqx.push(0); qy.push(0);\n\tint stcol = grid[0][0];\n\tgrid[0][0] = col;\n\twhile(!qx.empty()){\n\t\tint x = qx.front(); int y = qy.front();\n\t\tqx.pop(); qy.pop();\n\t\tREP(i,4){\n\t\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\t\tif(nx > -1 && ny > -1 && nx < h && ny < w && issearched[nx][ny] == 0){\n\t\t\t\tissearched[nx][ny] = 1;\n\t\t\t\tif(grid[nx][ny] == stcol){\n\t\t\t\t\tgrid[nx][ny] = col;\n\t\t\t\t\tqx.push(nx); qy.push(ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int n,int grid[100][100]){\n\t// cout << n << endl;\n\tint bgrid[100][100];\n\tREP(i,h) REP(j,w) bgrid[i][j] = grid[i][j];\n\n\tif(n == 4){\n\t\tchange(c,grid);\n\t\tans = max(check(grid),ans);\n\t}else{\n\t\tREP(i,6){\n\t\t\tchange(i,grid);\n\t\t\tsolve(n+1,grid);\n\t\t\tREP(i,h) REP(j,w) grid[i][j] = bgrid[i][j];\t\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> h >> w >> c;\n\t\tif(h==0) break;\n\t\tc--;\n\t\tans = 0;\n\t\tREP(i,h) REP(j,w) cin >> data[i][j];\n\t\tREP(i,h) REP(j,w) data[i][j]--;\n\t\tcout << solve(0,data) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvvi shock(vvi panel, int c) {\n\tint tc = panel[0][0];\n\tint h = panel.size();\n\tint w = panel[0].size();\n\tqueue<pii> Q;\n\tQ.push(make_pair(0, 0));\n\tvvi visited(h, vi(w, 0));\n\tvisited[0][0] = 1;\n\tpanel[0][0] = c;\n\twhile(!Q.empty()) {\n\t\tpii p = Q.front();\n\t\tQ.pop();\n\t\tREP(d, 4) {\n\t\t\tint ny = p.first + dy[d];\n\t\t\tint nx = p.second + dx[d];\n\t\t\tif(ny<0 || h<=ny || nx<0 || w<=nx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(visited[ny][nx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(panel[ny][nx] == tc) {\n\t\t\t\tpanel[ny][nx] = c;\n\t\t\t\tvisited[ny][nx] = 1;\n\t\t\t\tQ.push(make_pair(ny, nx));\n\t\t\t}\n\t\t}\t\t\n\t}\n\treturn panel;\n}\n\nint count(vvi panel, int c) {\n\tint res = 0;\n\tint h = panel.size();\n\tint w = panel[0].size();\n\tif(panel[0][0] != c) {\n\t\treturn 0;\n\t}\n\tqueue<pii> Q;\n\tQ.push(make_pair(0, 0));\n\tpanel[0][0] = 0;\n\tres++;\n\twhile(!Q.empty()) {\n\t\tpii p = Q.front();\n\t\tQ.pop();\n\t\tREP(d, 4) {\n\t\t\tint ny = p.first + dy[d];\n\t\t\tint nx = p.second + dx[d];\n\t\t\tif(ny<0 || h<=ny || nx<0 || w<=nx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(panel[ny][nx] == c) {\n\t\t\t\tpanel[ny][nx] = 0;\n\t\t\t\tres++;\n\t\t\t\tQ.push(make_pair(ny, nx));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint h, w, c;\n\twhile(cin >> h >> w >> c, h) {\n\t\tvvi panel(h, vi(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> panel[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tFOR(i, 1, 6) {\n\t\t\tFOR(j, 1, 6) {\n\t\t\t\tFOR(k, 1, 6) {\n\t\t\t\t\tFOR(l, 1, 6) {\n\t\t\t\t\t\tvvi tmp(panel);\n\t\t\t\t\t\ttmp = shock(shock(shock(shock(tmp, i), j), k), l);\n\t\t\t\t\t\ttmp = shock(tmp, c);\n\t\t\t\t\t\tans = max(ans, count(tmp, tmp[0][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<int,int> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\nint h,w,c;\nint p[10][10];\nbool bp[10][10];\n\nint cou;\nvoid dfs(int y,int x){\n\tif(y==0&&x==0){\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tbp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcou=0;\n\t}\n\tbp[y][x]=1;\n\tREP(i,4){\n\t\tint ty=y+dy[i];\n\t\tint tx=x+dx[i];\n\t\tif(0<=tx&&tx<w&&0<=ty&&ty<h&&bp[ty][tx]==0&&p[0][0]==p[ty][tx]){\n\t\t\tdfs(ty,tx);\n\t\t}\n\t}\n\tcou++;\n}\n\t\n\nint calc(int times){\n\tif(times>=4){\n\t\tdfs(0,0);\n\t\tint tmp[10][10];\n\t\tREP(k,h){\n\t\t\tREP(j,w){\n\t\t\t\ttmp[k][j]=p[k][j];\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<h;k++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(bp[k][j]==1){\n\t\t\t\t\tp[k][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(0,0);\n\t\tREP(k,h){\n\t\t\tREP(j,w){\n\t\t\t\tp[k][j]=tmp[k][j];\n\t\t\t}\n\t\t}\n\t\treturn cou;\n\t}\n\tint ans=-1;\n\tfor(int i=1;i<=6;i++){\n\t\tif(i!=p[0][0]){\n\t\t\tdfs(0,0);\n\t\t\tint tmp[10][10];\n\t\t\tREP(k,h){\n\t\t\t\tREP(j,w){\n\t\t\t\t\ttmp[k][j]=p[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(bp[k][j]==1){\n\t\t\t\t\t\tp[k][j]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=max(ans,calc(times+1));\n\t\t\tREP(k,h){\n\t\t\t\tREP(j,w){\n\t\t\t\t\tp[k][j]=tmp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\t\t\t\n\nint main(){\n\twhile(1){\n\t\tcin>>h>>w>>c;\n\t\tif(h==0&&w==0&&c==0){\n\t\t\tbreak;\n\t\t}\n\t\tREP(i,h)\n\t\t\tREP(j,w)\n\t\t\t\tcin>>p[i][j];\n\t\t\n\t\tcout<<calc(0)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\nusing namespace std;\n\nint h, w, c;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint dfs(vector<vector<int> >& p, vector<vector<bool> >& visited, int x, int y, int color) {\n  int ret = 1;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if (nx < 0 || w <= nx || ny < 0 || h <= ny || visited[ny][nx]) {\n      continue;\n    }\n    visited[ny][nx] = true;\n    if (p[ny][nx] == p[y][x]) {\n      ret += dfs(p, visited, nx, ny, color);\n    }\n  }\n  p[y][x] = color;\n  return ret;\n}\n\nint change(vector<vector<int> >& p, int color) {\n  vector<vector<bool> > visited(h, vector<bool>(w));\n  visited[0][0] = true;\n  return dfs(p, visited, 0, 0, color);\n}\n\nint dfs_change(int times, vector<vector<int> >& p) {\n  if (times == 4) {\n    vector<vector<int> > copy = p;\n    change(copy, c);\n    // 表示\n    /* for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cout << copy[i][j];\n      }\n      cout << endl;\n    }\n    cout << \"-----\" << endl;*/\n    \n    return change(copy, c);\n  }\n  int ret = 0;\n  for (int i = 1; i <= 6; i++) {\n    if (i == p[0][0]) {\n      continue;\n    }\n    vector<vector<int> > copy = p;\n    change(copy, i);\n    ret = max(ret, dfs_change(times+1, copy));\n  }\n  return ret;\n}\n\nint solve() {\n  vector<vector<int> > p(h, vector<int>(w));\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> p[i][j];\n    }\n  }\n  int ans = dfs_change(0, p);\n  cout << ans << endl;\n}\n\nint main() {\n  while (true) {\n    cin >> h >> w >> c;\n    if (h == 0 && w == 0) {\n      break;\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w,lt,res;\nvvi a,used,c;\nvi b;\n\nvoid DFS(int i,int j,int col){\n\tused[i][j]=1;\n\tfor(int k=0;k<4;k++){\n\t\tint x=i+dx[k],y=j+dy[k];\n\t\tif(x>=0&&x<h&&y>=0&&y<w&&!used[x][y]&&c[x][y]==col) DFS(x,y,col);\n\t}\n}\n\nvoid dfs(int I){\n\tif(I==5){\n\t\tif(b.back()!=lt) return;\n\t\tc=a;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tused=vvi(h,vi(w));\n\t\t\tDFS(0,0,c[0][0]);\n\t\t\tfor(int j=0;j<h;j++) for(int k=0;k<w;k++) if(used[j][k]) c[j][k]=b[i];\n\t\t}\n\t\tused=vvi(h,vi(w));\n\t\tDFS(0,0,c[0][0]);\n\t\tint tmp=0;\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) tmp+=used[i][j];\n\t\tres=max(res,tmp);\n\t\treturn;\n\t}\n\tfor(int i=1;i<=6;i++){\n\t\tb.push_back(i);\n\t\tdfs(I+1);\n\t\tb.pop_back();\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tcin>>h>>w>>lt;\n\t\tif(h==0) break;\n\t\ta=vvi(h,vi(w));\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) cin>>a[i][j];\n\t\tres=0;\n\t\tdfs(0);\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint h, w, c;\n\nint dfs(int cnt, vvi ce) {\n\tcnt++;\n\tqueue<pair<int, int>> now;\n\tnow.push(pair<int, int>(0, 0));\n\tset<pair<int, int>> visited;\n\tvisited.insert(pair<int, int>(0, 0));\n\tint count=1;\n\twhile (!now.empty()) {\n\t\tpair<int, int> q = now.front();now.pop();\n\t\tREP(i, 4) {\n\t\t\tif (0 <= q.first + dy[i] && q.first + dy[i] < h && 0 <= q.second + dx[i] && q.second + dx[i] < w) {\n\t\t\t\tif (visited.find(pair<int, int>(q.first + dy[i], q.second + dx[i])) == visited.end() &&\n\t\t\t\t\tce[q.first + dy[i]][q.second + dx[i]]== ce[q.first][q.second]) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tnow.push(pair<int, int>(q.first + dy[i], q.second + dx[i]));\n\t\t\t\t\tvisited.insert(pair<int, int>(q.first + dy[i], q.second + dx[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (cnt == 6)\n\t\treturn count;\n\tif (cnt == 5) {\n\t\tvvi ce2 = ce;\n\t\tREP(i, h)\n\t\t\tREP(j, w)\n\t\t\tif (visited.find(pair<int, int>(i, j)) != visited.end())\n\t\t\t\tce2[i][j] = c;\n\t\treturn dfs(cnt,ce2);\n\t}\n\tint ma = 0;\n\tREP(k, 6) {\n\t\tvvi ce2 = ce;\n\t\t\tREP(i, h)\n\t\t\t\tREP(j, w)\n\t\t\t\tif (visited.find(pair<int, int>(i, j)) != visited.end())\n\t\t\t\t\tce2[i][j] = (k + 1);\n\t\t\tma = max(ma, dfs(cnt, ce2));\n\t}\n\treturn ma;\n}\n\nint main() {\n\twhile (cin >> h >> w >> c, h) {\n\t\tvvi cell(h, vi(w));\n\t\tREP(i, h)\n\t\t\tREP(j, w)\n\t\t\tcin >> cell[i][j];\n\t\tcout << dfs(0, cell) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntemplate <typename T>\nclass UF{\npublic:\n\tvector<T> par,rank;\n\n\tUF(long long n){\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor(T i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tT find(T x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x]=find(par[x]);\n\t}\n\n\tvoid unite(T x, T y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(T x, T y){\n\t\treturn find(x)==find(y);\n\t}\n\n};\n\nint dx[]={0, 1,0,-1};\nint dy[]={-1,0,1, 0};\n\nint main()\n{\n\tint h,w,c;\n\twhile(cin>>h>>w>>c,h){\n\n\t\tvector<vector<int> > table(h,vector<int>(w,0)),table2;\n\n\n\n\n\t\tfor(int i=0;i<h;i++){\t\n\t\t\tfor(int j=0;j<w;j++) cin>>table[i][j];\n\t\t}\n\t\t\t\t\n\t\ttable2=table;\n\t\t\n\t\t//cout<<\"init end\"<<endl;\n\t\t\n\t\tlong long res=0;\n\t\t//4????±???????\n\t\tfor(long long bit=0;bit<6LL*6LL*6LL*6LL;bit++){\n\t\t\t\n\t\t\ttable=table2;\n\t\t\tUF<long long> uf(1000);\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ny=i+dy[k],nx=j+dx[k];\n\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && table[i][j]==table[ny][nx]){\n\t\t\t\t\t\t\tuf.unite(i*w+j,ny*w+nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t\tlong long x=bit;\n\t\t\t\n\t\t\t//???????????????\n\t\t\tvector<int> vc(5);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tvc[i]=x%6;\n\t\t\t\tvc[i]++;\n\t\t\t\tx/=6;\n\t\t\t}\n\t\t\t//??????????????????\n\t\t\tvc[4]=c;\n\t\t\t\t\t\t\n\t\t\t//cout<<\"set order\"<<endl;\n\t\t\t\t\t\t\n\t\t\tfor(int i=0;i<5;i++){\n\n\t\t\t\t//?????´??°\n\t\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t\tif(uf.same(0,j*w+k)){\n\t\t\t\t\t\t\ttable[j][k]=vc[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//???????????????\n\t\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(uf.same(0,j*w+k)){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\t\t\t\t\tint ny=j+dy[d],nx=k+dx[d];\n\t\t\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && table[j][k]==table[ny][nx]){\n\t\t\t\t\t\t\t\t\tuf.unite(ny*w+nx,0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\n\t\t\t}\n\n\t\t\tlong long cnt=0;\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t//(0,0)??¨??????????????????\n\t\t\t\t\tif(uf.same(j*w+k,0)) cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tif(res<cnt){\n\t\t\t\t//cout<<bit<<endl;\n\t\t\t\tres=cnt;\n/*\t\t\t\t\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++) cout<<table[i][j]<<\" \";\n\t\t\t\t\tcout<<endl<<endl;\n\t\t\t\t}\n*/\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tcout<<res<<endl;\n\n\t}\n\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1174\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint data[10][10], done[10][10];\nint h, w, c;\nint ret, cnt;\n\nvoid coloring(int x, int y, int color, int from);\nvoid calc(int x, int y, int color);\n\nvoid rec(int deep)\n{\n\tif (deep == 5){\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\tdone[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcoloring(1, 1, c, data[1][1]);\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\tdone[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcalc(1, 1, c);\n\t\tret = max(ret, cnt);\n\t}\n\telse {\n\t\tfor (int i = 1; i <= 6; i++){\n\t\t\tint tmp[10][10];\n\t\t\tfor (int i = 0; i < 10; i++){\n\t\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\t\ttmp[i][j] = data[i][j];\n\t\t\t\t\tdone[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcoloring(1, 1, i, data[1][1]);\n\t\t\trec(deep + 1);\n\t\t\tfor (int i = 0; i < 10; i++){\n\t\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\t\tdata[i][j] = tmp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nvoid coloring(int x, int y, int color, int from)\n{\n\tif (data[y][x] == from && done[y][x] == false){\n\t\tdata[y][x] = color;\n\t\tdone[y][x] = true;\n\t\tcoloring(x + 1, y, color, from);\n\t\tcoloring(x - 1, y, color, from);\n\t\tcoloring(x, y + 1, color, from);\n\t\tcoloring(x, y - 1, color, from);\n\t}\n\treturn;\n}\n\nvoid calc(int x, int y, int color)\n{\n\tif (data[y][x] == color && done[y][x] == false){\n\t\tcnt++;\n\t\tdone[y][x] = true;\n\t\tcalc(x + 1, y, color);\n\t\tcalc(x - 1, y, color);\n\t\tcalc(x, y + 1, color);\n\t\tcalc(x, y - 1, color);\n\t}\n\treturn;\n}\n\nint main(void)\n{\n\twhile (cin >> h >> w >> c, h && w){\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\tdata[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t\trec(1);\n\t\t\n\t\tcout << ret << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 8;\nconst int MAXW = 8;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint h, w, c;\nint p[10][MAXH][MAXW];\nint ans;\n\nint dfs(int i, int j, int a, int b, int g[MAXH][MAXW]) {\n  g[i][j] = b;\n  int res = 1;\n  for(int k = 0; k < 4; ++k) {\n    int ni = i + di[k];\n    int nj = j + dj[k];\n    if(ni < 0 || ni >= h) continue;\n    if(nj < 0 || nj >= w) continue;\n    if(g[ni][nj] != a) continue;\n    res += dfs(ni, nj, a, b, g);\n  }\n  return res;\n}\n\nvoid rec(int k) {\n  if(k+1 == 5) {\n    if(p[k][0][0] != c) {\n      copy(p[k][0], p[k+1][0], p[k+1][0]);\n      dfs(0, 0, p[k+1][0][0], 0, p[k+1]);\n      dfs(0, 0, 0, c, p[k+1]);\n      ans = max(ans, dfs(0, 0, c, 0, p[k+1]));\n    }\n    return;\n  }\n  for(int b = 1; b <= 6; ++b) {\n    copy(p[k][0], p[k+1][0], p[k+1][0]);\n    dfs(0, 0, p[k+1][0][0], 0, p[k+1]);\n    dfs(0, 0, 0, b, p[k+1]);\n    rec(k+1);\n  }\n}\n\nint main() {\n  while(cin >> h >> w >> c && (h|w|c)) {\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        cin >> p[0][i][j];\n      }\n    }\n    ans = 0;\n    rec(0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ndouble EPS=1e-8;\nint INF = 1e9;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint h,w,ans,c;\nint fld[8][8];\nbool pos(int x,int y){\n      return 0<=x&&x<w&&0<=y&&y<h;\n}\nvoid rec(int a){\n      int cnt=0,color=fld[0][0];\n      //cout<<a<<endl;\n      if(a==5){\n            if(fld[0][0]!=c)return;\n            bool used[w][h];\n            memset(used,false,sizeof(used));\n            queue<P> Q;\n            Q.push(P(0,0));\n            used[0][0]=true;\n            cnt++;\n            while(!Q.empty()){\n                  P p=Q.front();Q.pop();\n                  REP(j,4){\n                        int nx=p.first+dx[j],ny=p.second+dy[j];\n                        if(!pos(nx,ny))continue;\n                        if(fld[nx][ny]==color&&!used[nx][ny]){\n                              used[nx][ny]=true;\n                              cnt++;\n                              Q.push(P(nx,ny));\n                        }\n                  }\n            }\n            ans=max(ans,cnt);\n            return;\n      }\n      for(int i=1;i<=6;i++){\n            if(fld[0][0]==i)continue;\n            int tmp[w][h];\n            REP(j,h)REP(k,w)tmp[k][j]=fld[k][j];\n            bool f=false,used[w][h];\n            queue<P> Q;\n            memset(used,false,sizeof(used));\n            while(!Q.empty())Q.pop();\n            Q.push(P(0,0));\n            while(!Q.empty()){\n                  P p=Q.front();Q.pop();\n                  used[p.first][p.second]=true;\n                  fld[p.first][p.second]=i;\n                  REP(j,4){\n                        int nx=p.first+dx[j],ny=p.second+dy[j];\n                        if(!pos(nx,ny))continue;\n                        if(fld[nx][ny]==color&&!used[nx][ny]){\n                              Q.push(P(nx,ny));\n                        }\n                  }\n            }\n            rec(a+1);\n            REP(i,h)REP(j,w)fld[j][i]=tmp[j][i];\n      }\n}\nint main(){\n      while(cin>>h>>w>>c&&(h||w||c)){\n            REP(i,h)REP(j,w)cin>>fld[j][i];\n            ans=0;\n            rec(0);\n            cout<<ans<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint H, W, C;\nint field[8][8];\nint dh[] = {0, 0, 1, -1};\nint dw[] = {1, -1, 0, 0};\n\nvoid dfs2(int h, int w, int pc, int nc){\n    field[h][w] = nc;\n    for(int i=0; i<4; i++){\n        int nh = h + dh[i];\n        int nw = w + dw[i];\n        if(0<=nh&&nh<H && 0<=nw&&nw<W && field[nh][nw]==pc && field[nh][nw]!=nc){\n            dfs2(nh, nw, pc, nc);\n        }\n    }\n}\n\n\nint dfs(int deepth, int changes[]){\n    int res;\n    int tfield[8][8];\n    \n    memcpy(tfield, field, sizeof(field));\n    dfs2(0, 0, field[0][0], changes[deepth]);\n    \n    if(deepth < 5){\n        res = dfs(deepth+1, changes);\n    }else{\n        res = 0;\n        for(int h=0; h<H; h++){\n            for(int w=0; w<W; w++){\n                if(field[h][w] == changes[deepth]){\n                    res ++;\n                }\n            }\n        }\n    }\n    memcpy(field, tfield, sizeof(field));\n    \n    return res;\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i1=1; i1<=6; i1++){\n        for(int i2=1; i2<=6; i2++){\n            for(int i3=1; i3<=6; i3++){\n                for(int i4=1; i4<=6; i4++){\n                    int i5 = C;\n                    int chnges[] = {i1, i2, i3, i4, i5};\n                    ans = max(ans, dfs(0, chnges));\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    while(cin >>H>>W>>C, H|W|C){\n        for(int h=0; h<H; h++){\n            for(int w=0; w<W; w++){\n                cin >> field[h][w];\n            }\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nvoid paint(vector<vector<int>>& p, vector<vector<bool>>& use, int next)\n{\n\tint h = p.size();\n\tint w = p[0].size();\n\tbool update;\n\tqueue<pair<int, int>> q;\n\tREP(i, h)REP(j, w) if(use[i][j]){\n\t\tq.push({ i,j });\n\t}\n\n\n\twhile (!q.empty()) {\n\t\tauto now = q.front(); q.pop();\n\n\t\t//上\n\t\tif (0 < now.first && !use[now.first - 1][now.second] && p[now.first - 1][now.second] == next) {\n\t\t\tuse[now.first - 1][now.second] = true;\n\t\t\tq.push({ now.first - 1,now.second });\n\t\t}\n\t\t//下\n\t\tif (now.first < h - 1 && !use[now.first + 1][now.second] && p[now.first + 1][now.second] == next) {\n\t\t\tuse[now.first + 1][now.second] = true;\n\t\t\tq.push({ now.first + 1,now.second });\n\t\t}\n\t\t//左\n\t\tif (0 < now.second && !use[now.first][now.second - 1] && p[now.first][now.second-1] == next) {\n\t\t\tuse[now.first][now.second - 1] = true;\n\t\t\tq.push({ now.first,now.second - 1 });\n\t\t}\n\t\t//右\n\t\tif (now.second < w - 1 && !use[now.first][now.second + 1] && p[now.first][now.second+1] == next) {\n\t\t\tuse[now.first][now.second+1] = true;\n\t\t\tq.push({ now.first,now.second + 1 });\n\t\t}\n\t}\n}\n\nvoid debug2(vector<vector<bool>> use) {\n\tfor (auto row : use) {\n\t\tfor (bool col : row) {\n\t\t\tif (col)cout << \"#\";\n\t\t\telse cout << \".\";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n//routeの順に色を変更するので、\n//その時に、use=falseが①trueに隣接②routeの色と同じ　ならtrueにする\nint act(vector<vector<int>> p, vector<vector<bool>> use, vector<int> route)\n{\n\tint h = p.size();\n\tint w = p[0].size();\n\tuse[0][0] = true;\n\t//=================================\n\tfor (int next : route) {\n\t\tpaint(p, use, next);\n\t}\n\n\n\n\t//=================================\n\tint ans = 0;\n\tfor (auto row : use) {\n\t\tfor (auto col : row) {\n\t\t\tif (col)ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\n//計算\nvoid calc(vector<vector<int>> p, int c)\n{\n\tint ans = 0;\n\tvector<vector<bool>> use;\n\tREP(i, p.size())use.push_back(vector<bool>(p[0].size(), false));\n\n\t//色変化順\n\tREP(i, pow(6, 4)) {\n\t\tint j = i;\n\t\tvector<int> route;\n\t\troute.push_back(p[0][0]);\n\t\tREP(k, 4) {\n\t\t\troute.push_back(j % 6);\n\t\t\tj /= 6;\n\t\t}\n\t\troute.push_back(c);\n\t\tans = max(ans, act(p, use, route));\n\t}\n\tcerr << \"ans:\";\n\tcout << ans << endl;\n}\n\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tint h, w, c;\n\t\tvector<vector<int>> p;\n\t\tcin >> h >> w >> c;\n\t\tc--;\n\t\tif (h == 0)break;\n\n\t\tREP(i, h) {\n\t\t\tint tmp;\n\t\t\tvector<int> row;\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ttmp--;\n\t\t\t\trow.push_back(tmp);\n\t\t\t}\n\t\t\tp.push_back(row);\n\t\t}\n\t\tcalc(p, c);\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n\nbool pass(const int h, const int w, pair<int,int> &next) {\n\n  if (next.first < 0 || next.first >= h)\n    return false;\n  if (next.second < 0 || next.second >= w)\n    return false;\n\n  return true;\n}\n\nint search(const int h, const int w, const int c, int **p)\n{\n  queue<pair<int,int> > q;\n  pair<int,int> start = make_pair(0,0);\n  q.push(start);\n  int max = 0;\n  \n  int **tmp;\n  tmp = (int **)malloc(sizeof(int*)*h);\n  for (size_t i = 0; i < h; i++)\n    tmp[i] = (int *)malloc(sizeof(int)*w);\n  for (size_t i = 0; i < h; i++)\n    for (size_t j = 0; j < w; j++)\n      tmp[i][j]  = 0;\n  \n  while (!q.empty()) {\n    pair<int,int> cur = q.front(); q.pop();\n    if (!tmp[cur.first][cur.second]) {\n      tmp[cur.first][cur.second] = 1;\n      max++;\n      int a1[] = { -1, 0, 1, 0 };\n      int a2[] = { 0, 1, 0, -1 };\n      for (size_t i = 0; i < 4; i++) {\n\tpair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\tif (pass(h,w,next))\n\t  if (c == p[next.first][next.second] && tmp[next.first][next.second] != 1) {\n\t    q.push(next);\n\t  }\n      }  \n    }\n  }\n  for (size_t i = 0; i < h; i++)\n    free(tmp[i]);\n  free(tmp);\n\n  return max;\n}\n\n\nint rec(const int h, const int w, const int c, int **p, const int times) {\n  \n  int now, max;\n  max = 0;\n  pair<int,int> start = make_pair(0,0);\n  \n\n  int **tmp;\n  tmp = (int **)malloc(sizeof(int*)*h);\n  for (size_t i = 0; i < h; i++)\n    tmp[i] = (int *)malloc(sizeof(int)*w);\n  \n  if (times < 5) {\n    for (size_t k = 1; k <= 6; k++) {\n      \n      for (size_t i = 0; i < h; i++)\n\tfor (size_t j = 0; j < w; j++)\n\t  tmp[i][j] = p[i][j];\n      \n      int fig = tmp[start.first][start.second];\n      if (fig != k) {\n\ttmp[start.first][start.second] = k;\n\tqueue<pair<int,int> > q;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t  pair<int,int> cur = q.front(); q.pop();\n\t  int a1[] = { -1, 0, 1, 0 };\n\t  int a2[] = { 0, 1, 0, -1 };\n\t  for (size_t i = 0; i < 4; i++) {\n\t    pair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\t    if (pass(h,w,next))\n\t      if (fig == tmp[next.first][next.second]) {\n\t\ttmp[next.first][next.second] = k;\n\t\tq.push(next);\n\t      }\n\t  }\n\t}\n\tnow = rec(h,w,c,tmp,times+1);\n\tif (now > max)\n\t  max = now;\n      }\n    }\n  } else if (times == 5) {\n    for (size_t i = 0; i < h; i++)\n      for(size_t j = 0; j < w; j++)\n\ttmp[i][j] = p[i][j];\n    queue<pair<int,int> > q;\n    q.push(start);\n    int fig = tmp[start.first][start.second];\n    if (fig != c) {\n      tmp[start.first][start.second] = c;\n      while (!q.empty()) {\n\tpair<int,int> cur = q.front(); q.pop();\n\tint a1[] = { -1, 0, 1, 0 };\n\tint a2[] = { 0, 1, 0, -1 };\n\tfor (size_t i = 0; i < 4; i++) {\n\t  pair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\t  if (pass(h,w,next))\n\t    if (fig == tmp[next.first][next.second]) {\n\t      tmp[next.first][next.second] = c;\n\t      q.push(next);\n\t    }\n\t}\n      }\n      max = search(h,w,c,tmp);\n    } \n  }\n  \n  for (size_t i = 0; i < h; i++)\n    free(tmp[i]);\n  free(tmp);\n  \n  return max;\n}\n\n\n    \nint main(int argc, char *argv[])\n{\n  while (true) {\n  int h, w, c;\n  cin >> h >> w >> c;\n  if (h == 0 && w == 0 && c == 0) break;\n  int **p;\n  p = (int**)malloc(sizeof(int *)*h);\n  for (size_t i = 0; i < h; i++)\n    p[i] = (int*)malloc(sizeof(int)*w);\n  for (size_t i = 0; i < h; i++)\n    for (size_t j = 0; j < w; j++)\n      cin >> p[i][j];\n\n  int max;\n  max = rec(h,w,c,p,1);\n\n  cout << max << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nvector< vector<int> > c(int k,vector< vector<int> > M){\n    queue< pair<int,int> > q;\n    q.push(make_pair(0,0));\n    int f_c = M.at(0).at(0);\n    vector< vector<bool> > reached(M.size(),vector<bool>(M.at(0).size(),false));\n    reached.at(0).at(0)=true;\n    while(q.size()>0){\n        pair<int,int> next=q.front();\n        q.pop();\n        for(int i=-1;i<=1;i++){\n            if(0<=next.first+i && next.first+i<M.size()){\n                if(M.at(next.first+i).at(next.second)==f_c && !(reached.at(next.first+i).at(next.second))){\n                    reached.at(next.first+i).at(next.second)=true;\n                    q.push(make_pair(next.first+i,next.second));\n                }\n            }\n        }\n        for(int j=-1;j<=1;j++){\n            if(0<=next.second+j && next.second+j<M.at(0).size() ){\n                if(M.at(next.first).at(next.second+j)==f_c && !(reached.at(next.first).at(next.second+j))){\n                    reached.at(next.first).at(next.second+j)=true;\n                    q.push(make_pair(next.first,next.second+j));\n                }\n            }\n        }\n    }\n    for(int i=0;i<M.size();i++){\n        for(int j=0;j<M.at(0).size();j++){\n            if(reached.at(i).at(j)){\n                M.at(i).at(j)=k;\n            }\n        }\n    }\n    return M;\n}\n\nint c_count(int l,int m,int k,vector< vector<int> > M){\n    queue< pair<int,int> > q;\n    q.push(make_pair(l,m));\n    vector< vector<bool> > reached(M.size(),vector<bool>(M.at(0).size(),false));\n    reached.at(0).at(0)=true;\n    while(q.size()>0){\n        pair<int,int> next=q.front();\n        q.pop();\n        for(int i=-1;i<=1;i++){\n            if(0<=next.first+i && next.first+i<M.size()){\n                if(M.at(next.first+i).at(next.second)==k && !(reached.at(next.first+i).at(next.second))){\n                    reached.at(next.first+i).at(next.second)=true;\n                    q.push(make_pair(next.first+i,next.second));\n                }\n            }\n        }\n        for(int j=-1;j<=1;j++){\n            if(0<=next.second+j && next.second+j<M.at(0).size() ){\n                if(M.at(next.first).at(next.second+j)==k && !(reached.at(next.first).at(next.second+j))){\n                    reached.at(next.first).at(next.second+j)=true;\n                    q.push(make_pair(next.first,next.second+j));\n                }\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<M.size();i++){\n        for(int j=0;j<M.at(0).size();j++){\n            if(reached.at(i).at(j)){\n                ans++;\n            }\n        }\n    }\n    return ans;\n}\n\nint change(int count,vector< vector<int> > M,int k){\n    int ans=0;\n    if(count==5){\n        /*\n        for(int i=0;i<M.size();i++){\n            for(int j=0;j<M.at(0).size();j++){\n                if(M.at(i).at(j)==k){\n                    ans=max(ans,c_count(i,j,k,M));\n                }\n            }\n        }*/\n        ans=c_count(0,0,k,M);\n        return ans;\n    }\n    for(int i=1;i<=6;i++){\n        vector< vector<int> > M_;\n        M_=c(i,M);\n        ans=max(ans,change(count+1,M_,k));\n        /*\n        if(ans==11){\n            cout << endl;\n        for(int i=0;i<M.size();i++){\n            for(int j=0;j<M.at(0).size();j++){\n                cout << M.at(i).at(j) << \" \";\n            }\n            cout << endl;\n        }\n        cout << ans << endl;\n        }\n        */\n    }\n    return ans;\n}\n\nint main(){\n    int h,w,color;\n    cin >> h >> w >> color;\n    while(!(h==0 && w==0 && color==0)){\n        vector< vector<int> > M(h,vector<int>(w));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> M.at(i).at(j);\n            }\n        }\n        /*\n        vector< vector<int> > M_ = c(2,M);\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout << M_.at(i).at(j) << \" \";\n            }\n            cout << endl;\n        }\n        */\n        int ans = change(0,M,color);\n        cout << ans << endl;\n        cin >> h >> w >> color;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define s second\n#define f first\n#define mk make_pair\nusing namespace std;\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\nint h,w,c,a[9][9];\nint check(int a[9][9]){\n\tqueue<pair<int,int> >q;\n\tint used[9][9]={},res=0;\n\tused[0][0]=1;\n\tq.push(mk(0,0));\n\twhile(!q.empty()){\n\t\tpair<int,int>p=q.front();q.pop();\n\t\tres++;\n\t\tr(i,4){\n\t\t\tint x=dx[i]+p.s,y=dy[i]+p.f;\n\t\t\tif(x>=0&&y>=0&&x<w&&y<h)\n\t\t\t\tif(!used[y][x]&&a[y][x]==c){\n\t\t\t\t\tused[y][x]=1;\n\t\t\t\t\tq.push(mk(y,x));\n\t\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint dfs(int d,int a[9][9]){\n\tint b[9][9],res=0;\n\tif(d==5){\n\t\tif(a[0][0]=c)return check(a);\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<7;i++){\n\t\tr(k,h)r(j,w)b[k][j]=a[k][j];\n\t\tqueue<pair<int,int> >q;\n\t\tint used[h][w]={};\n\t\tq.push(mk(0,0));\n\t\tused[0][0]=1;\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int>p=q.front();q.pop();\n\t\t\tb[p.f][p.s]=i;\n\t\t\tr(j,4){\n\t\t\t\tint x=dx[j]+p.s,y=dy[j]+p.f;\n\t\t\t\tif(x>=0&&x<w&&y>=0&&y<h)\n\t\t\t\t\tif(!used[y][x]&&b[y][x]==a[0][0]){\n\t\t\t\t\t\tused[y][x]=1;\n\t\t\t\t\t\tq.push(mk(y,x));\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres=max(res,dfs(d+1,b));\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>h>>w>>c,c){\n\t\tint a[9][9];\n\t\tr(i,h)r(j,w)cin>>a[i][j];\n\t\tcout<<dfs(0,a)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n \nusing namespace std;\n\nvoid changepanel(int ***p, int px, int py, int newc, int t);\nint count(int ***p, int t, int color);\nvoid simulate(int ***p, int t);\n\nint h, w, c;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ans;\n\nint main()\n{\n    while(1){\n        cin >> h >> w >> c;\n        if(h == 0) break;\n        ans = 0;\n        int ***panel = new int**[h];\n        for(int i = 0; i < h; i++) panel[i] = new int*[w];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                panel[i][j] = new int[6];\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> panel[i][j][0];\n            }\n        }\n        simulate(panel, 1);\n        cout << ans << endl;\n        delete[] panel;\n    }\n    return 0;\n}\n\nvoid changepanel(int ***p, int px, int py, int newc, int t)\n{\n    int nextx, nexty;\n    int beforecolor = p[px][py][t];\n    p[px][py][t] = newc;\n    for(int i = 0; i < 4; i++){\n        nextx = px + dx[i];\n        nexty = py + dy[i];\n        if(nextx >= h || nextx < 0 || nexty >= w || nexty < 0) continue;\n        else if(p[nextx][nexty][t] == beforecolor) changepanel(p, nextx, nexty, newc, t);\n    }\n    return;\n}\n\nint count(int ***p, int t, int color)\n{\n    int max_result = 0, result = 0;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(p[i][j][t] == c || p[i][j][t] == color){\n                for(int k = 0; k < 4; k++){\n                    int nexti = i + dx[k];\n                    int nextj = j + dy[k];\n                    if(nexti < 0 || nextj < 0 || nexti >= h || nextj >= w) continue;\n                    else if(p[nexti][nextj][t] == c || p[nexti][nextj][t] == color){\n                        result++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    // cout << result << endl;\n    return result;\n}\n\nvoid simulate(int ***p, int t)\n{\n    if(t == 5) {\n        // for(int i = 0; i < h; i++){\n            // for(int j = 0; j < w; j++){\n                // cout << \" \" << p[i][j][t - 1];\n            // }\n            // cout << endl;\n        // }\n        // cout << endl;\n        for(int i = 1; i < 7; i++){\n            int a = 0;\n            a = count(p, t - 1, i);\n                ans = max(ans, a);\n            }\n        return;\n    }\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            for(int k = 0; k < 2; k++){\n                for(int l = 0; l < h; l++){\n                    for(int m = 0; m < w; m++){\n                        p[l][m][t] = p[l][m][t - 1];\n                    }\n                }\n                // 一つ前の状態に戻した\n                if(i + dx[k] >= h || j + dy[k] >= w) continue;\n                int newc = p[i + dx[k]][j + dy[k]][t];\n                if(newc == p[i][j][t]) continue;\n                // cout << i << \" \" << j << \" \" << newc << endl;\n                changepanel(p, i, j, newc, t);\n                simulate(p, t + 1);\n            }\n        }\n    }\n}\n// あるパネルについて、隣り合ってるパネルの色以外の色でぬりかえることは無意味\n// 左上から調べる場合、右隣と下を確認するだけでok(∵上と左隣はすでに確認されているはず)"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint dd[]={-1,0,1,0,-1};\n\nint h,w,c;\nint p[11][11];\n\nbool visc[11][11];\nint cnt=0;\n\nvoid cntc(int i,int j,int cc){\n\tvisc[i][j]=true;\n\tcnt++;\n\trep(d,4){\n\t\tint ni=i+dd[d],nj=j+dd[d+1];\n\t\tif(ni>=0&&ni<h&&nj>=0&&nj<w&&p[ni][nj]==cc&&!visc[ni][nj])cntc(ni,nj,cc);\n\t}\n}\n\nvoid change(int i,int j,int mc,int cc){\n\tp[i][j]=cc;\n\tvisc[i][j]=true;\n\trep(d,4){\n\t\tint ni=i+dd[d],nj=j+dd[d+1];\n\t\tif(ni>=0&&ni<h&&nj>=0&&nj<w&&p[ni][nj]==mc&&!visc[ni][nj])change(ni,nj,mc,cc);\n\t}\n}\n\nint dfs(int d){\n\tif(d==5){\n\t\tcnt=0;\n\t\tmemset(visc,0,sizeof(visc));\n\t\tcntc(0,0,c);\n\t\treturn cnt;\n\t}else{\n\t\tint res=0;\n\t\tint pp[11][11];\n\t\tmemcpy(pp,p,sizeof(p));\n\t\tif(d==4){\n\t\t\tmemset(visc,0,sizeof(visc));\n\t\t\tchange(0,0,p[0][0],c);\n\t\t\tmaxch(res,dfs(d+1));\n\t\t\tmemcpy(p,pp,sizeof(pp));\n\t\t}else{\n\t\t\trepl(i,1,6+1){\n\t\t\t\tmemset(visc,0,sizeof(visc));\n\t\t\t\tchange(0,0,p[0][0],i);\n\t\t\t\tmaxch(res,dfs(d+1));\n\t\t\t\tmemcpy(p,pp,sizeof(pp));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>h>>w>>c;\n\t\tif(h==0)break;\n\t\trep(i,h)rep(j,w)cin>>p[i][j];\n\t\tcout<<dfs(0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define COMBI_SIZE 3750\n\nint combi[COMBI_SIZE][5];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nvoid precalc() {\n    int s = 0;\n    for (int i = 1; i <= 6; i++) {\n        for (int j = 1; j <= 6; j++) {\n            if (j == i) continue;\n            for (int k = 1; k <= 6; k++) {\n                if (k == j) continue;\n                for (int l = 1; l <= 6; l++) {\n                    if (l == k) continue;\n                    for (int m = 1; m <= 6; m++) {\n                        if (m == l) continue;\n                        combi[s][0] = i;\n                        combi[s][1] = j;\n                        combi[s][2] = k;\n                        combi[s][3] = l;\n                        combi[s][4] = m;\n                        s++;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint h, w;\n\nvoid update(int tile[][8], int base, int color, int x, int y) {\n    tile[y][x] = color;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx >= w || ny < 0 || ny >= h) {\n            continue;\n        }\n        if (tile[ny][nx] == base) {\n            update(tile, base, color, nx, ny);\n        }\n    }\n}\n\nvoid count(int tile[][8], int color, int x, int y, int *cnt) {\n    (*cnt)++;\n    tile[y][x] = -1;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 0 || nx >= w || ny < 0 || ny >= h) {\n            continue;\n        }\n        if (tile[ny][nx] == color) {\n            count(tile, color, nx, ny, cnt);\n        }\n    }\n}\n\nint simulation(int s, int tile[][8]) {\n    int temp[8][8];\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            temp[i][j] = tile[i][j];\n        }\n    }\n    for (int i = 0; i < 5; i++) {\n        update(temp, temp[0][0], combi[s][i], 0, 0);\n    }\n    \n    int cnt = 0;\n    count(temp, combi[s][4], 0, 0, &cnt);\n    return cnt;\n}\n\nint main() {\n    precalc();\n\n    while (1) {\n        int c;\n        int tile[8][8];\n        cin >> h >> w >> c;\n        if (h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> tile[i][j];\n            }\n        }\n\n        int maxv = 0;\n        for (int i = 0; i < COMBI_SIZE; i++) {\n            if (combi[i][0] == tile[0][0] || combi[i][4] != c) {\n                continue;\n            }\n            maxv = max(maxv, simulation(i, tile));\n        }\n        cout << maxv << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    while(1){\n        int h, w, c; cin>>h>>w>>c;\n        if(h == 0) return 0;\n\n        vector<vector<int>> p(h, vector<int>(w));\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin>>p[i][j];\n            }\n        }\n\n        int ans=0;\n        for(int a1=1; a1<=6; a1++){\n            for(int a2=1; a2<=6; a2++){\n                for(int a3=1; a3<=6; a3++){\n                    for(int a4=1; a4<=6; a4++){\n                        int a5 = c;\n\n                        vector<vector<int>> cp(h, vector<int>(w));\n                        cp = p;\n\n                        vector<int> color(5);\n                        color[0] = a1;\n                        color[1] = a2;\n                        color[2] = a3;\n                        color[3] = a4;\n                        color[4] = a5;\n\n                        for(int i=0; i<5; i++){\n                            int start = cp[0][0];\n                            cp[0][0] = color[i];\n                            queue<P> que;\n                            que.push(P(0, 0));\n                            vector<vector<bool>> visited(h, vector<bool>(w, false));\n                            visited[0][0] = true;\n\n                            while(que.size()){\n                                int cy, cx;\n                                tie(cy, cx) = que.front();\n                                que.pop();\n\n                                for(int j=0; j<4; j++){\n                                    int ny = cy + dy[j];\n                                    int nx = cx + dx[j];\n\n                                    if(0 <= ny && ny < h && 0 <= nx && nx < w){\n                                        if(!visited[ny][nx] && cp[ny][nx] == start){\n                                            cp[ny][nx] = color[i];\n                                            visited[ny][nx] = true;\n                                            que.push(P(ny, nx));\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        int sum=1;\n                        queue<P> que2;\n                        que2.push(P(0, 0));\n                        cp[0][0] = -1;\n                        while(que2.size()){\n                            int cy, cx;\n                            tie(cy, cx) = que2.front();\n                            que2.pop();\n\n                            for(int i=0; i<4; i++){\n                                int ny = cy + dy[i];\n                                int nx = cx + dx[i];\n\n                                if(0 <= ny && ny < h && 0 <= nx && nx < w){\n                                    if(cp[ny][nx] == c){\n                                        que2.push(P(ny, nx));\n                                        cp[ny][nx] = -1;\n                                        sum++;\n                                    }\n                                }\n                            }\n                        }\n\n                        chmax(ans, sum);\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPR(i,n) for(long long i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(long long i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define MOD 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n#define SV(v) {for(long long sitr=0;sitr<v.size();++sitr){cin>>v[sitr];}}\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint h, w, c;\n\nint solve(int mass[8][8], int num){\n\n  int res = 0;\n  if(num == 5){\n    bool used[8][8] = {};\n    REP(i,h){\n      REP(j,w){\n        int sum = 0;\n        if(mass[i][j] == c && !used[i][j]){\n          queue<pii> que;\n          que.push({i,j});\n          used[i][j] = true;\n          sum++;\n\n          while(!que.empty()){\n            pii tmp = que.front();\n            int y = tmp.first, x = tmp.second;\n            que.pop();\n            REP(i,4){\n              int nx = x + dx[i], ny = y + dy[i];\n              if(nx >= 0 && nx < w && ny >= 0 && ny < h && !used[ny][nx]){\n                if(mass[ny][nx] == c){\n                  que.push({ny, nx});\n                  used[ny][nx] = true;\n                  sum++;\n                }\n              }\n            }\n          }\n\n          res = max(res, sum);\n        }\n      }\n    }\n    return res;\n  }\n\nREP(color,6){\n  //最後は指定された色である必要がある\n  if(num == 4 && color != c){\n    continue;\n  }\n\n  //同じ色には変えない\n  if(color == mass[0][0]) continue;\n\n  int tmp_mass[8][8];\n  REP(i,h){\n    REP(j,w){\n      tmp_mass[i][j] = mass[i][j];\n    }\n  }\n\n  queue<pii> que;\n  que.push({0, 0});\n  int cur_color = tmp_mass[0][0];\n  tmp_mass[0][0] = color;\n\n  while(!que.empty()){\n    pii tmp = que.front();\n    int y = tmp.first, x = tmp.second;\n    que.pop();\n    REP(i,4){\n      int nx = x + dx[i], ny = y + dy[i];\n      if(nx >= 0 && nx < w && ny >= 0 && ny < h){\n        if(tmp_mass[ny][nx] == cur_color){\n          tmp_mass[ny][nx] = color;\n          que.push({ny, nx});\n        }\n      }\n    }\n  }\n\n  res = max(res, solve(tmp_mass, num+1));\n} \nreturn res;\n}\n\nint main(){\n\n  while(true){\n    cin >> h >> w >> c;\n    if(h == 0 && w == 0 && c == 0) break;\n\n    c--;\n\n    int mass[8][8];\n    REP(i,h){\n      REP(j,w){\n        int tmp;\n        cin >> tmp;\n        mass[i][j] = tmp - 1;\n      }\n    }\n\n    cout << solve(mass, 0) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>pii;\n\nconst int MAX_N = 8;\nconst int dx[] = {1,-1,0,0};\nconst int dy[] = {0,0,1,-1};\n\nint h,w,c,opt;\n\nvoid dfs(int cnt,vector<vector<int> >& fd)\n{\n    if(cnt == 5){\n        int res = 0;\n        rep(i,h){\n            rep(j,w){\n                if(fd[i][j] == c){\n                    res++;\n                }\n            }\n        }\n        opt = max(opt,res);\n        return;\n    }\n    for(int i=1;i<=6;i++){\n        if(cnt != 4 || i == c){\n            vector<P> trans;\n            int flag[MAX_N][MAX_N];\n            int bf[MAX_N][MAX_N];\n            queue<pii> que;\n            rep(j,h){\n                rep(k,w){\n                    flag[j][k] = INF;\n                }\n            }\n            que.push(pii(P(0,0),0));\n            flag[0][0] = 0;\n            trans.push_back(P(0,0));\n            while(!que.empty()){\n                pii p = que.front();\n                que.pop();\n                int x = (p.first).first;\n                int y = (p.first).second;\n                rep(j,4){\n                    x += dx[j],y += dy[j];\n                    if(0 <= x && x < h && 0 <= y && y < w){\n                        if(fd[x][y] == fd[0][0] && flag[x][y] > p.second + 1){\n                            que.push(pii(P(x,y),p.second));\n                            flag[x][y] = p.second + 1;\n                            trans.push_back(P(x,y));\n                        }\n                    }\n                }\n            }\n            rep(j,trans.size()){\n                int x = trans[j].first;\n                int y = trans[j].second;\n                bf[x][y] = fd[x][y];\n                fd[x][y] = i;\n            }\n            dfs(cnt+1,fd);\n            rep(j,trans.size()){\n                int x = trans[j].first;\n                int y = trans[j].second;\n                fd[x][y] = bf[x][y];\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d%d\",&h,&w,&c);\n        if(h == 0 && w == 0 && c == 0){\n            break;\n        }\n        opt = 0;\n        vector<vector<int> > a;\n    \trep(i,h){\n            vector<int> vec;\n            int hoge;\n            rep(j,w){\n                scanf(\"%d\",&hoge);\n                vec.push_back(hoge);\n            }\n            a.push_back(vec);\n    \t}\n        dfs(0,a);\n        printf(\"%d\\n\",opt);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\n// #define DEBUG\n\nusing namespace std;\n\nint h, w, c;\nint p[9][9];\n\nvoid Coloring(int y, int x, int c, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      Coloring(ny, nx, c, checked);\n    }\n  }\n  p[y][x] = c;\n  checked[y][x] = false;\n}\n\nint Count(int y, int x, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return 0;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      ret += Count(ny, nx, checked);\n    }\n  }\n\n  return ret + 1; \n}\n\nint dfs(int limit, int c, int pv[10]) {\n  if (limit == 0) {\n    bool checked[9][9] = { false };\n    return Count(0, 0, checked);\n  }\n  int ret = 0;\n  for (int i = 1; i <= 6; i++) {\n    if (limit == 1 && i != c) {\n      continue;\n    }\n    int tmp[9][9];\n    memcpy(tmp, p, sizeof(p));\n    bool checked[9][9] = { false };\n    Coloring(0, 0, i, checked);\n    int tpv[10] = { 0 };\n    int d = dfs(limit - 1, c, tpv);\n    memcpy(p, tmp, sizeof(p)); // UNDO\n    if (d > ret) {\n      ret = d;\n      pv[limit] = i;\n      for (int j = 0; j < limit; j++) {\n        pv[j] = tpv[j];\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> h >> w >> c;\n    if (h + w + c == 0) {\n      break;\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> p[i][j];\n      }\n    }\n    int pv[10] = { 0 };\n    cout << dfs(5, c, pv) << endl;\n   \n#ifdef DEBUG\n    for (int i = 0; i < 10; i++) {\n      cout << pv[i] << \" \\n\"[i == 9];\n    }\n#endif\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n\nusing namespace std;\n\nint h,w,c;\nint col[10][10];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nbool b[10][10];\n\nbool contain(int y,int x){\n    return (y>=0 && y<h && x>=0 && x<w);\n}\n\nint dfs(int y,int x){\n    if(col[y][x]!=c)return 0;\n    if(b[y][x])return 0;\n    b[y][x]=true;\n    int res=0;\n    for(int i=0;i<4;i++){\n        if(!contain(y+dy[i],x+dx[i]))continue;\n        res+=dfs(y+dy[i],x+dx[i]);\n    }\n    return res+1;\n}\n\nvoid update(int y,int x,int cc,int color){\n    col[y][x]=color;\n    for(int i=0;i<4;i++){\n        if(!contain(y+dy[i],x+dx[i]))continue;\n        if(col[y+dy[i]][x+dx[i]]!=cc)continue;\n        update(y+dy[i],x+dx[i],cc,color);\n    }\n}\n\nint solve(int color,int t){\n    if(t==5){\n        if(color==c){\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    b[i][j]=false;\n                }\n            }\n            return dfs(0,0);\n        }\n        else return 0;\n    }\n    int res=0;\n    int tmp[10][10];\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            tmp[i][j]=col[i][j];\n        }\n    }\n    for(int i=1;i<=6;i++){\n        if(i==color)continue;\n        update(0,0,col[0][0],i);\n        res=max(res,solve(i,t+1));\n        for(int j=0;j<h;j++){\n            for(int k=0;k<w;k++){\n                col[j][k]=tmp[j][k];\n            }\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while(1){\n        cin>>h>>w>>c;\n        if(h==0)break;\n\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>col[i][j];\n            }\n        }\n        int ans=solve(col[0][0],0);\n        cout<<ans<<endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\nconst int dx[4] = {1,-1,0,0};\nconst int dy[4] = {0,0,1,-1};\nconst int NUMC = 6;\nint h,w,c;\nvector<vector<int> > mp;\n \nint dfs(int def_i,int def_j,int depth,int col){\n\tif(col == mp[def_i][def_j])return 0;\n\tvector<vector<int> > save_mp;\n  int num_panel[NUMC] = {};\n\tint def_col = mp[def_i][def_j];\n\tmp[def_i][def_j] = col;\n\tqueue<pair<int,int> > que;\n  que.push(make_pair(def_i,def_j));\n  while(!que.empty()){\n    pair<int,int> P = que.front();\n      que.pop();\n      REP(i,4){\n\t\t\t\tint y = P.first + dy[i];\n\t\t\t\tint x = P.second + dx[i];\n\t\t\t\tif(x<0 || y<0 || x>=w || y>=h){continue;}\n\t\t\t\tif(def_col == mp[y][x] ){\n\t\t\t\t\tque.push(make_pair(y,x));\n\t\t\t\t\tmp[y][x] = col;\n\t\t\t\t}\n      }\n\t}\n\tif(depth<5){\n\t\tsave_mp = mp;\n\t\tREP(col_i,NUMC){\n\t\t\tif(depth == 4 && col_i+1 != c || depth == 3 && col_i+1 == c)continue;\n\t\t\tnum_panel[col_i] = dfs(def_i,def_j,depth+1,col_i+1);\n\t\t\tmp = save_mp;\n\t\t}\n\t\treturn *max_element(num_panel,num_panel+NUMC);\n\t}else if(depth == 5){\n\t\tque.push(make_pair(def_i,def_j));\n\t\tint ct = 1;\n\t\tmp[def_i][def_j] = -1;\n\t\twhile(!que.empty()){\n\t\t\tpair<int,int> P = que.front();\n      que.pop();\n      REP(i,4){\n\t\t\t\tint y = P.first + dy[i];\n\t\t\t\tint x = P.second + dx[i];\n\t\t\t\tif(x<0 || y<0 || x>=w || y>=h){continue;}\n\t\t\t\tif(col == mp[y][x] ){\n\t\t\t\t\tque.push(make_pair(y,x));\n\t\t\t\t\tmp[y][x] = -1;\n\t\t\t\t\tct++;\n\t\t\t\t}\n      }\n\t\t}\n\t\treturn ct;\n\t}\n}\n  \nint main(){\n    while(cin >> h>>w>>c,h||w||c){\n        mp.resize(h,vector<int>(w));\n        REP(i,h)\n            REP(j,w)cin >> mp[i][j];\n        int ans = 0;\n\t\t\t\tvector<vector<int> > save_mp = mp;\n        REP(i,1){\n            REP(j,1){\n                REP(col_i,NUMC){\n                    ans = max(ans,dfs(i,j,1,col_i+1));\n\t\t\t\t\t\t\t\t\t\tmp = save_mp;\n                }\n\t\t\t\t\t\t\t\t//cout << ans << \" \";\n            }\n\t\t\t\t\t\t//\t\t\t\t\t\tcout << endl;\n        }\n    cout << ans << endl;\n\t\tmp.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n//---------------------------------------------------------------\n// ------ disjoint set ------ //\nstruct UnionFind {\n    vector<int> data;\n    int __size;\n    UnionFind(int size) : data(size, -1), __size(size) { }\n    bool unionSet(int x, int y) {\n        if ((x = root(x)) != (y = root(y))) {\n            if (data[y] < data[x]) swap(x, y);  // par -> child とは限らない\n            data[x] += data[y]; data[y] = x; __size--;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int size() { return __size; }\n    vector<int> subset_roots() {\n        vector<int> roots;\n        for (int i = 0; i < data.size(); i++) if (data[i] < 0) roots.push_back(i);\n        return roots;\n    }\n};\n//---------------------------------------------------------------\n\nint w, h;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint encode(int i, int j) { return i * w + j; }\nbool exterior(int i, int j) { return i < 0 || h <= i || j < 0 || w <= j; }\n\nvoid bfs(vector<vector<int>> &fi, int num) {\n    queue<int> q; q.push(encode(0, 0));\n    int color = fi[0][0];\n    while (!q.empty()) {\n        int cur = q.front(); q.pop();\n        int i = cur / w, j = cur % w;\n        fi[i][j] = num;\n        for (int k = 0; k < 4; k++) {\n            int ni = i + dx[k], nj = j + dy[k];\n            if (exterior(ni, nj)) continue;\n            if (fi[ni][nj] == color && fi[ni][nj] != num) q.push(encode(ni, nj));\n        }\n    }\n}\n\nint solve(vector<vector<int>> fi, vector<int> nums) {\n    for (int i = 0; i < 5; i++) bfs(fi, nums[i]);\n    UnionFind uf(w * h);\n    for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) {\n        int ij = encode(i, j);\n        for (int k = 0; k < 4; k++) {\n            int ni = i + dx[k], nj = j + dy[k];\n            if (exterior(ni, nj)) continue;\n            int nij = encode(ni, nj);\n            if (fi[i][j] == fi[ni][nj]) uf.unionSet(ij, nij);\n        }\n    }\n    return uf.size(encode(0, 0));\n}\n\nint main() {\n    int c;\n    while (cin >> h >> w >> c, h) {\n        vector<vector<int>> field(h, vector<int>(w));\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        int ans = 0;\n        for (int x = 1; x <= 6; x++) {\n            for (int y = 1; y <= 6; y++) {\n                for (int z = 1; z <= 6; z++) {\n                    for (int w = 1; w <= 6; w++) {\n                        ans = max(ans, solve(field, vector<int>{x, y, z, w, c}));\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rev(i,n) for(int i=(int)n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? n==1 ? x: b_pow(x,n>>1)*b_pow(x,(n>>1)+(n&1)) : 1;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\n\nbool done[10][10];\nint d[10][10];\nint ans = 0;\nint h,w,c;\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nvoid dfs(int x,int y,int from,int to){\n\tif(!(x >= 0 && x < w && y >= 0 && y < h))return;\n\tif( done[y][x] || d[y][x] != from) return ;\n\telse d[y][x] = to , done[y][x] = true;\n\trep(i,4){\n\t\tint tx = x + dx[i] , ty = y + dy[i];\n\t\tdfs(tx,ty,from,to);\n\t}\n}\nint ppp = 0;\nint counta(int x,int y,int color){\n\tif(!(x >= 0 && x < w && y >= 0 && y < h))return 0;\n\tif( done[y][x] || d[y][x] != color) return 0;\n\telse done[y][x] = true, ppp++;\n\trep(i,4){\n\t\tint tx = x + dx[i] , ty = y + dy[i];\n\t\tcounta(tx,ty,color);\n\t}\n}\nvoid bt(int p){\n\tif(p == 5){\n\t\tppp = 0;\n\t\trep(i,10)rep(j,10)done[i][j] = 0;\n\t\tcounta(0,0,c);\n\t\tans = max(ans,ppp);\n\t\t\n\t\treturn;\n\t}\n\tint tmp[10][10];\n\tfor(int i = 1 ; i <= 6 ; i++){\n\t\trep(x,10)rep(y,10)tmp[x][y] = d[x][y];\n\t\trep(x,10)rep(y,10)done[x][y] = 0;\n\t\tdfs(0,0,d[0][0],i);\n\t\tbt(p+1);\t\t\n\t\trep(x,10)rep(y,10)d[x][y] = tmp[x][y];\n\t}\n}\nint main(){\n\twhile(cin >> h >> w >> c , h || w || c){\n\t\trep(i,h)rep(j,w){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t\tans = 0;\n\t\tbt(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\n#define F first\n#define S second\n#define RANGE(a, b, c) ( (a) <= (b) && (b) <= (c) )\nint w, h, c;\nint ans;\nint field[8][8];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid color_change(int from, int to) {\n\tfield[0][0] = to;\n\tqueue< pair<int, int> > q;\n\tq.push( pair<int, int>(0, 0) );\n\n\tbool visited[8][8];\n\tfor(int k=0; k<h; ++k) {\n\t\tfor(int l=0; l<w; l++) {\n\t\t\tvisited[k][l] = false;\n\t\t}\n\t}\n\n\twhile(!q.empty()) {\n\t\tpair<int, int> pos = q.front(); q.pop();\n\t\tint i = pos.F, j = pos.S;\n\t\tfor(int d=0; d<4; ++d) {\n\t\t\tint id = i + dy[d];\n\t\t\tint jd = j + dx[d];\n\t\t\tif( RANGE(0, id, h-1) && RANGE(0, jd, w-1) ) {\n\t\t\t\tif( !visited[id][jd] && field[id][jd] == from ) {\n\t\t\t\t\tvisited[id][jd] = true;\n\t\t\t\t\tfield[id][jd] = to;\n\t\t\t\t\tq.push( pair<int, int>(id, jd) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor(int k=0; k<h; ++k) {\n\t\tfor(int l=0; l<w; l++) {\n\t\t\tcout << field[k][l] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tchar c;\n\tcin >> c;\n\t*/\n}\n\nint count(int i, int j) {\n\tint color = field[i][j];\n\tint cnt = 0;\n\n\tbool visited[8][8];\n\tfor(int k=0; k<h; ++k) {\n\t\tfor(int l=0; l<w; l++) {\n\t\t\tvisited[k][l] = false;\n\t\t}\n\t}\n\n\tqueue< pair<int, int> > q;\n\tq.push( pair<int, int>(0, 0) );\n\tvisited[0][0] = true;\n\n\twhile(!q.empty()) {\n\t\tpair<int, int> pos = q.front(); q.pop();\n\t\tint i = pos.F, j = pos.S;\n\t\t++cnt;\n\t\tfor(int d=0; d<4; ++d) {\n\t\t\tint id = i + dy[d];\n\t\t\tint jd = j + dx[d];\n\t\t\tif( RANGE(0, id, h-1) && RANGE(0, jd, w-1) ) {\n\t\t\t\tif( !visited[id][jd] && field[id][jd] == color ) {\n\t\t\t\t\tvisited[id][jd] = true;\n\t\t\t\t\tq.push( pair<int, int>(id, jd) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nvoid rec(int cnt) {\n\t//printf(\"%d rec\\n\", cnt);\n\tif(cnt == 5) {\n\t\tcolor_change(field[0][0], c);\n\t\tint buf = count(0, 0);\n\t\tans = max(ans, buf);\n\t\treturn;\n\t}\n\n\tint save[8][8];\n\tfor(int i=0; i<h; ++i) {\n\t\tfor(int j=0; j<w; ++j) {\n\t\t\tsave[i][j] = field[i][j];\n\t\t}\n\t}\n\n\tint crr_color = field[0][0];\n\tfor(int color=1; color<=6; ++color) {\n\t\tif(color == crr_color) {\n\t\t\tcontinue;\n\t\t}\n\t\t//printf(\"change color to %d\\n\", color);\n\t\tcolor_change(field[0][0], color);\n\t\trec(cnt+1);\n\t\tfor(int i=0; i<h; ++i) {\n\t\t\tfor(int j=0; j<w; ++j) {\n\t\t\t\tfield[i][j] = save[i][j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> h >> w >> c, h || w || c) {\n\t\tans = 0;\n\t\tfor(int i=0; i<h; ++i) {\n\t\t\tfor(int j=0; j<w; ++j) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\trec(1);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define ISIN(x, y, w, h) (x >= 0 && x < w && y >= 0 && y < h)\n\n#define f first\n#define s second\n\nusing namespace std;\n\npair<int, int> joint[70];\nint h, w, c;\nint p[8][8];\nbool f[8][8];\n\nconst int dx[4] = { 1,-1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1};\n\nint getInt(){ int r; scanf(\"%d\", &r); return r; }\n\nint solve(int now, int prev, int cnt){\n  int ret = 0;\n\n  //printf(\"solve(%d, %d, %d)\\n\", now, prev, cnt);\n\n  if(now == 6) return cnt;\n\n  for(int col = 1; col <= 6; col++){\n    int cc = cnt;\n    queue<pair<int, int> > q;\n\n    if(now == 5 && col != c) continue;\n    if(now == 0 && col != prev) continue;\n\n    REP(i, cnt) q.push(joint[i]);\n\n    while(q.size()){\n      int x = q.front().s;\n      int y = q.front().f;\n\n      q.pop();\n\n      REP(i, 4){\n\tint xx = x + dx[i];\n\tint yy = y + dy[i];\n\n\tif(ISIN(xx, yy, w, h) && p[yy][xx] == col && !f[yy][xx]){\n\t  f[yy][xx] = true;\n\t  joint[cc].f = yy;\n\t  joint[cc].s = xx;\n\t  q.push(joint[cc++]);\n\t}\n      }\n    }\n\n    ret = max(ret, solve(now + 1, col, cc));\n    \n    for(int i = cnt; i < cc; i++){\n      int x = joint[i].s;\n      int y = joint[i].f;\n      \n      f[y][x] = false;\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    h = getInt();\n    w = getInt();\n    c = getInt();\n\n    if(h + w + c == 0) break;\n\n    REP(i, h) REP(j, w) p[i][j] = getInt();\n    f[0][0] = true;\n\n    printf(\"%d\\n\", solve(0, p[0][0], 1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nint cal_max(std::vector<std::vector<int>>& current, const int target_color, int count = 0) {\n\tstd::vector<std::vector<bool>> is_merged(current.size(), std::vector<bool>(current.front().size(), false));\n\tconst auto initial = current[0][0];\n\tstd::stack<std::pair<int, int>>  stack; stack.emplace(0, 0);\n\tis_merged[0][0] = true;\n\twhile (!stack.empty()) {\n\t\tauto top = stack.top(); stack.pop();\n\t\tfor (auto d = -1; d <= 1; d += 2) {\n\t\t\tif (0 <= top.first + d && top.first + d < current.size() && current[top.first + d][top.second] == initial && !is_merged[top.first + d][top.second]) {\n\t\t\t\tis_merged[top.first + d][top.second] = true;\n\t\t\t\tstack.emplace(top.first + d, top.second);\n\t\t\t}\n\t\t\tif (0 <= top.second + d && top.second + d < current[top.first].size() && current[top.first][top.second + d] == initial && !is_merged[top.first][top.second + d]) {\n\t\t\t\tis_merged[top.first][top.second + d] = true;\n\t\t\t\tstack.emplace(top.first, top.second + d);\n\t\t\t}\n\t\t}\n\t}\n\tint result = 0;\n\tif (count == 5) {\n\t\tif (initial != target_color) return 0;\n\t\tfor (const auto& line : is_merged) for (const auto b : line) if (b) ++result;\n\t\treturn result;\n\t}\n\telse if (count < 4) {\n\t\tfor (auto c = 1; c <= 6; ++c) if (c != initial) {\n\t\t\tfor (auto i = 0; i < current.size(); ++i) for (auto j = 0; j < current[i].size(); ++j) if (is_merged[i][j]) current[i][j] = c;\n\t\t\tresult = std::max(result, cal_max(current, target_color, count + 1));\n\t\t}\n\t}\n\telse {\n\t\tfor (auto i = 0; i < current.size(); ++i) for (auto j = 0; j < current[i].size(); ++j) if (is_merged[i][j]) current[i][j] = target_color;\n\t\tresult = std::max(result, cal_max(current, target_color, count + 1));\n\t}\n\tfor (auto i = 0; i < current.size(); ++i) for (auto j = 0; j < current[i].size(); ++j) if (is_merged[i][j]) current[i][j] = initial;\n\treturn result;\n}\nint main(){\n\twhile (true) {\n\t\tint h, w, c; std::cin >> h >> w >> c; if (h == 0) break;\n\t\tstd::vector<std::vector<int>> state(h, std::vector<int>(w)); for (auto& line : state) for (auto& cell : line) std::cin >> cell;\n\t\tstd::cout << cal_max(state, c) << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nint h,w,c,ans;\nint t[10][10];\n \nvoid check(){\n  int cnt=0,flg[10][10];\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)flg[i][j]=false;\n  queue<int> qy,qx;\n  qy.push(0);qx.push(0);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if(y<0||x<0)continue;\n    if(y>=h||x>=w)continue;\n    if(flg[y][x])continue;\n    if(t[y][x]!=c)continue;\n    cnt++;\n    flg[y][x]=true;\n    for(int i=0;i<4;i++)qy.push(y+dy[i]),qx.push(x+dx[i]);\n  }\n  ans=max(ans,cnt);\n}\n \nvoid solve(int depth){\n  if(depth==5)check();\n  else{\n \n    int flg[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)flg[i][j]=0;\n    queue<int> qy,qx;\n    qy.push(0);qx.push(0);\n    while(!qy.empty()){\n      int y=qy.front();qy.pop();\n      int x=qx.front();qx.pop();\n      if(y<0||x<0)continue;\n      if(y>=h||x>=w)continue;\n      if(flg[y][x]!=0)continue;\n      if(t[y][x]!=t[0][0])continue;\n      flg[y][x]=t[y][x];\n      for(int i=0;i<4;i++)qy.push(y+dy[i]),qx.push(x+dx[i]);\n    }\n    for(int I=1;I<=6;I++){\n      if(I==flg[0][0])continue;\n      for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(flg[i][j]!=0)t[i][j]=I;\n      solve(depth+1);\n    }\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n    if(flg[i][j]!=0)t[i][j]=flg[i][j];\n  }\n}\nint main(){\n  while(1){\n    cin>>h>>w>>c;\n    if(h==0&&w==0&&c==0)break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n    cin>>t[i][j];\n    ans=0;\n    solve(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nint ans,h,e,w,dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint bfs(int s[10][10]){\n\tint cnp=1;\n\tbool visit[10][10];\n\tmemset(visit,0,sizeof(visit));\n\tqueue<P> que;\n\tque.push(P(0,0));\n\tvisit[0][0]=1;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\trep(i,4){\n\t\t\tint nx=p.second+dx[i];\n\t\t\tint ny=p.first+dy[i];\n\t\t\tif(!(nx>=0&&nx<w&&ny>=0&&ny<h)||!(s[ny][nx]==s[0][0])||visit[ny][nx])\n\t\t\tcontinue;\n\t\t\tque.push(P(ny,nx));\n\t\t\tcnp++;\n\t\t\tvisit[ny][nx]=1;\n\t\t}\n\t}\n\treturn cnp;\n}\nvoid func(int s[10][10],int now){\n\tif(now==5){\n\t\tif(s[0][0]==e){\n\t\t\tans=max(ans,bfs(s));\n\t\t}\n\t\treturn;\n\t}\n\tint c[10][10];\n\tbool visit[10][10];\n\n\tfor(int i=1;i<=6;i++){\n\t\tif(i!=s[0][0]){\n\t\t\trep(k,h)\n\t\t\t\trep(j,w)\n\t\t\t\t\tc[k][j]=s[k][j];\n\t\t\tqueue<P> que;\n\t\t\tque.push(P(0,0));\n\t\t\tvisit[0][0]=1;\n\tmemset(visit,0,sizeof(visit));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tc[p.first][p.second]=i;\n\t\t\t\trep(z,4){\n\t\t\t\t\tint nx=p.second+dx[z];\n\t\t\t\t\tint ny=p.first+dy[z];\n\t\t\t\t\tif(!(nx>=0&&nx<w&&ny>=0&&ny<h)||!(c[ny][nx]==s[0][0])||visit[ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t\tvisit[ny][nx]=1;\n\t\t\t\t\tc[ny][nx]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunc(c,now+1);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>h>>w>>e,w||h||e){\n\t\tint s[10][10];\n\t\tans=0;\n\t\trep(i,h)\n\t\t\trep(j,w)\n\t\t\t\tcin>>s[i][j];\n\t\t\n\t\tfunc(s,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nint h, w, c;\nint p[8][8];\n\nint ans;\nbool visit[8][8];\n\nint count() {\n\tint res = 0;\n\t\n\tminit(visit, 0);\n\t\n\tqueue< pii > q;\n\tq.push(pii(0, 0));\n\tint color = p[0][0];\n\t\n\twhile (!q.empty()) {\n\t\tpii v = q.front(); q.pop();\n\t\t\n\t\tint x = v.first, y = v.second;\n\t\t\n\t\tif (visit[y][x]) continue;\n\t\tvisit[y][x] = true;\n\t\t\n\t\t++res;\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tint nx = x + DX[d], ny = y + DY[d];\n\t\t\tif (!in_range(nx, ny, w, h)) continue;\n\t\t\tif (p[ny][nx] == color) q.push(pii(nx, ny));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid update(int new_color) {\n\tminit(visit, 0);\n\t\n\tqueue< pii > q;\n\tq.push(pii(0, 0));\n\tint color = p[0][0];\n\t\n\twhile (!q.empty()) {\n\t\tpii v = q.front(); q.pop();\n\t\t\n\t\tint x = v.first, y = v.second;\n\t\t\n\t\tif (visit[y][x]) continue;\n\t\tvisit[y][x] = true;\n\t\tp[y][x] = new_color;\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tint nx = x + DX[d], ny = y + DY[d];\n\t\t\tif (!in_range(nx, ny, w, h)) continue;\n\t\t\tif (p[ny][nx] == color) q.push(pii(nx, ny));\n\t\t}\n\t}\n\t\n}\n\nvoid rec(int i) {\n\tif (i == 5) {\n\t\tans = max(ans, count());\n\t\treturn;\n\t}\n\t\n\tint back[8][8];\n\tfor_(y,0,h) for_(x,0,w) back[y][x] = p[y][x];\n\t\n\tfor_(j,1,7) {\n\t\tif (i == 4 && j != c) continue;\n\t\tupdate(j);\n\t\trec(i + 1);\n\t\tfor_(y,0,h) for_(x,0,w) p[y][x] = back[y][x];\n\t}\n}\n\nvoid solve() {\n\tans = 0;\n\trec(0);\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> h >> w >> c, h) {\n\t\tfor_(i,0,h) for_(j,0,w) cin >> p[i][j];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nstatic const int di[]={-1, 0, 1, 0};\nstatic const int dj[]={0, -1, 0, 1};\n\nint count(std::vector<std::vector<int> > &p, int i=0, int j=0) {\n  int res=1;\n  const int H=p.size(), W=p[0].size();\n  int orig=p[i][j];\n  p[i][j] = 0;\n  for (int k=0; k<4; ++k) {\n    int ni=i+di[k], nj=j+dj[k];\n    if (!(0 <= ni && ni < H && 0 <= nj && nj < W))\n      continue;\n\n    if (p[ni][nj] == orig)\n      res += count(p, ni, nj);\n  }\n\n  return res;\n}\n\nvoid fill(std::vector<std::vector<int> > &p, int c, int i=0, int j=0) {\n  const int H=p.size(), W=p[0].size();\n\n  int orig=p[i][j];\n  p[i][j] = c;\n\n  for (int k=0; k<4; ++k) {\n    int ni=i+di[k], nj=j+dj[k];\n    if (!(0 <= ni && ni < H && 0 <= nj && nj < W)) \n      continue;\n\n    if (p[ni][nj] == orig && p[ni][nj] != c)\n      fill(p, c, ni, nj);\n  }\n}\n\nint rec(std::vector<std::vector<int> > p, int c, int n=0) {\n  if (n == 4) {\n    fill(p, c);\n    return count(p);\n  }\n\n  int res=0;\n  for (int i=1; i<=6; ++i) {\n    if (p[0][0] == i) continue;\n\n    std::vector<std::vector<int> > q=p;\n    fill(q, i);\n    res = std::max(res, rec(q, c, n+1));\n  }\n\n  return res;\n}\n\nint solve_testcase() {\n  int h, w, c;\n  scanf(\"%d %d %d\", &h, &w, &c);\n  if (h == 0 && w == 0 && c == 0)\n    return 1;\n\n  std::vector<std::vector<int> > p(h, std::vector<int>(w));\n  for (int i=0; i<h; ++i)\n    for (int j=0; j<w; ++j)\n      scanf(\"%d\", &p[i][j]);\n\n  printf(\"%d\\n\", rec(p, c));\n  return 0;\n}\n\nint main() {\n  while (!solve_testcase());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "3 5 5\n1 6 3 2 5\n2 5 4 6 1\n1 2 4 1 5\n4 5 6\n1 5 6 1 2\n1 4 6 3 2\n1 5 2 3 2\n1 1 2 3 2\n1 1 5\n1\n1 8 6\n1 2 3 4 5 1 2 3\n8 1 1\n1\n2\n3\n4\n5\n1\n2\n3\n8 8 6\n5 2 5 2 6 5 4 2\n4 2 2 2 5 2 2 2\n4 4 4 2 5 2 2 2\n6 4 5 2 2 2 6 6\n6 6 5 5 2 2 6 6\n6 2 5 4 2 2 6 6\n2 4 4 4 6 2 2 6\n2 2 2 5 5 2 2 2\n8 8 2\n3 3 5 4 1 6 2 3\n2 3 6 4 3 6 2 2\n4 1 6 6 6 4 4 4\n2 5 3 6 3 6 3 5\n3 1 3 4 1 5 6 3\n1 6 6 3 5 1 5 3\n2 4 2 2 2 6 5 3\n4 1 3 6 1 5 5 4\n0 0 0"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\nint di[8] = {0,0,1,-1,1,1,-1,-1};\nint dj[8] = {1,-1,0,0,1,-1,1,-1};\n\nvector<vector<int>> mat(8, vector<int>(8));\nint h, w, c, ans = 0;\n\nvoid dfs(int cur){\n    if(cur == 5){\n        vector<vector<int>> cp = mat;\n        int from = mat[0][0], to = c;\n        queue<pair<int,int>> q;\n        q.push({0,0});\n        while(!q.empty()){\n            pair<int,int> p = q.front();    q.pop();\n            int i = p.first, j = p.second;\n            if(mat[i][j]==to)   continue;\n            mat[i][j] = to;\n            for(int k = 0; k < 4; k++){\n                int ni = i+di[k], nj = j+dj[k];\n                if(inRange(ni,0,h)&&inRange(nj,0,w)&&mat[ni][nj]==from) q.push({ni,nj});\n            }\n        }\n        int tmp = 0;\n        vector<vector<bool>> visit(8, vector<bool>(8,0));\n        q.push({0,0});\n        while(!q.empty()){\n            pair<int,int> p = q.front();    q.pop();\n            int i = p.first, j = p.second;\n            if(visit[i][j])   continue;\n            visit[i][j] = true;\n            tmp++;\n            for(int k = 0; k < 4; k++){\n                int ni = i+di[k], nj = j+dj[k];\n                if(inRange(ni,0,h)&&inRange(nj,0,w)&&mat[ni][nj]==to) q.push({ni,nj});\n            }\n        }\n        ans = max(ans, tmp);\n        mat = cp;\n        return;\n    }\n\n    for(int to = 1; to <= 6; to++){\n        if(mat[0][0] == to) continue;\n        vector<vector<int>> cp = mat;\n        int from = mat[0][0];\n        queue<pair<int,int>> q;\n        q.push({0,0});\n        while(!q.empty()){\n            pair<int,int> p = q.front();    q.pop();\n            int i = p.first, j = p.second;\n            if(mat[i][j]==to)   continue;\n            mat[i][j] = to;\n            for(int k = 0; k < 4; k++){\n                int ni = i+di[k], nj = j+dj[k];\n                if(inRange(ni,0,h)&&inRange(nj,0,w)&&mat[ni][nj]==from) q.push({ni,nj});\n            }\n        }\n        dfs(cur+1);\n        mat = cp;\n    }\n\n    return;\n}\n\nint main(){\n    while(cin >> h >> w >> c, h+w+c){\n        ans = 0;\n        mat.resize(8, vector<int>(8,0));\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mat[i][j];\n            }\n        }\n        dfs(1);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nstruct status {\n    int k;\n    vector<int> log;\n    int map[8][8];\n};\n\nint h, w, c;\nint d[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nbool gone[8][8];\n\nvoid change_color(int ac, int (&map)[8][8]){\n    int cc = map[0][0];\n    queue<pair<int, int> > q;\n    q.push(make_pair(0, 0));\n    REP(i, h) REP(j, w) gone[i][j] = false;\n    gone[0][0] = true;\n    while(!q.empty()){\n        pair<int, int> p = q.front();\n        q.pop();\n        int x = p.first;\n        int y = p.second;\n        map[x][y] = ac;\n        REP(i, 4){\n            int nx = x+d[i][0];\n            int ny = y+d[i][1];\n            if(!gone[nx][ny] && nx>=0 && nx<h && ny>=0 && ny<w){\n                gone[nx][ny] = true;\n                if(map[nx][ny]==cc){\n                    q.push(make_pair(nx, ny));\n                }\n            }\n        }\n    }\n}\n\nint count_color(int (&map)[8][8]){\n    int cc = map[0][0];\n    int count = 0;\n    queue<pair<int, int> > q;\n    q.push(make_pair(0, 0));\n    REP(i, h) REP(j, w) gone[i][j] = false;\n    gone[0][0] = true;\n    while(!q.empty()){\n        pair<int, int> p = q.front();\n        q.pop();\n        int x = p.first;\n        int y = p.second;\n        count += 1;\n        REP(i, 4){\n            int nx = x+d[i][0];\n            int ny = y+d[i][1];\n            if(!gone[nx][ny] && nx>=0 && nx<h && ny>=0 && ny<w){\n                gone[nx][ny] = true;\n                if(map[nx][ny]==cc){\n                    q.push(make_pair(nx, ny));\n                }\n            }\n        }\n    }\n    return count;\n}\n\nvector<int> find_color(int (&map)[8][8]){\n    int cc = map[0][0];\n    vector<int> candidates;\n    queue<pair<int, int> > q;\n    q.push(make_pair(0, 0));\n    REP(i, h) REP(j, w) gone[i][j] = false;\n    gone[0][0] = true;\n    while(!q.empty()){\n        pair<int, int> p = q.front();\n        q.pop();\n        int x = p.first;\n        int y = p.second;\n        REP(i, 4){\n            int nx = x+d[i][0];\n            int ny = y+d[i][1];\n            if(!gone[nx][ny] && nx>=0 && nx<h && ny>=0 && ny<w){\n                gone[nx][ny] = true;\n                if(map[nx][ny]==cc){\n                    q.push(make_pair(nx, ny));\n                } else {\n                    candidates.push_back(map[nx][ny]);\n                }\n            }\n        }\n    }\n    return candidates;\n}\n\nint main(){\n    while(1){\n        cin >> h >> w >> c;\n\n        if(h==0) break;\n\n        queue<status> que;\n        status init;\n        init.k = 0;\n        init.log = vector<int>();\n        REP(i, h){\n            REP(j, w){\n                cin >> init.map[i][j];\n            }\n        }\n\n        que.push(init);\n        int output = 0;\n        while(!que.empty()){\n            status s = que.front();\n            que.pop();\n            if(s.k == 4){\n                change_color(c, s.map);\n                int count = count_color(s.map);\n                output = max(output, count);\n            } else {\n                status next;\n                next.k = s.k+1;\n                REP(i, h) REP(j, w) next.map[i][j] = s.map[i][j];\n                que.push(next);\n\n                vector<int> candidates = find_color(s.map);\n                REP(i, candidates.size()){\n                    status next;\n                    next.k = s.k+1;\n                    next.log = s.log;\n                    next.log.push_back(candidates[i]);\n                    REP(i, h) REP(j, w) next.map[i][j] = s.map[i][j];\n                    change_color(candidates[i], next.map);\n                    que.push(next);\n                }\n            }\n        }\n\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n    dice() {\n        id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n        id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n    }\n    T& operator[] (FACE f) { return var[id[f]]; }\n    const T& operator[] (FACE f) const { return var[id[f]]; }\n    bool operator==(const dice<T>& b) const {\n        const dice<T> &a = *this;\n        return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n               a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n               a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n    }\n    void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n    void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n    void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n    vector<dice> all_rolls() {\n        vector<dice> ret;\n        for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n            for (int i = 0; i < 4; roll_z(), ++i)\n                ret.push_back(*this);\n        return ret;\n    }\n    bool equivalent_to(const dice& di) {\n        for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n            for (int i = 0; i < 4; roll_z(), ++i)\n                if (*this == di) return true;\n        return false;\n    }\nprivate:\n    void roll(FACE a, FACE b, FACE c, FACE d) {\n        T tmp = id[a];\n        id[a] = id[b]; id[b] = id[c];\n        id[c] = id[d]; id[d] = tmp;\n    }\n    T var[6];\n    int id[6];\n};\n\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nconst int INF = 100000000;\n\nint GCD(int a, int b){\n    if(a < b) swap(a, b);\n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\nbool cmp(const pii& a, const pii& b){\n    if(a.first == b.first){\n        return a.second < b.second;\n    }\n    return a.first < b.first;\n}\nint h, w, c;\nint dxy[5] = {-1, 0, 1, 0, -1};\nint maxV;\nvoid dfs(int y, int x, int turn, int p[10][10]) {\n    if (turn == 5) {\n            queue<pii> q;\n            q.push({y, x});int cnt=0;\n            if(p[y][x] == c)  cnt++;\n\n            bool used[10][10];\n            REP(i, 10) REP(j, 10) used[i][j] = false;\n            used[y][x] = true;\n            while (q.size()) {\n                pii P = q.front();\n                q.pop();\n                int Y = P.first;\n                int X = P.second;\n                for (int i = 0; i < 4; ++i) {\n                    int ny = Y + dxy[i],\n                            nx = X + dxy[i + 1];\n                    if (ny >= 0 && ny < h && nx >= 0 && nx < w && !used[ny][nx]) {\n                        if (p[ny][nx] == c) {\n                            used[ny][nx] = true;\n                            q.push({ny, nx});\n                            cnt++;\n                        }\n                    }\n                }\n            }\n\n        maxV = max(maxV, cnt);\n\n        return ;\n    }\n\n\n    for(int i=1; i<=6; ++i){\n        queue<pair<int, int>> q;\n\n        q.push({y, x});\n        int t = p[y][x]; //変更前の色\n\n\n        if(t==i) continue;\n        int np[10][10];bool passed[10][10];\n        REP(j, 10)REP(k, 10) {\n                np[j][k] = p[j][k];\n                passed[j][k]=false;\n            }\n        passed[y][x] = true;\n\n        while(q.size()){\n            pii P = q.front();\n            q.pop();\n\n            int Y = P.first, X = P.second;\n            for(int j=0; j<4; ++j){\n                int ny = Y + dxy[j],\n                nx = X + dxy[j+1];\n                if(ny>=0 && ny<h && nx>=0&& nx<w && !passed[ny][nx] && p[ny][nx] == p[y][x]){\n                    passed[ny][nx] = true;\n                    q.push({ny, nx});\n                }\n            }\n        }\n        for(int j=0; j<h; ++j){\n            for(int k=0; k<w; ++k){\n                if(passed[j][k]){\n                    np[j][k] = i;\n                }\n            }\n        }\n        dfs(y, x, turn+1, np);\n    }\n}\nint main() {\n    //cout << fixed << setprecision(15);\n\n\n    while(cin >> h >> w >> c){\n        if(h==0 && w==0 && c==0) break;\n        maxV = 1;\n        int p[10][10];\n        REP(i, 10) REP(j, 10) p[i][j]=0;\n        REP(i, h) REP(j, w) cin >> p[i][j];\n\n\n        bool cused[10];\n        for(int i=0; i<10; ++i) cused[i] = false;\n        dfs(0, 0, 0, p);\n\n        cout << maxV << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n//#include<fstream>\n\nusing namespace std;\n\n#define fin cin\n\nint panel[8][8];\nint h, w, last;\n\nbool come[8][8];\n\nvoid come_init() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcome[i][j] = false;\n\t\t}\n\t}\n}\n\n//????????????????????????????????£??\\????????????????¨????\nint getCount(int map[][8], int y, int x) {\n\n\t//??????????????¨NullPo??????\n\tif (x < 0 || y < 0 || x >= 8 || y >= 8)return 0;\n\t\n\tif (map[y][x] != map[0][0] || come[y][x])return 0;\n\n\tcome[y][x] = true;\n\n\tint count = 1;\n\tcount += getCount(map, y + 1, x);\n\tcount += getCount(map, y, x + 1);\n\tcount += getCount(map, y - 1, x);\n\tcount += getCount(map, y, x - 1);\n\n\treturn count;\n}\n\nvoid change(int map[][8], bool (*f_change)[8], int y, int x) {\n\tif (x < 0 || y < 0 || x >= 8 || y >= 8)return;\n\n\tif (map[y][x] != map[0][0] || f_change[y][x])return;\n\n\tchange(map, f_change, y + 1, x);\n\tchange(map, f_change, y, x + 1);\n\tchange(map, f_change, y - 1, x);\n\tchange(map, f_change, y, x - 1);\n\n\t//cout << f_change[0][1];\n\n}\n\n\n//search(????????????????????????????????????????????????)\nint search(int map[][8], int level, int color) {\n\tstatic int max = 0;\n\tif (level == 0)max = 0;\n\n\t\n\t//??£??\\??????????????????color????????????\n\n\tbool f_change[8][8] = {};\n\t\n\tchange(map, f_change, 0, 0);\n\n\t/*\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\n\t\t\tif (map[i][j] == map[0][0]) {\n\t\t\t\tif (\n\t\t\t\t\t(i < 7 && map[i][j] == map[i + 1][j] && f_change[i + 1][j]) ||\n\t\t\t\t\t(j < 7 && map[i][j] == map[i][j + 1] && f_change[i][j + 1]) ||\n\t\t\t\t\t(i > 0 && map[i][j] == map[i - 1][j] && f_change[i - 1][j]) ||\n\t\t\t\t\t(j > 0 && map[i][j] == map[i][j - 1] && f_change[i][j - 1])\n\t\t\t\t\t)\n\t\t\t\t\tf_change[i][j] = true;\n\t\t\t}\n\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif(f_change[i][j])map[i][j] = color;\n\t\t}\n\t}\n\tlevel++;\n\n\tif (level < 4) {\n\n\t\tfor (int i = 1; i <= 6; i++) {\n\n\t\t\tint map_tmp[8][8];\n\n\t\t\t//copy\n\t\t\tfor (int y = 0; y < 8; y++) {\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tmap_tmp[y][x] = map[y][x];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint tmp = search(map_tmp, level, i);\n\t\t\tif (max < tmp)max = tmp;\n\n\t\t}\n\t}\n\t//4??????????????????5??????\n\telse if (level == 4) {\n\t\tint map_tmp[8][8];\n\n\t\t//copy\n\t\tfor (int y = 0; y < 8; y++) {\n\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\tmap_tmp[y][x] = map[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint tmp = search(map_tmp, level, last);\n\t\tif (max < tmp)max = tmp;\n\t\n\t}\n\t//5??????????????????\n\telse if (level == 5) {\n\t\tcome_init();\n\t\tint tmp = getCount(map, 0, 0);\n\t\tif (max < tmp) {\n\t\t\tmax = tmp;\n\n\t\t\tif(0)\n\t\t\t{\n\t\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\t\tcout << map[y][x] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tcout << \"   :   \" << level << \" \" << color << endl;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn max;\n}\n\n\nint main() {\n\t//ifstream fin(\"in.txt\");\n\n\twhile (true) {\n\t\tfin >> h >> w >> last;\n\t\tif ((h | w) == 0)break;\n\n\t\t//initialize\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tpanel[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\t//input\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfin >> panel[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tint panel_tmp[8][8];\n\t\t\t\n\t\t\t//copy\n\t\t\tfor (int y = 0; y < 8; y++) {\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tpanel_tmp[y][x] = panel[y][x];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint tmp = search(panel_tmp, 0, i);\n\t\t\tif (max < tmp)max = tmp;\n\t\t}\n\n\t\tcout << max << endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint h,w,c;\nint data[8][8];\n\n\nint done[8][8];\nint change(int x,int y,int color,int to){\n    if(y >= h || x < 0 || y < 0 || x >= w) return 0;\n\n    if(data[y][x] != color) return 0;\n    else data[y][x] = to;\n\n    if(done[y][x] == true) return 0;\n    else done[y][x] = true;\n\n    int dx[] = {-1,0,1,0};\n    int dy[] = {0,1,0,-1};\n    for(int i = 0 ; i < 4 ; i++) change(x+dx[i] , y+dy[i] , color , to);\n    return 0;\n}\nint count(int x,int y,int color){\n    if(y >= h || x < 0 || y < 0 || x >= w) return 0;\n    if(data[y][x] != color) return 0;\n    if(done[y][x] == true) return 0;\n    else done[y][x] = true;\n    int ans = 0;\n    int dx[] = {-1,0,1,0};\n    int dy[] = {0,1,0,-1};\n    for(int i = 0 ; i < 4 ; i++)\n        ans += count(x+dx[i] , y+dy[i] , color);\n    return ans+1;\n}\nint ans = 0;\nint dfs(int n){\n    if(n == 5){\n        for(int x = 0 ; x < 8 ; x++)\n            for(int y = 0 ; y < 8 ; y++)\n                done[x][y] = 0;\n        ans = max(ans,count(0,0,c));\n        return 0;\n    }\n    int tmp[8][8];\n\n    for(int i = 0 ; i < 6 ; i++){\n        for(int x = 0 ; x < 8 ; x++)\n            for(int y = 0 ; y < 8 ; y++)\n                tmp[x][y] = data[x][y] ,done[x][y] = 0;\n        change(0,0,data[0][0],i);\n        dfs(n+1);\n\n        for(int x = 0 ; x < 8 ; x++)\n            for(int y = 0 ; y < 8 ; y++)\n                data[x][y] = tmp[x][y], done[x][y] = 0;\n\n    }\n    return 0;\n\n}\nint main(){\n    while(cin >> h >> w >> c , h){\n        c--;\n        for(int i = 0 ; i < h ; i++)\n            for(int j = 0; j < w ; j++)\n                cin >> data[i][j] , data[i][j]--;\n        ans = 0;\n        dfs(0);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint h, w, c;\n\nbool isIn(int x, int y){\n     return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint change(int n, int color, vector<vector<int> > field){\n    vector<pair<int, int> > samecolor;\n    samecolor.push_back(make_pair(0, 0));\n    while(1){\n        vector<pair<int, int> > v;\n        for(int i=0; i < samecolor.size(); i++){\n            v.push_back(samecolor[i]);\n            int dx[4] = {1, 0, -1, 0};\n            int dy[4] = {0, 1, 0, -1};\n            for(int j=0; j < 4; j++){\n                int nx = samecolor[i].first+dx[j], ny = samecolor[i].second+dy[j];\n                if(isIn(nx, ny) && field[nx][ny] == field[0][0]){\n                    bool is = true;\n                    for(int k=0; k < v.size(); k++) if(nx == v[k].first && ny == v[k].second){is = false; break;}\n                    for(int k=0; k < samecolor.size(); k++) if(nx == samecolor[k].first && ny == samecolor[k].second){is = false; break;}\n                    if(is) v.push_back(make_pair(nx, ny));\n                }\n            }\n        }\n        if(v.size() == samecolor.size()) break;\n        else samecolor = v;\n    }\n    if(n == 5) return samecolor.size();\n    for(int i=0; i< samecolor.size(); i++) field[samecolor[i].first][samecolor[i].second] = color;\n\n    int result = 0;\n    if(n == 3) result = change(n+1, c, field);\n    else for(int i=1; i <= 6; i++) if(field[0][0] != i)result = max(result, change(n+1, i, field));\n    return result;\n}\n\nint main(){\n    while(cin >> h >> w >> c, h+w+c){\n        vector<vector<int> > field(8);\n        for(int i=0; i< h; i++) {\n            for(int j=0; j< w; j++){int t; cin >> t; field[i].push_back(t);}\n        }\n        int result = 0;\n        for(int i=1; i <= 6; i++) if(field[0][0] != i) result = max(result, change(0, i, field));\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint h, w, c;\nint p[8][8];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvoid print(int time){\n  printf(\"time %d\\n\", time);\n  REP(y, h){\n    REP(x, w) printf(\"%d \", p[y][x]);\n    cout<<endl;\n  }\n}\nint dfs(int time){\n  if(time != 5){\n    bool equal[8][8] = {};\n    queue<int> qx; queue<int> qy;\n    qx.push(0); qy.push(0);\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      equal[y][x] = true;\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && !equal[ny][nx] && p[y][x] == p[ny][nx]){\n          qx.push(nx); qy.push(ny);\n          equal[ny][nx] = true;\n        }\n      }\n    }\n    int res = 0;\n    int tmp[8][8];\n    REP(y, h)REP(x, w) tmp[y][x] = p[y][x];\n    for(int color = 1; color <= 6; color++){\n      REP(y, h)REP(x, w)if(equal[y][x]){\n        p[y][x] = color;\n      }\n      res = max(res, dfs(time + 1));\n      REP(y, h)REP(x, w) p[y][x] = tmp[y][x];\n    }\n    return res;\n  }\n  else if(time == 5){\n    if(p[0][0] != c) return 0;\n    bool equal[8][8] = {};\n    queue<int> qx; queue<int> qy;\n    qx.push(0); qy.push(0);\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      equal[y][x] = true;\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && !equal[ny][nx] && p[y][x] == p[ny][nx]){\n          qx.push(nx); qy.push(ny);\n          equal[ny][nx] = true;\n        }\n      }\n    }\n    int res = 0;\n    REP(y, h)REP(x, w) res += equal[y][x];\n    return res;\n  }\n}\n\nint main(){\n  while(cin>>h>>w>>c){\n    REP(y, h)REP(x, w) cin>>p[y][x];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint h,w,c;\n\nbool used[10][10];\n\nvvi coloring(int color,vvi v){\n    int c=v[0][0];\n    vector<vector<bool>> used(h,vector<bool>(w,true));\n    queue<pii> que;\n    que.push(make_pair(0,0));\n    while(!que.empty()){\n        auto q=que.front();\n        que.pop();\n        int x=q.first;\n        int y=q.second;\n\n        used[x][y]=false;\n        v[x][y]=color;\n        rep(i,4){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(nx>=0 and nx<h and ny>=0 and ny<w and v[nx][ny]==c and used[nx][ny]){\n                que.push(make_pair(nx,ny));\n            }\n        }\n    }\n    return v;\n}\n\nint counter(vvi v,int val=0){\n    int ret=0;\n    vector<vector<bool>> used(h,vector<bool>(w,true));\n    queue<pii> que;\n    que.push(make_pair(0,0));\n    used[0][0]=false;\n    while(!que.empty()){\n        auto q=que.front();\n        que.pop();\n        ret++;\n        if(val==1) cerr << q << endl;\n        int x=q.first,y=q.second;\n        rep(i,4){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(0<=nx and nx<h and 0<=ny and ny<w and used[nx][ny] and v[nx][ny]==v[0][0]){\n                used[nx][ny]=false;\n                que.push(make_pair(nx,ny));\n            }\n        }\n    }\n    return ret;\n}\n\nvoid solve(){\n    vvi p(h,vi(w));\n    rep(i,h) rep(j,w) cin>>p[i][j];\n    rep(i,h) rep(j,w) p[i][j]--;\n\n    int ans=0;\n    rep(i,6){\n        if(i==p[0][0]) continue;\n        rep(j,6) rep(k,6) rep(l,6){\n            auto v = coloring(i,p);\n            v = coloring(j,v);\n            v = coloring(k,v);\n            v = coloring(l,v);\n            v = coloring(c,v);\n            int tmp=counter(v);\n\n            ans = max(ans,tmp);\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>h>>w>>c){\n        if(h==0 and w==0 and c==0) break;\n        c--;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nint h, w, color;\nbool checked[10][10];\n\nvoid fill(int x, int y, int f, int t, vvi& panel) {\n\tpanel[y][x] = t;\n\tif( 0<=x-1 && panel[y][x-1]==f ) {\n\t\tfill(x-1, y, f, t, panel);\n\t}\n\tif( x+1<w && panel[y][x+1]==f ) {\n\t\tfill(x+1, y, f, t, panel);\n\t}\n\tif( 0<=y-1 && panel[y-1][x]==f ) {\n\t\tfill(x, y-1, f, t, panel);\n\t}\n\tif( y+1<h && panel[y+1][x]==f ) {\n\t\tfill(x, y+1, f, t, panel);\n\t}\n}\n\nint count(int x, int y, vvi& p) {\n\tint cnt = 1;\n\tchecked[y][x] = true;\n\tif( 0<=x-1 && p[y][x-1]==p[y][x] && !checked[y][x-1] ) {\n\t\tcnt += count(x-1, y, p);\n\t}\n\tif( x+1<w && p[y][x+1]==p[y][x] && !checked[y][x+1] ) {\n\t\tcnt += count(x+1, y, p);\n\t}\n\tif( 0<=y-1 && p[y-1][x]==p[y][x] && !checked[y-1][x] ) {\n\t\tcnt += count(x, y-1, p);\n\t}\n\tif( y+1<h && p[y+1][x]==p[y][x] && !checked[y+1][x] ) {\n\t\tcnt += count(x, y+1, p);\n\t}\n\treturn cnt;\n}\n\nint dfs(int lp, vvi& panel) {\n\tif( lp==0 ) {\n\t\tvvi p = panel;\n\t\tif(color == p[0][0]) return 0;\n\t\tfill(0, 0, p[0][0], color, p);\n\t\tmemset(checked, 0, sizeof(checked));\n\t\treturn count(0, 0, p);\n\t}\n\tint res = 0;\n\tfor(int c=1; c<=6; c++) {\n\t\tif(c == panel[0][0]) continue;\n\t\tvvi p = panel;\n\t\tfill(0, 0, p[0][0], c, p);\n\t\tres = max(res, dfs(lp-1, p));\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile( cin >> h >> w >> color, h||w||color ) {\n\t\tvvi panel(h);\n\t\trep(y, h) {\n\t\t\tpanel[y].resize(w);\n\t\t\trep(x, w) {\n\t\t\t\tcin >> panel[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << dfs(4, panel) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nint h,w,c;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint count(vector<vector<int>> &v){\n    int res=0;\n    queue<P> q;\n    q.push(P(0,0));\n    while(!q.empty()){\n        P p=q.front();q.pop();\n        if(v[p.first][p.second]!=c) continue;\n        res++;\n        v[p.first][p.second]=-1;\n        for(int i=0;i<4;i++){\n            int nx=p.first+dx[i],ny=p.second+dy[i];\n            if(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n            if(v[nx][ny]!=c) continue;\n            q.push(P(nx,ny));\n        }\n    }\n    return res;\n}\n\nvoid paint(vector<vector<int>> &v, int col){\n    int base=v[0][0];\n    if(base==col) return;\n    queue<P> q;\n    q.push(P(0,0));\n    while(!q.empty()){\n        P p=q.front(); q.pop();\n        if(v[p.first][p.second]!=base) continue;\n        v[p.first][p.second]=col;\n        for(int i=0;i<4;i++){\n            int nx=p.first+dx[i],ny=p.second+dy[i];\n            if(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n            if(v[nx][ny]!=base) continue;\n            q.push(P(nx,ny));\n        }\n    }\n    return ;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>h>>w>>c,h||w||c){\n        c--;\n        vector<vector<int>> v(h,vector<int>(w));\n        for(int i=0;i<h;i++) for(int j=0;j<w;j++){\n            cin>>v[i][j]; v[i][j]--;\n        }\n        int res=0;\n        for(int p=0;p<6;p++){\n            for(int q=0;q<6;q++){\n                for(int r=0;r<6;r++){\n                    for(int i=0;i<6;i++){\n                        for(int j=0;j<6;j++){\n                            vector<vector<int>> cp=v;\n                            paint(cp,p);\n                            paint(cp,q);\n                            paint(cp,r);\n                            paint(cp,i);\n                            paint(cp,j);\n                            res=max(res,count(cp));\n                        }\n                    }\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(a,b,c) for(int a=b; a<(int)c; a++)\n#define REPE(a,b,c) for(int a=b; a<=(int)c; a++)\n#define REPD(a,b,c) for(int a=b; a>=(int)c; a--)\n#define rep(a,b) REP(a,0,b)\n#define repd(a,b) REPD(a,b,0)\ntypedef long long int ll;\nusing namespace std;\ntypedef vector<vector<int> > board;\ntypedef vector<vector<bool> > conect_map;\ntypedef struct{int x;int y;}pos;\nint h, w, c;\nvoid show(conect_map p){\n  rep(i,h){\n    rep(j,w){\n      if(p[i][j]){\n        cout << \"o\";\n      }else{\n          cout << \"x\";\n      }\n    }\n    cout << endl;\n  }\n}\nvoid show(board b){\n  rep(i,h){\n    rep(j,w) cout << b[i][j];\n    cout << endl;\n  }\n}\n\nint func(board b){\n  conect_map rtn(h, vector<bool>(w, false));\n  vector<pos> now;\n  rtn[0][0] = true;\n  int cnt = 0;\n  now.push_back({0,0});\n  while(now.size() != 0){\n    vector<pos> next;\n    cnt += now.size();\n    rep(i,now.size()){\n      int x,y;\n      x = now[i].x+1; y= now[i].y;\n      if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==c){\n        next.push_back({x,y});\n        rtn[x][y] = true;\n      }\n      x = now[i].x-1; y= now[i].y;\n      if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==c){\n        next.push_back({x,y});\n        rtn[x][y] = true;\n      }\n      x = now[i].x; y= now[i].y+1;\n      if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==c){\n        next.push_back({x,y});\n        rtn[x][y] = true;\n      }\n      x = now[i].x; y= now[i].y-1;\n      if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==c){\n        next.push_back({x,y});\n        rtn[x][y] = true;\n      }\n    }\n    now = next;\n  }\n  return cnt;\n}\nboard move(board b, int color){\n  conect_map rtn(h, vector<bool>(w, false));\n  vector<pos> now;\n  rtn[0][0] = true;\n  now.push_back({0,0});\n  int c = b[0][0];\n  while(now.size() != 0){\n    vector<pos> next;\n    rep(i,now.size()){\n      // cout << now[i].x << \",\" << now[i].y << endl;\n      int x,y;\n      x = now[i].x+1; y= now[i].y;\n      if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==c){\n        next.push_back({x,y});\n        rtn[x][y] = true;\n      }\n      x = now[i].x-1; y= now[i].y;\n      if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==c){\n        next.push_back({x,y});\n        rtn[x][y] = true;\n      }\n      x = now[i].x; y= now[i].y+1;\n      if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==c){\n        next.push_back({x,y});\n        rtn[x][y] = true;\n      }\n      x = now[i].x; y= now[i].y-1;\n      if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==c){\n        next.push_back({x,y});\n        rtn[x][y] = true;\n      }\n    }\n    now = next;\n  }\n  //cout << \"color:\" << color << endl;\n  //show(rtn);\n  rep(i,h){\n    rep(j,w){\n      if(rtn[i][j]){\n        b[i][j] = color;\n        int x,y;\n        x = i+1; y= j;\n        if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==color){\n          b[x][y] = color;\n        }\n        x = i-1; y= j;\n        if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==color){\n          b[x][y] = color;\n        }\n        x = i; y= j+1;\n        if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==color){\n          b[x][y] = color;\n        }\n        x = i; y= j-1;\n        if(x >= 0 && x<h && y>=0 && y<w && !rtn[x][y] && b[x][y]==color){\n          b[x][y] = color;\n        }\n      }\n    }\n  }\n  return b;\n}\nint DFS(board b,int n){\n  //cout << \"n:\"<< n << endl;\n  if(n==5){\n    //cout << func(b) << endl;\n    //show(b);\n    return func(b);\n  }\n  if(n!=4){\n    board sent = b;\n    int rtn = 0;\n    REPE(i,1,6){\n      sent = move(b,i);\n      rtn = max(rtn, DFS(sent,n+1));\n    }\n    return rtn;\n  }else{\n    board sent = b;\n    sent = move(b,c);\n    return DFS(sent, n+1);\n  }\n\n}\n\n\nint main(){\n  while(true){\n    cin >> h >> w >> c;\n    if(h==0 && w==0 && c==0) break;\n    board b(h,vector<int>(w,0));\n    rep(i,h) rep(j,w) cin >> b[i][j];\n    cout << DFS(b,0) << endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\n\nint temp, h, w, from, to, c;\n\nvoid count(int i, int j, vector<vector<int> >& b, int& temp){\n    temp++;\n    b[i][j] = -1;\n    for(int l = 0; l < 4; l++){\n        int ni = i + di[l];\n        int nj = j + dj[l];\n        if(0 <= ni && ni < h && 0 <= nj && nj < w && b[ni][nj] == c) count(ni, nj, b, temp);\n    }\n    return;\n\n}\n\nvoid change(int i, int j, vector<vector<int> >& a){\n\n    if(from == to) return;\n    a[i][j] = to;\n    for(int l = 0; l < 4; l++){\n        int ni = i + di[l];\n        int nj = j + dj[l];\n        if(0 <= ni && ni < h && 0 <= nj && nj < w && a[ni][nj] == from) change(ni, nj, a);\n    }\n    return;\n}\n\nint main(){\n    \n    while(1){\n\n        //入力\n        cin >> h >> w >> c;\n        if(!h) break;\n        vector<vector<int> > a(h, vector<int> (w));\n        for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) cin >> a[i][j];\n\n        \n        vector<vector<int> > b(h, vector<int> (w));\n        //change(h, w, 0, 0, 1, 3, a);\n        int ans = 0;\n\n        /*\n        change(h, w, 0, 0, b[0][0], 1, a);\n        change(h, w, 0, 0, b[0][0], 1, a);\n        change(h, w, 0, 0, b[0][0], 2, a);\n        change(h, w, 0, 0, b[0][0], 2, a);\n        change(h, w, 0, 0, b[0][0], c, a);\n        */\n\n\n        for(int i = 1; i <= 6; i++){\n            for(int j = 1; j <= 6; j++){\n                for(int k = 1; k <= 6; k++){\n                    for(int l = 1; l <= 6; l++){\n\n                        \n                        for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) b[i][j] = a[i][j];\n                        \n                        //cout << \"ok\" << endl;\n                        //cout << i << j << k << l << endl;\n                        from = b[0][0];\n                        to = i;\n                        //cout << from << \" \" << to << endl;\n                        change(0, 0, b);\n                        from = b[0][0];\n                        to = j;\n                        //cout << from << \" \" << to << endl;                        \n                        change(0, 0, b);\n                        from = b[0][0];\n                        to = k;\n                        //cout << from << \" \" << to << endl;                        \n                        change(0, 0, b);\n                        from = b[0][0];\n                        to = l;\n                        //cout << from << \" \" << to << endl;\n                        change(0, 0, b);\n                        from = b[0][0];\n                        to = c;\n                        //cout << from << \" \" << to << endl; \n\n                        /*for(int i = 0; i < h; i++){\n                            for(int j = 0; j < w; j++){\n                                cout << b[i][j] << \" \";\n                            }\n                            cout << endl;\n                        }*/\n\n                        change(0, 0, b);\n                        //cout << \"ok\" << endl;\n                        //int temp = 0;\n                        //for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) if(b[i][j] == c) temp++;\n                        temp = 0;\n                        count(0, 0, b, temp);\n                        ans = max(ans, temp);\n\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int DR[] = {-1, 0, 1, 0};\nconst int DC[] = {0, -1, 0, 1};\n\nint paint(vector<vector<int> > &field, vector<vector<int> > &visited, int r, int c, int color) {\n    const int H = field.size();\n    const int W = field[0].size();\n    visited[r][c] = true;\n\n    int cnt = 1;\n    for(int i = 0; i < 4; ++i) {\n        int nr = r + DR[i];\n        int nc = c + DC[i];\n        if(0 <= nr && nr < H && 0 <= nc && nc < W) {\n            if(!visited[nr][nc] && field[nr][nc] == field[r][c]) cnt += paint(field, visited, nr, nc, color);\n        }\n    }\n    field[r][c] = color;\n\n    return cnt;\n}\n\nint main() {\n    while(true) {\n        int H, W, C;\n        cin >> H >> W >> C;\n        if(!H && !W && !C) break;\n\n        vector<vector<int> > v(H, vector<int>(W));\n        for(int i = 0; i < H; ++i) {\n            for(int j = 0; j < W; ++j) {\n                cin >> v[i][j];\n            }\n        }\n\n        int ans = 0;\n        int lim = 1;\n        for(int i = 0; i < 4; ++i) lim *= 6;\n        for(int pat = 0; pat <= lim; ++pat) {\n            vector<vector<int> > field = v;\n\n            int tmp = pat;\n            for(int i = 0; i < 4; ++i) {\n                int color = tmp%6 + 1;\n                tmp /= 6;\n                vector<vector<int> > visited(H, vector<int>(W, 0));\n                paint(field, visited, 0, 0, color);\n            }\n            {\n                vector<vector<int> > visited(H, vector<int>(W, 0));\n                paint(field, visited, 0, 0, C);\n            }\n            {\n                vector<vector<int> > visited(H, vector<int>(W, 0));\n                ans = max(ans, paint(field, visited, 0, 0, 7));\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = 998244353;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e6 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct UnionFindTree {\n    vector<int> par;\n    vector<int> rank;\n    vector<int> siz;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        siz.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n            siz[i] = 1;\n        }\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        siz[x] += siz[y];\n    }\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        x = find(x);\n        return siz[x];\n    }\n};\n\nint h, w, c, p[10][10];\nvector<vector<int> > ls;\n\nvoid dfs(int i, vector<int> &v){\n    if(i==4){\n        ls.push_back(v);\n    }\n    else{\n        for(int m=1;m<=6;m++){\n            if(i==0 || v.back() != m){\n                v.push_back(m);\n                dfs(i+1,v);\n                v.pop_back();\n            }\n        }\n    }\n}\n\nint solve(int si, int sj){\n    int res = 0;\n    UnionFindTree uf;\n    for(int m=0;m<ls.size();m++){\n        if(ls[m][0] == p[si][sj])continue;\n        uf.init(h*w);\n        queue<P> que, used;\n        que.push({si,sj});\n        int now = p[si][sj];\n        for(int i=0;i<6;i++){\n            //cout << now << endl;\n            while(!que.empty()){\n                P tmp = que.front();\n                que.pop();\n                int pi = tmp.first, pj = tmp.second;\n                if(now == p[pi][pj]){\n                    //cout << pi << \" \" << pj << endl;\n                    uf.unite(si*w+sj, pi*w+pj);\n                    for(int k=0;k<4;k++){\n                        int ni = pi + di[k], nj = pj + dj[k];\n                        if(ni < 0 || ni >= h) continue;\n                        if(nj < 0 || nj >= w) continue;\n                        if(uf.is_same(si*w+sj, ni*w+nj))continue;\n                        que.push({ni,nj});\n                    }\n                }\n                else{\n                    used.push(tmp);\n                }\n            }\n            if(i<4){\n                now = ls[m][i];\n            }\n            else{\n                now = c;\n            }\n            while(!used.empty()){\n                que.push(used.front());\n                used.pop();\n            }\n        }\n        if(res < uf.size(si*w+sj)){\n            res = uf.size(si*w+sj);\n            //cout << res << endl;\n            //for(auto t : ls[m]){\n                //cout << t << \" \";\n            //}\n            //cout << c << endl;\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector<int> v;\n    dfs(0,v);\n    while(cin >> h >> w >> c, h){\n        REP(i,h)REP(j,w) cin >> p[i][j];\n        int ans = 0;\n        cout << solve(0,0) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n struct unionfind{\n\tprivate:\n\tpublic:\n\t\nvector<int> par,ranks,kosuu;\n\t\n\tvoid shoki(int N){\n\t\tpar.resize(N+1,0);\n\t\tranks.resize(N+1,0);\n\t\tkosuu.resize(N+1,1);\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\treturn par[x]==x ? x : par[x]=root(par[x]);\n\t}\n\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\tbool is_root(int x){\n\t\treturn x==root(x);\n\t}\n\tvoid unite(int x,int y){\n \t\tx=root(x);\n\t \ty=root(y);\n\t\tint xx=kosuu[x],yy=kosuu[y];\n\t \tif(x==y) return;\n\t\tif(ranks[x]<ranks[y]){\n\t\t\tpar[x]=y;\n\t\t\tkosuu[y]=yy+xx;\n\t\t}\n\t \telse {\n\t\t\tpar[y]=x;\n\t\t\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n\t \t\tkosuu[x]=yy+xx;\n\t \t}\n\t\treturn;\n\t}\n};\n\nint ban[10][10];\nint h,w,c;\nint sol(vector<int> ve){\n\tunionfind uf;\n\tuf.shoki(100);\n\t\n\tfor(int i=1;i<h;i++)for(int j=1;j<=w;j++){\n\t\tif(ban[i][j]==ban[i+1][j])uf.unite(i*10+j,(i+1)*10+j);\n\t}\n\t\n\tfor(int i=1;i<=h;i++)for(int j=1;j<w;j++){\n\t\tif(ban[i][j]==ban[i][j+1])uf.unite(i*10+j,(i)*10+j+1);\n\t}\n\t\n\tfor(int num=0;num<5;num++){\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)if(uf.root(i*10+j)!=11)if(ban[i][j]==ve[num]){\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tint di=i+dx[r];\n\t\t\t\tint dj=j+dy[r];\n\t\t\t\tif(di<=0 || dj<=0 || di>h || dj>w) continue;\n\t\t\t\tif(!uf.same(di*10+dj,11)) continue;\n\t\t\t//\tcout<<i<<\" \"<<j<<\" \"<<di<<\" \"<<dj<<endl;\n\t\t\t\tuf.unite(i*10+j,di*10+dj);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<uf.kosuu[uf.root(11)]<<endl;\n\treturn uf.kosuu[uf.root(11)];\n}\n\nvoid solve(){\n\t\n\tcin>>h>>w>>c;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)cin>>ban[i][j];\n\tif(h==0 && w==0) exit(0);\n\tvector<int> ve;\n//\tvector<int> ve={1,2,3,4,5};\n//\tsol(ve);\n//\treturn;\n\tint ans=0;\n\t\n\tfor(int i=1;i<=6;i++){\n\t\tve.pb(i);\n\t\tfor(int j=1;j<=6;j++){\n\t\t\tve.pb(j);\n\t\t\tfor(int k=1;k<=6;k++){\n\t\t\t\tve.pb(k);\n\t\t\t\tfor(int l=1;l<=6;l++){\n\t\t\t\t\tve.pb(l);\n\t\t\t\t\tve.pb(c);\n\t\t\t\t\tans=max(ans,sol(ve));\n\t\t\t\t\tve.pop_back();\n\t\t\t\t\tve.pop_back();\n\t\t\t\t}\n\t\t\t\tve.pop_back();\n\t\t\t}\n\t\t\tve.pop_back();\n\t\t}\n\t\tve.pop_back();\n\t}\n\tcout<<ans<<endl;\n\treturn ;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \n \twhile(1){\n \t\tsolve();\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  ICPC2011C\n//\n//  Created by aki33524 on 2014/07/02.\n//  Copyright (c) 2014年 aki33524. All rights reserved.\n//\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint H, W, C;\nint field[8][8];\nint dh[] = {0, 0, 1, -1};\nint dw[] = {1, -1, 0, 0};\n\nvoid dfs2(int h, int w, int pc, int nc){\n    field[h][w] = nc;\n    \n    for(int i=0; i<4; i++){\n        int nh = h + dh[i];\n        int nw = w + dw[i];\n        if(0<=nh&&nh<H && 0<=nw&&nw<W && field[nh][nw]==pc && field[nh][nw]!=nc){\n            dfs2(nh, nw, pc, nc);\n        }\n    }\n}\n\n\nint dfs(int deepth, int changes[]){\n    int res;\n    int tfield[8][8];\n    \n    //memcopyで\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            tfield[h][w] = field[h][w];\n        }\n    }\n    \n    dfs2(0, 0, field[0][0], changes[deepth]);\n    \n    if(deepth < 5){\n        res = dfs(deepth+1, changes);\n    }else{\n        res = 0;\n        for(int h=0; h<H; h++){\n            for(int w=0; w<W; w++){\n                if(field[h][w] == changes[deepth]){\n                    res ++;\n                }\n            }\n        }\n    }\n    \n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            field[h][w] = tfield[h][w];\n        }\n    }\n    \n    return res;\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i1=1; i1<=6; i1++){\n        for(int i2=1; i2<=6; i2++){\n            for(int i3=1; i3<=6; i3++){\n                for(int i4=1; i4<=6; i4++){\n                    int i5 = C;\n                    int chnges[] = {i1, i2, i3, i4, i5};\n                    ans = max(ans, dfs(0, chnges));\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[])\n{\n    while(cin >>H>>W>>C, H|W|C){\n        for(int h=0; h<H; h++){\n            for(int w=0; w<W; w++){\n                cin >> field[h][w];\n            }\n        }\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint h, w, c;\nint p[10][10];\nbool used[10][10];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nint dfs2(int x, int y, int c, int nc, int p[10][10])\n{\n\tused[x][y] = true;\n\tp[x][y] = nc;\n\tint nx, ny, ret = 1;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = x + dx[i], ny = y + dy[i];\n\t\tif(nx <= 0 || nx > w || ny <= 0 || ny > h) continue;\n\t\tif(used[nx][ny]) continue;\n\t\tif(p[nx][ny] != c) continue;\n\t\tret += dfs2(nx, ny, c, nc, p);\n\t}\n\treturn ret;\n}\n\nint dfs(int t, int p[10][10])\n{\n\tif(t == 5){\n\t\tfor(int x = 1; x <= w; x++){\n\t\t\tfor(int y = 1; y <= h; y++){\n\t\t\t\tused[x][y] = false;\n\t\t\t}\n\t\t}\n\t\treturn dfs2(1, 1, c, 0, p);\n\t}\n\t\n\tint np[10][10], ret = 0;\n\tfor(int i = 1; i <= 6; i++){\n\t\tif(t == 4 && i != c) continue;\n\t\tfor(int x = 1; x <= w; x++){\n\t\t\tfor(int y = 1; y <= h; y++){\n\t\t\t\tnp[x][y] = p[x][y];\n\t\t\t\tused[x][y] = false;\n\t\t\t}\n\t\t}\n\t\tdfs2(1, 1, p[1][1], i, np);\n\t\tret = max(ret, dfs(t+1, np));\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> h >> w >> c;\n\t\tif(h == 0 && w == 0 && c == 0) break;\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tcin >> p[x][y];\n\t\t\t}\n\t\t}\n\t\tcout << dfs(0, p) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n\nusing namespace std;\n\n#define fin cin\n\nint panel[8][8];\nint h, w, last;\n\nbool come[8][8];\n\nvoid come_init() {\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tcome[i][j] = false;\n\t\t}\n\t}\n}\n\n//????????????????????????????????£??\\????????????????¨????\nint getCount(int map[][8], int y, int x) {\n\n\t//??????????????¨NullPo??????\n\tif (x < 0 || y < 0 || x >= 8 || y >= 8)return 0;\n\t\n\tif (map[y][x] != map[0][0] || come[y][x])return 0;\n\n\tcome[y][x] = true;\n\n\tint count = 1;\n\tcount += getCount(map, y + 1, x);\n\tcount += getCount(map, y, x + 1);\n\tcount += getCount(map, y - 1, x);\n\tcount += getCount(map, y, x - 1);\n\n\treturn count;\n}\n\nvoid change(int map[][8], bool (*f_change)[8], int y, int x) {\n\tif (x < 0 || y < 0 || x >= 8 || y >= 8)return;\n\n\tif (map[y][x] != map[0][0] || f_change[y][x])return;\n\n\tchange(map, f_change, y + 1, x);\n\tchange(map, f_change, y, x + 1);\n\tchange(map, f_change, y - 1, x);\n\tchange(map, f_change, y, x - 1);\n\n\t//cout << f_change[0][1];\n\n}\n\n\n//search(????????????????????????????????????????????????)\nint search(int map[][8], int level, int color) {\n\tstatic int max = 0;\n\tif (level == 0)max = 0;\n\n\t\n\t//??£??\\??????????????????color????????????\n\n\tbool f_change[8][8] = {};\n\t\n\tchange(map, f_change, 0, 0);\n\n\t/*\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\n\t\t\tif (map[i][j] == map[0][0]) {\n\t\t\t\tif (\n\t\t\t\t\t(i < 7 && map[i][j] == map[i + 1][j] && f_change[i + 1][j]) ||\n\t\t\t\t\t(j < 7 && map[i][j] == map[i][j + 1] && f_change[i][j + 1]) ||\n\t\t\t\t\t(i > 0 && map[i][j] == map[i - 1][j] && f_change[i - 1][j]) ||\n\t\t\t\t\t(j > 0 && map[i][j] == map[i][j - 1] && f_change[i][j - 1])\n\t\t\t\t\t)\n\t\t\t\t\tf_change[i][j] = true;\n\t\t\t}\n\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif(f_change[i][j])map[i][j] = color;\n\t\t}\n\t}\n\tlevel++;\n\n\tif (level < 4) {\n\n\t\tfor (int i = 1; i <= 6; i++) {\n\n\t\t\tint map_tmp[8][8];\n\n\t\t\t//copy\n\t\t\tfor (int y = 0; y < 8; y++) {\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tmap_tmp[y][x] = map[y][x];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint tmp = search(map_tmp, level, i);\n\t\t\tif (max < tmp)max = tmp;\n\n\t\t}\n\t}\n\t//4??????????????????5??????\n\telse if (level == 4) {\n\t\tint map_tmp[8][8];\n\n\t\t//copy\n\t\tfor (int y = 0; y < 8; y++) {\n\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\tmap_tmp[y][x] = map[y][x];\n\t\t\t}\n\t\t}\n\n\t\tint tmp = search(map_tmp, level, last);\n\t\tif (max < tmp)max = tmp;\n\t\n\t}\n\t//5??????????????????\n\telse if (level == 5) {\n\t\tcome_init();\n\t\tint tmp = getCount(map, 0, 0);\n\t\tif (max < tmp) {\n\t\t\tmax = tmp;\n\n\t\t\tif(0)\n\t\t\t{\n\t\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t\t\tcout << map[y][x] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tcout << \"   :   \" << level << \" \" << color << endl;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn max;\n}\n\n\nint main() {\n\t//ifstream fin(\"in.txt\");\n\n\twhile (true) {\n\t\tfin >> h >> w >> last;\n\t\tif ((h | w) == 0)break;\n\n\t\t//initialize\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\tpanel[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\t//input\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfin >> panel[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tint panel_tmp[8][8];\n\t\t\t\n\t\t\t//copy\n\t\t\tfor (int y = 0; y < 8; y++) {\n\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\tpanel_tmp[y][x] = panel[y][x];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint tmp = search(panel_tmp, 0, i);\n\t\t\tif (max < tmp)max = tmp;\n\t\t}\n\n\t\tcout << max << endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, f, a[9][9], b[9][9], g[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e; f++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nint solve(int d) {\n\tif (d == 4) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) g[i][j] = b[i][j];\n\t\t}\n\t\tf = 0; rec(0, 0, c);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) b[i][j] = g[i][j];\n\t\t}\n\t\treturn f;\n\t}\n\tint ret = 0;\n\tfor (int k = 1; k <= 6; k++) {\n\t\tif (b[0][0] == k) continue;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) g[i][j] = b[i][j];\n\t\t}\n\t\tf = 0; rec(0, 0, k);\n\t\tret = max(ret, solve(d + 1));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) b[i][j] = g[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\trec(0, 0, 3);\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<functional>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MOD = 1000000007;\nconst ll INF=2e18;\n\nll H,W,C;\nqueue<P> edgeQ;\nqueue<P> nowColorQ;\nconst ll dh[4]={0,1,0,-1};\nconst ll dw[4]={1,0,-1,0};\nbool checked[10][10];\nll p[10][10];\nvoid UpdateEdgeQ(ll color,ll& ans){\n    vector<P> returnToEdgeQ;\n    while(!edgeQ.empty()){\n        P now=edgeQ.front();edgeQ.pop();\n        ll nh=now.first;\n        ll nw=now.second;\n        if(p[nh][nw]==color && !checked[nh][nw]){\n            nowColorQ.push(now);\n            checked[nh][nw]=true;\n            ans++;\n        }else{\n            returnToEdgeQ.push_back(now);\n        }\n    }\n    for(auto p:returnToEdgeQ){\n        edgeQ.push(p);\n    }\n    while(!nowColorQ.empty()){\n        P now=nowColorQ.front();nowColorQ.pop();\n        ll nh=now.first;\n        ll nw=now.second;\n        for(ll i=0;i<4;i++){\n            ll h=nh+dh[i];\n            ll w=nw+dw[i];\n            if(0<=h&&h<H && 0<=w&&w<W && !checked[h][w]){\n                if(p[h][w]==color){\n                    nowColorQ.push(P(h,w));\n                    checked[h][w]=true;\n                    ans++;\n                }else{\n                    edgeQ.push(P(h,w));\n                }\n            }\n        }\n    }\n}\nll Solve(vector<ll>& changedColor){\n    if(changedColor.size()==4){\n        changedColor.push_back(C);\n        for(ll i=0;i<H;i++){\n            for(ll j=0;j<W;j++){\n                checked[i][j]=false;\n            }\n        }\n        edgeQ.push(P(0,0));\n        ll ret=0;\n        UpdateEdgeQ(p[0][0],ret);\n        for(auto c:changedColor){\n            UpdateEdgeQ(c,ret);\n        }\n        while(!edgeQ.empty()){\n            edgeQ.pop();\n        }\n        changedColor.pop_back();\n        return ret;\n    }\n    \n    ll ret=0;\n    for(ll i=1;i<=6;i++){\n        if(changedColor.size()!=0 && i==changedColor[changedColor.size()-1])continue;\n        changedColor.push_back(i);\n        ret=max(ret,Solve(changedColor));\n        changedColor.pop_back();\n    }\n    return ret;\n}\nint main(){\n    while(cin>>H>>W>>C,H!=0){\n        vector<ll> changedColor;\n        changedColor.reserve(5);\n        for(ll i=0;i<H;i++){\n            for(ll j=0;j<W;j++){\n                cin>>p[i][j];\n            }\n        }\n        cout<<Solve(changedColor)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint h,w,c;\nint p[10][10];\nint ans;\n\nstruct data{\n  int i,j;\n  data(int a,int b){i=a;j=b;}\n};\n\nbool isVisit[10][10];\nint di[]={0,0,1,-1}, dj[]={1,-1,0,0};\nint count(int i, int j){\n  if( i<0||j<0 ) return 0;\n  if( i>=h||j>=w ) return 0;\n  if( isVisit[i][j] ) return 0;\n  if( p[i][j] != c )return 0;\n\n  int rtn =1;\n  isVisit[i][j] = true;\n  for( int d=0;d<4;d++ )\n    rtn += count(i+di[d], j+dj[d]);\n\n  return rtn;\n}\n\nvector<data> haveSameC(int i,int j, int c){\n  vector<data> v;\n  if( i<0||j<0 ) return v;\n  if( i>=h||j>=w ) return v;\n  if( isVisit[i][j] ) return v;\n  if( p[i][j] != c ) return v;\n\n  isVisit[i][j] = true;\n  v.push_back( data(i,j) );\n  for( int d=0;d<4;d++ ){\n    vector<data> dd = haveSameC(i+di[d], j+dj[d], c);\n    for( int k=0;k<(int)dd.size();k++ )\n      v.push_back( dd[k] );\n  }\n  return v;\n}\n\nvoid rec(int n){ // 0<c<=6\n  if( n==0 ){\n    // count color\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ )\n\tisVisit[i][j] = false;\n    ans = max( ans, count(0,0) );\n\n    return ;\n  }\n  n--;\n\n  for(int i=0;i<h;i++ )\n    for( int j=0;j<w;j++ )\n      isVisit[i][j] = false;\n\n  int orgC = p[0][0];\n  vector<data> same = haveSameC(0,0, orgC);\n  //  cout << n << \" :\" << same.size() << endl;\n  for( int cc=1;cc<=6;cc++ ){\n    if( cc == orgC )\n      continue;\n    for( int i=0;i<(int)same.size();i++ ){\n      data &d = same[i];\n      p[d.i][d.j] = cc;\n    }\n    rec(n);\n  }\n  for( int i=0;i<(int)same.size();i++ ){\n    data &d = same[i];\n    p[d.i][d.j] = orgC;\n  }\n\n}\n\nint main(){\n  while(cin>>h>>w>>c,h){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ )\n\tcin >> p[i][j];\n    ans=0;\n    rec(5);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,c,ans,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nbool check(int x,int y) {\n  return x>=0 && x<n && y>=0 && y<m;\n}\n\nvoid solve(vector<int> a[], int t) {\n  int e=a[0][0];\n  for(int k=1; k<=6; k++) {\n    if(t<5 && k==e) continue;\n    if(t==5 && k!=e) continue;\n    vector<int> b[n];\n    for(int i=0; i<n; i++) b[i]=a[i];\n    bool u[n][m];\n    memset(u,0,sizeof(u));\n    queue<P> que;\n    que.push(P(0,0));\n    b[0][0]=k;\n    u[0][0]=1;\n    int cnt=1;\n    while(!que.empty()) {\n      P p=que.front();que.pop();\n      int nx=p.first,ny=p.second;\n      for(int i=0; i<4; i++) {\n        int x=nx+dx[i],y=ny+dy[i];\n        if(check(x,y) && b[x][y]==e && !u[x][y]) {\n          b[x][y]=k;\n          u[x][y]=1;\n          cnt++;\n          que.push(P(x,y));\n        }\n      }\n    }\n    if(t==5 && e==c) ans=max(ans,cnt);\n    if(t<5) solve(b,t+1);\n  }\n}\n\nint main() {\n  while(cin >> n >> m >> c && n) {\n    vector<int> a[n];\n    for(int i=0; i<n; i++) {\n      for(int j=0,x; j<m; j++) {\n        cin >> x;\n        a[i].push_back(x);\n      }\n    }\n    ans=0;\n    solve(a,0);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,c,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nvector<int> p(64);\n\nint nu(int x,int y,int cl,int t){\n  int res=1;\n  p[y*w+x]=cl;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||w<=nx||ny<0||h<=ny||p[ny*w+nx]!=t||p[ny*w+nx]==cl)continue;\n    res+=nu(nx,ny,cl,t);\n  }\n  return res;\n}\n\nint dfs(int d){\n  if(d==4){\n    nu(0,0,c,p[0]);\n    return nu(0,0,7,p[0]);\n  }\n  vector<int> tp=p;\n  int res=0;\n  for(int j=1;j<7;j++){\n    nu(0,0,j,p[0]);\n    res=max(res,dfs(d+1)),p=tp;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>h>>w>>c,h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>p[i*w+j];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nint h,w,c;\nvector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\nbool isin(int x, int y){\n  bool ans;\n  if(0 <= x and x < h and 0 <= y and y < w) ans = true;\n  else ans = false;\n  return ans;\n}\n\nvoid changeto(int to,vector<vector<int>> &tmpp){\n  queue<pair<int,int>> q;\n  int from = tmpp[0][0];\n  if(from == to) return;\n\n  q.push(pair<int,int>(0,0));\n  tmpp[0][0] = to;\n\n  while(not q.empty()){\n    pair<int,int> p = q.front();\n    q.pop();\n\n    rep(i, dx.size()){\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(isin(nx,ny) and tmpp[nx][ny] == from){\n\tq.push(pair<int,int>(nx, ny));\n\ttmpp[nx][ny] = to;\n      }\n    }\n  }\n}\n\nint area(vector<vector<int>> tmpp){\n  queue<pair<int,int>> q;\n\n  q.push(pair<int,int>(0,0));\n  int tmpc = tmpp[0][0];\n  tmpp[0][0] = -1;\n  int res = 1;\n\n  while(not q.empty()){\n    pair<int,int> p = q.front();\n    q.pop();\n\n    rep(i, dx.size()){\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(isin(nx,ny) and tmpp[nx][ny] == tmpc){\n\tq.push(pair<int,int>(nx, ny));\n\ttmpp[nx][ny] = -1;\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint rec(int depth,vector<vector<int>> p){\n  if(depth == 4){\n    changeto(c,p);\n    int res = area(p);\n    return res;\n  }\n\n  int res = 0;\n  FOR(i,1,7){\n    vector<vector<int>> tmpp = p;\n    changeto(i,tmpp);\n    res = max(res, rec(depth+1, tmpp));\n  }\n  return res;\n}\n\t      \nint main(void){\n  while(cin >> h >> w >> c, h){\n    vector<vector<int>> p(h,vector<int>(w));\n    rep(i,h) rep(j,w) cin >> p[i][j];\n\n    int res = rec(0,p);\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);i++)\nint h, w,c;\nint max_n = 0;\nstruct Area{ int c, f; };\nArea area[8][8] = { 0 };\ntypedef pair <int,int>P;\n\nvoid solve(int cr, int level){\n\n\tqueue<P> que;\n\tbool color[6] = { false };\n\tcolor[c] = true;\n\tbool check[8][8] = { false };\n\tque.push(P(0, 0));\n\twhile (!que.empty()){\n\t\tP pos = que.front();\n\t\tque.pop();\n\t\tint y = pos.first;\n\t\tint x = pos.second;\n\t\tarea[y][x].f++;\n\t\tif (y > 0)if (!check[y - 1][x]){\n\t\t\tif (area[y - 1][x].c == cr)que.push(P(y - 1, x));\n\t\t\telse color[area[y - 1][x].c] = true;\n\t\t\tcheck[y - 1][x] = true;\n\t\t}\n\t\tif (x > 0)if (!check[y][x - 1]){\n\t\t\tif (area[y][x - 1].c == cr)que.push(P(y, x - 1));\n\t\t\telse color[area[y][x - 1].c] = true;\n\t\t\tcheck[y][x - 1] = true;\n\t\t}\n\t\tif (y < h - 1)if (!check[y + 1][x]){\n\t\t\tif (area[y + 1][x].c == cr)que.push(P(y + 1, x));\n\t\t\telse color[area[y + 1][x].c] = true;\n\t\t\tcheck[y + 1][x] = true;\n\t\t}\n\t\tif (x < w - 1)if (!check[y][x + 1]){\n\t\t\tif (area[y][x + 1].c == cr)que.push(P(y, x + 1));\n\t\t\telse color[area[y][x + 1].c] = true;\n\t\t\tcheck[y][x + 1] = true;\n\t\t}\n\t}\n\t\n\tif (level<5){\n\t\trep(k, 0, 6)if (color[k]){\n\t\t\trep(i, 0, h)rep(j, 0, w)if (area[i][j].f>0)area[i][j].c = k;\n\t\t\tsolve(k, level + 1);\n\t\t}\n\t}\n\tif (cr == c){\n\t\tint n = 0;\n\t\trep(i, 0, h)rep(j, 0, w)if (area[i][j].f > 0)n++;\n\t\tif (max_n<n)max_n = n;\n\t}\n\trep(i, 0, h)rep(j, 0, w)if (area[i][j].f>0)area[i][j].c = cr, area[i][j].f--;\n\t\t\n\t\n}\n\nint main(void){\n\twhile (true){\n\t\tcin >> h >> w >> c;\n\t\tif (h == 0)\n\t\treturn(0);\n\t\tc--;\n\t\tmax_n = 0;\n\t\t//input\n\t\trep(i, 0, h)rep(j, 0, w){\n\t\t\tArea input;\n\t\t\tcin >> input.c;\n\t\t\tinput.c--;\n\t\t\tinput.f = 0;\n\t\t\tarea[i][j] = input;\n\n\t\t}\n\t\tsolve(area[0][0].c, 0);\n\t\tcout << max_n << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\nusing namespace std;\nstruct point_t { int x, y; };\ntemplate <typename T>\nbool on(point_t p, T const & xss) {\n    return 0 <= p.y and p.y < xss.size()\n        and 0 <= p.x and p.x < xss.front().size();\n}\nconst point_t directions[] = { {0,1},{0,-1},{1,0},{-1,0} };\npoint_t operator + (point_t a, point_t b) { return { a.x + b.x, a.y + b.y }; }\nvector<vector<int> > shock(int c, vector<vector<int> > const & p) {\n    assert (1 <= c and c <= 6);\n    vector<vector<int> > q = p;\n    stack<point_t> s;\n    s.push({ 0, 0 });\n    while (not s.empty()) {\n        point_t a = s.top(); s.pop();\n        if (q[a.y][a.x] == c) continue;\n        q[a.y][a.x] = c;\n        for (point_t b : directions) {\n            b = a + b;\n            if (on(b, p) and q[b.y][b.x] == p[0][0]) {\n                s.push(b);\n            }\n        }\n    }\n    return q;\n}\nint count(vector<vector<int> > const & p) {\n    vector<vector<bool> > used(p.size(), vector<bool>(p.front().size()));\n    int result = 0;\n    stack<point_t> s;\n    s.push({ 0, 0 });\n    while (not s.empty()) {\n        point_t a = s.top(); s.pop();\n        if (used[a.y][a.x]) continue;\n        used[a.y][a.x] = true;\n        result += 1;\n        for (point_t b : directions) {\n            b = a + b;\n            if (on(b, p) and not used[b.y][b.x] and p[b.y][b.x] == p[0][0]) {\n                s.push(b);\n            }\n        }\n    }\n    return result;\n}\nint solve(int i, vector<vector<int> > const & p, int c) {\n    if (i == 4) {\n        return count(shock(c, p));\n    }\n    int result = 0;\n    for (int j : { 1,2,3,4,5,6 }) {\n        result = max(result, solve(i+1, shock(j,p), c));\n    }\n    return result;\n}\nint main() {\n    while (true) {\n        int h, w, c; cin >> h >> w >> c;\n        if (h == 0 and w == 0 and c == 0) break;\n        vector<vector<int> > p(h, vector<int>(w));\n        repeat (y, h) {\n            repeat (x, w) {\n                cin >> p[y][x];\n            }\n        }\n        cout << solve(0,p,c) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,e) for ( int i = b; i < e; i++)\n#define rep(i,n) REP(i,0,n)\nstatic const int MAX = 10;\nstatic const int di[4] = {0, -1, 0, 1};\nstatic const int dj[4] = {1, 0, -1, 0};\n\nint H, W, C, G[MAX][MAX], V[MAX+2][MAX];\nint cnt, ans;\n\nvoid init(){ \n  REP(i, 1, H+1) REP(j, 1, W+1) V[i][j] = 0; \n  cnt = 0;\n}\n\nvoid fillc(int color, int i, int j, int prec){\n  G[i][j] = V[i][j] = color;\n  cnt++;\n  rep(r, 4){\n    int ni = i + di[r];\n    int nj = j + dj[r];\n    if ( G[ni][nj] == prec && !V[ni][nj]) fillc(color, ni, nj, prec);\n  }\n}\n\nvoid solve(int d){\n  int T[MAX][MAX];\n  if ( d == 4 ){\n    rep(i, 2){ init(); fillc(C, 1, 1, G[1][1]); }\n    ans = max(ans, cnt);\n    return;\n  }\n  \n  REP(a, 1, 7) {\n    REP(i, 1, H+1) REP(j, 1, W+1) T[i][j] = G[i][j]; \n    init(); fillc(a, 1, 1, G[1][1]);\n    solve(d+1);\n    REP(i, 1, H+1) REP(j, 1, W+1) G[i][j] = T[i][j];\n  }\n}\n\nmain(){\n  while(1){\n    cin >> H >> W >> C;\n    if ( H == 0 ) break;\n    rep(i, H+2) rep(j, W+2) G[i][j] = 0;\n    rep(i, H) rep(j, W) cin >> G[i+1][j+1];\n    ans = 0;\n    solve(0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint h,w,c;\nint p[8][8];\n\nvoid print(int d){\n\tcout<<\"depth:\"<<d<<endl;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)cout<<p[i][j]<<' ';\n\t\tcout<<endl;\n\t}\n}\nbool all(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\n\t\t\tif(p[0][0]!=p[i][j])return false;\n\t}\n\treturn true;\n}\nbool in(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\nint _count(int y,int x,int c){\n\tif(!in(y,x))return 0;\n\tif(c!=p[y][x])return 0;\t\n\tint res=1;\n\tp[y][x]=0;\n\tfor(int i=0;i<4;i++){\n\t\tres += _count(y+dy[i],x+dx[i],c);\n\t}\n\treturn res;\n}\nbool f(int y,int x,int from,int c,bool visit[8][8]){\n\tif(!in(y,x))return false;\n\tif(visit[y][x])return false;\n\tif(c==p[y][x])return true;\n\tif(from!=p[y][x])return false;\n\tvisit[y][x]=true;\n\tfor(int i=0;i<4;i++){\n\t\tif(f(y+dy[i],x+dx[i],from,c,visit))return true;\n\t}\n\treturn false;\n}\nbool neighbor(int c){\n\tbool visit[8][8];\n\tmemset(visit,false,sizeof(visit));\n\treturn f(0,0,p[0][0],c,visit);\n}\nvoid change(int from,int to,int y,int x){\n\tif(!in(y,x))return;\n\tif(from!=p[y][x])return;\n\tp[y][x]=to;\n\tfor(int i=0;i<4;i++){\n\t\tchange(from,to,y+dy[i],x+dx[i]);\n\t}\n}\nint dfs(int depth){//print(depth);\n\tint res=0;\n\tif(depth==4){\n\t\tif(p[0][0]!=c)change(p[0][0],c,0,0);\n\t\treturn _count(0,0,c);\n\t}\n\tif(all())return h*w;\n\tint temp[8][8];\n\tfor(int i=1;i<=6;i++){\n\t\tif(!neighbor(i) || p[0][0]==i)continue;\n\t\tmemcpy(temp,p,sizeof(temp));\n\t\tchange(p[0][0],i,0,0);\n\t\tres = max(res,dfs(depth+1));\n\t\tmemcpy(p,temp,sizeof(temp));\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>h>>w>>c,h|w|c){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)cin>>p[i][j];\n\t\tcout<<dfs(0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n#define FOR(i, s, e) for (ll(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (ll(i) = (s); (i) > (e); (i)--)\n#define debug(x) cout << #x << \": \" << x << endl\n#define mp make_pair\n#define pb push_back\nconst ll MOD = 1000000007;\nconst int INF = 1e9;\nconst ll LINF = 1e16;\nconst double PI = acos(-1.0);\nint dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n \n/* -----  xtimex  Problem: ICPC2012?\\??????\\??????????????????C / Link:   ----- */\n/* ------?\\??¢????????------\n \n \n \n-----?\\??¢?????????£??????£??????£?????£???§----- */\n/* -----?¨?§?£?¨???¬?§????°-----\n \n \n \n----?¨?§?£?¨???¬?£??????£??????£?????£???§---- */\n \nll N;\n \nll ans = 0LL;\n \nint h, w, c;\n \nvoid pro(int n, vector<vector<int>>& temp) {\n    queue<pair<int, int>> q;\n    q.push({ 1, 1 });\n    int key = temp[1][1];\n    temp[1][1] = n;\n    bool usage[10][10] = { false };\n    usage[1][1] = true;\n \n    while (!q.empty()) {\n        auto now = q.front(); q.pop();\n        int x = now.first, y = now.second;\n        for (int i = 0; i < 4; i++) {\n            if (temp[x + dx[i]][y + dy[i]] == key) {\n                if (usage[x + dx[i]][y + dy[i]] == true) continue;\n                temp[x + dx[i]][y + dy[i]] = n;\n                q.push({ x + dx[i], y + dy[i] });\n                usage[x + dx[i]][y + dy[i]] = true;\n            }\n        }\n    }\n}\n \nvoid Count(vector<vector<int>>& temp) {\n    queue<pair<int, int>> q;\n    q.push({ 1, 1 });\n    bool usage[10][10] = { false };\n    usage[1][1] = true;\n \n    ll counta = 1;\n \n    //for (int i = 1; i <= h; i++) {\n    //  for (int j = 1; j <= w; j++) {\n    //      cout << temp[i][j] << \" \";\n    //  }\n    //  cout << endl;\n    //}\n    //cout << endl;\n \n \n    while (!q.empty()) {\n        auto now = q.front(); q.pop();\n        int x = now.first, y = now.second;\n        for (int i = 0; i < 4; i++) {\n            if (temp[x + dx[i]][y + dy[i]] == c) {\n                if (usage[x + dx[i]][y + dy[i]] == true) continue;\n                counta++;\n                q.push({ x + dx[i], y + dy[i] });\n                usage[x + dx[i]][y + dy[i]] = true;\n            }\n        }\n    }\n \n    ans = max(ans, counta);\n}\n \nvoid dfs(int n,vector<vector<int>>p) {\n    if (n == 5) {\n        Count(p);\n        return;\n    }\n \n    if (n == 4) {\n        auto temp = p;\n        pro(c, temp);\n        dfs(n + 1, temp);\n        return;\n    }\n    for (int i = 1; i <= 6; i++) {\n        auto temp = p;\n        pro(i, temp);\n \n        /*if (n == 1) {\n            for (int i = 1; i <= h; i++) {\n                for (int j = 1; j <= w; j++) {\n                    cout << temp[i][j] << \" \";\n                }\n                cout << endl;\n            }\n            cout << endl;\n        }*/\n \n        dfs(n + 1, temp);\n    }\n}\n \nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  while (true) {\n      cin >> h >> w >> c;\n      if (h == 0 && w == 0 && c == 0) break;\n      ans = 0;\n      vector<vector<int>> p(h + 2, vector<int>(w + 2, -1));\n \n      for (int i = 1; i <= h; i++) for (int j = 1; j <= w; j++) cin >> p[i][j];\n \n      /*for (int i = 1; i <= h; i++) {\n          for (int j = 1; j <= w; j++) {\n              cout << p[i][j] << \" \";\n          }\n          cout << endl;\n      }*/\n \n \n      dfs(0, p);\n \n      cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint h, w, c;\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < h && j < w;\n}\n\nvoid show(mat& a)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < a[i].size(); j++){\n\t\t\tprintf(\"%d \", a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n\nbool vis[8][8];\nint search(int d, mat panel)\n{\n\t//printf(\":  %d\\n\", d);\n\t//show(panel);\n\t\n\tif (d == 0){\n\t\tif (panel[0][0] != c) return 0;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvis[0][0] = true;\n\t\tqueue<int> que;\n\t\tque.push(0);\n\t\tque.push(0);\n\t\tint res = 1;\n\t\twhile (que.size()){\n\t\t\tint x = que.front(); que.pop();\n\t\t\tint y = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\tif (vis[nx][ny]) continue;\n\t\t\t\tif (panel[nx][ny] != c) continue;\n\t\t\t\tque.push(nx);\n\t\t\t\tque.push(ny);\n\t\t\t\tvis[nx][ny] = true;\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 1; i <= 6; i++){\n\t\tmat tp = panel;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvis[0][0] = true;\n\t\tqueue<int> que;\n\t\tque.push(0);\n\t\tque.push(0);\n\t\twhile (que.size()){\n\t\t\tint x = que.front(); que.pop();\n\t\t\tint y = que.front(); que.pop();\n\t\t\ttp[x][y] = i;\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[dir];\n\t\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t\tif (vis[nx][ny]) continue;\n\t\t\t\tif (panel[nx][ny] != panel[0][0]) continue;\n\t\t\t\tque.push(nx);\n\t\t\t\tque.push(ny);\n\t\t\t\tvis[nx][ny] = true;\n\t\t\t}\n\t\t}\n\t\tres = max(res, search(d - 1, tp));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d %d\", &h, &w, &c), h){\n\t\tmat panel(h, vec(w));\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &panel[i][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", search(5, panel));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\ntypedef struct a\n{\n\tint x; \n\tint y;\n}coordin;\n\nint h,w,c;\nint res = 0;\nint maze [8][8];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid changeColor(int tmp[8][8],int color)\n{\n\tint originColor = tmp[0][0];\n\tqueue <coordin> q;\n\tcoordin cc;\n\tcc.x = 0; cc.y = 0;\n\n\tq.push(cc);\n\ttmp[0][0] = color;\n\t\n\twhile (!q.empty())\n\t{\n\t\tcc = q.front();\n\t\tq.pop();\n\n\t\tfor (int i=0;i<4;++i)\n\t\t{\n\t\t\tint tmp_x = cc.x + dx[i];\n\t\t\tint tmp_y = cc.y + dy[i];\n\t\t\t\n\t\t\tif (0<= tmp_x && tmp_x < w && 0<= tmp_y && tmp_y < h)\n\t\t\t{\n\t\t\t\tif (tmp[tmp_x][tmp_y] == originColor)\n\t\t\t\t{\t\n\t\t\t\t\tcoordin tmp_cc;\n\t\t\t\t\ttmp_cc.x = tmp_x;\n\t\t\t\t\ttmp_cc.y = tmp_y;\n\t\t\t\t\tif (color != originColor) q.push(tmp_cc);\n\t\t\t\t\ttmp[tmp_x][tmp_y] = color;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n\t\n}\n\nint cnt(int m[8][8], int x, int y)\n{\n    int count=1;\n    int oc = m[x][y];\n    m[x][y] = 0;\n    for(int i=0; i<4; i++)\n    {\n        int tmp_x = x+dx[i];\n        int tmp_y = y+dy[i];\n        if(0<=tmp_x && tmp_x<w && 0<=tmp_y && tmp_y<h)\n        {\n            if(m[tmp_x][tmp_y]==oc) count+=cnt(m, tmp_x, tmp_y);\n        }\n    }\n    return count;\n}\n\nint dfs(int m[8][8],int depth)\n{\n\tif (depth == 4)\n\t{\n\t\tif(m[0][0]!=c) changeColor(m,c);\n\t\treturn cnt(m,0,0);\n\t}\n\t\n\tfor (int i=1;i<=6;++i)\n\t{\n\t\tint tmp_m[8][8];\n\t\tmemcpy(tmp_m,m,sizeof(tmp_m));\n\t\t\n\t\tif (tmp_m[0][0] != i) changeColor(tmp_m,i);\n\t\tres = max(res,dfs(tmp_m,depth+1));\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tcin>>h>>w>>c;\n\t\n\twhile (h!=0)\n\t{\n\t\tfor (int i=0;i<h;++i)\n\t\t\tfor (int j=0;j<w;++j)\n\t\t\t\tcin>>maze[j][i];\n\t\t\n\t\tcout<<dfs(maze,0)<<endl;\n\t\tres = 0;\n\t\tcin>>h>>w>>c;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstdlib>\n#define _A_ true\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 10\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,c;\nint p[MAX][MAX];\nint Ans;\n\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\n\nvoid Display(){\n  rep(i,h){\n    rep(j,w){\n      printf(\"%d \",p[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\nvoid ColorCount(){\n  queue<P> CQ;\n  CQ.push(P(0,0));\n  bool used[h][w];\n  rep(i,h)rep(j,w)used[i][j] = false;\n  used[0][0] = true;\n  int count = 1;\n  //Display();\n\n  while(CQ.size()){\n    P pi = CQ.front(); CQ.pop();\n\n    rep(i,4){\n      int nx = pi.first + dx[i], ny = pi.second + dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && !used[ny][nx] && p[ny][nx] == c){\n      count++;\t\n      CQ.push(P(nx,ny));\n      used[ny][nx] = true;    \n      }\n      \n    }\n    \n  }\n  //cout << \"Color = \" << count << endl;\n  Ans = max(Ans,count);\n\n}\n\n\n\nvoid FiveRec(){\n  //cout << \"In\" << endl;\n  queue<P> que;\n  bool used[h][w];\n  rep(i,h)rep(j,w)used[i][j] = false;\n  //bool pre\n  que.push(P(0,0));\n  used[0][0] = true;\n  int ThisColor = p[0][0];\n  p[0][0] = c;\n\n  while(que.size()){\n    P pi = que.front(); que.pop();\n    //cout << \"pi.first = \" << pi.first << \", pi.second = \" << pi.second << endl;\n    rep(i,4){\n      int nx = pi.first + dx[i],ny = pi.second + dy[i];   \n      if(0<= nx && nx < w && 0<= ny && ny < h && !used[ny][nx] &&  p[ny][nx] == ThisColor){       \n\t//cout << \"In \" << endl; \n\tque.push(P(nx,ny));\n\t//cout << \"w = \" << w << \", h = \" << h << endl;\n\tp[ny][nx] = c;\n\tused[ny][nx] = true;\n      }\n    }\n  }\n  //cout << \"Five Fin \" << endl;\n}\n\n\nvoid rec(int color,int count){\n  //cout << \"count = \" << count << endl;\n  if(count == 5){\n    //printf(\"Five Count --------------\\n\");\n    FiveRec();\n    //Display();\n    ColorCount();\n    //printf(\"Fin Five Count ---------- %d\\n\",Ans);\n    return;\n  }\n\n  //cout << \"normal disp --------\" << endl;\n  //Display();\n  //cout << \"FF----------------FF\" << endl;\n  queue<P> que;\n  bool used[h][w];\n  rep(i,h)rep(j,w)used[i][j] = false;\n \n  int ThisColor = p[0][0];\n  int pb[h][w];\n  rep(i,h)rep(j,w)pb[i][j] = p[i][j];\n  que.push(P(0,0));\n  used[0][0] = true;\n  p[0][0] = color;\n\n\n  while(que.size()){\n    P pi = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = pi.first + dx[i],ny = pi.second + dy[i];   \n      if(0<= nx && nx < w && 0<= ny && ny < h && !used[ny][nx] &&  p[ny][nx] == ThisColor){ \n\tque.push(P(nx,ny));\n\tp[ny][nx] = color;\n\tused[ny][nx] = true;\n      }\n    }\n  }\n\n\n  //koko ra hennde syuukei siteha douda roka\n  REP(i,1,7){\n    //if(i != color)\n    rec(i,count+1);\n  }\n  //printf(\"-----------------------\\n\");\n  rep(i,h)rep(j,w)p[i][j] = pb[i][j];\n  \n}\n\n\n\nint main(){\n  while(_A_){\n    scanf(\"%d %d %d\",&h,&w,&c);\n    if(!(h|w|c))break;\n    Ans = -1;\n    rep(i,h)rep(j,w)scanf(\"%d\",&p[i][j]);\n    REP(i,1,7){\n      //if(i != p[0][0])\n\trec(i,1);\n    }\n    printf(\"%d\\n\",Ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w, c;\n\nvoid copy_panel(int s[10][10], int d[10][10]) {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            d[i][j] = s[i][j];\n        }\n    }\n}\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid change_color(int p[10][10], int x, int y, int c) {\n    int color = p[x][y];\n    p[x][y] = c;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (p[nx][ny] == color) {\n            change_color(p, nx, ny, c);\n        }\n    }\n}\n\nint count_color(int p[10][10], int x, int y, int c) {\n    p[x][y] = -1;\n    int ans = 1;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (p[nx][ny] == c) {\n            ans += count_color(p, nx, ny, c);\n        }\n    }\n    return ans;\n}\n\nint dfs(int p[10][10], int n) {\n    int ans;\n    int b[10][10];\n\n    if (n == 1) {\n        copy_panel(p, b);\n        if (b[1][1] != c) {\n            change_color(b, 1, 1, c);\n        }\n        ans = count_color(b, 1, 1, c);\n    } else {\n        ans = 0;\n        for (int i = 1; i <= 6; i++) {\n            copy_panel(p, b);\n            if (b[1][1] != i) {\n                change_color(b, 1, 1, i);\n            }\n            ans = max(ans, dfs(b, n - 1));\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    int P[10][10];\n\n    for (;;) {\n        scanf(\"%d%d%d\", &h, &w, &c);\n        if (!h && !w && !c) { break; }\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                P[i][j] = 0;\n            }\n        }\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                scanf(\"%d\", &P[i][j]);\n            }\n        }\n\n        printf(\"%d\\n\", dfs(P, 5));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint h, w, c, in[8][8];\nbool v[8][8];\n\nint dfs(int y, int x, int col){\n\tint prev = in[y][x], res = 1;\n\tv[y][x] = 1;\n\tif(col > 0) in[y][x] = col;\n\trep(d, 4){\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w || v[ny][nx]) continue;\n\t\tif(in[ny][nx] == prev) res += dfs(ny, nx, col);\n\t}\n\treturn res;\n}\n\nint rec(int cnt){\n\tif(cnt == 0){\n\t\tmemset(v, 0, sizeof(v));\n\t\treturn dfs(0, 0, -1);\n\t}\n\tint res = 0, prev;\n\tmemset(v, 0, sizeof(v));\n\tif(in[0][0] == c) res = prev = dfs(0, 0, -1);\n\t\n\trep(i, 6) if(in[0][0] != i + 1){\n\t\tif(cnt == 1 && i + 1 != c) continue;\n\t\t\n\t\tint tmp[8][8];\n\t\tmemset(v, 0, sizeof(v));\n\t\tmemcpy(tmp, in, sizeof(in));\n\t\tdfs(0, 0, i + 1);\n\t\tres = max(res, rec(cnt - 1));\n\t\tmemcpy(in, tmp, sizeof(in));\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> h >> w >> c, h){\n\t\trep(i, h) rep(j, w) cin >> in[i][j];\n\t\tcout << rec(5) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nint h,w,c,ans;\nint t[10][10];\n\nvoid check(){\n  int cnt=0,flg[10][10];\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)flg[i][j]=false;\n  queue<int> qy,qx;\n  qy.push(0);qx.push(0);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if(y<0||x<0)continue;\n    if(y>=h||x>=w)continue;\n    if(flg[y][x])continue;\n    if(t[y][x]!=c)continue;\n    cnt++;\n    flg[y][x]=true;\n    for(int i=0;i<4;i++)qy.push(y+dy[i]),qx.push(x+dx[i]);\n  }\n  ans=max(ans,cnt);\n}\n\nvoid solve(int depth){\n  if(depth==5)check();\n  else{\n\n    int flg[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)flg[i][j]=0;\n    queue<int> qy,qx;\n    qy.push(0);qx.push(0);\n    while(!qy.empty()){\n      int y=qy.front();qy.pop();\n      int x=qx.front();qx.pop();\n      if(y<0||x<0)continue;\n      if(y>=h||x>=w)continue;\n      if(flg[y][x]!=0)continue;\n      if(t[y][x]!=t[0][0])continue;\n      flg[y][x]=t[y][x];\n      for(int i=0;i<4;i++)qy.push(y+dy[i]),qx.push(x+dx[i]);\n    }\n    for(int I=1;I<=6;I++){\n      if(I==flg[0][0])continue;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  if(flg[i][j]!=0)t[i][j]=I;\n      solve(depth+1);\n    }\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(flg[i][j]!=0)t[i][j]=flg[i][j];\n  }\n}\nint main(){\n  while(1){\n    cin>>h>>w>>c;\n    if(h==0&&w==0&&c==0)break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>t[i][j];\n    ans=0;\n    solve(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint g[8][8];\nint h,w,c;\nbool used[8][8];\nconst int dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint dfs(int cnt,int tg[8][8]){\n    int ret=0;\n    if(cnt==5){\n        int mx=0;\n        memset(used,0,sizeof(used));\n        rep(i,h)rep(j,w)if(!used[i][j]&&tg[i][j]==c){\n            int cnt=0;\n            queue<pint> q;\n            q.push({j,i});\n            used[j][i]=true;\n            while(!q.empty()){\n                pint pi=q.front();q.pop();\n                ++cnt;\n                rep(k,4){\n                    int tx=pi.first+dx[k],ty=pi.second+dy[k];\n                    if(tx>=0&&ty>=0&&tx<w&&ty<h&&tg[ty][tx]==c&&!used[ty][tx]){\n                        q.push({tx,ty});\n                        used[ty][tx]=true;\n                    }\n                }\n            }\n            mx=max(mx,cnt);\n        }\n        return mx;\n    }\n    else{\n        rep(i,6){\n            if(tg[0][0]==i) continue;\n            int cc=tg[0][0];\n            int ttg[8][8];\n            rep(j,h)rep(k,w) ttg[j][k]=tg[j][k];\n            memset(used,0,sizeof(used));\n            queue<pint> q;\n            q.push({0,0});\n            used[0][0]=true;\n            while(!q.empty()){\n                pint pi=q.front();q.pop();\n                ttg[pi.second][pi.first]=i;\n                rep(j,4){\n                    int tx=pi.first+dx[j],ty=pi.second+dy[j];\n                    if(tx>=0&&ty>=0&&tx<w&&ty<h&&tg[ty][tx]==cc&&!used[ty][tx]){\n                        q.push({tx,ty});\n                        used[ty][tx]=true;\n                    }\n                }\n            }\n            ret=max(ret,dfs(cnt+1,ttg));\n        }    \n    }\n    return ret;\n}\nint main(){\n    while(cin>>h>>w>>c,h){\n        --c;\n        rep(i,h)rep(j,w) cin>>g[i][j],--g[i][j];\n        cout<<dfs(0,g)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nstruct status{\n\tint count, to;\n\tint p[10][10];\n\tstatus(){\n\t\tcount = 0;\n\t\tto = 1;\n\t\tfill(p[0], p[0]+10*10, 0);\n\t}\n};\n\nint main(){\n\tint h, w, c;\n\twhile(cin>>h>>w>>c, h|w|c){\n\t\tstack<status> st;\n\t\tstatus in;\n\t\tint ans = 0;\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> in.p[i][j];\n\t\t\t}\n\t\t}\n\t\tin.to = in.p[1][1];\n\t\tin.p[1][1] = 8;\n\t\tst.push( in );\n\t\twhile( !st.empty() ){\n\t\t\tstatus s = st.top();\n\t\t\tst.pop();\n\t\t\t// to??????????????´\n\t\t\tstack< P > check;\n\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif( s.p[i][j] == 8 )\n\t\t\t\t\t\tcheck.push( make_pair(i, j) );\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile( !check.empty() ){\t// ?????????\n\t\t\t\tP p = check.top(); check.pop();\n\t\t\t\tint y = p.first, x = p.second;\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tif( s.p[ y+vy[k] ][ x+vx[k] ] == s.to ){\n\t\t\t\t\t\ts.p[ y+vy[k] ][ x+vx[k] ] = 8;\n\t\t\t\t\t\tcheck.push( make_pair( y+vy[k], x+vx[k] ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( s.count == 5 ){\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\t\tif( s.p[i][j] == 8 )\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max( ans, sum );\n\t\t\t}else if( s.count == 4 ){\n\t\t\t\ts.count++;\n\t\t\t\ts.to = c;\n\t\t\t\tst.push( s );\n\t\t\t}else{\n\t\t\t\ts.count++;\n\t\t\t\tfor(int i=1; i<=6; i++){\n\t\t\t\t\tif( i != s.to ){\n\t\t\t\t\t\tstatus sn = s;\n\t\t\t\t\t\tsn.to = i;\n\t\t\t\t\t\tst.push( sn );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\n#define max(a,b)(a>b?a:b)\n\nstruct POINT{\n\tint x;\n\tint y;\n\tint c;\n\tPOINT(int X,int Y,int C){\n\t\tx = X;y = Y;c=C;\n\t}\n};\n\nstack<POINT> st;\n\nint h,w,c;\nint panel[8][8][2]={0};\nint ans=0;\n\n\n\nvoid show(int ans){\n\tcout << \"--- panel contents\"<<endl;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcout << panel[i][j][0] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout<< \"--- count = \"<< ans<< endl<<endl;\n}\n\nvoid change(int c){\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tif(panel[i][j][1])\n\t\t\t\tpanel[i][j][0]=c;\n}\n\nint countPanel(){\n\tint count=0;\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tif(panel[i][j][1])\n\t\t\t\tcount++;\n\treturn count;\n}\n\nvoid push(POINT pt,int dp){\n\tpanel[pt.y][pt.x][1]=dp;\n\tif(pt.x>0&&panel[pt.y][pt.x-1][1]!=dp&&panel[pt.y][pt.x-1][0]==pt.c){\n\t\tst.push(POINT(pt.x-1,pt.y,panel[pt.y][pt.x-1][0]));\n\t}\n\tif(pt.x<w-1&&panel[pt.y][pt.x+1][1]!=dp&&panel[pt.y][pt.x+1][0]==pt.c){\n\t\tst.push(POINT(pt.x+1,pt.y,panel[pt.y][pt.x+1][0]));\n\t}\n\tif(pt.y>0&&panel[pt.y-1][pt.x][1]!=dp&&panel[pt.y-1][pt.x][0]==pt.c){\n\t\tst.push(POINT(pt.x,pt.y-1,panel[pt.y-1][pt.x][0]));\n\t}\n\tif(pt.y<h-1&&panel[pt.y+1][pt.x][1]!=dp&&panel[pt.y+1][pt.x][0]==pt.c){\n\t\tst.push(POINT(pt.x,pt.y+1,panel[pt.y+1][pt.x][0]));\n\t}\n\tif(!st.empty()){\n\t\tPOINT t_st=st.top();\n\t\tst.pop();\n\t\tpush(t_st,dp);\n\t}\n}\n\n\nvoid depth(int dp){\n\n\tif(dp==5){\n\t\tpush(POINT(0,0,panel[0][0][0]),dp+1);\n\t\tans=max(ans,countPanel());\n\t}\n\telse{\n\t\t//状態を保存\n\t\tint tmp[8][8][2]={0};\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\ttmp[i][j][0]=panel[i][j][0];\n\t\t\t\ttmp[i][j][1]=panel[i][j][1];\n\t\t\t}\n\t\t}\n\n\t\tif(dp==4){\n\t\t\t//同色を結合\n\t\t\tpush(POINT(0,0,panel[0][0][0]),dp+1);\n\t\t\tchange(c);\n\t\t\t//再帰\n\t\t\tdepth(dp+1);\n\t\t\t//状態を戻す\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[i][j][0]=tmp[i][j][0];\n\t\t\t\t\tpanel[i][j][1]=tmp[i][j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\t//全色色を変えていく\n\t\t\tfor(int i=1;i<=6;i++){\n\t\t\t\t//同色を結合\n\t\t\t\tpush(POINT(0,0,panel[0][0][0]),dp+1);\n\t\t\t\tchange(i);\n\t\t\t\t//再帰\n\t\t\t\tdepth(dp+1);\n\t\t\t\t//状態を戻す\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tpanel[i][j][0]=tmp[i][j][0];\n\t\t\t\t\t\tpanel[i][j][1]=tmp[i][j][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nint main(void){\n\n\twhile(1){\n\n\t\tans=0;\n\t\tcin >> h>>w>>c;\n\n\t\tif(!h&&!w&&!c)\n\t\t\tbreak;\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> panel[i][j][0];\n\t\t\t}\n\t\t}\n\n\t\tdepth(0);\n\n\t\tcout << ans <<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int>  P;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint h, w, c;\n\nvoid Debug(const vector<vector<int>> &b)\n{\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n            cout << b[i][j] << \" \";\n        cout << \"\\n\";\n    }\n}\n\n\nvoid Bfs(int cc, vector<vector<int>> &panel)\n{\n    vector<vector<bool>> visit(h, vector<bool>(w, false));\n\n    int bf = panel[0][0];\n    visit[0][0] = true;\n    queue<P> que;\n    que.push(make_pair(0, 0));\n\n\n    while (!que.empty()) {\n        P now = que.front();  que.pop();\n        panel[now.second][now.first] = cc;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = now.first + dx[i];\n            int ny = now.second + dy[i];\n\n            if (nx < 0 || ny < 0 || nx >= w || ny >= h)\n                continue;\n            if (!visit[ny][nx] && panel[ny][nx] == bf) {\n                que.push(make_pair(nx, ny));\n                visit[ny][nx] = true;\n            }\n        }\n    }\n}\n\nint Count(const vector<vector<int>> &panel)\n{\n    vector<vector<bool>> visit(h, vector<bool>(w, false));\n\n    int cc = panel[0][0], res = 0;\n    visit[0][0] = true;\n    queue<P> que;\n    que.push(make_pair(0, 0));\n\n    while (!que.empty()) {\n        P now = que.front();  que.pop();\n        ++res;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = now.first + dx[i];\n            int ny = now.second + dy[i];\n\n            if (nx < 0 || ny < 0 || nx >= w || ny >= h)\n                continue;\n            if (!visit[ny][nx] && panel[ny][nx] == cc) {\n                que.push(make_pair(nx, ny));\n                visit[ny][nx] = true;\n            }\n        }\n    }\n\n    return res;\n}\n\nint Dfs(int cc, int cnt, vector<vector<int>> panel)\n{\n    if (cnt == 4 && panel[0][0] != c) {\n        Bfs(c, panel);\n        return Count(panel);\n    }\n    else if (cnt == 4)\n        return 0;\n\n    Bfs(cc, panel);\n    int res = 0;\n    for (int i = 1; i <= 6; ++i) {\n        if (panel[0][0] == i)\n            continue;\n        res = max(res, Dfs(i, cnt + 1, panel));\n    }\n\n    return res;\n}\n\nint main()\n{\n    while (cin >> h >> w >> c, h || w || c) {\n        vector<vector<int>> panel(h, vector<int>(w));\n\n        for (int i = 0; i < h; ++i)\n            for (int j = 0; j < w; ++j)\n                cin >> panel[i][j];\n\n        int res = 0;\n        for (int i = 1; i <= 6; ++i) {\n            if (panel[0][0] == i)\n                continue;\n            res = max(res, Dfs(i, 0, panel));\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint colorflag[5][6];\n\nvoid selectcolor(int panel[8][8],int flag[8][8],int h,int w,int count){\n\tint i, j;\n\tfor(i = 0;i < 6;i++)\n\t\tcolorflag[count][i] = 0;\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++){\n\t\t\tif(flag[i][j] == 1){\n\t\t\t\tif(i - 1 >= 0 && flag[i - 1][j] != 1) // 上\n\t\t\t\t\tcolorflag[count][panel[i - 1][j] - 1] = 1;\n\n\t\t\t\tif(i + 1 < h && flag[i + 1][j] != 1) // 下\n\t\t\t\t\tcolorflag[count][panel[i + 1][j] - 1] = 1;\n\n\t\t\t\tif(j - 1 >= 0 && flag[i][j - 1] != 1) // 左\n\t\t\t\t\tcolorflag[count][panel[i][j - 1] - 1] = 1;\n\n\t\t\t\tif(j + 1 < w && flag[i][j + 1] != 1) // 右\n\t\t\t\t\tcolorflag[count][panel[i][j + 1] - 1] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid combine(int panel[8][8],int flag[8][8],int h,int w,int n,int count){\n\tint i, j;\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++){\n\t\t\tif(flag[i][j] == 1)\n\t\t\t\tpanel[i][j] = n;\n\t\t}\n\t}\n\tselectcolor(panel,flag,h,w,count);\n\twhile(colorflag[count][n - 1] == 1){\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tif(flag[i][j] == 1){\n\t\t\t\t\tif(i - 1 >= 0 && panel[i - 1][j] == n) //上\n\t\t\t\t\t\tflag[i - 1][j] = 1;\n\n\t\t\t\t\tif(i + 1 < h && panel[i + 1][j] == n) //下\n\t\t\t\t\t\tflag[i + 1][j] = 1;\n\n\t\t\t\t\tif(j - 1 >= 0 && panel[i][j - 1] == n) //左\n\t\t\t\t\t\tflag[i][j - 1] = 1;\n\n\t\t\t\t\tif(j + 1 < w && panel[i][j + 1] == n) //右\n\t\t\t\t\t\tflag[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tselectcolor(panel,flag,h,w,count);\n\t}\n}\n\nint tmppanel[5][8][8], tmpflag[5][8][8];\nvoid sub(int panel[8][8],int flag[8][8],int h,int w,int c,int count,int *max){\n\tint i, j, k, fcount;\n\tif(count < 4){\n\t\tselectcolor(panel,flag,h,w,count);\n\t\tfor(i = 0;i < 6 && !colorflag[count][i];i++);\n\t\tif(i == 6){//　もし同じ色に染まったら\n\t\t\t*max = h * w;\n\t\t\treturn;\n\t\t}\n\t\tfor(i = 0;i < 6;i++){\n\t\t\tif(colorflag[count][i] == 1){\n\t\t\t\tfor(j = 0;j < h;j++){\n\t\t\t\t\tfor(k = 0;k < w;k++){\n\t\t\t\t\t\ttmppanel[count][j][k] = panel[j][k];\n\t\t\t\t\t\ttmpflag[count][j][k] = flag[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcombine(tmppanel[count],tmpflag[count],h,w,i + 1,count);\n\t\t\t\tsub(tmppanel[count],tmpflag[count],h,w,c,count + 1,max);\n\t\t\t}\n\t\t}\n\t}\n\telse if(count == 4){\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\ttmppanel[count][i][j] = panel[i][j];\n\t\t\t\ttmpflag[count][i][j] = flag[i][j];\n\t\t\t}\n\t\t}\n\t\tcombine(tmppanel[count],tmpflag[count],h,w,c,count); // 結合する\n\t\tsub(tmppanel[count],tmpflag[count],h,w,c,count + 1,max);\n\t\t\n\t}\n\telse{\n\t\tfcount = 0;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tif(flag[i][j] == 1)\n\t\t\t\t\tfcount++;\n\t\t\t}\n\t\t}\n\t\tif(*max < fcount)\n\t\t\t*max = fcount;\n\t}\n}\n\nint main(void){\n\tint h, w, c, i, j, max = 0x80000000;\n\tint panel[8][8], flag[8][8];\n\tscanf(\"%d%d%d\",&h,&w,&c);\n\twhile(h != 0 || w != 0 || c != 0){\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tflag[i][j] = 0;\n\t\t\t\tscanf(\"%d\",&panel[i][j]);\n\t\t\t}\n\t\t}\n\t\tflag[0][0] = 1;\n\t\tcombine(panel,flag,h,w,panel[0][0],0);\n\t\tsub(panel,flag,h,w,c,0,&max);\n\t\tprintf(\"%d\\n\",max);\n\t\tmax = 0x80000000;\n\t\tscanf(\"%d%d%d\",&h,&w,&c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e9;\nconst double ESP=1e-5;\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\nusing Graph=vector<vector<int>>;\nint h,w,c;\nGraph mp(h,vector<int> (w,0));\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ans;\n\nvoid change(int y,int x,int col,int pre){\n  if(col==pre)return;\n  mp[y][x]=col;\n  rep(i,4){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(0<=nx&&nx<w&&0<=ny&&ny<h&&mp[ny][nx]==pre){\n      change(ny,nx,col,pre);\n    }\n  }\n  return;\n}\nvoid f(int cnt){\n  if(cnt==4){\n    change(0,0,c,mp[0][0]);\n    change(0,0,INF,mp[0][0]);\n    int tmp=0;\n    rep(i,mp.size())rep(j,mp[i].size())if(mp[i][j]==INF)tmp++;\n    cmax(ans,tmp);\n  }else{\n    loop(i,1,7){\n      Graph tmp=mp;\n      change(0,0,i,mp[0][0]);\n      f(cnt+1);\n      mp=tmp;\n    }\n  }\n}\n\nsigned main(){\n  while(cin>>h>>w>>c){\n    if(h==0&&w==0&&c==0)break;\n    mp=vector<vector<int>> (h,vector<int> (w,0));\n    rep(i,h)rep(j,w)cin>>mp[i][j];\n    ans=0;\n    f(0);\n    cout<<ans<<endl;\n  }\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W, C, ans, cnt;\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\nbool used[8][8];\ntypedef pair<int,int> P;\n\nbool inField(int y, int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid color_count(vector<vector<int> > &vec, int y, int x){\n  if(used[y][x]) return;\n  used[y][x] = true;\n  if(vec[y][x] == C){\n    cnt++;\n  }\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(!inField(ny, nx)) continue;\n    if(vec[ny][nx] != C) continue;\n    color_count(vec, ny, nx);\n  }\n}\n\nvector<P> pos;\nvoid color_change(int y, int x, int c1, int c2, \n                  bool flg, vector<vector<int> > &vec){\n  if(used[y][x]) return;\n  used[y][x] = true;\n  pos.push_back(P(y,x));\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(!inField(ny, nx)) continue;\n    if(vec[ny][nx] != c1 && vec[ny][nx] != c2) continue;\n    if(vec[y][x] != vec[ny][nx] && !flg){\n      flg = true;\n      color_change(ny, nx, c1, c2, flg, vec);\n    }else{\n      if(flg){\n        if(vec[y][x] != vec[ny][nx]) continue;\n        color_change(ny, nx, c1, c2, flg, vec);\n      }else{\n        color_change(ny, nx, c1, c2, flg, vec);\n      }\n    }\n  }\n}\n\nvoid solve(vector<vector<int> > &vec, int rem){\n  if(rem == 0){\n    memset(used, false, sizeof(used));\n    cnt = 0;\n    color_count(vec, 0, 0);\n    ans = max(ans, cnt);\n    return;\n  }\n  \n  for(int i = 0 ; i < 6 ; i++){\n    vector<vector<int> > next = vec;\n    pos.clear();\n    memset(used, false, sizeof(used));\n    color_change(0, 0, i+1, vec[0][0], false, vec);\n    for(int j = 0 ; j < pos.size() ; j++){\n      P p = pos[j];\n      next[p.first][p.second] = i+1;\n    }\n    solve(next, rem-1);\n  }\n}\n\nint main(){\n  while(cin >> H >> W >> C , (H | W | C)){\n    vector<vector<int> > vec(H, vector<int>(W));\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> vec[i][j];\n      }\n    }\n    ans = 0;\n    solve(vec, 5);   \n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nclass Point{\npublic:\n    int y, x;\n    Point(){}\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n};\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint solve(int n, vector<vector<int> >& panel0, int last)\n{\n    if(n == 0 && last != panel0[0][0])\n        return 0;\n\n    int h = panel0.size();\n    int w = panel0[0].size();\n    int color = panel0[0][0];\n\n    int ret = 1;\n    for(int i=1; i<=6; ++i){\n        if(panel0[0][0] == i)\n            continue;\n\n        vector<vector<int> > panel = panel0;\n        queue<Point> q;\n        q.push(Point(0, 0));\n        panel[0][0] = i;\n\n        int tmp = 1;\n        while(!q.empty()){\n            Point p = q.front();\n            q.pop();\n            for(int j=0; j<4; ++j){\n                int y = p.y + dy[j];\n                int x = p.x + dx[j];\n                if(y < 0 || y >= h || x < 0 || x >= w)\n                    continue;\n                if(panel[y][x] == color){\n                    panel[y][x] = i;\n                    q.push(Point(y, x));\n                    ++ tmp;\n                }\n            }\n        }\n\n        if(n == 0)\n            return tmp;\n        ret = max(ret, solve(n-1, panel, last));\n    }\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int h, w, c;\n        cin >> h >> w >> c;\n        if(h == 0)\n            return 0;\n\n        vector<vector<int> > panel(h, vector<int>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> panel[i][j];\n            }\n        }\n\n        cout << solve(5, panel, c) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n// >>> union find\nstruct UnionFind {\n    int n, sz; // id : 0...n-1\n    vector<int> par;\n\n    UnionFind(int n = 0) : n(n), sz(n), par(n,-1) { }\n    int root(int x) {\n        assert(0 <= x); assert(x < n);\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x == y) return false;\n        sz--;\n        if (par[x] < par[y]) swap(x,y);\n        par[y] += par[x];\n        par[x] = y;\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -par[root(x)]; }\n    int size() const { return sz; }\n    struct groups_t {\n        vector<vector<int> > grp;\n        vector<pair<int,int> > id;\n    };\n    groups_t groups() {\n        vector<vector<int> > g(n);\n        rep (i,n) if (par[i] < 0) g[i].reserve(-par[i]);\n        rep (i,n) g[root(i)].push_back(i);\n        vector<vector<int> > grp; grp.reserve(size());\n        rep (i,n) if (g[i].size()) grp.emplace_back(move(g[i]));\n        vector<pair<int,int> > id(n);\n        rep (i,grp.size()) rep (j,grp[i].size()) {\n            id[grp[i][j]] = make_pair(i,j);\n        }\n        return { grp, id };\n    }\n};\n// <<<\nbool next_product(vector<int> &v, int m) {\n    repR (i,v.size()) {\n        if (++v[i] < m) return true;\n        v[i] = 0;\n    }\n    return false;\n}\n\nint32_t main() {\n    while (true) {\n        int n,m,c; cin >> n >> m >> c; --c;\n        if (n == 0 && m == 0) break;\n        auto p = make_v<int,2>(n,m);\n        rep (i,n) rep (j,m) cin >> p[i][j], --p[i][j];\n        auto id = [&](int i, int j) { return i*m+j; };\n\n\n        vector<int> a(5);\n        int ans = 0;\n        do {\n            if (a.back() != c) continue;\n            auto q = p;\n            rep (k,sz(a)+1) {\n                UnionFind uf(n*m);\n                rep (i,n) rep (j,m-1) if (q[i][j] == q[i][j+1]) {\n                    uf.unite(id(i,j),id(i,j+1));\n                }\n                rep (i,n-1) rep (j,m) if (q[i][j] == q[i+1][j]) {\n                    uf.unite(id(i,j),id(i+1,j));\n                }\n                if (k < sz(a)) {\n                    rep (i,n) rep (j,m) if (uf.same(id(0,0),id(i,j))) {\n                        q[i][j] = a[k];\n                    }\n            } else {\n                    chmax(ans, uf.size(id(0,0)));\n                }\n            }\n        } while (next_product(a,6));\n\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// repetition\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\n// container util\n#define all(x) (x).begin(), (x).end()\n\n// debug\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x)                                         \\\n  cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" \\\n       << \" \" << __FILE__ << endl;\n\n// typedef\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef complex<long double> Complex;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n// constant\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\n// conversion\ninline int toInt(string s) {\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\n\n//\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n//\n\nstatic const int MAX = 12;\nint h, w, c;\nint G[MAX][MAX], V[MAX][MAX];\nint ans, cnt;\n\nvoid init() {\n  FOR(y, 1, h + 1) FOR(x, 1, w + 1) V[y][x] = 0;\n  cnt = 0;\n}\n\nvoid fillc(int color, int y, int x, int prec) {\n  G[y][x] = V[y][x] = color;\n  cnt++;\n  rep(i, 4) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if (G[ny][nx] == prec && !V[ny][nx]) fillc(color, ny, nx, prec);\n  }\n}\n\nvoid solve(int d) {\n  int tmp[MAX][MAX];\n  if (d == 4) {\n    rep(i, 2) {\n      init();\n      fillc(c, 1, 1, G[1][1]);\n    }\n    ans = max(ans, cnt);\n    return;\n  }\n\n  FOR(i, 1, 7) {\n    FOR(y, 1, h + 1) FOR(x, 1, w + 1) tmp[y][x] = G[y][x];\n    init();\n    fillc(i, 1, 1, G[1][1]);\n    solve(d + 1);\n    FOR(y, 1, h + 1) FOR(x, 1, w + 1) G[y][x] = tmp[y][x];\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  while (true) {\n    cin >> h >> w >> c;\n    if (h == 0 && w == 0 && c == 0) break;\n    rep(y, h + 2) rep(x, w + 2) G[y][x] = 0;\n    rep(y, h) rep(x, w) cin >> G[y + 1][x + 1];\n    ans = 0;\n    solve(0);\n    cout << ans << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <algorithm>\n#include <vector>\n\nconstexpr int NUM = 1 << (3*4);\nint panel[8][8] = {0};\nint w, h, c;\nint dx[] = { 1, 0, -1, 0 }, dy[] = { 0, 1, 0, -1 };\n\nint changeColor(int colors) {\n\tint newPanel[8][8];\n\tint colorCount = 1;\n\tfor (int i = 0; i < h; i++) for (int j = 0; j < w; j++) newPanel[i][j] = panel[i][j];\n\tfor (int i = 0; i < 5; i++) {\n\t\tint color = c;\n\t\tif (i < 4) color = (colors >> (i*3)) & 0b111;\n\t\tif (color < 1 || 6 < color) return 0;\n\t\tint targetColor = newPanel[0][0];\n\t\tnewPanel[0][0] = color;\n\t\t//DFS\n\t\tstd::stack<std::pair<int, int>> s; s.push(std::make_pair(0, 0));\n\t\twhile (!s.empty() && color != targetColor) {\n\t\t\tauto node = s.top(); s.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tnext.first += dx[i]; next.second += dy[i];\n\t\t\t\tif (next.first < 0 || next.first >= w || next.second < 0 || next.second >= h) continue;\n\t\t\t\tif (newPanel[next.second][next.first] != targetColor) continue;\n\t\t\t\tnewPanel[next.second][next.first] = color;\n\t\t\t\ts.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\t//DFS\n\tstd::stack<std::pair<int, int>> s; s.push(std::make_pair(0, 0));\n\tnewPanel[0][0] = 0;\n\twhile (!s.empty()) {\n\t\tauto node = s.top(); s.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tauto next = node;\n\t\t\tnext.first += dx[i]; next.second += dy[i];\n\t\t\tif (next.first < 0 || next.first >= w || next.second < 0 || next.second >= h) continue;\n\t\t\tif (newPanel[next.second][next.first] != c) continue;\n\t\t\tcolorCount++;\n\t\t\tnewPanel[next.second][next.first] = 0;\n\t\t\ts.push(next);\n\t\t}\n\t}\n\treturn colorCount;\n}\n\nint main() {\n\twhile (std::cin >> h >> w >> c && (h || w || c)) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tstd::cin >> panel[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint max = 0;\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tmax = std::max(changeColor(i), max);\n\t\t}\n\t\tstd::cout << max << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\ntypedef vector<vi> P;\nint h, w, c;\n\nint hoge(P &a,int t)\n{\n\tint o = a[1][1];\n\ta[1][1] = t;\n\tqueue<pii> que;\n\tque.push(pii(1, 1));\n\tint ans = 0;\n\twhile (!que.empty())\n\t{\n\t\tpii now = que.front(); que.pop();\n\t\tFOR(j, 4)\n\t\t{\n\t\t\tint x = now.first + dx[j];\n\t\t\tint y = now.second + dy[j];\n\t\t\tif (a[x][y] == o)\n\t\t\t{\n\t\t\t\ta[x][y] = t;\n\t\t\t\tque.push(pii(x, y));\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans+1;\n}\n\n\nint calc(P p,int now)\n{\n\tint ans = 0;\n\tif (now == 5)\n\t{\n\t\tif (p[1][1] != c)return 0;\n\t\treturn hoge(p, 0);\n\t}\n\tFORI(i, 1, 6 + 1)\n\t{\n\t\tP a=p;\n\t\tif (i == a[1][1])continue;\n\t\thoge(a, i);\n\t\tans = max(ans, calc(a, now + 1));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> h >> w >> c;\n\t\tif (!h)break;\n\t\tvi wall(10, -1);\n\t\tP a(10, wall);\n\t\tFORI(i, 1, h + 1)\n\t\t{\n\t\t\tFORI(j, 1, w + 1)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << calc(a,0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\n\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, -1, 0, 1};\nint h, w, c;\n\nvoid draw(vector<vector<int> > &p, int color) {\n    vector<vector<bool> > used(h, vector<bool>(w, false));\n    queue<pii> que;\n    que.push(pii(0, 0));\n    int nowc = p[0][0];\n    p[0][0] = color;\n    while (!que.empty()) {\n        int ci = que.front().first;\n        int cj = que.front().second;\n        que.pop();\n        for (int i = 0; i < 4; i++) {\n            int ni = ci + di[i];\n            int nj = cj + dj[i];\n            if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n            if (used[ni][nj] == false) {\n                used[ni][nj] = 1;\n                if (p[ni][nj] == nowc) {\n                    p[ni][nj] = color;\n                    que.push(pii(ni, nj));\n                }\n            }\n        }\n    }\n}\n\nint count(vector<vector<int> > p) {\n    vector<vector<bool> > used(h, vector<bool>(w, false));\n    queue<pii> que;\n    que.push(pii(0, 0));\n    used[0][0] = true;\n    int res = 1;\n    while (!que.empty()) {\n        int ci = que.front().first;\n        int cj = que.front().second;\n        que.pop();\n        for (int i = 0; i < 4; i++) {\n            int ni = ci + di[i];\n            int nj = cj + dj[i];\n            if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n            if (used[ni][nj] == false) {\n                used[ni][nj] = 1;\n                if (p[ni][nj] == c) {\n                    res++;\n                    que.push(pii(ni, nj));\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint ans;\nint dfs(int cnt, vector<vector<int> > &p) {\n    auto t = p;\n    if (cnt == 4) {\n        draw(p, c);\n        ans = max(ans, count(p));\n    } else {\n        for (int i = 1; i <= 6; i++) {\n            draw(p, i);\n            dfs(cnt + 1, p);\n            p = t;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (cin >> h >> w >> c) {\n        if (h + w + c == 0) break;\n        vector<vector<int> > p(h, vector<int>(w, 0));\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> p[i][j];\n            }\n        }\n        ans = 0;\n        cout << dfs(0, p) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind{\n    // 頂点数(1-indexed)\n    const int V;\n    // par[x]:=xのroot\n    vector<int> par;\n    // sz[x]:=xを含む集合のサイズ\n    vector<int> sz;\n    UnionFind(const int V):V(V){\n        par.resize(V+1);\n        for(int i=0;i<=V;i++) par[i]=i;\n        sz.resize(V+1,1);\n    }\n    void init(){\n        for(int i=0;i<=V;i++) par[i]=i;\n        for(int i=0;i<=V;i++) sz[i]=1;\n    }\n    bool unite(int x,int y){\n        x=root(x),y=root(y);\n        if(same(x,y)) return false;\n        if(y<x) swap(x,y);\n        par[y]=x;\n        sz[x]+=sz[y];\n        return true;\n    }\n    int root(int x){\n    \tif(par[x]==x) return x; // xはroot\n    \treturn (par[x]=root(par[x])); // xの親のroot\n    }\n    bool same(int x,int y){\n    \treturn (root(x)==root(y));\n    }\n    int size(int x){\n        return sz[root(x)];\n    }\n};\n\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint h, w, c;\n\nbool able(int y, int x) {\n    if(y < 0 or h <= y) return false;\n    if(x < 0 or w <= x) return false;\n    return true;\n}\n\nvoid merge(UnionFind &uf, vector<vector<int>> &board) {\n    for(int y = 0; y < h; ++y) {\n        for(int x = 0; x < w; ++x) {\n            for(int i = 0; i < 4; ++i) {\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if(able(ny, nx)) {\n                    if(board[y][x] == board[ny][nx]) {\n                        uf.unite(y * w + x, ny * w + nx);\n                    }\n                }\n            }\n        }   \n    }\n}\n\nint solve(vector<int> &color, vector<vector<int>> &board, UnionFind &uf) {\n    // first merge\n    merge(uf, board);\n    // color change\n    for(int q = 0; q < 5; ++q) {\n        for(int y = 0; y < h; ++y) {\n            for(int x = 0; x < w; ++x) {\n                if(uf.same(0, y * w + x)) {\n                    board[y][x] = color[q];\n                }\n            }   \n        }\n        merge(uf, board);\n    }\n    return uf.size(0);\n}\n\nint main() {\n    while(cin >> h >> w >> c and h > 0) {\n        c--;\n        vector<vector<int>> p(h, vector<int>(w));\n        for(int y = 0; y < h; ++y) {\n            for(int x = 0; x < w; ++x) {\n                cin >> p[y][x];\n                p[y][x]--;\n            }\n        }\n        int ans = 0;\n        for(int mask = 0; mask < (int)pow(6, 4); ++mask) {\n            vector<vector<int>> board = p;\n            vector<int> color(5);\n            int tmp = mask;\n            for(int i = 0; i < 4; ++i) {\n                color[i] = tmp % 6;\n                tmp /= 6;\n            }\n            color[4] = c;\n            UnionFind uf(h * w);\n            ans = max(ans, solve(color, board, uf));\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint h,w,c;\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nint change(int maps[9][9],int color,int x,int y)\n{\n  int tmp=maps[x][y];\n  maps[x][y]=color;\n  int sum=1;\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]>=0 && y+dy[i]>=0 &&\n         x+dx[i]<h && y+dy[i]<w &&\n         tmp==maps[x+dx[i]][y+dy[i]])\n        {\n          sum+=change(maps,color,x+dx[i],y+dy[i]);\n        }\n    }\n  return sum;\n}\n\n\nint check(int maps[9][9],int cnt)\n{\n  /*\n  if(cnt==0&& maps[0][0]==c)\n    {\n  cerr<<\"------\"<<endl<<\"cnt  \"<<cnt<<endl;\n  for(int i=0;i<h;i++,cerr<<endl)\n        for(int j=0;j<w;j++)\n          {\n            cerr<<maps[i][j]<<\" \";\n          }\n  cerr<<\"------\"<<endl;\n    }\n  */\n  if(cnt<=0)\n    {\n      if(maps[0][0]!=c)\n        return 0;\n      else\n        return change(maps,9,0,0);\n    }\n  int ans=0;\n  for(int cc=1;cc<=6;cc++)\n    {\n      if(maps[0][0]!=cc)\n        {\n          int tmp[9][9];\n          for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++)\n              tmp[i][j]=maps[i][j];\n          change(tmp,cc,0,0);\n          ans=max(ans,check(tmp,cnt-1));\n        }\n    }\n  return ans;\n\n}\n\n\nint main()\n{\n\n  for(;cin>>h>>w>>c,h;)\n    {\n      int maps[9][9];\n      memset(maps,-1,sizeof(maps));\n      for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n          {\n            cin>>maps[i][j];\n          }\n      cout<<check(maps,5)<<endl;\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint h,w;\nint t[10][10];\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nbool in(int x, int y){\n    if(0 > x || x >= h) return false;\n    if(0 > y || y >= w) return false;\n    return true;\n}\n\nvoid change(int c){ //g[0][0]を色cに変える\n\n    int bef = t[0][0];\n    if(bef == c)return;\n    queue<pii> q;\n    q.push(pii(0,0));\n    while(q.size()){\n        int x = q.front().first;\n        int y = q.front().second;\n\n        t[x][y] = c;\n        q.pop();\n        rep(i,4){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(in(nx,ny) && t[nx][ny] == bef){\n                q.push(pii(nx,ny));\n            }\n        }\n    }\n}\n\nint count(int c){ //色cの連結成分の大きさを調べる\n\n    int ret = 0;\n    rep(i,h)rep(j,w)if(t[i][j] == c){\n        int cnt = 0;\n        queue<pii> q;\n        q.push(pii(i,j));\n        while(q.size()){\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            if(t[x][y] < 0)continue;\n\n            cnt++;\n            t[x][y] = -1;\n            rep(k,4){\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                if(in(nx,ny) && t[nx][ny] == c ){\n                    q.push(pii(nx,ny));\n                }\n            }\n        }\n\n        ret = max(ret, cnt);\n    }\n\n    return ret;\n}\n\nint main(void) {\n    int col;\n    while(cin >> h >> w >> col, h){\n        col--;\n        int g[10][10];\n        rep(i,h)rep(j,w)cin >> g[i][j],g[i][j]--;\n        int ans = 0;\n        rep(a,6)rep(b,6)rep(c,6)rep(d,6)rep(e,6){\n            rep(i,h)rep(j,w)t[i][j] = g[i][j];\n            change(a);\n            change(b);\n            change(c);\n            change(d);\n            change(e);\n            ans = max(ans, count(col));\n        }\n        cout << ans << endl;\n    }\n}\nv\n"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\nconst int MAX = 2*123500;\n\n\n/** Problem1174 : Identically Colored Panels Connection **/\ntypedef struct {\n\tint field[8][8];\n\tbool area[8][8];\n\tint cost;\n} S;\n\nint w, h;\nvoid bond(int f[8][8], bool b[8][8])\n{\n\tbool vis[8][8];\n\tqueue<P> Q;\n\tfill(vis[0], vis[0]+8*8, false);\n\tQ.push(P(0, 0));\n\t\n\twhile (Q.size()) {\n\t\tP p = Q.front(); Q.pop();\n\t\tif (vis[p.first][p.second]) continue;\n\t\telse vis[p.first][p.second]=true;\n\t\t\n\t\trep(i, 4) {\n\t\t\tint nx=p.first+dx[i], ny=p.second+dy[i];\n\t\t\tif_range(nx, ny, w, h) {\n\t\t\t\tif (f[nx][ny] == f[p.first][p.second]) {\n\t\t\t\t\tb[nx][ny] = true;\n\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint c;\n\t\n\twhile (cin>>h>>w>>c, h||w||c) {\n\t\tc--;\n\t\t\n\t\tqueue<S> Q;\n\t\tS first;\n\t\tint ans=0;\n\t\t\n\n\t\trep(y, h) rep(x, w) {\n\t\t\tcin >> first.field[x][y];\n\t\t\tfirst.field[x][y]--;\n\t\t\tfirst.area[x][y]=false;\n\t\t}\n\t\t\n\t\tfirst.area[0][0]=true;\n\t\tbond(first.field, first.area);\n\t\t\n\t\trep(y, h) rep(x, w) {\n\t\t\trep(i, 4) {\n\t\t\t\tint nx=x+dx[i], ny=y+dy[i];\n\t\t\t\tif (0<=nx&&nx<w&&0<=ny&&ny<h&&first.area[x][y]&&first.field[0][0]==first.field[nx][ny])\n\t\t\t\t\tfirst.area[nx][ny]=true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfirst.cost = 0;\n\t\tQ.push(first);\n\t\t\n\t\twhile (Q.size()) {\n\t\t\tS s = Q.front();\n\t\t\t\n\t\t\tif (s.cost==5 && s.field[0][0]==c) {\n\t\t\t\tint cnt=0;\n\t\t\t\trep(y, h){\n\t\t\t\t\trep(x, w) {\n\t\t\t\t\t\tif (s.area[x][y])\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans, cnt);\n\t\t\t\tQ.pop(); continue;\n\t\t\t} else if (s.cost>5) {\n\t\t\t\tQ.pop(); continue;\n\t\t\t}\n\t\t\t\n\t\t\trep(i, 6) {\n\t\t\t\tif (s.field[0][0]==i) continue;\n\t\t\t\trep(y, h) rep(x, w) {\n\t\t\t\t\tif (s.area[x][y])\n\t\t\t\t\t\ts.field[x][y] = i;\n\t\t\t\t}\n\t\t\t\tbond(s.field, s.area);\n\t\t\t\ts.cost++;\n\t\t\t\tQ.push(s);\n\t\t\t\ts = Q.front();\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint h, w, c;\nint panel[8][8];\n\nclass node {\npublic:\n\tint panel[8][8], tmpPanel[8][8];\n\tint d;\n\tint area;\n\tnode(int src[8][8]){\n\t\tmemcpy(panel, src, sizeof(panel));\n\t\tmemcpy(tmpPanel, panel, sizeof(panel));\n\t\tgetArea(0, 0, panel[0][0]);\n\t\tarea = 0;\n\t\td = 0;\n\t}\n\tnode(int src[8][8], int i, int _d=0){\n\t\tmemcpy(panel, src, sizeof(panel));\n\t\tarea = 0;\n\t\tflip(0, 0, this->panel[0][0], i);\n\t\tmemcpy(tmpPanel, panel, sizeof(panel));\n\t\tgetArea(0, 0, i);\n\t\td = _d;\n\t}\n\tvoid flip(int x, int y, int c1, int c2) {\n\t\tthis->panel[x][y] = c2;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nextX = x + dx[i];\n\t\t\tint nextY = y + dy[i];\n\t\t\tif (0 <= nextX && nextX < w && 0 <= nextY && nextY < h && this->panel[nextX][nextY] == c1) {\n\t\t\t\tflip(nextX, nextY, c1, c2);\n\t\t\t}\n\t\t}\n\t}\n\tvoid getArea(int x, int y, int c) {\n\t\ttmpPanel[x][y] = -1;\n\t\tthis->area++;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nextX = x + dx[i];\n\t\t\tint nextY = y + dy[i];\n\t\t\tif (0 <= nextX && nextX < w && 0 <= nextY && nextY < h && this->tmpPanel[nextX][nextY] == c) {\n\t\t\t\tgetArea(nextX, nextY, c);\n\t\t\t}\n\t\t}\n\t}\n\tbool operator < (const node& o) const {\n\t\treturn this->area < o.area;\n\t}\n};\n\nvoid debug(node& n){\n\tcout << \"Debug===========================\" << endl;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++)\n\t\t\tcout << n.panel[j][i] << \" \";\n\t\tcout<< endl;\n\t}\n\tcout << n.area << endl;\n}\n\nint solve() {\n\tint maxArea = 0;\n\tnode root(panel);\n\tpriority_queue<node> q;\n\tq.push(root);\n\twhile (!q.empty()) {\n\t\tnode current = q.top();q.pop();\n\t\t//debug(current);\n\t\tif (current.panel[0][0] == c)\n\t\t\tmaxArea = max(maxArea, current.area);\n\t\tfor (int i = 1; i < 7; i++) {\n\t\t\tif (current.d + 1 == 6) continue;\n\t\t\tif (current.panel[0][0] == i) continue;\n\t\t\tif (current.d == 3 && i == c) continue;\n\t\t\tnode next(current.panel, i, current.d + 1);\n\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn maxArea;\n}\n\nint main() {\n\twhile (cin >> h >> w >> c, h || w || c) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> panel[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[6][9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[y][x] == b[ty][tx] && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nvoid cpy(int d, int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[d][i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[d][i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tif (b[0][0] != c) cpy(d, 0), rec(0, 0, c);\n\tcpy(0, 2), ret = rec1(0, 0), cpy(d, 1);\n\tif (d < 4) {\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(d, 0), rec(0, 0, i);\n\t\t\tret = max(ret, solve(d + 1)), cpy(d, 1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tmemset(b, 0, sizeof(b));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,c;\nint field[8][8];\nint tmpfield[8][8];\nint lt;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nvoid dfs(int a,int b,int cc){\n  if(a<0||h<=a||b<0||w<=b) return;\n  if(tmpfield[a][b]!=lt) return;\n  tmpfield[a][b]=cc;\n  for(int i=0;i<4;++i)\n    dfs(a+dx[i],b+dy[i],cc);\n  return;\n}\n\nvoid color(int cc){\n  lt=tmpfield[0][0];\n  if(lt==cc) return;\n  dfs(0,0,cc);\n  return;\n}\n\nint main(void){\n  while(cin >> h >> w >> c,h+w+c){\n    int answer=0;\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j){\n\tcin >> field[i][j];\n      }\n    int ch[6]={};\n    for(int chp=0;chp<6*6*6*6;++chp){\n      ch[0]=chp%6+1;\n      ch[1]=(chp/6)%6+1;\n      ch[2]=(chp/6/6)%6+1;\n      ch[3]=(chp/6/6/6)%6+1;\n      ch[4]=c;\n      ch[5]=0;\n      for(int i=0;i<h;++i)\n\tfor(int j=0;j<w;++j)\n\t  tmpfield[i][j]=field[i][j];\n      for(int i=0;i<6;++i) color(ch[i]);\n      int tmpanswer=0;\n      for(int i=0;i<h;++i)\n\tfor(int j=0;j<w;++j)\n\t  if(tmpfield[i][j]==0) tmpanswer++;\n      answer=max(answer,tmpanswer);\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nint h,w,tc;\n\nvoid cpy(char dst[10][10], const char src[10][10]) {\n    for(int j=0; j<10; j++)\n        for(int i=0; i<10; i++)\n            dst[j][i] = src[j][i];\n}\nvoid paint(char dst[10][10], int sc, int tc, int x, int y) {\n    if(x<0 || y<0 || x>=w || y>=h) return;\n    if(sc == tc) return;\n    if(dst[y][x] == sc) {\n        dst[y][x] = tc;\n        paint(dst, sc, tc, x-1, y);\n        paint(dst, sc, tc, x, y-1);\n        paint(dst, sc, tc, x+1, y);\n        paint(dst, sc, tc, x, y+1);\n    }\n}\n\nint dfs(int d, int c, const char src[10][10]) {\n    char map[10][10];\n    int res=0;\n    memset(map, 0, sizeof(map));\n\n\n    cpy(map,src);\n\n    paint(map,map[0][0], c, 0, 0);\n\n    if(d==5) {\n        int res=0;\n        paint(map, map[0][0], 100, 0, 0);\n        for(int j=0; j<10; j++)\n            for(int i=0; i<10; i++)\n                if(map[j][i] == 100) res++;\n        return res;\n\n    }\n\n\n    if(d==4) return dfs(d+1, tc, map);\n\n    for(int cc=1; cc<=6; cc++) {\n        res = max(dfs(d+1, cc, map), res);\n    }\n    return res;\n}\n\n\n\nint main(void) {\n    while(true) {\n        char map[10][10] = {};\n        scanf(\"%d%d%d\",&h,&w,&tc);\n        if(!h) break;\n\n        for(int j=0; j<h; j++)\n            for(int i=0; i<w; i++)\n                scanf(\"%d\", &map[j][i]);\n        printf(\"%d\\n\", dfs(0, map[0][0], map));\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nvoid paint(vector<vector<int>>& p, vector<vector<bool>>& use, int next)\n{\n\tint h = p.size();\n\tint w = p[0].size();\n\tqueue<pair<int, int>> q;\n\tREP(i, h)REP(j, w) if(use[i][j]){\n\t\tq.push({ i,j });\n\t}\n\n\n\twhile (!q.empty()) {\n\t\tauto now = q.front(); q.pop();\n\n\t\t//上\n\t\tif (0 < now.first && !use[now.first - 1][now.second] && p[now.first - 1][now.second] == next) {\n\t\t\tuse[now.first - 1][now.second] = true;\n\t\t\tq.push({ now.first - 1,now.second });\n\t\t}\n\t\t//下\n\t\tif (now.first < h - 1 && !use[now.first + 1][now.second] && p[now.first + 1][now.second] == next) {\n\t\t\tuse[now.first + 1][now.second] = true;\n\t\t\tq.push({ now.first + 1,now.second });\n\t\t}\n\t\t//左\n\t\tif (0 < now.second && !use[now.first][now.second - 1] && p[now.first][now.second-1] == next) {\n\t\t\tuse[now.first][now.second - 1] = true;\n\t\t\tq.push({ now.first,now.second - 1 });\n\t\t}\n\t\t//右\n\t\tif (now.second < w - 1 && !use[now.first][now.second + 1] && p[now.first][now.second+1] == next) {\n\t\t\tuse[now.first][now.second+1] = true;\n\t\t\tq.push({ now.first,now.second + 1 });\n\t\t}\n\t}\n}\n\n//routeの順に色を変更するので、\n//その時に、use=falseが①trueに隣接②routeの色と同じ　ならtrueにする\nint act(vector<vector<int>> p, vector<vector<bool>> use, vector<int> route)\n{\n\tint h = p.size();\n\tint w = p[0].size();\n\tuse[0][0] = true;\n\t//=================================\n\tfor (int next : route) {\n\t\tpaint(p, use, next);\n\t}\n\n\n\n\t//=================================\n\tint ans = 0;\n\tfor (auto row : use) {\n\t\tfor (auto col : row) {\n\t\t\tif (col)ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\n//計算\nvoid testing(int c ,vector<vector<int>> p)\n{\n\tint ans = 0;\n\tvector<vector<bool>> use;\n\tREP(i, p.size())use.push_back(vector<bool>(p[0].size(), false));\n\n\t//色変化順\n\tREP(i, pow(6, 4)) {\n\t\tint j = i;\n\t\tvector<int> route;\n\t\troute.push_back(p[0][0]);\n\t\tREP(k, 4) {\n\t\t\troute.push_back(j % 6);\n\t\t\tj /= 6;\n\t\t}\n\t\troute.push_back(c);\n\t\tif (route[0] == route[1]\n\t\t\t|| route[1] == route[2]\n\t\t\t|| route[2] == route[3]\n\t\t\t|| route[3] == route[4]\n\t\t\t|| route[4] == route[5])continue;\n\t\tans = max(ans, act(p, use, route));\n\t}\n\tcout << ans << endl;\n}\n\n\n//メイン関数\nint main()\n{\n\tint a;\n\n\twhile (true) \n\t{\n\t\tint h, w, c;\n\t\tvector<vector<int>> p;\n\t\tcin >> h >> w >> c;\n\t\tc--;\n\t\tif (h == 0)break;\n\n\t\tREP(i, h) {\n\t\t\tint tmp;\n\t\t\tvector<int> row;\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ttmp--;\n\t\t\t\trow.push_back(tmp);\n\t\t\t}\n\t\t\tp.push_back(row);\n\t\t}\n\t\ttesting(c, p);\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nvoid paint(vector<vector<int>>& p, vector<vector<bool>>& use, int next)\n{\n\tint h = p.size();\n\tint w = p[0].size();\n\tbool update;\n\nstart:;\n\tupdate = false;\n\tREP(i, h)REP(j, w) if (p[i][j] == next && (!use[i][j])) {\n\t\t//上\n\t\tif (0 < i && use[i - 1][j]) {\n\t\t\tuse[i][j] = true;\n\t\t\tupdate = true;\n\t\t}\n\t\t//下\n\t\tif (i < h - 1 && use[i + 1][j]) {\n\t\t\tuse[i][j] = true;\n\t\t\tupdate = true;\n\t\t}\n\t\t//左\n\t\tif (0 < j && use[i][j - 1]) {\n\t\t\tuse[i][j] = true;\n\t\t\tupdate = true;\n\t\t}\n\t\t//右\n\t\tif (j < w - 1 && use[i][j + 1]) {\n\t\t\tuse[i][j] = true;\n\t\t\tupdate = true;\n\t\t}\n\t}\n\tif (update)goto start;\n}\n\nvoid debug2(vector<vector<bool>> use) {\n\tfor (auto row : use) {\n\t\tfor (bool col : row) {\n\t\t\tif (col)cout << \"#\";\n\t\t\telse cout << \".\";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n//routeの順に色を変更するので、\n//その時に、use=falseが①trueに隣接②routeの色と同じ　ならtrueにする\nint act(vector<vector<int>> p, vector<vector<bool>> use, vector<int> route)\n{\n\tint h = p.size();\n\tint w = p[0].size();\n\tuse[0][0] = true;\n\t//=================================\n\tfor (int next : route) {\n\t\tpaint(p, use, next);\n\t\t//debug2(use);\n\t}\n\n\n\n\t//=================================\n\tint ans = 0;\n\tfor (auto row : use) {\n\t\tfor (auto col : row) {\n\t\t\tif (col)ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\n//計算\nvoid calc(vector<vector<int>> p, int c)\n{\n\tint ans = 0;\n\tvector<vector<bool>> use;\n\tREP(i, p.size())use.push_back(vector<bool>(p[0].size(), false));\n\n\t//色変化順\n\tREP(i, pow(6, 4)) {\n\t\tint j = i;\n\t\tvector<int> route;\n\t\troute.push_back(p[0][0]);\n\t\tREP(k, 4) {\n\t\t\troute.push_back(j % 6);\n\t\t\tj /= 6;\n\t\t}\n\t\troute.push_back(c);\n\t\tans = max(ans, act(p, use, route));\n\t}\n\tcerr << \"ans:\";\n\tcout << ans << endl;\n}\n\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile (true) {\n\t\tint h, w, c;\n\t\tvector<vector<int>> p;\n\t\tcin >> h >> w >> c;\n\t\tc--;\n\t\tif (h == 0)break;\n\n\t\tREP(i, h) {\n\t\t\tint tmp;\n\t\t\tvector<int> row;\n\t\t\tREP(j, w) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ttmp--;\n\t\t\t\trow.push_back(tmp);\n\t\t\t}\n\t\t\tp.push_back(row);\n\t\t}\n\t\tcalc(p, c);\n\t}\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint m[6][10][10];\nint h,w,c,d[]={0,1,0,-1,0};\nint C(int x,int y,int s,int f,int t)\n{\n\tint&r=m[s][y][x],i,a=1;\n\tif(r-f)return 0;\n\tr=t;\n\tfor(i=0;i<4;++i)a+=C(x+d[i],y+d[i+1],s,f,t);\n\treturn a;\n}\nint F(int s)\n{\n\tif(s>=5)return C(1,1,s,c,0);\n\tint r=0,t,i,p=m[s][1][1];\n\tfor(i=1;i<=6;++i)\n\t{\n\t\tif(p==i)continue;\n\t\tmemcpy(m[s+1],m[s],sizeof(m[0]));\n\t\tC(1,1,s+1,p,i);\n\t\tt=F(s+1);\n\t\tr=(r>t?r:t);\n\t}\n\treturn r;\n}\nint main()\n{\n\tint x,y;\n\twhile(scanf(\"%d%d%d\",&h,&w,&c),h)\n\t{\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(y=1;y<=h;++y)for(x=1;x<=w;++x)scanf(\"%d\",&m[0][y][x]);\n\t\tprintf(\"%d\\n\",F(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nstruct pos{\n  pos(int _f,int _s):first(_f),second(_s){}\n  int first;int second;\n};\n\nint union_t(vector<vector<int> > & table,int clr,int h,int w)\n{\n  vector<vector<int> > vis(h,vector<int>(w,0));\n  queue<pos> q;\n  q.push(pos(0,0));\n  vis[0][0]=1;\n  while(!q.empty())\n  {\n    int dx[]={1,0,-1,0};\n    int dy[]={0,1,0,-1};\n    pos p = q.front();\n    q.pop();\n    int x,y;\n    x=p.first;\n    y=p.second;\n    vis[y][x]=1;\n    REP(i,4)\n    {\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(nx<0||nx>=w||ny<0||ny>=h)\n        continue;\n      if(vis[ny][nx]==1)\n        continue;\n      if(table[ny][nx] == clr || (table[y][x] == table[0][0] && table[ny][nx] == table[0][0]))\n      {\n        q.push(pos(nx,ny));\n      }\n    }\n  }\n  int c = 0;\n  REP(i,h)\n    REP(j,w)\n      if(vis[i][j]==1)\n      {\n        table[i][j] = clr;\n        c++;\n      }\n  return c;\n}\n\nint search(vector<vector<int> > & table,int depth,int clr,int h,int w)\n{\n  if(depth > 1)\n  {\n    int m = 0;\n    FOR(i,1,7)\n    {\n      vector<vector<int> > cp(h);\n      REP(j,h)\n        cp[j] = vector<int>(table[j]);\n      union_t(cp,i,h,w);\n      m = max(m,search(cp,depth-1,clr,h,w));\n    }\n    return m;\n  }\n  else\n  {\n    vector<vector<int> > cp(h);\n    REP(j,h)\n      cp[j] = vector<int>(table[j]);\n    return union_t(cp,clr,h,w);\n  }\n}\n\nint main(void) {\n  while(1)\n  {\n    int h,w,c;\n    cin>>h>>w>>c;\n    if(!(h||w||c))break;\n    vector<vector<int> > table(h,vector<int>(w,0));\n    REP(i,h)\n      REP(j,w)\n        cin>>table[i][j];\n    cout<<search(table,5,c,h,w)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pi;\n\nvvi f;\nint h,w,c;\n\nint dx[]={1,-1,0,0}, dy[]={0,0,1,-1};\n\nint dfs(int col, int num, const vvi &field)\n{\n    //BFS\n    vvi vis(h,vi(w,0));\n    //?????????????????????\n    int lu=field[0][0];\n    queue<pi> que;\n    vis[0][0]=1;\n    que.push(pi(0,0));\n    while(!que.empty())\n    {\n        pi now=que.front();\n        que.pop();\n        rep(i,4)\n        {\n            int nx=now.se+dx[i], ny=now.fi+dy[i];\n            if(0<=nx&&nx<w && 0<=ny&&ny<h)\n            {\n                if(!vis[ny][nx] && field[ny][nx]==lu)\n                {\n                    vis[ny][nx]=1;\n                    que.push(pi(ny,nx));\n                }\n            }\n        }\n    }\n\n    //????????????\n    vvi nf(field);\n    rep(i,h)rep(j,w)\n    {\n        if(vis[i][j]) nf[i][j]=col;\n    }\n\n    int ret=0;\n    if(num==6)\n    {\n        //???????????????\n        int ct=0;\n        rep(i,h)rep(j,w) ct+=vis[i][j];\n        return ct;\n    }\n    else if(num==5)\n    {\n        //???????????????\n        //???????????§dfs\n        ret=max(ret,dfs(col,num+1,nf));\n    }\n    else if(num==4)\n    {\n        //????????????c??????????????¨????????????\n        ret=max(ret,dfs(c,num+1,nf));\n    }\n    else\n    {\n        //?¬???????????????¶\n        for(int i=1; i<=6; ++i)\n        {\n            //????????????????§?\n            if(i==col) continue;\n\n            ret=max(ret,dfs(i,num+1,nf));\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d %d\",&h,&w,&c),h|w|c)\n    {\n        f=vvi(h,vi(w));\n        rep(i,h)rep(j,w) scanf(\" %d\", &f[i][j]);\n\n        int ans=0;\n        for(int i=1; i<=6; ++i) ans=max(ans,dfs(i,1,f));\n\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef vector<int>  vi;\ntypedef vector<vi> vv;\nint h,w,c,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nbool visited[8][8];\nvoid dfs2(vv& vc,int be,int to,int x,int y){\n\tif(visited[x][y]) return;\n\tvisited[x][y]=true;\n\tif(vc[x][y]!=be) return;\n\tvc[x][y]=to;\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n\t\tdfs2(vc,be,to,nx,ny);\n\t}\n}\nint cnt(vv &vc,int be,int x,int y){\n\tif(visited[x][y]) return 0;\n\tint ret=1;\n\tvisited[x][y]=true;\n\tif(vc[x][y]!=be) return 0;\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n\t\tret+=cnt(vc,be,nx,ny);\n\t}\n//\tcout << x << \" \" << y << \" \" << ret << endl;\n\treturn ret;\n}\nint dfs(vv vc,int t){\n\tint ret=-1;\n\trep(i,6){\n\t\tif(t==4) if(i!=c-1) continue;\n\t\tvv np=vc;\n\t\trep(j,8) rep(k,8) visited[j][k]=false;\n\t\tdfs2(np,np[0][0],i,0,0);\n\t\tnp[0][0]=i;\n/*\t\tcout << t << \" \" << i << endl;\n\t\trep(j,h){\n\t\t\trep(k,w){\n\t\t\t\tcout << np[j][k] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;*/\n\t\trep(j,8) rep(k,8) visited[j][k]=false;\n\t\tif(t<4){\n\t\t\tret=max(ret,dfs(np,t+1));\n\t\t}else{\n\t\t\tint hoge=cnt(np,np[0][0],0,0);\n//\t\t\tcout << i << \" \" << hoge << endl;\n\t\t\tret=max(ret,hoge);\n/*\t\t\tif(ret<hoge){\n\t\t\t\tret=hoge;\n\t\t\t\tcout << t << \" \" << i << \"  ret= \" << ret << endl;\n\t\t\t\trep(j,h){\n\t\t\t\t\trep(k,w){\n\t\t\t\t\t\tcout << np[j][k] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d%d\",&h,&w,&c);\n\t\tif(!h) break;\n\t\tvv pn(h,vi(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&pn[i][j]),pn[i][j]--;\n\t\t//printf(\"%d\\n\",cnt(pn,pn[0][0],0,0));\n\t\t/*dfs2(pn,pn[0][0],4,0,0);\n\t\tcout << endl;\n\t\trep(j,h){\n\t\t\trep(k,w){\n\t\t\t\tcout << pn[j][k] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tprintf(\"%d\\n\",dfs(pn,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, f, a[9][9], b[9][9], g[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e; f++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tfor (int k = 1; k <= 6; k++) {\n\t\tif (d == 4) k = c;\n\t\tif (b[0][0] == k) continue;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) g[i][j] = b[i][j];\n\t\t}\n\t\tf = 0; rec(0, 0, k);\n\t\tret = max(ret, d != 0 ? max(f, solve(d + 1)) : f);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) b[i][j] = g[i][j];\n\t\t}\n\t\tif (d == 4) break;\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,e) for ( int i = b; i < e; i++)\n#define rep(i,n) for (int i = 0; i < n; i++)\nstatic const int MAX = 8;\nstatic const int di[4] = {0, -1, 0, 1};\nstatic const int dj[4] = {1, 0, -1, 0};\n\nint H, W, C, G[MAX+2][MAX+2], V[MAX+2][MAX+2];\nint cnt, ans;\n\nvoid init(){ \n  REP(i, 1, H+1) REP(j, 1, W+1) V[i][j] = 0; \n  cnt = 0;\n}\n\nvoid fillc(int color, int i, int j, int prec){\n  G[i][j] = color;\n  V[i][j] = 1;\n  cnt++;\n  rep(r, 4){\n    int ni = i + di[r];\n    int nj = j + dj[r];\n    if ( G[ni][nj] == prec && V[ni][nj] == 0) fillc(color, ni, nj, prec);\n  }\n}\n\nvoid solve(int d){\n  int T[MAX+2][MAX+2];\n\n  if ( d == 4 ){\n    init();\n    fillc(C, 1, 1, G[1][1]);\n    init();\n    fillc(C, 1, 1, G[1][1]);\n    ans = max(ans, cnt);\n    return;\n  }\n  \n  REP(a, 1, 7) {\n    REP(i, 1, H+1) REP(j, 1, W+1) T[i][j] = G[i][j]; \n    init();\n    fillc(a, 1, 1, G[1][1]);\n    solve(d+1);\n    REP(i, 1, H+1) REP(j, 1, W+1) G[i][j] = T[i][j];\n  }\n}\n\nmain(){\n  while(1){\n    cin >> H >> W >> C;\n    if ( H == 0 ) break;\n    rep(i, H+2) rep(j, W+2) G[i][j] = 0;\n    rep(i, H) rep(j, W) cin >> G[i+1][j+1];\n    ans = 0;\n    solve(0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n = 6;\nint h, w, c;\nint p[10][10];\nint prv[10][10];\nbool connect[10][10];\nbool visited[10][10];\nint ans;\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvoid dfs2(int y, int x, int color, int change){\n    visited[y][x] = true;\n    if(p[y][x] != color) return;\n    connect[y][x] = true;\n    p[y][x] = change;\n    rep(i, 0, 4){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if(!contain(ny, nx)) continue;\n        if(visited[ny][nx]) continue;\n        dfs2(ny, nx, color, change);\n    }\n}\n\nvoid dfs(int times){\n    int sv[10][10];\n    rep(i, 0, h) rep(j, 0, w) sv[i][j] = p[i][j];\n    rep(i, 0, n){\n        rep(j, 0, h) rep(k, 0, w){\n            connect[j][k] = false;\n            visited[j][k] = false;\n        }\n        dfs2(0, 0, p[0][0], i);\n        if(times <= 4) dfs(times + 1);\n        else{\n            if(sv[0][0] != c) continue;\n            int cnt = 0;\n            rep(j, 0, h) rep(k, 0, w) if(connect[j][k]) cnt++;\n            chmax(ans, cnt);\n        }\n        rep(j, 0, h) rep(k, 0, w) p[j][k] = sv[j][k];\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> h >> w >> c;\n        if(h + w + c == 0) break;\n        c--;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> p[i][j];\n                p[i][j]--;\n            }\n        }\n        ans = 0;\n        dfs(0);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nvector< vector<bool> > getunion(vector< vector<int> >& base){\n\tvector< vector<bool> > ret;\n\tstack< pair<int,int> > nxt;\n\tint xmax=base[0].size();\n\tint ymax=base.size();\n\tint tar=base[0][0];\n\tint curx,cury;\n\tret.resize(ymax);\n\tfor(int i=0;i<ymax;i++)ret[i].resize(xmax);\n\tnxt.push(pair<int,int>(0,0));\n\twhile(!nxt.empty()){\n\t\tcurx=nxt.top().first;\n\t\tcury=nxt.top().second;\n\t\tnxt.pop();\n\t\tif(base[cury][curx]==tar&&!ret[cury][curx]){\n\t\t\tret[cury][curx]=true;\n\t\t\tif(curx>0)nxt.push(pair<int,int>(curx-1,cury));\n\t\t\tif(curx<xmax-1)nxt.push(pair<int,int>(curx+1,cury));\n\t\t\tif(cury>0)nxt.push(pair<int,int>(curx,cury-1));\n\t\t\tif(cury<ymax-1)nxt.push(pair<int,int>(curx,cury+1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector< vector<int> >ccolor(vector< vector<int> >& base,int color){\n\tvector< vector<int> > ret;\n\tvector< vector<bool> > uni=getunion(base);;\n\tint ymax=base.size();\n\tint xmax=base[0].size();\n\tret=base;\n\tfor(int i=0;i<ymax;i++){\n\t\tfor(int j=0;j<xmax;j++){\n\t\t\tif(uni[i][j])ret[i][j]=color;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint score(vector< vector<int> >& base){\n\tvector< vector<bool> > get=getunion(base);\n\tint ymax=get.size();\n\tint xmax=get[0].size();\n\tint ret=0;\n\tfor(int i=0;i<ymax;i++){\n\t\tfor(int j=0;j<xmax;j++){\n\t\t\tif(get[i][j])ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint cal(vector< vector<int> >& base,int target,int count){\n\tif(count==1){\n\t\treturn score(ccolor(base,target));\n\t}else{\n\t\tvector< vector<int> > cald;\n\t\tint max=0,get;\n\t\t// 最大色数指定\n\t\tfor(int i=1;i<7;i++){\n\t\t\tif(i!=base[0][0]){\n\t\t\t\tcald=ccolor(base,i);\n\t\t\t\tget=cal(cald,target,count-1);\n\t\t\t\tif(get>max)max=get;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n\nint main(){\n\tint xsize,ysize,target;\n\tvector< vector<int> > base;\n\twhile(true){\n\t\tcin>>xsize>>ysize>>target;\n\t\tif(xsize==0)break;\n\t\tbase.resize(ysize);\n\t\tfor(int i=0;i<ysize;i++){\n\t\t\tbase[i].resize(xsize);\n\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\tcin>>base[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<cal(base,target,5)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint p[10][10], q[10][10], h, w, c, res = 0;\nbool used[10][10];\nvoid dfs(int x, int y, int co) {\n\t//cout << \"xy:\" << x << \" \" << y << endl;\n\tused[y][x] = true;\n\tREP(i, 4) {\n\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\tif(IN(0, w, nx) && IN(0, h, ny) && !used[ny][nx] && q[y][x] == q[ny][nx]) {\n\t\t\tdfs(nx, ny, co);\n\t\t}\n\t}\n\tq[y][x] = co;\n}\n\nvoid dfs1(int x, int y, int co) {\n\t//cout << x << \" \" << y << endl;\n\tused[y][x] = true;\n\tREP(i, 4) {\n\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\tif(IN(0, w, nx) && IN(0, h, ny) && !used[ny][nx] && q[y][x] == q[ny][nx]) {\n\t\t\tdfs1(nx, ny, co);\n\t\t\tres++;\n\t\t}\n\t}\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tcin >> h >> w >> c;\n\t\tif(!h && !w && !c) break;\n\t\tREP(i, h) REP(j, w) cin >> p[i][j];\n\t\tint ans = -INF;\n\t\tFOR(i1, 1, 7) FOR(i2, 1, 7) FOR(i3, 1, 7) FOR(i4, 1, 7) {\n\t\t\t//cout << \"i:\" << i1 << \" \" << i2 << \" \" << i3 << \" \" << i4 << endl;\n\t\t\tREP(i, h) REP(j, w) q[i][j] = p[i][j];\n\t\t\t//cout << \"a\" << endl;\n\t\t\tREP(i, h) REP(j, w) used[i][j] = false;\n\t\t\tdfs(0, 0, i1);\n\t\t\t/*REP(i, h) {\n\t\t\t\tREP(j, w) {\n\t\t\t\t\tcout << q[i][j] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\t//cout << \"b\" << endl;\n\t\t\tREP(i, h) REP(j, w) used[i][j] = false;\n\t\t\tdfs(0, 0, i2);\n\t\t\t/*REP(i, h) {\n\t\t\t\tREP(j, w) {\n\t\t\t\t\tcout << q[i][j] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\t//cout << \"c\" << endl;\n\t\t\tREP(i, h) REP(j, w) used[i][j] = false;\n\t\t\tdfs(0, 0, i3);\n\t\t\t/*REP(i, h) {\n\t\t\t\tREP(j, w) {\n\t\t\t\t\tcout << q[i][j] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\t//cout << \"d\" << endl;\n\t\t\tREP(i, h) REP(j, w) used[i][j] = false;\n\t\t\tdfs(0, 0, i4);\n\t\t\t/*REP(i, h) {\n\t\t\t\tREP(j, w) {\n\t\t\t\t\tcout << q[i][j] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\t//cout << \"e\" << endl;\n\t\t\tREP(i, h) REP(j, w) used[i][j] = false;\n\t\t\tdfs(0, 0, c);\n\t\t\t//cout << \"f\" << endl;\n\t\t\t//if(i1 == 6 && i2 == 3 && i3 == 4 && i4 == 2) {\n\t\t\t\t/*REP(i, h) {\n\t\t\t\t\tREP(j, w) {\n\t\t\t\t\t\tcout << q[i][j] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}*/\n\t\t\t//}\n\t\t\tREP(i, h) REP(j, w) used[i][j] = false;\n\t\t\tres = 1;\n\t\t\tdfs1(0, 0, c);\n\t\t\tans = max(ans, res);\n\t\t\t//cout << \"ans:\" << ans << endl;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int MAX_H = 10;\nconst int MAX_W = 10;\nconst int C = 5;\nint h, w, c;\nint p[MAX_H][MAX_W];\nint used[MAX_H][MAX_W];\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < h && 0 <= hy && hy < w; }\n\nint dfs(int color)\n{\n  int ret = 0;\n  int prev = p[0][0];\n  stack<pair<int, int> > st;\n  rep(i, h) rep(j, w) used[i][j] = 0;\n  p[0][0] = color;\n  used[0][0] = 1;\n  st.push(make_pair(0, 0));\n  while(!st.empty()){\n    pair<int, int> here = st.top();  st.pop();\n    int hx = here.first;\n    int hy = here.second;\n    ret += 1;\n    rep(k, 4){\n      int nx = hx + dx[k];\n      int ny = hy + dy[k];\n      if(!check(nx, ny)) continue;\n      if(used[hx][hy] == 2){\n        if(!used[nx][ny] && p[nx][ny] == color){\n          used[nx][ny] = 2;\n          st.push(make_pair(nx, ny));\n        }\n        continue;\n      }\n      if(!used[nx][ny] && p[nx][ny] == color){\n        used[nx][ny] = 2;\n        st.push(make_pair(nx, ny));\n      }\n      if(!used[nx][ny] && p[nx][ny] == prev){\n        p[nx][ny] = color;\n        used[nx][ny] = 1;\n        st.push(make_pair(nx, ny));\n      }\n    }\n  }\n  return ret;\n}\n\nint solve(int cnt)\n{\n  int ret = 0;\n  int prev[MAX_H][MAX_W];\n  rep(i, h) rep(j, w) prev[i][j] = p[i][j];\n  if(cnt){\n    rep(k, 6){\n      dfs(k + 1);\n      ret = max(ret, solve(cnt - 1));\n      rep(i, h) rep(j, w) p[i][j] = prev[i][j];\n    }\n    return ret;\n  }\n  else return dfs(c);\n}\n\nint main()\n{\n  while(cin >> h >> w >> c, h){\n    rep(i, h) rep(j, w) cin >> p[i][j];\n    cout << solve(C - 1) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h,w,c;\nint panel[10][10], sub[10][10];\nvector<int> seq;\nbool vis[10][10];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint dfs(int y, int x, int col){\n  if(vis[y][x])return 0;\n  vis[y][x] = true;\n\n  int res = 1;\n  for(int i=0;i<4;i++){\n    int ny = y+dy[i], nx = x+dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || panel[ny][nx] != panel[0][0])continue;\n    res += dfs(ny,nx,col);\n  }\n\n  panel[y][x] = col;\n  return res;\n}\n\nint sim(void){\n  int res = 0;\n  for(int i=0;i<5;i++){\n    memset(vis,0,sizeof(vis));\n    dfs(0,0,seq[i]);\n  }\n  memset(vis,0,sizeof(vis));\n  return dfs(0,0,0);\n}\n\nint rec(int depth){\n  if(depth == 5){\n    if(seq[depth-1] != c)return 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)panel[i][j] = sub[i][j];\n    }\n    int res = sim();\n    return res;\n  }\n\n  int res = 0;\n  for(int i=1;i<=6;i++){\n    seq.push_back(i);\n    res = max(res, rec(depth+1));\n    seq.pop_back();\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> h >> w >> c, h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> sub[i][j];\n    }\n    cout << rec(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int c, vector<int> v, vector<vector<int>> &vv)\n{\n    v.push_back(c);\n    if (v.size() == 6)\n    {\n        vv.push_back(v);\n        return;\n    }\n    for (int i = 1; i <= 6; i++)\n    {\n        auto x = v;\n        if (i == c)\n            continue;\n        dfs(i, x, vv);\n    }\n}\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nint main()\n{\n    int H, W, C;\n    while (cin >> H >> W >> C, H | W | C)\n    {\n        vector<vector<int>> P(H, vector<int>(W));\n        for (int i = 0; i < H; i++)\n            for (int j = 0; j < W; j++)\n                cin >> P[i][j];\n        int sclr = P[0][0];\n        vector<vector<int>> orders;\n        dfs(sclr, vector<int>(), orders);\n        int res = 0;\n        for (auto v : orders)\n        {\n            if(v.back()!=C)\n                continue;\n            auto CP = P;\n            int sz = 0;\n            for (int k = 1; k < v.size(); k++)\n            {\n                int c = v[k];\n                queue<pair<int, int>> que;\n                que.push(make_pair(0, 0));\n                int sc = CP[0][0];\n                int tmp = 0;\n                while (!que.empty())\n                {\n                    auto p = que.front();\n                    que.pop();\n                    int x = p.first, y = p.second;\n                    CP[y][x] = c;\n                    for (int i = 0; i < 4; i++)\n                    {\n                        int nx = x + dx[i], ny = y + dy[i];\n                        if (nx >= 0 && nx < W && ny >= 0 && ny < H)\n                        {\n                            if (CP[ny][nx] == sc)\n                            {\n                                CP[ny][nx] = c;\n                                que.push(make_pair(nx, ny));\n                            }\n                        }\n                    }\n                }\n            }\n            queue<pair<int, int>> que;\n            que.push(make_pair(0, 0));\n            int sc = CP[0][0];\n            while (!que.empty())\n            {\n                auto p = que.front();\n                que.pop();\n                int x = p.first, y = p.second;\n                CP[y][x] = 0;\n                sz++;\n                for (int i = 0; i < 4; i++)\n                {\n                    int nx = x + dx[i], ny = y + dy[i];\n                    if (nx >= 0 && nx < W && ny >= 0 && ny < H)\n                    {\n                        if (CP[ny][nx] == sc)\n                        {\n                            CP[ny][nx] = 0;\n                            que.push(make_pair(nx, ny));\n                        }\n                    }\n                }\n            }\n            res = max(res, sz);\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf=1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,c,out=0;\nvvi w;\nvoid f(int x,int y,int r){\n    w[x][y]=0;\n    rep(i,4){\n        int nx=x+dx[i];\n        int ny=y+dy[i];\n        if(nx<0||ny<0||nx>=n||ny>=m)continue;\n        if(w[nx][ny]==r)f(nx,ny,r);\n    }\n}\nvoid F(vvi in,int a){\n    if(a==5){\n        w=in;\n        int co=0;\n        if(c==in[0][0])f(0,0,in[0][0]);\n        rep(i,n)rep(j,m)co+=!w[i][j];\n        out=max(out,co);\n    }else{\n        rep(q,6){\n            w=in;\n            f(0,0,in[0][0]);\n            rep(i,n)rep(j,m)if(w[i][j]==0)w[i][j]=q+1;\n            F(w,a+1);\n        }\n    }\n}\nsigned main(){\n    while(cin>>n>>m>>c,n){\n        vvi in(n,vi(m));\n        rep(i,n)rep(j,m)cin>>in[i][j];\n        out=0;\n        F(in,0);\n        cout<<out<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dx[4] = {1, 0 ,-1, 0};\nint dy[4] = {0 ,-1, 0, 1};\nint h, w, c;\nbool used[10][10];\nint dfs(vector<vector<int> > &grid, int x, int y, int p, int d) {\n  int res = 1;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(0 <= nx && nx < w &&\n       0 <= ny && ny < h &&\n       used[ny][nx] == false && \n       grid[ny][nx] == p){\n      grid[ny][nx] = d;\n      used[ny][nx] = true;\n      res += dfs(grid, nx, ny, p, d);\n    }\n  }\n  return res;\n}\n\nint solve(vector<vector<int> > &grid, vector<int> &change, int depth){\n  int res = 0;\n  if(depth == 4){\n    vector<vector<int> > tmp = grid;\n    for (int i = 0; i < 5; i++) {\n      memset(used, 0, sizeof(used));\n      int a = grid[0][0];\n      grid[0][0] = change[i];\n      if(a == change[i])continue;\n      res = max(res, dfs(grid, 0, 0, a, change[i]));\n    }\n    memset(used, 0, sizeof(used));\n    used[0][0] = true;\n    res = max(res, dfs(grid, 0, 0, change[4], change[4]));\n    memset(used, 0, sizeof(used));\n    grid = tmp;\n    return res;\n  }\n  for (int i = 1; i <= 6; i++) {\n    change[depth] = i;\n    res = max(res, solve(grid, change, depth + 1));\n  }\n  return res;\n}\n\n\nint main(int argc, char *argv[]){\n  while(cin >> h >> w >> c, c){\n    vector<vector<int> >grid(h, vector<int>(w, 0));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n      }\n    }\n    vector<int> change(5, 0);\n    change[4] = c;\n    std::cout << solve(grid, change, 0) << std::endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n \nusing namespace std;\n\nvoid changepanel(int ***p, int px, int py, int newc, int t);\nint count(int ***p, int t, int color, int x, int y);\nvoid simulate(int ***p, int t);\nbool isedge(int ***p, int x, int y, int t);\n\nint h, w, c;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint ans;\n\nbool ischecked[8][8];\nbool ischanged[8][8];\nbool iscounted[8][8];\n\nint main()\n{\n    while(1){\n        cin >> h >> w >> c;\n        if(h == 0) break;\n        ans = 0;\n        int ***panel = new int**[h];\n        for(int i = 0; i < h; i++) panel[i] = new int*[w];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                panel[i][j] = new int[6];\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> panel[i][j][0];\n            }\n        }\n        simulate(panel, 1);\n        cout << ans << endl;\n        delete[] panel;\n    }\n    return 0;\n}\n\nvoid changepanel(int ***p, int px, int py, int newc, int t)\n{\n    int nextx, nexty;\n    int beforecolor = p[px][py][t];\n    p[px][py][t] = newc;\n    ischanged[px][py] = true;\n    for(int i = 0; i < 4; i++){\n        nextx = px + dx[i];\n        nexty = py + dy[i];\n        if(nextx >= h || nextx < 0 || nexty >= w || nexty < 0) continue;\n        if(p[nextx][nexty][t] == beforecolor && !ischanged[nextx][nexty]) changepanel(p, nextx, nexty, newc, t);\n    }\n    return;\n}\n\nint count(int ***p, int t, int color, int x, int y)\n{\n    int ans = 0;\n    if(iscounted[x][y]) ans++;\n    for(int i = 0; i < 4; i++){\n        int nextx = x + dx[i], nexty = y + dy[i];\n        if(nextx >= h || nextx < 0 || nexty >= w || nexty < 0) continue;\n        else if(p[nextx][nexty][t] == color && !iscounted[nextx][nexty]){\n            iscounted[nextx][nexty] = true;\n            ans += count(p, t, color, nextx, nexty);\n        }else if(p[nextx][nexty][t] == c && !iscounted[nextx][nexty]){\n            iscounted[nextx][nexty] = true;\n            ans += count(p, t, c, nextx, nexty);\n        }\n    }\n    return ans;\n}\n\nvoid simulate(int ***p, int t)\n{\n    if(w == 1 && h == 1){\n        ans = 1;\n        return;\n    }\n    if(t == 5) {\n        // for(int i = 0; i < h; i++){\n            // for(int j = 0; j < w; j++){\n                // cout << \" \" << p[i][j][t - 1];\n            // }\n       //     cout << endl;\n        // }\n        // cout << endl;\n        for(int i = 1; i < 7; i++){\n            for(int j = 0; j < h; j++){\n                for(int k = 0; k < w; k++){\n                    iscounted[j][k] = false;\n                }\n            }\n            if(p[0][0][t] == i) iscounted[0][0] = true;\n            int a = 0;\n            a = count(p, t - 1, i, 0, 0);\n            // cout << a << endl;\n            ans = max(ans, a);\n            }\n            // cout << ans << endl;\n        return;\n    }\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            p[i][j][t] = p[i][j][t - 1];\n        }\n    }\n    // for(int i = 0; i < h; i++){\n        // for(int j = 0; j < w; j++){\n            // cout << \" \" << p[i][j][t];\n            // }\n        // cout << endl;\n    // }\n    // cout << endl;\n    int x = 0, y = 0;\n    while(1){\n        // cout << x << \" \" << y << endl;\n        if(y == w) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                ischecked[i][j] = false;\n                ischanged[i][j] = false;\n            }\n        }\n        ischecked[x][y] = true;\n        if(p[x][y][t] != p[0][0][t] && isedge(p, x, y, t)){\n            for(int i = 0; i < h; i++){\n                for(int j = 0; j < w; j++){\n                    p[i][j][t] = p[i][j][t - 1];\n                }\n            }\n            // パネルを一つ前の状態に戻しておく\n            int newc = p[x][y][t];\n            changepanel(p, 0, 0, newc, t);\n            simulate(p, t + 1);\n        } else {\n            x++;\n            if(x == h){\n                y++;\n                x = 0;\n            }\n        }\n    }\n    simulate(p, t + 1);\n}\n// あるパネルについて、隣り合ってるパネルの色以外の色でぬりかえることは無意味\n\nbool isedge(int ***p, int x, int y, int t)\n{\n    if(x == 0 && y == 0) return true;\n    bool ans = false;\n    for(int i = 0; i < 4; i++){\n        int nextx = x + dx[i];\n        int nexty = y + dy[i];\n        if(nextx >= h || nextx < 0 || nexty >= w || nexty < 0) continue;\n        if(p[nextx][nexty][t] == p[0][0][t] && !ischecked[nextx][nexty]){\n            ischecked[nextx][nexty] = true;\n            ans = isedge(p, nextx, nexty, t);\n            if(ans) break;\n        }\n    }\n    return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint w,h,Col;\ntypedef pair<int,int> C;\ntypedef vector<vector<int> > P;\nP V;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint res;\n\nvoid on(P N,int count,int c){\n\t\n\tif(count==6) return;\n\tif(count==4)\n\t\tc=Col;\n\n\tint nc=N[0][0];\n\tqueue<C> Q;\n\tQ.push(make_pair(0,0));\n\tbool used[8][8];\n\tmemset(used,false,sizeof(used));\n\n\tint tres=0;\n\twhile(!Q.empty()){\n\t\tC now=Q.front();\n\t\tQ.pop();\n\t\tif(used[now.first][now.second]) continue;\n\t\tused[now.first][now.second]=true;\n\t\tN[now.first][now.second]=c;\n\t\ttres++;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint ny=now.first+dy[r],nx=now.second+dx[r];\n\t\t\tif(ny<0 || nx<0 || ny>=h || nx>=w) continue;\n\t\t\tif(N[ny][nx]==nc)\n\t\t\t\tQ.push(make_pair(ny,nx));\n\t\t}\n\t\tres=max(res,tres);\n\t}\n\n\tfor(int i=1;i<=6;i++)\n\t\ton(N,count+1,i);\n}\n\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tV.resize(h);\n\n\tfor(int y=0;y<h;y++)\n\t\tfor(int x=0;x<w;x++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tV[y].push_back(t);\n\t\t}\n\t\n\tfor(int i=1;i<=6;i++){\n\t\t on(V,0,i);\n\t}\n\n\tcout<<res<<endl;\n\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w>>Col){\n\t\tif(w==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntemplate <typename T>\nclass UF{\npublic:\n\tvector<T> par,rank;\n\n\tUF(long long n){\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor(T i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tT find(T x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x]=find(par[x]);\n\t}\n\n\tvoid unite(T x, T y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(T x, T y){\n\t\treturn find(x)==find(y);\n\t}\n\n};\n\nint dx[]={0, 1,0,-1};\nint dy[]={-1,0,1, 0};\n\nint main()\n{\n\tint h,w,c;\n\twhile(cin>>h>>w>>c,h){\n\n\t\tvector<vector<int> > table(h,vector<int>(w,0)),table2;\n\n\n\n\n\t\tfor(int i=0;i<h;i++){\t\n\t\t\tfor(int j=0;j<w;j++) cin>>table[i][j];\n\t\t}\n\t\t\t\t\n\t\ttable2=table;\n\t\t\n\t\t//cout<<\"init end\"<<endl;\n\t\t\n\t\tlong long res=0;\n\t\t//4????±???????\n\t\tfor(long long bit=0;bit<6LL*6LL*6LL*6LL;bit++){\n\t\t\t\n\t\t\ttable=table2;\n\t\t\tUF<long long> uf(10000);\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ny=i+dy[k],nx=j+dx[k];\n\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && table[i][j]==table[ny][nx]){\n\t\t\t\t\t\t\tuf.unite(i*w+j,ny*w+nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t\tlong long x=bit;\n\t\t\t\n\t\t\t//???????????????\n\t\t\tvector<int> vc(5);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tvc[i]=x%6;\n\t\t\t\tvc[i]++;\n\t\t\t\tx/=6;\n\t\t\t}\n\t\t\t//??????????????????\n\t\t\tvc[4]=c;\n\t\t\t\t\t\t\n\t\t\t//cout<<\"set order\"<<endl;\n\t\t\t\t\t\t\n\t\t\tfor(int i=0;i<5;i++){\n\n\t\t\t\t//?????´??°\n\t\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t\tif(uf.same(0,j*w+k)){\n\t\t\t\t\t\t\ttable[j][k]=vc[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//???????????????\n\t\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(uf.same(0,j*w+k)){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\t\t\t\t\tint ny=j+dy[d],nx=k+dx[d];\n\t\t\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && table[j][k]==table[ny][nx]){\n\t\t\t\t\t\t\t\t\tuf.unite(ny*w+nx,0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\n\t\t\t}\n\n\t\t\tlong long cnt=0;\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t//(0,0)??¨??????????????????\n\t\t\t\t\tif(uf.same(j*w+k,0)) cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tif(res<cnt){\n\t\t\t\t//cout<<bit<<endl;\n\t\t\t\tres=cnt;\n/*\t\t\t\t\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++) cout<<table[i][j]<<\" \";\n\t\t\t\t\tcout<<endl<<endl;\n\t\t\t\t}\n*/\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tcout<<res<<endl;\n\n\t}\n\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w, c;\nvector<vector<int>> grid;\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nvector<vector<int>> change(const vector<vector<int>>& g, int color) {\n    vector<vector<int>> v = g;\n    vector<pair<int, int>> vertices;\n    bool visited[8][8] = {false}; \n    queue<pair<int, int>> que;\n    que.push(make_pair(0, 0));\n    int target = v[0][0];\n    while (!que.empty()) {\n        auto vec = que.front();\n        que.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = vec.first + dx[i];\n            int ny = vec.second + dy[i];\n            if (0 <= nx && nx < w && 0 <= ny && ny < h \n                && !visited[ny][nx] && v[ny][nx] == target) {\n                visited[ny][nx] = true;\n                vertices.push_back(make_pair(nx, ny));\n                que.push(make_pair(nx, ny));\n            }\n        }\n    }\n    v[0][0] = color;\n    for (auto ver : vertices) {\n        v[ver.second][ver.first] = color;\n    }\n    return v;\n}\n\nint count(const vector<vector<int>>& g) {\n    int count = 1;\n    bool visited[8][8] = {false}; \n    visited[0][0] = true;\n    queue<pair<int, int>> que;\n    que.push(make_pair(0, 0));\n    int target = g[0][0];\n    while (!que.empty()) {\n        auto vec = que.front();\n        que.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = vec.first + dx[i];\n            int ny = vec.second + dy[i];\n            if (0 <= nx && nx < w && 0 <= ny && ny < h \n                && !visited[ny][nx] && g[ny][nx] == target) {\n                visited[ny][nx] = true;\n                que.push(make_pair(nx, ny));\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint solve() {\n    int ans = 0;\n    queue<pair<vector<vector<int>> , int>> que;\n    que.push(make_pair(grid, 0));\n    while(!que.empty()) {\n        auto front = que.front();\n        que.pop();\n        auto g = front.first;\n        int depth = front.second;\n        if (depth < 4) {\n            for (int i = 1; i < 7; ++i) {\n                auto tmp_grid = change(g, i);\n                que.push(make_pair(tmp_grid, depth+1));\n            }\n        }\n        else {\n            auto tmp_grid = change(g, c);\n            ans = max(ans, count(tmp_grid));\n        }\n    }\n    cout<<ans<<endl;\n}\n\nint main (int argc, char *argv[]) {\n    while (cin>>h>>w>>c, h||w||c) {\n        for (int y = 0; y < h; ++y) {\n            vector<int> tmp;\n            for (int x = 0; x < w; ++x) {\n                int t;\n                cin>>t;\n                tmp.push_back(t);\n            }\n            grid.push_back(tmp);\n        }\n        solve();\n        grid.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n\nusing namespace std;\n\nint h, w, c;\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nint saiki(vector<vector<int>>data, int n,int c)\n{\n\tif (!n)\n\t{\n\t\tvector<pair<int, int>>p;\n\t\tint memo = data[1][1];\n\t\tint count = 0;\n\t\tp.push_back(pair < int, int > {1, 1});\n\t\twhile (p.size())\n\t\t{\n\t\t\tint x_=p.back().first,y_=p.back().second;\n\t\t\tp.pop_back();\n\t\t\tcount++;\n\t\t\tfor (size_t i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif (memo == data[x_ + dx[i]][y_ + dy[i]])\n\t\t\t\t{\n\t\t\t\t\tdata[x_ + dx[i]][y_ + dy[i]] = 100;\n\t\t\t\t\t//data[x_ + dx[i]][y_ + dy[i]] = 100;\n\t\t\t\t\tp.push_back(pair < int, int > {x_ + dx[i], y_ + dy[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tint retur = 0;\n\n\tif (n == 1)\n\t{\n\t\tint i = c;\n\t\tif (data[1][1] != i)\n\t\t{\n\t\t\tvector<vector<int>>data2 = data;\n\t\t\tvector<pair<int, int>>p;\n\t\t\tint memo = data[1][1];\n\t\t\tdata2[1][1] = i;\n\t\t\tp.push_back(pair < int, int > {1, 1});\n\t\t\twhile (p.size())\n\t\t\t{\n\t\t\t\tint x_ = p.back().first, y_ = p.back().second;\n\t\t\t\tp.pop_back();\n\t\t\t\tfor (size_t j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tif (memo == data2[x_ + dx[j]][y_ + dy[j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tdata2[x_ + dx[j]][y_ + dy[j]] = i;\n\t\t\t\t\t\tp.push_back(pair < int, int > {x_ + dx[j], y_ + dy[j]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tretur = max(retur, saiki(data2, n - 1,c));\n\t\t\tdata2.clear();\n\t\t}\n\t\treturn retur;\n\t} else\n\t{\n\t\tfor (size_t i = 1; i <= 6; i++)\n\t\t{\n\t\t\tif (data[1][1] != i)\n\t\t\t{\n\t\t\t\tvector<vector<int>>data2 = data;\n\t\t\t\tvector<pair<int, int>>p;\n\t\t\t\tint memo = data[1][1];\n\t\t\t\tdata2[1][1] = i;\n\t\t\t\tp.push_back(pair < int, int > {1, 1});\n\t\t\t\twhile (p.size())\n\t\t\t\t{\n\t\t\t\t\tint x_ = p.back().first, y_ = p.back().second;\n\t\t\t\t\tp.pop_back();\n\t\t\t\t\tfor (size_t j = 0; j < 4; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (memo == data2[x_ + dx[j]][y_ + dy[j]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[x_ + dx[j]][y_ + dy[j]] = i;\n\t\t\t\t\t\t\tp.push_back(pair < int, int > {x_ + dx[j], y_ + dy[j]});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tretur = max(retur, saiki(data2, n - 1,c));\n\t\t\t\tdata2.clear();\n\t\t\t}\n\t\t}\n\t\treturn retur;\n\t}\n}\n\nint main()\n{\n\twhile (cin >> h >> w >> c, h || w || c)\n\t{\n\t\tvector<vector<int>>data;\n\t\tdata.resize(h+2);\n\t\tdata[0].resize(w + 2);\n\t\tdata[h + 1].resize(w + 2);\n\t\tfor (size_t i = 1; i <= h; i++)\n\t\t{\n\t\t\tdata[i].resize(w + 2);\n\t\t\tfor (size_t j = 1; j <= w; j++)\n\t\t\t{\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = saiki(data, 5, c);\n\t\tcout << (ans==1?1:ans-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\nconst int INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\ntypedef pair<int, int> P;\n\nint h, w, c;\nint d[10][10];\n\nint dfs(int n){\n\tint ret = 0;\n\tif (n == 6){\n\t\tif (d[0][0] != c)return 0;\n\t\tqueue<P> q;\n\t\tq.push(P(0, 0));\n\t\tbool f[10][10]; clr(f);\n\t\tf[0][0] = true;\n\t\tret = 1;\n\t\twhile (q.size()){\n\t\t\tint y = q.front().first, x = q.front().second;\n\t\t\tq.pop();\n\t\t\trep(i, 4){\n\t\t\t\tint ty = y + dy[i], tx = x + dx[i];\n\t\t\t\tif (cheak(tx, ty, w, h) && d[ty][tx] == c && !f[ty][tx]){\n\t\t\t\t\tq.push(P(ty, tx));\n\t\t\t\t\tf[ty][tx] = true;\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tFor(i, 1, 7){\n\n\t\tint pr = d[0][0];\n\t\tqueue<P> q;\n\t\tq.push(P(0, 0));\n\t\tbool f[10][10]; clr(f);\n\t\tf[0][0] = true;\n\t\td[0][0] = i;\n\t\tint count = 0;\n\t\twhile (q.size()){\n\t\t\tint y = q.front().first, x = q.front().second;\n\t\t\tq.pop();\n\t\t\trep(j, 4){\n\t\t\t\tint ty = y + dy[j], tx = x + dx[j];\n\t\t\t\tif (cheak(tx, ty, w, h) && !f[ty][tx]){\n\t\t\t\t\tif (d[ty][tx] == pr){\n\t\t\t\t\t\tq.push(P(ty, tx));\n\t\t\t\t\t\tf[ty][tx] = true;\n\t\t\t\t\t\td[ty][tx] = i;\n\t\t\t\t\t}else\n\t\t\t\t\tif (d[ty][tx] == i){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count)ret = max(ret,dfs(n + 1));\n\n\t\trep(y, h)rep(x, w){\n\t\t\tif (f[y][x])d[y][x] = pr;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\twhile (cin >> h >> w >> c && (h || w || c)){\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> d[y][x];\n\t\t}\n\t\tcout << dfs(1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint a[10][10],ans,t,x[65],y[65],e[5][3],h,w,c;\n\nint bfs(){\n\tint h=0,nx,ny;\n\tbool bj[10][10]={false};\n\tx[1]=1;\n\ty[1]=1;\n\tbj[1][1]=true;\n\tt=1;\n\twhile (h<t){\n\t\th++;\n\t\tfor (int i=1;i<=4;i++){\n\t\t\tnx=x[h]+e[i][1];\n\t\t\tny=y[h]+e[i][2];\n\t\t\tif (a[nx][ny]==a[1][1]&&!bj[nx][ny]){\n\t\t\t\tbj[nx][ny]=true;\n\t\t\t\tt++;\n\t\t\t\tx[t]=nx;\n\t\t\t\ty[t]=ny;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int k){\n\tif (k==6){\n\t\tif (a[1][1]!=c) return 0;\n\t\tbfs();\n\t\tif (t>ans) ans=t;\n\t\treturn 0;\n\t}\n\tbfs();\n\tint nt,nx[65],ny[65],nc;\n\tnc=a[1][1];\n\tnt=t;\n\tfor (int i=1;i<=t;i++){\n\t\tnx[i]=x[i];\n\t\tny[i]=y[i];\n\t}\n\tfor (int i=1;i<=6;i++)if (i!=nc){\n\t\tfor (int j=1;j<=nt;j++) a[nx[j]][ny[j]]=i;\n\t\tdfs(k+1);\n\t}\n\tfor (int j=1;j<=nt;j++) a[nx[j]][ny[j]]=nc;\n\treturn 0;\n}\n\nint main(){\n\te[1][1]=1;e[2][1]=-1;e[3][2]=1;e[4][2]=-1;\n\tscanf(\"%d%d%d\",&h,&w,&c);\n\twhile (h!=0){\n\t\tfor (int i=0;i<=9;i++) for (int j=0;j<=9;j++)a[i][j]=0;\n\t\tfor (int i=1;i<=h;i++)\n\t\t\tfor (int j=1;j<=w;j++)scanf(\"%d\",&a[i][j]);\n\t\tans=0;\t\n\t\tdfs(1);\t\n\t\tprintf(\"%d\\n\",ans);\n\t\tscanf(\"%d%d%d\",&h,&w,&c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/06/21 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint cnt_max;\nint C;\n\nvoid DFS2(int q[10][10], int y, int x, int b, int c)\n{\n\tif(q[y][x]!=b)\n\t\treturn;\n\n\tq[y][x] = c;\n\n\tDFS2(q, y, x+1, b, c);\n\tDFS2(q, y+1, x, b, c);\n\tDFS2(q, y, x-1, b, c);\n\tDFS2(q, y-1, x, b, c);\n}\n\nvoid DFS(int n, const int p[10][10], int c)\n{\n\tint q[10][10];\n\tfor(int y=0; y<10; y++){\n\t\tfor(int x=0; x<10; x++){\n\t\t\tq[y][x] = p[y][x];\n\t\t}\n\t}\n\n\tDFS2(q, 1, 1, q[1][1], c);\n\t\n\tif(n>=5){\n\t\tif(c!=C)\n\t\t\treturn;\n\n\t\tDFS2(q, 1, 1, q[1][1], 7);\n\n\t\tint cnt = 0;\n\t\tfor(int y=0; y<10; y++){\n\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\tif(q[y][x]==7){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(cnt>cnt_max){\n\t\t\tcnt_max = cnt;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor(int cc=1; cc<=6; cc++){\n\t\tif(q[1][1]==cc)\n\t\t\tcontinue;\n\n\t\tDFS(n+1, q, cc);\n\t}\n}\n\nint main()\n{\n\twhile(true){\n\t\tint h, w;\n\t\tcin >> h >> w >> C;\n\n\t\tif(h==0&&w==0&&C==0)\n\t\t\tbreak;\n\n\t\tint p[10][10];\n\t\tfor(int y=0; y<10; y++){\n\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\tp[y][x] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int y=1; y<=h; y++){\n\t\t\tfor(int x=1; x<=w; x++){\n\t\t\t\tcin >> p[y][x];\n\t\t\t}\n\t\t}\n\n\t\tcnt_max = 0;\n\n\t\tfor(int c=1; c<=6; c++){\n\t\t\tif(p[1][1]==c)\n\t\t\t\tcontinue;\n\n\t\t\tDFS(1, p, c);\n\t\t}\n\n\t\tcout << cnt_max << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nint H, W, C;\n\nint count_panels(vvi& panels) {\n    int color = panels[0][0];\n    vvi G(H, vi(W, false));\n    queue<pii> que;\n    int cnt = 0;\n    que.push({0, 0});\n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        REP(i, 4) {\n            int sx = p.first + dx[i], sy = p.second + dy[i];\n            if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n                if (panels[sy][sx] == color) {\n                    if (!G[sy][sx]) {\n                        G[sy][sx] = true;\n                        cnt++;\n                        que.push({sx, sy});\n                    }\n                }\n            }\n        }\n    }\n    return cnt;\n}\n\nvoid dfs2(vvi& panels, int c1, int c2, int x, int y) {\n    panels[y][x] = c2;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (panels[sy][sx] == c1) {\n//                LOG(\"%d %d\\n\", sx, sy);\n                dfs2(panels, c1, c2, sx, sy);\n            }\n        }\n    }\n}\n\nvoid dfs(vvi& panels, int& ma, int depth) {\n    int c1 = panels[0][0];\n    if (depth == 4) {\n        if (c1 != C) {\n            vvi copy = panels;\n//            copy[0][0] = C;\n            dfs2(copy, c1, C, 0, 0);\n            ma = max(ma, count_panels(copy));\n        }\n    } else {\n        FOR(c2, 1, 7) {\n            if (c1 == c2) continue;\n            vvi copy = panels;\n//            copy[0][0] = c2;\n            dfs2(copy, c1, c2, 0, 0);\n            dfs(copy, ma, depth+1);\n        }\n    }\n}\n\nint main() {\n    while (cin >> H >> W >> C, H|W|C) {\n        vvi panels(H, vi(W));\n        REP(i, H) REP(j, W) {\n            cin >> panels[i][j];\n        }\n        int ma = 1;\n        dfs(panels, ma, 0);\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, f, a[9][9], b[9][9], g[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e; f++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tfor (int k = 1; k <= 6; k++) {\n\t\tif (d == 4) k = c;\n\t\tif (b[0][0] == k) {\n\t\t\tif (d == 4) break;\n\t\t\telse continue;\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) g[i][j] = b[i][j];\n\t\t}\n\t\tf = 0; rec(0, 0, k);\n\t\tret = max(ret, d != 4 ? max(f, solve(d + 1)) : f);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) b[i][j] = g[i][j];\n\t\t}\n\t\tif (d == 4) break;\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 左上の色を変える順番を全列挙\n// 列挙したものについて、それぞれシミュレート\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    while (true) {\n        int h, w, c;\n        cin >> h >> w >> c;\n        if (!(h || w || c)) break;\n\n        vector<vector<int>> p(h, vector<int>(w));\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> p[i][j];\n            }\n        }\n\n        //cout << \"input done\" << endl;\n        // 全列挙\n        auto enumaration = [](int c0, int c, vector<vector<int>> &res) -> void {\n            stack<pair<int, int>> stk;\n            for (int i = 1; i <= 6; ++i) {\n                if (i != c0) stk.emplace(0, i);\n            }\n            vector<int> tmp(5);\n            while (!stk.empty()) {\n                auto P = stk.top();\n                stk.pop();\n                if (P.first >= 5) {\n                    bool flg = true;\n                    for (int i = 1; i < 5; ++i) {\n                        if (tmp[i] == tmp[i - 1]) flg = false;\n                    }\n                    assert(flg);\n                    if (tmp.back() == c) res.push_back(tmp);\n                    continue;\n                }\n                tmp[P.first] = P.second;\n                for (int i = 1; i <= 6; ++i) {\n                    if (i != P.second) stk.emplace(P.first + 1, i);\n                }\n            }\n        };\n\n        vector<vector<int>> candidate;\n        enumaration(p[0][0], c, candidate);\n        //cout << candidate.size() << endl;\n\n        //cout << \"enumeration done\" << endl;\n\n        // それぞれに対してシミュレーション\n        static const int dx[] = {-1, 0, 1, 0};\n        static const int dy[] = {0, 1, 0, -1};\n        auto simulate = [&](vector<int> &op) -> int {\n            static int Panel[10][10];\n            static bool visited[10][10];\n            for (int i = 0; i < h; ++i) {\n                for (int j = 0; j < w; ++j) {\n                    Panel[i][j] = p[i][j];\n                    visited[i][j] = false;\n                }\n            }\n\n            for (int color : op) {\n                int prev = Panel[0][0];\n                stack<pair<int, int>> tsk;\n                assert(prev != color);\n                tsk.emplace(0, 0);\n                while (!tsk.empty()) {\n                    int x = tsk.top().first, y = tsk.top().second;\n                    tsk.pop();\n                    if (Panel[x][y] != prev) continue;\n                    //cout << x << \" \" << y << endl;\n                    Panel[x][y] = color;\n                    for (int i = 0; i < 4; ++i) {\n                        int nx = x + dx[i], ny = y + dy[i];\n                        if (nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n                        tsk.emplace(nx, ny);\n                    }\n                }\n            }\n            //cout << \"simullation done\" << endl;\n            int res = 0;\n            stack<pair<int, int>> tsk;\n            tsk.emplace(0, 0);\n            while (!tsk.empty()) {\n                int x = tsk.top().first, y = tsk.top().second;\n                tsk.pop();\n                if (visited[x][y] || Panel[x][y] != c) continue;\n                visited[x][y] = true;\n                ++res;\n                for (int i = 0; i < 4; ++i) {\n                    int nx = x + dx[i], ny = y + dy[i];\n                    if (nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n                    tsk.emplace(nx, ny);\n                }\n            }\n\n            return res;\n        };\n\n        int ans = 0;\n        for (vector<int> &cd : candidate) {\n            ans = max(ans, simulate(cd));\n        }\n\n        //cout << \"simulation done\" << endl;\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#define N 8\nusing namespace std;\nint h,w,c,p[N][N],d[N][N],t[N][N],change[5],ans;\nbool visited[N][N];\nvoid func(int);\nvoid func2(int,int);\n\nint main(){\n  while(1){\n    cin>>h>>w>>c;\n    if(!h&&!w&&!c) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>p[i][j];\n    ans=0;\n    change[4]=c;\n    func(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nvoid func(int x){\n  if(x==4){\n    int flag=0;\n    for(int i=0;i<4;i++)\n      if(change[i]==change[i+1]) flag=1;\n    if(!flag){\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++) d[i][j]=p[i][j];\n      for(int i=0;i<5;i++){\n\tfor(int j=0;j<h;j++)\n\t  for(int k=0;k<w;k++) visited[j][k]=false,t[j][k]=0;\n\tfunc2(0,0);\n\tfor(int j=0;j<h;j++)\n\t  for(int k=0;k<w;k++)\n\t    if(t[j][k]) d[j][k]=change[i];\n      }\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++) visited[i][j]=false,t[i][j]=0;\n      func2(0,0);\n      int cnt=0;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  if(t[i][j]) cnt++;\n      ans=max(ans,cnt);\n    }\n    return;\n  }\n  for(int i=1;i<=6;i++) change[x]=i,func(x+1);\n}\n\nvoid func2(int y,int x){\n  int dx[4]={0,1,0,-1};\n  int dy[4]={-1,0,1,0};\n  visited[y][x]=true;\n  t[y][x]=1;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(ny<0||nx<0||h<=ny||w<=nx||d[y][x]!=d[ny][nx]) continue;\n    if(visited[ny][nx]) continue;\n    func2(ny,nx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push\nusing namespace std;\n\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint anss=0;\n\nvoid play(int h, int w, int c,int mas[10][10],int cnt){\n    //cout << \"x\" << endl;\n    //cout << endl;\n    int con[10][10]={0};\n\n    int ans=0;\n\n    con[0][0] = 1;\n\n    queue < pair <int,int> > qu;\n\n    qu.pb(mp(0,0));\n\n    while(qu.size() > 0){\n        int xx = qu.front().xx;\n        int yy = qu.front().yy;\n\n        qu.pop();\n\n        for(int i = 0 ; i < 4 ; i++){\n            int xxx = xx + dx[i];\n            int yyy = yy + dy[i];\n\n            if(xxx >=0 && xxx < h && yyy >=0 && yyy < w){\n                if(mas[xxx][yyy] == mas[xx][yy] && con[xxx][yyy] == 0){\n                    con[xxx][yyy] = 1;\n                    qu.pb(mp(xxx,yyy));\n                }\n            }\n        }\n        //cout << qu.size() << endl;\n    }\n    for(int i = 0 ; i < h ; i++){\n        for(int j= 0 ; j < w ;j++){\n            if(con[i][j] == 1) ans++;\n        }\n    }\n\n    /*\n    for(int i = 0 ; i < h ; i++){\n        for(int j= 0 ; j < w ;j++){\n            cout << con[i][j] << \" \";\n        }\n\n        cout << \" | \";\n        for(int j= 0 ; j < w ;j++){\n            cout << mas[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n    if(cnt == 5){\n        if(mas[0][0] == c){\n            anss = max(anss,ans);\n        }\n        return;\n    }\n\n    int poss[10] = {0};\n\n    for(int i = 0 ; i < h ; i++){\n        for(int j = 0 ; j < w ; j++){\n            if(con[i][j] == 1){\n                for(int k = 0 ; k < 4 ; k++){\n                    int xx = i +dx[k];\n                    int yy = j + dy[k];\n\n                    if(xx >= 0 && xx < h && yy >=0 && yy < w){\n                        if(mas[xx][yy] != mas[i][j]) poss[mas[xx][yy]] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    int m[10][10];\n\n    for(int col = 1 ; col <= 6 ; col++){\n        for(int i = 0 ; i < h ; i++){\n            for(int j = 0 ; j < w ; j++){\n                m[i][j] = mas[i][j];\n            }\n        }\n\n        if(1){\n            for(int i = 0 ; i < h ; i++){\n                for(int j = 0 ; j < w ; j++){\n                    if(con[i][j] == 1) m[i][j] = col;\n                }\n            }\n\n            int cntt = cnt;\n            cntt++;\n            play(h,w,c,m,cntt);\n        }\n    }\n\n}\nmain(){\n    int h,w,c;\n\n    while(cin >> h >> w >> c,h!=0){\n        int mas[10][10];\n\n        for(int i = 0 ; i < h ; i++){\n            for(int j = 0 ; j < w ; j++){\n                cin >> mas[i][j];\n            }\n        }\n\n        anss = 0;\n        play(h,w,c,mas,0);\n\n        cout << anss << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint h, w, c, p[9][9], q[9][9];\nint id = 7;\n\nvoid change(int x, int y, int color){\n\tint first = p[x][y];\n\tp[x][y] = color * (-1);\n\tif (x < h - 1 && p[x + 1][y] == first)\n\t\tchange(x + 1, y, color);\n\tif (x > 0 && p[x - 1][y] == first)\n\t\tchange(x - 1, y, color);\n\tif (y < w - 1 && p[x][y + 1] == first)\n\t\tchange(x, y + 1, color);\n\tif (y > 0 && p[x][y - 1] == first)\n\t\tchange(x, y - 1, color);\n}\n\nvoid pabs(){\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tif (p[i][j] < 0)\n\t\t\tp[i][j] = p[i][j] * (-1);\n\t\t}\n\t}\n\n\n}\n\nvoid show(){\n\tcout << endl;\n\tfor (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t\tcout << p[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main()\n{\n\n\t//長方形サイズ，目標色の入力\n\twhile (cin >> h >> w >> c, (h || w || c)){\n\n\t\t//初期化\n\t\tfor (int i = 0; i < 9; i++){\n\t\t\tfor (int j = 0; j < 9; j++){\n\t\t\t\tp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t//色の入力\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> p[i][j];\n\t\t}\n\n\t\t//パネルをコピーしておく\n\t\tfor (int a = 0; a < h; a++){\n\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\tq[a][b] = p[a][b];\n\t\t\t}\n\t\t}\n\n\t\t//全パターン\n\n\t\tint max = 0;\n\t\tint counter;\n\t\tfor (int i = 1; i < 7; i++){\n\t\t\tfor (int j = 1; j < 7; j++){\n\t\t\t\tfor (int k = 1; k < 7; k++){\n\t\t\t\t\tfor (int l = 1; l < 7; l++){\n\t\t\t\t\t\tfor (int m = 1; m < 7; m++){\n\n\t\t\t\t\t\t\t//パネルを初期状態に戻す\n\t\t\t\t\t\t\tfor (int a = 0; a < h; a++){\n\t\t\t\t\t\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\t\t\t\t\t\tp[a][b] = q[a][b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//5回色塗り\n\t\t\t\t\t\t\tchange(0, 0, i);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, j);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, k);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, l);\n\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\tchange(0, 0, m);\n\t\t\t\t\t\t\tpabs();\n\n\t\t\t\t\t\t\t//集計\n\t\t\t\t\t\t\tfor (int i = 0; i < h; i++){\n\t\t\t\t\t\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\t\t\t\t\t\tif (p[i][j] == c){\n\t\t\t\t\t\t\t\t\t\tchange(i, j, ++id);\n\t\t\t\t\t\t\t\t\t\tpabs();\n\t\t\t\t\t\t\t\t\t\tcounter = 0;\n\t\t\t\t\t\t\t\t\t\tfor (int a = 0; a < h; a++){\n\t\t\t\t\t\t\t\t\t\t\tfor (int b = 0; b < w; b++){\n\t\t\t\t\t\t\t\t\t\t\t\tif (p[a][b] == id)\n\t\t\t\t\t\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (counter > max)\n\t\t\t\t\t\t\t\t\t\t\tmax = counter;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//出力\n\t\tcout << max << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint h,w;\nint p[8][8];\nint cp[8][8];\nint cnt[4];//最後の1回は色固定\nvoid cppanel()\n{\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t\tcp[i][j]=p[i][j];\n\t}\n}\n\nbool f[8][8];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nvoid dfs(int nowh,int noww,int nowcolor,int nuru)\n{\n\tf[nowh][noww]=true;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint nh=nowh+dx[i];\n\t\tint nw=noww+dy[i];\n\t\tif(nh>=0 && nh<h && nw>=0 && nw<w)\n\t\t{\n\t\t\tif(cp[nh][nw]==nowcolor && !f[nh][nw])\n\t\t\t\tdfs(nh,nw,nowcolor,nuru);\n\t\t}\n\t}\n\tcp[nowh][noww]=nuru;\n\treturn;\n}\n\nint main()\n{\n\tint c;\n\tint ans=0;\n\twhile(1)\n\t{\n\t\tcin>>h>>w>>c;\n\t\tif(h==0)\n\t\t\tbreak;\n\t\tc--;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tcin>>p[i][j];\n\t\t\t\tp[i][j]--;\n\t\t\t}\n\t\t}\n\t\tfill(cnt,cnt+4,0);\n\t\tans=0;\n\t\tfor(int bit=0;bit<1296;bit++)\n\t\t{\n\t\t\tcnt[0]++;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(cnt[i]==6)\n\t\t\t\t{\n\t\t\t\t\tcnt[i+1]++;\n\t\t\t\t\tcnt[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//順番に塗りつぶして調べる\n\t\t\tcppanel();\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\t//dfsで帰るがけ順に塗りつぶし\n\t\t\t\tfill(f[0],f[8],false);\n\t\t\t\tdfs(0,0,cp[0][0],cnt[i]);\n\t\t\t}\n\t\t\tfill(f[0],f[8],false);\n\t\t\tdfs(0,0,cp[0][0],c);\n\t\t\tfill(f[0],f[8],false);\n\t\t\tdfs(0,0,c,c);//これでついでに連結成分を調べる\n\t\t\tint tmp=0;\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t{\n\t\t\t\t\tif(f[i][j])\n\t\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=max(ans,tmp);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint h, w, c;\nint panel[8][8];\n\nclass node {\npublic:\n\tint panel[8][8], tmpPanel[8][8];\n\tint d;\n\tint area;\n\tnode(int src[8][8]){\n\t\tmemcpy(panel, src, sizeof(panel));\n\t\tmemcpy(tmpPanel, panel, sizeof(panel));\n\t\tgetArea(0, 0, panel[0][0]);\n\t\tarea = 0;\n\t\td = 0;\n\t}\n\tnode(int src[8][8], int i, int _d=0){\n\t\tmemcpy(panel, src, sizeof(panel));\n\t\tarea = 0;\n\t\tflip(0, 0, this->panel[0][0], i);\n\t\tmemcpy(tmpPanel, panel, sizeof(panel));\n\t\tgetArea(0, 0, i);\n\t\td = _d;\n\t}\n\tvoid flip(int x, int y, int c1, int c2) {\n\t\tthis->panel[x][y] = c2;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nextX = x + dx[i];\n\t\t\tint nextY = y + dy[i];\n\t\t\tif (0 <= nextX && nextX < w && 0 <= nextY && nextY < h && this->panel[nextX][nextY] == c1) {\n\t\t\t\tflip(nextX, nextY, c1, c2);\n\t\t\t}\n\t\t}\n\t}\n\tvoid getArea(int x, int y, int c) {\n\t\ttmpPanel[x][y] = -1;\n\t\tthis->area++;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nextX = x + dx[i];\n\t\t\tint nextY = y + dy[i];\n\t\t\tif (0 <= nextX && nextX < w && 0 <= nextY && nextY < h && this->tmpPanel[nextX][nextY] == c) {\n\t\t\t\tgetArea(nextX, nextY, c);\n\t\t\t}\n\t\t}\n\t}\n\tbool operator < (const node& o) const {\n\t\treturn this->area < o.area;\n\t}\n};\n\nvoid debug(node& n){\n\tcout << \"Debug===========================\" << endl;\n\tfor (int i = 0; i < 8; i++) {\n\t\tfor (int j = 0; j < 8; j++)\n\t\t\tcout << n.panel[j][i] << \" \";\n\t\tcout<< endl;\n\t}\n\tcout << n.area << endl;\n}\n\nint solve() {\n\tint maxArea = 0;\n\tnode root(panel);\n\tpriority_queue<node> q;\n\tq.push(root);\n\twhile (!q.empty()) {\n\t\tnode current = q.top();q.pop();\n\t\t//debug(current);\n\t\tif (current.panel[0][0] == c)\n\t\t\tmaxArea = max(maxArea, current.area);\n\t\tfor (int i = 1; i < 7; i++) {\n\t\t\tif (current.d + 1 == 6) continue;\n\t\t\tif (current.panel[0][0] == i) continue;\n\t\t\tif (current.d == 3 && i == c) continue;\n\t\t\tnode next(current.panel, i, current.d + 1);\n\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn maxArea;\n}\n\nint main() {\n\twhile (cin >> h >> w >> c, h || w || c) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> panel[j][i];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define rep(i,n) for(int i=0;i<(int)n;++i)\nint max(const int a, const int b) {\n  return a > b ? a : b ;\n}\n\nint H, W, C;\nint base[10][10];\nint copy[10][10], visit[10][10];\nconst int di[] = {1, -1, 0, 0};\nconst int dj[] = {0, 0, -1, 1};\n\nvoid rec(int base_color, int color, int i, int j) {\n  // printf(\">>%2d %2d %2d %2d\\n\", base_color, color, i, j);\n  if (visit[i][j]) return;\n  visit[i][j] = 1;\n  rep(z,4) {\n    int ni = i+di[z], nj = j+dj[z];\n    if (ni < 0 || nj < 0 || H <= ni || W <= nj) continue;\n    if (visit[ni][nj] || (base_color != copy[ni][nj])) continue;\n    if (color == copy[ni][nj]) continue;\n    copy[ni][nj] = color;\n    rec(base_color, color, ni, nj);\n  }\n}\n\nvoid update(int color) {\n  // memset(visit, 0, sizeof (visit));\n  rep(i,H) rep(j,W) visit[i][j] = 0;\n  int prev_color = copy[0][0];\n  copy[0][0] = color;\n  rec(prev_color, color, 0, 0);\n}\n\nvoid debug() {\n  rep(h,H) {\n    rep(w,W) printf(\"%2d\", copy[h][w]);\n    puts(\"\");\n  }\n}\n\nint t_ans = 0;\n\n\nvoid calc_rec(int i, int j) {\n  if (visit[i][j]) return;\n  t_ans++;\n  visit[i][j] = 1;\n  rep(z,4) {\n    int ni = i+di[z], nj = j+dj[z];\n    if (ni < 0 || nj < 0 || H <= ni || W <= nj) continue;\n    if (visit[ni][nj] || copy[ni][nj] != copy[i][j]) continue;\n    calc_rec(ni, nj);\n  }\n}\n\nint calc() {\n  memset(visit, 0, sizeof (visit));\n  t_ans = 0;\n  calc_rec(0, 0);\n  return t_ans;\n}\n\nint solve() {\n  int ans = 0;\n  rep(i,6) rep(j,6) rep(k,6) rep(l,6) {\n    if (i==j || j==k || k==l || l+1==C)\n      continue;\n    rep(h,H) rep(w,W) copy[h][w] = base[h][w];\n    int ch[5] = {i+1, j+1, k+1, l+1, C};\n    rep(z,5) {\n      update(ch[z]);\n      /* if (ch[0] == 6 && ch[1] == 3 && ch[2] == 4 && */\n      /*     ch[3] == 2 && ch[4] == 5) { */\n      /*   puts(\"\"); */\n      /*   debug(); */\n      /* } */\n    }\n    ans = max(ans,calc());\n  }\n  return ans;\n}\n\nint main() {\n  while(scanf(\"%d%d%d\", &H, &W, &C), H|W) {\n    rep(i,H) rep(j,W) scanf(\"%d\", base[i]+j);\n    printf(\"%d\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n, m) for (int i = (int) (n) ; i < (int) (m); i++)\n\nusing namespace std;\n\nvector<vector<int>> v;\nint h, w, c;\n\nbool init() {\n\tv.clear();\n\tcin >> h >> w >> c;\n\tif (h == 0) return false;\n\tv.resize(h, vector<int>(w));\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\treturn true;\n}\n\nint dfs2(int r, int c, vector<vector<int>>& a, int f, int t, vector<vector<int>>& H, int st = 0) {\n\tassert(f != t);\n\tif (r < 0 || c < 0 || r >= h || c >= w) return 0;\n\tif (st == 1 && a[r][c] != t) return 0;\n\tif (H[r][c]) return 0;\n\tH[r][c] = 1;\n\tif (a[r][c] != f && a[r][c] != t) return 0;\n\tint dr[] = {1, 0, -1, 0};\n\tint dc[] = {0, 1, 0, -1};\n\tint res = 1;\n\tif (a[r][c] == t) st = 1;\n\ta[r][c] = t;\n\trep(i,4) {\n\t\tres += dfs2(r+dr[i], c+dc[i], a, f, t, H, st);\n\t}\n\treturn res;\n}\n\nint dfs(int C, int d = 1) {\n\tauto t = v;\n\tvector<vector<int>> H;\n\tH.resize(h, vector<int>(w, 0));\n\tif (d == 5) {\n\t\tif (C != c) return 0;\n\t\tif (c == v[0][0]) return 0;\n\t\tint res = dfs2(0, 0, v, v[0][0], c, H);\n\t\treturn res;\n\t}\n\tif (C == v[0][0]) return 0;\n\tint res = dfs2(0, 0, v, v[0][0], C, H);\n\tif (C != c) res = 0;\n\trep(i, 6) {\n\t\tres = max(res, dfs(i+1, d+1));\n\t}\n\tv = t;\n\treturn res;\n}\n\nvoid solve() {\n\tint res = 0;\n\trep(i, 6) {\n\t\tres = max(res, dfs(i+1));\n\t}\n\tcout << res << endl;\n}\n\nint main() {\n\twhile (init()) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nint h, w, c;\nint bo[10][10];\n\nstruct unionfind {\n    pii par[10][10];\n    int rank[10][10];\n\n    void init(int h, int w) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                par[i][j] = pii(i, j);\n                rank[i][j] = 0;\n            }\n        }\n    }\n\n    pii find(int x, int y) {\n        if (par[x][y] == pii(x, y)) {\n            return pii(x, y);\n        } else {\n            return par[x][y] = find(par[x][y].first, par[x][y].second);\n        }\n    }\n    \n    void unite(int x1, int y1, int x2, int y2) {\n        pii p = find(x1, y1);\n        pii q = find(x2, y2);\n        x1 = p.first;\n        y1 = p.second;\n        x2 = q.first;\n        y2 = q.second;\n        if (x1 == x2 && y1 == y2) {\n            return;\n        }\n        if (rank[x1][y1] < rank[x2][y2]) {\n            par[x1][y1] = pii(x2, y2);\n        } else {\n            par[x2][y2] = pii(x1, y1);\n            if (rank[x1][y1] == rank[x2][y2]) {\n                rank[x1][y1]++;\n            }\n        }\n    }\n\n    bool same(int x1, int y1, int x2, int y2) {\n        return find(x1, y1) == find(x2, y2);\n    }\n\n    int rankfind(int x, int y) {\n        return rank[find(x, y).first][find(x, y).second];\n    }\n};\n\nint ans;\nunionfind u;\n\nint panel[10][10];\n\nvoid DFS(int n) {\n    for (int l = 1; l <= 6; l++) {\n        if (n == 5 && l != c) {\n            continue;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (panel[i][j] == -1 && bo[i][j] == l) {\n                    for (int k = 0; k < 4; k++) {\n                        int x = i + dx[k];\n                        int y = j + dy[k];\n                        if (x >= 0 && x < h && y >= 0 && y < w) {\n                            if (panel[x][y] >= 0) {\n                                panel[i][j] = n;\n                                pii p = u.find(i, j);\n                                panel[p.first][p.second] = n;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (panel[i][j] == -1 && bo[i][j] == l) {\n                    pii p = u.find(i, j);\n                    if (panel[p.first][p.second] == n) {\n                        panel[i][j] = n;\n                    }\n                }\n            }\n        }\n        if (n == 5) {\n            int num = 0;\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    if (panel[i][j] >= 0) {\n                        num++;\n                    }\n                }\n            }\n            if (num > ans) {\n                ans = num;\n            }\n        } else {\n            DFS(n + 1);\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (panel[i][j] == n) {\n                    panel[i][j] = -1;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        cin >> h >> w >> c;\n        if (h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> bo[i][j];\n            }\n        }\n        u.init(h, w);\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                for (int k = 0; k < 4; k++) {\n                    int x = i + dx[k];\n                    int y = j + dy[k];\n                    if (x >= 0 && x < h && y >= 0 && y < w) {\n                        if (bo[i][j] == bo[x][y]) {\n                            u.unite(i, j, x, y);\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < h; i++) {\n            fill(panel[i], panel[i] + w, -1);\n        }\n        panel[0][0] = 0;\n        pii p = u.find(0, 0);\n        panel[p.first][p.second] = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                pii q = u.find(i, j);\n                if (panel[q.first][q.second] == 0) {\n                    panel[i][j] = 0;\n                }\n            }\n        }\n        ans = 0;\n        DFS(1);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\n//// i/o helper ////\n\n#ifdef _DEBUG\n#define DEBUG WRITE\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\n#else\n#define DEBUG(...)\ninline void readfrom(...) { }\ninline void writeto(...) { }\n#endif\n#ifdef ccout\n#  define cout ccout\n#  define endl cendl\n#endif\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\n\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ntypedef pair<int, int> P;\ntemplate<class T, class TC>\nint seedfill(TC &field, vector<P> *painted, T self, T replace, int r, int c)\n{\n\tif (!contains(r, c, field.size(), field[0].size())) return 0;\n\t//if (self == replace) { TC f(field); return seedfill(f, painted, self, ~replace, r, c); }\n\t\n\tint ret = 0;\n\tif (field[r][c] == self)\n\t{\n\t\tif (painted) painted->emplace_back(r, c);\n\t\tfield[r][c] = replace; ret++;\n\t\tret += seedfill(field, painted, self, replace, r + 1, c);\n\t\tret += seedfill(field, painted, self, replace, r - 1, c);\n\t\tret += seedfill(field, painted, self, replace, r, c + 1);\n\t\tret += seedfill(field, painted, self, replace, r, c - 1);\n\t}\n\treturn ret;\n}\n\nint dfs(vevector<int> f, int depth, int fill, int last)\n{\n\tif (fill != f[0][0]) { seedfill(f, nullptr, f[0][0], fill, 0, 0); }\n\n\tint result = 0;\n\tif (depth == 0)\n\t{\n\t\tresult = seedfill(f, nullptr, f[0][0], -1, 0, 0);\n\t}\n\telse if (depth == 1)\n\t{\n\t\tresult = dfs(f, depth - 1, last, last);\n\t}\n\telse\n\t{\n\t\tFOR(i, 1, 7) result = max(result, dfs(f, depth - 1, i, last));\n\t}\n\treturn result;\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, h, w, c);\n\t\tif (!(h | w | c)) break;\n\t\tauto f = read<int>(h, w);\n\t\tWRITE(dfs(f, 5, f[0][0], c));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[6][9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[y][x] == b[ty][tx] && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nvoid cpy(int d, int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[d][i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[d][i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0; cpy(d, 0);\n\tif (b[0][0] != c) rec(0, 0, c);\n\tcpy(0, 2), ret = rec1(0, 0), cpy(d, 1);\n\tif (d < 4) {\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(d, 0), rec(0, 0, i);\n\t\t\tret = max(ret, solve(d + 1)), cpy(d, 1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\ntypedef vector< vector<int> > Array;\nint H, W, C;\nint ans = -1;\n\nvoid solve(Array prev, int turn=0) {\n    int orig = prev[0][0];\n\n    if(turn == 5) {\n        int temp = 0;\n        bool used[10][10] = {};\n        used[0][0] = true;\n\n        queue<pii> q;\n        q.push(pii(0, 0));\n        while(!q.empty()) {\n            temp++;\n            pii temp = q.front(); q.pop();\n            int x = temp.first, y = temp.second;\n\n            rep(k,0,4) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if(used[nx][ny]) continue;\n                if(prev[nx][ny] != orig) continue;\n                used[nx][ny] = true;\n                q.push(pii(nx, ny));\n            }\n        }\n        chmax(ans, temp);\n        return;\n    }\n\n    \n    repq(i,1,6) {\n        if(turn == 4 && i != C) continue;\n        Array board = prev;\n        bool used[10][10] = {};\n        used[0][0] = true;\n\n        queue<pii> q;\n        q.push(pii(0, 0));\n        while(!q.empty()) {\n            pii temp = q.front(); q.pop();\n            int x = temp.first, y = temp.second;\n            board[x][y] = i;\n\n            rep(k,0,4) {\n                int nx = x + dx[k], ny = y + dy[k];\n                if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if(board[nx][ny] != orig) continue;\n                if(used[nx][ny]) continue;\n                used[nx][ny] = true;\n                q.push(pii(nx, ny));\n            }\n        }\n\n        solve(board, turn+1);\n    }\n}\n\nsigned main() {\n    while(cin >> H >> W >> C, H || W || C) {\n        ans = -1;\n        Array board(H, vector<int>(W, 0));\n        rep(i,0,H) rep(j,0,W) cin >> board[i][j];\n        solve(board, 0);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++) \ntypedef pair<int,int> P;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint h,w,c;\nint tile[10][10];\nint cnt_tile() {\n    bool visit[10][10] = {};\n    int t = tile[0][0];\n    int ret = 1;\n    queue<P> que;\n\n    que.push(P(0,0));\n    visit[0][0] = true;\n\n    while(que.size()) {\n        P p = que.front(); que.pop();\n        rep(i,4) {\n            int y = p.first + dy[i];\n            int x = p.second + dx[i];\n            if(!(0<=x&&x<w && 0<=y&&y<h)) continue;\n            if(visit[y][x]) continue;\n            if(tile[y][x] != t) continue;\n            visit[y][x] = true;\n            if(tile[y][x] == c) ret++;\n            que.push(P(y,x));\n            \n        }\n    }\n    return ret;\n    \n}\nvoid fill_tile(int color) {\n    bool visit[10][10] = {};\n    int t = tile[0][0];\n    tile[0][0] = color;\n    queue<P> que;\n\n    que.push(P(0,0));\n    visit[0][0] = true;\n\n    while(que.size()) {\n        P p = que.front(); que.pop();\n        rep(i,4) {\n            int y = p.first + dy[i];\n            int x = p.second + dx[i];\n            if(!(0<=x&&x<w && 0<=y&&y<h)) continue;\n            if(visit[y][x]) continue;\n            if(tile[y][x] != t) continue;\n            visit[y][x] = true;\n            tile[y][x] = color;\n            que.push(P(y,x));\n        }\n    }\n\n}\nint dfs(int depth_) {\n    if(depth_ == 5) return cnt_tile();\n    int ret = 0;\n\n    for(int k=1;k<=6;k++) {\n        int tmp[10][10];\n        rep(i,10) rep(j,10) tmp[i][j] = tile[i][j];\n        fill_tile(k);\n        ret = max(ret,dfs(depth_+1));\n        rep(i,10) rep(j,10) tile[i][j] = tmp[i][j];\n    }\n\n    return ret;\n}\nvoid solve() {\n    rep(i,10) rep(j,10) tile[i][j] = 0;\n    rep(i,h) rep(j,w) cin>>tile[i][j];\n    cout<<dfs(0)<<endl;\n\n}\nint main() {\n    while(cin>>h>>w>>c) {\n        if(h+w+c==0) return 0;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[6][9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[y][x] == b[ty][tx] && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nvoid cpy(int d, int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[d][i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[d][i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tif (b[0][0] != c) cpy(d, 0), rec(0, 0, c);\n\tcpy(0, 2), ret = rec1(0, 0), cpy(d, 1);\n\tif (d < 4) {\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(d, 0), rec(0, 0, i);\n\t\t\tret = max(ret, solve(d + 1)), cpy(d, 1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> i_i;\nint o,h,w,c;\nvoid rec(int st[8][8],int d){\n  if(d==5){\n    queue<i_i> q;\n    vector<i_i> v;\n    int u[8][8]={{}};\n    i_i p,b;\n    p.first=0;p.second=0;\n    if(st[p.first][p.second]==c) q.push(p);\n    u[p.first][p.second]=1;\n    int ax[]={1,-1,0,0},ay[]={0,0,1,-1};\n    while(!q.empty()){\n      p=q.front();q.pop();\n      v.push_back(p);\n      for(int i=0;i<4;i++){\n\tb.first=p.first+ax[i];\n\tb.second=p.second+ay[i];\n\tif(b.first<0||b.first>=w||\n\t   b.second<0||b.second>=h) continue;\n\tif(u[b.first][b.second]==0&&\n\t   st[b.first][b.second]==c){\n\t  u[b.first][b.second]=1;\n\t  q.push(b);\n\t}\n      }\n    }\n    int s=v.size();\n    o=max(o,s);\n    return;\n  }\n  \n  queue<i_i> q;\n  vector<i_i> v;\n  int u[8][8]={{}};\n  i_i p,b;\n  p.first=0;p.second=0;\n  int bc=st[p.first][p.second];\n  u[p.first][p.second]=1;\n  q.push(p);\n  int ax[]={1,-1,0,0},ay[]={0,0,1,-1};\n  while(!q.empty()){\n    p=q.front();q.pop();\n    v.push_back(p);\n    for(int i=0;i<4;i++){\n      b.first=p.first+ax[i];\n      b.second=p.second+ay[i];\n      if(b.first<0||b.first>=w||\n\t b.second<0||b.second>=h) continue;\n      if(u[b.first][b.second]==0&&\n\t st[b.first][b.second]==bc){\n\tu[b.first][b.second]=1;\n\tq.push(b);\n      }\n    }\n  }\n  /*\n  cout << d << \":\";\n  for(int j=0;j<v.size();j++){\n    cout << v[j].first << \":\" << v[j].second << endl;\n  }\n  \n  \n  \n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cout << st[j][i] << \" \";\n    }\n    cout <<  endl;\n  }\n  cout << d << \":\" << v.size() << endl;\n  \n  */\n  int stage[8][8]={{}};\n  for(int i=1;i<=6;i++){\n    for(int j=0;j<h;j++)\n      for(int k=0;k<w;k++)\n\tstage[k][j]=st[k][j];\n    for(int j=0;j<v.size();j++){\n      stage[v[j].first][v[j].second]=i;\n    }\n    rec(stage,d+1);\n  }\n  \n}\nint main(){\n  cin >> h >> w >> c;\n  while(h!=0){\n    o=0;\n    int st[8][8]={{}};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> st[j][i];\n      }\n    }\n    rec(st,0);\n    cout << o << endl;\n    cin >> h >> w >> c;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint W, H, C;\nint field[9][9];\nbool visited[9][9];\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nvoid recolor(int x, int y, int org, int col)\n{\n    field[x][y] = col;\n    \n    for(int i=0; i<4; i++) {\n\tint tx = x + dx[i];\n\tint ty = y + dy[i];\n\n\tif(tx < 0 || ty < 0 || tx >= W || ty >= H) continue;\n\n\tif(field[tx][ty] == org)\n\t    recolor(tx,ty,org,col);\n    }\n}\n\nint comb(int x, int y)\n{\n    visited[x][y] = true;\n    int res = 1;\n\n    for(int i=0; i<4; i++) {\n\tint tx = x + dx[i];\n\tint ty = y + dy[i];\n\n\tif(tx < 0 || ty < 0 || tx >= W || ty >= H) continue;\n\n\tif(visited[tx][ty]) continue;\n\tif(field[0][0] != field[tx][ty]) continue;\n\t\n\tres += comb(tx,ty);\n    }\n\n    return res;\n}\n\n\nint solve(int cnt)\n{\n    int res = 0;\n\n    int tfield[9][9];\n    \n    if(cnt == 5) {\n\tif(field[0][0] != C) return 0;\n\n\tmemset(visited, 0, sizeof(visited));\n\treturn comb(0,0);\n    }\n    \n    for(int i=1; i<=6; i++) {\n\tif(field[0][0] == i) continue;\n\n\tmemcpy(tfield, field, sizeof(field));\n\n\trecolor(0,0,field[0][0],i);\n\n\tres = max(res, solve(cnt + 1) );\n\n\tmemcpy(field, tfield, sizeof(field));\t\n    }\n\n    return res;\n}\n\nint main()\n{\n    while(cin >> H >> W >> C, (H||W||C)) {\n\tfor(int i=0; i<H; i++)\n\t    for(int j=0; j<W; j++)\n\t\tcin >> field[j][i];\n\n\tcout << solve(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) string((s).rbegin(), (s).rend())\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\ntypedef vector<vector<int> > vvi;\nvvi rect;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint seedfill(vvi &r, int oldc, int newc){\n//\tif(oldc == newc) return;\n\tqueue<P> q;\n\tr[1][1] = newc;\n\tq.push(MP(1, 1));\n\n\tint cnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.front();\n\t\tq.pop();\n\n\t\trep(i, 4){\n\t\t\tint x = p.X + dx[i];\n\t\t\tint y = p.Y + dy[i];\n\t\t\tif(r[y][x] == oldc){\n\t\t\t\tcnt++;\n\t\t\t\tr[y][x] = newc;\n\t\t\t\tq.push(MP(x, y));\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint c;\n\nint best;\n\nint solve(int n = 0){\n\tif( n == 4 ){\n\t\tif(rect[1][1] != c) seedfill(rect, rect[1][1], c);\n\t\treturn seedfill(rect, rect[1][1], 0); // カウント用に存在しない色で塗る\n\t}\n\n\tFOR(i, 1, 7){\n\t\tif(rect[1][1] == i) continue;\n\n\t\t//rep(test, 10){\n\t\t//\trep(testj, 10){\n\t\t//\t\tcout << rect[test][testj];\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\n\n\t\tvvi tmp = rect;\n\t\tseedfill(rect, rect[1][1], i);\n\t\t//rep(test, 10){\n\t\t//\trep(testj, 10){\n\t\t//\t\tcout << rect[test][testj];\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\n\t\tbest = max(best, solve(n+1));\n\t\trect = tmp;\n\t}\n\n\treturn best;\n}\n\nint main(){\n\trect.resize(10);\n\trep(i, 10){\n\t\trect[i].resize(10);\n\t}\n\twhile(1){\n\t\tint h, w;\n\t\tcin >> h >> w >> c;\n\t\tif(!h && !w && !c) break;\n\n\t\trep(i, 10){\n\t\t\trep(j, 10){\n\t\t\t\trect[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tcin >> rect[i+1][j+1];\n\t\t\t}\n\t\t}\n\n\t\tbest = 0;\n\t\t//cout << \"***\";\n\t\tcout << solve() << endl;\n\n\t\t//rep(i, h+2){\n\t\t//\trep(j, w+2){\n\t\t//\t\tcout << rect[i][j];\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint h, w, c, p[16][16];\n\nbool in(int x, int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nint ans, op[8], q[16][16];\nbool ved[16][16];\n\nvoid shock(int x, int y, int c, int nc)\n{\n    if (!in(x, y) || q[y][x] != c || ved[y][x]) return;\n    q[y][x] = nc;\n    ved[y][x] = true;\n\n    const int dx[] = {1, 0, -1, 0};\n    const int dy[] = {0, 1, 0, -1};\n    rep(i, 4)\n\tshock(x + dx[i], y + dy[i], c, nc);\n}\n\nint cnt;\n\nvoid ponyo(int x, int y, int c)\n{\n    if (!in(x, y) || q[y][x] != c || ved[y][x]) return;\n    ved[y][x] = true;\n    ++cnt;\n\n    const int dx[] = {1, 0, -1, 0};\n    const int dy[] = {0, 1, 0, -1};\n    rep(i, 4)\n\tponyo(x + dx[i], y + dy[i], c);\n}\n\nvoid attempt()\n{\n    rep(y, h) rep(x, w) q[y][x] = p[y][x];\n    rep(i, 5) {\n\tmemset(ved, 0, sizeof(ved));\n\tshock(0, 0, q[0][0], op[i]);\n    }\n\n    memset(ved, 0, sizeof(ved));\n    cnt = 0;\n    ponyo(0, 0, c);\n    ans = max(ans, cnt);\n}\n\nvoid dfs(int d, int prev)\n{\n    if (d == 5) {\n\tattempt();\n\treturn;\n    }\n    for (int i = 1; i <= 6; ++i) {\n\top[d] = i;\n\tdfs(d + 1, i);\n    }\n}\n\nint solve()\n{\n    ans = 0;\n    dfs(0, 0);\n    return ans;\n}\n\nint main() {\n    while (cin >> h >> w >> c && h) {\n\trep(y, h) rep(x, w) cin >> p[y][x];\n\top[4] = c;\n\n\tcout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define rep(i,from,to) for(int i=from; i<to; ++i)\n#define REP(i,from,to) for(int i=from; i<=to; ++i)\nusing namespace std;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\nconst int maxh = 8;\nint h, w, c;\nint di[4] = { -1, 0, 1, 0 };\nint dj[4] = { 0, 1, 0, -1 };\nint ans;\nint paint(vector<vector<int>>& p, int i, int j, int from, int to) { //from???????????????(i,j)???to??????????????????, p????????§??????\n\tp[i][j] = to;\n\tint cnt = 1; //(i,j)???to????????£????????§, ?????£?????°???1???\n\trep(k,0,4)\n\t{\n\t\tint ni = i + di[k], nj = j + dj[k];\n\t\tif (0 <= ni && ni < h && 0 <= nj && nj < w && (p[ni][nj] == from)) {\n\t\t\tcnt += paint(p, ni, nj, from, to); //??£??\\??????????????????????????????\n\t\t}\n\t}\n\treturn cnt; //(i,j)????????????????????????to???????????????????????????\n}\n\nvoid dfs(vector<vector<int>>& p, int level) { //\"????????????\"level?????????????????´\n\tint ret = 0;\n\tREP(col, 1, 6)\n\t{\n\t\tif (col == p[0][0]) { //????????¨???????????????????????????(????????????)\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 5 && col != c) { //5????????????c??\\??????????????´?????????\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<int> > next = p; //???????????????p????????????next????????£???????????????\n\t\tif (level < 5) { //1-4???????????§?????¨????????????\n\t\t\tpaint(next, 0, 0, next[0][0], col); //???col????????´??????\n\t\t\tdfs(next, level + 1); //next?????????????¬????\n\t\t} else {\n\t\t\tpaint(next, 0, 0, next[0][0], c); //?????????????¨????c??§??????\n\t\t\tret = paint(next, 0, 0, next[0][0], 0); //0??§???????????¨??§?????§???????????????????????°?????°????????????\n\t\t\tans = max(ans, ret);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\twhile (cin >> h >> w >> c, h || w || c) {\n\t\tans = 0;\n\t\tvector<vector<int> > p(h);\n\t\trep(i,0,h)\n\t\t{\n\t\t\tp[i] = vector<int>(w);\n\t\t\trep(j,0,w)\n\t\t\t{\n\t\t\t\tcin >> p[i][j];\n\t\t\t}\n\t\t}\n\t\tdfs(p, 1);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nvoid cpy(int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tif (b[0][0] != c) cpy(0), rec(0, 0, c);\n\tcpy(2), ret = rec1(0, 0), cpy(1);\n\tif (d < 4) {\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(0), rec(0, 0, c);\n\t\t\tret = max(ret, solve(d + 1)), cpy(1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint max(int a,int b){\n\tif(b>a)return b;\n\treturn a;\n}\n\nint p[10][10];\nint cp[10][10];\nint flag[10][10];\nint h,w,c;\n\nstruct data{\n\tint x,y;\n};\n\nstruct data que[5000000];\nint f,t;\nvoid push(int xx,int yy){\n\tque[t].x=xx;\n\tque[t].y=yy;\n\tt++;\n}\n\nstruct data pop(){\n\treturn que[f++];\n}\n\nint sx[4]={0,1,0,-1};\nint sy[4]={1,0,-1,0};\nint col[7],res;\n\nint bfs(int cc){\n\tmemset(flag,0,sizeof(flag));\n\tf=0,t=0;\n\tpush(1,1);\n\tflag[1][1]=1;\n\twhile(f!=t){\n\t\tstruct data q=pop();\n\t\tint i;\n\t\tfor(i=0;i<4;i++){\n\t\t\tint nx=sx[i]+q.x,ny=sy[i]+q.y;\n\t\t\tif(flag[nx][ny]==0){\n\t\t\t\tif(cp[q.x][q.y]==cp[nx][ny]){\n\t\t\t\t\tflag[nx][ny]=1;\n\t\t\t\t\tpush(nx,ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tint i,j;\n\tfor(i=1;i<=h;i++){\n\t\tfor(j=1;j<=w;j++){\n\t\t\tif(flag[j][i]==1)cp[j][i]=cc;\n\t\t\tcnt+=flag[j][i];\n\t\t}\n\t}\n\treturn cnt;\n}\nint d[6];\nvoid dfs(int x){\n\tif(x<4){\n\t\tfor(d[x]=1;d[x]<=6;d[x]++){\n\t\t\tcol[x]=d[x];\n\t\t\tdfs(x+1);\n\t\t}\n\t}else{\n\t\tcol[4]=c;\n\t\tint i,j;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcp[j][i]=p[j][i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++){\n\t\t\tbfs(col[i]);\n\t\t}\n\t\tres=max(res,bfs(7));\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&c);\n\t\tif(h+w+c==0)break;\n\t\tres=0;\n\t\tmemset(p,0,sizeof(p));\n\t\tint a,b;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&p[b][a]);\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nint gSum = 0;\nint w,h,c;\n\nclass Data{\npublic:\n\tint stage[8][8];\n\tint count;\n\tData() : count(0), stage(){}\n\tData(int _stage[8][8],int _count){\n\t\tmemcpy(this->stage,_stage,sizeof(int)*8*8);\n\t\tthis->count = _count;\n\t}\n\tbool operator>(const Data& d) const{\n\t\treturn this->count > d.count;\n\t}\n\n\tbool operator<(const Data& d) const{\n\t\treturn this->count < d.count;\n\t}\n};\n\nvoid dfs(int stage[8][8],int x,int y,int from,int to,bool visited[8][8]){\n\tstage[y][x] = to;\n\tvisited[y][x] = true;\n\n\tfor(int i=0;i<4;i++){\n\t\tint dx = x + tx[i];\n\t\tint dy = y + ty[i];\n\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\tif(stage[dy][dx] != from ) continue;\n\t\tif(visited[dy][dx]) continue;\n\n\t\tdfs(stage,dx,dy,from,to,visited);\n\t}\n}\n\nvoid dfs2 (int stage[8][8],int x,int y,bool visited[8][8]){\n\tvisited[y][x] = true;\n\tgSum++;\n\tfor(int i=0;i<4;i++){\n\t\tint dx = x + tx[i];\n\t\tint dy = y + ty[i];\n\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\tif(stage[dy][dx] != c) continue;\n\t\tif(visited[dy][dx]) continue;\n\n\t\tdfs2(stage,dx,dy,visited);\n\t}\n}\n\nstring stg2str(int stage[8][8]){\n\tstring res = \"\";\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tres += stage[y][x] + '0';\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d %d\",&h,&w,&c)){\n\t\tif(h==w && w==c && c==0) break;\n\n\t\tint stage[8][8];\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tscanf(\"%d\",&stage[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Data,vector<Data>,greater<Data> > que;\n\t\tque.push(Data(stage,0));\n\n\t\tint maxv = 0;\n\t\tmap<string,int> cost;\n\n\t\twhile(!que.empty()){\n\t\t\tData d = que.top();\n\t\t\tque.pop();\n\n\t\t\tif(d.count >= 5) continue;\n\t\t\tfor(int i=1;i<=6;i++){\n\t\t\t\tint next[8][8];\n\t\t\t\tmemcpy(next,d.stage,sizeof(int)*8*8);\n\n\t\t\t\t\n\t\t\t\tbool visited[8][8];\n\t\t\t\tmemset(visited,0,sizeof(visited));\n\t\t\t\tdfs(next,0,0,d.stage[0][0],i,visited);\n\n\n\t\t\t\tstring str = stg2str(next);\n\t\t\t\tif(cost.find(str) != cost.end() && cost[str] <= d.count + 1) continue;\n\n\t\t\t\tcost[str] = d.count + 1;\n\n\t\t\t\tgSum = 0;\n\t\t\t\tmemset(visited,0,sizeof(visited));\n\t\t\t\tdfs2(next,0,0,visited);\n\t\t\t\tmaxv = max(maxv,gSum);\n\n\t\t\t\tque.push(Data(next,d.count+1));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",maxv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <utility>\n\nusing namespace std;\ntypedef vector<vector<int>> mat;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nvector<pii> d(4);\n\nint solve();\nint getCols( const int target, const mat & m );\nvoid setColor( const int col, mat &m );\nvoid search( int &ans, int target, mat &orig );\n\nvoid printmat( mat &m ) {\n\tfor( int i = 0; i < m.size(); i++ ) {\n\t\tfor( int j = 0; j < m[i].size(); j++ ) {\n\t\t\tcout << m[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void) {\n\t\t\n\twhile(solve()){}\n\n\treturn 0;\n}\n\nvoid setColor( const int col, mat &m ) {\n\n\t//?????¨?????¨??????\n\tconst int orig = m[0][0];\n\n\tqueue<pii> q;\n\tq.push(pii(0,0));\n\tmat visited( m.size(), vi( m[0].size(), 0 ) );\n\t\n\twhile(!q.empty()) {\n\n\t\tpii p = q.front();\n\t\tvisited[p.first][p.second] = 1;\n\t\tq.pop();\n\n\t\tif( m[p.first][p.second] == orig ) {\n\t\t\tm[p.first][p.second] = col;\n\n\t\t\tfor( int i = 0; i < d.size(); i++ ) {\n\n\t\t\t\tpii n;\n\t\t\t\t\tn.first = p.first + d[i].first;\n\t\t\t\t\tn.second = p.second + d[i].second;\n\n\t\t\t\tif( n.first >= 0 && n.first < m.size() \n\t\t\t\t\t&& n.second >= 0 && n.second < m[0].size()\n\t\t\t\t\t&& visited[n.first][n.second] == 0 ) {\n\n\t\t\t\t\t\tq.push(n);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\n}\n\nint getCols( const int target, const mat& m) {\n\n\tint ret = 0;\n\tqueue<pii> q;\n\tq.push(pii(0,0));\n\tmat visited( m.size(), vi( m[0].size(), 0 ) );\n\tvisited[0][0] = 1;\n\n\twhile(!q.empty()){\n\n\t\tpii p = q.front();\n\t\tq.pop();\n\t\tret ++;\n\t\tfor( int i = 0; i < d.size(); i++ ) {\n\n\t\t\tpii n;\n\t\t\t\tn.first = p.first + d[i].first;\n\t\t\t\tn.second = p.second + d[i].second;\n\n\t\t\tif( n.first >= 0 && n.first < m.size() \n\t\t\t\t&& n.second >= 0 && n.second < m[0].size()\n\t\t\t\t&& visited[n.first][n.second] == 0\n\t\t\t\t&& m[n.first][n.second] == target ) {\n\t\t\t\t\tvisited[n.first][n.second] = 1;\n\t\t\t\t\tq.push(n);\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid search( int &ans, int target, mat &orig ) {\n\n\tstack<vi> s;\n\n\tfor( int i = 1; i <= 6; i++ ) {\n\t\ts.push(vi(1,i));\n\t}\n\n\twhile( !s.empty() ){\n\n\t\tvi t = s.top();\n\t\ts.pop();\n\t\tif( t.size() < 5 ) {\n\t\t\tt.push_back(0);\n\t\t\tfor( int i = 1; i <= 6; i++ ) {\n\t\t\t\tt[t.size()-1] = i;\n\t\t\t\ts.push(t);\n\t\t\t}\n\t\t} else if( t.size() == 5 ){\n\t\t\tmat m = orig;\n\t\t\tfor( int i = 0; i < t.size(); i++ ) {\n\t\t\t\tsetColor( t[i], m );\n\t\t\t}\n\t\t\tans = max( getCols( target, m ), ans);\n\t\t}\n\n\t}\n\n}\n\nint solve() {\n\n\tint h, w, c;\n\n\tcin >> h >> w >> c;\n\n\tif(!(h|w|c)){ return 0; }\n\n\tmat p(h,vector<int>(w,0));\n\n\td[0] = pii(0,1);\n\td[1] = pii(0,-1);\n\td[2] = pii(1,0);\n\td[3] = pii(-1,0);\n\n\tfor( int i = 0; i < h; i++ ) {\n\t\tfor( int j = 0; j < w; j++ ) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tsearch( ans, c, p );\n\tcout << ans << endl;\n\n\treturn 1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint fill(int y, int x, int from, int to, vector<vector<int> > &panel){\n\tif(panel[y][x] != from) return 0;\n\tpanel[y][x] = to;\n\tint ret = 1;\n\tfor(int d=0; d<4; d++){\n\t\tret += fill(y+dy[d], x+dx[d], from, to, panel);\n\t}\n\treturn ret;\n}\n\nint solve(int step, int color, vector<vector<int> > &panel){\n\tif(step == 0){\n\t\tvector<vector<int> > tmp = panel;\n\t\treturn fill(1, 1, tmp[1][1], 0, tmp);\n\t}\n\tint ret = 0;\n\tfor(int i=1; i<=6; i++){\n\t\tif(i == panel[1][1]) continue;\n\t\tif(step==1 && i!=color) continue;\n\t\tvector<vector<int> > tmp = panel;\n\t\tfill(1, 1, tmp[1][1], i, tmp);\n\t\tret = max(ret, solve(step-1, color, tmp));\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint h,w,c;\n\t\tcin >> h >> w >> c;\n\t\tif(h == 0) break;\n\n\t\tvector<vector<int> > panel(h+2, vector<int>(w+2, -1));\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> panel[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve(5, c, panel) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint ma, h, w, c, aaa;\n\nvoid huga(int p[10][10], int tempt[10][10], int x, int y, int a){\n  if(tempt[x][y] == a) return;\n  tempt[x][y] = a;//cout<<x<<\" \"<<y<<endl;\n  if(p[x][y] == p[x][y+1])huga(p, tempt, x, y+1, a);\n  if(p[x][y] == p[x][y-1])huga(p, tempt, x, y-1, a);\n  if(p[x][y] == p[x+1][y])huga(p, tempt, x+1, y, a);\n  if(p[x][y] == p[x-1][y])huga(p, tempt, x-1, y, a);\n}\n\nint foo(int p[10][10], int count, int temp[10][10]){//cout<<count<<\" \"<<c<<endl;\n  int tempp[10][10] = {},tempt[10][10] = {}, temp2[10] = {}, count2 = 0, count3 = 0 ,temp3 = p[1][1];\n\n\n  // count2 = 1; temp2[count2] = c;\n\n\n \n  // huga(p, tempt, 1, 1, 1);\n  \n  /* for(int i = 1; i <= h; i++){\n    for(int j = 1; j <= w; j++){\n      // tempp[i][j] = p[i][j];\n      if(tempt[i][j+1] == 1|| tempt[i][j-1] == 1||tempt[i+1][j] == 1|| tempt[i-1][j] == 1){\n\tif(p[1][1] == p[i][j]) tempt[i][j] = 1;\n\telse if(p[i][j] != 0){ temp2[count2++] = p[i][j]; tempt[i][j] = 2;}\n      }\n    }\n    }*/\n  \n  for(int i = 1; i <= h; i++){\n    for(int j = 1; j <= w; j++){\n       if(temp[i][j+1] == 1|| temp[i][j-1] == 1||temp[i+1][j] == 1|| temp[i-1][j] == 1){\n\t if(temp[i][j] != 1){\n\t   //tempt[i][j] = 2;\n\t    huga(p, temp, i, j, 2);\n\t   temp2[count2++] = p[i][j];\n\t }\n       }\n    }\n  }\n  \n  temp2[count2++] = c;\n  // if((p[1][1] == 5 && p[1][3] == 5) || (p[1][1] == 4 && p[1][3] == 4)){\n  /*  cout<<\"HHHHHHHHHHHHHHHH  \"<<count<<endl;\n  for(int i = 0; i <= h; i++){\n\t  for(int j = 0; j <= w; j++)cout<<tempt[i][j]<<\" \";\n\t  cout<<endl;\n\t  }cout<<endl;\n  \n  for(int i = 0; i <= h; i++){\n\t  for(int j = 0; j <= w; j++)cout<<p[i][j]<<\" \";\n\t  cout<<endl;\n\t  }cout<<endl;\n\t  // }*/\n  \n  \n  if(count < 5){\n    for(int k = 0; k < count2 ; k++){// cout<<temp2[k]<<\" A \"<<count2<<endl;\n      for(int i = 1; i <= h; i++){\n\tfor(int j = 1; j <= w; j++){\n\t  tempp[i][j] = p[i][j];\n\t  tempt[i][j] = temp[i][j];\n\t  //  if((p[i][j] == temp2[k] || p[i][j] == p[1][1]) && (tempt[i][j] == 1 || tempt[i][j] == 2)){ tempp[i][j] = temp2[k];}\n\t  if(( p[i][j] == p[1][1] && temp[i][j] == 1 ) ||(p[i][j] == temp2[k] &&  temp[i][j] == 2)) {tempp[i][j] = temp2[k]; tempt[i][j] = 1;}\n\t  // else if(p[i][j] == temp2[k] &&  tempt[i][j] == 2){tempp[i][j] = temp2[k];}\n\t  // else {tempp[i][j] = p[i][j];}//cout<<tempp[i][j];\n\t}//cout<<endl;\n      }/*cout<<\"---------\"<<endl;\n       for(int b = 0; b <= h; b++){\n\tfor(int l = 0; l <= w; l++)cout<<tempp[b][l]<<\" \";\n\tcout<<endl;\n\t}cout<<endl;*/\n       // cin>>aaa;\n      \n      \n      //  count++;//cout<<\"XXXX\"<<endl;\n      foo(tempp, count+1, tempt);\n    }\n\n  } else {\n    count3 = 0;\n     for(int i = 1; i <= h; i++){\n\tfor(int j = 1; j <= w; j++){\n\t  tempp[i][j] = p[i][j];\n\t  // tempt[i][j] = temp[i][j];\n\t  if(p[i][j] == p[1][1] && temp[i][j] == 1){tempp[i][j] = c; count3++;}\n\t  else if(p[i][j] == c && temp[i][j] == 2){ count3++; }\n\t  //else tempp[i][j] = p[i][j];//cout<<tempp[i][j];\n\t}//cout<<endl;\n     }\n\n         ma = max(count3, ma);\n\t \n\t/* if(ma != count3) return 0;\n\t \n\t // cout<<\"BBBBBBBBBBBBBBBBBBBBBb   \"<<c<<endl;\n\t for(int b = 0; b <= h; b++);\n\t // for(int l = 0; l <= w; l++);//cout<<tempp[b][l]<<\" \";\n\t    //\tcout<<endl;\n\t    //cout<<endl;\n\t //cin>>aaa;\n\t // cout<<count3<<endl;\n\t // cout<<\"HHHHHHHHHHHHHHHH  \"<<count<<endl;\n\t for(int i = 0; i <= h; i++);{\n\t   for(int j = 0; j <= w; j++);//cout<<tempt[i][j]<<\" \";\n\t   // cout<<endl;\n\t   }//cout<<endl;\n\t \n\t for(int i = 0; i <= h; i++){\n\t   for(int j = 0; j <= w; j++);//cout<<p[i][j]<<\" \";\n\t    // cout<<endl;\n\t }//cout<<endl;*/\n\t \n\t return 0;\n  }\n  \n  return 0;\n}\n\nint main(){\n  cin >> h >> w >> c;\n\n  while( h != 0 || w != 0 || c != 0){\n    int p[10][10] = {}, tempt[10][10] = {};//, temp[10][10] = {}, temp2[10] = {}, count , tempt[10][10] = {};//, tempp[10][10] = {};\n    ma = 0;\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tcin >> p[i][j];\n      }\n    }\n    \n    /*  temp[1][1]  = 1; count = 0;\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\ttempp[i][j] = p[i][j];\n\t  if(temp[i][j+1] == 1 || temp[i][j-1] == 1 ||temp[i+1][j] == 1 || temp[i-1][j] == 1){\n\t    if(p[1][1] == p[i][j]) temp[i][j] = 1;\n\t    else if(p[i][j] != 0){ temp2[count++] = p[i][j]; temp[i][j] = 2;}\n\t  }\n      }\n    }\n    temp2[count++] = c;\n    */\n    /*  for(int k = 1; k <= 6; k++){//cout<<\"GFGFGGF k\"<<k<<endl;\n     for(int i = 1; i <= h; i++){//cout<<\"GFGFGGF i\"<<i<<endl;\n\tfor(int j = 1; j <= w; j++){//cout<<\"GFGFGGF j\"<<j<<\" \"<<h<<\" \"<<w<<endl;\n\t  tempt[i][j] = temp[i][j];//cout<<i<<endl;\n\t  if(p[i][j] == k && (temp[i][j] == 1 || temp[i][j] == 2)){tempp[i][j] = k; tempt[i][j] = 1;}\n\t  else tempp[i][j] = p[i][j];// cout<<i<<endl;\n\t}\n     }//cout<<\"GFGFGGF \"<<k<<endl;\n      foo(p, 0, temp);\n      }*/\n    huga(p, tempt, 1, 1, 1);\n  \n    foo(p, 1, tempt);\n\n\n\n    \n   /* for(int i = 0; i <= h; i++){\n\t  for(int j = 0; j <= w; j++)cout<<temp[i][j]<<\" \";\n       cout<<endl;\n       }*/\n    cout<<ma<<endl;\n \n    cin >> h >> w >> c;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ntypedef pair<int, int> P;\n\nint p[10][10], visited[10][10];\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nint h, w, c;\n\nint dfs(int count) {\n    if(count == 5) {\n        int ret = 0;\n        if(p[0][0] != c) return 0;\n        rep(i, 10) rep(j, 10) visited[i][j] = 0;\n        queue<P> que;\n        que.push(P(0, 0));\n        while(!que.empty()) {\n            P point = que.front(); que.pop();\n            if(visited[point.first][point.second] == 0) {\n               visited[point.first][point.second] = 1;\n               ret++;\n                rep(i, 4) {\n                    int ny = point.first + dy[i];\n                    int nx = point.second + dx[i];\n                    if(nx >= 0 && nx < w && ny >= 0 && ny < h &&\n                       visited[ny][nx] == 0 && p[ny][nx] == c) {\n                        que.push(P(ny, nx));\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n    int org[10][10];\n    int ret = 0;\n    rep(i, h) rep(j, w) org[i][j] = p[i][j];\n    rep(color, 6) {\n        int org_c = p[0][0];\n        rep(i, 10) rep(j, 10) visited[i][j] = 0;\n        queue<P> que;\n        que.push(P(0, 0));\n        while(!que.empty()) {\n            P point = que.front(); que.pop();\n            p[point.first][point.second] = color+1;\n            visited[point.first][point.second] = 1;\n            rep(i, 4) {\n                int ny = point.first + dy[i];\n                int nx = point.second + dx[i];\n                if(nx >= 0 && nx < w && ny >= 0 && ny < h &&\n                   visited[ny][nx] == 0 && p[ny][nx] == org_c) {\n                    que.push(P(ny, nx));\n                }\n            }\n        }\n        ret = max(ret, dfs(count+1));\n        rep(i, 10) rep(j, 10) p[i][j] = org[i][j];\n    }\n    return ret;\n}\n\nint main(void){\n    while(cin >> h >> w >> c && h) {\n        rep(i, h) rep(j, w) cin >> p[i][j];\n        cout << dfs(0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int MAX_N = 9;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint h, w, c, ans;\nconst int limit = 5;\nvector<vector<int>> board(MAX_N, vector<int>(MAX_N));\nbool used[MAX_N][MAX_N];\nbool isOK(int y, int x)\n{\n    if(y >= 0 and x >= 0 and y < h and x < w) return true;\n    return false;\n}\nint calc()\n{\n    int res = 0;\n    int color = board[0][0];\n    if(color != c) return 0;\n    memset(used, 0, sizeof(used));\n    queue<pair<int, int>> que;\n    que.push(make_pair(0, 0));\n    used[0][0] = true;\n    while(que.size())\n    {\n        pair<int, int> now = que.front(); que.pop();\n        res++;\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = now.first + dy[i];\n            int nx = now.second + dx[i];\n            if(not isOK(ny, nx)) continue;\n            if(used[ny][nx] || board[ny][nx] != color) continue;\n            used[ny][nx] = true;\n            que.push(make_pair(ny, nx));\n        }\n    }\n    return res;\n}\nvoid change(int next_color)\n{\n    int color = board[0][0];\n    memset(used, 0, sizeof(used));\n    queue<pair<int, int>> que;\n    que.push(make_pair(0, 0));\n    used[0][0] = true;\n    while(que.size())\n    {\n        pair<int, int> now = que.front(); que.pop();\n        board[now.first][now.second] = next_color;\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = now.first + dy[i];\n            int nx = now.second + dx[i];\n            if(not isOK(ny, nx)) continue;\n            if(used[ny][nx] || board[ny][nx] != color) continue;\n            used[ny][nx] = true;\n            que.push(make_pair(ny, nx));\n        }\n    }\n}\nvoid dfs(int cnt)\n{\n    if(cnt == limit)\n    {\n        ans = max(ans, calc());\n        return;\n    }\n    vector<vector<int>> tmp = board;\n    for(int color = 1; color <= 6; color++)\n    {\n        if(board[0][0] == color) continue;\n        change(color);\n        dfs(cnt + 1);\n        board = tmp;\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> h >> w >> c, h | w | c)\n    {\n        ans = -1;\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                cin >> board[i][j];\n            }\n        }\n        dfs(0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint H,W,C;\nint tbl[10][10];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nbool visited[10][10];\n\nvoid paint(int x,int y,int c){\n  visited[y][x]=true;\n  for(int i=0;i<4;++i){\n    int mx = x+dx[i];\n    int my = y+dy[i];\n    if(mx>=W||my>=H||mx<0||my<0) continue;\n    if(visited[my][mx]) continue;\n    if(tbl[my][mx]==tbl[0][0]) paint(mx,my,c);\n  }\n  tbl[y][x]=c;\n}\n\nint calc(int x,int y){\n  visited[y][x]=true;\n  int ret = 1;\n  for(int i=0;i<4;++i){\n    int mx = x+dx[i];\n    int my = y+dy[i];\n    if(mx>=W||my>=H||mx<0||my<0) continue;\n    if(visited[my][mx]) continue;\n    if(tbl[my][mx]==tbl[0][0]) ret+=calc(mx,my);\n  }\n  return ret;\n}\n\nint solve(int depth){\n  if(!depth){\n    /*\n    for(int i=0;i<H;++i){\n      for(int j=0;j<W;++j) cout << tbl[i][j];\n      cout << endl;\n    }\n    cout << endl;\n    */    \n    memset(visited,0,sizeof(visited));\n    return calc(0,0);\n  }\n  int ret = 0;\n  for(int i=1;i<=6;++i){\n    if(depth==1&&i!=C) continue;\n    int tmp[10][10];\n    for(int y=0;y<H;++y) for(int x=0;x<W;++x) tmp[y][x]=tbl[y][x];\n    memset(visited,0,sizeof(visited));\n    paint(0,0,i);\n    ret = max(ret,solve(depth-1));\n    for(int y=0;y<H;++y) for(int x=0;x<W;++x) tbl[y][x]=tmp[y][x];    \n  }\n  return ret;\n}\n\nint main(){\n  while(cin>>H>>W>>C,H||W||C){\n    for(int i=0;i<H;++i)\n      for(int j=0;j<W;++j) cin>>tbl[i][j];\n    cout << solve(5) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint h,w,c;\nint dis[10][10];\nint ans;\nint count;\nstruct po{\n  int x,y;\n  int mp[10][10];\n  bool flg[6];\n};\nstruct xy{\n  int x,y;\n};\n\nvoid deb(po t) {\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++)\n      cout << t.mp[i][j] << \" \";\n    cout << endl;\n  }\n  cout <<\"-----------------\"<<endl;\n\n}\n\n\nvoid saiki(po sta,int d){\n  // for(int i=0;i<6;i++) cout <<sta.flg[i];\n  //cout << endl;\n  count++;\n  po t = sta;\n  if(d <= 6 ) {\n  for(int i=0;i<6;i++){\n    if( t.mp[0][0] != i+1) {\n      if(d == 5 && i != c-1) continue;\n      queue <xy> Q;\n      Q.push((xy){0,0});\n      for(int j=0;j<h;j++) for(int k=0;k<w;k++) dis[j][k] = 0;\n      dis[0][0] = 1;\n      int tf = 0;\n      int sum = 1;\n      while(!Q.empty()){\n\tint dx[4] = {0,0,1,-1},dy[4] = {1,-1,0,0};\n\txy u = Q.front();\n\tQ.pop();\n\tfor(int j=0;j<4;j++) {\n\t  int tx = u.x+dx[j] , ty = u.y+dy[j];\n\t  if(tx>=0 && tx<w && ty>=0 && ty<h){\n\t    if(t.mp[ty][tx]==t.mp[0][0] && dis[ty][tx]==0) {\n\t    Q.push((xy){tx,ty});\n\t    dis[ty][tx] = 1;\n\t    sum++;\n\t    }\n\t    if(t.mp[ty][tx]==i+1 && d!=6) tf = 1;\n\t  }\n\t}\n      }\n      po tmp = t;\n      if(tf == 1 && d != 6) {\n\tfor(int j=0;j<h;j++)\n\t  for(int k=0;k<w;k++)\n\t    if(dis[j][k] == 1) t.mp[j][k] = i+1;\n      }\n      else if(d != 6) t.mp[0][0] = i+1;\n    \n      if(sum > ans && t.mp[0][0] == c) {\n\t  ans = sum;\n\t  //deb(t);\n\t}\n      \n      \n      t.flg[i] = 1;\n      saiki(t,d+1);\n      t = tmp;\n    }\n  }\n  }\n}   \n\n\n\nint main() {\n\n  while(1) {\n\n    cin >> h >> w  >> c;\n    if(h == 0 && w == 0 && c == 0) break;\n\n    po in;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin >> in.mp[i][j];\n    \n    \n    for(int i=0;i<6;i++) in.flg[i] = 0;\n    ans = 0;\n    saiki(in,1);\n\n    cout << ans << endl;   \n    //cout <<count << endl;\n  }    \n\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define loop(x) for(int x=1;x<=6;x++)\n\nusing namespace std;\n\nvoid change(int[10][10],int,int,int);\nint count(int[10][10],int,int);\n\nint main(void){\n\tfor(int h,w,c;cin >> h >> w >> c,h||w||c;){\n\t\tint fld[10][10]={0};\n\t\tint max=0,tmp;\n\n\t\tfor(int i=1;i<=h;i++)\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t\tcin >> fld[i][j];\n\n\t\tloop(i){\n\t\t\tint cpy1[10][10];\n\t\t\tmemcpy(cpy1,fld,sizeof(fld));\n\t\t\tchange(cpy1,1,1,i);\n\t\t\tloop(j){\n\t\t\t\tint cpy2[10][10];\n\t\t\t\tmemcpy(cpy2,cpy1,sizeof(cpy1));\n\t\t\t\tchange(cpy2,1,1,j);\n\t\t\t\tloop(k){\n\t\t\t\t\tint cpy3[10][10];\n\t\t\t\t\tmemcpy(cpy3,cpy2,sizeof(cpy2));\n\t\t\t\t\tchange(cpy3,1,1,k);\n\t\t\t\t\tloop(l){\n\t\t\t\t\t\tint cpy4[10][10];\n\t\t\t\t\t\tmemcpy(cpy4,cpy3,sizeof(cpy3));\n\t\t\t\t\t\tchange(cpy4,1,1,l);\n\t\t\t\t\t\tchange(cpy4,1,1,c);\n\t\t\t\t\t\ttmp=count(cpy4,1,1);\n\t\t\t\t\t\tmax=max>tmp?max:tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << max << endl;\n\t}\n\n\treturn 0;\n}\n\nvoid change(int fld[10][10],int x,int y,int col){\n\tint cul=fld[x][y];\n\n\tif(cul!=col){\n\t\tfld[x][y]=col;\n\t\tif(fld[x+1][y]==cul)\n\t\t\tchange(fld,x+1,y,col);\n\t\tif(fld[x-1][y]==cul)\n\t\t\tchange(fld,x-1,y,col);\n\t\tif(fld[x][y+1]==cul)\n\t\t\tchange(fld,x,y+1,col);\n\t\tif(fld[x][y-1]==cul)\n\t\t\tchange(fld,x,y-1,col);\n\t}\n}\n\nint count(int fld[10][10],int x,int y){\n\tint c=1,cul=fld[x][y];\n\n\tfld[x][y]=-1;\n\tif(fld[x+1][y]==cul)\n\t\tc+=count(fld,x+1,y);\n\tif(fld[x-1][y]==cul)\n\t\tc+=count(fld,x-1,y);\n\tif(fld[x][y+1]==cul)\n\t\tc+=count(fld,x,y+1);\n\tif(fld[x][y-1]==cul)\n\t\tc+=count(fld,x,y-1);\n\n\treturn c;\n}"
  },
  {
    "language": "C++",
    "code": "//同じ連結成分を違う色で塗る工程は、bfsでできるが、実装は\n//連結成分を列挙し終えてから新しい色を塗ったほうが、連結成分を列挙中に新しい色を塗っていくよりも断然楽。\n#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\nclass Input {\npublic:\n\tint h, w, aimColor;\n\tint colors[64];\t//color[i*w + j] = i行j列の色\n\t\n\tbool input(FILE *fp) {\n\t\tfscanf(fp, \"%d%d%d\", &h, &w, &aimColor);\n\t\tif (h == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < h*w; i++) {\n\t\t\tfscanf(fp, \"%d\", colors + i);\n\t\t}\n\t\treturn true;\n\t}\n};\n\n//とにかくそのまま使いたい継承\nclass Solver : public Input {\npublic:\n\tint ans;\n\t\n\tint getScore() {\n\t\tint ret = bfs(colors[0], colors);\n\t\treturn ret;\n\t}\n\tvoid dfs(int dep) {\n\t\tif (dep == 5) {\n\t\t\tif (colors[0] != aimColor) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint res = getScore();\n\t\t\tans = max(res, ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tint copy[64];\n\t\t\tfor (int j = 0; j < h*w; j++) {\n\t\t\t\tcopy[j] = colors[j];\n\t\t\t}\n\t\t\t\n\t\t\tbfs(i, colors);\n\t\t\tdfs(dep+1);\n\t\t\t\n\t\t\tfor (int j = 0; j < h*w; j++) {\n\t\t\t\tcolors[j] = copy[j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//戻り値は左上マスを含む連結成分の大きさ\n\tint bfs(int color, int *dst) {\t\t\n\t\tqueue<int> que;\n\t\tbool done[64] = {false};\n\t\t\n\t\t//dst[0]と同じ連結成分を抽出\n\t\tque.push(0);\n\t\twhile(!que.empty() ) {\n\t\t\tint v = que.front();\n\t\t\tque.pop();\n\t\t\tif (done[v])\n\t\t\t\tcontinue;\n\t\t\tdone[v] = true;\n\t\t\t\n\t\t\tint dy[4] = {-1, 0, 1, 0};\n\t\t\tint dx[4] = {0, 1, 0, -1};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint y = dy[i] + (v/w);\n\t\t\t\tint x = dx[i] + (v%w);\n\t\t\t\tif (0 <= y && y < h && 0 <= x && x < w && dst[y*w + x] == dst[0] && !done[y*w + x]) {\n\t\t\t\t\tque.push(y*w + x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//その連結成分の全マスをcolorにする\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < h*w; i++) {\n\t\t\tif (done[i]) {\n\t\t\t\tdst[i] = color;\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint solve() {\n\t\tans = 0;\n\t\tdfs(0);\n\t\treturn ans;\n\t}\n}solver;\n\nsigned main() {\n\twhile (solver.input(stdin) ) {\n\t\tint res = solver.solve();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n#define M 8\n\nint h,w,c;\n\nint p[M][M];\nint buf[M][M];\nint maxv,maxi;\n\n\nvoid change(int oc,int nc,int i,int j){\n    if(buf[i][j]!=oc)return;\n    buf[i][j]=nc;\n    if(i>=1)change(oc,nc,i-1,j);\n    if(j>=1)change(oc,nc,i,j-1);\n    if(i<=h-2)change(oc,nc,i+1,j);\n    if(j<=w-2)change(oc,nc,i,j+1);\n}\n/*\n destroys buf\n */\nint count0(int col,int i,int j){\n    if(buf[i][j]!=col)return 0;\n    buf[i][j]=-1;\n    int cnt=0;\n    if(i>=1)cnt+=count0(col,i-1,j);\n    if(j>=1)cnt+=count0(col,i,j-1);\n    if(i<=h-2)cnt+=count0(col,i+1,j);\n    if(j<=w-2)cnt+=count0(col,i,j+1);\n    return cnt+1;\n}\nvoid check(int arg0){\n    int ar[5];\n    int oldarg=arg0;\n    for(int i=0;i<5;i++){\n        ar[i]=arg0%6;\n        arg0/=6;\n    }\n    for(int i=0;i<5;i++){\n        if(buf[0][0]!=ar[i]){\n            change(buf[0][0],ar[i],0,0);\n        }\n    }\n    int c=count0(buf[0][0],0,0);\n    if(maxv<c){\n        maxv=c;\n        maxi=oldarg;\n    }\n}\n\n\nint main(void){\n    while((cin >> h >> w >> c)&&(h||w||c)){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>p[i][j];\n                p[i][j]--;\n            }\n        }\n        maxv=-1;\n        maxi=-1;\n        for(int i=0;i<1296;i++){\n            for(int x=0;x<h;x++){\n                for(int y=0;y<w;y++){\n                    buf[x][y]=p[x][y];\n                }\n            }\n            check(i+1296*(c-1));\n        }\n        cout<<maxv<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n// #include <boost/foreach.hpp>\n// #include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n//#define INF 1e9\n#define LINF 1e18\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define int long long\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n// int dx[]={0,1,0,-1};\n// int dy[]={1,0,-1,0};\nstruct edge{int to,cost;};\n//typedef pair<int,int> P;\n\nconst long long MOD=1000000007LL;\nbool isupper(char c){if('A'<=c&&c<='Z')return 1;return 0;}\nbool islower(char c){if('a'<=c&&c<='z')return 1;return 0;}\nbool isPrime(int x){if(x==1)return 0;if(x==2)return 1;if(x%2==0)return 0;for(int i=3;i*i<=x;i++)if(x%i==0)return 0;return 1;}\nbool iskaibun(string s){for(int i=0;i<s.size()/2;i++)if(s[i]!=s[s.size()-i-1])return 0;return 1;}\nbool isnumber(char c){return ('0'<=c&&c<='9');}\nbool isalpha(char c){return (isupper(c)||islower(c));}\ntemplate<typename T> \nvoid print(vector<T> v){\n    for(int i=0;i<v.size();i++){\n        if(i)cout<<\" \";\n        cout<<v[i];\n    }\n    cout<<endl;\n}\n\ntemplate<typename T>\nvoid printendl(vector<T> v){\n    for(auto date:v)cout<<date<<endl;\n}\n\ntemplate<typename T>\nvoid printvv(vector<vector<T>> v){\n    for(int i=0;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++){\n            if(j)cout<<\" \";\n            cout<<v[i][j];\n        }\n        cout<<endl;\n    }\n}\nint gcd(int a,int b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    else return gcd(b,a%b);\n}\n\nstruct Point{\n    int x,y;\n};\n\nint ans=0;\nint h,w,C;\nvector<vector<int>> looked(h,vector<int>(w,-1));\n\nint count(vector<vector<int>>& v,int c){\n    Point init=Point{0,0};\n    int target_color=v[0][0];\n    if(target_color!=C){\n        return -1;\n    }\n    queue<Point> q;\n    q.push(init);\n    int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n    looked.clear();\n    looked.resize(h,vector<int>(w,-1));\n    looked[0][0]=1;\n    int ret=1;\n    while(!q.empty()){\n        Point now=q.front();\n        q.pop();\n        rep(i,0,4){\n            int nx=now.x+dx[i],ny=now.y+dy[i];\n            if(0<=ny&&0<=nx&&ny<h&&nx<w&&looked[ny][nx]==-1){\n                looked[ny][nx]=1;\n                if(v[ny][nx]==target_color){\n                    ret++;\n                    q.push(Point{nx,ny});\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nvoid dfs(int deep,vector<vector<int>> v,int c){ //再起の回数、配列、どの色に変えるか\n    if(deep==5){\n        int ret=count(v,c);\n        if(ans<ret){\n            ans=ret;\n            //printvv(v);\n        }\n        return;\n    }\n    int lu_color=v[0][0];\n    if(lu_color==c){\n        return ;\n    }\n    v[0][0]=c;\n    Point init=Point{0,0};\n    queue<Point> q;\n    q.push(init);\n    int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n    looked.clear();\n    looked.resize(h,vector<int>(w,-1));\n    //vector<Point> changed;\n    while(!q.empty()){\n        Point now=q.front();\n        q.pop();\n        rep(i,0,4){\n            int nx=now.x+dx[i],ny=now.y+dy[i];\n            if(0<=ny&&0<=nx&&ny<h&&nx<w&&looked[ny][nx]==-1){\n                looked[ny][nx]=1;\n                if(v[ny][nx]==lu_color){\n                    v[ny][nx]=c;\n                    q.push(Point{nx,ny});\n                    //changed.push_back(Point{nx,ny});\n                }\n            }\n        }\n    }\n    rep(next_c,1,6+1){\n        dfs(deep+1, v, next_c);\n    }\n    // rep(i,0,changed.size()){\n    //     v[changed[i].y][changed[i].x]=lu_color;\n    // }\n    \n    return;\n    \n}\n\nsigned main (){\n    while(cin>>h>>w>>C){\n        if(h+w+C==0)break;\n        ans=0;\n        vector<vector<int>> v(h,vector<int>(w));\n        rep(i,0,h)rep(j,0,w)cin>>v[i][j];\n        \n        rep(init_c, 1, 6+1){\n            dfs(0, v, init_c);\n        }\n        cout<<ans<<endl;\n    }\n\n}\n/*\n3 5 5\n1 6 3 2 5\n2 5 4 6 1\n1 2 4 1 5\n4 5 6\n1 5 6 1 2\n1 4 6 3 2\n1 5 2 3 2\n1 1 2 3 2\n1 1 5\n1\n1 8 6\n1 2 3 4 5 1 2 3\n8 1 1\n1\n2\n3\n4\n5\n1\n2\n3\n8 8 6\n5 2 5 2 6 5 4 2\n4 2 2 2 5 2 2 2\n4 4 4 2 5 2 2 2\n6 4 5 2 2 2 6 6\n6 6 5 5 2 2 6 6\n6 2 5 4 2 2 6 6\n2 4 4 4 6 2 2 6\n2 2 2 5 5 2 2 2\n8 8 2\n3 3 5 4 1 6 2 3\n2 3 6 4 3 6 2 2\n4 1 6 6 6 4 4 4\n2 5 3 6 3 6 3 5\n3 1 3 4 1 5 6 3\n1 6 6 3 5 1 5 3\n2 4 2 2 2 6 5 3\n4 1 3 6 1 5 5 4\n0 0 0\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define L(a,d) ((a)<<((d)*3))\n#define R(a,d) (((a)>>((d)*3))&7)\nint h,w,c,f[16][16],ofs[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\nvoid P(int d){\n  int m=~L(7,d+1);\n  rep(i,h)rep(j,w){\n    f[i][j]&=m;\n    f[i][j]|=L(R(f[i][j],d),d+1);\n  }\n}\nint F(int x,int y, int d, int C){\n  int n=1;\n  int a=R(f[y][x],d);\n  int m=~L(7,d+1);\n  f[y][x]&=m;\n  f[y][x]|=L(C,d+1);\n  for(auto l:ofs){\n    int s=x+l[0];\n    int t=y+l[1];\n    if(0<=s&&s<w&&0<=t&&t<h&&R(f[t][s],d)==a&&R(f[t][s],d+1)!=C)n+=F(s,t,d,C);\n  }\n  return n;\n}\nint D(int d){\n  if(d&4){\n    P(d);\n    F(0,0,d,c);\n    P(d+1);\n    return F(0,0,d+1,7);\n  }\n  int x;\n  for(int r=1;r<=6;++r){\n    P(d);\n    F(0,0,d,r);\n    int v=D(d+1);\n    x=x>v?x:v;\n  }\n  return x;\n}\nint main() {\n  while(cin>>h>>w>>c,h){\n    rep(i,h)rep(j,w)cin>>f[i][j];\n    cout<<D(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\nint h,w,c;\n\nint p[7][10][10];\nint cp[10][10];\n\nint cal_dfs(int x,int y){\n\tint res=1;\n\tcp[x][y]=-1;\n\tif(x+1<h&&cp[x+1][y]==c){\n\t\tres+=cal_dfs(x+1,y);\n\t}\n\tif(x-1>=0&&cp[x-1][y]==c){\n\t\tres+=cal_dfs(x-1,y);\n\t}\n\tif(y+1<w&&cp[x][y+1]==c){\n\t\tres+=cal_dfs(x,y+1);\n\t}\n\tif(y-1>=0&&cp[x][y-1]==c){\n\t\tres+=cal_dfs(x,y-1);\n\t}\n\treturn res;\n}\n\nint cal(){\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcp[i][j]=p[5][i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(i*j==0&&cp[i][j]==c)res=max(res,cal_dfs(i,j));\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid change_dfs(int x,int y,int t,int k,int col){\n\tif(k==col)return;\n\tp[t][x][y]=col;\n\tif(x+1<h&&p[t][x+1][y]==k){\n\t\tchange_dfs(x+1,y,t,k,col);\n\t}\n\tif(x-1>=0&&p[t][x-1][y]==k){\n\t\tchange_dfs(x-1,y,t,k,col);\n\t}\n\tif(y+1<w&&p[t][x][y+1]==k){\n\t\tchange_dfs(x,y+1,t,k,col);\n\t}\n\tif(y-1>=0&&p[t][x][y-1]==k){\n\t\tchange_dfs(x,y-1,t,k,col);\n\t}\n}\n\nvoid change(int t,int col){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tp[t+1][i][j]=p[t][i][j];\n\t\t}\n\t}\n\tchange_dfs(0,0,t+1,p[t+1][0][0],col);\n}\n\nint solve(int t){\n\tif(t==5)return cal();\n\tint res=0;\n\tfor(int i=1;i<=6;i++){\n\t\tchange(t,i);\n\t\tres=max(res,solve(t+1));\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\twhile(cin >> h >> w >> c,c){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> p[0][i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",solve(0));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint h, w, c;\nint cnt = 0;\n\nint dx[]={0, 0, -1, 1};\nint dy[]={-1, 1, 0, 0};\n\nvoid fill(vvi &field, int y, int x, int cb, int ca){\n  cnt++;\n  field[y][x] = ca;\n  REP(i, 4){\n    int sx = x + dx[i];\n    int sy = y + dy[i];\n    if(0 <= sx && 0<= sy && sx<w && sy<h) {\n      if(field[sy][sx] == cb) {\n        fill(field, sy, sx, cb, ca);\n      }\n    }\n  }\n}\n\nint result = 0;\nvoid dfs(vvi &field, int step){\n  if(step == 1) {\n    if(field[0][0] == c) return;\n    fill(field, 0, 0, field[0][0], c);\n    cnt = 0;\n    fill(field, 0, 0, field[0][0], 0);\n    result = max(result, cnt);\n    return;\n  }\n  FOR(i, 1, 7){\n    if(field[0][0] == i) continue;\n    vvi f = field;\n    fill(f, 0, 0, field[0][0], i);\n    dfs(f, step - 1);\n  }\n}\n\nint main() {\n  while(cin >> h >> w >> c, h | w | c) {\n    result = 0;\n    vvi field(h, vi(w, 0));\n    REP(y, h) REP(x, w){\n      cin >> field[y][x];\n    }\n\n    dfs(field, 5);\n    cout << result << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nint h, w, tc, p[8][8];\nbool m[8][8];\nvoid _mark(int x, int y, int c)\n{\n\tm[y][x] = true;\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (valid_pos(tx, ty, w, h) && !m[ty][tx] && p[ty][tx] == c)\n\t\t\t_mark(tx, ty, c);\n\t}\n}\nvoid mark(int c) { CL(m, 0); _mark(0, 0, c); }\nvoid change(int c)\n{\n\tmark(p[0][0]);\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tif (m[y][x])\n\t\t\t\tp[y][x] = c;\n}\nint count()\n{\n\tmark(tc);\n\tint res = 0;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tif (m[y][x])\n\t\t\t\t++res;\n\treturn res;\n}\nint dfs(int depth)\n{\n\tif (depth == 5)\n\t\treturn count();\n\telse\n\t{\n\t\tint res = 0;\n\t\tfor (int c = 1; c <= 6; ++c)\n\t\t{\n\t\t\tif (c != p[0][0] && (depth != 4 || c == tc))\n\t\t\t{\n\t\t\t\tint _p[8][8];\n\t\t\t\tmemcpy(_p, p, sizeof(p));\n\n\t\t\t\tchange(c);\n\t\t\t\tmax_swap(res, dfs(depth + 1));\n\n\t\t\t\tmemcpy(p, _p, sizeof(_p));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> h >> w >> tc, h)\n\t{\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tcin >> p[y][x];\n\t\tcout << dfs(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\n\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table & state, int from, int to, int x, int y){\n\tif (from==to) return;\n\tREP(i, 4){\n\t\tif(state[y+dy[i]][x+dx[i]] != from) continue;\n\t\tstate[y+dy[i]][x+dx[i]] = to;\n\t\tfillColor(state, from, to, x+dx[i], y+dy[i]);\n\t}\n}\n\nint countColor(Table & state, int x, int y){\n\tint cnt = 0;\n\tREP(i, 4) {\n\t\tif (state[y + dy[i]][x + dx[i]] != g_c) continue;\n\t\tstate[y + dy[i]][x + dx[i]] = -1;\n\t\tcnt += 1 + countColor(state, x + dx[i], y + dy[i]);\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(state, 1, 1);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i, 1, 1);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w;\n\t\tif (h == 0) break;\n\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << recursion(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nint term(State& begin);\nint expression(State& begin) {\n\tint now_value = 0;\n\tif (*begin == '(') {\n\t\tbegin++;\n\t\tint d1 = expression(begin);\n\t\tint d2;\n\t\tif (*begin == '+') {\n\t\t\tbegin++;\n\t\t\td2 = expression(begin);\n\t\t\tnow_value = max(d1, d2);\n\t\t}\n\t\telse if(*begin == '*'){\n\t\t\tbegin++;\n\t\t\td2 = expression(begin);\n\t\t\tnow_value = min(d1, d2);\n\t\t}\n\t\tbegin++;\n\t}\n\telse {\n\t\tnow_value = term(begin);\n\t}\n\treturn now_value;\n}\nint term(State& begin) {\n\tint now_value = 0;\n\tif (*begin == '-') {\n\t\tbegin++;\n\t\tnow_value = 2 - expression(begin);\n\t}\n\telse if (*begin >= '0' && *begin <= '9') {\n\t\tnow_value = *begin - '0';\n\t\tbegin++;\n\t}\n\treturn now_value;\n}\nint main() {\n\twhile (true) {\n\t\tint h, w, c;\n\t\tcin >> h >> w >> c;\n\t\tif (h == 0) return 0;\n\t\tint base[9][9] = {};\n\t\tint grid[9][9] = {};\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tcin >> grid[i][q];\n\t\t\t}\n\t\t}\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < pow(6, 4); ++i) {\n\t\t\tREP(q, h) {\n\t\t\t\tREP(j, w) {\n\t\t\t\t\tbase[q][j] = grid[q][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint coloring[5] = {};\n\t\t\tint geko = i;\n\t\t\tREP(q, 4) {\n\t\t\t\tcoloring[q] = geko % 6 + 1;\n\t\t\t\tgeko /= 6;\n\t\t\t}\n\t\t\tcoloring[4] = c;\n\t\t\tREP(q, 5) {\n\t\t\t\tint geko = base[0][0];\n\t\t\t\tif (geko == coloring[q]) continue;\n\t\t\t\tbase[0][0] = coloring[q];\n\t\t\t\tqueue<pair<int, int>> next;\n\t\t\t\tnext.push(make_pair(0, 0));\n\t\t\t\twhile (next.empty() == false) {\n\t\t\t\t\tpair<int, int> now = next.front();\n\t\t\t\t\tnext.pop();\n\t\t\t\t\tint xe[4] = { 1,-1,0,0 };\n\t\t\t\t\tint ye[4] = { 0,0,1,-1 };\n\t\t\t\t\tREP(j, 4) {\n\t\t\t\t\t\tint now_x = now.first + xe[j];\n\t\t\t\t\t\tint now_y = now.second + ye[j];\n\t\t\t\t\t\tif (now_x >= 0 && now_x < h && now_y >= 0 && now_y < w) {\n\t\t\t\t\t\t\tif (base[now_x][now_y] == geko) {\n\t\t\t\t\t\t\t\tbase[now_x][now_y] = coloring[q];\n\t\t\t\t\t\t\t\tnext.push(make_pair(now_x, now_y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long now_ans = 1;\n\t\t\tqueue<pair<int, int>> next;\n\t\t\tnext.push(make_pair(0, 0));\n\t\t\tbase[0][0] = 0;\n\t\t\twhile (next.empty() == false) {\n\t\t\t\tpair<int, int> now = next.front();\n\t\t\t\tnext.pop();\n\t\t\t\tint xe[4] = { 1,-1,0,0 };\n\t\t\t\tint ye[4] = { 0,0,1,-1 };\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tint now_x = now.first + xe[j];\n\t\t\t\t\tint now_y = now.second + ye[j];\n\t\t\t\t\tif (now_x >= 0 && now_x < h && now_y >= 0 && now_y < w) {\n\t\t\t\t\t\tif (base[now_x][now_y] == c) {\n\t\t\t\t\t\t\tbase[now_x][now_y] = 0;\n\t\t\t\t\t\t\tnow_ans++;\n\t\t\t\t\t\t\tnext.push(make_pair(now_x, now_y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans < now_ans) {\n\t\t\t\tans = max(ans, now_ans);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int MAX_W=8;\n\nstruct panel{\n  panel(){}\n  panel(const panel& pnl){\n    REP(i,MAX_W)REP(j,MAX_W)p[j][i]=pnl.p[j][i];\n  }\n  int p[MAX_W][MAX_W];\n};\nint w,h,c;\n\nvoid draw(panel* pnl,int x,int y,int nc){\n  int cc=pnl->p[y][x];\n  pnl->p[y][x]=nc;\n  if(x>0&&pnl->p[y][x-1]==cc)draw(pnl,x-1,y,nc);\n  if(x+1<w&&pnl->p[y][x+1]==cc)draw(pnl,x+1,y,nc);\n  if(y>0&&pnl->p[y-1][x]==cc)draw(pnl,x,y-1,nc);\n  if(y+1<h&&pnl->p[y+1][x]==cc)draw(pnl,x,y+1,nc);\n}\nint cntRecursive(panel* pnl,int x,int y){\n  pnl->p[y][x]=-1;\n  int sum=1;\n  if(x>0&&pnl->p[y][x-1]==c)sum+=cntRecursive(pnl,x-1,y);\n  if(x+1<w&&pnl->p[y][x+1]==c)sum+=cntRecursive(pnl,x+1,y);\n  if(y>0&&pnl->p[y-1][x]==c)sum+=cntRecursive(pnl,x,y-1);\n  if(y+1<h&&pnl->p[y+1][x]==c)sum+=cntRecursive(pnl,x,y+1);\n  return sum;\n}\nint cnt(panel* pnl){\n  panel check(*pnl);\n  return cntRecursive(&check,0,0);\n}\nint dfs(panel* pnl,int depth=1){\n  if(depth==5){\n    panel pnl_(*pnl);\n    draw(&pnl_,0,0,c);\n    return cnt(&pnl_);\n  }\n  int result=0;\n  for(int i=1;i<=6;i++){\n    if(depth==4&&i==c)continue;\n    if(pnl->p[0][0]==i)continue;\n    panel pnl_(*pnl);\n    draw(&pnl_,0,0,i);\n    result=max(result,dfs(&pnl_,depth+1));\n  }\n  return result;\n}\nint main(){ _;\n  while(cin>>h>>w>>c,(h|w|c)!=0){\n    panel pnl;\n    REP(i,h)REP(j,w)cin>>pnl.p[i][j];\n    cout<<dfs(&pnl)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\n// #define DEBUG\n\nusing namespace std;\n\nint h, w, c;\nint p[9][9];\n\nvoid Coloring(int y, int x, int c, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      Coloring(ny, nx, c, checked);\n    }\n  }\n  p[y][x] = c;\n  checked[y][x] = false;\n}\n\nint Count(int y, int x, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return 0;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      ret += Count(ny, nx, checked);\n    }\n  }\n\n  return ret + 1; \n}\n\nint dfs(int limit, int c, int* pv = nullptr) {\n  if (limit == 0) {\n    bool checked[9][9] = { false };\n    return Count(0, 0, checked);\n  }\n  int ret = 0;\n  for (int i = 1; i <= 6; i++) {\n    if (limit == 1 && i != c) {\n      continue;\n    }\n    int tmp[9][9];\n    memcpy(tmp, p, sizeof(p));\n    bool checked[9][9] = { false };\n    Coloring(0, 0, i, checked);\n    int tpv[10] = { 0 };\n    int d = dfs(limit - 1, c, tpv);\n    memcpy(p, tmp, sizeof(p)); // UNDO\n    if (d > ret) {\n      ret = d;\n      if (pv != nullptr) {\n        pv[limit] = i;\n        for (int j = 0; j < limit; j++) {\n          pv[j] = tpv[j];\n        }\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> h >> w >> c;\n    if (h + w + c == 0) {\n      break;\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> p[i][j];\n      }\n    }\n    int pv[10] = { 0 };\n    cout << dfs(5, c) << endl;\n   \n#ifdef DEBUG\n    for (int i = 0; i < 10; i++) {\n      cout << pv[i] << \" \\n\"[i == 9];\n    }\n#endif\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define ISIN(x, y, w, h) (x >= 0 && x < w && y >= 0 && y < h)\n\n#define f first\n#define s second\n\nusing namespace std;\n\npair<int, int> joint[70];\nint h, w, c;\nint p[8][8];\nbool f[8][8];\n\nconst int dx[4] = { 1,-1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1};\n\nint getInt(){ int r; scanf(\"%d\", &r); return r; }\n\nint solve(int now, int prev, int cnt){\n  int ret = 0;\n\n  //printf(\"solve(%d, %d, %d)\\n\", now, prev, cnt);\n\n  if(now == 6) return cnt;\n\n  for(int col = 1; col <= 6; col++){\n    int cc = cnt;\n    queue<pair<int, int> > q;\n\n    if(now == 5 && col != c) continue;\n    if(now != 5 && col != 0 && col == prev) continue;\n    if(now == 0 && col != prev) continue;\n\n    REP(i, cnt) q.push(joint[i]);\n\n    while(q.size()){\n      int x = q.front().s;\n      int y = q.front().f;\n\n      q.pop();\n\n      REP(i, 4){\n\tint xx = x + dx[i];\n\tint yy = y + dy[i];\n\n\tif(ISIN(xx, yy, w, h) && p[yy][xx] == col && !f[yy][xx]){\n\t  f[yy][xx] = true;\n\t  joint[cc].f = yy;\n\t  joint[cc].s = xx;\n\t  q.push(joint[cc++]);\n\t}\n      }\n    }\n\n    ret = max(ret, solve(now + 1, col, cc));\n    \n    for(int i = cnt; i < cc; i++){\n      int x = joint[i].s;\n      int y = joint[i].f;\n      \n      f[y][x] = false;\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    h = getInt();\n    w = getInt();\n    c = getInt();\n\n    if(h + w + c == 0) break;\n\n    REP(i, h) REP(j, w) p[i][j] = getInt();\n    f[0][0] = true;\n\n    printf(\"%d\\n\", solve(0, p[0][0], 1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nvector< vector<bool> > getunion(const vector< vector<int> >& base){\n\tvector< vector<bool> > ret;\n\tstack< pair<int,int> > nxt;\n\tint xmax=base[0].size();\n\tint ymax=base.size();\n\tint tar=base[0][0];\n\tint curx,cury;\n\tret.resize(ymax);\n\tfor(int i=0;i<ymax;i++)ret[i].resize(xmax);\n\tnxt.push(pair<int,int>(0,0));\n\twhile(!nxt.empty()){\n\t\tcurx=nxt.top().first;\n\t\tcury=nxt.top().second;\n\t\tnxt.pop();\n\t\tif(base[cury][curx]==tar&&!ret[cury][curx]){\n\t\t\tret[cury][curx]=true;\n\t\t\tif(curx>0)nxt.push(pair<int,int>(curx-1,cury));\n\t\t\tif(curx<xmax-1)nxt.push(pair<int,int>(curx+1,cury));\n\t\t\tif(cury>0)nxt.push(pair<int,int>(curx,cury-1));\n\t\t\tif(cury<ymax-1)nxt.push(pair<int,int>(curx,cury+1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector< vector<int> >ccolor(const vector< vector<int> >& base,int color){\n\tvector< vector<int> > ret;\n\tvector< vector<bool> > uni=getunion(base);\n\tint ymax=base.size();\n\tint xmax=base[0].size();\n\tret=base;\n\tfor(int i=0;i<ymax;i++){\n\t\tfor(int j=0;j<xmax;j++){\n\t\t\tif(uni[i][j])ret[i][j]=color;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint score(const vector< vector<int> >& base){\n\tvector< vector<bool> > get=getunion(base);\n\tint ymax=get.size();\n\tint xmax=get[0].size();\n\tint ret=0;\n\tfor(int i=0;i<ymax;i++){\n\t\tfor(int j=0;j<xmax;j++){\n\t\t\tif(get[i][j])ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint cal(const vector< vector<int> >& base,int target,int count){\n\tif(count==1){\n\t\treturn score(ccolor(base,target));\n\t}else{\n\t\tvector< vector<int> > cald;\n\t\tint max=0,get;\n\t\t// 最大色数指定\n\t\tfor(int i=1;i<7;i++){\n\t\t\tif(i!=base[0][0]){\n\t\t\t\tcald=ccolor(base,i);\n\t\t\t\tget=cal(cald,target,count-1);\n\t\t\t\tif(get>max)max=get;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n\nint main(){\n\tint xsize,ysize,target;\n\tvector< vector<int> > base;\n\twhile(true){\n\t\tcin>>ysize>>xsize>>target;\n\t\tif(target==0)break;\n\t\tbase.resize(ysize);\n\t\tfor(int i=0;i<ysize;i++){\n\t\t\tbase[i].resize(xsize);\n\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\tcin>>base[i][j];\n\t\t\t}\n\t\t}\n//繰り返し回数指定\n\t\tcout<<cal(base,target,5)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nint h, w, c;\nvector<vector< int > > mas(10, vector< int >(10));\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint visited[10][10];\n\nint countC(int x, int y) {\n    if(mas[y][x] != c) return 0;\n    visited[y][x] = 1;\n    int ret = 1;\n    for(int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && !visited[ny][nx]) {\n            ret += countC(nx, ny);\n        }\n    }\n    return ret;\n}\n\nvoid change(int x, int y, int orig, int color) {\n    visited[y][x] = 1;\n    mas[y][x] = color;\n    for(int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && !visited[ny][nx] && mas[ny][nx] == orig) {\n            change(nx, ny, orig, color);\n        }\n    }\n}\n\nint rec(int cnt) {\n    if(cnt == 5) {\n        memset(visited, 0, sizeof(visited));\n        return countC(0, 0);\n    }\n\n    int ret = 0;\n    int prev = mas[0][0];\n    vector< vector< int > > temp = mas;\n    for(int i = 1; i <= 6; i++) {\n        if(i == prev) continue;\n        memset(visited, 0, sizeof(visited));\n        change(0, 0, prev, i);\n        ret = max(ret, rec(cnt + 1));\n        mas = temp;\n    }\n    return ret;\n}\n\nint main() {\n\n    while(cin >> h >> w >> c, h) {\n        for(int i = 0; i < h; i++)\n            for(int j = 0; j < w; j++)\n                cin >> mas[i][j];\n\n        cout << rec(0) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define L(a,d) ((a)<<((d)*3))\n#define R(a,d) (((a)>>((d)*3))&7)\nint h,w,c,f[16][16],ofs[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nvoid P(int d){\n  int m=~L(7,d+1);\n  rep(i,h)rep(j,w){\n    f[i][j]&=m;\n    f[i][j]|=L(R(f[i][j],d),d+1);\n  }\n}\nint F(int x,int y, int d, int C){\n  int n=1;\n  int a=R(f[y][x],d);\n  int m=~L(7,d+1);\n  f[y][x]&=m;\n  f[y][x]|=L(C,d+1);\n  for(auto l:ofs){\n    int s=x+l[0];\n    int t=y+l[1];\n    if(0<=s&&s<w&&0<=t&&t<h&&R(f[t][s],d)==a&&R(f[t][s],d+1)!=C)n+=F(s,t,d,C);\n  }\n  return n;\n}\nint D(int d){\n  if(d&4){\n    P(d);\n    F(0,0,d,c);\n    P(d+1);\n    return F(0,0,d+1,7);\n  }\n  int x=0;\n  for(int r=1;r<=6;++r){\n    P(d);\n    F(0,0,d,r);\n    int v=D(d+1);\n    x=x>v?x:v;\n  }\n  return x;\n}\nint main() {\n  while(cin>>h>>w>>c,h){\n    rep(i,h)rep(j,w)cin>>f[i][j];\n    cout<<D(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n\n#define int long long\n\nusing namespace std;\n\nclass Solver {\n};\n\nsigned main() {\n\twhile (true) {\n\t\tint h, w, c;\n\t\tcin >> h >> w >> c;\n\t\tif (h == 0)break;\n\n\t\tint all = pow(5, 5);\n\n\t\tvector<vector<int>> grid(h, vector<int>(w, 0));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)cin >> grid[i][j];\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int z = 0; z < all; z++) {\n\t\t\tvector<vector<int>> now(h, vector<int>(w, 0));\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tnow[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint val = z;\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tint color = now[0][0];\n\t\t\t\tint to = val % 5 + 1;\n\t\t\t\tif (to >= color)to++;\n\t\t\t\tval /= 5;\n\n\t\t\t\tqueue<tuple<int, int>> que;\n\t\t\t\tque.push(make_tuple(0, 0));\n\t\t\t\twhile (que.size() > 0) {\n\t\t\t\t\tint y = get<0>(que.front());\n\t\t\t\t\tint x = get<1>(que.front());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (now[y][x] != color)continue;\n\n\t\t\t\t\tnow[y][x] = to;\n\t\t\t\t\tif (y > 0 && now[y - 1][x] == color) {\n\t\t\t\t\t\tque.push(make_tuple(y - 1, x));\n\t\t\t\t\t}\n\t\t\t\t\tif (y + 1 < h && now[y + 1][x] == color) {\n\t\t\t\t\t\tque.push(make_tuple(y + 1, x));\n\t\t\t\t\t}\n\t\t\t\t\tif (x > 0 && now[y][x - 1] == color) {\n\t\t\t\t\t\tque.push(make_tuple(y, x - 1));\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < w && now[y][x + 1] == color) {\n\t\t\t\t\t\tque.push(make_tuple(y, x + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint cnt = 0;\n\t\t\tvector<vector<bool>> visited(h, vector<bool>(w, false));\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (visited[i][j] || now[i][j] != c)continue;\n\n\t\t\t\t\tqueue<tuple<int, int>> que;\n\t\t\t\t\tque.push(make_tuple(i, j));\n\t\t\t\t\tint tmp = 0;\n\t\t\t\t\twhile (que.size() > 0) {\n\t\t\t\t\t\tint y = get<0>(que.front());\n\t\t\t\t\t\tint x = get<1>(que.front());\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\tif (visited[y][x])continue;\n\n\t\t\t\t\t\tvisited[y][x] = true;\n\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\tif (y > 0 && now[y - 1][x] == c) {\n\t\t\t\t\t\t\tque.push(make_tuple(y - 1, x));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (y + 1 < h && now[y + 1][x] == c) {\n\t\t\t\t\t\t\tque.push(make_tuple(y + 1, x));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x > 0 && now[y][x - 1] == c) {\n\t\t\t\t\t\t\tque.push(make_tuple(y, x - 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < w && now[y][x + 1] == c) {\n\t\t\t\t\t\t\tque.push(make_tuple(y, x + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcnt = max(cnt, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, cnt);\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\n\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table & state, int from, int to, int x, int y){\n\tif (from==to) return;\n\tREP(i, 4){\n\t\tif(state[y+dy[i]][x+dx[i]] != from) continue;\n\t\tstate[y+dy[i]][x+dx[i]] = to;\n\t\tfillColor(state, from, to, x+dx[i], y+dy[i]);\n\t}\n}\n\nint countColor(Table & state, int x, int y){\n\tint cnt = 0;\n\tREP(i, 4) {\n\t\tif (state[y + dy[i]][x + dx[i]] != g_c) continue;\n\t\tstate[y + dy[i]][x + dx[i]] = -1;\n\t\tcnt += 1 + countColor(state, x + dx[i], y + dy[i]);\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(state, 1, 1);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i, 1, 1);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w;\n\t\tif (h == 0) break;\n\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << recursion(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,a,n) for(i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nbool used[10][10];\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\nint ope[5],field[10][10],w,h,c;\n\nint marking(int x, int y, int color){\n  if( x < 0 || y < 0 || x >= w || y >= h || used[y][x] ) return 0;\n  if( field[y][x] != color ) return 0;\n  used[y][x] = true;\n  //printf(\"%d,%d\\n\",x,y);\n  return marking(x+1,y,color) + marking(x-1,y,color) +\n    marking(x,y+1,color) + marking(x,y-1,color) + 1;\n}\n\nvoid umeru(int x, int y, int cc, int next){\n  if( x < 0 || y < 0 || x >= w || y >= h ) return;\n  if( field[y][x] != cc ) return;\n  //printf(\"%d,%d\\n\",x,y);\n  field[y][x] = next;\n  umeru(x+1,y,cc,next); umeru(x-1,y,cc,next);\n  umeru(x,y+1,cc,next); umeru(x,y-1,cc,next);\n}\n\nint solve(){\n  int i,j,k;\n  rep(i,5) if( field[0][0] != ope[i] ) umeru(0,0,field[0][0],ope[i]);\n  memset(used, false, sizeof(used));\n  return marking(0,0,field[0][0]);\n}\n\nint main(){\n  int i,j,k,l,ii,jj;\n  \n  while( cin >> h >> w >> c, h|w|c ){\n    \n    rep(i,h) rep(j,w) scanf(\"%d\",&field[i][j]);\n\n    int tmp[10][10];\n    rep(i,h) rep(j,w) tmp[i][j] = field[i][j];\n\n    int res = 0;\n    REP(i,1,7){\n      REP(j,1,7){\n        REP(k,1,7){\n          REP(l,1,7){\n            //printf(\"%d,%d,%d,%d,%d, res=%d\\n\",i,j,k,l,c,res);\n            ope[0] = i; ope[1] = j;\n            ope[2] = k; ope[3] = l;\n            ope[4] = c;\n\n            // copy\n            rep(ii,h) rep(jj,w) field[ii][jj] = tmp[ii][jj];\n\n            res = max(res, solve());\n          }\n        }\n      }\n    }\n\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-9;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tvector<int>ans;\n\tint six[] = { 1,6,36,216,1296 };\n\tint dir[] = { 1,0,-1,0,1 };\n\twhile (H) {\n\t\tvector<vector<int>>v(H, vector<int>(W));\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 6 * 6 * 6 * 6; i++) {\n\t\t\tauto field = v;\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint c = (i%six[j + 1]) / six[j];\n\t\t\t\tc++;\n\t\t\t\tqueue<pair<int, int>>Q;\n\t\t\t\tvector<vector<bool>>used(H, vector<bool>(W));\n\t\t\t\tQ.push({ 0,0 });\n\t\t\t\tint bc = field[0][0];\n\t\t\t\tused[0][0] = true;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint cy = Q.front().first;\n\t\t\t\t\tint cx = Q.front().second;\n\t\t\t\t\tfield[cy][cx] = c;\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ny = cy + dir[k];\n\t\t\t\t\t\tint nx = cx + dir[k + 1];\n\t\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W)continue;\n\t\t\t\t\t\tif (used[ny][nx])continue;\n\t\t\t\t\t\tif (field[ny][nx] == bc) {\n\t\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<int, int>>Q;\n\t\t\tQ.push({ 0,0 });\n\t\t\tint bc = field[0][0];\n\t\t\tvector<vector<bool>>used(H, vector<bool>(W));\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint cy = Q.front().first;\n\t\t\t\tint cx = Q.front().second;\n\t\t\t\tfield[cy][cx] = K;\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = cy + dir[k];\n\t\t\t\t\tint nx = cx + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W)continue;\n\t\t\t\t\tif (used[ny][nx])continue;\n\t\t\t\t\tif (field[ny][nx] == bc) {\n\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint box = 0;\n\t\t\tQ.push({ 0,0 });\n\t\t\tfield[0][0] = 0;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tbox++;\n\t\t\t\tint cy = Q.front().first;\n\t\t\t\tint cx = Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint ny = cy + dir[k];\n\t\t\t\t\tint nx = cx + dir[k + 1];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W)continue;\n\t\t\t\t\tif (field[ny][nx] == K) {\n\t\t\t\t\t\tfield[ny][nx] = 0;\n\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = max(ret, box);\n\t\t}\n\t\tans.push_back(ret);\n\t\tcin >> H >> W >> K;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nint h, w, c;\nstruct map{\n\tint m[12][12];\n\tmap(){\n\t\tfill( m[0], m[0]+12*12, 0 );\n\t}\n};\nstruct status{\n\tint to, x, y;\n\tstatus(int t, int _x, int _y){\n\t\tx = _x;\n\t\ty = _y;\n\t\tto = t;\n\t}\n};\nvoid calc(int to, map &m){\n\tstack<status> st;\n\tst.push( status(to, 1, 1) );\n\twhile(!st.empty()){\n\t\tstatus s = st.top();\n\t\tst.pop();\n//\tcout << s.x << \" \" << s.y << endl;\n\t\tif( m.m[s.x][s.y] > 9 || m.m[s.x][s.y] == to ){\n\t\t\tm.m[s.x][s.y] = to + 10;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif( m.m[ s.x+vx[i] ][ s.y+vy[i] ] != to + 10 )\n\t\t\t\t\tst.push( status(to, s.x+vx[i], s.y+vy[i]) );\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int count, int to, map m){\n\tint result=0;\n\tcalc(to, m);\n//\tfor(int i=0; i<10; i++){\n//\t\tfor(int j=0; j<10; j++)\n//\t\t\tcout << m.m[i][j] << ' ';\n//\t\tcout << endl;\n//\t}\n\tif( count == 4 ){\n\t\tcalc(c, m);\n//\tfor(int i=0; i<10; i++){\n//\t\tfor(int j=0; j<10; j++)\n//\t\t\tcout << m.m[i][j] << ' ';\n//\t\tcout << endl;\n//\t}\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tif( m.m[i][j] > 9 )\n\t\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(int i=1; i<=6; i++){\n\t\t\tif( i != to )\n\t\t\t\tresult = max( result, solve(count+1, i, m) );\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(){\n\twhile(cin >> h >> w >> c, h|w|c){\n\t\tmap m;\n\t\tfor(int x=1; x<=h; x++){\n\t\t\tfor(int y=1; y<=w; y++){\n\t\t\t\tcin >> m.m[x][y];\n\t\t\t}\n\t\t}\n\t\tint ans = solve(0, m.m[1][1], m);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nint maxc;\n\nint count_color(vector<vector<int> > &m) {\n  if(m[0][0] != maxc) return 0;\n  int c = m[0][0];\n  int ret = 0;\n  queue<pair<int,int> > q;\n  q.push(make_pair(0,0));\n  while(!q.empty()) {\n    pair<int,int> p = q.front(); q.pop();\n    if(m[p.second][p.first] == -1) continue;\n    ret++;\n    m[p.second][p.first] = -1;\n    for(int k=0; k<4; ++k) {\n      int nx = p.first + dx[k], ny = p.second + dy[k];\n      if(nx < 0 || nx > m[0].size()-1 || ny < 0 || ny > m.size()-1) continue;\n      if(m[ny][nx] == c) q.push(make_pair(nx,ny));\n    }\n  }\n  return ret;\n}\n\nvector<vector<int> > change(vector<vector<int> > m,int c) {\n  int nc = m[0][0];\n  queue<pair<int,int> > q;\n  q.push(make_pair(0,0));\n  while(!q.empty()) {\n    pair<int,int> p = q.front(); q.pop();\n    m[p.second][p.first] = c;\n    for(int k=0; k<4; ++k) {\n      int nx = p.first + dx[k], ny = p.second + dy[k];\n      if(nx < 0 || nx > m[0].size()-1 || ny < 0 || ny > m.size()-1) continue;\n      if(m[ny][nx] == nc) q.push(make_pair(nx,ny));\n    }\n  }\n  return m;\n}\n\nint dfs(int depth,vector<vector<int> > m) {\n  //  cout<<depth<<endl;\n  if(depth == 5) {\n    return count_color(m);\n  }\n\n  int ret = 0;\n  for(int i=1; i<=6; ++i) {\n    //    cout<<i<<endl;\n    if(m[0][0] == i) continue;\n    vector<vector<int> > nm = change(m,i);\n    ret = max(ret, dfs(depth+1,nm));\n  }\n  return ret;\n}\n\nint main() {\n  int h,w,c;\n  while(cin>>h>>w>>c, h|w|c) {\n    maxc = c;\n    vector<vector<int> > mp(h,vector<int>(w,0));\n\n    for(int i=0; i<h; ++i) {\n      for(int j=0; j<w; ++j) {\n        cin>>mp[i][j];\n      }\n    }\n\n    cout<<dfs(0,mp)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table & state, int from, int to, int x, int y){\n\tif (from==to) return;\n\tREP(i, 4){\n\t\tif(state[y+dy[i]][x+dx[i]] != from) continue;\n\t\tstate[y+dy[i]][x+dx[i]] = to;\n\t\tfillColor(state, from, to, x+dx[i], y+dy[i]);\n\t}\n}\n\nint countColor(Table & state, int x, int y){\n\tint cnt = 0;\n\tREP(i, 4) {\n\t\tif (state[y + dy[i]][x + dx[i]] != g_c) continue;\n\t\tstate[y + dy[i]][x + dx[i]] = -1;\n\t\tcnt += 1 + countColor(state, x + dx[i], y + dy[i]);\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(state, 1, 1);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i, 1, 1);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w \n\t\tif (h == 0) break;\n\t\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << walk(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint h, w, c;\nint p[8][8];\nint cnt, ans;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool done[8][8];\n\nvoid cntclr(int x, int y, int f, int t)\n{\n  if(p[y][x] != f) return;\n  done[y][x] = true;\n  p[y][x] = t; cnt++;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(0 <= nx && nx < w && 0 <= ny && ny < h && !done[ny][nx]) cntclr(nx, ny, f, t);\n  }\n}\n\nvoid solve(int lim)\n{\n  if(lim <= 0) {\n    memset(done, false, sizeof(done));\n    cnt = 0; cntclr(0, 0, c, -1);\n    ans = max(cnt, ans);\n    return;\n  }\n  int q[8][8];\n  for(int d = 1; d <= 6; d++) {\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) q[i][j] = p[i][j], done[i][j] = false;\n    }\n    cnt = 0; cntclr(0, 0, p[0][0], d); solve(lim-1);\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) p[i][j] = q[i][j], done[i][j] = false;\n    }\n  }\n}\n\nint main()\n{\n  while(cin >> h >> w >> c, h) {\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) cin >> p[i][j];\n    }\n    ans = 0; solve(5);\n    cout << ans << endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint field[10][10];\nint H, W, C;\n\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint count_field() {\n  int c = field[1][1];\n  bool visit[10][10];\n  fill(&visit[0][0], &visit[9][10], false);\n  visit[1][1] = true;\n  int cnt = 1;\n  queue<P> Q;\n  Q.push(P(1, 1));\n  while (!Q.empty()) {\n    P cur = Q.front();\n    int x = cur.first;\n    int y = cur.second;\n    Q.pop();\n    \n    for (int i = 0; i < 4; i++) {\n      int tx = x + dx[i];\n      int ty = y + dy[i];\n      // printf(\"%d, %d = %d\\n\",tx, ty,  field[ty][tx]);\n      if (field[ty][tx] > 0 && !visit[ty][tx] && field[ty][tx] == C) {\n        visit[ty][tx] = true;\n        cnt++;\n        Q.push(P(tx, ty));\n      }\n    }\n  }\n  return cnt;\n}\n\nint fill_color(int color, vector<P>& filled) {\n  queue<P> Q;\n  Q.push(P(1, 1));\n  bool visit[10][10];\n  fill(&visit[0][0], &visit[9][10], false);\n  visit[1][1] = true;\n  int bc = field[1][1];\n  field[1][1] = color;\n  filled.push_back(P(1,1));\n  while (!Q.empty()) {\n    P cur = Q.front();\n    int x = cur.first;\n    int y = cur.second;\n    Q.pop();\n\n    for (int i = 0; i < 4; i++) {\n      int tx = x + dx[i];\n      int ty = y + dy[i];\n      if (field[ty][tx] > 0 && !visit[ty][tx] && field[ty][tx] == bc) {\n        visit[ty][tx] = true;\n        field[ty][tx] = color;\n        Q.push(P(tx, ty));\n        filled.push_back(P(tx, ty));\n      }\n    }\n  }\n}\n\nvoid reverse_color(int c, vector<P> & filled) {\n  for (int i = 0; i < filled.size(); i++) {\n    int x = filled[i].first;\n    int y = filled[i].second;\n    field[y][x] = c;\n  }\n}\n\nvoid print_field() {\n  for (int i = 1; i <= H; i++) {\n    for (int j = 1; j <= W; j++) {\n      printf(\"%d \", field[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint _solve(int depth) {\n  // print_field();\n  /*\n  if (depth == 4) {\n    int c = field[1][1];\n    filled.clear();\n    fill_color(C);\n    int res = count_field();\n    reverse_color(c);\n    return res;\n  }\n  */\n  if (depth == 5) {\n    return count_field();\n  }\n  int c = field[1][1];\n  int mx = 0;\n  for (int i = 1; i <= 6; i++) {\n    if (c != i) {\n      vector<P> prev;\n      fill_color(i, prev);\n      mx = max(_solve(depth + 1), mx);\n      reverse_color(c, prev);\n    }\n  }\n  return mx;\n}\n\nvoid solve() {\n  printf(\"%d\\n\", _solve(0));\n}\n\nvoid init() {\n  for (int i = 0; i <= H + 1; i++) {\n    for (int j = 0; j <= W + 1; j++) {\n      field[i][j] = 0;\n    }\n  }\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d %d \", &H, &W, &C);\n    init();\n    if (H == 0 && W == 0 && C == 0) {\n      return 0;\n    }\n    for (int i = 1; i <= H; i++) {\n      for (int j = 1; j <= W; j++) {\n        scanf(\"%d \", &field[i][j]);\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, from, to) for (int i = from; i < to; ++i)\n#define REP(i, from, to) for (int i = from; i <= to; ++i)\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint data[9][9];\nqueue<P> que;\nint dx[] = {-1, 0,1, 0};\nint dy[] = {0, -1, 0, 1};\nint x, y;\nint datax, datay, endC;\n\nvoid pData(int p[9][9]) {\n\tREP(i, 1, datay) {\n\t\tREP(j, 1, datax) {\n\t\t\tcout << p[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvoid copy(int p1[9][9], int p2[9][9]) {\n\tREP(i, 1, 8) {\n\t\tREP(j, 1, 8) {\n\t\t\tp1[i][j] = p2[i][j];\n\t\t}\n\t}\n}\n\nint countColor(int masu[9][9]) {\n\tbool isGone[9][9];\n\tREP(i, 1, 8) {\n\t\tREP(j, 1, 8) {\n\t\t\tisGone[i][j] = false;\n\t\t}\n\t}\n\tint num = 1;\n\tP p = P(1, 1);\n\tque.push(p);\n\tisGone[1][1] = true;\n\twhile(!que.empty()) {\n\t\tp = que.front();\n\t\tque.pop();\n\t\ty = p.first; x = p.second;\n\t\trep(i, 0, 4) {\n\t\t\tint tmpy = y + dy[i];\n\t\t\tint tmpx = x + dx[i];\n\t\t\tif (tmpy < 1 || tmpy > datay || tmpx < 1 || tmpx > datax) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (masu[tmpy][tmpx] == endC && !isGone[tmpy][tmpx]) {\n\t\t\t\tisGone[tmpy][tmpx] = true;\n\t\t\t\tque.push(make_pair(tmpy, tmpx));\n\t\t\t\t++num;\n\t\t\t}\n\t\t}\n\t}\n\treturn num;\n}\n\nvoid nuruColor(int masu[9][9], int c) {\n\tint now = masu[1][1];\n\tbool isGone[9][9];\n\tREP(i, 1, 8) {\n\t\tREP(j, 1, 8) {\n\t\t\tisGone[i][j] = false;\n\t\t}\n\t}\n\tisGone[1][1] = true;\n\tmasu[1][1] = c;\n\tP p = P(1, 1);\n\tque.push(p);\n\twhile(!que.empty()) {\n\t\tp = que.front();\n\t\tque.pop();\n\t\ty = p.first; x = p.second;\n\t\trep(i, 0, 4) {\n\t\t\tint tmpy = y + dy[i];\n\t\t\tint tmpx = x + dx[i];\n\t\t\tif (tmpy < 1 || tmpy > datay || tmpx < 1 || tmpx > datax) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (masu[tmpy][tmpx] == now && !isGone[tmpy][tmpx]) {\n\t\t\t\tisGone[tmpy][tmpx] = true;\n\t\t\t\tmasu[tmpy][tmpx] = c;\n\t\t\t\tque.push(make_pair(tmpy, tmpx));\n\t\t\t}\n\t\t}\n\t}\n}\t\n\nint data1[9][9], data2[9][9], data3[9][9], data4[9][9], data5[9][9];\nvoid solve() {\n\twhile(true) {\n\t\tint ans = -1;\n\t\tcin >> datay >> datax >> endC;\n\t\tif (datay == 0 && datax == 0 && endC == 0) return;\n\n\t\tREP(i, 1, datay) {\n\t\t\tREP(j, 1, datax) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i, 1, 6) {\n\t\t\tcopy(data1, data);\n\t\t\t//pData(data1);\n\t\t\tnuruColor(data1, i);\n\t\t\t//pData(data1);\n\t\t\tREP(i2, 1, 6) {\n\t\t\t\tcopy(data2, data1);\n\t\t\t\tnuruColor(data2, i2);\n\t\t\t\t//pData(data2);\n\t\t\t\tREP(i3, 1, 6) {\n\t\t\t\t\tcopy(data3, data2);\n\t\t\t\t\tnuruColor(data3, i3);\n\t\t\t\t\t//pData(data3);\n\t\t\t\t\tREP(i4, 1, 6) {\n\t\t\t\t\t\tcopy(data4, data3);\n\t\t\t\t\t\tnuruColor(data4, i4);\n\t\t\t\t\t\t//pData(data4);\n\n\t\t\t\t\t\tcopy(data5, data4);\n\t\t\t\t\t\tnuruColor(data5, endC);\n\t\t\t\t\t\tint tmp = countColor(data5);\n\t\t\t\t\t\t//if (ans < tmp) {\n\t\t\t\t\t\t\t//pData(data5);\n\t\t\t\t\t\t\t//cout << endl;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tans = max(ans, tmp);\n\t\t\t\t\t\t//pData(data5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\nvoid test() {\n\trep(i, 0, 2) {\n\t\tdatay = 1;datax = 1;\n\t\tendC = 5;\n\t\tREP(i, 1, datay) {\n\t\t\tREP(j, 1, datax) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\t\tnuruColor(data, 5);\n\t\tpData(data);\n\t\tcout << countColor(data) << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n\t//test();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,c,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nvector<int> p(64);\n\nint nu(int x,int y,int cl,int t){\n  int res=1;\n  p[y*w+x]=cl;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||w<=nx||ny<0||h<=ny||p[ny*w+nx]!=t||p[ny*w+nx]==cl)continue;\n    res+=nu(nx,ny,cl,t);\n  }\n  return res;\n}\n\nint dfs(int d){\n  vector<int> tp=p;\n  int res=0;\n  if(d==4){\n    res=nu(0,0,c,p[0]);\n    return nu(0,0,7,p[0]);\n  }\n  for(int j=1;j<7;j++){\n    nu(0,0,j,p[0]);\n    res=max(res,dfs(d+1)),p=tp;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>h>>w>>c,h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>p[i*w+j];\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n\nint H, W, C;\nint panel[8][8];\nint ans;\nint used[8][8];\n\nint dfs2(int x, int y, int c) {\n\tint ret = 0;\n\tused[y][x] = 1;\t\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\tif ( nx < 0 || ny < 0 || nx >= W || ny >= H ||\n\t\t\t\t used[ny][nx] || panel[ny][nx] != c ) continue;\n\t\tret += dfs2(nx, ny, c); \n\t}\n\n\treturn ret+1;\t\n}\n\nvoid dfs3(int x, int y, int c, int d) {\n\tused[y][x] = 1;\n\tpanel[y][x] = d;\t\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\tif ( nx < 0 || ny < 0 || nx >= W || ny >= H ||\n\t\t\t\t used[ny][nx] || panel[ny][nx] != c ) continue;\n\t\tdfs3(nx, ny, c, d);\t\t\n\t}\n}\n\nvoid dfs(int cnt) {\n\tint tmp[8][8];\n\tfor ( int i = 0; i < H; i++ )\n\t\tfor ( int j = 0; j < W; j++ )\t\t\t\t\n\t\t\ttmp[i][j] = panel[i][j];\n\n\tif ( cnt == 5 ) {\n\t\tif ( panel[0][0] == C ) {\n\t\t\tfill_n(*used, 8*8, 0);\t\t\n\t\t\tans = max(ans, dfs2(0, 0, panel[0][0]));\n\t\t}\n\t} else {\n\t\tfor ( int i = 1; i <= 6; i++ ) {\n\t\t\t//if ( panel[0][0] == i ) continue;\n\t\t\tfill_n(*used, 8*8, 0);\t\t\n\t\t\tdfs3(0, 0, panel[0][0], i);\t\t\n\t\t\tdfs(cnt+1);\n\t\t\tfor ( int k = 0; k < H; k++ )\n\t\t\t\tfor ( int j = 0; j < W; j++ )\t\t\t\t\n\t\t\t\t\tpanel[k][j] = tmp[k][j];\n\t\t}\n\t}\n\t\n}\n\nint main() {\n\twhile ( cin >> H >> W >> C, H ) {\n\t\tans = 0;\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t\tfor ( int j = 0; j < W; j++ )\t\t\t\t\n\t\t\t\tcin >> panel[i][j];\n\n\t\tdfs(0);\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint h,w,c;\nint data[100][100];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nint ans;\n\nint check(int grid[100][100]){\n\tint issearched[100][100] = {0};\n\tissearched[0][0] = 1;\n\tint cnt = 1;\n\tqueue<int> qx,qy;\n\tqx.push(0); qy.push(0);\n\twhile(!qx.empty()){\n\t\tint x = qx.front(); int y = qy.front();\n\t\tqx.pop(); qy.pop();\n\t\tREP(i,4){\n\t\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\t\tif(nx > -1 && ny > -1 && nx < h && ny < w && issearched[nx][ny] == 0){\n\t\t\t\tissearched[nx][ny] = 1;\n\t\t\t\tif(grid[nx][ny] == c){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tqx.push(nx); qy.push(ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid change(int col,int grid[100][100]){\n\tint issearched[100][100] = {0};\n\tqueue<int> qx,qy;\n\tqx.push(0); qy.push(0);\n\tint stcol = grid[0][0];\n\tgrid[0][0] = col;\n\twhile(!qx.empty()){\n\t\tint x = qx.front(); int y = qy.front();\n\t\tqx.pop(); qy.pop();\n\t\tREP(i,4){\n\t\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\t\tif(nx > -1 && ny > -1 && nx < h && ny < w && issearched[nx][ny] == 0){\n\t\t\t\tissearched[nx][ny] = 1;\n\t\t\t\tif(grid[nx][ny] == stcol){\n\t\t\t\t\tgrid[nx][ny] = col;\n\t\t\t\t\tqx.push(nx); qy.push(ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int n,int grid[100][100]){\n\t// cout << n << endl;\n\tint bgrid[100][100];\n\tREP(i,h) REP(j,w) bgrid[i][j] = grid[i][j];\n\n\tif(n == 4){\n\t\tchange(c,grid);\n\t\tans = max(check(grid),ans);\n\t}else{\n\t\tREP(i,6){\n\t\t\tchange(i,grid);\n\t\t\tsolve(n+1,grid);\n\t\t\tREP(i,h) REP(j,w) grid[i][j] = bgrid[i][j];\t\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> h >> w >> c;\n\t\tc--;\n\t\tans = 0;\n\t\tREP(i,h) REP(j,w) cin >> data[i][j];\n\t\tREP(i,h) REP(j,w) data[i][j]--;\n\n\t\tcout << solve(0,data) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nvoid fill(vector<vector<int> >& m, int y, int x, int from, int to){\n    if(from==to) return;\n    if(m[y][x]!=from) return;\n    m[y][x] = to;\n    for(int i=0; i<4; i++){\n        fill(m, y+dy[i], x+dx[i], from, to);\n    }\n}\n\nint _count(vector<vector<int> >& m, int y, int x, int color){\n    if(m[y][x]!=color) return 0;\n    m[y][x] = 0;\n    int cnt=1;\n    for(int i=0; i<4; i++){\n        cnt += _count(m, y+dy[i], x+dx[i], color);\n    }\n    return cnt;\n}\n\nint count(vector<vector<int> > m, int color){\n    return _count(m, 1, 1, color);\n}\n\nint search(vector<vector<int> > m, int step, int final){\n    if(step==4){\n        fill(m, 1, 1, m[1][1], final);\n        return count(m, m[1][1]);\n    }else{\n        vector<vector<int> > tmp = m;\n        int most=0;\n        for(int i=1; i<=6; i++){\n            m = tmp;\n            fill(m, 1, 1, m[1][1], i);\n            most = max(most, search(m, step+1, final));\n        }\n        return most;\n    }\n}\n    \n\nint main(){\n    while(1){\n        int h,w,c;\n        cin >> h >> w >> c;\n        if(h==0) break;\n\n        vector<vector<int> > panel(h+2, vector<int>(w+2, 0));\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                cin >> panel[i][j];\n            }\n        }\n\n        int ans = search(panel, 0, c);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct sta{\n  int x;\n  int y;\n  int d;\n};\n\nint main(){\n  while(1){\n    int h,w,c;\n    cin >> h >> w >> c;\n    if(h==0) return 0;\n    c--;\n    vector<vector<int>> f(h,vector<int>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> f[i][j];\n        f[i][j]--;\n      }\n    }\n    vector<int> a;\n    int ans=0;\n    int v[5]={0,1,0,-1,0};\n    for(int x1=0;x1<6;x1++){\n      for(int x2=0;x2<6;x2++){\n        for(int x3=0;x3<6;x3++){\n          for(int x4=0;x4<6;x4++){\n            if(f[0][0]==x1||x1==x2||x2==x3||x3==x4||x4==c) continue;\n            a={f[0][0],x1,x2,x3,x4,c};\n            priority_queue<sta,vector<sta>,function<bool(sta,sta)>>\n              heap([](const sta &a, const sta &b){return a.d>b.d;});\n            vector<vector<int>> dist(h,vector<int>(w,IINF));\n            heap.push({0,0,0});\n            int tmp=0;\n            while(!heap.empty()){\n              sta now = heap.top();\n              heap.pop();\n              if(dist[now.y][now.x]!=IINF) continue;\n              dist[now.y][now.x] = now.d;\n              tmp++;\n              for(int i=0;i<4;i++){\n                int nx = now.x + v[i];\n                int ny = now.y + v[i+1];\n                if(0<=nx&&nx<w&&0<=ny&&ny<h){\n                  if(dist[ny][nx]==IINF){\n                    for(int k=now.d;k<7;k++){\n                      if(f[ny][nx]==a[k]){\n                        heap.push({nx,ny,k});\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            ans=max(ans,tmp);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint H, W, C, ans, cnt;\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\nbool used[8][8];\ntypedef pair<int,int> P;\n \nbool inField(int y, int x){\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\n \nvoid color_count(vector<vector<int> > &vec, int y, int x){\n    if(used[y][x]) return;\n    used[y][x] = true;\n    if(vec[y][x] == C){\n\tcnt++;\n    }\n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(!inField(ny, nx)) continue;\n\tif(vec[ny][nx] != C) continue;\n\tcolor_count(vec, ny, nx);\n    }\n}\n \nvector<P> pos;\nvoid color_change(int y, int x, int c1, int c2, \n                  bool flg, vector<vector<int> > &vec){\n    if(used[y][x]) return;\n    used[y][x] = true;\n    pos.push_back(P(y,x));\n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(!inField(ny, nx)) continue;\n\tif(vec[ny][nx] != c1 && vec[ny][nx] != c2) continue;\n\tif(vec[y][x] != vec[ny][nx] && !flg){\n\t    flg = true;\n\t    color_change(ny, nx, c1, c2, flg, vec);\n\t}else{\n\t    if(flg){\n\t\tif(vec[y][x] != vec[ny][nx]) continue;\n\t\tcolor_change(ny, nx, c1, c2, flg, vec);\n\t    }else{\n\t\tcolor_change(ny, nx, c1, c2, flg, vec);\n\t    }\n\t}\n    }\n}\n \nvoid solve(vector<vector<int> > &vec, int rem){\n    if(rem == 0){\n\tmemset(used, false, sizeof(used));\n\tcnt = 0;\n\tcolor_count(vec, 0, 0);\n\tans = max(ans, cnt);\n\treturn;\n    }\n   \n    for(int i = 0 ; i < 6 ; i++){\n\tvector<vector<int> > next = vec;\n\tpos.clear();\n\tmemset(used, false, sizeof(used));\n\tcolor_change(0, 0, i+1, vec[0][0], false, vec);\n\tfor(int j = 0 ; j < pos.size() ; j++){\n\t    P p = pos[j];\n\t    next[p.first][p.second] = i+1;\n\t}\n\tsolve(next, rem-1);\n    }\n}\n \nint main(){\n    while(cin >> H >> W >> C , (H | W | C)){\n\tvector<vector<int> > vec(H, vector<int>(W));\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> vec[i][j];\n\t    }\n\t}\n\tans = 0;\n\tsolve(vec, 5);   \n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint field[10][10];\nint H, W, C;\nint ans = 0;\nvector<int> v;\nint dh[4] = {1, -1, 0, 0};\nint dw[4] = {0, 0, 1, -1};\n\nvoid check() {\n    if(v.back() != C) return;\n    UnionFind uni(100);\n    for(int h = 1; h <= H; h++) {\n        for(int w = 1; w <= W; w++) {\n            if(h < H) {\n                if(field[h][w] == field[h+1][w]) uni.merge(h+w*H, h+1+w*H);\n            }\n            if(w < W) {\n                if(field[h][w] == field[h][w+1]) uni.merge(h+w*H, h+(w+1)*H);\n            }\n        }\n    }\n    for(int time = 0; time < v.size(); time++) {\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                if(!uni.issame(h+w*H, 1+1*H)) continue;\n                for(int k = 0; k < 4; k++) {\n                    int newh = h + dh[k];\n                    int neww = w + dw[k];\n                    if(newh < 1 || newh > H || neww < 1 || neww > W) continue;\n                    if(field[newh][neww] == v[time]) uni.merge(h+w*H, newh+neww*H);\n                }\n            }\n        }\n    }\n    ans = max(ans, (int)uni.size(1+1*H));\n}\n\nvoid f() {\n    if(v.size() == 5) {\n        check();\n        return;\n    }\n    for(int i = 1; i <= 6; i++) {\n        v.push_back(i);\n        f();\n        v.pop_back();\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> H >> W >> C;\n        if(H == 0) break;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                cin >> field[h][w];\n            }\n        }\n        ans = 0;\n        f();\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w,c;\n\nstruct Panel{ int a[8][8]; };\nstruct Point{ int x,y; };\n\nint count(const Panel &pnl){\n\tint ans=1;\n\tbool visited[8][8]={}; visited[0][0]=true;\n\n\tqueue<Point> qu; qu.push((Point){0,0});\n\twhile(!qu.empty()){\n\t\tPoint p=qu.front(); qu.pop();\n\t\trep(i,4){\n\t\t\tPoint q={p.x+dx[i],p.y+dy[i]};\n\t\t\tif(0<=q.y && q.y<h && 0<=q.x && q.x<w\n\t\t\t&& !visited[q.y][q.x] && pnl.a[q.y][q.x]==c){\n\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\tans++;\n\t\t\t\tqu.push((Point){q.x,q.y});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint dfs(Panel pnl,int depth){\n\tif(depth==5) return count(pnl);\n\n\tint ans=0;\n\tchar prev=pnl.a[0][0];\n\tfor(int cc=1;cc<=6;cc++){\n\t\tPanel tmp=pnl;\n\n\t\tpnl.a[0][0]=cc;\n\t\tbool visited[8][8]={}; visited[0][0]=true;\n\t\tqueue<Point> qu; qu.push((Point){0,0});\n\t\twhile(!qu.empty()){\n\t\t\tPoint p=qu.front(); qu.pop();\n\t\t\trep(i,4){\n\t\t\t\tPoint q={p.x+dx[i],p.y+dy[i]};\n\t\t\t\tif(0<=q.y && q.y<h && 0<=q.x && q.x<w\n\t\t\t\t&& !visited[q.y][q.x] && pnl.a[q.y][q.x]==prev){\n\t\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\t\tpnl.a[q.y][q.x]=cc;\n\t\t\t\t\tqu.push((Point){q.x,q.y});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=max(ans,dfs(pnl,depth+1));\n\n\t\tpnl=tmp;\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d%d\",&h,&w,&c),h;){\n\t\tPanel pnl;\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&pnl.a[i][j]);\n\n\t\tprintf(\"%d\\n\",dfs(pnl,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n\n#define loop(x) for(int x=1;x<=6;x++)\n\nusing namespace std;\n\nvoid change(int[10][10],int,int,int);\nint count(int[10][10],int,int);\n\nint main(void){\n\tfor(int h,w,c;cin >> h >> w >> c,h||w||c;){\n\t\tint fld[10][10]={0};\n\t\tint max=0,tmp;\n\n\t\tfor(int i=1;i<=h;i++)\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t\tcin >> fld[i][j];\n\n\t\tloop(i){\n\t\t\tint cpy1[10][10];\n\t\t\tmemcpy(cpy1,fld,sizeof(fld));\n\t\t\tchange(cpy1,1,1,i);\n\t\t\tloop(j){\n\t\t\t\tint cpy2[10][10];\n\t\t\t\tmemcpy(cpy2,cpy1,sizeof(cpy1));\n\t\t\t\tchange(cpy2,1,1,j);\n\t\t\t\tloop(k){\n\t\t\t\t\tint cpy3[10][10];\n\t\t\t\t\tmemcpy(cpy3,cpy2,sizeof(cpy2));\n\t\t\t\t\tchange(cpy3,1,1,k);\n\t\t\t\t\tloop(l){\n\t\t\t\t\t\tint cpy4[10][10];\n\t\t\t\t\t\tmemcpy(cpy4,cpy3,sizeof(cpy3));\n\t\t\t\t\t\tchange(cpy4,1,1,l);\n\t\t\t\t\t\tchange(cpy4,1,1,c);\n\t\t\t\t\t\ttmp=count(cpy4,1,1);\n\t\t\t\t\t\tmax=max>tmp?max:tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << max << endl;\n\t}\n\n\treturn 0;\n}\n\nvoid change(int fld[10][10],int x,int y,int col){\n\tint cul=fld[x][y];\n\n\tif(cul!=col){\n\t\tfld[x][y]=col;\n\t\tif(fld[x+1][y]==cul)\n\t\t\tchange(fld,x+1,y,col);\n\t\tif(fld[x-1][y]==cul)\n\t\t\tchange(fld,x-1,y,col);\n\t\tif(fld[x][y+1]==cul)\n\t\t\tchange(fld,x,y+1,col);\n\t\tif(fld[x][y-1]==cul)\n\t\t\tchange(fld,x,y-1,col);\n\t}\n}\n\nint count(int fld[10][10],int x,int y){\n\tint c=1,cul=fld[x][y];\n\n\tfld[x][y]=-1;\n\tif(fld[x+1][y]==cul)\n\t\tc+=count(fld,x+1,y);\n\tif(fld[x-1][y]==cul)\n\t\tc+=count(fld,x-1,y);\n\tif(fld[x][y+1]==cul)\n\t\tc+=count(fld,x,y+1);\n\tif(fld[x][y-1]==cul)\n\t\tc+=count(fld,x,y-1);\n\n\treturn c;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAX_V=1e3+5;\nconst int INF=1e9;\nvector< vector<int> > board(10,vector<int>(10,0) );\n//vector< vector<bool> > same(10,vector<bool>(10,false) );\nint w,h,c;\nbool visited[10][10];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint ans=0;\nint tmpans=1;\nbool outofrange(int y,int x,int pcolor,int ncolor,vector<vector<int> > &nowboard)\n{\n  if(y<0 || y>=h || x<0 || x>=w || visited[y][x]) return true;\n  else if(nowboard[y][x]!=pcolor) return true;\n  else return false;\n}\n\nvoid paintbfs(int y,int x,int pcolor,int ncolor,vector<vector<int> > &nowboard)\n{\n  visited[y][x]=true;\n  if(y==0 && x==0) nowboard[y][x]=ncolor;\n  for(int k=0;k<4;k++)\n    {\n      int ny=y+dy[k],nx=x+dx[k];\n      if(!outofrange(ny,nx,pcolor,ncolor,nowboard))\n\t{\n\t  nowboard[ny][nx]=ncolor;\n\t  paintbfs(ny,nx,pcolor,ncolor,nowboard);\t  \n\t}\n    }\n}\n\nvoid countbfs(int y,int x,int color,vector<vector<int> > &nowboard)\n{\n  tmpans++;\n  visited[y][x]=true;\n  for(int k=0;k<4;k++)\n    {\n      int ny=y+dy[k],nx=x+dx[k];\n      if(!outofrange(ny,nx,color,color,nowboard))\n\t{\n\t  countbfs(ny,nx,color,nowboard);\t  \n\t}\n    }\n}\n\nvoid shock(int num,vector< vector<int> > &nowboard)\n{\n  int pcolor;\n  if(num>=6) return;\n  vector< vector<int> > save;\n  save=nowboard;\n  if(num!=0)\n    {\n      for (int ncolor = 1; ncolor <= 6; ++ncolor)\n\t{\n\t  memset(visited,false,sizeof(visited));\n\t  tmpans=0;\n\t  nowboard=save;\n\t  pcolor=nowboard[0][0];\n\t  paintbfs(0,0,pcolor,ncolor,nowboard);\n\t  memset(visited,false,sizeof(visited));\n\t  countbfs(0,0,ncolor,nowboard);\n\t  if(num==5 && ncolor==c) ans=max(tmpans,ans);\n\t  shock(num+1,nowboard);\n\t}\n    }\n  else\n    {\n      tmpans=0;\n      pcolor=nowboard[0][0];\n      paintbfs(0,0,pcolor,pcolor,nowboard);\n      memset(visited,false,sizeof(visited));\n      countbfs(0,0,pcolor,nowboard);\n      //if(pcolor==c) ans=max(tmpans,ans);\n      shock(num+1,nowboard);\n    }\n  return;\n}\n\nint main(void)\n{\n  while(cin >> h >> w >> c && w)\n    {\n      ans=0;\n      for (int i = 0; i < h; ++i)\n\t{\n\t  for (int j = 0; j < w; ++j)\n\t    {\n\t      cin >> board[i][j];\n\t    }\n\t}\n      shock(0,board);\n      //cout << sy << ' ' << sx << ' ' << gy << ' ' << gx << endl;\n      cout << ans << endl;\n    }\n  return 0;\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,c;\nint ans;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint dfs(vector<vector<int> > f){\n\tqueue<P> que;\n\tint fc=f[0][0];\n\tque.push(P(0,0));\n\tint a=0;\n\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\twhile(!que.empty()){\n\t\tP t=que.front();\n\t\tque.pop();\n\t\tif(used[t.first][t.second])\n\t\t\tcontinue;\n\t\ta++;\n\t\tused[t.first][t.second]=true;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tP nt=P(t.first+dy[i],t.second+dx[i]);\n\t\t\tif(nt.first>=0&&nt.first<h&&nt.second>=0&&nt.second<w&&fc==f[nt.first][nt.second]&&!used[nt.first][nt.second]){\n\t\t\t\tque.push(nt);\n\t\t\t}\n\t\t}\n\t}\n\treturn a;\n}\nvector<vector<int> > change(vector<vector<int> > f,int col){\n\tqueue<P> que;\n\tint fc=f[0][0];\n\tque.push(P(0,0));\n\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\twhile(!que.empty()){\n\t\tP t=que.front();\n\t\tque.pop();\n\t\tif(used[t.first][t.second])\n\t\t\tcontinue;\n\t\tf[t.first][t.second]=col;\n\t\tused[t.first][t.second]=true;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tP nt=P(t.first+dy[i],t.second+dx[i]);\n\t\t\tif(nt.first>=0&&nt.first<h&&nt.second>=0&&nt.second<w&&fc==f[nt.first][nt.second]&&!used[nt.first][nt.second]){\n\t\t\t\tque.push(nt);\n\t\t\t}\n\t\t}\n\t}\n\treturn f;\n\t\n}\nvoid ret(vector<vector<int> > f,int cnt){\n\tif(cnt==5){\n\t\tif(f[0][0]==c)\n\t\t\tans=max(dfs(f),ans);\n\t\treturn;\n\t}\n\tfor(int i=1;i<=6;i++){\n\t\tif(f[0][0]==i)\n\t\t\tcontinue;\n\t\tret(change(f,i),cnt+1);\n\t}\n}\nint main(){\n\twhile(cin>>h>>w>>c,w||h||c){\n\t\tans=0;\n\t\tvector<vector<int> > f(h,vector<int>(w));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>f[i][j];\n\t\t\t}\n\t\t}\n\t\tret(f,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\nint h, w, c;\nbool inrange(int i, int j) {\n\treturn i >= 0 && i < h&&j >= 0 && j < w;\n}\nint count(const vvi &v) {\n\tvvi b(h, vi(w, 0));\n\tint ret = 1;\n\n\tif (v[0][0] == c) {\n\t\tqueue<pii> q;\n\t\tq.push({ 0,0 });\n\t\tb[0][0] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tREP(k, 4) {\n\t\t\t\tint nx = p.first + dx[k * 2], ny = p.second + dy[k * 2];\n\t\t\t\tif (inrange(nx, ny) && b[nx][ny] == 0 && v[nx][ny] == c) {\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t\tb[nx][ny] = 1;\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint dfs(vvi v, int cnt) {\n\tif (cnt == 5) {\n\t\treturn count(v);\n\t}\n\tvvi b(h, vi(w, 0));\n\tqueue<pii> q;\n\tq.push({ 0,0 });\n\tb[0][0] = 1;\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(k, 4) {\n\t\t\tint nx = p.first + dx[k * 2], ny = p.second + dy[k * 2];\n\t\t\tif (inrange(nx, ny) && b[nx][ny] == 0 && v[nx][ny] == v[0][0]) {\n\t\t\t\tq.push({ nx,ny });\n\t\t\t\tb[nx][ny] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tREP(k, 6) {\n\t\tvvi tmp = v;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (b[i][j]) {\n\t\t\t\t\ttmp[i][j] = k + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = max(ret, dfs(tmp, cnt + 1));\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> h >> w >> c) {\n\t\tif (h == 0 && w == 0 && c == 0)break;\n\t\tvvi v(h, vi(w));\n\t\tREP(i, h)REP(j, w)cin >> v[i][j];\n\t\tcout << dfs(v, 0) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nvoid cpy(int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t\tif (m == ) b[i][j] = g[i][j];\n\t\t\telse g[i][j] = b[i][j];\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tif (b[0][0] != c) cpy(0), rec(0, 0, c);\n\tcpy(2), ret = rec1(0, 0), cpy(1);\n\tif (d < 4) {\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(0), rec(0, 0, c);\n\t\t\tret = max(ret, solve(d + 1)), cpy(1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h, w, c;\nint field[10][10][10];\nbool visit[10][10];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint dfs(int depth, int x, int y, int tc) {\n  if (visit[y][x]) { return 0; }\n  visit[y][x] = true;\n  const int ndepth = depth + 1;\n  const int pc = field[depth][0][0];\n  field[ndepth][y][x] = tc;\n  int ret = 1;\n  REP(dir, 4) {\n    int nx = x + dx[dir];\n    int ny = y + dy[dir];\n    if (nx < 0 || nx >= w || ny < 0 || ny >= h) { continue; }\n    if (field[depth][ny][nx] != pc) { continue; }\n    ret += dfs(depth, nx, ny, tc);\n  }\n  return ret;\n}\n\nint calc(int depth) {\n  if (depth == 5) {\n    if (field[depth][0][0] != c) { return 0; }\n    MEMSET(visit, false);\n    memcpy(field[depth + 1], field[depth], sizeof(field[depth]));\n    return dfs(depth, 0, 0, c);\n  }\n  int ret = 0;\n  FOREQ(i, 1, 6) {\n    MEMSET(visit, false);\n    memcpy(field[depth + 1], field[depth], sizeof(field[depth]));\n    dfs(depth, 0, 0, i);\n    ret = max(ret, calc(depth + 1));\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &c), h|w|c) {\n    REP(y, h) {\n      REP(x, w) {\n        scanf(\"%d\", &field[0][y][x]);\n      }\n    }\n    cout << calc(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint h,w,c;\nint board[8][8];\nbool vis[8][8];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint dfs(int y,int x, int col){\n  if(vis[y][x] || board[y][x] != col)return 0;\n  vis[y][x] = true;\n\n  int res = 1;\n  for(int i=0;i<4;i++){\n    int ny = y+dy[i], nx = x+dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    res += dfs(ny,nx,col);\n  }\n  return res;\n}\n\nint rec(int depth){\n  if(depth==5){\n    if(board[0][0] != c)return 0;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)vis[i][j] = false;\n    }\n    return dfs(0,0,c);\n  }\n\n  int tmp[8][8];\n  bool local_vis[8][8];\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      vis[i][j] = false;\n      tmp[i][j] = board[i][j];\n    }\n  }\n  \n  dfs(0,0,board[0][0]);\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++)local_vis[i][j] = vis[i][j];\n  }\n\n  int res = 0;\n  for(int col=1;col<=6;col++){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(local_vis[i][j])board[i][j] = col;\n      }\n    }\n    res = max(res,rec(depth+1));\n  }\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      board[i][j] = tmp[i][j];\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> h >> w >> c, h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> board[i][j];\n    }\n\n    cout << rec(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nvoid fill(vector<vector<int>>& color, int x, int y, int pc, int c) {\n    if(pc == c) {\n        return;\n    }\n    color[y][x] = c;\n    int dx[4] = {0, 1, 0, -1},\n        dy[4] = {1, 0, -1, 0};\n    for(int i=0; i<4; ++i) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < color[0].size() && 0 <= ny && ny < color.size() && color[ny][nx] == pc) {\n            fill(color, nx, ny, pc, c);\n        }\n    }\n}\n\nint dfs(vector<vector<int>>& color, int d, int last) {\n    int res = 0;\n    if(d == 4) {\n        fill(color, 0, 0, color[0][0], last);\n        fill(color, 0, 0, color[0][0], -1);\n        for(int i=0; i<color.size(); ++i) {\n            for(int j=0; j<color[i].size(); ++j) {\n                if(color[i][j] == -1) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n    int pc = color[0][0];\n    for(int i=1; i<=6; ++i) {\n        auto v2 = color;\n        fill(v2, 0, 0, color[0][0], i);\n        res = max(res, dfs(v2, d+1, last));\n    }\n    return res;\n}\n\nint main() {\n    int h, w, c;\n    while(cin >> h >> w >> c, h) {\n        vector<vector<int>> color(h, vector<int>(w));\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                cin >> color[i][j];\n            }\n        }\n        cout << dfs(color, 0, c) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\n#define REP(i, n) for(int i = 0; i < (n); i++)\n#define ISIN(x, y, w, h) (x >= 0 && x < w && y >= 0 && y < h)\n\n#define f first\n#define s second\n\nusing namespace std;\n\npair<int, int> joint[70];\nint h, w, c;\nint p[8][8];\nbool f[8][8];\n\nconst int dx[4] = { 1,-1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1};\n\nint getInt(){ int r; scanf(\"%d\", &r); return r; }\n\nint solve(int now, int prev, int cnt){\n  int ret = cnt;\n\n  //printf(\"solve(%d, %d, %d)\\n\", now, prev, cnt);\n\n  if(now == 6) return cnt;\n\n  for(int col = 1; col <= 6; col++){\n    int cc = cnt;\n    queue<pair<int, int> > q;\n\n    if(now == 5 && col != c) continue;\n    if(now == 0 && col != prev) continue;\n\n    REP(i, cnt) q.push(joint[i]);\n\n    while(q.size()){\n      int x = q.front().s;\n      int y = q.front().f;\n\n      q.pop();\n\n      REP(i, 4){\n\tint xx = x + dx[i];\n\tint yy = y + dy[i];\n\n\tif(ISIN(xx, yy, w, h) && p[yy][xx] == col && !f[yy][xx]){\n\t  f[yy][xx] = true;\n\t  joint[cc].f = yy;\n\t  joint[cc].s = xx;\n\t  q.push(joint[cc++]);\n\t}\n      }\n    }\n\n    if(cc != cnt){\n      ret = max(ret, solve(now + 1, col, cc));\n      \n      for(int i = cnt; i < cc; i++){\n\tint x = joint[i].s;\n\tint y = joint[i].f;\n\t\n\tf[y][x] = false;\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    h = getInt();\n    w = getInt();\n    c = getInt();\n\n    if(h + w + c == 0) break;\n\n    REP(i, h) REP(j, w) p[i][j] = getInt();\n    f[0][0] = true;\n\n    printf(\"%d\\n\", solve(0, p[0][0], 1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\n#define int ll\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nint ans = -INF;\nint h,w,c;\nvector<vector<int>>graph;\nvoid dfs2(int x,int y,int nc,int pc){\n    if(nc == pc)return;\n    graph[y][x] = nc;\n    rep(k,4){\n        int nx = dx[k] + x;\n        int ny = dy[k] + y;\n        if(valid(nx, ny) and graph[ny][nx] == pc){\n            dfs2(nx, ny, nc,pc);\n        }\n    }\n    return;\n}\nvoid dfs(int cnt){\n    if(cnt == 5){\n        dfs2(0, 0,c,graph[0][0]);\n        dfs2(0, 0,INF,graph[0][0]);\n        int temp = 0;\n        rep(i,graph.size()){\n            rep(j,graph[i].size()){\n                //cout << graph[i][j];\n                if(graph[i][j] == INF)temp++;\n            }\n         //   cout << endl;\n        }\n        cmax(ans,temp);\n    } else {\n        rep(i,6){\n            auto g = graph;\n            dfs2(0,0,i+1,graph[0][0]);\n            dfs(cnt+1);\n            graph = g;\n        }\n    }\n}\nsigned main(){\n    while(cin >> h >> w >> c,h+w+c){\n        H = h;\n        W = w;\n        graph = vectors(h,w,0LL);\n        ans =  -INF;\n        rep(i,h)rep(j,w){\n            cin >> graph[i][j];\n        }\n        dfs(1);\n        cout << ans << endl;\n    }\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dx[4]={1, 0, 0, -1};\nint dy[4]={0, -1, 1, 0};\n\nint change(int panel[10][10], int y, int x, int c){\n\tint sum=1;\n\tint color=panel[y][x];\n\tpanel[y][x]=c;\n\tfor(int i=0; i<4; i++){\n\t\tif(panel[y+dy[i]][x+dx[i]] == color){\n\t\t\tsum+=change(panel, y+dy[i], x+dx[i], c);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint solve(int panel[10][10], int depth, int c){\n\tif(depth >= 5) {\n\t\tif(panel[1][1] != c) return 0;\n\t\telse return change(panel, 1, 1, 0);\n\t}\n\tint ans=0;\n\tfor(int i=1; i<=6; i++){\n\t\tint tmp[10][10];\n\t\tif(panel[1][1]==i) continue;\n\t\tfor(int j=0; j<10; j++){\n\t\t\tfor(int k=0; k<10; k++){\n\t\t\t\ttmp[j][k] = panel[j][k];\n\t\t\t}\n\t\t}\n\t\tchange(tmp, 1, 1, i);\n\t\tans = max(ans, solve(tmp, depth+1, c));\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tint h, w, c; cin >>h>>w>>c;\n\t\tif(!h && !w) break;\n\n\t\tint panel[10][10]={0};\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin>>panel[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<solve(panel, 0, c)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\n#define MH 8\n#define MW 8\n\nint H, W, C;\nint P[MH][MW];\nbool input() {\n    cin >> H >> W >> C;\n    if (H == 0 && W == 0 && C == 0) return false;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> P[i][j];\n        }\n    }\n    return true;\n}\n\nconst int dy[] = {0, 1, 0, -1},\n          dx[] = {1, 0, -1, 0};\nint Count() {\n    if (P[0][0] != C) return 0;\n    bool used[H][W]; memset(used, 0, sizeof(used));\n    used[0][0] = true;\n    queue< pair<int, int> > Q;\n    Q.push(make_pair(0, 0));\n    int Ret = 0;\n    while (!Q.empty()) {\n        pair<int, int> next = Q.front(); Q.pop();\n        Ret++;\n        int y = next.first,\n            x = next.second;\n        for (int i = 0; i < 4; i++) {\n            int ny = y + dy[i],\n                nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (used[ny][nx]) continue;\n            if (P[ny][nx] != C) continue;\n            Q.push(make_pair(ny, nx));\n            used[ny][nx] = true;\n        }\n    }\n    return Ret;\n}\n\nvoid Change(int color) {\n    bool used[H][W]; memset(used, 0, sizeof(used));\n    int pcolor = P[0][0];\n    used[0][0] = true;\n    queue< pair<int, int> > Q;\n    P[0][0] = color;\n    Q.push(make_pair(0, 0));\n    while (!Q.empty()) {\n        pair<int, int> next = Q.front(); Q.pop();\n        int y = next.first,\n            x = next.second;\n        for (int i = 0; i < 4; i++) {\n            int ny = y + dy[i],\n                nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (used[ny][nx]) continue;\n            if (P[ny][nx] != pcolor) continue;\n            P[ny][nx] = color;\n            Q.push(make_pair(ny, nx));\n            used[ny][nx] = true;\n        }\n    }\n}\n\nvoid dump() {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cerr << setw(3) << P[i][j];\n        }\n        cerr << endl;\n    }\n    cerr << endl;\n}\n\nint dfs(int R) {\n    if (R == 0) {\n        return Count();\n    }\n    int P1[MH][MW];\n    int Max = 0;\n    for (int color = 1; color <= 6; color++) {\n        memcpy(P1, P, sizeof(P));\n        Change(color);\n        Max = max(Max, dfs(R - 1));\n        memcpy(P, P1, sizeof(P));\n    }\n    return Max;\n}\n\nvoid solve() {\n    cout << dfs(5) << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nint field[10][10][6] = {0};\nint h,w,c;\nvoid copyfield(int num);\nvoid color(int draw, int x, int y, int fand, int num);\nint colorval(int lot);\nint color_c(int x, int y, int fand, int sum);\nusing namespace std;\nint main(){\n\twhile(cin >>h>>w>>c){\n\t\tif(!h && !w && !c){break;}\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >>field[j][i][0];\n\t\t\t}\n\t\t}\n\t\tcout <<colorval(5)<<endl;\n\t}\n\treturn 0;\n}\nvoid color(int draw, int x, int y, int fand, int num){\n\tfield[x][y][num] = draw;\n\tif(x>0){if(field[x-1][y][num-1] == fand && field[x-1][y][num] != draw){color(draw,x-1,y,fand,num);}}\n\tif(y>0){if(field[x][y-1][num-1] == fand && field[x][y-1][num] != draw){color(draw,x,y-1,fand,num);}}\n\tif(x<w-1){if(field[x+1][y][num-1] == fand && field[x+1][y][num] != draw){color(draw,x+1,y,fand,num);}}\n\tif(y<h-1){if(field[x][y+1][num-1] == fand && field[x][y+1][num] != draw){color(draw,x,y+1,fand,num);}}\n}\nvoid copyfield(int num){\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tfield[j][i][num] = field[j][i][num-1];\n\t\t}\n\t}\n}\nint colorval(int lot){\n\tint sum=0;\n\tif(lot>1){\n\t\tfor(int i=1; i<7; i++){\n\t\t\tcopyfield(6-lot);\n\t\t\tcolor(i,0,0,field[0][0][5-lot],6-lot);\n\t\t\tint r = colorval(lot-1);\n\t\t\tif(sum<r){sum = r;}\n\t\t}\n\t}\n\tif(lot == 1){\n\t\tcopyfield(5);\n\t\tcolor(c,0,0,field[0][0][4],5);\n\t\tsum = color_c(0,0,field[0][0][5],0);\n\t}\n\treturn sum;\n}\nint color_c(int x, int y, int fand, int sum){\n\tfield[x][y][5] = 0;\n\tsum++;\n\tif(x>0){if(field[x-1][y][5] == fand){sum+=color_c(x-1,y,fand,0);}}\n\tif(y>0){if(field[x][y-1][5] == fand){sum+=color_c(x,y-1,fand,0);}}\n\tif(x<w-1){if(field[x+1][y][5] == fand){sum+=color_c(x+1,y,fand,0);}}\n\tif(y<h-1){if(field[x][y+1][5] == fand){sum+=color_c(x,y+1,fand,0);}}\n\treturn sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint w,h,Col;\ntypedef pair<int,int> C;\ntypedef vector<vector<int> > P;\nP V;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint res;\n\nP temp;\nint tres=0;\n\n\nvoid calc(int y,int x){\n\tif(y<0 || x<0 || x>=w || y>=h) return;\n\tif(temp[y][x]==Col){tres++;temp[y][x]=0;\n\tfor(int r=0;r<4;r++)\n\t\tcalc(y+dy[r],x+dx[r]);\n\t}\n}\n\nvoid on(P N,int count,int c){\n\n\tif(count==5){temp=N;tres=0;calc(0,0);res=max(res,tres);return;}\n\n\tint nc=N[0][0];\n\tqueue<C> Q;\n\tQ.push(make_pair(0,0));\n\tbool used[8][8];\n\tmemset(used,false,sizeof(used));\n\n\tint tres=0;\n\twhile(!Q.empty()){\n\t\tC now=Q.front();\n\t\tQ.pop();\n\t\tif(used[now.first][now.second]) continue;\n\t\tused[now.first][now.second]=true;\n\t\tN[now.first][now.second]=c;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint ny=now.first+dy[r],nx=now.second+dx[r];\n\t\t\tif(ny<0 || nx<0 || ny>=h || nx>=w) continue;\n\t\t\tif(N[ny][nx]==nc)\n\t\t\t\tQ.push(make_pair(ny,nx));\n\t\t}\n\t}\n\n\tif(count!=4){\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tif(nc!=i && i!=N[0][0])\n\t\t\t\ton(N,count+1,i);\n\t\t}\n\t}\n\telse on(N,count+1,Col);\n}\n\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tV.resize(h);\n\n\tfor(int y=0;y<h;y++)\n\t\tfor(int x=0;x<w;x++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tV[y].push_back(t);\n\t\t}\n\t\n\tfor(int i=1;i<=6;i++){\n\t\tif(V[0][0]!=i)\n\t\t on(V,0,i);\n\t}\n\n\tcout<<res<<endl;\n\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w>>Col){\n\t\tif(w==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int DIRECTION[][2] = {\n\t0, 1,\n\t1, 0,\n\t0, -1,\n\t-1, 0\n};\n\nstruct Solver\n{\n\tconst int H, W, C;\n\tint res;\n\n\tSolver( int h, int w, int c ) : H( h ), W( w ), C( c ), res( 0 )\n\t{\n\t\tVVI board( h, VI( w, 0 ) );\n\t\tREP( i, 0, H )\n\t\t{\n\t\t\tREP( j, 0, W )\n\t\t\t{\n\t\t\t\tcin >> board[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs( board, 0 );\n\t\t\n\t\treturn;\n\t}\n\n\toperator int ()\n\t{\n\t\treturn res;\n\t}\n\n\tvoid dfs( VVI board, int depth )\n\t{\n\t\tres = max( res, check( board ) );\n\n\t\tif ( 5 <= depth )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tREP( i, 1, 7 )\n\t\t{\n\t\t\tdfs( change( board, i ), depth + 1 );\n\t\t}\n\t\treturn;\n\t}\n\n\tint check( VVI board )\n\t{\n\t\tint res = 0;\n\t\tqueue< PII > que;\n\t\tque.push( MP( 0, 0 ) );\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tPII cur = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ( board[ cur.fst ][ cur.snd ] != C )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres++;\n\t\t\tboard[ cur.fst ][ cur.snd ] = 0;\n\n\t\t\tREP( d, 0, 4 )\n\t\t\t{\n\t\t\t\tPII next( cur );\n\t\t\t\tnext.fst += DIRECTION[d][0];\n\t\t\t\tnext.snd += DIRECTION[d][1];\n\t\t\t\tif ( 0 <= next.fst && next.fst < H && 0 <= next.snd && next.snd < W )\n\t\t\t\t{\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tVVI change( VVI board, int c )\n\t{\n\t\tset<PII> target;\n\n\t\tqueue<PII> que;\n\t\tque.push( MP( 0, 0 ) );\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tPII cur = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ( board[ cur.fst ][ cur.snd ] != board[0][0] || EXIST( target, cur ) )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttarget.insert( cur );\n\n\t\t\tREP( d, 0, 4 )\n\t\t\t{\n\t\t\t\tPII next( cur );\n\t\t\t\tnext.fst += DIRECTION[d][0];\n\t\t\t\tnext.snd += DIRECTION[d][1];\n\t\t\t\tif ( 0 <= next.fst && next.fst < H && 0 <= next.snd && next.snd < W )\n\t\t\t\t{\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tEACH( it, target )\n\t\t{\n\t\t\tboard[ it -> fst ][ it -> snd ] = c;\n\t\t}\n\t\treturn board;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint h, w, c;\n\t\tcin >> h >> w >> c;\n\n\t\tif ( !( h | w | c ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << Solver( h, w, c ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint w,h,Col;\ntypedef pair<int,int> C;\ntypedef vector<vector<int> > P;\nP V;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint res;\n\nvoid on(P N,int count,int c){\n\t\n\tif(count==6) return;\n\tif(count==4)\n\t\tc=Col;\n\n\tint nc=N[0][0];\n\tqueue<C> Q;\n\tQ.push(make_pair(0,0));\n\tbool used[8][8];\n\tmemset(used,false,sizeof(used));\n\n\tint tres=0;\n\twhile(!Q.empty()){\n\t\tC now=Q.front();\n\t\tQ.pop();\n\t\tif(used[now.first][now.second]) continue;\n\t\tused[now.first][now.second]=true;\n\t\tN[now.first][now.second]=c;\n\t\ttres++;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint ny=now.first+dy[r],nx=now.second+dx[r];\n\t\t\tif(ny<0 || nx<0 || ny>=h || nx>=w) continue;\n\t\t\tif(N[ny][nx]==nc)\n\t\t\t\tQ.push(make_pair(ny,nx));\n\t\t}\n\t\tres=max(res,tres);\n\t}\n\n\tfor(int i=1;i<=6;i++)\n\t\ton(N,count+1,i);\n}\n\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tV.resize(h);\n\n\tfor(int y=0;y<h;y++)\n\t\tfor(int x=0;x<w;x++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tV[y].push_back(t);\n\t\t}\n\t\n\tfor(int i=1;i<=6;i++){\n\t\t on(V,0,i);\n\t}\n\n\tcout<<res<<endl;\n\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w>>Col){\n\t\tif(w==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nint di[] = {1, 0, -1, 0}, dj[] = {0, 1, 0, -1};\n\nmain {\n  while (true) {\n    int h, w, c;\n    cin >> h >> w >> c;\n    if (h == 0 && w == 0 && c == 0) break;\n    c--;\n    auto v = vectors(h, w, 0LL);\n    cin >> v;\n    rep(i, h) rep(j, w) v[i][j]--;\n    function<void(int, int, int, int)> dfs2 = [&](int i, int j, int a, int b) {\n      v[i][j] = b;\n      rep(k, 4) {\n        int ni = i + di[k], nj = j + dj[k];\n        if (ni < 0 || nj < 0 || ni >= h || nj >= w || v[ni][nj] != a) continue;\n        dfs2(ni, nj, a, b);\n      }\n    };\n    function<int(int)> dfs = [&](int n) {\n      if (n == 0) {\n        if (v[0][0] != c) dfs2(0, 0, v[0][0], c);\n        int maxi = 0;\n        rep(i, h) rep(j, w) {\n          if (v[i][j] != c) continue;\n          dfs2(i, j, c, -1);\n          int cnt = 0;\n          rep(k, h) rep(l, w) cnt += v[k][l] == -1;\n\n          cmax(maxi, cnt);\n          dfs2(i, j, -1, c);\n        }\n        return maxi;\n      }\n      auto tmp = v;\n      int maxi = 0;\n      rep(i, 6) {\n        if (v[0][0] == i) continue;\n        dfs2(0, 0, v[0][0], i);\n        cmax(maxi, dfs(n - 1));\n        v = tmp;\n      }\n      return maxi;\n    };\n    cout << dfs(4) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint change_color(vector<vector<int>>&fi, const int to_co) {\n\tqueue<pair<int, int>>que;\n\tconst int from_co = fi[1][1];\n\tque.push(make_pair(1, 1));\n\tfi[1][1] = -1;\n\twhile (!que.empty()) {\n\t\tconst auto p(que.front());\n\t\tque.pop();\n\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\tconst int nextx = p.first + dx[way];\n\t\t\tconst int nexty = p.second + dy[way];\n\t\t\tif (fi[nexty][nextx] == from_co) {\n\t\t\t\tfi[nexty][nextx] = -1;\n\t\t\t\tque.push(make_pair(nextx, nexty));\n\t\t\t}\n\t\t}\n\t}\n\tint num = 0;\n\tfor (auto& l : fi) {\n\t\tfor (auto& e : l) {\n\t\t\tif (e == -1) {\n\t\t\t\tnum++;\n\t\t\t\te = to_co;\n\t\t\t}\n\t\t}\n\t}\n\treturn num;\n}\n\nint solve(const vector<vector<int>>&ori_fi, const int rest,const int fin) {\n\tif (!rest) {\n\t\tvector<vector<int>>n_fi(ori_fi);\n\t\treturn change_color(n_fi, -1);\n\t}\n\tint amax = 0;\n\tfor (int nc = 1; nc <= 6; ++nc) {\n\t\tif (rest == 1 && nc != fin)continue;\n\t\tvector<vector<int>>n_fi(ori_fi);\n\t\tchange_color(n_fi, nc);\n\t\tamax = max(amax, solve(n_fi, rest - 1,fin));\n\t}\n\treturn amax;\n}\nint main() {\n\twhile (1) {\n\t\tint H, W, C; cin >> H >> W >> C;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tcin >> field[i + 1][j + 1];\n\t\t\t}\n\t\t}\n\t\tint ans = solve(field, 5,C);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n\ntemplate <typename T>\nclass UF{\npublic:\n\tvector<T> par,rank;\n\n\tUF(long long n){\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor(T i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tT find(T x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x]=find(par[x]);\n\t}\n\n\tvoid unite(T x, T y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\n\t\tif(rank[x]<rank[y])\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(T x, T y){\n\t\treturn find(x)==find(y);\n\t}\n\n};\n\nint dx[]={0, 1,0,-1};\nint dy[]={-1,0,1, 0};\n\nint main()\n{\n\tint h,w,c;\n\twhile(cin>>h>>w>>c,h){\n\n\t\tvector<vector<int> > table(h,vector<int>(w,0)),table2;\n\n\n\n\n\t\tfor(int i=0;i<h;i++){\t\n\t\t\tfor(int j=0;j<w;j++) cin>>table[i][j];\n\t\t}\n\t\t\t\t\n\t\ttable2=table;\n\t\t\n\t\t//cout<<\"init end\"<<endl;\n\t\t\n\t\tlong long res=0;\n\t\t//4????±???????\n\t\tfor(long long bit=0;bit<6LL*6LL*6LL*6LL;bit++){\n\t\t\t\n\t\t\ttable=table2;\n\t\t\tUF<long long> uf(1000);\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ny=i+dy[k],nx=j+dx[k];\n\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && table[i][j]==table[ny][nx]){\n\t\t\t\t\t\t\tuf.unite(i*w+j,ny*w+nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t\tlong long x=bit;\n\t\t\t\n\t\t\t//???????????????\n\t\t\tvector<int> vc(5);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tvc[i]=x%6;\n\t\t\t\tvc[i]++;\n\t\t\t\tx/=6;\n\t\t\t}\n\t\t\t//??????????????????\n\t\t\tvc[4]=c;\n\t\t\t\t\t\t\n\t\t\t//cout<<\"set order\"<<endl;\n\t\t\t\t\t\t\n\t\t\tfor(int i=0;i<5;i++){\n\n\t\t\t\t//?????´??°\n\t\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t\tif(uf.same(0,j*w+k)){\n\t\t\t\t\t\t\ttable[j][k]=vc[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//???????????????\n\t\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(uf.same(0,j*w+k)){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(int d=0;d<4;d++){\n\t\t\t\t\t\t\t\tint ny=j+dy[d],nx=k+dx[d];\n\t\t\t\t\t\t\t\tif(0<=ny && ny<h && 0<=nx && nx<w && table[j][k]==table[ny][nx]){\n\t\t\t\t\t\t\t\t\tuf.unite(ny*w+nx,0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\n\t\t\t}\n\n\t\t\tlong long cnt=0;\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\t//(0,0)??¨??????????????????\n\t\t\t\t\tif(uf.same(j*w+k,0)) cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tif(res<cnt){\n\t\t\t\t//cout<<bit<<endl;\n\t\t\t\tres=cnt;\n/*\t\t\t\t\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++) cout<<table[i][j]<<\" \";\n\t\t\t\t\tcout<<endl<<endl;\n\t\t\t\t}\n*/\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tcout<<res<<endl;\n\n\t}\n\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint m[10][10];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nstruct wolf{\n\tint m[10][10];\n};\nint ret=0;\nint a,b,c;\nvoid solve(int p,wolf t){\n\tif(!p){\n\t\tint V=0;\n\t\tint S=c;\n\t\tqueue<pair<int,int> > Q;\n\t\tQ.push(make_pair(1,1));\n\t\tt.m[1][1]=-1;\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tV++;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(S==t.m[row+dx[j]][col+dy[j]]){\n\t\t\t\t\tt.m[row+dx[j]][col+dy[j]]=-1;\n\t\t\t\t\tQ.push(make_pair(row+dx[j],col+dy[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret=max(ret,V);\n\t}else{\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tif(t.m[1][1]==i)continue;\n\t\t\twolf u=t;\n\t\t\tint S=t.m[1][1];\n\t\t\tqueue<pair<int,int> > Q;\n\t\t\tQ.push(make_pair(1,1));\n\t\t\tu.m[1][1]=i;\n\t\t\twhile(Q.size()){\n\t\t\t\tint row=Q.front().first;\n\t\t\t\tint col=Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tif(S==u.m[row+dx[j]][col+dy[j]]){\n\t\t\t\t\t\tu.m[row+dx[j]][col+dy[j]]=i;\n\t\t\t\t\t\tQ.push(make_pair(row+dx[j],col+dy[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(p-1,u);\n\t\t}\n\t}\n}\nint main(){\n\twolf W;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tret=0;\n\t\tfor(int i=0;i<10;i++)\n\t\t\tfor(int j=0;j<10;j++)W.m[i][j]=0;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\tscanf(\"%d\",&(W.m[i+1][j+1]));\n\t\t\n\t\tsolve(5,W);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define rep(i,from,to) for(int i=from; i<to; ++i)\n#define REP(i,from,to) for(int i=from; i<=to; ++i)\nusing namespace std;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\nconst int maxh = 8;\nint h, w, c;\nint di[4] = { -1, 0, 1, 0 };\nint dj[4] = { 0, 1, 0, -1 };\nint ans;\nint paint(vector<vector<int> >& p, int i, int j, int from, int to) { //from???????????????(i,j)???to??????????????????, p????????§??????\n\tp[i][j] = to;\n\tint cnt = 1; //(i,j)???to????????£????????§, ?????£?????°???1???\n\trep(k,0,4)\n\t{\n\t\tint ni = i + di[k], nj = j + dj[k];\n\t\tif (0 <= ni && ni < h && 0 <= nj && nj < w && (p[ni][nj] == from)) {\n\t\t\tcnt += paint(p, ni, nj, from, to); //??£??\\??????????????????????????????\n\t\t}\n\t}\n\treturn cnt; //(i,j)????????????????????????to???????????????????????????\n}\n\nvoid dfs(vector<vector<int> >& p, int level) { //\"????????????\"level?????????????????´\n\tint ret = 0;\n\tREP(col, 1, 6)\n\t{\n\t\tif (col == p[0][0]) { //????????¨???????????????????????????(????????????)\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 5 && col != c) { //5????????????c??\\??????????????´?????????\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<int> > next = p; //???????????????p????????????next????????£???????????????\n\t\tif (level < 5) { //1-4???????????§?????¨????????????\n\t\t\tpaint(next, 0, 0, next[0][0], col); //???col????????´??????\n\t\t\tdfs(next, level + 1); //next?????????????¬????\n\t\t} else {\n\t\t\tpaint(next, 0, 0, next[0][0], c); //?????????????¨????c??§??????\n\t\t\tret = paint(next, 0, 0, next[0][0], 0); //0??§???????????¨??§?????§???????????????????????°?????°????????????\n\t\t\tans = max(ans, ret);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\twhile (cin >> h >> w >> c, h || w || c) {\n\t\tans = 0;\n\t\tvector<vector<int> > p(h);\n\t\trep(i,0,h)\n\t\t{\n\t\t\tp[i] = vector<int>(w);\n\t\t\trep(j,0,w)\n\t\t\t{\n\t\t\t\tcin >> p[i][j];\n\t\t\t}\n\t\t}\n\t\tdfs(p, 1);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\n\n\n\nvoid change(int h, int w, int i, int j, int from, int to, vector<vector<int> >& a){\n\n    a[i][j] = to;\n    for(int l = 0; l < 4; l++){\n        int ni = i + di[l];\n        int nj = j + dj[l];\n        if(0 <= ni && ni < h && 0 <= nj && nj < w && a[ni][nj] == from) change(h, w, ni, nj, from, to, a);\n    }\n}\n\nint main(){\n    \n    while(1){\n\n        //入力\n        int h, w, c; cin >> h >> w >> c;\n        if(!h) break;\n        vector<vector<int> > a(h, vector<int> (w));\n        for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) cin >> a[i][j];\n\n        \n        vector<vector<int> > b(h, vector<int> (w));\n        //change(h, w, 0, 0, 1, 3, a);\n        int ans = 0;\n        for(int i = 1; i <= 6; i++){\n            for(int j = 1; j <= 6; j++){\n                for(int k = 1; k <= 6; k++){\n                    for(int l = 1; l <= 6; l++){\n\n                        \n                        for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) b[i][j] = a[i][j];\n                        \n                        //cout << \"ok\" << endl;\n                        change(h, w, 0, 0, b[0][0], i, b);\n                        change(h, w, 0, 0, b[0][0], j, b);\n                        change(h, w, 0, 0, b[0][0], k, b);\n                        change(h, w, 0, 0, b[0][0], l, b);\n                        change(h, w, 0, 0, b[0][0], c, b);\n                        //cout << \"ok\" << endl;\n                        int temp = 0;\n                        for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) if(b[i][j] == c) temp++;\n                        ans = max(ans, temp);\n\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    while (true) {\n        int h;\n        int w;\n        int c;\n        scanf(\"%d %d %d\", &h, &w, &c);\n        if (h == 0 && w == 0 && c == 0) {\n            break;\n        }\n\n        vector<vector<int>> cp;\n        cp.resize(h);\n        for (auto i = 0; i < h; ++i) {\n            for (auto j = 0; j < w; ++j) {\n                int pp;\n                scanf(\"%d\", &pp);\n                cp[i].push_back(pp);\n            }\n        }\n        const auto p = move(cp);\n\n        auto f = [&p, w, h](const vector<int>& colors) {\n            auto pp = p;\n            auto cc = [&pp](int i, int j, int c) { return pp[i][j] == c; };\n\n            // if (cc(0, 0, colors[0])) {\n            //    return 0;\n            //}\n\n            // pp[0][0] = colors[0];\n            for (size_t n = 0; n < colors.size(); ++n) {\n                const auto ccc = colors[n];\n                // printf(\"ccc %d\\n\", ccc);\n                auto getAdjency = [w, h](int i, int j) {\n                    vector<pair<int, int>> r;\n                    if (i - 1 >= 0) {\n                        r.push_back(make_pair(i - 1, j));\n                    }\n                    if (i + 1 < h) {\n                        r.push_back(make_pair(i + 1, j));\n                    }\n                    if (j - 1 >= 0) {\n                        r.push_back(make_pair(i, j - 1));\n                    }\n                    if (j + 1 < w) {\n                        r.push_back(make_pair(i, j + 1));\n                    }\n                    return r;\n                };\n                stack<pair<int, int>> s;\n                s.push(make_pair(0, 0));\n                vector<vector<bool>> v;\n                v.resize(h);\n                for (auto&& r : v) {\n                    r.resize(w);\n                }\n                auto init = pp[0][0];\n                while (!s.empty()) {\n                    auto t = s.top();\n                    s.pop();\n                    v[t.first][t.second] = true;\n                    pp[t.first][t.second] = ccc;\n                    auto r = getAdjency(t.first, t.second);\n                    // printf(\"get\\n\");\n                    for (auto&& i : r) {\n                        // printf(\"%d %d\\n\", i.first, i.second);\n                        if (!v[i.first][i.second] &&\n                            init == pp[i.first][i.second]) {\n                            // printf(\"push\\n\");\n                            // printf(\"%d %d\\n\", i.first, i.second);\n                            s.push(i);\n                        }\n                    }\n                }\n\n                //    for (auto&& r : pp) {\n                //        for (auto&& b : r) {\n                //            printf(\"%d \", b);\n                //        }\n                //        putchar('\\n');\n                //    }\n                //    putchar('\\n');\n            }\n            // putchar('\\n');\n            // for (auto&& r : pp) {\n            //    for (auto&& b : r) {\n            //        printf(\"%d \", b);\n            //    }\n            //    putchar('\\n');\n            //}\n            // putchar('\\n');\n\n            auto getAdjency = [w, h](int i, int j) {\n                vector<pair<int, int>> r;\n                if (i - 1 >= 0) {\n                    r.push_back(make_pair(i - 1, j));\n                }\n                if (i + 1 < h) {\n                    r.push_back(make_pair(i + 1, j));\n                }\n                if (j - 1 >= 0) {\n                    r.push_back(make_pair(i, j - 1));\n                }\n                if (j + 1 < w) {\n                    r.push_back(make_pair(i, j + 1));\n                }\n                return r;\n            };\n            stack<pair<int, int>> s;\n            s.push(make_pair(0, 0));\n            vector<vector<bool>> v;\n            v.resize(h);\n            for (auto&& r : v) {\n                r.resize(w);\n            }\n            auto count = 0;\n            while (!s.empty()) {\n                auto t = s.top();\n                s.pop();\n                auto r = getAdjency(t.first, t.second);\n                for (auto&& i : r) {\n                    if (!v[i.first][i.second] &&\n                        pp[i.first][i.second] == pp[0][0]) {\n                        v[i.first][i.second] = true;\n                        ++count;\n                        s.push(i);\n                        // printf(\"push %d %d\\n\", i.first, i.second);\n                    }\n                }\n            }\n            // for (auto&& i : colors) {\n            //    printf(\"%d \", i);\n            //}\n            // printf(\": count %d\\n\\n\", count);\n            return count;\n        };\n\n        vector<int> colors;\n        colors.resize(5);\n        // f({2, 3, 4, 2, 5});\n\n        auto max = 1;\n        for (auto a = 1; a <= 6; ++a) {\n            for (auto b = 1; b <= 6; ++b) {\n                for (auto e = 1; e <= 6; ++e) {\n                    for (auto d = 1; d <= 6; ++d) {\n                        colors[0] = a;\n                        colors[1] = b;\n                        colors[2] = e;\n                        colors[3] = d;\n                        colors[4] = c;\n                        auto r = f(colors);\n                        if (r > max) {\n                            max = r;\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", max);\n\n        // break;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\n\nint h, w, c;\nvvi panel;\nvvi initPanel;\nvvb visited;\nvi change;\n\nbool in(int i, int j){\n\treturn 0 <= i && i < h && 0 <= j && j < w;\n}\n\nint CountDfs(int i, int j){\n\tvisited[i][j] = true;\n\tint sum = 1;\n\tint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\tfor (int k = 0; k < 4; k++) {\n\t\tint ni = i + dy[k], nj = j + dx[k];\n\t\tif (in(ni, nj) && !visited[ni][nj] && panel[ni][nj] == c)\n\t\t\tsum += CountDfs(ni, nj);\n\t}\n\treturn sum;\n}\n\nint CountBond(){\n\tint ret = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (!visited[i][j] && panel[i][j] == c)\n\t\t\t\tret = max(ret, CountDfs(i, j));\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid Change(int i, int j, int color, int prev){\n\tpanel[i][j] = color;\n\tint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\tfor (int k = 0; k < 4; k++) {\n\t\tint ni = i + dy[k], nj = j + dx[k];\n\t\tif (in(ni, nj) && panel[ni][nj] == prev)\n\t\t\tChange(ni, nj, color, prev);\n\t}\n}\n\nint apply(){\n\tfor (int i = 0; i < 5; i++) {\n\t\tif (change[i] != panel[0][0])\n\t\t\tChange(0, 0, change[i], panel[0][0]);\n\t}\n\n\treturn CountBond();\n}\n\nint calc(){\n\tint ret = 0;\n\tint maxCount = pow(6, 5);\n\n\tpanel = vvi(h, vi(w, 0));\n\tchange = vi(5);\n\n\tfor (int loop = 0; loop < maxCount; loop++) {\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tpanel[i][j] = initPanel[i][j];\n\n\t\tvisited = vvb(h, vb(w, false));\n\t\tint n = loop;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tchange[i] = (n % 6) + 1;\n\t\t\tn /= 6;\n\t\t}\n\t\tchange[4] = c;\n\t\tret = max(ret, apply());\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile (cin >> h >> w >> c , !(h == 0 && w == 0 && c == 0)) {\n\t\tinitPanel = vvi(h, vi(w, 0));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> initPanel[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << calc() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nint h, w, color;\nbool checked[10][10];\n\nvoid fill(int x, int y, int f, int t, vvi& panel) {\n\tpanel[y][x] = t;\n\tif( 0<=x-1 && panel[y][x-1]==f ) {\n\t\tfill(x-1, y, f, t, panel);\n\t}\n\tif( x+1<w && panel[y][x+1]==f ) {\n\t\tfill(x+1, y, f, t, panel);\n\t}\n\tif( 0<=y-1 && panel[y-1][x]==f ) {\n\t\tfill(x, y-1, f, t, panel);\n\t}\n\tif( y+1<h && panel[y+1][x]==f ) {\n\t\tfill(x, y+1, f, t, panel);\n\t}\n}\n\nint count(int x, int y, vvi& p) {\n\tint cnt = 1;\n\tchecked[y][x] = true;\n\tif( 0<=x-1 && p[y][x-1]==p[y][x] && !checked[y][x-1] ) {\n\t\tcnt += count(x-1, y, p);\n\t}\n\tif( x+1<w && p[y][x+1]==p[y][x] && !checked[y][x+1] ) {\n\t\tcnt += count(x+1, y, p);\n\t}\n\tif( 0<=y-1 && p[y-1][x]==p[y][x] && !checked[y-1][x] ) {\n\t\tcnt += count(x, y-1, p);\n\t}\n\tif( y+1<h && p[y+1][x]==p[y][x] && !checked[y+1][x] ) {\n\t\tcnt += count(x, y+1, p);\n\t}\n\treturn cnt;\n}\n\nint dfs(int lp, vvi& panel) {\n\tif( lp==0 ) {\n\t\tvvi p = panel;\n\t\tif(color == p[0][0]) return 0;\n\t\tfill(0, 0, p[0][0], color, p);\n\t\tmemset(checked, 0, sizeof(checked));\n\t\treturn count(0, 0, p);\n\t}\n\tint res = 0;\n\tfor(int c=1; c<=6; c++) {\n\t\tif(c == panel[0][0]) continue;\n\t\tvvi p = panel;\n\t\tfill(0, 0, p[0][0], c, p);\n\t\tres = max(res, dfs(lp-1, p));\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile( cin >> h >> w >> color, h||w||color ) {\n\t\tvvi panel(h);\n\t\trep(y, h) {\n\t\t\tpanel[y].resize(w);\n\t\t\trep(x, w) {\n\t\t\t\tcin >> panel[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << dfs(4, panel) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint p[10][10];\nint d[5] = {0, 1, 0, -1, 0};\nint h, w, c;\n\nint dfs(int cnt) {\n    if (cnt == 5) {\n        if (p[0][0] != c) return 0;\n        int ret = 1;\n        int vis[10][10] = {};\n        queue<int> qi;\n        queue<int> qj;\n        qi.push(0);\n        qj.push(0);\n        vis[0][0] = 1;\n        while (!qi.empty()) {\n            int pi = qi.front(), pj = qj.front();\n            qi.pop();\n            qj.pop();\n            for (int i = 0; i < 4; ++i) {\n                int ti = pi + d[i], tj = pj + d[i + 1];\n                if (ti >= 0 && ti < h && tj >= 0 && tj < w && !vis[ti][tj] && p[ti][tj] == c) {\n                    ++ret;\n                    vis[ti][tj] = 1;\n                    qi.push(ti);\n                    qj.push(tj);\n                }\n            }\n        }\n        return ret;\n    }\n    int ret = -1;\n    for (int col = 1; col <= 6; ++col) {\n        int prev = p[0][0];\n        if (prev == col) continue;\n        int temp[10][10];\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                temp[i][j] = p[i][j];\n            }\n        }\n        queue<int> qi;\n        queue<int> qj;\n        qi.push(0);\n        qj.push(0);\n        p[0][0] = col;\n        while (!qi.empty()) {\n            int pi = qi.front(), pj = qj.front();\n            qi.pop();\n            qj.pop();\n            for (int i = 0; i < 4; ++i) {\n                int ti = pi + d[i], tj = pj + d[i + 1];\n                if (ti >= 0 && ti < h && tj >= 0 && tj < w && p[ti][tj] == prev) {\n                    p[ti][tj] = col;\n                    qi.push(ti);\n                    qj.push(tj);\n                }\n            }\n        }\n        ret = max(ret, dfs(cnt + 1));\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                p[i][j] = temp[i][j];\n            }\n        }\n    }\n    return ret;\n}\n\n\nint main() {\n    while (1) {\n        cin >> h >> w >> c;\n        if (!h) return 0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> p[i][j];\n            }\n        }\n        cout << dfs(0) << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,k,n) for(int i=k;i<(int)(n);i++)\n\n#define vi vector<int>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n\ntypedef long long ll;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nint main(){\n    ifstream in(\"cin.txt\");\n    cin.rdbuf(in.rdbuf());\n    int h,w,c;\n    while(cin >> h >> w >> c,h||w||c){\n        int ma = 0;\n        int p[10][10] = {};\n        rep(y,h)rep(x,w) cin >> p[y][x];\n        int a[6] = {};\n        rep(bit,pow(6,4)){\n            int tmp_bit = bit;\n            rep(i,4){\n                a[i] = tmp_bit%6;\n                tmp_bit/=6;\n                a[i]+=1;\n//                cout << a[i] << \" \";\n            }\n//            cout << endl;\n            a[4] = c;\n//            rep(i,c) cout << a[i] << \" \";\n//            cout << endl;\n            int t[10][10];\n            rep(y,h)rep(x,w) t[y][x] = p[y][x];\n\n            rep(i,5){\n\n                queue<pii> que;\n                que.push(make_pair(0,0));\n                int now_color = t[0][0];\n                bool u[10][10] = {};\n                while(!que.empty()){\n                    int x,y;\n                    tie(x,y) = que.front();\n                    que.pop();\n                    u[y][x] = true;\n                    t[y][x] = a[i];\n                    rep(d,4){\n                        int nx = x + dx[d];\n                        int ny = y + dy[d];\n                        if(nx < 0 || w <= nx ||\n                                ny < 0 || h <= ny) continue;\n                        if(u[ny][nx] || t[ny][nx] != now_color) continue;\n                        que.push(make_pair(nx,ny));\n                    }\n                }\n            }\n            int cnt = 0;\n            queue<pii> qe;\n            qe.push(make_pair(0,0));\n            bool uu[10][10] = {};\n\n            while(!qe.empty()) {\n                int xp, yp;\n\n                if(cnt > 1000){\n                    rep(yy,h){rep(xx,w) cout << uu[yy][xx] << \" \"; cout << endl;}\n                    cout << \"q : \" << qe.front().fi << \" \" << qe.front().se << endl;\n                    cout << endl;\n                }\n                tie(xp, yp) = qe.front();\n                qe.pop();\n                if(uu[yp][xp]) continue;\n                cnt += 1;\n                uu[yp][xp] = true;\n                rep(d, 4) {\n                    int nx = xp + dx[d];\n                    int ny = yp + dy[d];\n                    if (nx < 0 || w <= nx ||\n                        ny < 0 || h <= ny)\n                        continue;\n                    if(uu[ny][nx]) continue;\n                    if(t[ny][nx] != c) continue;\n                    qe.push(make_pair(nx, ny));\n                }\n            }\n            ma = max(ma,cnt);\n        };\n        cout << ma << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint H,W,C,diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\n\nstruct Info{\n\tint table[8][8],count;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tInfo first;\n\tfirst.count = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&first.table[i][k]);\n\t}\n\n\tqueue<Info> Q;\n\n\tQ.push(first);\n\n\tqueue<Data> D;\n\n\tint maximum = 1,self_color,num,next_row,next_col,new_color;\n\n\tbool tonari_color[7],check[8][8];\n\tInfo work;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().count == 5){\n\n\t\t\tnum = 0;\n\n\t\t\tD.push(Data(0,0));\n\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int k = 0; k < W; k++)check[i][k] = false;\n\t\t\t}\n\n\t\t\tcheck[0][0] = true;\n\n\t\t\twhile(!D.empty()){\n\n\t\t\t\tQ.front().table[D.front().row][D.front().col] = 9;\n\t\t\t\tnum++;\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tnext_row = D.front().row + diff_row[i];\n\t\t\t\t\tnext_col = D.front().col + diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && Q.front().table[next_row][next_col] == C && check[next_row][next_col] == false){\n\t\t\t\t\t\tcheck[next_row][next_col] = true;\n\t\t\t\t\t\tD.push(Data(next_row,next_col));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tD.pop();\n\t\t\t}\n\n\t\t\tmaximum = max(maximum,num);\n\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tQ.front().count++;\n\n\t\t\tif(Q.front().count <= 4){\n\n\t\t\t\tself_color = Q.front().table[0][0];\n\t\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\t\ttonari_color[i] = false;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\t\twork.table[i][k] = Q.front().table[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tD.push(Data(0,0));\n\t\t\t\tcheck[0][0] = true;\n\n\t\t\t\twhile(!D.empty()){\n\t\t\t\t\twork.table[D.front().row][D.front().col] = 9;\n\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tnext_row = D.front().row + diff_row[i];\n\t\t\t\t\t\tnext_col = D.front().col + diff_col[i];\n\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col)){\n\t\t\t\t\t\t\tif(work.table[next_row][next_col] != self_color && work.table[next_row][next_col] != 9){\n\t\t\t\t\t\t\t\ttonari_color[work.table[next_row][next_col]] = true;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(work.table[next_row][next_col] == self_color){\n\t\t\t\t\t\t\t\t\tD.push(Data(next_row,next_col));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tD.pop();\n\t\t\t\t}\n\n\t\t\t\tnum = 0;\n\t\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\t\tif(tonari_color[i] == true){\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(num == 0){\n\t\t\t\t\tmaximum = H*W;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\t\tif(i == self_color || tonari_color[i] == false)continue;\n\n\t\t\t\t\tInfo next;\n\t\t\t\t\tnext.count = Q.front().count;\n\t\t\t\t\tfor(int a = 0; a < H; a++){\n\t\t\t\t\t\tfor(int b = 0; b < W; b++){\n\t\t\t\t\t\t\tnext.table[a][b] = Q.front().table[a][b];\n\t\t\t\t\t\t\tcheck[a][b] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnew_color = i;\n\n\t\t\t\t\tcheck[0][0] = true;\n\n\t\t\t\t\tD.push(Data(0,0));\n\n\t\t\t\t\twhile(!D.empty()){\n\t\t\t\t\t\tnext.table[D.front().row][D.front().col] = new_color;\n\n\t\t\t\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\t\t\t\tnext_row = D.front().row + diff_row[a];\n\t\t\t\t\t\t\tnext_col = D.front().col + diff_col[a];\n\n\t\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && check[next_row][next_col] == false && next.table[next_row][next_col] == self_color){\n\t\t\t\t\t\t\t\tcheck[next_row][next_col] = true;\n\t\t\t\t\t\t\t\tD.push(Data(next_row,next_col));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tD.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\n\t\t\t\tQ.pop();\n\n\t\t\t}else{\n\n\t\t\t\tself_color = Q.front().table[0][0];\n\n\t\t\t\tD.push(Data(0,0));\n\n\t\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\t\tfor(int k = 0; k < W; k++)check[i][k] = false;\n\t\t\t\t}\n\n\t\t\t\tcheck[0][0] = true;\n\n\t\t\t\twhile(!D.empty()){\n\t\t\t\t\tQ.front().table[D.front().row][D.front().col] = C;\n\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tnext_row = D.front().row + diff_row[i];\n\t\t\t\t\t\tnext_col = D.front().col + diff_col[i];\n\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && check[next_row][next_col] == false && Q.front().table[next_row][next_col] == self_color){\n\t\t\t\t\t\t\tcheck[next_row][next_col] = true;\n\t\t\t\t\t\t\tD.push(Data(next_row,next_col));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tD.pop();\n\t\t\t\t}\n\n\t\t\t\tQ.push(Q.front());\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",maximum);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&C);\n\t\tif(H == 0 && W == 0 && C == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nstruct S {\n  int p[8][8];\n  S() { fill_n((int*)p, 8 * 8, -1); }\n  // bool operator < (const S &s) const {\n  //   for (int i = 0; i < 8; i++) {\n  //     for (int j = 0; j < 8; j++) {\n  //       if (p[i][j] != s.p[i][j]) return p[i][j] < s.p[i][j];\n  //     }\n  //   }\n  // }\n};\n\nint dy[4] = {0, -1, 0, 1};\nint dx[4] = {1, 0, -1, 0};\nint h, w, c;\nint used[8][8];\n\nbool contain(int y, int x) {\n  return y >= 0 && y < h && x >= 0 && x < w;\n}\n\nint dfs(S *s, int y, int x, int c, int flag) {\n  int res = 1;\n  char ch = flag ? c : s->p[y][x];\n  used[y][x]++;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (contain(ny, nx) && !used[ny][nx] && s->p[ny][nx] == ch) {\n      res += dfs(s, ny, nx, c, flag);\n    }\n  }\n  s->p[y][x] = c;\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> h >> w >> c, h) {\n    S s;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> s.p[i][j];\n      }\n    }\n    using P = pair<int, S>;\n    queue<P> que;\n    que.emplace(0, s);\n    int ans = 0;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      S curr = p.second;\n      if (p.first == 5) continue;\n      for (int i = 1; i <= 6; i++) {\n        if (curr.p[0][0] == i) continue;\n        S next = curr;\n        fill_n((int*)used, 8 * 8, 0);\n        dfs(&next, 0, 0, i, 0);\n        fill_n((int*)used, 8 * 8, 0);\n        if (i == c && p.first + 1 == 5) {\n          ans = max(ans, dfs(&next, 0, 0, i, 1));\n        }\n        que.emplace(p.first + 1, next);\n      }\n    }\n    cout << ans << endl;\n  }  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint h, w, c, ans;\nint panel[8][8], done[8][8];\nconst int di[] = {1,0,-1,0}, dj[] = {0,1,0,-1};\ninline bool in(int i, int j) { return i >= 0 and i < h and j >= 0 and j < w;}\n\nint dfs2(int i, int j, int prev, int to, int p[8][8]){\n    done[i][j] = 1;\n    p[i][j] = to;\n    int ret = 1;\n    rep(d,4){\n        int ni = i + di[d], nj = j + dj[d];\n        if(in(ni,nj) and !done[ni][nj] and p[ni][nj] == prev)\n            ret += dfs2(ni,nj,prev, to, p);\n    }\n    return ret;\n}\n\nvoid dfs(int turn, int pp[8][8]){\n    int p[8][8];\n    if(turn == 4){\n        memcpy(p,pp,sizeof(p));\n        memset(done, 0, sizeof(done));\n        dfs2(0,0,p[0][0],c,p);\n        memset(done, 0, sizeof(done));\n        ans = max(ans, dfs2(0,0,p[0][0],c,p));\n    }\n    else {\n        repi(i,1,7){\n            memcpy(p,pp,sizeof(p));\n            memset(done, 0, sizeof(done));\n            dfs2(0,0,p[0][0],i,p);\n            dfs(turn+1,p);\n        }\n    }\n}\n\nint solve(){\n    ans = 0;\n    dfs(0,panel);\n    return ans;\n}\n\nbool input(){\n    cin >> h >> w >> c;\n    if(!h and !w and !c) return 0;\n    rep(i,h)rep(j,w) cin >> panel[i][j];\n    return 1;\n}\n\nint main()\n{\n    while(input()) cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define MAX_N 8\n#define MAX_M 8\n#define MAX_C 6\n#define INF 1000000\nusing namespace std;\n\nint N, M, C, ans = 1, nd, flag = 0;\nint field[MAX_N][MAX_M], d[MAX_N][MAX_M], dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nclass Graphs\n{\npublic:\n\tint g[MAX_N][MAX_M];\n\tint sum;\n\tint node;\n\tint intialize(int x[MAX_N][MAX_M]);\n\tint ingrh(int x[MAX_N][MAX_M]);\n\tvoid outgrh();\n\tint outNode();\n};\n\nint Graphs::intialize(int x[MAX_N][MAX_M])\n{\n\tnode = 0;\n\tfor (int i = 0; i < N; i++) \n\t\tfor (int j = 0; j < M; j++) g[i][j] = field[i][j];\n\n\treturn node;\n}\n\nint Graphs::ingrh(int x[MAX_N][MAX_M])\n{\n\tsum = 0;\n\tnode++;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tg[i][j] = x[i][j];\n\t\t\tif (g[i][j] == 7) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\tif (node == 5 && ans < sum) ans = sum;\n\n\treturn node;\n}\n\nvoid Graphs::outgrh()\n{\n\tfor (int i = 0; i < N; i++) \n\t\tfor (int j = 0; j < M; j++)  field[i][j] = g[i][j];\n}\n\ntypedef Graphs G;\ntypedef pair<int, int> P;\n\nG grh;\nqueue<G> que;\n\nvoid initINF(){\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\td[0][0] = 0; \n}\n\nvoid bfs(int color) {\n\tqueue<P> qg;\n\tqg.push(P(0, 0));\n\tinitINF();\n\twhile(qg.size()) {\n\t\tP p = qg.front();\n\t\tqg.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && (field[nx][ny] == 7 || field[nx][ny] == color) && d[nx][ny] == INF) {\n\t\t\t\tif (field[nx][ny] == color) flag = 1;\n\t\t\t\tqg.push(P(nx, ny));\n\t\t\t\td[nx][ny] = 0;\n\t\t\t\tfield[nx][ny] = 7;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint Graphs::outNode() { return node; }\n\nvoid solve()\n{\n\tint color;\n\tcolor = field[0][0];\n\tfield[0][0] = 7;\n\tbfs(color);\t\n\tgrh.intialize(field);\n\tnd = grh.outNode();\n\tque.push(grh);\n\tfor (int i = 0; nd < 4; i++) {\n\t\tfor (int j = 0; j < MAX_C+1; j++) {\n\t\t\tgrh = que.front();\n\t\t\tgrh.outgrh();\n\t\t\tif (j == C) continue;\n\t\t\tflag = 0;\n\t\t\tbfs(j);\n\t\t\tif (flag == 1) {\n\t\t\t\tgrh.ingrh(field);\n\t\t\t\tque.push(grh);\n\t\t\t}\n\t\t}\n\t\tque.pop();\n\t\tif (que.size()) {\n\t\t\tgrh = que.front();\n\t\t\tnd = grh.outNode();\n\t\t}else break;\n\t}\n\twhile (que.size()) {\n\t\tgrh = que.front();\n\t\tque.pop();\n\t\tgrh.outgrh();\n\t\tbfs(C);\n\t\tgrh.ingrh(field);\n\t}\n}\n\nint main(void)\n{\n\twhile (cin >> N >> M >> C) {\n\t\tans = 1;\n\t\tfor (int i = 0; i < N; i++) \n\t\t\tfor (int j = 0; j < M; j++) cin >> field[i][j];\n\t\tsolve();\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\n// #define DEBUG\n\nusing namespace std;\n\nint h, w, c;\nint p[9][9];\n\nvoid Coloring(int y, int x, int c, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      Coloring(ny, nx, c, checked);\n    }\n  }\n  p[y][x] = c;\n  checked[y][x] = false;\n}\n\nint Count(int y, int x, bool checked[9][9]) {\n  if (checked[y][x]) {\n    return 0;\n  }\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1};\n\n  int ret = 0;\n  checked[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (ny < 0 || ny >= h) {\n      continue;\n    }\n    if (nx < 0 || nx >= w) {\n      continue;\n    }\n    if (p[y][x] == p[ny][nx]) {\n      ret += Count(ny, nx, checked);\n    }\n  }\n\n  return ret + 1; \n}\n\nint dfs(int limit, int c, int pv[10]) {\n  if (limit == 0) {\n    if (p[0][0] != c) {\n      return 0;\n    }\n    bool checked[9][9] = { false };\n    return Count(0, 0, checked);\n  }\n  int ret = 0;\n  for (int i = 1; i <= 6; i++) {\n    int tmp[9][9];\n    memcpy(tmp, p, sizeof(p));\n    bool checked[9][9] = { false };\n    Coloring(0, 0, i, checked);\n    int tpv[10] = { 0 };\n    int d = dfs(limit - 1, c, tpv);\n    memcpy(p, tmp, sizeof(p)); // UNDO\n    if (d > ret) {\n      ret = d;\n      pv[limit] = i;\n      for (int j = 0; j < limit; j++) {\n        pv[j] = tpv[j];\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> h >> w >> c;\n    if (h + w + c == 0) {\n      break;\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> p[i][j];\n      }\n    }\n    int pv[10] = { 0 };\n    cout << dfs(5, c, pv) << endl;\n   \n#ifdef DEBUG\n    for (int i = 0; i < 10; i++) {\n      cout << pv[i] << \" \\n\"[i == 9];\n    }\n  }\n#endif\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint s[1311][7],t[7],cnt,a[11][11];\nint n,m,k;\nvoid dfs(int x)\n{\n    //printf(\"x=%d,t=%d\\n\",x,t[x-1]);\n    if(x==4)\n    {\n        for(int i=0;i<4;i++)\n        s[cnt][i]=t[i];\n        cnt++;\n        return;\n    }\n    for(int i=1;i<7;i++)\n    {\n        t[x]=i;\n        dfs(x+1);\n    }\n}\nvoid init()\n{\n    int i,j;\n    cnt=0,dfs(0);\n//    for(i=0;i<cnt;i++)\n//    {\n//        if(s[i][0]==5&&s[i][1]==2&&s[i][2]==3&&s[i][3]==2)\n//        printf(\"i=%d\\n\",i);\n//    }\n}\nstruct node\n{\n    int x,y;\n}re[111];\nint dir[4][2]={1,0,-1,0,0,1,0,-1};\nint solve(int x)\n{\n    int i,j,tt,l;\n    int b[11][11],flag[11][11];\n    node st,t1,t2;\n    for(i=1;i<=n;i++)\n    for(j=1;j<=m;j++)b[i][j]=a[i][j];\n    queue<node>q;st.x=st.y=1;l=1;re[0]=st;\n    memset(flag,0,sizeof(flag));flag[st.x][st.y]=1;\n    for(int i1=0;i1<6;i1++)\n    {\n        if(i1<4)tt=s[x][i1];\n        else tt=k;\n        for(j=0;j<l;j++)\n        q.push(re[j]);\n//        if(x==913)\n//        {\n//            printf(\"ii=%d,l=%d\\n\",i1,l);\n//            for(j=0;j<l;j++)\n//            printf(\"%d %d %d\\n\",re[j].x,re[j].y,b[re[j].x][re[j].y]);\n//        }\n        while(!q.empty())\n        {\n            t1=q.front();q.pop();\n            for(i=0;i<4;i++)\n            {\n                if(t1.x+dir[i][0]>0&&t1.x+dir[i][0]<=n&&t1.y+dir[i][1]>0&&t1.y+dir[i][1]<=m)\n                {\n                    t2.x=t1.x+dir[i][0];t2.y=t1.y+dir[i][1];\n                    if(!flag[t2.x][t2.y]&&b[t2.x][t2.y]==b[t1.x][t1.y])\n                    {\n                        q.push(t2);re[l++]=t2;\n                        flag[t2.x][t2.y]=1;\n                    }\n                }\n            }\n        }\n        for(j=0;j<l;j++)\n        b[re[j].x][re[j].y]=tt;\n    }\n    return l;\n}\nint main()\n{\n   //freopen(\"c.in\",\"r\",stdin);\n//    freopen(\"c.out\",\"w\",stdout);\n     int i,j,ans;\n     init();\n     while(scanf(\"%d%d%d\",&n,&m,&k)==3)\n     {\n         if(n==0&&m==0&&k==0)break;\n         for(i=1;i<=n;i++)\n         for(j=1;j<=m;j++)\n         scanf(\"%d\",&a[i][j]);ans=0;\n         for(i=0;i<cnt;i++)\n             ans=max(ans,solve(i));\n         printf(\"%d\\n\",ans);\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[y][x] == b[ty][tx] && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\nvoid cpy(int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0;\n\tif (b[0][0] != c) cpy(0), rec(0, 0, c);\n\tcpy(2), ret = rec1(0, 0), cpy(1);\n\tif (d < 0) {\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(0), rec(0, 0, c);\n\t\t\tret = max(ret, solve(d + 1)), cpy(1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\nconst int error=1e9-7;\n#define F first\n#define S second\n#define MK make_pair\nint b[10][10][10]={};\nint ansp[10][10]={};\n\nint dfs_ans(int x,int y,int c){\n    int ans=0;\n    ansp[x][y]=-1;\n    ans++;\n    if(x!=9 && ansp[x+1][y]==c){ans+=dfs_ans(x+1,y,c);}\n    if(y!=9 && ansp[x][y+1]==c){ans+=dfs_ans(x,y+1,c);}\n    if(x!=0 && ansp[x-1][y]==c){ans+=dfs_ans(x-1,y,c);}\n    if(y!=0 && ansp[x][y-1]==c){ans+=dfs_ans(x,y-1,c);}\n    return ans;\n}\n\nint ans(int c){\n    int mx=0;\n    for(int i=0;i<10;i++){\n        for(int t=0;t<10;t++){\n            ansp[i][t]=b[5][i][t];\n        }\n    }\n    for(int i=0;i<10;i++){\n        for(int t=0;t<10;t++){\n            if(ansp[i][t]==c){mx=max(mx,dfs_ans(i,t,c));}\n        }\n    }\n    return mx;\n}\n\nvoid dfs_change(int x,int y,int t,int k,int c){\n    if(k==c){return;}\n    b[t][x][y]=c;\n    if(x!=9 && b[t][x+1][y]==k){dfs_change(x+1,y,t,k,c);}\n    if(y!=9 && b[t][x][y+1]==k){dfs_change(x,y+1,t,k,c);}\n    if(x!=0 && b[t][x-1][y]==k){dfs_change(x-1,y,t,k,c);}\n    if(y!=0 && b[t][x][y-1]==k){dfs_change(x,y-1,t,k,c);}\n}\n\nvoid change(int t,int c){\n    for(int i=0;i<10;i++){\n        for(int h=0;h<10;h++){\n            b[t+1][i][h]=b[t][i][h];\n        }\n    }\n    dfs_change(0,0,t+1,b[t+1][0][0],c);\n}\n\nint search(int t,int c){\n    if(t==5){return ans(c);}\n    int mx=0;\n    for(int i=1;i<=6;i++){\n        change(t,i);\n        mx=max(mx,search(t+1,c));\n    }\n    return mx;\n}\n\n\n\n\n\nint main(){\n    while(1){\n    \n    \n    \n    int h,w,c;\n    cin>>h>>w>>c;\n        if(h==0 && w==0 && c==0){break;}\n    for(int i=0;i<10;i++){\n        for(int t=0;t<10;t++){\n            b[0][i][t]=0;\n        }\n    }\n    for(int i=0;i<h;i++){\n        for(int t=0;t<w;t++){\n            cin>>b[0][i][t];\n        }\n    }\n    cout<<search(0,c)<<endl;\n    \n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ntypedef pair<int, int> P;\n\nint p[10][10], visited[10][10];\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nint h, w, c;\n\nint dfs(int count) {\n    if(count == 5) {\n        int ret = 0;\n        if(p[0][0] != c) return 0;\n        rep(i, 10) rep(j, 10) visited[i][j] = 0;\n        queue<P> que;\n        que.push(P(0, 0));\n        while(!que.empty()) {\n            P point = que.front(); que.pop();\n            if(visited[point.first][point.second] == 0) {\n               visited[point.first][point.second] = 1;\n               ret++;\n                rep(i, 4) {\n                    int ny = point.first + dy[i];\n                    int nx = point.second + dx[i];\n                    if(nx >= 0 && nx < w && ny >= 0 && ny < h &&\n                       visited[ny][nx] == 0 && p[ny][nx] == c) {\n                        que.push(P(ny, nx));\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n    int org[10][10];\n    int ret = 0;\n    rep(i, h) rep(j, w) org[i][j] = p[i][j];\n    rep(color, 6) {\n        int org_c = p[0][0];\n        rep(i, 10) rep(j, 10) visited[i][j] = 0;\n        queue<P> que;\n        que.push(P(0, 0));\n        while(!que.empty()) {\n            P point = que.front(); que.pop();\n            p[point.first][point.second] = color+1;\n            visited[point.first][point.second] = 1;\n            rep(i, 4) {\n                int ny = point.first + dy[i];\n                int nx = point.second + dx[i];\n                if(nx >= 0 && nx < w && ny >= 0 && ny < h &&\n                   visited[ny][nx] == 0 && p[ny][nx] == org_c) {\n                    que.push(P(ny, nx));\n                }\n            }\n        }\n        ret = max(ret, dfs(count+1));\n        rep(i, 10) rep(j, 10) p[i][j] = org[i][j];\n    }\n    return ret;\n}\n\nint main(void){\n    while(cin >> h >> w >> c && h) {\n        rep(i, h) rep(j, w) cin >> p[i][j];\n        cout << dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//同じ連結成分を違う色で塗る工程は、bfsでできるが、実装は\n//連結成分を列挙し終えてから新しい色を塗ったほうが、連結成分を列挙中に新しい色を塗っていくよりも断然楽。\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass Input {\npublic:\n\tint h, w, aimColor;\n\tint colors[64];\t//color[i*w + j] = i行j列の色\n\t\n\tbool input(FILE *fp) {\n\t\tfscanf(fp, \"%d%d%d\", &h, &w, &aimColor);\n\t\tif (h == 0) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < h*w; i++) {\n\t\t\tfscanf(fp, \"%d\", colors + i);\n\t\t}\n\t\treturn true;\n\t}\n};\n\n//とにかくそのまま使いたい継承\nclass Solver : public Input {\npublic:\n\tint ans;\n\t\n\tint getScore() {\n\t\tint ret = bfs(colors[0], colors);\n\t\treturn ret;\n\t}\n\tvoid dfs(int dep) {\n\t\tif (dep == 5) {\n\t\t\tif (colors[0] != aimColor) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint res = getScore();\n\t\t\tans = max(res, ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tint copy[64];\n\t\t\tfor (int j = 0; j < h*w; j++) {\n\t\t\t\tcopy[j] = colors[j];\n\t\t\t}\n\t\t\t\n\t\t\tbfs(i, colors);\n\t\t\tdfs(dep+1);\n\t\t\t\n\t\t\tfor (int j = 0; j < h*w; j++) {\n\t\t\t\tcolors[j] = copy[j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//戻り値は左上マスを含む連結成分の大きさ\n\tint bfs(int color, int *dst) {\t\t\n\t\tqueue<int> que;\n\t\tbool done[64] = {false};\n\t\t\n\t\t//dst[0]と同じ連結成分を抽出\n\t\tque.push(0);\n\t\twhile(!que.empty() ) {\n\t\t\tint v = que.front();\n\t\t\tque.pop();\n\t\t\tif (done[v])\n\t\t\t\tcontinue;\n\t\t\tdone[v] = true;\n\t\t\t\n\t\t\tint dy[4] = {-1, 0, 1, 0};\n\t\t\tint dx[4] = {0, 1, 0, -1};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint y = dy[i] + (v/w);\n\t\t\t\tint x = dx[i] + (v%w);\n\t\t\t\tif (0 <= y && y < h && 0 <= x && x < w && dst[y*w + x] == dst[0] && !done[y*w + x]) {\n\t\t\t\t\tque.push(y*w + x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//その連結成分の全マスをcolorにする\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < h*w; i++) {\n\t\t\tif (done[i]) {\n\t\t\t\tdst[i] = color;\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint solve() {\n\t\tans = 0;\n\t\tdfs(0);\n\t\treturn ans;\n\t}\n}solver;\n\nsigned main() {\n\twhile (solver.input(stdin) ) {\n\t\tint res = solver.solve();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std ;\n\nint h,w,c ;\nint table[10][10] = {} ;\nint dxy[] = {0,-1,0,1,0} ;\n\nint MAX( int a , int b ){ return ( (a>b) ? a : b ) ; }\n\nint cnt_search( int P[][10] , int nx , int ny , int color ){\n\tint ans = 1 ;\n\tP[ny][nx] = 0 ;\n\tfor( int i=0 ; i<4 ; i++ ){\n\t\tif( color == P[ny+dxy[i]][nx+dxy[i+1]] ){\n\t\t\tans += cnt_search( P , nx+dxy[i+1] , ny+dxy[i] , color ) ;\n\t\t}\n\t}\n\treturn ans ;\n}\n\nint search( int P[][10] ){\n\tint ans = 0 , z ;\n\tfor( int i=1 ; i<=h ; i++ ){\n\t\tfor( int j=1 ; j<=w ; j++ ){\n\t\t\tif( P[i][j] = c ){\n\t\t\t\tans = MAX( ans , cnt_search( P , j , i , c ) ) ;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans ;\n}\n\nvoid copy( int x[][10] , int p[][10] ){\n\tfor( int i=0 ; i<=h+1 ; i++ )\n\t\tfor( int j=0 ; j<=w+1 ; j++ )\n\t\t\tx[i][j] = p[i][j] ;\n}\n\nvoid change( int P[][10] , int nx , int ny , int P_color , int C_color ){\n\tP[ny][nx] = C_color ;\n\tfor( int i=0 ; i<4 ; i++ ){\n\t\tif( P_color == P[ny+dxy[i]][nx+dxy[i+1]] ){\n\t\t\tchange( P , nx+dxy[i+1] , ny+dxy[i] , P_color , C_color ) ;\n\t\t}\n\t}\n}\n\nint func( int P[][10] , int cnt ){\n\tint tmp[10][10] , ans = 0 ;\n\tcopy( tmp , P ) ;\n\t/*\n\tchar d ;\n\tfor( int i=0 ; i<=h+1 ; i++ ){\n\t\tfor( int j=0 ; j<=w+1 ; j++ ){\n\t\t\tcout << \" \" << P[i][j] ;\n\t\t}\n\t\tcout << endl ;\n\t}cin >> d ;*/\n\t\n\tif( cnt == 5 ) ans = search( P ) ;\n\telse {\n\t\tfor( int i=1 ; i<=6 ; i++ ){\n\t\t\tif( P[1][1] != i ){\n\t\t\t\tchange( P , 1 , 1 , P[1][1] , i ) ;\n\t\t\t\tans = MAX( ans , func( P , cnt+1 ) ) ;\n\t\t\t\tcopy( P , tmp ) ;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans ;\n}\n\nmain(){\n\t\n\twhile( cin >> h >> w >> c , h ){\n\t\tfor( int i=0 ; i<=h+1 ; i++ ){\n\t\t\tfor( int j=0 ; j<=w+1 ; j++ ){\n\t\t\t\tif( !i || !j || i==h+1 || j==w+1 ) table[i][j] = 0 ;\n\t\t\t\telse cin >> table[i][j] ;\n\t\t\t}\n\t\t}\n\t\tcout << func( table , 0 ) << endl ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef pair<int, int> P;\n#define REP(i,n) for(int i = 0; i < (int)n; ++i)\n#define REP2(i,n) for(i = 0; i < (int)n; ++i)\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nint count_board(const vector<vector<int> >& board) {\n    vector<vector<char> > vis(board.size(), vector<char>(board.begin()->size(), 0));\n    const int color = board[0][0];\n    int res = 1;\n    queue<P> Q;\n    Q.push(P(0, 0));\n    vis[0][0] = 1;\n    const int dx[4] = { 1, 0, -1, 0 };\n    const int dy[4] = { 0, 1, 0, -1 };\n    while(!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        for(int i = 0; i < 4; i++) {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            if(0 <= ny && ny < (int)board.size() && 0 <= nx && nx < (int)board.begin()->size() && board[ny][nx] == color && vis[ny][nx] == 0) {\n                vis[ny][nx] = 1;\n                res++;\n                Q.push(P(ny, nx));\n            }\n        }\n    }\n    return res;\n}\n\nvoid fill_board(const int c, vector<vector<int> >& board) {\n    vector<vector<char> > vis(board.size(), vector<char>(board.begin()->size(), 0));\n    const int old = board[0][0];\n    queue<P> Q;\n    Q.push(P(0, 0));\n    board[0][0] = c;\n    vis[0][0] = 1;\n    const int dx[4] = { 1, 0, -1, 0 };\n    const int dy[4] = { 0, 1, 0, -1 };\n    while(!Q.empty()) {\n        P p = Q.front(); Q.pop();\n        for(int i = 0; i < 4; i++) {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            if(0 <= ny && ny < (int)board.size() && 0 <= nx && nx < (int)board.begin()->size() && board[ny][nx] == old && vis[ny][nx] == 0) {\n                vis[ny][nx] = 1;\n                board[ny][nx] = c;\n                Q.push(P(ny, nx));\n            }\n        }\n    }\n}\n\nvoid trace_board(const vector<vector<int> >& board) {\n    for(int i = 0; i < (int)board.size(); i++) {\n        for(int j = 0; j < (int)board[i].size(); j++) {\n            cerr << board[i][j] << \" \\n\"[j == board[i].size() - 1];\n        }\n    }\n}\n\nint main() {\n    for(int H, W, C; cin >> H >> W >> C, H; ) {\n        C--;\n        vector<vector<int> > orig(H, vector<int>(W));\n        REP(i,H) REP(j,W) {\n            cin >> orig[i][j];\n            orig[i][j]--;\n        }\n        int res = 0;\n#if 1\n        int cs[4];\n        REP2(cs[0], 6) REP2(cs[1], 6) REP2(cs[2], 6) REP2(cs[3], 6) {\n            vector<vector<int> > board = orig;\n            fill_board(cs[0], board);\n            // DEBUG(cs[0]);\n            // trace_board(board);\n            fill_board(cs[1], board);\n            fill_board(cs[2], board);\n            fill_board(cs[3], board);\n            fill_board(C, board);\n            res = max(res, count_board(board));\n        }\n#endif\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint panel[6][8][8];\nint h,w,c;\nint counting;\nint maximum;\nint ans;\n\nvoid roll(int num,int x,int y,int a){\n\tint dx[]={0,0,-1,1};\n\tint dy[]={-1,1,0,0};\n\n\tint b=panel[num][y][x];\n\tpanel[num][y][x]=a;\n\tif(a==0) counting++;\n\tfor(int i=0;i<4;i++){\n\t\tint nextx=x+dx[i];\n\t\tint nexty=y+dy[i];\n\t\tif(nextx>=0&&nextx<w&&nexty>=0&&nexty<h&&panel[num][nexty][nextx]==b)\n\t\t\troll(num,nextx,nexty,a);\n\t}\n}\n/*\nint change(int num){\n\tint i,j;\n\n\tcout<<\"colored times=\"<<num<<endl;\n\n\tif(num==4){\n\t\troll(num+1,0,0,c);\n\t\tcounting=0;\n\t\troll(num+1,0,0,0);\n\n\t\treturn counting;\n\t}else{\n\n\t\tint ii,jj;\n\t\tfor(ii=0;ii<h;ii++){\n\t\t\tfor(jj=0;jj<w;jj++){\n\t\t\t\tpanel[num+1][ii][jj]=panel[num][ii][jj];\n\t\t\t}\n\t\t}\n\t\tint numsame;\n\t\tfor(i=1;i<7;i++){\n\t\t\tif(panel[num][0][0]!=i){\n\t\t\t\troll(num+1,0,0,i);\n\t\t\t\tcout << i << endl;\n\t\t\t\tfor(ii=0;ii<h;ii++){\n\t\t\t\t\tfor(jj=0;jj<w;jj++){\n\t\t\t\t\t\tcout<<panel[num+1][ii][jj];\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\tfor(ii=0;ii<h;ii++){\n\t\t\t\t\tfor(jj=0;jj<w;jj++){\n\t\t\t\t\t\tpanel[num+1][ii][jj]=panel[num][ii][jj];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumsame=change(num+1);\n\t\t\t\tif(numsame>maximum) maximum=numsame;\n\t\t\t\tcout<<\"numsame=\"<<numsame<<\"\\n max=\"<<maximum<<endl;\n\t\t\t}\n\t\t}\n\t\treturn maximum;\n\t}\n}*/\n\nvoid cpyArray(int num){\n\tfor(int j=0;j<h;j++){\n\t\tfor(int k=0;k<w;k++){\n\t\t\tpanel[num+1][j][k] = panel[num][j][k];\n\t\t}\n\t}\n}\n\nvoid change(int num){\n\tif(num==4){\n\t\tif(panel[num][0][0]==c) return;\n\t\tcpyArray(num);\n\t\troll(num+1,0,0,c);\n\t\tcounting = 0;\n\t\troll(num+1,0,0,0);\n\t\tif(ans<counting){\n\t\t\tans = counting;\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=1;i<7;i++){\n\t\tif(panel[num][0][0]==i)continue;\n\t\tcpyArray(num);\n\t\troll(num+1,0,0,i);\n\t\tchange(num+1);\n\t}\n}\n\nint main(){\n\tint i,j,k;\n\tint numsame;\n\n\twhile(1){\n\t\tcin>>h>>w>>c;\n\t\tif(h==0&&w==0&&c==0)break;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tcin>>panel[0][i][j];\n\t\t\t}\n\t\t}\n\t\tmaximum=1;\n\t\tans = 0;\n\t\tchange(0);\n\n\t\tcout<< ans <<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint H, W;\n\nvector<pair<int,int> > bfs(const int grid[8][8])\n{\n  int dist[8][8];\n  for (int i = 0; i < H; i++) {\n    fill_n(dist[i], W, 0);\n  }\n  dist[0][0] = true;\n  queue<pair<int,int> > q;\n  q.push(make_pair(0, 0));\n  const int color = grid[0][0];\n  vector<pair<int,int> > ans;\n  while (!q.empty()) {\n    ans.push_back(q.front());\n    const int i = q.front().first, j = q.front().second;\n    q.pop();\n    for (int d = 0; d < 4; d++) {\n      static const int di[] = {-1, 1, 0, 0}, dj[] = {0, 0, -1, 1};\n      const int k = i + di[d], l = j + dj[d];\n      if (0 <= k && k < H && 0 <= l && l < W && grid[k][l] == color && !dist[k][l]) {\n        dist[k][l] = true;\n        q.push(make_pair(k, l));\n      }\n    }\n  }\n  return ans;\n}\n\nint dfs(const int grid[8][8], int depth, int C)\n{\n  const vector<pair<int,int> > c = bfs(grid);\n  if (depth == 0) {\n    if (grid[0][0] == C) {\n      return c.size();\n    } else {\n      return 0;\n    }\n  } else {\n    int ans = 0;\n    for (int i = 1; i <= 6; i++) {\n      int g[8][8];\n      for (int j = 0; j < H; j++) {\n        copy(grid[j], grid[j]+W, g[j]);\n      }\n      for (vector<pair<int,int> >::const_iterator it = c.begin(); it != c.end(); ++it) {\n        g[it->first][it->second] = i;\n      }\n      ans = max(ans, dfs(g, depth-1, C));\n    }\n    return ans;\n  }\n}\n\nint main()\n{\n  int C;\n  while (cin >> H >> W >> C && H != 0) {\n    int grid[8][8];\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        cin >> grid[i][j];\n      }\n    }\n    cout << dfs(grid, 5, C) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nvector< vector<bool> > getunion(const vector< vector<int> >& base){\n\tvector< vector<bool> > ret;\n\tstack< pair<int,int> > nxt;\n\tint xmax=base[0].size();\n\tint ymax=base.size();\n\tint tar=base[0][0];\n\tint curx,cury;\n\tret.resize(ymax);\n\tfor(int i=0;i<ymax;i++)ret[i].resize(xmax);\n\tnxt.push(pair<int,int>(0,0));\n\twhile(!nxt.empty()){\n\t\tcurx=nxt.top().first;\n\t\tcury=nxt.top().second;\n\t\tnxt.pop();\n\t\tif(base[cury][curx]==tar&&!ret[cury][curx]){\n\t\t\tret[cury][curx]=true;\n\t\t\tif(curx>0)nxt.push(pair<int,int>(curx-1,cury));\n\t\t\tif(curx<xmax-1)nxt.push(pair<int,int>(curx+1,cury));\n\t\t\tif(cury>0)nxt.push(pair<int,int>(curx,cury-1));\n\t\t\tif(cury<ymax-1)nxt.push(pair<int,int>(curx,cury+1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector< vector<int> >ccolor(const vector< vector<int> >& base,int color){\n\tvector< vector<int> > ret;\n\tvector< vector<bool> > uni=getunion(base);;\n\tint ymax=base.size();\n\tint xmax=base[0].size();\n\tret=base;\n\tfor(int i=0;i<ymax;i++){\n\t\tfor(int j=0;j<xmax;j++){\n\t\t\tif(uni[i][j])ret[i][j]=color;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint score(const vector< vector<int> >& base){\n\tvector< vector<bool> > get=getunion(base);\n\tint ymax=get.size();\n\tint xmax=get[0].size();\n\tint ret=0;\n\tfor(int i=0;i<ymax;i++){\n\t\tfor(int j=0;j<xmax;j++){\n\t\t\tif(get[i][j])ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint cal(const vector< vector<int> >& base,int target,int count){\n\tif(count==1){\n\t\treturn score(ccolor(base,target));\n\t}else{\n\t\tvector< vector<int> > cald;\n\t\tint max=0,get;\n\t\t// 最大色数指定\n\t\tfor(int i=1;i<7;i++){\n\t\t\tif(i!=base[0][0]){\n\t\t\t\tcald=ccolor(base,i);\n\t\t\t\tget=cal(cald,target,count-1);\n\t\t\t\tif(get>max)max=get;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n\nint main(){\n\tint xsize,ysize,target;\n\tvector< vector<int> > base;\n\twhile(true){\n\t\tcin>>xsize>>ysize>>target;\n\t\tif(xsize==0)break;\n\t\tbase.resize(ysize);\n\t\tfor(int i=0;i<ysize;i++){\n\t\t\tbase[i].resize(xsize);\n\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\tcin>>base[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<cal(base,target,5)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define rep2(i, s, n) for(int i=s; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T>\nusing priority_queue_rev = priority_queue<T, vector<T>, greater<T> >;\n\nstatic const int INTINF = (2147483647 >> 1); // 10^9 + 5000\nstatic const ll LLINF = (9223372036854775807 >> 1);\nstatic const int MAX = 1e5+1;\nstatic const ll MOD = 1e9+7;\n\nnamespace Kunitaka{\n    template<\n        typename TYPE,\n        std::size_t SIZE\n    >\n    std::size_t array_length(const TYPE (&array)[SIZE])\n    {\n        return SIZE;\n    }\n\n    template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n    template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n}\nusing namespace Kunitaka;\nnamespace Printer{\n    void br(){\n        cout << endl;\n    }\n\n    void loop_cnt(int i){\n        cout << \"i = \" << i << endl;\n    }\n\n    void loop_cnt(int i, int j){\n        cout << \"i = \" << i << \", \" << \"j = \" << j << endl;\n    }\n\n    template<class T>\n    void print(T x){\n        cout << x << endl;\n    }\n\n    template<class T, class S>\n    void print(T x, S y){\n        cout << x << \",\" << y << endl;\n    }\n\n    template<class T, class S, class U>\n    void print(T x, S y, U z){\n        cout << x << \",\" << y << \",\" << z << endl;\n    }\n\n    template<class T, class S>\n    void print(pair<T, S> p){\n        cout << p.first << \", \" << p.second << endl;\n    }\n\n    template<\n        typename TYPE,\n        std::size_t SIZE\n    >\n    void print(const TYPE (&array)[SIZE]){\n        int lim = array_length(array);\n        for(int i=0; i<lim; i++){\n            if(i) cout << \" \";\n            cout << array[i];\n        }\n        cout << endl;\n    }\n\n    template<class S>\n    void print(vector<S> v){\n        for(int i=0; i<v.size(); i++){\n            if(i) cout << \" \";\n            cout<< v[i];\n        }\n        cout << endl;\n    }\n\n    template<class S>\n    void print(vector<vector<S> > vv){\n        for(int i=0; i<vv.size(); i++){\n            for(int j=0; j<vv[i].size(); j++){\n                if(j) cout << \" \";\n                cout << vv[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    void yesno(bool x){\n        if(x) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n};\nusing namespace Printer;\nint h, w, c;\nint p[10][10];\n\nstruct point{\n    int x, y;\n};\n\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {-1, 1, 0, 0};\n\nll rec(int color){\n    int origin_c = p[0][0];\n    queue<point> q;\n    int used[10][10];\n    memset(used, 0, sizeof(used));\n    used[0][0] = 1;\n    q.push({0, 0});\n    int k = 0;\n    while(!q.empty()){\n        point now = q.front(); q.pop();\n        for(int i=0; i<4; i++){\n            point np = {now.x, now.y};\n            np.x += dx[i];\n            np.y += dy[i];\n            if(np.x < 0 || w <= np.x) continue;\n            if(np.y < 0 || h <= np.y) continue;\n            if(used[np.x][np.y] == 1) continue;\n            used[np.x][np.y] = 1;\n            if(p[np.y][np.x] == origin_c) q.push({np.x, np.y});\n        }\n        p[now.y][now.x] = color;\n        k++;\n    }\n\n    return k;\n}\n\nll calc(string out){\n    ll cnt = 0;\n    out += '0';\n    for(char i : out){\n        int color = i - '0';\n\n        cnt = rec(color);\n    }\n    return cnt;\n}\n\nll make_c(string out){\n    if(out.size() == 4){\n        int cnt = 0;\n        int bef[10][10];\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                bef[i][j] = p[i][j];\n            }\n        }\n        cnt = calc(out + to_string(c));\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                p[i][j] = bef[i][j];\n            }\n        }\n        return cnt;\n    }\n\n    ll res = 0;\n    for(int c=1; c<7; c++){\n        res = max(res, make_c(out + to_string(c)));\n    }\n    return res;\n}\n\nint main(int argc, const char * argv[]) {\n    //提出時、消す----//\n    //--------------//\n\n\n    // input\n    cout << fixed << setprecision(10);\n    while(1){\n        cin >> h >> w >> c;\n        if(!h && !w && !c) break;\n        memset(p, 0, sizeof(p));\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin >> p[i][j];\n            }\n        }\n\n        string tmp = \"\";\n\n        int cnt = make_c(tmp);\n        \n        cout << cnt << endl;\n    }\n\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint h, w, c, Max;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a;\nvoid mark(int x, int y, int b, int c) {\n\ta[x][y] = c;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&a[nx][ny] == b)mark(nx, ny, b, c);\n\t}\n}\nint cnt = 0;\nvoid dfs(int t) {\n\tif (t == 0) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tint d = a[i][j];\n\t\t\tif (d != c)continue;\n\t\t\tmark(i, j, d, 10);\n\t\t\tint cnt = 0;\n\t\t\trep(l, h)rep(k, w)if (a[l][k] == 10)Max = max(Max, ++cnt);\n\t\t\tmark(i, j, 10, d);\n\t\t}\n\t\treturn;\n\t}\n\tvector<vector<int>>b = a;\n\trep(i, 6) {\n\t\tif (a[0][0] == i)continue;\n\t\tmark(0, 0, a[0][0], i);\n\t\tdfs(t - 1); a = b;\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &h, &w, &c), h) {\n\t\ta = vector<vector<int>>(h, vector<int>(w)); c--;\n\t\trep(i, h)rep(j, w)scanf(\"%d\", &a[i][j]), a[i][j]--;\n\t\tMax = 0; dfs(5);\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nvector< vector<bool> > getunion(vector< vector<int> >& base){\n\tvector< vector<bool> > ret;\n\tstack< pair<int,int> > nxt;\n\tint xmax=base[0].size();\n\tint ymax=base.size();\n\tint tar=base[0][0];\n\tint curx,cury;\n\tret.resize(ymax);\n\tfor(int i=0;i<ymax;i++)ret[i].resize(xmax);\n\tnxt.push(pair<int,int>(0,0));\n\twhile(!nxt.empty()){\n\t\tcurx=nxt.top().first;\n\t\tcury=nxt.top().second;\n\t\tnxt.pop();\n\t\tif(base[cury][curx]==tar&&!ret[cury][curx]){\n\t\t\tret[cury][curx]=true;\n\t\t\tif(curx>0)nxt.push(pair<int,int>(curx-1,cury));\n\t\t\tif(curx<xmax-1)nxt.push(pair<int,int>(curx+1,cury));\n\t\t\tif(cury>0)nxt.push(pair<int,int>(curx,cury-1));\n\t\t\tif(cury<ymax-1)nxt.push(pair<int,int>(curx,cury+1));\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector< vector<int> >ccolor(vector< vector<int> >& base,int color){\n\tvector< vector<int> > ret;\n\tvector< vector<bool> > uni=getunion(base);;\n\tint ymax=base.size();\n\tint xmax=base[0].size();\n\tret=base;\n\tfor(int i=0;i<ymax;i++){\n\t\tfor(int j=0;j<xmax;j++){\n\t\t\tif(uni[i][j])ret[i][j]=color;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint score(vector< vector<int> >& base){\n\tvector< vector<bool> > get=getunion(base);\n\tint ymax=get.size();\n\tint xmax=get[0].size();\n\tint ret=0;\n\tfor(int i=0;i<ymax;i++){\n\t\tfor(int j=0;j<xmax;j++){\n\t\t\tif(get[i][j])ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint cal(vector< vector<int> >& base,int target,int count){\n\tif(count==1){\n\t\treturn score(ccolor(base,target));\n\t}else{\n\t\tvector< vector<int> > cald;\n\t\tint max=0,get;\n\t\t// 最大色数指定\n\t\tfor(int i=1;i<7;i++){\n\t\t\tif(i!=base[0][0]){\n\t\t\t\tcald=ccolor(base,i);\n\t\t\t\tget=cal(cald,target,count-1);\n\t\t\t\tif(get>max)max=get;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n\nint main(){\n\tint xsize,ysize,target;\n\tvector< vector<int> > base;\n\twhile(true){\n\t\tcin>>xsize>>ysize>>target;\n\t\tif(xsize==0)break;\n\t\tbase.resize(ysize);\n\t\tfor(int i=0;i<ysize;i++){\n\t\t\tbase[i].resize(xsize);\n\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\tcin>>base[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<cal(base,target,5)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\nint hyou[10][10];\nint H, W, C, ans;\nint D[4] = {1, 0, -1, 0};\nbool used[10][10];\n\nvoid bfs(int c , int (&H3)[10][10]) {\n\tH3[1][1] = 0;\n\trep(i, 10) rep(j, 10) used[i][j] = false;\n\tint px = 1, py = 1;\n\tqueue<pair<int, int>> dq;\n\tdq.push(make_pair(px, py));\n\twhile(!dq.empty()) {\n\t\tpx = dq.front().first;\n\t\tpy = dq.front().second;\n\t\tdq.pop();\n\t\tfor (int i = 0; i < 4 ;i++)  {\n\t\t\tint nx = px + D[i];\n\t\t\tint ny = py + D[3 - i];\n\t\t\tif(used[ny][nx] == 0 and ( H3[ny][nx] == c or H3[ny][nx] == 0)) {\n\t\t\t\tH3[ny][nx] = 0;\n\t\t\t\tdq.push(make_pair(nx, ny));\n\t\t\t\tused[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\t\t\nvoid dfs(int k, int (&H3)[10][10]) {\n\tint H2[10][10] ;\n\trep(i, 10) rep(j, 10) H2[i][j] = H3[i][j];\n\tif (k == 5) {\n\t\tbfs(C, H2);\n\t\tint cnt = 0;\n\t\trep1(i, H) rep1(j , W) {\n\t\t\tif (H2[i][j] == 0){\n\t\t\tcnt += 1;\n\t\t\t}\n\t\t}\n\t\tans = max(cnt, ans);\n\t\treturn;\n\t}\n\trep1(i, 7){\n\t\trep(i, 10) rep(j, 10) H2[i][j] = H3[i][j];\n\t\tbfs(i, H2);\n\t\tdfs(k + 1, H2);\n\t}\n\treturn;\n}\nint main() {\n\twhile(cin >> H >> W >> C, H) {\n\t\tans = 0;\n\t\trep(i, 10) rep(j, 10) hyou[i][j] = -1;\n\t\trep1(i, H) rep1(j,W) cin >> hyou[i][j];\n\t\tbfs(hyou[1][1], hyou);\n\t\tint hyou2[10][10];\n\t\t//rep(i, n) rep(j, n) hyou2[i][j] = hyou[i][j];\n\t\tdfs(1, hyou) ;\n\t\tcout << ans << endl;\n\t}\n}\n\t\t\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<queue>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi = vector<int>;\n\nint f_dir[2][4] = {{-1, 0, 0, 1}, {0, -1, 1, 0}};\nbool is_in_field(int y, int x, int h, int w){\n  return (y >= 0 && y < h && x >= 0 && x < w);\n}\n\nint h, w, c;\nvector<vector<int> > p(8, vector<int>(8));\n\nbool is_sc(int y, int x, vvi& orig){\n  if(!is_in_field(y, x, h, w)) return false;\n  if(orig[0][0] == orig[y][x]) return true;\n  return false;\n}\n\nint color(int n_c, vvi& field){\n  vvi orig = field;\n  queue<pii> q;\n  q.push({0, 0});\n  vvi used(h, vi(w, 0));\n  field[0][0] = n_c;\n  used[0][0] = 1;\n  while(!q.empty()){\n    pii now = q.front(); q.pop();\n    for(int i = 0; i < 4; i++){\n      if(is_sc(now.first+f_dir[0][i], now.second+f_dir[1][i], orig)\n        && !used[now.first+f_dir[0][i]][now.second+f_dir[1][i]]){\n        q.push({now.first+f_dir[0][i], now.second+f_dir[1][i]});\n        field[now.first+f_dir[0][i]][now.second+f_dir[1][i]] = n_c;\n        used[now.first+f_dir[0][i]][now.second+f_dir[1][i]] = 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint cnt(vvi& field){\n  int ret = 0;\n  queue<pii> q;\n  q.push({0, 0});\n  vvi used(h, vi(w, 0));\n  used[0][0] = 1;\n  while(!q.empty()){\n    pii now = q.front(); q.pop();\n    ret++;\n    for(int i = 0; i < 4; i++){\n      if(is_sc(now.first+f_dir[0][i], now.second+f_dir[1][i], field)\n        && !used[now.first+f_dir[0][i]][now.second+f_dir[1][i]]){\n        q.push({now.first+f_dir[0][i], now.second+f_dir[1][i]});\n        used[now.first+f_dir[0][i]][now.second+f_dir[1][i]] = 1;\n      }\n    }\n  }\n  return ret;\n}\n\nint dfs(int k, vvi field){\n  int ret = 0;\n  if(k == 4){\n    color(c, field);\n    return cnt(field);\n  }\n  for(int i = 0; i < 6; i++){\n    vvi tmp_f = field;\n    color(i, tmp_f);\n    ret = max(ret, dfs(k+1, tmp_f));\n  }\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  while(cin >> h >> w >> c && h){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> p[i][j];\n        p[i][j]--;\n      }\n    }\n    c--;\n    cout << dfs(0, p) << endl;\n  }\n\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 8;\nint H, W, C;\nint G[MAX_N][MAX_N];\n\nbool vis[MAX_N][MAX_N];\n\nint dfs(int x, int y, int c) {\n  const static int dx[] = {1,0,-1,0};\n  const static int dy[] = {0,1,0,-1};\n  int res = 1;\n  vis[y][x] = true;\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(G[ny][nx] != c) continue;\n    if(vis[ny][nx]) continue;\n    res += dfs(nx, ny, c);\n  }\n  return res;\n}\n\nint solve() {\n  int g[MAX_N][MAX_N];\n  int res = 1;\n  for(int a = 1; a <= 6; ++a) {\n    for(int b = 1; b <= 6; ++b) {\n      for(int c = 1; c <= 6; ++c) {\n\tfor(int d = 1; d <= 6; ++d) {\n\t  int col[] = {a, b, c, d, C};\n\t  copy(G[0], G[MAX_N], g[0]);\n\t  for(int k = 0; k < 5; ++k) {\n\t    fill(vis[0], vis[MAX_N], false);\n\t    dfs(0, 0, G[0][0]);\n\t    for(int i = 0; i < H; ++i) {\n\t      for(int j = 0; j < W; ++j) {\n\t\tif(vis[i][j]) G[i][j] = col[k];\n\t      }\n\t    }\n\t  }\n\t  fill(vis[0], vis[MAX_N], false);\n\t  res = max(res, dfs(0, 0, G[0][0]));\n\t  copy(g[0], g[MAX_N], G[0]);\n\t}\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  while((cin >> H >> W >> C) && (H || W || C)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint H, W, c, a[9][9], b[9][9], g[6][9][9], v[9][9];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint rec1(int x, int y) {\n\tint ret = 1; v[y][x] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[y][x] == b[ty][tx] && !v[ty][tx]) ret += rec1(tx, ty);\n\t}\n\treturn ret;\n}\nvoid rec(int x, int y, int e) {\n\tint w = b[y][x]; b[y][x] = e;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && b[ty][tx] == w) rec(tx, ty, e);\n\t}\n}\ninline void cpy(int d, int m) {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tswitch (m) {\n\t\t\tcase 0: g[d][i][j] = b[i][j]; break;\n\t\t\tcase 1: b[i][j] = g[d][i][j]; break;\n\t\t\tcase 2: v[i][j] = 0; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint solve(int d) {\n\tint ret = 0; cpy(d, 0);\n\tif (b[0][0] != c) rec(0, 0, c);\n\tcpy(0, 2), ret = rec1(0, 0), cpy(d, 1);\n\tif (d < 4) {\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tif (b[0][0] == i) continue;\n\t\t\tcpy(d, 0), rec(0, 0, i);\n\t\t\tret = max(ret, solve(d + 1)), cpy(d, 1);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &c), H) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &a[i][j]), b[i][j] = a[i][j];\n\t\t}\n\t\tprintf(\"%d\\n\", solve(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[10][10], y[10][10], z[10][10], p[6] = { 1,6,36,216,1296,7776 };\nint a[6], H, W, C, cnt, res; queue<pair<int, int>>Q;\nvoid h(int A, int B, int C) { if (z[A][B] == 0 && y[A][B] == C) { z[A][B] = 1; Q.push(make_pair(A, B)); } }\nint main() {\n\twhile (true) {\n\t\tfor (int j = 0; j < 100; j++) { x[j / 10][j % 10] = -1; }\n\t\tcin >> H >> W >> C; C--; if (H == 0 && W == 0 && C == -1) { break; }res = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j]; x[i][j]--;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < p[5]; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) { a[j] = (i / p[j]) % 6; }a[4] = C;\n\t\t\tfor (int j = 0; j < 100; j++) { y[j / 10][j % 10] = x[j / 10][j % 10]; }\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tQ.push(make_pair(1, 1));\n\t\t\t\tfor (int k = 0; k < 100; k++) { z[k / 10][k % 10] = 0; }z[1][1] = 1;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpair<int, int>a0 = Q.front(); Q.pop(); int a1 = a0.first, a2 = a0.second, a3 = y[a1][a2];\n\t\t\t\t\th(a1 + 1, a2, a3); h(a1 - 1, a2, a3); h(a1, a2 - 1, a3); h(a1, a2 + 1, a3);\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < 100; k++) { if (z[k / 10][k % 10] == 1) { y[k / 10][k % 10] = a[j];} }\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\tQ.push(make_pair(1, 1));\n\t\t\tfor (int k = 0; k < 100; k++) { z[k / 10][k % 10] = 0; }z[1][1] = 1;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tpair<int, int>a0 = Q.front(); Q.pop(); int a1 = a0.first, a2 = a0.second, a3 = y[a1][a2];\n\t\t\t\th(a1 + 1, a2, a3); h(a1 - 1, a2, a3); h(a1, a2 - 1, a3); h(a1, a2 + 1, a3);\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\tfor (int k = 0; k < 100; k++) { if (z[k / 10][k % 10] == 1) { cnt++; } }\n\t\t\tres = max(res, cnt);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\n\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table & state, int from, int to, int x, int y){\n\tif (from==to) return;\n\tREP(i, 4){\n\t\tif(state[y+dy[i]][x+dx[i]] != from) continue;\n\t\tstate[y+dy[i]][x+dx[i]] = to;\n\t\tfillColor(state, from, to, x+dx[i], y+dy[i]);\n\t}\n}\n\nint countColor(Table & state, int x, int y){\n\tint cnt = 0;\n\tREP(i, 4) {\n\t\tif (state[y + dy[i]][x + dx[i]] != g_c) continue;\n\t\tstate[y + dy[i]][x + dx[i]] = -1;\n\t\tcnt += 1 + countColor(state, x + dx[i], y + dy[i]);\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(state, 1, 1);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i, 1, 1);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w;\n\t\tif (h == 0) break;\n\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << recutsion(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint w,h,Col;\ntypedef pair<int,int> C;\ntypedef vector<vector<int> > P;\nP V;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint res;\n\nP temp;\nint tres=0;\n\n\nvoid calc(int y,int x){\n\tif(y<0 || x<0 || x>=w || y>=h) return;\n\tif(temp[y][x]==Col){tres++;temp[y][x]=0;\n\tfor(int r=0;r<4;r++)\n\t\tcalc(y+dy[r],x+dx[r]);\n\t}\n}\n\nvoid on(P N,int count,int c){\n\n\tif(count==5){temp=N;tres=0;calc(0,0);res=max(res,tres);return;}\n\n\tint nc=N[0][0];\n\tqueue<C> Q;\n\tQ.push(make_pair(0,0));\n\tbool used[8][8];\n\tmemset(used,false,sizeof(used));\n\n\tint tres=0;\n\twhile(!Q.empty()){\n\t\tC now=Q.front();\n\t\tQ.pop();\n\t\tif(used[now.first][now.second]) continue;\n\t\tused[now.first][now.second]=true;\n\t\tN[now.first][now.second]=c;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint ny=now.first+dy[r],nx=now.second+dx[r];\n\t\t\tif(ny<0 || nx<0 || ny>=h || nx>=w) continue;\n\t\t\tif(N[ny][nx]==nc)\n\t\t\t\tQ.push(make_pair(ny,nx));\n\t\t}\n\t}\n\n\tif(count!=4)\n\t\tfor(int i=1;i<=6;i++)\n\t\t\t\ton(N,count+1,i);\n\telse on(N,count+1,Col);\n}\n\n\nvoid solve(){\n\tres=0;\n\tV.clear();\n\tV.resize(h);\n\n\tfor(int y=0;y<h;y++)\n\t\tfor(int x=0;x<w;x++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tV[y].push_back(t);\n\t\t}\n\t\n\tfor(int i=1;i<=6;i++){\n\t\tif(V[0][0]!=i)\n\t\t on(V,0,i);\n\t}\n\n\tcout<<res<<endl;\n\n}\n\n\n\nint main()\n{\n\twhile(cin>>h>>w>>Col){\n\t\tif(w==0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint h, w, c, Max;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nvector<vector<int>>a;\nvoid mark(int x, int y, int b, int c) {\n\ta[x][y] = c;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&a[nx][ny] == b)mark(nx, ny, b, c);\n\t}\n}\nint cnt = 0;\nvoid dfs(int t) {\n\tif (t == 0) {\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (a[i][j] != c) {\n\t\t\t\tif (i == 0 && j == 0)mark(0, 0, a[0][0], c);\n\t\t\t\telse continue;\n\t\t\t}\n\t\t\tmark(i, j, c, 10);\n\t\t\tint cnt = 0;\n\t\t\trep(l, h)rep(k, w)if (a[l][k] == 10)Max = max(Max, ++cnt);\n\t\t\tmark(i, j, 10, c);\n\t\t}\n\t\treturn;\n\t}\n\tvector<vector<int>>b = a;\n\trep(i, 6) {\n\t\tif (a[0][0] == i)continue;\n\t\tmark(0, 0, a[0][0], i);\n\t\tdfs(t - 1); a = b;\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d%d\", &h, &w, &c), h) {\n\t\ta = vector<vector<int>>(h, vector<int>(w)); c--;\n\t\trep(i, h)rep(j, w)scanf(\"%d\", &a[i][j]), a[i][j]--;\n\t\tMax = 0; dfs(4);\n\t\tprintf(\"%d\\n\", Max);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <stdlib.h>\nusing namespace std;\n\n\nbool pass(const int h, const int w, pair<int,int> &next) {\n\n  if (next.first < 0 || next.first >= h)\n    return false;\n  if (next.second < 0 || next.second >= w)\n    return false;\n\n  return true;\n}\n\nint search(const int h, const int w, const int c, int **p)\n{\n  queue<pair<int,int> > q;\n  pair<int,int> start = make_pair(0,0);\n  q.push(start);\n  int max = 0;\n  \n  int **tmp;\n  tmp = (int **)malloc(sizeof(int*)*h);\n  for (size_t i = 0; i < h; i++)\n    tmp[i] = (int *)malloc(sizeof(int)*w);\n  for (size_t i = 0; i < h; i++)\n    for (size_t j = 0; j < w; j++)\n      tmp[i][j]  = 0;\n  \n  while (!q.empty()) {\n    pair<int,int> cur = q.front(); q.pop();\n    if (!tmp[cur.first][cur.second]) {\n      tmp[cur.first][cur.second] = 1;\n      max++;\n      int a1[] = { -1, 0, 1, 0 };\n      int a2[] = { 0, 1, 0, -1 };\n      for (size_t i = 0; i < 4; i++) {\n\tpair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\tif (pass(h,w,next))\n\t  if (c == p[next.first][next.second] && tmp[next.first][next.second] != 1) {\n\t    q.push(next);\n\t  }\n      }  \n    }\n  }\n  for (size_t i = 0; i < h; i++)\n    free(tmp[i]);\n  free(tmp);\n\n  return max;\n}\n\n\nint rec(const int h, const int w, const int c, int **p, const int times) {\n  \n  int now, max;\n  max = 0;\n  pair<int,int> start = make_pair(0,0);\n  \n\n  int **tmp;\n  tmp = (int **)malloc(sizeof(int*)*h);\n  for (size_t i = 0; i < h; i++)\n    tmp[i] = (int *)malloc(sizeof(int)*w);\n  \n  if (times < 5) {\n    for (size_t k = 1; k <= 6; k++) {\n      \n      for (size_t i = 0; i < h; i++)\n\tfor (size_t j = 0; j < w; j++)\n\t  tmp[i][j] = p[i][j];\n      \n      int fig = tmp[start.first][start.second];\n      if (fig != k) {\n\ttmp[start.first][start.second] = k;\n\tqueue<pair<int,int> > q;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t  pair<int,int> cur = q.front(); q.pop();\n\t  int a1[] = { -1, 0, 1, 0 };\n\t  int a2[] = { 0, 1, 0, -1 };\n\t  for (size_t i = 0; i < 4; i++) {\n\t    pair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\t    if (pass(h,w,next))\n\t      if (fig == tmp[next.first][next.second]) {\n\t\ttmp[next.first][next.second] = k;\n\t\tq.push(next);\n\t      }\n\t  }\n\t}\n\tnow = rec(h,w,c,tmp,times+1);\n\tif (now > max)\n\t  max = now;\n      }\n    }\n  } else if (times == 5) {\n    for (size_t i = 0; i < h; i++)\n      for(size_t j = 0; j < w; j++)\n\ttmp[i][j] = p[i][j];\n    queue<pair<int,int> > q;\n    q.push(start);\n    int fig = tmp[start.first][start.second];\n    if (fig != c) {\n      tmp[start.first][start.second] = c;\n      while (!q.empty()) {\n\tpair<int,int> cur = q.front(); q.pop();\n\tint a1[] = { -1, 0, 1, 0 };\n\tint a2[] = { 0, 1, 0, -1 };\n\tfor (size_t i = 0; i < 4; i++) {\n\t  pair<int,int> next = make_pair(cur.first+a1[i], cur.second+a2[i]);\n\t  if (pass(h,w,next))\n\t    if (fig == tmp[next.first][next.second]) {\n\t      tmp[next.first][next.second] = c;\n\t      q.push(next);\n\t    }\n\t}\n      }\n      max = search(h,w,c,tmp);\n    } \n  }\n  \n  for (size_t i = 0; i < h; i++)\n    free(tmp[i]);\n  free(tmp);\n  \n  return max;\n}\n\n\n    \nint main(int argc, char *argv[])\n{\n  while (true) {\n  int h, w, c;\n  cin >> h >> w >> c;\n  if (h == 0 && w == 0 && c == 0) break;\n  int **p;\n  p = (int**)malloc(sizeof(int *)*h);\n  for (size_t i = 0; i < h; i++)\n    p[i] = (int*)malloc(sizeof(int)*w);\n  for (size_t i = 0; i < h; i++)\n    for (size_t j = 0; j < w; j++)\n      cin >> p[i][j];\n\n  int max;\n  max = rec(h,w,c,p,1);\n\n  cout << max << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint h, w, c;\nint dy[4] = {-1,0,1,0}, dx[4] = {0,1,0,-1};\n\n\nvoid paint(int t[8][8],int a){ // aは変更する色\n\tint y, x, b, i, j, f[8][8]; // bは元の色\n\tqueue<P> que;\n\tque.push(P(0,0));\n\tb = t[0][0];\n\tt[0][0] = a;\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++)\n\t\t\tf[i][j] = 1;\n\t}\n\tf[0][0] = 0;\n\twhile(que.size()){\n\t\ty = que.front().first, x = que.front().second;\n\t\tque.pop();\n\t\tfor(i = 0;i < 4;i++){\n\t\t\tif(y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < w && t[y + dy[i]][x + dx[i]] == b && f[y + dy[i]][x + dx[i]]){\n\t\t\t\tque.push(P(y + dy[i],x + dx[i]));\n\t\t\t\tt[y + dy[i]][x + dx[i]] = a;\n\t\t\t\tf[y + dy[i]][x + dx[i]] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint countcolor(int t[8][8]){\n\tint a = t[0][0], i, j, ret = 1, f[8][8], y, x; // aは数えるべき色\n\tfor(i = 0;i < h;i++){\n\t\tfor(j = 0;j < w;j++)\n\t\t\tf[i][j] = 1;\n\t}\n\tqueue<P> que;\n\tf[0][0] = 0;\n\tque.push(P(0,0));\n\twhile(que.size()){\n\t\ty = que.front().first, x = que.front().second;\n\t\tque.pop();\n\t\tfor(i = 0;i < 4;i++){\n\t\t\tif(y + dy[i] >= 0 && y + dy[i] < h && x + dx[i] >= 0 && x + dx[i] < w && t[y + dy[i]][x + dx[i]] == a && f[y + dy[i]][x + dx[i]]){\n\t\t\t\tf[y + dy[i]][x + dx[i]] = 0;\n\t\t\t\tret++;\n\t\t\t\tque.push(P(y + dy[i],x + dx[i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint solve(int d,int t[8][8]){\n\tint i, j, k, tt[8][8], ret = 0;\n\tif(d == 4){\n\t\tpaint(t,c);\n\t\treturn countcolor(t);\n\t}\n\telse{\n\t\tfor(i = 1;i <= 6;i++){\n\t\t\tfor(j = 0;j < h;j++){\n\t\t\t\tfor(k = 0;k < w;k++){\n\t\t\t\t\ttt[j][k] = t[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpaint(tt,i);\n\t\t\tret = max(ret,solve(d + 1,tt));\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n\n\nint main(void){\n\tint t[8][8], i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&h,&w,&c);\n\t\tif(h + w + c == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++)\n\t\t\t\tscanf(\"%d\",&t[i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",solve(0,t));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\nconst int dx[4] = {1,-1,1,-1};\nconst int dy[4] = {-1,-1,1,1};\nconst int NUMC = 6;\nint h,w,c;\nvector<vector<int> > mp,tmp_mp,save_mp;\n\nint dfs(int def_i,int def_j,int depth,int col){\n  int num_panel[NUMC] = {};\n  queue<pair<int,int> > que;\n  que.push(make_pair(def_i,def_j));\n  tmp_mp = mp;\n  tmp_mp[def_i][def_j] = col;\n  vector<vector<bool> > is_checked(h,vector<bool>(w,false));\n  int ct = 1;\n  while(!que.empty()){\n    pair<int,int> P = que.front();\n      que.pop();\n      REP(i,4){\n\tint y = P.first + dy[i];\n\tint x = P.second + dx[i];\n\tif(x<0 || y<0 || x>=w || y>=h){continue;}\n\t  if(mp[P.first][P.second] == mp[y][x] && !is_checked[y][x]){\n\t    que.push(make_pair(def_i,def_j));\n\t    is_checked[y][x] = true;\n\t    tmp_mp[y][x] = col;\n\t    ct++;\n\t  }\n      }\n    }\n    save_mp = tmp_mp;\n    if(depth<5){\n        REP(col_i,NUMC){\n            if(depth == 4 && col_i+1 != c || depth == 3 && col_i+1 == c)continue;\n\t    mp = tmp_mp;\n            num_panel[col_i] = dfs(def_i,def_j,depth+1,col_i+1);\n\t    tmp_mp = save_mp;\n        }\n        return *max_element(num_panel,num_panel+NUMC);\n    }else if(depth == 5){\n        return ct;\n    }\n}\n \nint main(){\n    while(cin >> h>>w>>c,h||w||c){\n        mp.resize(h,vector<int>(w));\n        REP(i,h)\n            REP(j,w)cin >> mp[i][j];\n        int ans = 0;\n        REP(i,h){\n            REP(j,w){\n                REP(col_i,NUMC){\n                    ans = max(ans,dfs(i,j,1,col_i+1));\n                }\n            }\n        }\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint h,w,c;\n\nint calc(int map[8][8], int c[6]){\n    bool isConnedted[8][8];\n    fill(isConnedted[0],isConnedted[8],false);\n    typedef pair<int,int> P;\n    queue<P> que;\n    int d[5]={-1,0,1,0,-1};\n    int num;\n    for(int k=0;k<6;k++){\n        que.emplace(0,0);\n        isConnedted[0][0]=true;\n        while(!que.empty()){\n            P p = que.front(); que.pop();\n            for(int i=0;i<4;i++){\n                int y=p.first+d[i];\n                int x=p.second+d[i+1];\n                if(x<0||w<=x) continue;\n                if(y<0||h<=y) continue;\n                if(map[y][x]==map[p.first][p.second]&&!isConnedted[y][x]){\n                    isConnedted[y][x]=true;\n                    que.emplace(y,x);\n                }\n            }\n        }\n        num=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(isConnedted[i][j]){\n                    isConnedted[i][j]=false;\n                    num++;\n                    map[i][j]=c[k];\n                }\n            }\n        }        \n    }\n    return num;\n}\n\nint main(){\n    int p[8][8];\n    while(cin>>h>>w>>c,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>p[i][j];\n            }\n        }\n        int ans=0;\n        int C[6];\n        C[4]=C[5]=c;\n        for(C[0]=1;C[0]<=6;C[0]++){\n            for(C[1]=1;C[1]<=6;C[1]++){\n                for(C[2]=1;C[2]<=6;C[2]++){\n                    for(C[3]=1;C[3]<=6;C[3]++){\n                        int temp[8][8];\n                        for(int i=0;i<h;i++){\n                            for(int j=0;j<w;j++){\n                                temp[i][j]=p[i][j];\n                            }\n                        }\n                        ans=max(ans,calc(temp,C));\n                    }\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define MAX_N 8\n#define MAX_M 8\n#define MAX_C 6\n#define INF 1000000\nusing namespace std;\n\nint N, M, C, ans = 1, nd, flag = 0;\nint field[MAX_N][MAX_M], d[MAX_N][MAX_M], dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nclass Graphs\n{\npublic:\n\tint g[MAX_N][MAX_M];\n\tint sum;\n\tint node;\n\tint intialize(int x[MAX_N][MAX_M]);\n\tint ingrh(int x[MAX_N][MAX_M]);\n\tvoid outgrh();\n\tint outNode();\n};\n\nint Graphs::intialize(int x[MAX_N][MAX_M])\n{\n\tnode = 0;\n\tsum = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tg[i][j] = field[i][j];\n\t\t\tif (g[i][j] == 7) sum++;\n\t\t}\n\t}\n\tif (ans < sum) ans = sum;\n\n\treturn node;\n}\n\nint Graphs::ingrh(int x[MAX_N][MAX_M])\n{\n\tsum = 0;\n\tnode++;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tg[i][j] = x[i][j];\n\t\t\tif (g[i][j] == 7) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans < sum) ans = sum;\n\n\treturn node;\n}\n\nvoid Graphs::outgrh()\n{\n\tfor (int i = 0; i < N; i++) \n\t\tfor (int j = 0; j < M; j++)  field[i][j] = g[i][j];\n}\n\ntypedef Graphs G;\ntypedef pair<int, int> P;\n\nG grh;\nqueue<G> que;\n\nvoid initINF(){\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\td[0][0] = 0; \n}\n\nvoid bfs(int color) {\n\tqueue<P> qg;\n\tqg.push(P(0, 0));\n\tinitINF();\n\twhile(qg.size()) {\n\t\tP p = qg.front();\n\t\tqg.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && (field[nx][ny] == 7 || field[nx][ny] == color) && d[nx][ny] == INF) {\n\t\t\t\tif (field[nx][ny] == color) flag = 1;\n\t\t\t\tqg.push(P(nx, ny));\n\t\t\t\td[nx][ny] = 0;\n\t\t\t\tfield[nx][ny] = 7;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint Graphs::outNode() { return node; }\n\nvoid solve()\n{\n\tint color;\n\tcolor = field[0][0];\n\tfield[0][0] = 7;\n\tbfs(color);\t\n\tgrh.intialize(field);\n\tnd = grh.outNode();\n\tque.push(grh);\n\tfor (int i = 0; nd < 4; i++) {\n\t\tfor (int j = 0; j < MAX_C+1; j++) {\n\t\t\tgrh = que.front();\n\t\t\tgrh.outgrh();\n\t\t\tif (j == C) continue;\n\t\t\tflag = 0;\n\t\t\tbfs(j);\n\t\t\tif (flag == 1) {\n\t\t\t\tgrh.ingrh(field);\n\t\t\t\tque.push(grh);\n\t\t\t}\n\t\t}\n\t\tque.pop();\n\t\tif (que.size()) {\n\t\t\tgrh = que.front();\n\t\t\tnd = grh.outNode();\n\t\t}else break;\n\t}\n\twhile (que.size()) {\n\t\tgrh = que.front();\n\t\tque.pop();\n\t\tgrh.outgrh();\n\t\tbfs(C);\n\t\tgrh.ingrh(field);\n\t}\n}\n\nint main(void)\n{\n\twhile (cin >> N >> M >> C) {\n\t\tif (N == 0) break;\n\t\tans = 1;\n\t\tfor (int i = 0; i < N; i++) \n\t\t\tfor (int j = 0; j < M; j++) cin >> field[i][j];\n\t\tsolve();\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAX_H 10\n#define MAX_W 10\n\nint h, w, c, cnt, ans;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nusing namespace std;\n\nint in_map(int x, int y)\n{\n  return (0 <= x && x < w && 0 <= y && y < h);\n}\n\nvoid connection(vector< vector<int> > &map, int x, int y, int color, int sc)\n{\n  int xx, yy;\n\n  map[y][x] = color;\n\n  for(int i = 0; i < 4; i++)\n    {\n      xx = x + dx[i];\n      yy = y + dy[i];\n      if(in_map(xx, yy) && map[yy][xx] == sc && map[yy][xx] != color)\n\tconnection(map, xx, yy, color, sc);\n     }\n  return ;\n}\n\nvoid count(vector< vector<int> > &map, int x, int y)\n{\n  map[y][x] = -1;\n  int xx, yy;\n  cnt++;\n  for(int i = 0; i < 4; i++)\n    {\n      xx = x + dx[i];\n      yy = y + dy[i];\n      if(in_map(xx, yy) && map[yy][xx] == c)\n\tcount(map, xx, yy);\n    }\n}\n\nvoid dfs(vector< vector<int> > map, int depth)\n{\n  if(depth >= 4)\n    {\n      connection(map, 0, 0, c, map[0][0]);\n      for(int  i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  {\n\t    if(map[i][j] == c)\n\t      {\n\t\tcount(map, j, i);\n\t\tans = (cnt > ans)? cnt: ans;\n\t\tcnt = 0;\n\t      }\n\t  }\n    }\n  else\n    {\n      for(int i = 1; i <= 6; i++)\n\t{\n\t  vector < vector <int> > map_bk = map;\n\t  connection(map_bk, 0, 0, i, map_bk[0][0]);\n\t  dfs(map_bk, depth + 1);\n\t}\n    }\n}\n\nint main(void)\n{\n  vector< vector<int> > map;\n  \n  while(1)\n    {\n      cin >> h;\n      cin >> w;\n      cin >> c;\n\n      if(h == 0 && w == 0)\n\tbreak;\n\n      map.resize(h);\n      for(int i = 0; i < h; i++)\n\tmap[i].resize(w);\n\n      for(int i = 0; i < h; i++)\n\tfor(int j = 0; j < w; j++)\n\t  cin >> map[i][j];\n\n      dfs(map, 0);\n\n      cout << ans << endl;\n\n      ans = 0;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvoid dfs(vector< vector<int> >& p, int c, int x, int y) {\n\tp[y][x] = 0;\n\tint h = p.size(), w = p[0].size();\n\tfor (int k = 0; k < 4; k++) {\n\t\tint _x = x + dx[k], _y = y + dy[k];\n\t\tif (_x >= 0 && _x < w && _y >= 0 && _y < h && p[_y][_x] == c)\n\t\t\tdfs(p, c, _x, _y);\n\t}\n}\n\nint hoge(vector< vector<int> >& p, int c) {\n\tdfs(p, p[0][0], 0, 0);\n\tint h = p.size(), w = p[0].size(), cnt = 0;\n\tfor (int y = 0; y < h; y++)\n\t\tfor (int x = 0; x < w; x++)\n\t\t\tif (p[y][x] == 0) {\n\t\t\t\tp[y][x] = c;\n\t\t\t\tcnt++;\n\t\t\t}\n\treturn cnt;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint h, w, c; cin >> h >> w >> c;\n\t\tif (h == 0) break;\n\t\tvector< vector<int> > p(h, vector<int>(w));\n\t\tfor (int y = 0; y < h; y++)\n\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t\tcin >> p[y][x];\n\t\tint maxi = 0;\n\t\tfor (int z = 0; z < 1296; z++) {\n\t\t\tint _z = z;\n\t\t\tvector< vector<int> > _p = p;\n\t\t\tfor (int t = 0; t < 4; t++) {\n\t\t\t\thoge(_p, 1 + _z % 6);\n\t\t\t\t_z /= 6;\n\t\t\t}\n\t\t\thoge(_p, c);\n\t\t\tmaxi = max(maxi, hoge(_p, 0));\n\t\t}\n\t\tcout << maxi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <memory.h>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n\nFILE * in = freopen(\"input.txt\", \"r\" , stdin);\n\ntypedef unsigned int Color;\n\nstruct Point{\n\tPoint(unsigned int x, unsigned int y) : x(x), y(y){}\n\tunsigned int x;\n\tunsigned int y;\n\tbool operator < (const Point &p) const {\n\t\t//return x < p.x ? true : y < p.y ?  ;\n\t\treturn x == p.x ? y < p.y ? true : false : x < p.x;\n\t}\n};\n\nint surX[] = {0, 1, 0, -1};\nint surY[] = {1, 0, -1, 0};\n\nbool baketuTool(Point point, set<Point> * currentPoints, set<Point> * touchPoints, Color color, vector<vector<Color>> * table){\n\tif((*table)[point.y][point.x] == color){ // onazi color check\n\t\tcurrentPoints->insert(point);\n\t\tfor(unsigned int i=0; i<4; i++){ // sihou check\n\t\t\tunsigned y = point.y + surY[i];\n\t\t\tif(0 > y || y >= table->size()) continue;\n\t\t\tunsigned x = point.x + surX[i];\n\t\t\tif(0 > x || x >= (*table)[y].size()) continue;\n\t\t\tPoint p = Point(x,y);\n\t\t\tif(currentPoints->find(p)==currentPoints->end()){ // iranai\n\t\t\t\tif(baketuTool(p, currentPoints, touchPoints, color, table)){\n\t\t\t\t\ttouchPoints->insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nunsigned int recursion(set<Point> currentPoints, set<Point> touchPoints, map<set<Point>, unsigned int> * caches, vector<vector<Color>> * table, unsigned int count, Color lastColor){\n\tif(count > 5){\n\t\treturn currentPoints.size();\n\t}\n\tunsigned int max_size = 0;\n\tfor(Color color=1;color<=6;color++){\n\t\tif(count == 5 && color != lastColor) continue;\n\t\tauto new_currentPoints = currentPoints;\n\t\tset<Point> new_touchPoints;\n\t\tfor(auto it=touchPoints.begin(); it!=touchPoints.end();it++){\n\t\t\tif(baketuTool(*it, &new_currentPoints, &new_touchPoints, color, table)){\n\t\t\t\tnew_touchPoints.insert(*it);\n\t\t\t}\n\t\t}\n\t\tauto size = recursion(new_currentPoints, new_touchPoints, caches, table, count+1, lastColor);\n\t\tif((*caches)[new_currentPoints] < size){\n\t\t\t(*caches)[new_currentPoints] = size;\n\t\t}\n\t\tmax_size = max(max_size, size);\n\t}\n\treturn max_size;\n}\n\nvoid solution(unsigned int h, unsigned int w, Color c){\n\tmap<set<Point>, unsigned int> caches;\n\n\tvector<vector<Color>> table;\n\tColor p;\n\ttable.push_back(vector<Color>());\n\tfor(unsigned int i = 0; i < h*w; i++){\n\t\tcin >> p;\n\t\tif(table.back().size()==w) table.push_back(vector<Color>());\n\t\ttable.back().push_back(p);\n\t}\n\tunsigned int currentSize = 1;\n\tColor currentColor = table[0][0];\n\tset<Point> currentPoints;\n\tset<Point> touchPoints;\n\t\n\tbaketuTool(Point(0,0), &currentPoints, &touchPoints,  currentColor, &table);\n\n\n\tauto size = recursion(currentPoints, touchPoints, &caches, &table, 1, c);\n\tcout << size << endl;\n}\n\nint main() {\n\tunsigned int h,w,c;\n\twhile(true){\n\t\tcin >> h;\n\t\tcin >> w;\n\t\tcin >> c;\n\t\tif(h==0 && w==0 && c==0) break;\n\t\tsolution(h,w,c);\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint H,W,C;\nint tbl[10][10];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nbool visited[10][10];\n\nvoid paint(int x,int y,int c){\n  visited[y][x]=true;\n  for(int i=0;i<4;++i){\n    int mx = x+dx[i];\n    int my = y+dy[i];\n    if(mx>=W||my>=H||mx<0||my<0) continue;\n    if(visited[my][mx]) continue;\n    if(tbl[my][mx]==tbl[0][0]) paint(mx,my,c);\n  }\n  tbl[y][x]=c;\n}\n\nint calc(int x,int y){\n  visited[y][x]=true;\n  int ret = 1;\n  for(int i=0;i<4;++i){\n    int mx = x+dx[i];\n    int my = y+dy[i];\n    if(mx>=W||my>=H||mx<0||my<0) continue;\n    if(visited[my][mx]) continue;\n    if(tbl[my][mx]==tbl[0][0]) ret+=calc(mx,my);\n  }\n  return ret;\n}\n\nint solve(int depth){\n  if(!depth){\n    /*\n    for(int i=0;i<H;++i){\n      for(int j=0;j<W;++j) cout << tbl[i][j];\n      cout << endl;\n    }\n    cout << endl;\n    */    \n    memset(visited,0,sizeof(visited));\n    return calc(0,0);\n  }\n  int ret = 0;\n  for(int i=1;i<=6;++i){\n    if(depth==1&&i!=C) continue;\n    int tmp[10][10];\n    for(int y=0;y<H;++y) for(int x=0;x<W;++x) tmp[y][x]=tbl[y][x];\n    memset(visited,0,sizeof(visited));\n    paint(0,0,i);\n    ret = max(ret,solve(depth-1));\n    for(int y=0;y<H;++y) for(int x=0;x<W;++x) tbl[y][x]=tmp[y][x];    \n  }\n  return ret;\n}\n\nint main(){\n  while(cin>>H>>W>>C,H||W||C){\n    for(int i=0;i<H;++i)\n      for(int j=0;j<W;++j) cin>>tbl[i][j];\n    cout << solve(5) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint h, w, c;\nint panel[2][8][8];\nint visit[8][8];\nint sq, ans;\n\nvoid bfs(int x, int y, int cl, int pg)\n{\n\tif( x < 0 || x >= w || y < 0 || y >= h || panel[pg][y][x] != cl || visit[y][x] == 1 )\n\t\treturn;\n\telse\n\t{\n\t\tvisit[y][x] = 1;\n\t\tsq++;\n\t\tbfs(x+1, y, cl, pg);\n\t\tbfs(x-1, y, cl, pg);\n\t\tbfs(x, y+1, cl, pg);\n\t\tbfs(x, y-1, cl, pg);\n\t}\n\treturn;\n}\n\nvoid paint(int x, int y, int befc, int aftc, int pg)\n{\n\tif( x < 0 || x >= w || y < 0 || y >= h || panel[pg][y][x] != befc || visit[y][x] == 1 )\n\t\treturn;\n\telse\n\t{\n\t\tvisit[y][x] = 1;\n\t\tpanel[pg][y][x] = aftc;\n\t\tpaint(x+1, y, befc, aftc, pg);\n\t\tpaint(x-1, y, befc, aftc, pg);\n\t\tpaint(x, y+1, befc, aftc, pg);\n\t\tpaint(x, y-1, befc, aftc, pg);\n\t}\n\n\treturn;\n}\n\nvoid setpanel(int pg)\n{\n\t\tfor(int j = 0; j < h; j++ )\n\t\t\tfor(int i = 0; i < w; i++)\n\t\t\t\tpanel[pg][j][i] = panel[pg-1][j][i];\n\n\t\treturn;\n}\n\nint main()\n{\n\tint i,j,k,l,befc;\n\n\twhile( cin >> h >> w >> c, (h||w||c))\n\t{\n\t\tans = 0;\n\n\t\tfor( j = 0; j < h ; j++)\n\t\t\tfor( i = 0; i < w ; i++)\n\t\t\t\tcin >> panel[0][j][i];\n\n\t\tfor( i = 1; i <= 6 ; i++)\n\t\t{\n\t\t\tif(panel[0][0][0] == i)\n\t\t\t\tcontinue;\n\n\t\t\tfor( j = 1; j <= 6; j++ )\n\t\t\t{\n\t\t\t\tif( i == j )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor( k = 1; k <= 6; k++)\n\t\t\t\t{\n\t\t\t\t\tif( j == k )\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfor( l = 1; l <= 6; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif( k == l )\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tsetpanel(1);\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, i, 1);\n\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, j, 1);\n\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, k, 1);\n\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, l, 1);\n\n\t\t\t\t\t\tbefc = panel[1][0][0];\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tpaint( 0, 0, befc, c, 1);\n\n\t\t\t\t\t\tsq = 0;\n\t\t\t\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\t\t\t\tbfs(0, 0, c, 1);\n\t\t\t\t\t\tans = max(sq, ans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\ntypedef pair<int,int> P;\ntypedef pair<int,P>Q;\n#define fi first\ntypedef long long ll;\n#define sc second\n\nint x[10][10],f[10][10],n,m,c;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>c;\n\t\tif(n==0)return 0;\n\t\trep(i,n)rep(j,m) cin>>x[i][j];\n\t\tint ans = 0; c--;\n\t\tfor(int mask=0;mask<6*6*6*6;mask++)\n\t\t{\n\t\t\tvector<int>vec;\n\t\t\tint M = mask;\n\t\t\trep(q,4) {vec.push_back(M%6); M/=6;} vec.push_back(c);\n\t\t\trep(i,n) rep(j,m) f[i][j] = x[i][j]-1;\n\t\t\tfor(int i=0;i<=vec.size();i++){\n\t\t\t\tbool used[10][10] ={};\n\t\t\t\tqueue<P>que; que.push(P(0,0));\n\t\t\t\tint dx[4]={0,0,1,-1};\n\t\t\t\tint dy[4]={1,-1,0,0};\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p = que.front(); que.pop();\n\t\t\t\t\tif(used[p.fi][p.sc] ) continue;\n\t\t\t\t\tused[p.fi][p.sc] = 1;\n\t\t\t\t\trep(k,4){\n\t\t\t\t\t\tint nx = p.fi+dx[k];\n\t\t\t\t\t\tint ny = p.sc+dy[k];\n\t\t\t\t\t\tif(0<=nx&&nx<n&&0<=ny&&ny<m&&f[nx][ny] == f[0][0]){\n\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i == vec.size()){\n\t\t\t\t\tint C =0;\n\t\t\t\t\trep(i,n) rep(j,m) if(used[i][j])C++;\n\t\t\t\t\tans=max(ans,C); break;\n\t\t\t\t}\n\t\t\t\trep(ii,n) rep(j,m){\n\t\t\t\t\tif(used[ii][j]) f[ii][j] = vec[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> P;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint h,w,c;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint area(vvi &v){\n  int res = 0;\n  int color = v[0][0];\n  queue<P> open;\n  bool closed[h][w];\n\n  memset(closed,0,sizeof(closed));\n  open.push(P(0,0));\n\n  while(!open.empty()){\n    P p = open.front(); open.pop();\n    if(closed[p.second][p.first]) continue;\n    closed[p.second][p.first] = true;\n\n    res++;\n\n    rep(i,4){\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n      if(nx>=0 && w>nx && ny>=0 && h>ny && v[ny][nx]==color){\n        open.push(P(nx,ny));\n      }\n    }\n  }\n\n  return res;\n}\n\nvvi draw(vvi v,int nextColor){\n  int firstColor = v[0][0];\n  queue<P> open;\n  bool closed[h][w];\n\n  memset(closed,0,sizeof(closed));\n  open.push(P(0,0));\n\n  while(!open.empty()){\n    P p = open.front(); open.pop();\n    if(closed[p.second][p.first]) continue;\n    closed[p.second][p.first] = true;\n\n    v[p.second][p.first] = nextColor;\n\n    rep(i,4){\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n      if(nx>=0 && w>nx && ny>=0 && h>ny && v[ny][nx]==firstColor){\n        open.push(P(nx,ny));\n      }\n    }\n  }\n\n  return v;\n}\n\nint solve(vvi v,int rem){\n  if(rem == 0){\n    return area(v);\n  }\n\n  int res = 0;\n  REP(i,1,7){\n    if(rem == 1 && i != c) continue;\n    res = max(res,solve(draw(v,i),rem-1));\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>h>>w>>c,h||w||c){\n    vvi v(h);\n    rep(i,h){\n      v[i] = vi(w);\n      rep(j,w) cin>>v[i][j];\n    }\n    cout<<solve(v,5)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(),  (c).end()\n\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nint h, w, c;\nvector<vector<int> > p, vis;\nvector<int> col(6, 0);\n\nbool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nvoid flip(int x, int y, int k){\n    vis[x][y] = 1;\n    rep(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(!inrect(nx, ny) || vis[nx][ny] || p[nx][ny] != p[0][0])continue;\n        flip(nx, ny, k);\n    }\n    p[x][y] = col[k];\n}\n\nint solve(int k){\n    int res = 0;\n    if(k == 6){\n        vector<vector<int> > tmp(all(p));\n        for(int i=k-1; i>=0; --i){\n            vis.assign(h, vector<int>(w, 0));\n            flip(0, 0, i);\n        }\n        rep(i, h)res += count(all(vis[i]), 1);\n        p.swap(tmp);\n    }else{\n        for(int co=1; co<=6; ++co){\n            if(co == col[k-1])continue;\n            col[k] = co;\n            res = max(res, solve(k+1));\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> h >> w >> c, h|w|c){\n        col[0] = col[1] = c;\n        p.assign(h, vector<int>(w, 0));\n        rep(i, h)rep(j, w)cin >> p[i][j];\n        cout << solve(2) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nint h,w,c;\nvector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\nbool isin(int x, int y){\n  bool ans;\n  if(0 <= x and x < h and 0 <= y and y < w) ans = true;\n  else ans = false;\n  return ans;\n}\n\nint changeto(int to,vector<vector<int>> &tmpp){\n  queue<pair<int,int>> q;\n  int from = tmpp[0][0];\n  if(from == to) return 0;\n\n  q.push(pair<int,int>(0,0));\n  tmpp[0][0] = to;\n  int res = 1;\n\n  while(not q.empty()){\n    pair<int,int> p = q.front();\n    q.pop();\n\n    rep(i, dx.size()){\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(isin(nx,ny) and tmpp[nx][ny] == from){\n\tq.push(pair<int,int>(nx, ny));\n\ttmpp[nx][ny] = to;\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint rec(int depth,vector<vector<int>> p){\n  if(depth == 4){\n    changeto(c,p);\n    int res = changeto(-1,p);\n    return res;\n  }\n\n  int res = 0;\n  FOR(i,1,7){\n    vector<vector<int>> tmpp = p;\n    changeto(i,tmpp);\n    res = max(res, rec(depth+1, tmpp));\n  }\n  return res;\n}\n\t      \nint main(void){\n  while(cin >> h >> w >> c, h){\n    vector<vector<int>> p(h,vector<int>(w));\n    rep(i,h) rep(j,w) cin >> p[i][j];\n\n    int res = rec(0,p);\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint h,w,c,cnt;\nint Panel[8][8];\nint P[8][8];\n\nvoid dfs(int y, int x, int color, int precolor){\n  if (color==precolor)\n    return ;\n  P[y][x]=color;\n  for (int i=0;i<4;i++){\n    int mx=x+dx[i];\n    int my=y+dy[i];\n    if (0<=mx && mx<w && 0<=my && my<h && P[my][mx]==precolor)\n      dfs(my,mx,color,precolor);\n  }\n}\n\n\nint panelnum(int y, int x, int color){\n  if (P[y][x]==color){\n    P[y][x]=0;\n    cnt+=1;\n  }else\n    return cnt;\n  for (int i=0;i<4;i++){\n    int mx=x+dx[i];\n    int my=y+dy[i];\n    if (0<=mx && mx<w && 0<=my && my<h && P[my][mx]==color)\n      panelnum(my,mx,color);\n  }\n  return cnt;\n}\n\n\n\nint main(){\n  while (1){\n    scanf(\"%d %d %d\",&h,&w,&c);\n    if (h==0 && w==0 && c==0)\n      return 0;\n    for (int i=0;i<h;i++)\n      for (int j=0;j<w;j++)\n        scanf(\"%d\",&Panel[i][j]);\n    int maxInt=0;\n    for (int i=1;i<7;i++)\n      for (int j=1;j<7;j++)\n        for (int k=1;k<7;k++)\n          for (int l=1;l<7;l++){\n            cnt=0;\n            for (int t=0;t<h;t++)\n              for (int s=0;s<w;s++)\n                P[t][s]=Panel[t][s];\n            dfs(0,0,i,P[0][0]);\n            dfs(0,0,j,P[0][0]);\n            dfs(0,0,k,P[0][0]);\n            dfs(0,0,l,P[0][0]);\n            dfs(0,0,c,P[0][0]);\n            int temp=panelnum(0,0,c);\n            maxInt=std::max(maxInt,temp);\n          }\n    printf(\"%d\\n\",maxInt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector <VI> VVI;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint draw(int h, int w, int c, VVI p, int stage) {\n    //PIIは first=y second = x;\n    PII start = make_pair(0, 0);\n\n    if (stage == 5) {\n        int count = 0;\n        VVI map = p;\n        VVI used(h, VI(w, false));\n\n        queue<PII> Q;\n        Q.push(start);\n\n        while (!Q.empty()) {\n            PII pii = Q.front();\n            Q.pop();\n            if (used[pii.first][pii.second]) continue;\n            if (map[pii.first][pii.second] != c) continue;\n\n            used[pii.first][pii.second] = true;\n            count++;\n\n            REP(j, 4) {\n                PII next = make_pair(dy[j] + pii.first, dx[j] + pii.second);\n                if (next.first >= 0\n                    && next.first < h\n                    && next.second >= 0\n                    && next.second < w) {\n                    Q.push(next);\n                }\n            }\n\n        }\n\n//        if (map[start.first][start.second] == 5) {\n//            bool ok = true;\n//            REP(i, w){\n//                if(map[0][w] != 5){\n//                    ok = false;\n//                }\n//            }\n//            if(ok) {\n//                REP(i, h) {\n//                    REP(j, w) {\n//                        cout << map[i][j];\n//                    }\n//                    cout << endl;\n//                }\n//                cout << endl;\n//            }\n//        }\n\n        return count;\n    }\n\n    int ans = 0;\n\n    for (int i = 1; i <= 6; i++) {\n        VVI map = p;\n        int start_color = map[start.first][start.second];\n\n        if (i == start_color) continue;\n\n        queue<PII> S;\n        S.push(start);\n\n        while (!S.empty()) {\n            PII pii = S.front();\n            S.pop();\n\n            map[pii.first][pii.second] = i;\n\n            REP(j, 4) {\n                PII next = make_pair(dy[j] + pii.first, dx[j] + pii.second);\n                if (next.first >= 0\n                    && next.first < h\n                    && next.second >= 0\n                    && next.second < w\n                    && map[next.first][next.second] == start_color) {\n                    S.push(next);\n                }\n            }\n\n        }\n\n\n        ans = max(draw(h, w, c, map, stage + 1), ans);\n\n    }\n\n    return ans;\n\n}\n\nint main() {\n\n    while (true) {\n        int h, w, c;\n        cin >> h >> w >> c;\n\n        if (h == 0 && w == 0 && c == 0) {\n            break;\n        }\n\n        VVI p(h, VI(w));\n        REP(i, h)REP(j, w) cin >> p[i][j];\n\n        int ans = draw(h, w, c, p, 0);\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <array>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) begin((c)), end((c))\n#define REP(i,n) for(ll i=0;i<(ll)n;++i)\ninline int getInt() { int s; scanf(\"%d\", &s); return s; }\n\n#define SIZE 10\ntypedef array<array<int, SIZE>, SIZE> Table;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint g_c;\n\nvoid fillColor(Table & state, int from, int to, int x, int y){\n\tif (from==to) return;\n\tREP(i, 4){\n\t\tif(state[y+dy[i]][x+dx[i]] != from) continue;\n\t\tstate[y+dy[i]][x+dx[i]] = to;\n\t\tfillColor(state, from, to, x+dx[i], y+dy[i]);\n\t}\n}\n\nint countColor(Table & state, int x, int y){\n\tint cnt = 0;\n\tREP(i, 4) {\n\t\tif (state[y + dy[i]][x + dx[i]] != g_c) continue;\n\t\tstate[y + dy[i]][x + dx[i]] = -1;\n\t\tcnt += 1 + countColor(state, x + dx[i], y + dy[i]);\n\t}\n\treturn cnt;\n}\n\nint recursion(int depth, Table state) {\n\tif (depth > 5) return countColor(ntable, 1, 1);\n\t\n\tint cnt = 1;\n\tREP(i, 6) {\n\t\tif(depth==5 && i != g_c) continue;\n\t\tTable ntable = state;\n\t\tntable[1][1] = i;\n\t\tfillColor(ntable, state[1][1], i, 1, 1);\n\t\tcnt = max(recursion(depth+1, ntable),cnt);\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tll h,w;\n\t\tcin >> h >> w \n\t\tif (h == 0) break;\n\t\t\n\t\tg_c = getInt() - 1;\n\t\tTable table;\n\t\tREP(y, SIZE) REP(x, SIZE) table[y][x] = -1;\n\t\tREP(y, h) REP(x, w) table[y + 1][x + 1] = getInt()-1;\n\t\tcout << walk(1, table) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\n\nint par[110];//親\nint rank2[110];//木の深さ\n\nvoid init(int n){\n  for(int i = 0;i < n;i++){\n    par[i] = i;\n    rank2[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  \n  if(rank2[x] < rank2[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank2[x] == rank2[y])rank2[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n  \n\n\n\n\nint h,w,c;\nint p[12][12];\nint ban[7];\n\nint main(){\n    while(true){\n        cin >> h >> w >> c;\n        if(h + w + c == 0)break;\n        for(int i = 1;i <= h;i++){\n            for(int j = 1;j <= w;j++){\n                cin >> p[i][j];\n            }\n        }\n        for(int j = 0;j <= w+1;j++){\n            p[0][j] = -1;\n            p[h+1][j] = -1;\n        }\n        for(int i = 0;i <= h+1;i++){\n            p[i][0] = -1;\n            p[i][w+1] = -1;\n        }\n        int ans = 0;\n        for(int n = 11111;n <= 66666;n++){\n            int maxban = -1;\n            int div = 1;\n            for(int i = 1;i <= 5;i++){\n                ban[i] = (n / div) % 10;\n                maxban = max(maxban,ban[i]);\n                div *= 10;\n            }\n            if(maxban >= 7)continue;\n            init(80);\n\n            int tmpans = 0;\n            queue<P> que;\n            que.push(P(1,1));\n            tmpans++;\n            while(!que.empty()){\n                P q = que.front(); que.pop();\n                for(int k = 0;k < 4;k++){\n                    int ni = q.fs + dy[k],nj = q.sc + dx[k];\n                    if(p[ni][nj] == p[1][1] && same(1,w*(ni-1)+nj) == false){\n                        tmpans++;\n                        unite(1,w*(ni-1)+nj);\n                        que.push(P(ni,nj));\n                    }\n                }\n            }\n\n            for(int l = 1;l <= 5;l++){\n                for(int i = 1;i <= h;i++){\n                    for(int j = 1;j <= w;j++){\n                        if(same(1,w*(i-1)+j)){\n                            que.push(P(i,j));\n                        }\n                    }\n                }\n                while(!que.empty()){\n                  P q = que.front(); que.pop();\n                  for(int k = 0;k < 4;k++){\n                    int ni = q.fs + dy[k],nj = q.sc + dx[k];\n                    if(p[ni][nj] == ban[l] && same(1,w*(ni-1)+nj) == false){\n                      tmpans++;\n                      unite(1,w*(ni-1)+nj);\n                      que.push(P(ni,nj));\n                    }\n                  }\n                }\n            }\n            if(ban[5] == c){\n              ans = max(ans,tmpans);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint h, w, c;\nint ans, a, counta;\nvector<vector<int>> p;\n\nvector<vector<int>> check(vector<vector<int>> tmp, int i, int j, int color, int nowcolor){\n    tmp[i][j] = color;\n    counta++;\n    if(i != 0){\n        if(tmp[i - 1][j] == nowcolor){\n            tmp = check(tmp, i - 1, j, color, nowcolor);\n        }\n    }\n\n    if(i != h - 1){\n        if(tmp[i + 1][j] == nowcolor){\n            tmp = check(tmp, i + 1, j, color, nowcolor);\n        }\n    }\n\n    if(j != 0){\n        if(tmp[i][j - 1] == nowcolor){\n            tmp = check(tmp, i, j - 1, color, nowcolor);\n        }\n    }\n\n    if(j != w - 1){\n        if(tmp[i][j + 1] == nowcolor){\n            tmp = check(tmp, i, j + 1, color, nowcolor);\n        }\n    }\n\n    return tmp;\n}\n\nvoid dfs(vector<vector<int>> tmp, int times){\n    vector<vector<int>> tmp2;\n    if(times < 4){\n        for(int i = 1; i <= 6; i++){\n            if(i != tmp[0][0]){\n                tmp2 = check(tmp, 0, 0, i, tmp[0][0]);\n                dfs(tmp2, times + 1);\n            }\n        }\n    }else{\n        if(tmp[0][0] != c){\n            tmp2 = check(tmp, 0, 0, c, tmp[0][0]);\n            counta = 0;\n            check(tmp2, 0, 0, 0, tmp2[0][0]);\n            ans = max(ans, counta);\n        }\n    }\n}\n\nint main(){\n    vector<int> tmp;\n    while(true){\n        p.clear();\n        cin >> h >> w >> c;\n        if((h | w | c) == 0) break;\n        for(int i = 0; i < h; i++){\n            tmp.clear();\n            for(int j = 0; j < w; j++){cin >> a; tmp.push_back(a);}\n            p.push_back(tmp);\n        }\n\n        ans = 1;\n        counta = 0;\n        dfs(p, 0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <unordered_set>\n#include <functional>\n#include <complex>\nusing namespace std;\n\nconst auto gcu = getchar_unlocked;\nconst auto pcu = putchar_unlocked;\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n_T _DEF(T,in,int c){T n=0;int m=1;while(isspace(c)){c=gcu();}if(c=='-')m=-1,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n_DEF(int, in){return in<int>(gcu());}\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n_T _SCAN(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_DEF(bool, scan, char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_SCAN(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_OUT(string s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b,m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=n%10*m+'0',n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _OUT(vector<T> v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _OUTL(T&&... t){out(move(t)...);outl();}\nstruct range{\n\tint e,b=0,s=1; range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\tstruct it { int v, s; it (int _v, int _s) : v(_v), s(_s) {} operator int()const{return v;} operator int&(){return v;} int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin() {return {b, s};} it end() {return {e, s};}};\n\ntemplate <typename T>\nusing V = vector<T>;\nusing P = complex<int>;\ninline int x(P o) {return o.real();}\ninline int y(P o) {return o.imag();}\nstruct hash_p {\n\tsize_t operator()(const P &p) const {return (x(p) << 16) + y(p);}\n};\nusing N = vector<unordered_set<P, hash_p>>;\n\nint main() {\n\tfor (int h, w, c; h = in() + 2, w = in() + 2, c = in();) {\n\t\tV<V<int>> p(h, V<int>(w));\n\t\tV<V<bool>> v(h, V<bool>(w));\n\t\tN n(7);\n\t\tconst V<P> rot {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\t\tfor (int y: range(1, h - 1))\n\t\t\tfor (int x: range(1, w - 1))\n\t\t\t\tp[y][x] = in();\n\t\tfor (int i: range(1, max(h, w) - 1)) {\n\t\t\tif (i < h)\n\t\t\t\tv[i][0] = v[i][w - 1] = true;\n\t\t\tif (i < w)\n\t\t\t\tv[0][i] = v[h - 1][i] = true;\n\t\t}\n\t\tfunction<void(P, int, N &)> expand = [&](P a, int c, N &n) {\n\t\t\tn[c].insert(a);\n\t\t\tfor (P i: rot) {\n\t\t\t\tP t{a + i};\n\t\t\t\tif (!v[y(t)][x(t)] && c == p[y(t)][x(t)] && !n[c].count(t))\n\t\t\t\t\texpand(t, c, n);\n\t\t\t}};\n\t\tfunction<int(int, int, int, N)> dfs = [&](int i, int r, int tc, N n) {\n\t\t\tauto l = move(n[tc]);\n\t\t\tfor (auto p: l) {\n\t\t\t\tv[y(p)][x(p)] = true;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tn[tc] = {};\n\t\t\tfor (auto j: l)\n\t\t\t\tfor (P k: rot) {\n\t\t\t\t\tP t{j + k};\n\t\t\t\t\tif (!v[y(t)][x(t)])\n\t\t\t\t\t\texpand(t, p[y(t)][x(t)], n);\n\t\t\t\t}\n\t\t\tif (i == 5)\n\t\t\t\tr += (int) n[c].size();\n\t\t\telse if (!n.empty()) {\n\t\t\t\tint tr = r;\n\t\t\t\tfor (int j: range(1, 7))\n\t\t\t\t\tif (n[j].size())\n\t\t\t\t\t\tr = max(r, dfs(i + 1, tr, j, n));\n\t\t\t}\n\t\t\tfor (auto p: l)\n\t\t\t\tv[y(p)][x(p)] = false;\n\t\t\treturn r;\n\t\t};\n\t\tint tc = p[1][1];\n\t\texpand({1, 1}, tc, n);\n\t\toutl(dfs(1, 0, tc, n));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data{\n    int panel[8][8];\n    bool check[8][8];\n    int count;\n};\n\nint h,w,c;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid DFS(data& d,int x,int y, const int color, const int base_color){\n\n    d.panel[y][x] = color;\n    for(int i=0; i<4; i++){\n        if(x+dx[i] >= 0 && x+dx[i] < w && y+dy[i] >= 0 && y+dy[i] < h){\n            if(!d.check[y+dy[i]][x+dx[i]] && d.panel[y+dy[i]][x+dx[i]] == base_color){\n                d.check[y+dy[i]][x+dx[i]] = true;\n                DFS(d, x+dx[i], y+dy[i], color, base_color);\n            }\n        }\n    }\n\n}\n\nint counter(data& d, int x, int y){\n\n    int ret = 0;\n\n    for(int i=0; i<4; i++){\n        if(x+dx[i] >= 0 && x+dx[i] < w && y+dy[i] >= 0 && y+dy[i] < h){\n            if(d.panel[y+dy[i]][x+dx[i]] == d.panel[0][0]){\n                if(!d.check[y+dy[i]][x+dx[i]]) {\n                    ret++;\n                    d.check[y+dy[i]][x+dx[i]] = true;\n                    ret += counter(d, x + dx[i], y + dy[i]);\n                }\n            }\n        }\n    }\n    return ret;\n\n}\n\nconst int color[6] = {1,2,3,4,5,6};\n\nint main() {\n\n    while(true){\n\n        cin >> h >> w >> c;\n\n        if(h == 0){\n            break;\n        }\n\n        data start;\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin >> start.panel[i][j];\n                start.check[i][j] = false;\n            }\n        }\n\n        start.count = 0;\n\n        queue<data> q;\n\n        q.push(start);\n\n        int ans = 1;\n\n        while(!q.empty()){\n\n            data d = q.front();\n            q.pop();\n\n            data connection;\n\n            for(int i=0; i<6; i++){\n                connection = d;\n                connection.count++;\n                DFS(connection, 0, 0, color[i], d.panel[0][0]);\n                if(connection.count == 5){\n                    if(color[i] == c) {\n                        for(int i=0; i<h; i++){\n                            for(int j=0; j<w; j++){\n                                connection.check[i][j] = false;\n                            }\n                        }\n                        connection.check[0][0] = false;\n                        int count = counter(connection, 0, 0);\n                        ans = max(count, ans);\n                    }\n                    continue;\n                }\n                for(int i=0; i<h; i++){\n                    for(int j=0; j<w; j++){\n                        connection.check[i][j] = false;\n                    }\n                }\n                q.push(connection);\n            }\n\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nint H, W, C;\nchar map[8][8];\n\nvoid changeColor(char (&a)[8][8], int color){\n    int used[8][8];\n    REP(i, 8){\n        REP(j, 8){\n            used[i][j] = 0;\n        }\n    }\n\n    std::queue<P> q;\n    q.push(mp(0, 0));\n\n    char headColor = a[0][0];\n    while(!q.empty()){\n        P p = q.front(); q.pop();\n\n        if(used[p.second][p.first]){continue;}\n        a[p.second][p.first] = color + '0';\n        used[p.second][p.first] = 1;\n        \n        REP(i, 4){\n            int nx = p.first + dx[i], ny = p.second + dy[i];\n            if(0 <= nx && nx < W && 0 <= ny && ny < H && \n               !used[ny][nx] && a[ny][nx] == headColor){\n                q.push(mp(nx, ny));\n            }\n        }\n    }\n}\n\nint count(char (&a)[8][8]){\n    int used[8][8];\n    REP(i, 8){\n        REP(j, 8){\n            used[i][j] = 0;\n        }\n    }\n\n    std::queue<P> q;\n    q.push(mp(0, 0));\n\n    int res = 0;\n    while(!q.empty()){\n        P p = q.front(); q.pop();\n\n        if(used[p.second][p.first]){continue;}\n        res++;\n        used[p.second][p.first] = 1;\n        \n        REP(i, 4){\n            int nx = p.first + dx[i], ny = p.second + dy[i];\n            if(0 <= nx && nx < W && 0 <= ny && ny < H && \n               !used[ny][nx] && a[ny][nx] == a[0][0]){\n                q.push(mp(nx, ny));\n            }\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> H >> W >> C, H){\n        REP(i, H){\n            REP(j, W){\n                std::cin >> map[i][j];\n            }\n        }\n\n        // char _map[8][8];\n        // REP(y, H){\n        //     REP(x, W){\n        //         _map[y][x] = map[y][x];\n        //     }\n        // }\n\n        // changeColor(_map, 6);\n\n        // REP(i, H){\n        //     REP(j, W){\n        //         putchar(_map[i][j]);\n        //     }\n        //     puts(\"\");\n        // }\n        \n        int res = 0;\n        FOR(i, 1, 7){\n            FOR(j, 1, 7){\n                FOR(k, 1, 7){\n                    FOR(l, 1, 7){\n                        char _map[8][8];\n                        REP(y, H){\n                            REP(x, W){\n                                _map[y][x] = map[y][x];\n                            }\n                        }\n\n                        changeColor(_map, i);\n                        changeColor(_map, j);\n                        changeColor(_map, k);\n                        changeColor(_map, l);\n                        changeColor(_map, C);\n\n                        res = std::max(res, count(_map));\n                    }\n                }\n            }\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=(n);i<(int)(N);i++)\n#define ck(n,a,b) ((a)<=(n)&&(n)<(b))\n#define p(s) cout<<(s)<<endl\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint H, W, C, P[10][10];\nint tans = 0, ans = 0;\n\nbool flag[10][10], visited[10][10];\n\nvoid drow(int y, int x, int col){\n\tint precol = P[y][x];\n\tP[y][x] = col;\n\n\tvisited[y][x] = true;\n\n\tREP(k,0,4){\n\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\tif(!ck(ny,0,H) || !ck(nx,0,W)) continue;\n\t\tif(P[ny][nx] == precol && !visited[ny][nx]){\n\t\t\tdrow(ny, nx, col);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid cnt(int y, int x, int col){\n\tif(P[y][x] != col) return;\n\ttans++;\n\tvisited[y][x] = true;\n\tREP(k,0,4){\n\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\tif(!ck(ny,0,H) || !ck(nx,0,W)) continue;\n\t\tif(P[ny][nx] == col && !visited[ny][nx]){\n\t\t\t//p('e');\n\t\t\tcnt(ny, nx, col);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid dfs(int step, int col){\n\n\tif(step == 5){\n\t\ttans = 0;\n\t\tREP(i,0,H)REP(j,0,W) visited[i][j] = false;\n\t\tcnt(0,0,C);\n\t\tans = max(ans, tans);\n\t\treturn;\n\t}\n\n\tREP(i,1,7){\n\t\t//?????¶???????????£????????????\n\t\tint cp[10][10];\n\t\tREP(k,0,H)REP(l,0,W){\n\t\t\tcp[k][l] = P[k][l];\n\t\t}\n\t\tREP(k,0,H) REP(l,0,W) visited[k][l] = false;\n\t\tdrow(0,0,i);\n\t\tdfs(step+1, i);\n\t\t//????????????\n\t\tREP(k,0,H)REP(l,0,W){\n\t\t\tP[k][l] = cp[k][l];\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile(1){\n\t\tcin>>H>>W>>C;\n\t\tif(H==0) break;\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tcin>>P[i][j];\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tdfs(0,C);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; i ++)\n#define FOR(i,a,n) for(int i = a; i < n; i ++)\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nint h,w,final_c;\n\nint di[] = {0,0,-1,1};\nint dj[] = {-1,1,0,0};\n\nVVI change(int col, VVI board){\n  deque<PII> que;\n  que.push_back({0,0});\n  bool checked[h][w];\n  memset(checked,false,sizeof(checked));\n  int col0 = board[0][0];\n\n  // bfs\n  while( ! que.empty()){\n    PII p = que.front(); que.pop_front();\n    int ci = p.first, cj = p.second;\n    board[ci][cj] = col;\n    rep(dir,4){\n      int ni = ci + di[dir];\n      int nj = cj + dj[dir];\n      if(ni >= 0 && nj >= 0 && ni < h && nj < w && checked[ni][nj] == false && board[ni][nj] == col0){\n        checked[ni][nj] = true;\n        que.push_back({ni,nj});\n      }\n    }\n  }\n\n  return board;\n}\n\nint cntBFS(int col, VVI board){\n  deque<PII> que;\n  que.push_back({0,0});\n  bool checked[h][w];\n  memset(checked,false,sizeof(checked));\n  checked[0][0] = true;\n  int cnt = 0;\n  // bfs\n  while( ! que.empty()){\n    PII p = que.front(); que.pop_front();\n    int ci = p.first, cj = p.second;\n    cnt++;\n    rep(dir,4){\n      int ni = ci + di[dir];\n      int nj = cj + dj[dir];\n      if(ni >= 0 && nj >= 0 && ni < h && nj < w && checked[ni][nj] == false && board[ni][nj] == col){\n        checked[ni][nj] = true;\n        que.push_back({ni,nj});\n      }\n    }\n  }\n\n  return cnt;\n}\n\nvoid solve(VVI& board){\n  // 右角と同じパネルに隣接する数が最大の色を発見する。\n  int ans = -1;\n  FOR(a,1,7){\n    VVI board_a = change(a,board);\n    FOR(b,1,7){\n      VVI board_b = change(b,board_a);\n      FOR(c,1,7){\n        VVI board_c = change(c,board_b);\n        FOR(d,1,7){\n          VVI board_d = change(d,board_c);\n          FOR(e,1,7){\n            VVI board_e = change(d,board_d);\n            board_e = change(final_c,board_e);\n            ans = max(cntBFS(final_c,board_e),ans);\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  while(true){\n    cin >> h >> w >> final_c;\n    if(h == 0 && w == 0 && final_c == 0) break;\n    VVI board(h,VI(w));\n    rep(i,h)rep(j,w) cin >> board[i][j];\n    solve(board);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint D(x,y,c,n,M)int *M;{\n\tint r=1;\n\tM[x+(w+2)*y]=n;\n\tif(M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n,M);\n\tif(M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n,M);\n\tif(M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n,M);\n\tif(M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n,M);\n\treturn r;\n}\nint E(d,M)int *M;{\n\tif(d==4){\n\t\tif(M[1+w+2]==c)return;\n\t\tint *m=malloc(400);\n\t\tmemcpy(m,M,400);\n\t\tD(1,1,m[1+w+2],c,m);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t\tfree(m);\n\t\treturn;\n\t}else{\n\tint *m=malloc(400);\n\tint i=1,I,J;\n\tfor(;i<7;i++){\n\t\tif(M[1+w+2]==i)continue;\n\t\t\n\t\tmemcpy(m,M,400);\n\t\tD(1,1,m[1+w+2],i,m);\n\t\tE(d+1,m);\n\t\t\n\t}\n\tfree(m);\n\t}\n}\na[100];\nmain(i,j){\n\tfor(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\t\tmemset(a,0,400);\n\t\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\t\tE(max=0,a);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct{\n  int col;\n  int check;\n} panels;\n\nint max,h,w,c,num;\n\nvoid getmax(panels **panel,int color,int nest,int n);\nvoid change(panels **panel,int color,int i,int j);\nvoid countnum(panels **panel,int i,int j);\n\n\nint main(void){\n  panels **panel;\n  int i,j,colors;\n  while(scanf(\"%d %d %d\",&h,&w,&c) && h && w && c){\n    panel=(panels **)calloc(h,sizeof(panels *));\n    for(i=0;i<h;i++) *(panel+i)=(panels *)calloc(w,sizeof(panels *));\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&colors);\n\t(*(panel+i)+j)->col=colors;\n\t(*(panel+i)+j)->check=0;\n      }\n    }\n    max=0;\n    for(i=0;i<6;i++) getmax(panel,i+1,0,0);\n    printf(\"%d\\n\",max);\n    for(i=0;i<h;i++) free(*(panel+i));\n    free(panel);\n  }\n  return 0;\n}\n\nvoid getmax(panels **panel,int color,int nest,int n){\n  panels **tmp;\n  int i,j,k;\n  if(nest==4 && color!=c) return;\n  tmp=(panels **)calloc(h,sizeof(panels *));\n  for(i=0;i<h;i++) *(tmp+i)=(panels *)calloc(w,sizeof(panels *));\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      (*(tmp+i)+j)->col=(*(panel+i)+j)->col;\n      (*(tmp+i)+j)->check=0;\n    }\n  }\n  change(tmp,color,0,0);\n  num=0;\n  countnum(tmp,0,0);\n  if(max<num) max=num;\n  if(nest==4 || num==n){\n    for(i=0;i<h;i++) free(*(tmp+i));\n    free(tmp);\n    return;\n  }\n  for(i=0;i<6;i++) getmax(tmp,i+1,nest+1,1);\n  for(i=0;i<h;i++) free(*(tmp+i));\n  free(tmp);\n}\n\nvoid change(panels **panel,int color,int i,int j){\n  (*(panel+i)+j)->check=1;\n  if(i>0 && (*(panel+i)+j)->col==(*(panel+i-1)+j)->col && (*(panel+i-1)+j)->check==0) change(panel,color,i-1,j);\n  if(i<h-1 && (*(panel+i)+j)->col==(*(panel+i+1)+j)->col && (*(panel+i+1)+j)->check==0) change(panel,color,i+1,j);\n  if(j>0 && (*(panel+i)+j)->col==(*(panel+i)+j-1)->col && (*(panel+i)+j-1)->check==0) change(panel,color,i,j-1);\n  if(j<w-1 && (*(panel+i)+j)->col==(*(panel+i)+j+1)->col && (*(panel+i)+j+1)->check==0) change(panel,color,i,j+1);\n  (*(panel+i)+j)->col=color;\n}\n\nvoid countnum(panels **panel,int i,int j){\n  (*(panel+i)+j)->check=2;\n  if(i>0 && (*(panel+i)+j)->col==(*(panel+i-1)+j)->col && (*(panel+i-1)+j)->check!=2) countnum(panel,i-1,j);\n  if(i<h-1 && (*(panel+i)+j)->col==(*(panel+i+1)+j)->col && (*(panel+i+1)+j)->check!=2) countnum(panel,i+1,j);\n  if(j>0 && (*(panel+i)+j)->col==(*(panel+i)+j-1)->col && (*(panel+i)+j-1)->check!=2) countnum(panel,i,j-1);\n  if(j<w-1 && (*(panel+i)+j)->col==(*(panel+i)+j+1)->col && (*(panel+i)+j+1)->check!=2) countnum(panel,i,j+1);\n  num++;\n}"
  },
  {
    "language": "C",
    "code": "h,w,c,S,max,C,N;\nint *_M;\nint D(x,y){\n\tint r=1;\n\t_M[x+(w+2)*y]=N;\n\tif(_M[x-1+(w+2)*y]==C)r+=D(x-1,y);\n\tif(_M[x+1+(w+2)*y]==C)r+=D(x+1,y);\n\tif(_M[x+(w+2)*(y-1)]==C)r+=D(x,y-1);\n\tif(_M[x+(w+2)*(y+1)]==C)r+=D(x,y+1);\n\treturn r;\n}\nE(int d,int *M){if(d<4||M[1+w+2]!=c){\n\tint *m=malloc(S);\n\tif(d==4){\n\t\tmemcpy(_M=m,M,S);\n\t\tC=m[1+w+2],N=c;D(1,1);\n\t\tC=m[1+w+2],N=-1;int k=D(1,1);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++)if(M[1+w+2]!=i){\n\t\t\tmemcpy(_M=m,M,S);\n\t\t\tC=m[1+w+2],N=i;D(1,1);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,S=4*(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define max(a,b) (a>b?a:b)\n\nint mv[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\nint ori[10][10];\nint map[10][10];\nint fa[100];\nint color[100];\n\nint x,y,tar;\n\nint find(int now){\n  if(fa[now]==-1)return now;\n  return fa[now] = find(fa[now]);\n}\n\nvoid chkun()\n{\n  int i,j,k;\n  int dx,dy;\n  for(i=0;i<x;i++){\n    for(j=0;j<y;j++){\n      for(k=0;k<4;k++){\n        dx = i + mv[k][0];\n        dy = j + mv[k][1];\n        if(0<=dx && dx<x && 0<=dy && dy<y){\n          if(find(map[dx][dy])!=find(map[i][j]) && color[find(map[dx][dy])]==color[find(map[i][j])]){\n            fa[find(map[dx][dy])] = find(map[i][j]);\n          }\n        }\n      }\n    }\n  }\n}\n\nint dfs(int a,int b, int c, int d, int e){\n\n    int i,j;\n\n    memset(fa,-1,sizeof(fa));\n    int cn = 0;\n    int tem,total;\n\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n\n        tem = ori[i][j];\n        map[i][j] = cn;\n        color[cn] = tem;\n        cn++;\n      }\n    }\n    chkun();\n\n    color[find(map[0][0])] = a;\n    chkun();\n    color[find(map[0][0])] = b;\n    chkun();\n    color[find(map[0][0])] = c;\n    chkun();\n    color[find(map[0][0])] = d;\n    chkun();\n    color[find(map[0][0])] = e;\n    chkun();\n\n    tem = find(map[0][0]);\n    if(color[tem]!=tar)return 0;\n\n    total = 0;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        if(find(map[i][j])==tem)total++;\n      }\n    }\n    return total;\n\n}\n\nint main()\n{\n  int i,j,k,l,m;\n  int ans;\n  while(scanf(\"%d%d%d\",&x,&y,&tar)!=EOF){\n    if(!(x+y+tar))break;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        scanf(\"%d\",&ori[i][j]);\n      }\n    }\n\n    ans = 1;\n    for(i=1;i<=6;i++){\n      for(j=1;j<=6;j++){\n        for(k=1;k<=6;k++){\n          for(l=1;l<=6;l++){\n\n              ans = max(ans,dfs(i,j,k,l,tar));\n\n\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint D(x,y,c,n,M)int *M;{\n\tint r=1;\n\tM[x+(w+2)*y]=n;\n\tif(M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n,M);\n\tif(M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n,M);\n\tif(M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n,M);\n\tif(M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n,M);\n\treturn r;\n}\nE(d,M)int *M;{\n\tif(d==4&&M[1+w+2]==c)return;\n\n\tint *m=malloc(400);\n\tif(d==4){\n\t\tmemcpy(m,M,400);\n\t\tD(1,1,m[1+w+2],c,m);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1,I,J;\n\t\tfor(;i<7;i++){\n\t\t\tif(M[1+w+2]==i)continue;\n\t\t\tmemcpy(m,M,400);\n\t\t\tD(1,1,m[1+w+2],i,m);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}\na[100];\nmain(i,j){\n\tfor(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\t\tmemset(a,0,400);\n\t\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\t\tE(max=0,a);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "h,w,c,S,max;\nint *_M;\nint D(x,y,c,n){\n\tint r=1;\n\t_M[x+(w+2)*y]=n;\n\tif(_M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n);\n\tif(_M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n);\n\tif(_M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n);\n\tif(_M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n);\n\treturn r;\n}\nE(int d,int *M){if(d<4||M[1+w+2]!=c){\n\tint *m=malloc(S);\n\tif(d==4){\n\t\tmemcpy(_M=m,M,S);\n\t\tD(1,1,m[1+w+2],c);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++)if(M[1+w+2]!=i){\n\t\t\tmemcpy(_M=m,M,S);\n\t\t\tD(1,1,m[1+w+2],i,m);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,S=4*(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint h,w,c;\nint map[6][8][8];\nint visited[8][8];\n\nvoid change_color(int stage,int x,int y,int src_color,int dist_color) {\n\tif(x<0 || x>=w || y<0 || y>=h)return;\n\tif(map[stage][y][x]!=src_color || src_color==dist_color)return;\n\tmap[stage][y][x]=dist_color;\n\tchange_color(stage,x-1,y,src_color,dist_color);\n\tchange_color(stage,x+1,y,src_color,dist_color);\n\tchange_color(stage,x,y-1,src_color,dist_color);\n\tchange_color(stage,x,y+1,src_color,dist_color);\n}\n\nint get_color_num(int x,int y,int color) {\n\tint result=1;\n\tif(x<0 || x>=w || y<0 || y>=h)return 0;\n\tif(visited[y][x] || map[5][y][x]!=color)return 0;\n\tvisited[y][x]=1;\n\tresult+=get_color_num(x-1,y,color);\n\tresult+=get_color_num(x+1,y,color);\n\tresult+=get_color_num(x,y-1,color);\n\tresult+=get_color_num(x,y+1,color);\n\treturn result;\n}\n\nint tansaku(int stage,int prev_color) {\n\tint i,j,now_color;\n\tint result=0,now;\n\tfor(now_color=1;now_color<=6;now_color++) {\n\t\tif((stage<5 && prev_color==now_color) ||\n\t\t\t(stage>=5 && now_color!=c))continue;\n\t\tfor(i=0;i<h;i++) {\n\t\t\tfor(j=0;j<w;j++)map[stage][i][j]=map[stage-1][i][j];\n\t\t}\n\t\tchange_color(stage,0,0,map[stage][0][0],now_color);\n\t\tif(stage<5) {\n\t\t\tnow=tansaku(stage+1,now_color);\n\t\t\tif(result<now)result=now;\n\t\t} else {\n\t\t\tmemset(visited,0,sizeof(visited));\n\t\t\tresult=get_color_num(0,0,c);\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d%d\",&h,&w,&c);\n\t\tif(h==0 && w==0 && c==0)break;\n\t\tfor(i=0;i<h;i++) {\n\t\t\tfor(j=0;j<w;j++)scanf(\"%d\",&map[0][i][j]);\n\t\t}\n\t\tprintf(\"%d\\n\",tansaku(1,0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define COLOR_NUM 6\n\n/* パネル配置 */\ntypedef struct panel{\n\tint h;\n\tint w;\n\tint p[8][8];\n} Panel;\n\n/* 変更履歴 */\ntypedef struct change_log{\n\tint x[8*8];\n\tint y[8*8];\n\tint n;\n\tint c;\n} Log;\n\nPanel p;\nint c;\nLog l[6];\nint step;\n\n/* パネルを表示する (デバッグ用) */\nvoid show(){\n\tint i, j;\n\tfor (i = 0; i < p.h; i++){\n\t\tfor (j = 0; j < p.w; j++){\n\t\t\tprintf(\"%d \", p.p[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\n/* 指定した座標のパネルを指定された色 from から to に変える (再帰) */\nint fillr(int x, int y, int from, int to){\n\tint r;\n\tif (x < 0 || x >= p.w || y < 0 || y >= p.h || p.p[y][x] != from) return 0;\n\t/* 変更を記録する */\n\tl[step].x[l[step].n] = x;\n\tl[step].y[l[step].n] = y;\n\tl[step].n++;\n\n\tp.p[y][x] = to;\n\tr = 1;\n\n\t/* 周囲の升も塗りつぶす */\n\tr += fillr(x    , y - 1, from, to);\n\tr += fillr(x    , y + 1, from, to);\n\tr += fillr(x - 1, y    , from, to);\n\tr += fillr(x + 1, y    , from, to);\n\n\treturn r;\n}\n/* 指定した座標のパネルを指定された色で塗りつぶし、塗りつぶしたパネルの数を返す */\nint fill(int x, int y, int c){\n\tint r;\n\tl[step].n = 0;\n\tl[step].c = p.p[y][x];\n\tr = fillr(x, y, p.p[y][x], c);\n\tstep++;\n\treturn r;\n}\n\n/* 色の変更を戻す */\nvoid re(){\n\tint i;\n\tstep--;\n\tfor (i = 0; i < l[step].n; i++){\n\t\tp.p[l[step].y[i]][l[step].x[i]] = l[step].c;\n\t}\n}\n\n/* 指定した座標のパネルの大きさを返す */\nint size(int x, int y){\n\tint r = fill(x, y, 0);\n\tre();\n\treturn r;\n}\n\n/* パネルの色の変え方を探索し得られる最も大きなパネルの大きさを返す */\nint search(int n){\n\tint max = 0, m;\n\tint i;\n\n\t/* 5 回目 */\n\tif (n == 4){\n\t\tfill(0, 0, c);\n\t\tm = size(0, 0);  /* 左上のパネルの大きさを調べる */\n\t\tre();  /* 元に戻す */\n\t\treturn m;\n\t}\n\n\t/* 色の変え方を全通り試す */\n\tfor (i = 1; i <= COLOR_NUM; i++){\n\t\tif (p.p[0][0] == i) continue;  /* 今の色と同じ色に変えても無意味なので試行しない */\n\t\tif (n == 3 && i == c) continue;  /* 5 回目で目標色に必ず変えるので、4 回目では目標色を試行しない */\n\n\t\tfill(0, 0, i);  /* 色を変える */\n\t\tm = search(n + 1);\n\t\tif (m > max) max = m;\n\t\tre();  /* 元に戻す */\n\t}\n\n\treturn max;\n}\n\nint main(void){\n\tint i, j;\n\n\twhile (scanf(\"%d%d%d\", &p.h, &p.w, &c) == 3 && p.h > 0 && p.h <= 8 && p.w > 0 && p.w <= 8 && c > 0 && c <= COLOR_NUM){\n\t\t/* 入力 */\n\t\tfor (i = 0; i < p.h; i++) for (j = 0; j < p.w; j++) scanf(\"%d\", &(p.p[i][j]));\n\t\t/* 初期化 */\n\t\tstep = 0;\n\n\t\tprintf(\"%d\\n\", search(0));\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint D(x,y,c,n,M)int *M;{\n\tint r=1;\n\tM[x+(w+2)*y]=n;\n\tif(M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n,M);\n\tif(M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n,M);\n\tif(M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n,M);\n\tif(M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n,M);\n\treturn r;\n}\nint E(d,M)int *M;{\n\tif(d==4){\n\t\tif(M[1+w+2]==c)return;\n\t\tint *m=malloc(400);\n\t\tmemcpy(m,M,400);\n\t\tD(1,1,m[1+w+2],c,m);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t\tfree(m);\n\t\treturn;\n\t}\n\tint i=1,I,J;\n\tfor(;i<7;i++){\n\t\tif(M[1+w+2]==i)continue;\n\t\tint *m=malloc(400);\n\t\tmemcpy(m,M,400);\n\t\tD(1,1,m[1+w+2],i,m);\n\t\tE(d+1,m);\n\t\tfree(m);\n\t}\n}\na[100];\nmain(i,j){\n\tfor(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\t\tmemset(a,0,400);\n\t\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\t\tE(max=0,a);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define max(a,b) (a>b?a:b)\n\nint mv[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nint ori[10][10];\nint map[10][10];\nint fa[100];\nint color[100];\n\nint x,y,tar;\n\nint find(int now){\n  if(fa[now]==-1)return now;\n  return fa[now] = find(fa[now]);\n}\n\nvoid chkun()\n{\n  int i,j,k;\n  int dx,dy;\n  int ta,tb;\n  for(i=0;i<x;i++){\n    for(j=0;j<y;j++){\n      for(k=0;k<2;k++){\n        dx = i + mv[k][0];\n        dy = j + mv[k][1];\n        if(0<=dx && dx<x && 0<=dy && dy<y){\n          ta = find(map[dx][dy]), tb = find(map[i][j]);\n          if(ta!=tb && color[ta]==color[tb]){\n            fa[ta] = tb;\n          }\n        }\n      }\n    }\n  }\n}\n\nint dfs(int a,int b, int c, int d, int e){\n\n    int i,j;\n\n    memset(fa,-1,sizeof(fa));\n    int cn = 0;\n    int tem,total;\n\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        map[i][j] = cn;\n        color[cn] = ori[i][j];\n        cn++;\n      }\n    }\n    chkun();\n\n    color[find(map[0][0])] = a;\n    chkun();\n    color[find(map[0][0])] = b;\n    chkun();\n    color[find(map[0][0])] = c;\n    chkun();\n    color[find(map[0][0])] = d;\n    chkun();\n    color[find(map[0][0])] = e;\n    chkun();\n\n    tem = find(map[0][0]);\n    if(color[tem]!=tar)return 0;\n\n    total = 0;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        if(find(map[i][j])==tem)total++;\n      }\n    }\n    return total;\n\n}\n\nint main()\n{\n  int i,j,k,l;\n  int ans;\n  while(scanf(\"%d%d%d\",&x,&y,&tar)!=EOF){\n    if(!(x+y+tar))break;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        scanf(\"%d\",&ori[i][j]);\n      }\n    }\n\n    ans = 1;\n    for(i=1;i<=6;i++){\n      for(j=1;j<=6;j++){\n        for(k=1;k<=6;k++){\n          for(l=1;l<=6;l++){\n\n              ans = max(ans,dfs(i,j,k,l,tar));\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint max(int a,int b){\n\tif(b>a)return b;\n\treturn a;\n}\n\nint p[10][10];\nint cp[10][10];\nint flag[10][10];\nint h,w,c;\n\nstruct data{\n\tint x,y;\n};\n\nstruct data que[5000000];\nint f,t;\nvoid push(int xx,int yy){\n\tque[t].x=xx;\n\tque[t].y=yy;\n\tt++;\n}\n\nstruct data pop(){\n\treturn que[f++];\n}\n\nint sx[4]={0,1,0,-1};\nint sy[4]={1,0,-1,0};\nint col[7],res;\n\nint bfs(int cc){\n\tmemset(flag,0,sizeof(flag));\n\tf=0,t=0;\n\tpush(1,1);\n\tflag[1][1]=1;\n\twhile(f!=t){\n\t\tstruct data q=pop();\n\t\tint i;\n\t\tfor(i=0;i<4;i++){\n\t\t\tint nx=sx[i]+q.x,ny=sy[i]+q.y;\n\t\t\tif(flag[nx][ny]==0){\n\t\t\t\tif(cp[q.x][q.y]==cp[nx][ny]){\n\t\t\t\t\tflag[nx][ny]=1;\n\t\t\t\t\tpush(nx,ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tint i,j;\n\tfor(i=1;i<=h;i++){\n\t\tfor(j=1;j<=w;j++){\n\t\t\tif(flag[j][i]==1)cp[j][i]=cc;\n\t\t\tcnt+=flag[j][i];\n\t\t}\n\t}\n\treturn cnt;\n}\nint d[6];\nvoid dfs(int x){\n\tif(x<4){\n\t\tfor(d[x]=1;d[x]<=6;d[x]++){\n\t\t\tcol[x]=d[x];\n\t\t\tdfs(x+1);\n\t\t}\n\t}else{\n\t\tcol[4]=c;\n\t\tint i,j;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcp[j][i]=p[j][i];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<5;i++){\n\t\t\tbfs(col[i]);\n\t\t}\n\t\tres=max(res,bfs(7));\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d\",&h,&w,&c);\n\t\tif(h+w+c==0)break;\n\t\tres=0;\n\t\tmemset(p,0,sizeof(p));\n\t\tint a,b;\n\t\tfor(a=1;a<=h;a++){\n\t\t\tfor(b=1;b<=w;b++){\n\t\t\t\tscanf(\"%d\",&p[b][a]);\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint max(int a,int b){\nif(b>a)return b;\n return a;\n}\n\nint p[10][10];\nint cp[10][10];\nint flag[10][10];\nint h,w,c;\n\nstruct data{\n  int x,y;\n};\n\nstruct data que[5000000];\nint f,t;\nvoid push(int xx,int yy){\n  que[t].x=xx;\n  que[t].y=yy;\n  t++;\n}\n\nstruct data pop(){\n  return que[f++];\n}\n\nint sx[4]={0,1,0,-1};\nint sy[4]={1,0,-1,0};\nint col[7],res;\n\nint bfs(int cc){\n  memset(flag,0,sizeof(flag));\n  f=0,t=0;\n  push(1,1);\n  flag[1][1]=1;\n  while(f!=t){\n    struct data q=pop();\n    int i;\n    for(i=0;i<4;i++){\n      int nx=sx[i]+q.x,ny=sy[i]+q.y;\n      if(flag[nx][ny]==0){\n\tif(cp[q.x][q.y]==cp[nx][ny]){\n\t  flag[nx][ny]=1;\npush(nx,ny);\n\t}\n      }\n    }\n  }\n  int cnt=0;\n  int i,j;\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      if(flag[j][i]==1)cp[j][i]=cc;\n      cnt+=flag[j][i];\n    }\n  }\n  return cnt;\n}\nint d[6];\nvoid dfs(int x){\n  if(x<4){\n    for(d[x]=1;d[x]<=6;d[x]++){\n      col[x]=d[x];\n      dfs(x+1);\n    }\n  }else{\n    col[4]=c;\n    int i,j;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tcp[j][i]=p[j][i];\n      }\n    }\n    for(i=0;i<5;i++){\n      bfs(col[i]);\n }\n    res=max(res,bfs(7));\n  }\n}\n\nint main(void){\n  while(1){\n    scanf(\"%d %d %d\",&h,&w,&c);\n    if(h+w+c==0)break;\n    res=0;\n    memset(p,0,sizeof(p));\n    int a,b;\n    for(a=1;a<=h;a++){\n      for(b=1;b<=w;b++){\n\tscanf(\"%d\",&p[b][a]);\n      }\n    }\n    dfs(0);\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1174: Identically Colored Panels Connection\n// 2017.9.17 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int r, c; } Q;\nQ q[70]; int top, end;\nchar mk[8][8];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nchar map[8][8]; int h, w, color;\nint ans, max;\n\nint count(char p[8][8])\n{\n\tint i, r, c, r2, c2, f;\n\tq[0].r = q[0].c = 0, top = 0, end = 1, memset(mk, 0, sizeof(mk)), mk[0][0] = 1, f = 1;\n\twhile (top < end) {\n\t\tr = q[top].r, c = q[top++].c;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || p[r2][c2] != p[r][c] || mk[r2][c2]) continue;\n\t\t\tmk[r2][c2] = 1, f++, q[end].r = r2, q[end++].c = c2;\n\t\t}\n\t}\n\treturn f;\n}\n\nint combi(int c0, int k, char p[8][8])\n{\n\tint i, j, r, c, r2, c2, m;\n\tchar t[8][8];\n\n\tif (k == 5) return 0;\n\tfor (j = 1; j <= 6; j++) {\n\t\tif (j == c0) continue;\n\t\tmemcpy(t, p, sizeof(t)); t[0][0] = j;\n\t\tq[0].r = q[0].c = 0, top = 0, end = 1, memset(mk, 0, sizeof(mk)), mk[0][0] = 1;\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top++].c;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || t[r2][c2] != c0 || mk[r2][c2]) continue;\n\t\t\t\tmk[r2][c2] = 1, t[r2][c2] = j, q[end].r = r2, q[end++].c = c2;\n\t\t\t}\n\t\t}\n\t\tif (j == color) if ((m = count(t)) > ans) ans = m;\n\t\tif (combi(j, k+1, t)) return 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint a, r, c;\n\n\twhile(scanf(\"%d%d%d\", &h, &w, &color) && h) {\n\t\tfor (max = 0, r = 0; r < h; r++) for (c = 0; c < w; c++)\t{\n\t\t\tscanf(\"%d\", &a), map[r][c] = a; if (a == color) max++;\n\t\t}\n\t\tans = 0; if (map[0][0] == color) ans = count(map);\n\t\tcombi(map[0][0], 0, map);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 200\nint p[6][MAX],stack[6][MAX],indexSTACK[6];\nint h,w,c,max;\n\nvoid STACKpush(int,int);\nvoid colorChange(int,int);\nvoid stackPanelR(int,int);\nvoid stackPanel(int);\nvoid panelR(int);\nint panel();\n\nint main(void){\n  int i;\n  while(1){\n    scanf(\"%d %d %d\",&h,&w,&c);\n    if(h==0&&w==0&&c==0)break;\n    for(i=0;i<h*w;i++)scanf(\"%d\",&p[0][i]);\n    printf(\"%d\\n\",panel());\n  }\n  return 0;\n}\n\nvoid STACKpush(int n,int item){\n  int j;\n  for(j=0;j<indexSTACK[n];j++){\n      if(item==stack[n][j])return;\n    }\n  stack[n][indexSTACK[n]++]=item;\n}\n\nvoid colorChange(int n,int color){\n  int i;\n  for(i=0;i<w*h;i++)p[n+1][i]=p[n][i];\n  for(i=0;i<indexSTACK[n];i++){\n    p[n+1][stack[n][i]]=color;\n  }\n}\nvoid stackPanelR(int n,int point){\n  int i,j,nextX,nextY,next;\n  int x=point%w;int y=point/w;\n  int directionX[4]={-1,0,1,0};//左,上,右,下\n  int directionY[4]={0,-1,0,1};\n  for(i=0;i<4;i++){\n    nextX=x+directionX[i];\n    nextY=y+directionY[i];\n    if(nextX<0 || nextX>=w)continue;\n    if(nextY<0 || nextY>=h)continue;\n    next=nextX+nextY*w;\n    int judge=1;\n    for(j=0;j<indexSTACK[n];j++){\n      if(next==stack[n][j])judge=-1;\n    }\n    if(judge==-1)continue;\n    if(p[n][0]==p[n][next]){\n      STACKpush(n,next);\n      stackPanelR(n,next);\n    }\n  }\n}\nvoid stackPanel(int n){\n  indexSTACK[n]=0;\n  STACKpush(n,0);\n  if(1<w && p[n][0]==p[n][1]){\n    STACKpush(n,1);\n    stackPanelR(n,1);\n  }\n  if(1<h && p[n][0]==p[n][w]){\n    STACKpush(n,w);\n    stackPanelR(n,w);\n  }\n}\n\nvoid panelR(int n){\n  int i;\n  stackPanel(n);\n  if(n==5){\n    if(indexSTACK[n]>max)max=indexSTACK[n];\n    return; \n  }\n  for(i=1;i<=6;i++){\n    if(p[n][0]==i)continue;\n    if(n==4)colorChange(n,c);\n    else{\n      if(n==3&&i==c)continue;\n      colorChange(n,i);\n    }\n    panelR(n+1);\n  }\n}\n\nint panel(){\n  max=0;\n  panelR(0);\n  return max;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct{\n  int col;\n  int check;\n} panels;\n\nint max,h,w,c,num;\n\nvoid getmax(panels **panel,int color,int nest,int n);\nvoid change(panels **panel,int color,int i,int j);\nvoid countnum(panels **panel,int i,int j);\n\n\nint main(void){\n  panels **panel;\n  int i,j,colors;\n  while(scanf(\"%d %d %d\",&h,&w,&c) && h && w && c){\n    panel=(panels **)calloc(h,sizeof(panels *));\n    for(i=0;i<h;i++) *(panel+i)=(panels *)calloc(w,sizeof(panels *));\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&colors);\n\t(*(panel+i)+j)->col=colors;\n\t(*(panel+i)+j)->check=0;\n      }\n    }\n    max=0;\n    for(i=0;i<6;i++) getmax(panel,i+1,0,0);\n    printf(\"%d\\n\",max);\n    for(i=0;i<h;i++) free(*(panel+i));\n    free(panel);\n  }\n  return 0;\n}\n\nvoid getmax(panels **panel,int color,int nest,int n){\n  panels **tmp;\n  int i,j,k;\n  if(nest==4 && color!=c) return;\n  tmp=(panels **)calloc(h,sizeof(panels *));\n  for(i=0;i<h;i++) *(tmp+i)=(panels *)calloc(w,sizeof(panels *));\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      (*(tmp+i)+j)->col=(*(panel+i)+j)->col;\n      (*(tmp+i)+j)->check=0;\n    }\n  }\n  change(tmp,color,0,0);\n  num=0;\n  countnum(tmp,0,0);\n  if(max<num) max=num;\n  if(nest==4 || num==n){\n    for(i=0;i<h;i++) free(*(tmp+i));\n    free(tmp);\n    return;\n  }\n  for(i=0;i<6;i++) getmax(tmp,i+1,nest+1,1);\n  for(i=0;i<h;i++) free(*(tmp+i));\n  free(tmp);\n}\n\nvoid change(panels **panel,int color,int i,int j){\n  (*(panel+i)+j)->check=1;\n  if(i>0 && (*(panel+i)+j)->col==(*(panel+i-1)+j)->col && (*(panel+i-1)+j)->check==0) change(panel,color,i-1,j);\n  if(i<h-1 && (*(panel+i)+j)->col==(*(panel+i+1)+j)->col && (*(panel+i+1)+j)->check==0) change(panel,color,i+1,j);\n  if(j>0 && (*(panel+i)+j)->col==(*(panel+i)+j-1)->col && (*(panel+i)+j-1)->check==0) change(panel,color,i,j-1);\n  if(j<w-1 && (*(panel+i)+j)->col==(*(panel+i)+j+1)->col && (*(panel+i)+j+1)->check==0) change(panel,color,i,j+1);\n  (*(panel+i)+j)->col=color;\n}\n\nvoid countnum(panels **panel,int i,int j){\n  (*(panel+i)+j)->check=2;\n  if(i>0 && (*(panel+i)+j)->col==(*(panel+i-1)+j)->col && (*(panel+i-1)+j)->check!=2) countnum(panel,i-1,j);\n  if(i<h-1 && (*(panel+i)+j)->col==(*(panel+i+1)+j)->col && (*(panel+i+1)+j)->check!=2) countnum(panel,i+1,j);\n  if(j>0 && (*(panel+i)+j)->col==(*(panel+i)+j-1)->col && (*(panel+i)+j-1)->check!=2) countnum(panel,i,j-1);\n  if(j<w-1 && (*(panel+i)+j)->col==(*(panel+i)+j+1)->col && (*(panel+i)+j+1)->check!=2) countnum(panel,i,j+1);\n  num++;\n}"
  },
  {
    "language": "C",
    "code": "h,w,c,S,max,C,N,r;\nint *_M;\nD(x,y){\n\t_M[x+(w+2)*y]=N;\n\tif(_M[x-1+(w+2)*y]==C)r++,D(x-1,y);\n\tif(_M[x+1+(w+2)*y]==C)r++,D(x+1,y);\n\tif(_M[x+(w+2)*(y-1)]==C)r++,D(x,y-1);\n\tif(_M[x+(w+2)*(y+1)]==C)r++,D(x,y+1);\n}\nE(int d,int *M){if(d<4||M[1+w+2]!=c){\n\tint *m=malloc(S);\n\tif(d==4){\n\t\tmemcpy(_M=m,M,S);\n\t\tC=m[1+w+2],N=c;D(1,1);\n\t\tC=c,N=-1,r=1;D(1,1);\n\t\tif(max<r)max=r;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++)if(M[1+w+2]!=i){\n\t\t\tmemcpy(_M=m,M,S);\n\t\t\tC=m[1+w+2],N=i;D(1,1);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,S=4*(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define max(a, b) a<b?b:a\n#define INF 1010001000\n\nint board[10][10];\nint copy[10][10];\nint used[10][10];\nint h, w, c, ans, ret;\n\nvoid init(void);\nvoid clused(void);\nvoid dfs(int color, int x, int y);\nvoid count(int color, int x, int y);\n\nint main(void)\n{\n    int i, j, k, l, m, n;\n    scanf(\"%d%d%d\", &h, &w, &c);\n    while (h) {\n        init();\n        for (i = 0; i < h; i++) {\n            for (j = 0; j < w; j++) {\n                scanf(\"%d\", &board[i][j]);\n                board[i][j]--;\n                copy[i][j] = board[i][j];\n            }\n        }\n        for (i = 0; i < 6; i++) {\n            for (j = 0; j < 6; j++) {\n                for (k = 0; k < 6; k++) {\n                    for (l = 0; l < 6; l++) {\n                        for (n = 0; n <= h; n++) {\n                            for (m = 0; m <= w; m++) {\n                                board[n][m] = copy[n][m];\n                            }\n                        }\n                        dfs(i, 0, 0);\n                        clused();\n\n                        dfs(j, 0, 0);\n                        clused();\n\n                        dfs(k, 0, 0);\n                        clused();\n\n                        dfs(l, 0, 0);\n                        clused();\n\n                        dfs(c-1, 0, 0);\n                        clused();\n\n                        ans = 0;\n                        count(c-1, 0, 0);\n                        clused();\n\n                        ret = max(ret, ans);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", ret);\n        scanf(\"%d%d%d\", &h, &w, &c);\n    }\n    return 0;\n}\n\nvoid count(int color, int x, int y) \n{\n    int i;\n    int dx[4] = {0, -1, 0, 1};\n    int dy[4] = {1, 0, -1, 0};\n    ans++;\n    used[x][y] = 1;\n    for (i = 0; i < 4; i++) {\n        if (0 <= x + dx[i]  && x + dx[i] < h && \n                0 <= dy[i] + y && dy[i] + y < w &&\n                !used[x+dx[i]][y+dy[i]] && \n                board[x+dx[i]][y+dy[i]] == board[x][y]) {\n            count(color, x+dx[i], y+dy[i]);\n        }\n    }\n}\n\nvoid dfs(int color, int x, int y)\n{\n    int i;\n    int dx[4] = {0, -1, 0, 1};\n    int dy[4] = {1, 0, -1, 0};\n    used[x][y] = 1;\n    for (i = 0; i < 4; i++) {\n        if (0 <= x + dx[i]  && x + dx[i] < h && \n                0 <= dy[i] + y && dy[i] + y < w &&\n                !used[x+dx[i]][y+dy[i]] && \n                board[x+dx[i]][y+dy[i]] == board[x][y]) {\n            dfs(color, x+dx[i], y+dy[i]);\n        }\n    }\n    board[x][y] = color;\n}\n\nvoid init(void)\n{\n    int i, j;\n    for (i = 0; i <= h; i++) {\n        for (j = 0; j <= w; j++) {\n            board[i][j] = INF;\n            used[i][j] = 0;\n        }\n    }\n    ret = 0;\n    ans = 0;\n}\n\nvoid clused(void)\n{\n    int i, j;\n    for (i = 0; i <= h; i++) {\n        for (j = 0; j <= w; j++) {\n            used[i][j] = 0;\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\n#define max(a,b) (a>b?a:b)\n\nint mv[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\nint ori[10][10];\nint map[10][10];\nint fa[100];\nint color[100];\n\nint x,y,tar;\n\nint find(int now){\n  if(fa[now]==-1)return now;\n  return fa[now] = find(fa[now]);\n}\n\nvoid chkun()\n{\n  int i,j,k;\n  int dx,dy;\n  for(i=0;i<x;i++){\n    for(j=0;j<y;j++){\n      for(k=0;k<4;k++){\n        dx = i + mv[k][0];\n        dy = j + mv[k][1];\n        if(0<=dx && dx<x && 0<=dy && dy<y){\n          if(find(map[dx][dy])!=find(map[i][j]) && color[find(map[dx][dy])]==color[find(map[i][j])]){\n            fa[find(map[dx][dy])] = find(map[i][j]);\n          }\n        }\n      }\n    }\n  }\n}\n\nint dfs(int a,int b, int c, int d, int e){\n\n    int i,j;\n\n    memset(fa,-1,sizeof(fa));\n    int cn = 0;\n    int tem,total;\n\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n\n        tem = ori[i][j];\n        map[i][j] = cn;\n        color[cn] = tem;\n        cn++;\n      }\n    }\n    chkun();\n\n    color[find(map[0][0])] = a;\n    chkun();\n    color[find(map[0][0])] = b;\n    chkun();\n    color[find(map[0][0])] = c;\n    chkun();\n    color[find(map[0][0])] = d;\n    chkun();\n    color[find(map[0][0])] = e;\n    chkun();\n\n    tem = find(map[0][0]);\n    if(color[tem]!=tar)return 0;\n\n    total = 0;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        if(find(map[i][j])==tem)total++;\n      }\n    }\n    return total;\n\n}\n\nint main()\n{\n  int i,j,k,l,m;\n  int ans;\n  while(scanf(\"%d%d%d\",&x,&y,&tar)!=EOF){\n    if(!(x+y+tar))break;\n    for(i=0;i<x;i++){\n      for(j=0;j<y;j++){\n        scanf(\"%d\",&ori[i][j]);\n      }\n    }\n\n    ans = 1;\n    for(i=1;i<=6;i++){\n      for(j=1;j<=6;j++){\n        for(k=1;k<=6;k++){\n          for(l=1;l<=6;l++){\n            for(m=1;m<=6;m++){\n              ans = max(ans,dfs(i,j,k,l,m));\n\n            }\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define repl(i,a,b) for(i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define max(x,y) x>y?x:y\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n\ntypedef int bool;\n\n#define true 1\n#define false 0\n\nint dd[]={-1,0,1,0,-1};\n\nint h,w,c;\nint p[11][11];\n\nbool visc[11][11];\nint cnt;\n\nvoid cntc(int i,int j,int cc){\n\tvisc[i][j]=true;\n\tcnt++;\n\tint d;\n\trep(d,4){\n\t\tint ni=i+dd[d],nj=j+dd[d+1];\n\t\tif(ni>=0&&ni<h&&nj>=0&&nj<w&&p[ni][nj]==cc&&!visc[ni][nj])cntc(ni,nj,cc);\n\t}\n}\n\nvoid change(int i,int j,int mc,int cc){\n\tp[i][j]=cc;\n\tvisc[i][j]=true;\n\tint d;\n\trep(d,4){\n\t\tint ni=i+dd[d],nj=j+dd[d+1];\n\t\tif(ni>=0&&ni<h&&nj>=0&&nj<w&&p[ni][nj]==mc&&!visc[ni][nj])change(ni,nj,mc,cc);\n\t}\n}\n\nint dfs(int d){\n\tif(d==5){\n\t\tcnt=0;\n\t\tmemset(visc,0,sizeof(visc));\n\t\tcntc(0,0,c);\n\t\treturn cnt;\n\t}else{\n\t\tint res=0;\n\t\tint sav[11][11];\n\t\tmemcpy(sav,p,sizeof(p));\n\t\tif(d==4){\n\t\t\tmemset(visc,0,sizeof(visc));\n\t\t\tchange(0,0,p[0][0],c);\n\t\t\tmaxch(res,dfs(d+1));\n\t\t}else{\n\t\t\tint i;\n\t\t\trepl(i,1,6+1){\n\t\t\t\tmemset(visc,0,sizeof(visc));\n\t\t\t\tchange(0,0,p[0][0],i);\n\t\t\t\tmaxch(res,dfs(d+1));\n\t\t\t\tmemcpy(p,sav,sizeof(sav));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&h,&w,&c);\n\t\tif(h==0)break;\n\t\tint i,j;\n\t\trep(i,h)rep(j,w)scanf(\"%d\",&p[i][j]);\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define rep(i,n) for(int i=0;i<(int)n;++i)\nint max(const int a, const int b) {\n  return a > b ? a : b ;\n}\n\nint H, W, C;\nint base[10][10];\nint copy[10][10], visit[10][10];\nconst int di[] = {1, -1, 0, 0};\nconst int dj[] = {0, 0, -1, 1};\n\nvoid rec(int base_color, int color, int i, int j) {\n  // printf(\">>%2d %2d %2d %2d\\n\", base_color, color, i, j);\n  if (visit[i][j]) return;\n  visit[i][j] = 1;\n  rep(z,4) {\n    int ni = i+di[z], nj = j+dj[z];\n    if (ni < 0 || nj < 0 || H <= ni || W <= nj) continue;\n    if (visit[ni][nj] || (base_color != copy[ni][nj])) continue;\n    if (color == copy[ni][nj]) continue;\n    copy[ni][nj] = color;\n    rec(base_color, color, ni, nj);\n  }\n}\n\nvoid update(int color) {\n  // memset(visit, 0, sizeof (visit));\n  rep(i,H) rep(j,W) visit[i][j] = 0;\n  int prev_color = copy[0][0];\n  copy[0][0] = color;\n  rec(prev_color, color, 0, 0);\n}\n\nvoid debug() {\n  rep(h,H) {\n    rep(w,W) printf(\"%2d\", copy[h][w]);\n    puts(\"\");\n  }\n}\n\nint t_ans = 0;\n\n\nvoid calc_rec(int i, int j) {\n  if (visit[i][j]) return;\n  t_ans++;\n  visit[i][j] = 1;\n  rep(z,4) {\n    int ni = i+di[z], nj = j+dj[z];\n    if (ni < 0 || nj < 0 || H <= ni || W <= nj) continue;\n    if (visit[ni][nj] || copy[ni][nj] != copy[i][j]) continue;\n    calc_rec(ni, nj);\n  }\n}\n\nint calc() {\n  memset(visit, 0, sizeof (visit));\n  t_ans = 0;\n  calc_rec(0, 0);\n  return t_ans;\n}\n\nint solve() {\n  int ans = 0;\n  rep(i,6) rep(j,6) rep(k,6) rep(l,6) {\n    if (i==j || j==k || k==l || l+1==C)\n      continue;\n    rep(h,H) rep(w,W) copy[h][w] = base[h][w];\n    int ch[5] = {i+1, j+1, k+1, l+1, C};\n    rep(z,5) {\n      update(ch[z]);\n      /* if (ch[0] == 6 && ch[1] == 3 && ch[2] == 4 && */\n      /*     ch[3] == 2 && ch[4] == 5) { */\n      /*   puts(\"\"); */\n      /*   debug(); */\n      /* } */\n    }\n    ans = max(ans,calc());\n  }\n  return ans;\n}\n\nint main() {\n  while(scanf(\"%d%d%d\", &H, &W, &C), H|W) {\n    rep(i,H) rep(j,W) scanf(\"%d\", base[i]+j);\n    printf(\"%d\\n\",solve());\n  }\n}"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint *_M;\nint D(x,y,c,n){\n\tint r=1;\n\t_M[x+(w+2)*y]=n;\n\tif(_M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n);\n\tif(_M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n);\n\tif(_M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n);\n\tif(_M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n);\n\treturn r;\n}\nE(d,M)int *M;{\n\tif(d==4&&M[1+w+2]==c)return;\n\tint *m=malloc(4*(w+2)*(h+2));\n\tif(d==4){\n\t\tmemcpy(m,M,4*(w+2)*(h+2));_M=m;\n\t\tD(1,1,m[1+w+2],c);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++){\n\t\t\tif(M[1+w+2]==i)continue;\n\t\t\tmemcpy(m,M,4*(w+2)*(h+2));_M=m;\n\t\t\tD(1,1,m[1+w+2],i,m);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,4*(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint *_M;\nint D(x,y,c,n){\n\tint r=1;\n\t_M[x+(w+2)*y]=n;\n\tif(_M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n);\n\tif(_M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n);\n\tif(_M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n);\n\tif(_M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n);\n\treturn r;\n}\nE(d,M)int *M;{\n\tif(d==4&&M[1+w+2]==c)return;\n\tint *m=malloc(400);_M=m;\n\tif(d==4){\n\t\tmemcpy(m,M,400);\n\t\tD(1,1,m[1+w+2],c);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++){\n\t\t\tif(M[1+w+2]==i)continue;\n\t\t\tmemcpy(m,M,400);\n\t\t\tD(1,1,m[1+w+2],i,m);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,400);\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct{\n  int col;\n  int check;\n} panels;\n\nint max,h,w,c,num;\n\nvoid getmax(panels **panel,int color,int nest,int n);\nvoid change(panels **panel,int color,int i,int j);\nvoid countnum(panels **panel,int i,int j);\n\n\nint main(void){\n  panels **panel;\n  int i,j,colors;\n  while(scanf(\"%d %d %d\",&h,&w,&c) && h && w && c){\n    panel=(panels **)calloc(h,sizeof(panels *));\n    for(i=0;i<h;i++) *(panel+i)=(panels *)calloc(w,sizeof(panels *));\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&colors);\n\t(*(panel+i)+j)->col=colors;\n\t(*(panel+i)+j)->check=0;\n      }\n    }\n    max=0;\n    for(i=0;i<6;i++) getmax(panel,i+1,0,0);\n    printf(\"%d\\n\",max);\n    for(i=0;i<h;i++) free(*(panel+i));\n    free(panel);\n  }\n  return 0;\n}\n\nvoid getmax(panels **panel,int color,int nest,int n){\n  panels **tmp;\n  int i,j,k;\n  if(nest==4 && color!=c) return;\n  tmp=(panels **)calloc(h,sizeof(panels *));\n  for(i=0;i<h;i++) *(tmp+i)=(panels *)calloc(w,sizeof(panels *));\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      (*(tmp+i)+j)->col=(*(panel+i)+j)->col;\n      (*(tmp+i)+j)->check=0;\n    }\n  }\n  change(tmp,color,0,0);\n  num=0;\n  countnum(tmp,0,0);\n  if(max<num) max=num;\n  if(nest==4 || num==n){\n    for(i=0;i<h;i++) free(*(tmp+i));\n    free(tmp);\n    return;\n  }\n  for(i=0;i<6;i++) getmax(tmp,i+1,nest+1,1);\n  for(i=0;i<h;i++) free(*(tmp+i));\n  free(tmp);\n}\n\nvoid change(panels **panel,int color,int i,int j){\n  (*(panel+i)+j)->check=1;\n  if(i>0 && (*(panel+i)+j)->col==(*(panel+i-1)+j)->col && (*(panel+i-1)+j)->check==0) change(panel,color,i-1,j);\n  if(i<h-1 && (*(panel+i)+j)->col==(*(panel+i+1)+j)->col && (*(panel+i+1)+j)->check==0) change(panel,color,i+1,j);\n  if(j>0 && (*(panel+i)+j)->col==(*(panel+i)+j-1)->col && (*(panel+i)+j-1)->check==0) change(panel,color,i,j-1);\n  if(j<w-1 && (*(panel+i)+j)->col==(*(panel+i)+j+1)->col && (*(panel+i)+j+1)->check==0) change(panel,color,i,j+1);\n  (*(panel+i)+j)->col=color;\n}\n\nvoid countnum(panels **panel,int i,int j){\n  (*(panel+i)+j)->check=2;\n  if(i>0 && (*(panel+i)+j)->col==(*(panel+i-1)+j)->col && (*(panel+i-1)+j)->check!=2) countnum(panel,i-1,j);\n  if(i<h-1 && (*(panel+i)+j)->col==(*(panel+i+1)+j)->col && (*(panel+i+1)+j)->check!=2) countnum(panel,i+1,j);\n  if(j>0 && (*(panel+i)+j)->col==(*(panel+i)+j-1)->col && (*(panel+i)+j-1)->check!=2) countnum(panel,i,j-1);\n  if(j<w-1 && (*(panel+i)+j)->col==(*(panel+i)+j+1)->col && (*(panel+i)+j+1)->check!=2) countnum(panel,i,j+1);\n  num++;\n}"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint *_M;\nint D(x,y,c,n){\n\tint r=1;\n\t_M[x+(w+2)*y]=n;\n\tif(_M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n);\n\tif(_M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n);\n\tif(_M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n);\n\tif(_M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n);\n\treturn r;\n}\nE(d,M)int *M;{\n\tif(d==4&&M[1+w+2]==c)return;\n\tint *m=malloc(400);_M=m;\n\tif(d==4){\n\t\tmemcpy(m,M,400);\n\t\tD(1,1,m[1+w+2],c);\n\t\tint k=D(1,1,m[1+w+2],-1);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++){\n\t\t\tif(M[1+w+2]==i)continue;\n\t\t\tmemcpy(m,M,400);\n\t\t\tD(1,1,m[1+w+2],i);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,400);\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "#include <stdbool.h>\n#include <stdio.h>\n\nint h, w, c;\nint memo[10][10] = {0};\nbool added[10][10] = {0};\nint stack[105][2] = {0};\nint d[] = {1, 0, -1, 0};\nint scnt;\n\nvoid dfs(int col);\nint solve(int now, int bf);\nint max(int x, int y) { return x > y ? x : y; }\n\nint main() {\n  int i, j;\n  while(1) {\n    scanf(\"%d %d %d\", &h, &w, &c);\n    if(h + w + c == 0) break;\n    scnt = 1;\n    for(i = 0; i < h; ++i)\n      for(j = 0; j < w; ++j) added[i][j] = 0;\n    for(i = 0; i < h; ++i)\n      for(j = 0; j < w; ++j) scanf(\"%d\", &memo[i][j]);\n    stack[0][0] = stack[0][1] = 0;\n    added[0][0] = 1;\n    dfs(memo[0][0]);\n    printf(\"%d\\n\", solve(0, memo[0][0]));\n  }\n  return 0;\n}\n\nvoid dfs(int col) {\n  int i, j;\n  for(i = 0; i < scnt; ++i) {\n    int x = stack[i][0], y = stack[i][1];\n    for(j = 0; j < 4; ++j) {\n      int nx = x + d[j], ny = y + d[1 ^ j];\n      if(nx >= 0 && nx < h && ny >= 0 && ny < w &&\n         (!added[nx][ny]) && memo[nx][ny] == col) {\n        added[nx][ny] = 1;\n        stack[scnt][0] = nx;\n        stack[scnt][1] = ny;\n        ++scnt;\n      }\n    }\n  }\n}\n\nint solve(int now, int bf) {\n  if(now == 5) return scnt;\n  int i, j, ans = scnt, nscnt = scnt;\n  for(i = 1; i <= 6; ++i) {\n    scnt = nscnt;\n    if(bf == i || (now == 4 && i != c)) continue;\n    dfs(i);\n    ans = max(solve(now + 1, i), ans);\n    for(j = scnt - 1; j >= nscnt; --j) {\n      int x = stack[j][0], y = stack[j][1];\n      added[x][y] = 0;\n      --scnt;\n    }\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint map[6][8][8];\nint h, w, c;\nint max_count;\nint visited[8][8];\n\n#define fors(i, n) for (int i = 0; i < n; i++)\n#define clean_visited fors(i, h) fors(j, w) visited[i][j] = 0\n#define when_visited fors(i, h) fors(j, w) if (visited[i][j] == 1)\n\nint parse()\n{\n    scanf(\"%d %d %d\", &h, &w, &c);\n    if (h == 0)\n        return 0;\n    fors(i, h) fors(j, w) scanf(\"%d\", &map[0][i][j]);\n    max_count = 0;\n    return 1;\n}\n\nint dfs_fillVisited(int depth, int x, int y)\n{\n    visited[y][x] = 1;\n    if (x + 1 < w && map[depth][y][x + 1] == map[depth][y][x] && visited[y][x + 1] != 1)\n        dfs_fillVisited(depth, x + 1, y);\n    if (y + 1 < h && map[depth][y + 1][x] == map[depth][y][x] && visited[y + 1][x] != 1)\n        dfs_fillVisited(depth, x, y + 1);\n    if (x > 0 && map[depth][y][x - 1] == map[depth][y][x] && visited[y][x - 1] != 1)\n        dfs_fillVisited(depth, x - 1, y);\n    if (y > 0 && map[depth][y - 1][x] == map[depth][y][x] && visited[y - 1][x] != 1)\n        dfs_fillVisited(depth, x, y - 1);\n}\n\nint dfs(int depth, int flip)\n{\n    if (depth < 5)\n    {\n        fors(i, h) fors(j, w) map[depth + 1][i][j] = map[depth][i][j];\n        clean_visited;\n        dfs_fillVisited(depth, 0, 0);\n        when_visited\n        {\n            map[depth + 1][i][j] = flip;\n        }\n        fors(i, 6)\n        {\n            dfs(depth + 1, i + 1);\n        }\n    }\n    else\n    {\n        if (map[depth][0][0] != c)\n            return 0;\n        clean_visited;\n        dfs_fillVisited(depth, 0, 0);\n        int count = 0;\n        when_visited\n        {\n            count++;\n        }\n        if (count > max_count)\n            max_count = count;\n    }\n}\nint main()\n{\n    while (parse())\n    {\n        fors(i, 6)\n        {\n            dfs(0, i + 1);\n        }\n        printf(\"%d\\n\", max_count);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define maxN 10\n\nvoid dfs(int time, int color, int bfr[maxN][maxN]);\nint changeColor(int bfr[maxN][maxN], int panel[maxN][maxN], int color, int x, int y);\n\nint h, w, c, max;\nint vx[] = {1,0,-1,0};\nint vy[] = {0,1,0,-1};\n\nint main(){\n\tint i, j;\n\n\twhile(1){\n\t\tint panel[maxN][maxN];\n\n\t\tscanf(\"%d %d %d\", &h, &w, &c);\n\t\tif(h==0&&w==0&&c==0) break;\n\n\t\tfor(i=1; i<=h; i++){\n\t\t\tfor(j=1; j<=w; j++){\n\t\t\t\tscanf(\"%d\", &panel[i][j]);\n\t\t\t}\n\t\t}\n\t\tdfs(1, panel[1][1], panel);\n\t\tprintf(\"%d\\n\", max);\n\n\t\tmax = 0;\n\t}\n\n\treturn 0;\n}\n\nvoid dfs(int time, int color, int bfr[maxN][maxN]){\n\tint panel[maxN][maxN];\n\tint i, j, cnt = 0;\n\n\tfor(i=0; i<maxN; i++){\n\t\tfor(j=0; j<maxN; j++){\n\t\t\tpanel[i][j] = bfr[i][j];\n\t\t}\n\t}\n\n\tif(time<4){\n\t\tfor(i=1; i<=6; i++){\n\t\t\tif(i==color) continue;\n\t\t\tcnt = changeColor(bfr, panel, i, 1, 1);\n\t\t\tdfs(time+1, i, panel);\n\t\t}\n\t}else if(time==4){\n\t\tcnt = changeColor(bfr, panel, c, 1, 1);\n\t\tif(max<cnt) max = cnt;\n\t}\n}\n\nint changeColor(int bfr[maxN][maxN], int panel[maxN][maxN], int color, int x, int y){\n\tint i, cnt = 0;\n\tpanel[y][x] = color;\n\tcnt++;\n\tfor(i=0; i<4; i++){\n\t\tif(bfr[y+vy[i]][x+vx[i]]==bfr[y][x] && bfr[y+vy[i]][x+vx[i]]!=color){\n\t\t\tcnt += changeColor(bfr, panel, color, x+vx[i], y+vy[i]);\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct{\n  int col;\n  int check;\n} panels;\n\nint max,h,w,c,num;\n\nvoid getmax(panels **panel,int color,int nest,int n);\nvoid change(panels **panel,int color,int i,int j);\nvoid countnum(panels **panel,int i,int j);\n\n\nint main(void){\n  panels **panel;\n  int i,j,colors;\n  while(scanf(\"%d %d %d\",&h,&w,&c) && h && w && c){\n    panel=(panels **)calloc(h,sizeof(panels *));\n    for(i=0;i<h;i++) *(panel+i)=(panels *)calloc(w,sizeof(panels *));\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%d\",&colors);\n\t(*(panel+i)+j)->col=colors;\n\t(*(panel+i)+j)->check=0;\n      }\n    }\n    max=0;\n    for(i=0;i<6;i++) getmax(panel,i+1,0,0);\n    printf(\"%d\\n\",max);\n    for(i=0;i<h;i++) free(*(panel+i));\n    free(panel);\n  }\n  return 0;\n}\n\nvoid getmax(panels **panel,int color,int nest,int n){\n  panels **tmp;\n  int i,j,k;\n  if(nest==4 && color!=c) return;\n  tmp=(panels **)calloc(h,sizeof(panels *));\n  for(i=0;i<h;i++) *(tmp+i)=(panels *)calloc(w,sizeof(panels *));\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      (*(tmp+i)+j)->col=(*(panel+i)+j)->col;\n      (*(tmp+i)+j)->check=0;\n    }\n  }\n  change(tmp,color,0,0);\n  num=0;\n  countnum(tmp,0,0);\n  if(max<num) max=num;\n  if(nest==4 || num==n){\n    for(i=0;i<h;i++) free(*(tmp+i));\n    free(tmp);\n    return;\n  }\n  for(i=0;i<6;i++) getmax(tmp,i+1,nest+1,1);\n  for(i=0;i<h;i++) free(*(tmp+i));\n  free(tmp);\n}\n\nvoid change(panels **panel,int color,int i,int j){\n  (*(panel+i)+j)->check=1;\n  if(i>0 && (*(panel+i)+j)->col==(*(panel+i-1)+j)->col && (*(panel+i-1)+j)->check==0) change(panel,color,i-1,j);\n  if(i<h-1 && (*(panel+i)+j)->col==(*(panel+i+1)+j)->col && (*(panel+i+1)+j)->check==0) change(panel,color,i+1,j);\n  if(j>0 && (*(panel+i)+j)->col==(*(panel+i)+j-1)->col && (*(panel+i)+j-1)->check==0) change(panel,color,i,j-1);\n  if(j<w-1 && (*(panel+i)+j)->col==(*(panel+i)+j+1)->col && (*(panel+i)+j+1)->check==0) change(panel,color,i,j+1);\n  (*(panel+i)+j)->col=color;\n}\n\nvoid countnum(panels **panel,int i,int j){\n  (*(panel+i)+j)->check=2;\n  if(i>0 && (*(panel+i)+j)->col==(*(panel+i-1)+j)->col && (*(panel+i-1)+j)->check!=2) countnum(panel,i-1,j);\n  if(i<h-1 && (*(panel+i)+j)->col==(*(panel+i+1)+j)->col && (*(panel+i+1)+j)->check!=2) countnum(panel,i+1,j);\n  if(j>0 && (*(panel+i)+j)->col==(*(panel+i)+j-1)->col && (*(panel+i)+j-1)->check!=2) countnum(panel,i,j-1);\n  if(j<w-1 && (*(panel+i)+j)->col==(*(panel+i)+j+1)->col && (*(panel+i)+j+1)->check!=2) countnum(panel,i,j+1);\n  num++;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint P[8][8],H,W,C,i,j,mv[5]={0,-1,0,1,0};\n\nint ch(int p[8][8],int h,int w,int c,int nc)\n{\n\tint i,nh,nw,res=0;\n\tif(nc==-1)res++;\n\tif(p[h][w]==c)\n\t{\n\t\tp[h][w]=nc;\n\t\tfor(i=0;i<4;i++)\n\t\t{\n\t\t\tnh=h+mv[i],nw=w+mv[i+1];\n\t\t\tif(0<=nh&&0<=nw&&nh<H&&nw<W&&p[nh][nw]==c)\n\t\t\t{\n\t\t\t\tres+=ch(p,nh,nw,c,nc);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint dfs(int p[8][8],int c,int d)\n{\n\tint t[8][8],res=0,i,tm;\n\tif(d==5)\n\t{\n\t\tif(p[0][0]==C)\n\t\t\treturn ch(p,0,0,p[0][0],-1);\n\t\treturn 0;\n\t}\n\tfor(i=1;i<7;i++)\n\t{\n\t\tif(p[0][0]==i)continue;\n\t\tmemcpy(t,p,sizeof(t));\n\t\tch(t,0,0,t[0][0],i);\n\t\ttm=dfs(t,i,d+1);\n\t\tres=res<tm?tm:res;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d\",&H,&W,&C),W;)\n\t{\n\t\tint res=0,t;\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<W;j++)\n\t\t\t\tscanf(\"%d\",&P[i][j]);\n\t\tfor(i=1;i<7;i++)\n\t\t{\n\t\t\tt=dfs(P,i,0);\n\t\t\tres=t<res?res:t;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define maxN 10\n\nvoid dfs(int time, int color, int bfr[maxN][maxN]);\nint changeColor(int bfr[maxN][maxN], int panel[maxN][maxN], int color, int x, int y);\n\nint h, w, c, max;\nint vx[] = {1,0,-1,0};\nint vy[] = {0,1,0,-1};\n\nint main(){\n\tint i, j;\n\n\twhile(1){\n\t\tint panel[maxN][maxN] = {};\n\n\t\tscanf(\"%d %d %d\", &h, &w, &c);\n\t\tif(h==0&&w==0&&c==0) break;\n\n\t\tfor(i=1; i<=h; i++){\n\t\t\tfor(j=1; j<=w; j++){\n\t\t\t\tscanf(\"%d\", &panel[i][j]);\n\t\t\t}\n\t\t}\n\t\tdfs(0, panel[1][1], panel);\n\t\tprintf(\"%d\\n\", max);\n\n\t\tmax = 0;\n\t}\n\n\treturn 0;\n}\n\nvoid dfs(int time, int color, int bfr[maxN][maxN]){\n\tint panel[maxN][maxN];\n\tint i, j, cnt = 0;\n\n\tfor(i=0; i<maxN; i++){\n\t\tfor(j=0; j<maxN; j++){\n\t\t\tpanel[i][j] = bfr[i][j];\n\t\t}\n\t}\n\n\tif(time<4){\n\t\tfor(i=1; i<=6; i++){\n\t\t\tif(i==color) continue;\n\t\t\tcnt = changeColor(bfr, panel, i, 1, 1);\n\t\t\tdfs(time+1, i, panel);\n\t\t}\n\t}else if(time==4){\n\t\tcnt = changeColor(bfr, panel, c, 1, 1);\n\t\tdfs(time+1, c, panel);\n\t}else if(time==5){\n\t\tcnt = changeColor(bfr, panel, 7, 1, 1);\n\t\tif(max<cnt) max = cnt;\n\t}\n}\n\nint changeColor(int bfr[maxN][maxN], int panel[maxN][maxN], int color, int x, int y){\n\tint i, cnt = 1;\n\tpanel[y][x] = color;\n\tfor(i=0; i<4; i++){\n\t\tif(bfr[y+vy[i]][x+vx[i]]==bfr[y][x] && panel[y+vy[i]][x+vx[i]]!=color){\n\t\t\tcnt += changeColor(bfr, panel, color, x+vx[i], y+vy[i]);\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C",
    "code": "h,w,c,S,max,C,N,r;\nint *_M;\nD(x,y){\n\t_M[x+(w+2)*y]=N;\n\tif(_M[x-1+(w+2)*y]==C)r++,D(x-1,y);\n\tif(_M[x+1+(w+2)*y]==C)r++,D(x+1,y);\n\tif(_M[x+(w+2)*(y-1)]==C)r++,D(x,y-1);\n\tif(_M[x+(w+2)*(y+1)]==C)r++,D(x,y+1);\n}\nE(int d,int *M){if(d<4||M[1+w+2]!=c){\n\tint *m=malloc(S);\n\tif(d==4){\n\t\tmemcpy(_M=m,M,S);\n\t\tC=m[1+w+2],N=c;D(1,1);\n\t\tC=m[1+w+2],N=-1,r=1;D(1,1);\n\t\tif(max<r)max=r;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++)if(M[1+w+2]!=i){\n\t\t\tmemcpy(_M=m,M,S);\n\t\t\tC=m[1+w+2],N=i;D(1,1);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,S=4*(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint *_M;\nint D(x,y,c,n){\n\tint r=1;\n\t_M[x+(w+2)*y]=n;\n\tif(_M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n);\n\tif(_M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n);\n\tif(_M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n);\n\tif(_M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n);\n\treturn r;\n}\nE(d,M)int *M;{\n\tif(d==4&&M[1+w+2]==c)return;\n\tint *m=malloc((w+2)*(h+2));\n\tif(d==4){\n\t\tmemcpy(m,M,(w+2)*(h+2));_M=m;\n\t\tD(1,1,m[1+w+2],c);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++){\n\t\t\tif(M[1+w+2]==i)continue;\n\t\t\tmemcpy(m,M,(w+2)*(h+2));_M=m;\n\t\t\tD(1,1,m[1+w+2],i,m);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "h,w,c,S,max,C,N,r;\nint *_M;\nD(x,y){\n\t_M[x+(w+2)*y]=N;\n\tif(_M[x-1+(w+2)*y]==C)r++,D(x-1,y);\n\tif(_M[x+1+(w+2)*y]==C)r++,D(x+1,y);\n\tif(_M[x+(w+2)*(y-1)]==C)r++,D(x,y-1);\n\tif(_M[x+(w+2)*(y+1)]==C)r++,D(x,y+1);\n}\nE(int d,int *M){if(d<4||M[1+w+2]!=c){\n\tint *m=malloc(S);\n\tif(d==4){\n\t\tmemcpy(_M=m,M,S);\n\t\tC=m[1+w+2],N=c;D(1,1);\n\t\tC=c,N=-1,r=1;D(1,1);\n\t\tif(max<r)max=r;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++)if(M[1+w+2]!=i){\n\t\t\tmemcpy(_M=m,M,S);\n\t\t\tC=m[1+w+2],N=i;D(1,1);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,S=4*(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint *_M;\nint D(x,y,c,n){\n\tint r=1;\n\t_M[x+(w+2)*y]=n;\n\tif(_M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n);\n\tif(_M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n);\n\tif(_M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n);\n\tif(_M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n);\n\treturn r;\n}\nE(d,M)int *M;{\n\tif(d==4&&M[1+w+2]==c)return;\n\tint *m=malloc(400);\n\tif(d==4){\n\t\tmemcpy(m,M,400);_M=m;\n\t\tD(1,1,m[1+w+2],c);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++){\n\t\t\tif(M[1+w+2]==i)continue;\n\t\t\tmemcpy(m,M,400);_M=m;\n\t\t\tD(1,1,m[1+w+2],i,m);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,400);\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "h,w,c,S,max,C,N,r;\nint *_M;\nD(x,y){\n\t_M[x+(w+2)*y]=N;\n\tif(_M[x-1+(w+2)*y]==C)r++,D(x-1,y);\n\tif(_M[x+1+(w+2)*y]==C)r++,D(x+1,y);\n\tif(_M[x+(w+2)*(y-1)]==C)r++,D(x,y-1);\n\tif(_M[x+(w+2)*(y+1)]==C)r++,D(x,y+1);\n\treturn r;\n}\nE(int d,int *M){if(d<4||M[1+w+2]!=c){\n\tint *m=malloc(S);\n\tif(d==4){\n\t\tmemcpy(_M=m,M,S);\n\t\tC=m[1+w+2],N=c;D(1,1);\n\t\tC=m[1+w+2],N=-1,r=1;D(1,1);\n\t\tif(max<r)max=r;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++)if(M[1+w+2]!=i){\n\t\t\tmemcpy(_M=m,M,S);\n\t\t\tC=m[1+w+2],N=i;D(1,1);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,S=4*(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "h,w,c,max;\nint *_M;\nint D(x,y,c,n){\n\tint r=1;\n\t_M[x+(w+2)*y]=n;\n\tif(_M[x-1+(w+2)*y]==c)r+=D(x-1,y,c,n);\n\tif(_M[x+1+(w+2)*y]==c)r+=D(x+1,y,c,n);\n\tif(_M[x+(w+2)*(y-1)]==c)r+=D(x,y-1,c,n);\n\tif(_M[x+(w+2)*(y+1)]==c)r+=D(x,y+1,c,n);\n\treturn r;\n}\nE(int d,int *M){if(d<4||M[1+w+2]!=c){\n\tint *m=malloc(4*(w+2)*(h+2));\n\tif(d==4){\n\t\tmemcpy(_M=m,M,4*(w+2)*(h+2));\n\t\tD(1,1,m[1+w+2],c);\n\t\tint k=D(1,1,m[1+w+2],-1,m);\n\t\tif(max<k)max=k;\n\t}else{\n\t\tint i=1;\n\t\tfor(;i<7;i++){\n\t\t\tif(M[1+w+2]==i)continue;\n\t\t\tmemcpy(_M=m,M,4*(w+2)*(h+2));\n\t\t\tD(1,1,m[1+w+2],i,m);\n\t\t\tE(d+1,m);\n\t\t}\n\t}\n\tfree(m);\n}}\na[100];\nmain(i,j){for(;scanf(\"%d%d%d\",&h,&w,&c),c;printf(\"%d\\n\",max)){\n\tmemset(a,0,4*(w+2)*(h+2));\n\tfor(j=1;j<h+1;j++)for(i=1;i<w+1;i++)scanf(\"%d\",a+i+(w+2)*j);\n\tE(max=0,a);\n}}"
  },
  {
    "language": "C",
    "code": "// Aizu 1174: Identically Colored Panels Connection\n// 2017.9.17 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int r, c; } Q;\nQ q[70]; int top, end;\nchar mk[8][8];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nchar map[8][8]; int h, w, color;\nint ans;\n\nint count(char p[8][8])\n{\n\tint i, r, c, r2, c2, f;\n\tq[0].r = q[0].c = 0, top = 0, end = 1, memset(mk, 0, sizeof(mk)), mk[0][0] = 1, f = 1;\n\twhile (top < end) {\n\t\tr = q[top].r, c = q[top++].c;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || p[r2][c2] != p[r][c] || mk[r2][c2]) continue;\n\t\t\tmk[r2][c2] = 1, f++, q[end].r = r2, q[end++].c = c2;\n\t\t}\n\t}\n\treturn f;\n}\n\nvoid combi(int c0, int k, char p[8][8])\n{\n\tint i, j, r, c, r2, c2, m;\n\tchar t[8][8];\n\n\tif (k == 5) return;\n\tfor (j = 1; j <= 6; j++) {\n\t\tif (j == c0) continue;\n\t\tmemcpy(t, p, sizeof(t)); t[0][0] = j;\n\t\tq[0].r = q[0].c = 0, top = 0, end = 1, memset(mk, 0, sizeof(mk)), mk[0][0] = 1;\n\t\twhile (top < end) {\n\t\t\tr = q[top].r, c = q[top++].c;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || t[r2][c2] != c0 || mk[r2][c2]) continue;\n\t\t\t\tmk[r2][c2] = 1, t[r2][c2] = j, q[end].r = r2, q[end++].c = c2;\n\t\t\t}\n\t\t}\n\t\tif (j == color) if ((m = count(t)) > ans) ans = m;\n\t\tcombi(j, k+1, t);\n\t}\n}\n\nint main()\n{\n\tint a, r, c;\n\n\twhile(scanf(\"%d%d%d\", &h, &w, &color) && h) {\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) scanf(\"%d\", &a), map[r][c] = a;\n\t\tans = 0; if (map[0][0] == color) ans = count(map);\n\t\tcombi(map[0][0], 0, map);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define max(x,y) x>y?x:y\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n\ntypedef int bool;\n\n#define true 1\n#define false 0\n\nint dd[]={-1,0,1,0,-1};\n\nint h,w,c;\nint p[11][11];\n\nbool visc[11][11];\nint cnt;\n\nvoid cntc(int i,int j,int cc){\n\tvisc[i][j]=true;\n\tcnt++;\n\trep(d,4){\n\t\tint ni=i+dd[d],nj=j+dd[d+1];\n\t\tif(ni>=0&&ni<h&&nj>=0&&nj<w&&p[ni][nj]==cc&&!visc[ni][nj])cntc(ni,nj,cc);\n\t}\n}\n\nvoid change(int i,int j,int mc,int cc){\n\tp[i][j]=cc;\n\tvisc[i][j]=true;\n\trep(d,4){\n\t\tint ni=i+dd[d],nj=j+dd[d+1];\n\t\tif(ni>=0&&ni<h&&nj>=0&&nj<w&&p[ni][nj]==mc&&!visc[ni][nj])change(ni,nj,mc,cc);\n\t}\n}\n\nint dfs(int d){\n\tif(d==5){\n\t\tcnt=0;\n\t\tmemset(visc,0,sizeof(visc));\n\t\tcntc(0,0,c);\n\t\treturn cnt;\n\t}else{\n\t\tint res=0;\n\t\tint sav[11][11];\n\t\tmemcpy(sav,p,sizeof(p));\n\t\tif(d==4){\n\t\t\tmemset(visc,0,sizeof(visc));\n\t\t\tchange(0,0,p[0][0],c);\n\t\t\tmaxch(res,dfs(d+1));\n\t\t}else{\n\t\t\trepl(i,1,6+1){\n\t\t\t\tmemset(visc,0,sizeof(visc));\n\t\t\t\tchange(0,0,p[0][0],i);\n\t\t\t\tmaxch(res,dfs(d+1));\n\t\t\t\tmemcpy(p,sav,sizeof(sav));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&h,&w,&c);\n\t\tif(h==0)break;\n\t\trep(i,h)rep(j,w)scanf(\"%d\",&p[i][j]);\n\t\tprintf(\"%d\\n\", dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint h, w, c;\n\tint[][] cost, costzero;\n\tint[][][] map;\n\tArrayList<Integer> stack = new ArrayList<Integer>();\n\tint ans=0;\n\tint sum=0;\n\t\t\n\tpublic void zero(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcost[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void change(int z, int y, int x, int a){\n\t\tint b = map[z-1][0][0];\n\t\tmap[z][y][x]=a;\n\t\tif(y!=0 && map[z][y-1][x]==0 && map[z-1][y-1][x]==b)change(z, y-1, x, a);\n\t\tif(x!=0 && map[z][y][x-1]==0 && map[z-1][y][x-1]==b)change(z, y, x-1, a);\n\t\tif(y!=h-1 && map[z][y+1][x]==0 && map[z-1][y+1][x]==b)change(z, y+1, x, a);\n\t\tif(x!=w-1 && map[z][y][x+1]==0 && map[z-1][y][x+1]==b)change(z, y, x+1, a);\n\t}\n\t\n\tpublic void check(int y, int x){\n\t\tcost[y][x]=1;\n\t\tsum++;\n\t\tif(y!=0 && map[5][y-1][x]==c && cost[y-1][x]==0)check(y-1, x);\n\t\tif(x!=0 && map[5][y][x-1]==c && cost[y][x-1]==0)check(y, x-1);\n\t\tif(y!=h-1 && map[5][y+1][x]==c && cost[y+1][x]==0)check(y+1, x);\n\t\tif(x!=w-1 && map[5][y][x+1]==c && cost[y][x+1]==0)check(y, x+1);\n\t}\n\t\n\tpublic void fill(int z, int f){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(f==0)map[z][i][j]=0;\n\t\t\t\tif(f==1 && map[z][i][j]==0)map[z][i][j]=map[z-1][i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void func(int s){\n\t\tif(s!=5){\n\t\t\tfor(int i=1;i<7;i++){\n\t\t\t\tif(s==4)i=c;\n\t\t\t\tif(i!=map[s][0][0]){\n\t\t\t\t\tstack.add(i);\n\t\t\t\t\tchange(s+1,0,0,i);\n\t\t\t\t\tfill(s+1,1);\n\t\t\t\t\tfunc(s+1);\n\t\t\t\t}\n\t\t\t\tif(s==4)i=7;\n\t\t\t}\n\t\t}\n\t\tif(s==5){\n\t\t\tcheck(0,0);\n\t\t\tif(sum>ans)ans=sum;\n\t\t\tzero();\n\t\t\tsum=0;\n\t\t}\n\t\tfill(s,0);\n\t\tif(stack.size()!=0)stack.remove(stack.size()-1);\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tMain C = new Main();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint exit=0;\n\t\twhile(exit==0){\n\t\t\tC.h = sc.nextInt();\n\t\t\tC.w = sc.nextInt();\n\t\t\tC.c = sc.nextInt();\n\t\t\tif(C.h==0 && C.w==0 && C.c==0)exit=1;\n\t\t\tif(exit==0){\n\t\t\t\tC.map = new int[6][C.h][C.w];\n\t\t\t\tC.cost = new int[C.h][C.w];\t\t\t\t\n\t\t\t\tfor(int i=0;i<C.h;i++){\n\t\t\t\t\tfor(int j=0;j<C.w;j++){\n\t\t\t\t\t\tC.map[0][i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tC.func(0);\n\t\t\t\tSystem.out.println(C.ans);\n\t\t\t\tC.ans=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    int h,w,c;\n    int max;\n    int from,to;\n    int ans;\n    int[][] panel2;\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\th = sc.nextInt();\n\twhile(h!=0){\n\t    ans = 0;\n\t    w = sc.nextInt();\n\t    c = sc.nextInt();\n\t    int[][] panel = new int[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    panel[i][j] = sc.nextInt();\n\t\t}\n\t    }\n\t    \n\t    max = Integer.MIN_VALUE;\n\t    identically(0,panel);\n\t    System.out.println(max);\n\n\t    h = sc.nextInt();\n\t}\n    }\n\n    void identically(int count, int[][] panel){\n\tif(count==4){\n\t    if(panel[0][0]==c){return;}\n\t    from = panel[0][0]; to = c;\n\t    panel2 = panel;\n\t    change(0,0);\n\t    ans = 0;\n\t    from = c; to = 7;\n\t    change(0,0);\n\t    max = Math.max(max,ans);\n\t    return;\n\t}\n\n\tint first = panel[0][0];\n\tpanel2 = new int[h][w];\n\tfor(int i=0; i<h; i++){\n\t    for(int j=0; j<w; j++){\n\t\tpanel2[i][j] = panel[i][j];\n\t    }\n\t}\n\tfor(int i=1; i<=6; i++){\n\t    if(i==first)continue;\n\t    from = first; to = i;\n\t    identically(count+1,change(0,0));\n\t    for(int k=0; k<h; k++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    panel2[k][j] = panel[k][j];\n\t\t}\n\t    }\n\t}\n    }\n\n    int[] dx = {1,-1,0,0};\n    int[] dy = {0,0,1,-1};\n    int[][] change(int x, int y){\n\tpanel2[y][x] = to;\n\tans++;\n\tfor(int k=0; k<4; k++){\n\t    int nx = x+dx[k];\n\t    int ny = y+dy[k];\n\t    if(ny<h && ny>=0 && nx<w && nx>=0 && panel2[ny][nx]==from){\n\t\tpanel2 = change(nx,ny);\n\t    }\n\t}\n\t\n\treturn panel2;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    public static void main ( String [] args ) throws IOException\n\n\n    {\n    \t\n\tnew Main().cal();\n    }\n\n \n    private void cal() throws IOException \n    {\n    \twhile(true){\n\t    String[] buffer=br.readLine().split(\"\\\\s\");\n    \t\n\t    int height=Integer.parseInt(buffer[0]);\n\n\n\t    int width=Integer.parseInt(buffer[1]);\n\t    int objectColor = Integer.parseInt(buffer[2]);\n\t    int[][] arr=new int[height][width];\n\t    int max=0;\n    \t\t\n\t    if(height==0 && width==0 && objectColor==0)\n\t    \tbreak;\n    \t\t\n\t    for(int i=0;i<height;i++){\n\t    \tString[] temp=br.readLine().split(\"\\\\s\");\n\t    \tfor(int j=0;j<width;j++)\n\t    \t\tarr[i][j]=Integer.parseInt(temp[j]);\n\t    \t}\n    \t\t\n\t    for(int i=1;i<7;i++)\n\t    \tif(i!=objectColor)\n\t    \t\tfor(int j=1;j<7;j++)\n\t    \t\t\tfor(int k=1;k<7;k++)\n\t    \t\t\t\tfor(int m=1;m<7;m++){\n\t    \t\t\t\t\tif(i==j || j==k || k==m||m==objectColor)\n\t    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t\t\t\n\t    \t\t\t\t\tint temp=checkColor(0,0,change(arr,m,k,j,i,objectColor),objectColor);\n\t\t\t\t\t\t\n\t    \t\t\t\t\tif(max<temp){\n\t    \t\t\t\t\t\tmax=temp;\n\t\t\t\t\t\t\t/*\tfor(int z=0;z<height;z++){\n\t\t\t\t\t\t\t    for(int x=0;x<width;x++)\n\t\t\t\t\t\t\t\tSystem.out.print(change(arr,m,k,j,i,objectColor)[z][x]+\" \");\n\t\t\t\t\t\t\t    System.out.println(\"\");\t\t    }\t\t\tSystem.out.println(\"max : \"+max);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t*/\t}}\n\t    \n\t    System.out.println(max);\n    \t}\n\n    \t\n    }\n    public int[][] change(int[][] arr,int m,int k,int j,int i,int Color){\n\n\n    \tint[][]tempArr=(int[][]) clone(arr);\n\tint initial=tempArr[0][0];\n\n\tchangeCell(tempArr,0,0,m,initial);\n\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=m;\n\n     \tchangeCell(tempArr,0,0,k,m);\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=k;\n\n    \tchangeCell(tempArr,0,0,j,k); \n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=j;\n\n    \tchangeCell(tempArr,0,0,i,j);\n \n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=i;\n\n    \tchangeCell(tempArr,0,0,Color,i);\n\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=Color;\n\n    \treturn tempArr; \n    }\n    \n    public static Object[] clone(int[][] arr){\n    \t\tif(arr==null)\n    \t\t\t\treturn null;\n    \t\telse {\n\t\t    int[][] temp=new int[arr.length][arr[0].length];\n\t\t    for(int i=0;i<arr.length;i++)\n\t\t\tfor(int j=0;j<arr[0].length;j++)\n\t\t\t    temp[i][j]=arr[i][j];\n\t\t    \n    \t\t\t\treturn temp;\n\t\t}\n    }\n    \n    public int checkColor(int a,int b,int[][] checkingArr,int Color){\n    \t\n    \t\tif(a>=0 && b>=0 &&a<checkingArr.length&& b<checkingArr[0].length&&checkingArr[a][b]==Color){\n\t\t    checkingArr[a][b]=0;\n\t\t    return 1+\ncheckColor(a-1,b,checkingArr,Color)+checkColor(a+1,b,checkingArr,Color)+\ncheckColor(a,b-1,checkingArr,Color)+checkColor(a,b+1,checkingArr,Color);\n    \t\t}\n    \t\telse \n    \t\t\t\treturn 0;\n    }\n    \n    public void changeCell(int[][] tempArr,int a, int b,int c,int d){\n\n    \ttempArr[a][b]=0;\n    \t\n    \tif(a>0 && tempArr[a-1][b]==d)\n    \t\tchangeCell(tempArr,a-1,b,c,d);\n    \tif(b>0 && tempArr[a][b-1]==d)\n    \t\tchangeCell(tempArr,a,b-1,c,d);\n    \tif(a<tempArr.length-1 && tempArr[a+1][b]==d)\n    \t\tchangeCell(tempArr,a+1,b,c,d);\n    \tif(b<tempArr[0].length-1 && tempArr[a][b+1]==d)\n    \t\tchangeCell(tempArr,a,b+1,c,d);\n\t\n\n\n    \t\n    }\n\n    \n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tint H, W, C;\n\tint[][] map;\n\tboolean visit[][];\n\tint max, cnt;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tC = sc.nextInt();\n\t\t\tif ((H | W | C) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap = new int[H][W];\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] use = new boolean[6];\n\t\t\tint[] parm = new int[6];\n\t\t\tmakePerm(0, parm, use);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tvoid makePerm(int n, int[] parm, boolean use[]) {\n\t\tif (n == 6) {\n\t\t\tsolve(parm);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tparm[n] = i;\n\t\t\tmakePerm(n + 1, parm, use);\n\t\t}\n\t}\n\n\tvoid solve(int parm[]) {\n\t\tint field[][] = new int[H][W];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfield[i][j] = map[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tvisit = new boolean[H][W];\n\t\t\tint first = field[0][0];\n\t\t\tdfs(field, parm[i], first, visit, 0, 0);\n\t\t}\n\t\tvisit = new boolean[H][W];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (field[i][j] == C && !visit[i][j]) {\n\t\t\t\t\tcnt = 1;\n\t\t\t\t\tcntMap(field, visit, i, j);\n\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(int[][] field, int num, int first, boolean[][] visit, int h, int w) {\n\t\tfield[h][w] = num;\n\t\tvisit[h][w] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dy[i];\n\t\t\tint nw = w + dx[i];\n\t\t\tif (nh >= 0 && nh < H && nw >= 0 && nw < W && !visit[nh][nw]\n\t\t\t\t\t&& field[nh][nw] == first) {\n\t\t\t\tdfs(field, num, first, visit, nh, nw);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid cntMap(int[][] field, boolean[][] visitf, int h, int w) {\n\t\tvisit[h][w] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dy[i];\n\t\t\tint nw = w + dx[i];\n\t\t\tif (nh >= 0 && nh < H && nw >= 0 && nw < W && !visit[nh][nw]\n\t\t\t\t\t&& field[nh][nw] == C) {\n\t\t\t\tcnt++;\n\t\t\t\tcntMap(field, visit, nh, nw);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//import java.io.File;\nimport java.util.Scanner;\n\nimport java.util.Arrays;\n\nimport java.io.PrintWriter;\n\nclass Main {\n  static int[][] arr;\n  static boolean[][] checkedArray;\n  static int w,h,lastInput;\n  static int[] prime = {0,2,3,5,7,11,13};\n  static int max;\n  //static PrintWriter fos;\n  public static void main(String[] args) {\n    //Scanner scan = new Scanner(new File(\"in.txt\"));\n    Scanner scan = new Scanner(System.in);\n    //fos = new PrintWriter(new File(\"out.txt\"));\n    h = scan.nextInt();\n    w = scan.nextInt();\n    lastInput = scan.nextInt();\nwhile(!(h==0||w==0||lastInput==0)) {\n  max = 0;\n\n    arr = new int[h][w];\n    checkedArray = new boolean[h][w];\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n        arr[i][j] = scan.nextInt();\n      }\n    }\n\n    calcOneThing(0, arr);\n\n    System.out.println(max);\n    //fos.close();\n\nh = scan.nextInt();\nw = scan.nextInt();\nlastInput = scan.nextInt();\n}\n  }\n\n  static void calcOneThing(int _count, int[][] _arr) {\n    //System.out.println(Arrays.deepToString(_arr));\n    if(_count>=5) {\n      int _max = calcMax(0,0,_arr,new boolean[h][w],0);\n      if(_max>max) {\n        max = _max;\n        //System.out.println(\"----newrecord----\");\n      }\n      return;\n    }\n    boolean[][] nextCheckArray = cloneBooleanArray(checkedArray);\n    int nextCheck = checkNextPanel(_arr[0][0],0,0,_arr,nextCheckArray,1);\n    boolean flag = false;\n    for(int i = 1; i <= 6; i++) {\n      if(nextCheck % prime[i] == 0 || (_count == 4 && i == lastInput)) {\n        int[][] nextArr = cloneIntArray(_arr);\n        boolean[][] dummyChecked = cloneBooleanArray(checkedArray);\n        changeNextPanel(i,0,0,nextArr,dummyChecked);\n        //System.out.print(\"count : \"+_count+\" , color = \"+ i);\n        calcOneThing(_count+1,nextArr);\n        flag = true;\n      }\n    }\n    if(!flag) {\n      if(_arr[0][0] != lastInput) {\n        int[][] nextArr = cloneIntArray(_arr);\n        boolean[][] dummyChecked = cloneBooleanArray(checkedArray);\n        changeNextPanel(lastInput,0,0,nextArr,dummyChecked);\n        //System.out.print(\"[re]count : \"+_count+\" , color = \"+ lastInput);\n        calcOneThing(_count+1,nextArr);\n      }else {\n        int _max = calcMax(0,0,_arr,new boolean[h][w],0);\n        if(_max>max) {\n          max = _max;\n          //System.out.println(\"----newrecord----\");\n        }\n      }\n    }\n  }\n\n  static int calcMax(int _x, int _y, int[][] map, boolean[][] checked, int num) {\n    if(checked[_x][_y]) return num;\n    checked[_x][_y] = true;\n    if(_x>0) {\n      if(map[_x-1][_y] == map[_x][_y]) num = calcMax(_x-1,_y,map,checked,num);\n    }\n    if(_x<h-1) {\n      if(map[_x+1][_y] == map[_x][_y]) num = calcMax(_x+1,_y,map,checked,num);\n    }\n    if(_y>0) {\n      if(map[_x][_y-1] == map[_x][_y]) num = calcMax(_x,_y-1,map,checked,num);\n    }\n    if(_y<w-1) {\n      if(map[_x][_y+1] == map[_x][_y]) num = calcMax(_x,_y+1,map,checked,num);\n    }\n    return num+((map[_x][_y]==lastInput)?1:0);\n  }\n\n  //next to no panel wo sagasu.\n  static int checkNextPanel(int _my, int _x, int _y, int[][] map, boolean[][] checked ,int num) {\n    if(checked[_x][_y]) return num;\n    checked[_x][_y] = true;\n    if(_x>0) {\n      if(map[_x-1][_y] == _my) num = checkNextPanel(_my,_x-1,_y,map,checked,num);\n      else if(num % prime[map[_x-1][_y]] != 0) num *= prime[map[_x-1][_y]];\n    }\n    if(_x<h-1) {\n      if(map[_x+1][_y] == _my) num = checkNextPanel(_my,_x+1,_y,map,checked,num);\n      else if(num % prime[map[_x+1][_y]] != 0) num *= prime[map[_x+1][_y]];\n    }\n    if(_y>0) {\n      if(map[_x][_y-1] == _my) num = checkNextPanel(_my,_x,_y-1,map,checked,num);\n      else if(num % prime[map[_x][_y-1]] != 0) num *= prime[map[_x][_y-1]];\n    }\n    if(_y<w-1) {\n      if(map[_x][_y+1] == _my) num = checkNextPanel(_my,_x,_y+1,map,checked,num);\n      else if(num % prime[map[_x][_y+1]] != 0) num *= prime[map[_x][_y+1]];\n    }\n    //System.out.print(num+\",\");\n    return num;\n  }\n\n  //zissai ni kaeru.\n  static void changeNextPanel(int _my, int _x, int _y, int[][] map, boolean[][] checked) {\n    if(checked[_x][_y]) return;\n    checked[_x][_y] = true;\n    if(_x>0) {\n      if(map[_x-1][_y] == map[_x][_y]) {\n        changeNextPanel(_my,_x-1,_y,map,checked);\n      }\n    }\n    if(_x<h-1) {\n      if(map[_x+1][_y] == map[_x][_y]) {\n        changeNextPanel(_my,_x+1,_y,map,checked);\n      }\n    }\n    if(_y>0) {\n      if(map[_x][_y-1] == map[_x][_y]) {\n        changeNextPanel(_my,_x,_y-1,map,checked);\n      }\n    }\n    if(_y<w-1) {\n      if(map[_x][_y+1] == map[_x][_y]) {\n        changeNextPanel(_my,_x,_y+1,map,checked);\n      }\n    }\n    map[_x][_y] = _my;\n  }\n\n  static int[][] cloneIntArray(int[][] _arr) {\n    int[][] dummy = new int[_arr.length][];\n    for(int i = 0; i < _arr.length; i++) {\n      dummy[i] = new int[_arr[i].length];\n      for(int j = 0; j < dummy[i].length; j++) {\n        dummy[i][j] = _arr[i][j];\n      }\n    }\n    return dummy;\n  }\n\n  static boolean[][] cloneBooleanArray(boolean[][] _arr) {\n    boolean[][] dummy = new boolean[_arr.length][];\n    for(int i = 0; i < _arr.length; i++) {\n      dummy[i] = new boolean[_arr[i].length];\n      for(int j = 0; j < dummy[i].length; j++) {\n        dummy[i][j] = _arr[i][j];\n      }\n    }\n    return dummy;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int h, w, c;\n\tstatic int[] change;\n\tstatic int[][] p, stamp;\n\n\tstatic int[] dx = { 0, 1, 0,-1};\n\tstatic int[] dy = { 1, 0,-1, 0};\n\n\tstatic int rec(int y, int x, int pos) {\n\t\tint res = stamp[y][x] == 6 ? 1 : 0;\n\t\tstamp[y][x] = pos;\n\t\tfor (int k=0; k<4; k++) {\n\t\t\tint ny = y + dy[k];\n\t\t\tint nx = x + dx[k];\n\t\t\tif (ny < 0 || nx < 0 || h <= ny || w <= nx) continue;\n\t\t\tint ptmp = pos;\n\t\t\twhile (ptmp < 6 && change[ptmp] != p[ny][nx]) ptmp++;\n\t\t\tif (stamp[ny][nx] <= ptmp) continue;\n\t\t\tres += rec(ny, nx, ptmp);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic boolean solve() {\n\t\th = in.nextInt();\n\t\tw = in.nextInt();\n\t\tc = in.nextInt();\n\t\tif (h + w + c == 0) return false;\n\n\t\tp = new int[h][w];\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tp[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i=1; i<=6; i++) {\n\t\t\tfor (int j=1; j<=6; j++) {\n\t\t\t\tfor (int k=1; k<=6; k++) {\n\t\t\t\t\tfor (int l=1; l<=6; l++) {\n\t\t\t\t\t\tchange = new int[]{p[0][0], i, j, k, l, c};\n\n\t\t\t\t\t\tstamp = new int[h][w];\n\t\t\t\t\t\tfor (int m=0; m<h; m++) {\n\t\t\t\t\t\t\tArrays.fill(stamp[m],6);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = Math.max(ans, rec(0, 0, 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\tdump((end-start) + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * \n */\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * @author kumar1\n * \n */\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\ttry {\n\t\t\tsolve();\n\t\t} catch (IOException e) {\n\t\t\t// TODO 自動生成された catch ブロック\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * @throws IOException\n\t * \n\t */\n\tprivate static void solve() throws IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tArrayList<ArrayList<Byte>> list = new ArrayList<ArrayList<Byte>>();\n\t\t//File file = new File(\"ccase.txt\");\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(file));\n\t\tString s;\n\t\twhile ((s = in.readLine()) != null) {\n\t\t\tScanner scan = new Scanner(s);\n\t\t\tint n = 0;\n\t\t\tArrayList<Byte> l = new ArrayList<Byte>();\n\t\t\twhile (scan.hasNextInt()) {\n\t\t\t\tn = scan.nextInt();\n\t\t\t\tl.add((byte) n);\n\t\t\t}\n\t\t\tlist.add(l);\n\t\t\tscan.close();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tin.close();\n\t\t//System.out.println(list);\n\t\tfor (int i = 0; i < list.size();) {\n\t\t\tif (list.get(i).get(0) == 0)\n\t\t\t\tbreak;\n\t\t\tint h, w, c;\n\t\t\th = list.get(i).get(0);\n\t\t\tw = list.get(i).get(1);\n\t\t\tc = list.get(i).get(2);\n\t\t\tans(c, list.subList(i + 1, i + 1 + h));\n\t\t\ti = i + 1 + h;\n\t\t}\n\t}\n\n\t/**\n\t * @param h\n\t * @param w\n\t * @param c\n\t * @param subList\n\t */\n\tprivate static void ans(int c, List<ArrayList<Byte>> list) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t//System.out.println(list);\n\t\tbyte[][] arr = new byte[list.size()][list.get(0).size()];\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tfor(int j = 0; j < list.get(0).size(); j++) {\n\t\t\t\tarr[i][j] = list.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tdfs(arr, 1, 3, 0, 0);\n\t\tdfs(arr, arr[0][0], 6, 0, 0);\n\t\tfor(int j=0; j < arr.length; j++) {\n\t\t\tfor(int k=0; k < arr[0].length; k++) {\n\t\t\t\tSystem.out.print(arr[j][k] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(count(arr, arr[0][0], 0, 0, 1));\n\t\t*/\n\t\tSystem.out.println(pat(c, arr, 0));\n\t}\n\n\t/**\n\t * @param c : 最後の色\n\t * @param arr : 基板の配列\n\t * @param i : ループ回数\n\t * @return\n\t */\n\tprivate static int pat(int c, byte[][] arr, int i) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tbyte[][] carr;\n\t\ti++;\n\t\tif(i > 4) { // 5回目はc\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], c, 0, 0);\n\t\t\t/*\n\t\t\tfor(int j=0; j < carr.length; j++) {\n\t\t\t\tfor(int k=0; k < carr[0].length; k++) {\n\t\t\t\t\tSystem.out.print(carr[j][k] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\t\t\n\t\t\treturn count(carr, c, 0, 0, 1);\n\t\t}\n\t\tint max = 0;\n\t\t// 1, 2, 3, 4回目は全色\n\t\tfor(int j=1; j <= 6; j++) {\n\t\t\tif(arr[0][0] == j)\n\t\t\t\tcontinue;\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tint cnb = count(carr, carr[0][0], 0, 0, 1);\n\t\t\tdfs(carr, carr[0][0], j, 0, 0);\n\t\t\tint cna = count(carr, carr[0][0], 0, 0, 1);\n\t\t\tint n = cna;\n\t\t\tif(cnb != cna)\n\t\t\t\tn = pat(c, carr, i);\n\t\t\tif(max < n) {\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\n\t/**\n\t * @param c : 値がcの要素の数を求める\n\t * @return\n\t */\n\tprivate static int count(byte[][] arr, int c, int x, int y, int cnt) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tbyte[][] carr = cp2dIntArray(arr);\n\t\treturn countr(carr, c, x, y, cnt);\n\t}\n\t\n\tprivate static int countr(byte[][] carr, int c, int x, int y, int cnt) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = 0;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\t\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == c)\n\t\t\t\t\tcnt = countr(carr, c, nx, ny, cnt + 1);\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\t/**\n\t * @param carr\n\t * @param j : dfsした結果置換するやつ\n\t * @param x : x座標\n\t * @param y : y座標\n\t */\n\tprivate static void dfs(byte[][] carr, int before, int after, int x, int y) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = (byte) after;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == before && before != after)\n\t\t\t\t\tdfs(carr, before, after, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static byte[][] cp2dIntArray(byte[][] x) {\n\t\tbyte[][] ret = new byte[x.length][];\n\t\tfor(int i=0; i < x.length; i++)\n\t\t\tret[i] = x[i].clone();\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1174();\n\t}\n\tclass AOJ1174{\n\t\tAOJ1174(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tC=sc.nextInt();\n\t\t\t\tif((H|(W|C))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tint H,W,C;\n\t\tint[][][] b;\n\t\tfinal int[] vx={0,-1,0,1},vy={-1,0,1,0};\n\t\tvoid solve(){\n\t\t\tb=new int[6][W][H];\n\t\t\tfor(int h=0; h<H; ++h)for(int w=0; w<W; ++w)\tb[0][w][h]=sc.nextInt();\n\t\t\tSystem.out.println(dfs(b,0,b[0][0][0]));\n\t\t}\n\t\tint dfs(int[][][] b,int depth,int last){\n\t\t\tif(depth>=4)\treturn cnt(change(depth, C));\n\t\t\tint ret=0;\n\t\t\tfor(int c=1; c<=6; ++c){\n\t\t\t\tif(c==last)\tcontinue;\n\t\t\t\tchange(depth, c);\n\t\t\t\tret=max(ret, dfs(b, depth+1, c));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tint[][] change(int d,int target){\n\t\t\tfor(int w=0; w<W; ++w)for(int h=0; h<H; ++h)\tb[d+1][w][h]=b[d][w][h];\n\t\t\tLinkedList<Pair> open=new LinkedList<Pair>();\n\t\t\topen.add(new Pair(0,0));\n\t\t\tb[d+1][0][0]=target;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPair now=open.poll();\n\t\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\t\tint xx=now.x+vx[v], yy=now.y+vy[v];\n\t\t\t\t\tif(!(0<=xx&&xx<W && 0<=yy&&yy<H))\tcontinue;\n\t\t\t\t\tif(b[d][xx][yy]!=b[d][0][0])\tcontinue;\n\t\t\t\t\tif(b[d+1][xx][yy]==target)\tcontinue;\n\t\t\t\t\tb[d+1][xx][yy]=target;\n\t\t\t\t\topen.add(new Pair(xx,yy));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b[d+1];\n\t\t}\n\t\tint cnt(int[][] a){\n\t\t\tLinkedList<Pair> open=new LinkedList<Pair>();\n\t\t\topen.add(new Pair(0,0));\n\t\t\tboolean[][] closed=new boolean[W][H];\n\t\t\tclosed[0][0]=true;\n\t\t\tint cnt=1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPair now=open.poll();\n\t\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\t\tint xx=now.x+vx[v], yy=now.y+vy[v];\n\t\t\t\t\tif(!(0<=xx&&xx<W && 0<=yy&&yy<H))   continue;\n\t\t\t\t\tif(a[xx][yy]!=a[0][0])  continue;\n\t\t\t\t\tif(closed[xx][yy])  continue;\n\t\t\t\t\topen.add(new Pair(xx,yy));\n\t\t\t\t\tclosed[xx][yy]=true;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cnt;\n\t\t}\n\t\tclass Pair{\n\t\t\tint x,y;\n\t\t\tPair(int x,int y){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * \n */\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * @author kumar1\n * \n */\npublic class ProblemC {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\ttry {\n\t\t\tsolve();\n\t\t} catch (IOException e) {\n\t\t\t// TODO 自動生成された catch ブロック\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * @throws IOException\n\t * \n\t */\n\tprivate static void solve() throws IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tArrayList<ArrayList<Byte>> list = new ArrayList<ArrayList<Byte>>();\n\t\t//File file = new File(\"ccase.txt\");\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(file));\n\t\tString s;\n\t\twhile ((s = in.readLine()) != null) {\n\t\t\tScanner scan = new Scanner(s);\n\t\t\tint n = 0;\n\t\t\tArrayList<Byte> l = new ArrayList<Byte>();\n\t\t\twhile (scan.hasNextInt()) {\n\t\t\t\tn = scan.nextInt();\n\t\t\t\tl.add((byte) n);\n\t\t\t}\n\t\t\tlist.add(l);\n\t\t\tscan.close();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tin.close();\n\t\t//System.out.println(list);\n\t\tfor (int i = 0; i < list.size();) {\n\t\t\tif (list.get(i).get(0) == 0)\n\t\t\t\tbreak;\n\t\t\tint h, w, c;\n\t\t\th = list.get(i).get(0);\n\t\t\tw = list.get(i).get(1);\n\t\t\tc = list.get(i).get(2);\n\t\t\tans(c, list.subList(i + 1, i + 1 + h));\n\t\t\ti = i + 1 + h;\n\t\t}\n\t}\n\n\t/**\n\t * @param h\n\t * @param w\n\t * @param c\n\t * @param subList\n\t */\n\tprivate static void ans(int c, List<ArrayList<Byte>> list) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t//System.out.println(list);\n\t\tbyte[][] arr = new byte[list.size()][list.get(0).size()];\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tfor(int j = 0; j < list.get(0).size(); j++) {\n\t\t\t\tarr[i][j] = list.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tdfs(arr, 1, 3, 0, 0);\n\t\tdfs(arr, arr[0][0], 6, 0, 0);\n\t\tfor(int j=0; j < arr.length; j++) {\n\t\t\tfor(int k=0; k < arr[0].length; k++) {\n\t\t\t\tSystem.out.print(arr[j][k] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(count(arr, arr[0][0], 0, 0, 1));\n\t\t*/\n\t\tSystem.out.println(pat(c, arr, 0));\n\t}\n\n\t/**\n\t * @param c : 最後の色\n\t * @param arr : 基板の配列\n\t * @param i : ループ回数\n\t * @return\n\t */\n\tprivate static int pat(int c, byte[][] arr, int i) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tbyte[][] carr;\n\t\ti++;\n\t\tif(i > 4) { // 5回目はc\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], c, 0, 0);\n\t\t\t/*\n\t\t\tfor(int j=0; j < carr.length; j++) {\n\t\t\t\tfor(int k=0; k < carr[0].length; k++) {\n\t\t\t\t\tSystem.out.print(carr[j][k] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\t\t\n\t\t\treturn count(carr, c, 0, 0, 1);\n\t\t}\n\t\tint max = 0;\n\t\t// 1, 2, 3, 4回目は全色\n\t\tfor(int j=1; j <= 6; j++) {\n\t\t\tif(arr[0][0] == j)\n\t\t\t\tcontinue;\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], j, 0, 0);\n\t\t\tint n = pat(c, carr, i);\n\t\t\tif(max < n) {\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\n\t/**\n\t * @param c : 値がcの要素の数を求める\n\t * @return\n\t */\n\tprivate static int count(byte[][] carr, int c, int x, int y, int cnt) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = 0;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\t\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == c)\n\t\t\t\t\tcnt = count(carr, c, nx, ny, cnt + 1);\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\t/**\n\t * @param carr\n\t * @param j : dfsした結果置換するやつ\n\t * @param x : x座標\n\t * @param y : y座標\n\t */\n\tprivate static void dfs(byte[][] carr, int before, int after, int x, int y) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = (byte) after;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == before && before != after)\n\t\t\t\t\tdfs(carr, before, after, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static byte[][] cp2dIntArray(byte[][] x) {\n\t\tbyte[][] ret = new byte[x.length][];\n\t\tfor(int i=0; i < x.length; i++)\n\t\t\tret[i] = x[i].clone();\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int h;\n    static int w;\n    static int c;\n    static int ans;\n    static int count;\n    static int[] color_order;\n    static int[][] map;\n    static int[][] tmp;\n\n    public static void main(String[] args) throws java.io.IOException {\n\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            h = sc.nextInt();\n            w = sc.nextInt();\n            c = sc.nextInt();\n            if ((h | w | c) == 0)\n                break;\n            ans =0;\n            map = new int[h][w];\n            tmp = new int[h][w];\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                    map[i][j] = sc.nextInt();\n            color_order = new int[5];\n            for (int i = 1; i <= 6; i++) {\n                for (int j = 1; j <= 6; j++) {\n                    for (int k = 1; k <= 6; k++) {\n                        for (int l = 1; l <= 6; l++) {\n                            color_order[0] = i;\n                            color_order[1] = j;\n                            color_order[2] = k;\n                            color_order[3] = l;\n                            color_order[4] = c;\n                            for (int m = 0; m < h; m++)\n                                for (int n = 0; n < w; n++)\n                                    tmp[m][n] = map[m][n];\n                            count =0;\n                            ele();\n                            ans = Math.max(ans,count);\n                        }\n                    }\n                }\n\n            }\n            System.out.println(ans);\n\n        }\n    }\n\n    public static void ele() {\n        for (int i = 0; i < 5; i++) {\n            if (tmp[0][0] == color_order[i])\n                continue;\n            flip(0,0,tmp[0][0],color_order[i]);\n        }\n        solve(0,0);\n    }\n\n    public static void flip(int x, int y, int from,int to) {\n        int dx[] = { 1, 0, -1, 0 };\n        int dy[] = { 0, 1, 0, -1 };\n        tmp[y][x] = to;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx>=0&&ny>=0&&ny<h&&nx<w&&tmp[ny][nx] == from){\n                flip(nx,ny,tmp[ny][nx],to);\n\n\n                }\n            }\n        }\n    public static void solve(int x,int y){\n\n        int dx[] = { 1, 0, -1, 0 };\n        int dy[] = { 0, 1, 0, -1 };\n        count++;\n        tmp[y][x] =0;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx>=0&&ny>=0&&ny<h&&nx<w&&tmp[ny][nx]!=0&&c== tmp[ny][nx] ){\n                solve(nx,ny);\n\n\n                }\n            }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int h,w,c,max;\n\tstatic byte[][] panel;\n\tstatic byte[] v1={0,1,0,-1};\n\tstatic byte[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\th=cin.nextInt();\n\t\t\tw=cin.nextInt();\n\t\t\tc=cin.nextInt();\n\t\t\tmax=-1;\n\t\t\tif(h+w+c==0)break;\n\t\t\tpanel=new byte[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[i][j]=cin.nextByte();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\tstatic void bt(int depth){\n\t\tif(depth==5){\n\t\t\tint ans=0;\n\t\t\tif(panel[0][0]==c){\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\t\t\tSystem.out.print(panel[i][j]+\" \");\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\t\tq.add(new byte[]{0,0});\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\t\tbyte x=aaa[0];\n\t\t\t\t\tbyte y=aaa[1];\n\t\t\t\t\tif(panel[x][y]==-1)continue;\n\t\t\t\t\tpanel[x][y]=-1;\n\t\t\t\t\tans++;\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tbyte xx=(byte) (x+v1[j]);\n\t\t\t\t\t\tbyte yy=(byte) (y+v2[j]);\n\t\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\t\tif(panel[xx][yy]!=c)continue;\n\t\t\t\t\t\tq.add(new byte[]{xx,yy});\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(ans);\t\n\t\t\t\tmax=Math.max(ans,max);\n\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(byte i=1;i<=6;i++){\n\t\t\tif(panel[0][0]==i)continue;\n\t\t\tbyte[][] cp = new byte[h][w];\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcp[k][j]=panel[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint color=panel[0][0];\n\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\tq.add(new byte[]{0,0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte x=aaa[0];\n\t\t\t\tbyte y=aaa[1];\n\t\t\t\tpanel[x][y]=i;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte xx=(byte) (x+v1[j]);\n\t\t\t\t\tbyte  yy=(byte) (y+v2[j]);\n\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\tif(panel[xx][yy]!=color)continue;\n\t\t\t\t\tq.add(new byte[]{xx,yy});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(depth+1);\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[k][j]=cp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1174();\n\t}\n\tclass AOJ1174{\n\t\tAOJ1174(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt(); W=sc.nextInt(); C=sc.nextInt();\n\t\t\t\tif((H|(W|C))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tint H,W,C;\n\t\tint[][][] b;\n\t\tfinal int[] vx={0,-1,0,1},vy={-1,0,1,0};\n\t\tvoid solve(){\n\t\t\tb=new int[6][W][H];\n\t\t\tfor(int h=0; h<H; ++h)for(int w=0; w<W; ++w)\tb[0][w][h]=sc.nextInt();\n\t\t\tSystem.out.println(backtracking(b,0));\n\t\t}\n\t\tint backtracking(int[][][] b,int depth){\n\t\t\tif(depth>=4)\treturn cnt(chg(depth, C));\n\t\t\tint ret=0;\n\t\t\tfor(int c=1; c<=6; ++c){\n\t\t\t\tif(c==b[depth][0][0])\tcontinue;\n\t\t\t\tchg(depth, c);\n\t\t\t\tret=max(ret, backtracking(b, depth+1));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tint[][] chg(int d,int target){\n\t\t\tfor(int w=0; w<W; ++w)for(int h=0; h<H; ++h)\tb[d+1][w][h]=b[d][w][h];\n\t\t\tb[d+1][0][0]=target;\n\t\t\tchg(d,0,0,target);\n\t\t\treturn b[d+1];\n\t\t}\n\t\tvoid chg(int d,int x,int y,int target){\n\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\tint nx=x+vx[v],ny=y+vy[v];\n\t\t\t\tif(!(0<=nx&&nx<W && 0<=ny&&ny<H))\tcontinue;\n\t\t\t\tif(b[d][nx][ny]!=b[d][0][0])\tcontinue;\n\t\t\t\tif(b[d+1][nx][ny]==target)\tcontinue;\n\t\t\t\tb[d+1][nx][ny]=target;\n\t\t\t\tchg(d,nx,ny,target);\n\t\t\t}\n\t\t}\n\t\tint cnt(int[][] a){\n\t\t\treturn cnt(a,0,0,a[0][0]);\n\t\t}\n\t\tint cnt(int[][] a,int x,int y,int c){\n\t\t\tint ret=1;\n\t\t\ta[x][y]=-1;\n\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\tint nx=x+vx[v],ny=y+vy[v];\n\t\t\t\tif(!(0<=nx&&nx<W && 0<=ny&&ny<H))\tcontinue;\n\t\t\t\tif(a[nx][ny]!=c)\tcontinue;\n\t\t\t\tret+=cnt(a, nx, ny, c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint ni[] ={-1,0,1,0};\n\tint nj[] ={0,-1,0,1};\n\tint h ;\n\tint w ;\n\tint c ;\n\t\n\tvoid label2(int i , int j , int prev, int post, int [][] map){\n\t\tfor(int z=  0; z < 4; z++){\n\t\t\tint nni = i + ni[z];\n\t\t\tint nnj = j + nj[z];\n\t\t\t\n\t\t\tif(nni < 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(nni  >= h ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(nnj < 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(nnj  >= w ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[nni][nnj] != prev){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[nni][nnj] = post;\n\t\t\tlabel2(nni,nnj,prev,post,map);\n\t\t}\n\t}\n\t\n\tvoid fill(int prev,int post, int map[][]){\n\t\tfor(int i = 0; i < h ; i ++){\n\t\t\tfor(int j= 0; j < w ; j++){\n\t\t\t\tif(map[i][j] == prev){\n\t\t\t\t\tmap[i][j] = post;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid label(int [][] map, int color){\n\t\tint prev1 = map[0][0];\n\t\tmap[0][0] = -1;\n\t\tthis.label2(0, 0, prev1, -1, map);\n\t\tfill(-1,color,map);\n\t}\n\tint count( int map[][]){\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < h ; i ++){\n\t\t\tfor(int j= 0; j < w ; j++){\n\t\t\t\tif(map[i][j] ==-1){\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tint labelz(int [][] map, int color){\n\t\t\n\t\tint prev1 = map[0][0];\n\t\tmap[0][0] = -1;\n\t\tthis.label2(0, 0, prev1, -1, map);\n\t\tthis.fill(-1, color, map);\n\t\tmap[0][0] = -1;\n\t\tthis.label2(0, 0,color, -1, map);\n\t\treturn count(map);\n\t}\n\n\tint[][] clone(int map[][]){\n\t\tint[][] ret = new int[map.length][];\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tret[i] = map[i].clone();\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid run(){\n\t\tfor(;;){\n\t\t\th =sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif((h|w|c) == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint map [][] = new int[h][w];\n\t\t\tc--;\n\t\t\tfor(int i = 0; i < h ; i ++){\n\t\t\t\tfor(int j = 0 ; j < w ; j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt() -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\t\n\t\t\tfor(int g = 0; g < 6; g++){\n\t\t\t\tint mapg[][] = clone(map);\n\t\t\t\tlabel(map,g);\n\t\t\t\tfor(int f = 0 ; f < 6 ; f++){\n\t\t\t\t\tint mapf[][] = clone(map);\n\t\t\t\t\tlabel(map,f);\n\t\t\t\t\tfor(int e = 0; e < 6; e++){\n\t\t\t\t\t\tint mape[][] = clone(map);\n\t\t\t\t\t\tlabel(map,e);\n\t\t\t\t\t\tfor(int d = 0 ; d < 6 ; d++){\n\t\t\t\t\t\t\tint mapd[][] = clone(map);\n\t\t\t\t\t\t\tlabel(map,d);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tres = Math.max(labelz(map,c),res);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmap = mapd;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap = mape;\n\t\t\t\t\t}\n\t\t\t\t\tmap = mapf;\n\t\t\t\t}\n\t\t\t\tmap = mapg;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t\t\n\t\t}\t\t\n\t}\n\tpublic static void main(String[] args){\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n      \n      \npublic class Main {\n    static int[] vx = new int[] {0,1,0,-1};\n    static int[] vy = new int[] {1,0,-1,0};\n    static int Y;\n    static int X;\n    static int MIN;\n    static int TAR;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(true) {\n            int y = sc.nextInt();\n            int x = sc.nextInt();\n            int c = sc.nextInt();\n            X = x;\n            Y = y;\n            TAR = c;\n            if(x == 0 && y == 0) break;\n            int[][] map = new int[y][x];\n            for(int i = 0; i < Y; i++) {\n                for(int j = 0; j < X; j++) {\n                    map[i][j] = sc.nextInt();\n                }\n            }\n            boolean[][] same = new boolean[Y][X];\n            same[0][0] = true;\n            cc(map,same,new boolean[Y][X],0,0);\n            MIN = Integer.MAX_VALUE;\n            int count = dfs(map,same,0);\n            System.out.println(count);\n        }\n    }\n    static int dfs(int[][] map, boolean[][] same, int count) {\n        int c = map[0][0];\n        if(count == 5) {\n        \tint sum = 0;\n        \tcc(map,same,new boolean[Y][X],0,0);\n\t        for(int i = 0; i < Y; i++) {\n\t            for(int j = 0; j < X; j++) {\n\t                if(same[i][j]) {\n\t                \tsum++;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n        }\n        int ret = 0;\n        int[][]    before = new int[Y][X];\n        boolean[][] check  = new boolean[Y][X];\n        if(count == 4) {\n        \t for(int j = 0; j < Y; j++) {\n                 before[j] = Arrays.copyOf(map[j]  , X);\n                 check[j]  = Arrays.copyOf(same[j] , X);\n             }\n             for(int j = 0; j < Y; j++) {\n                 for(int k = 0; k < X; k++) {\n                     if(check[j][k]) before[j][k] = TAR;\n                 }\n             }\n             boolean go = cc(before,check,new boolean[Y][X],0,0);\n             ret = Math.max(dfs(before,check,count+1),ret);\n             return ret;\n        }\n        for(int i = 1; i <= 6; i++) {\n            for(int j = 0; j < Y; j++) {\n                before[j] = Arrays.copyOf(map[j]  ,  X);\n                check[j]  = Arrays.copyOf(same[j] ,  X);\n            }\n            for(int j = 0; j < Y; j++) {\n                for(int k = 0; k < X; k++) {\n                    if(check[j][k]) before[j][k] = i;\n                }\n            }\n            boolean go = cc(before,check,new boolean[Y][X],0,0);\n            ret = Math.max(dfs(before,check,count+1),ret);\n        }\n        return ret;\n    }\n    static boolean cc(int[][] a, boolean[][] b, boolean[][] oc,int y, int x) {\n        boolean ok = false;\n        if(oc[y][x]) return ok;\n        oc[y][x] = true;\n        for(int k = 0; k < 4; k++) {\n            int ty = vy[k] + y;\n            int tx = vx[k] + x;\n            if(ty < 0 || tx < 0 || ty >= Y || tx >= X) continue;\n            if(a[y][x] == a[ty][tx]) {\n                ok |= !b[ty][tx];\n                b[ty][tx] = true;\n                if(!oc[ty][tx])\n                ok |= cc(a,b,oc,ty,tx);\n            }\n        }\n        return ok;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int h;\n\tstatic int w;\n\tstatic int c;\n\tstatic int cnt;\n\tstatic int[][] p;\n\tstatic int[][] tmp;\n\tstatic int[][] move = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\tstatic int[] order;\n\tstatic boolean[][] jud;\n\t\n\tstatic void e() {\n\t\tfor(int k=0; k<5; k++) {\n\t\t\tif(tmp[0][0] == order[k]) continue;\n\t\t\tf(0, 0, tmp[0][0], order[k]);\n\t\t}\n\t\tcnt = 0;\n\t\tjud = new boolean[h][w];\n\t\tv(0, 0);\n\t}\n\t\n\tstatic void v(int i, int j) {\n\t\tif(tmp[i][j] != c) return;\n\t\tcnt++;\n\t\tjud[i][j] = true;\n\t\tfor(int k=0; k<4; k++) {\n\t\t\tint newi = i + move[k][0];\n\t\t\tint newj = j + move[k][1];\n\t\t\tif(0 <= newi && newi < h && 0 <= newj && newj < w && !jud[newi][newj]) {\n\t\t\t\tv(newi, newj);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void f(int i, int j, int from, int to) {\n\t\tif(tmp[i][j] != from) return;\n\t\ttmp[i][j] = to;\n\t\tfor(int k=0; k<4; k++) {\n\t\t\tint newi = i + move[k][0];\n\t\t\tint newj = j + move[k][1];\n\t\t\tif(0 <= newi && newi < h && 0 <= newj && newj < w) {\n\t\t\t\tf(newi, newj, from, to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tp = new int[h][w];\n\t\t\ttmp = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\tp[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\torder = new int[5];\n\t\t\tfor(int i=1; i<=6; i++) {\n\t\t\t\tfor(int j=1; j<=6; j++) {\n\t\t\t\t\tfor(int k=1; k<=6; k++) {\n\t\t\t\t\t\tfor(int l=1; l<=6; l++) {\n\t\t\t\t\t\t\torder[0] = i;\n\t\t\t\t\t\t\torder[1] = j;\n\t\t\t\t\t\t\torder[2] = k;\n\t\t\t\t\t\t\torder[3] = l;\n\t\t\t\t\t\t\torder[4] = c;\n\t\t\t\t\t\t\tfor(int x=0; x<h; x++) {\n\t\t\t\t\t\t\t\tfor(int y=0; y<w; y++) {\n\t\t\t\t\t\t\t\t\ttmp[x][y] = p[x][y];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te();\n\t\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static int[][] vec = {{0,1},{0,-1},{1,0},{-1,0}};\n\n\tpublic static void printer(int[][] field) {\n\t\tfor(int i=0; i<field.length; i++) {\n\t\t\tfor(int j=0; j<field[0].length; j++) {\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static int counter(int[][] field) {\n\t\tint c = field[0][0];\n\t\tfield[0][0] = 0;\n\t\tQueue<int[]> q = new ArrayDeque<int[]>();\n\t\tint count = 1;\n\t\tint[] def = {0,0};\n\t\tq.add(def);\n\t\twhile(!q.isEmpty()) {\n\t\t\tint[] n = q.remove();\n\t\t\tint x = n[0];\n\t\t\tint y = n[1];\n\t\t\tfor(int[] d: vec) {\n\t\t\t\tint dx = d[0];\n\t\t\t\tint dy = d[1];\n\t\t\t\tif(x+dx<0 || field.length<=x+dx || y+dy<0 || field[0].length<=y+dy) continue;\n\t\t\t\tif(field[x+dx][y+dy]==c) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tfield[x+dx][y+dy]=0;\n\t\t\t\t\tint[] dn = {x+dx,y+dy};\n\t\t\t\t\tq.add(dn);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static int[][] changeColor(int c, int[][] field) {\n\t\tint[][] newField = new int[field.length][field[0].length];\n\t\tfor(int i=0; i<field.length; i++) {\n\t\t\tfor(int j=0; j<field[0].length; j++) {\n\t\t\t\tnewField[i][j] = field[i][j];\n\t\t\t}\n\t\t}\n\t\tnewField[0][0] = c;\n\t\tQueue<int[]> q = new ArrayDeque<int[]>();\n\t\tboolean[][] changed = new boolean[field.length][field[0].length];\n\t\tint[] def = {0,0};\n\t\tchanged[0][0] = true;\n\t\tq.add(def);\n\t\twhile(!q.isEmpty()) {\n\t\t\tint[] n = q.remove();\n\t\t\tint x = n[0];\n\t\t\tint y = n[1];\n\t\t\tfor(int[] d: vec) {\n\t\t\t\tint dx = d[0];\n\t\t\t\tint dy = d[1];\n\t\t\t\tif(x+dx<0 || field.length<=x+dx || y+dy<0 || field[0].length<=y+dy) continue;\n\t\t\t\tif(field[x+dx][y+dy]==field[0][0]) {\n\t\t\t\t\tif(!changed[x+dx][y+dy]) {\n\t\t\t\t\t\tnewField[x+dx][y+dy] = c;\n\t\t\t\t\t\tchanged[x+dx][y+dy] = true;\n\t\t\t\t\t\tint[] dn = {x+dx,y+dy};\n\t\t\t\t\t\tq.add(dn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newField;\n\t}\n\n\tpublic static int electro(int count, int[][] field, int last) {\n\t\tif(count == 4) {\n\t\t\tint[][] newField = changeColor(last, field);\n\t\t\treturn counter(newField);\n\t\t}\n\t\tint maxSize=0;\n\t\tfor(int i=1; i<7; i++) {\n\t\t\tint[][] newField = changeColor(i, field);\n\t\t\tmaxSize = Math.max(maxSize, electro(count+1, newField, last));\n\t\t}\n\t\treturn maxSize;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\twhile(true) {\n\t\t\tint h = r.nextInt();\n\t\t\tint w = r.nextInt();\n\t\t\tint c = r.nextInt();\n\t\t\tif(h==0) break;\n\t\t\tint[][] field = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\tfield[i][j] = r.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(electro(0, field, c));\n\t\t}\n\t}\n\t\n\tpublic static void solver() {\n\t\t// write logic\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W, C;\n\tstatic int[][][] f;\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\tstatic int ans;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tW = sc.nextInt();\n\t\t\tC = sc.nextInt();\n\t\t\tf = new int[6][H][W];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tf[0][i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 0;\n\t\t\trec(0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void rec(int level) {\n\t\tif (level == 4) {\n\t\t\tchange(C, level);\n\t\t\tcount();\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= 6; ++i) {\n\t\t\tchange(i, level);\n\t\t\trec(level + 1);\n\t\t}\n\t}\n\n\tstatic void change(int color, int level) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tSystem.arraycopy(f[level][i], 0, f[level + 1][i], 0, W);\n\t\t}\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(0);\n\t\tboolean[][] used = new boolean[H][W];\n\t\tused[0][0] = true;\n\t\tint sc = f[level][0][0];\n\t\twhile (!q.isEmpty()) {\n\t\t\tint pos = q.poll();\n\t\t\tint cr = pos >> 8;\n\t\t\tint cc = pos & 0xFF;\n\t\t\tf[level + 1][cr][cc] = color;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint nr = cr + DR[i];\n\t\t\t\tint nc = cc + DC[i];\n\t\t\t\tif (nr < 0 || H <= nr || nc < 0 || W <= nc || used[nr][nc]) continue;\n\t\t\t\tif (f[level + 1][nr][nc] != sc) continue;\n\t\t\t\tq.add((nr << 8) + nc);\n\t\t\t\tused[nr][nc] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void count() {\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(0);\n\t\tboolean[][] used = new boolean[H][W];\n\t\tused[0][0] = true;\n\t\tint count = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tint pos = q.poll();\n\t\t\tint cr = pos >> 8;\n\t\t\tint cc = pos & 0xFF;\n\t\t\t++count;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint nr = cr + DR[i];\n\t\t\t\tint nc = cc + DC[i];\n\t\t\t\tif (nr < 0 || H <= nr || nc < 0 || W <= nc || used[nr][nc]) continue;\n\t\t\t\tif (f[5][nr][nc] != f[5][0][0]) continue;\n\t\t\t\tq.add((nr << 8) + nc);\n\t\t\t\tused[nr][nc] = true;\n\t\t\t}\n\t\t}\n\t\tans = Math.max(ans, count);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  static int w,h,c;\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    while(true) {\n      w = scan.nextInt();\n      h = scan.nextInt();\n      c = scan.nextInt();\n      if(w==0) break;\n      int[][] arr = new int[w][h];\n      for(int i = 0; i < w; i++) {\n        for(int j = 0; j < h; j++) {\n          arr[i][j] = scan.nextInt();\n        }\n      }\n      int result = calc(arr,1,c);\n      System.out.println(result);\n    }\n  }\n\n  static int calc(int[][] arr, int count, int lastColor) {\n    int result = 0;\n    for(int i = 1; i <= 6; i++) {\n      if(arr[0][0]==i) continue;\n      int[][] copyArr = cloneArray(arr);\n      changeColor(copyArr,i,0,0,new boolean[w][h]);\n/*\n        System.out.println(count+\",\"+i);\n        for(int j = 0; j < arr.length; j++) System.out.println(Arrays.toString(copyArr[j]));\n        System.out.println();\n*/\n      if(count==5) {\n        result = Math.max(result,countColor(copyArr,lastColor,0,0,new boolean[w][h]));\n      }else {\n        result = Math.max(result,calc(copyArr,count+1,lastColor));\n      }\n    }\n    return result;\n  }\n\n  static void changeColor(int[][] arr, int color, int x, int y, boolean[][] checked) {\n    if(checked[x][y]) return;\n    checked[x][y] = true;\n    if(x+1<arr.length && arr[x+1][y]==arr[x][y]) changeColor(arr,color,x+1,y,checked);\n    if(y+1<arr[x].length && arr[x][y+1]==arr[x][y]) changeColor(arr,color,x,y+1,checked);\n    if(x-1>=0 && arr[x-1][y]==arr[x][y]) changeColor(arr,color,x-1,y,checked);\n    if(y-1>=0 && arr[x][y-1]==arr[x][y]) changeColor(arr,color,x,y-1,checked);\n    arr[x][y] = color;\n  }\n\n  static int countColor(int[][] arr, int color, int x, int y, boolean[][] checked) {\n    if(checked[x][y]) return 0;\n    checked[x][y] = true;\n    int result = 0;\n    if(x+1<arr.length && arr[x+1][y]==arr[x][y]) result+=countColor(arr,color,x+1,y,checked);\n    if(y+1<arr[x].length && arr[x][y+1]==arr[x][y]) result+=countColor(arr,color,x,y+1,checked);\n    if(x-1>=0 && arr[x-1][y]==arr[x][y]) result+=countColor(arr,color,x-1,y,checked);\n    if(y-1>=0 && arr[x][y-1]==arr[x][y]) result+=countColor(arr,color,x,y-1,checked);\n    if(arr[x][y] == color) result++;\n    return result;\n  }\n\n  static int[][] cloneArray(int[][] arr) {\n    int[][] returnArray = new int[arr.length][];\n    for(int i = 0; i < arr.length; i++) {\n      returnArray[i] = new int[arr[i].length];\n      for(int j = 0; j < arr[i].length; j++) {\n        returnArray[i][j] = arr[i][j];\n      }\n    }\n    return returnArray;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\npublic class Main{\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1174();\n\t}\n\t\n\tclass AOJ1174{\n\t\tAOJ1174(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\th=sc.nextInt();\n\t\t\t\tw=sc.nextInt();\n\t\t\t\tc=sc.nextInt();\n\t\t\t\tif(h==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tint h,w,c;\n\t\tint[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tvoid solve(){\n\t\t\tint[][] b=new int[w][h];\n\t\t\tfor(int y=0; y<h; ++y)for(int x=0; x<w; ++x)\tb[x][y]=sc.nextInt();\n\t\t\tSystem.out.println(dfs(b, 1, -1));\n\t\t}\n\t\tint dfs(int[][] b,int depth,int last){\n\t\t\t// debug\n//\t\t\tSystem.out.println(depth);\n\t\t\tif(depth>=5){\n\t\t\t\tint[][] b2=change(b, c);\n\t\t\t\treturn cnt(b2);\n\t\t\t}\n\t\t\tint ret=1;\n\t\t\tfor(int i=1; i<=6; ++i){\n\t\t\t\tif(i==last)\tcontinue;\n\t\t\t\tret=max(ret, dfs(change(b, i), depth+1, i));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tint[][] change(int[][] b,int target){\n\t\t\tint base=b[0][0];\n\t\t\tLinkedList<Pair> open=new LinkedList<Pair>();\n\t\t\topen.add(new Pair(0,0));\n\t\t\tint[][] nb=new int[w][h];\n\t\t\tfor(int x=0; x<w; ++x)for(int y=0; y<h; ++y)\tnb[x][y]=b[x][y];\n\t\t\tnb[0][0]=target;\n\t\t\tboolean[][] closed=new boolean[w][h];\n\t\t\tclosed[0][0]=true;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPair now=open.poll();\n\t\t\t\t// debug\n//\t\t\t\tSystem.out.println(now);\n\t\t\t\tif(b[now.x][now.y]==base){\n\t\t\t\t\tnb[now.x][now.y]=target;\n\t\t\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i];\n\t\t\t\t\t\tif(!(0<=xx&&xx<w && 0<=yy&&yy<h))\tcontinue;\n\t\t\t\t\t\tif(closed[xx][yy])\tcontinue;\n\t\t\t\t\t\topen.add(new Pair(xx,yy));\n\t\t\t\t\t\tclosed[xx][yy]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nb;\n\t\t}\n\t\tint cnt(int[][] b){\n\t\t\t\n//\t\t\tfor(int y=0; y<h; ++y){\n//\t\t\t\tfor(int x=0; x<w; ++x)System.out.print(b[x][y]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tint base=b[0][0],\n\t\t\t\tret=0;\n\t\t\tLinkedList<Pair> open=new LinkedList<Pair>();\n\t\t\topen.add(new Pair(0,0));\n\t\t\tboolean[][] closed=new boolean[w][h];\n\t\t\tclosed[0][0]=true;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPair now=open.poll();\n\t\t\t\tif(b[now.x][now.y]==base){\n\t\t\t\t\t++ret;\n\t\t\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i];\n\t\t\t\t\t\tif(!(0<=xx&&xx<w && 0<=yy&&yy<h))\tcontinue;\n\t\t\t\t\t\tif(closed[xx][yy])\tcontinue;\n\t\t\t\t\t\topen.add(new Pair(xx,yy));\n\t\t\t\t\t\tclosed[xx][yy]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(ret);\n//\t\t\tSystem.out.println();\n\t\t\treturn ret;\n\t\t}\n\t\tclass Pair{\n\t\t\tint x,y;\n\t\t\tPair(int x,int y){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int h,w,c,max;\n\tstatic byte[][] panel;\n\tstatic byte[] v1={0,1,0,-1};\n\tstatic byte[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\th=cin.nextInt();\n\t\t\tw=cin.nextInt();\n\t\t\tc=cin.nextInt();\n\t\t\tmax=-1;\n\t\t\tif(h+w+c==0)break;\n\t\t\tpanel=new byte[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[i][j]=cin.nextByte();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\tstatic void bt(int depth){\n\t\tif(depth==5){\n\t\t\tint ans=0;\n\t\t\tif(panel[0][0]==c){\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\t\t\tSystem.out.print(panel[i][j]+\" \");\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\t\tq.add(new byte[]{0,0});\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\t\tbyte x=aaa[0];\n\t\t\t\t\tbyte y=aaa[1];\n\t\t\t\t\tif(panel[x][y]==-1)continue;\n\t\t\t\t\tpanel[x][y]=-1;\n\t\t\t\t\tans++;\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tbyte xx=(byte) (x+v1[j]);\n\t\t\t\t\t\tbyte yy=(byte) (y+v2[j]);\n\t\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\t\tif(panel[xx][yy]!=c)continue;\n\t\t\t\t\t\tq.add(new byte[]{xx,yy});\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(ans);\t\n\t\t\t\tmax=Math.max(ans,max);\n\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(byte i=1;i<=6;i++){\n\t\t\tif(panel[0][0]==i)continue;\n\t\t\tbyte[][] cp = new byte[h][w];\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcp[k][j]=panel[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint color=panel[0][0];\n\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\tq.add(new byte[]{0,0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte x=aaa[0];\n\t\t\t\tbyte y=aaa[1];\n\t\t\t\tif(panel[x][y]!=color)continue;\n\t\t\t\tpanel[x][y]=i;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte xx=(byte) (x+v1[j]);\n\t\t\t\t\tbyte  yy=(byte) (y+v2[j]);\n\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\tif(panel[xx][yy]!=color)continue;\n\t\t\t\t\t\n\t\t\t\t\tq.add(new byte[]{xx,yy});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(depth+1);\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[k][j]=cp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w, c;\n    int max;\n    int[][] p;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt(); w = sc.nextInt(); c = sc.nextInt();\n            if(h==0 && w==0 && c==0) break;\n\n            p = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p[i][j] = sc.nextInt();\n\n            max = 0;\n            rec(0);\n            System.out.println(max);\n        }\n    }\n\n    int[] num = new int[5];\n\n    void rec(int cnt){\n        if(cnt==5){\n            if(num[4]!=c) return;\n            int[][] p2 = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p2[i][j] = p[i][j];\n            for(int i=0; i<5; i++){\n                if(num[i]==p2[0][0]) continue;\n                p2 = changeColor(p2, num[i]);\n            }\n            int cc = countColor(p2);\n            max = Math.max(max, cc);\n            return;\n        }\n\n        for(int i=1; i<=6; i++){\n            num[cnt] = i;\n            rec(cnt + 1);\n        }\n    }\n\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n\n    int[][] changeColor(int[][] p, int color){\n        /*\n        System.out.println(\"before\");\n        for(int i=0; i<h; i++)\n            System.out.println(Arrays.toString(p[i]));\n        */\n        int before = p[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        p[0][0] = color;\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p[ny][nx]!=before || v[ny][nx]) continue;\n                p[ny][nx] = color;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        /*\n        System.out.println(\"after\");\n        for(int i=0; i<h; i++)\n            System.out.println(Arrays.toString(p[i]));\n        */\n        return p;\n    }\n    int countColor(int[][] p){\n        int target = p[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        int cnt = 0;\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n            cnt++;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p[ny][nx]!=target || v[ny][nx]) continue;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w, c;\n    int max;\n    int[][] p;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt(); w = sc.nextInt(); c = sc.nextInt();\n            if(h==0 && w==0 && c==0) break;\n\n            p = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p[i][j] = sc.nextInt();\n\n            max = 0;\n            rec(0);\n            System.out.println(max);\n        }\n    }\n\n    int[] num = new int[5];\n    int[][] p2;\n\n    void rec(int cnt){\n        if(cnt==5){\n            if(num[4]!=c) return;\n            p2 = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p2[i][j] = p[i][j];\n            for(int i=0; i<5; i++){\n                if(num[i]==p2[0][0]) continue;\n                changeColor(num[i]);\n            }\n            int cc = countColor();\n            max = Math.max(max, cc);\n            return;\n        }\n\n        for(int i=1; i<=6; i++){\n            num[cnt] = i;\n            rec(cnt + 1);\n        }\n    }\n\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n\n    void changeColor(int color){\n        int before = p2[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        p2[0][0] = color;\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p2[ny][nx]!=before || v[ny][nx]) continue;\n                p2[ny][nx] = color;\n                q.add(new int[]{nx, ny});\n            }\n        }\n    }\n    int countColor(){\n        int target = p2[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        int cnt = 0;\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n            cnt++;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p2[ny][nx]!=target || v[ny][nx]) continue;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tint c;\t\t// finish color\n\tint h;\n\tint w;\n\tint max;\n\tint tmp;\n\tboolean[][] comb;\n\tint z = 0;\n\t\n\tvoid Join(int[][] pane, int i, int j){\n\t\tif(i<0||i>=h||j<0||j>=w||comb[i][j]==true||pane[i][j]!=pane[0][0]){\n\t\t\treturn;\n\t\t}\n\t\ttmp++;\n\t\tcomb[i][j] = true;\n\t\tJoin(pane,i+1,j);\n\t\tJoin(pane,i,j+1);\n\t\tJoin(pane,i-1,j);\n\t\tJoin(pane,i,j-1);\n\t}\n\t\n\tvoid Color(int pane[][], int cnt){\n\t\t// 結合する\n\t\tcomb = new boolean[h][w];\n\t\ttmp = 0;\n//\t\tif(z++>20){\n//\t\t\tSystem.exit(0);\n//\t\t}\n\t\tJoin(pane,0,0);\n//\t\tSystem.out.println(\"結合状態\");\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tSystem.out.println(Arrays.toString(comb[i]));\n//\t\t}\n\t\tmax = Math.max(max,tmp);\n//\t\tSystem.out.println(\"最大値\"+max);\n\t\tif(cnt==4){\n//\t\t\tSystem.out.println(\"5回目 \"+c+\"に彩色\");\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(comb[j][k]){\n\t\t\t\t\t\tpane[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"設定色\");\n//\t\t\tfor(int j=0;j<h;j++){\n//\t\t\t\tSystem.out.println(Arrays.toString(pane[j]));\n//\t\t\t}\n\t\t\tColor(pane,++cnt);\n\t\t\treturn;\n\t\t}\n\t\telse if(cnt==5){\n\t\t\treturn;\n\t\t}\n\t\tcnt++;\n\t\tfor(int i=1;i<=6;i++){\n//\t\t\tSystem.out.println(cnt+\"回目 \"+i+\"に彩色\");\n\t\t\tint[][] copy = new int[h][w];\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tcopy[j][k] = pane[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][] copy_comb = new boolean[h][w];\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tcopy_comb[j][k] = comb[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(comb[j][k]){\n\t\t\t\t\t\tpane[j][k] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"設定色\");\n//\t\t\tfor(int j=0;j<h;j++){\n//\t\t\t\tSystem.out.println(Arrays.toString(pane[j]));\n//\t\t\t}\n\t\t\tColor(pane,cnt);\n//\t\t\tSystem.out.println(\"戻し\");\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tpane[j][k] = copy[j][k];\n\t\t\t\t\tcomb[j][k] = copy_comb[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner stdIn = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\th = stdIn.nextInt();\n\t\t\tw = stdIn.nextInt();\n\t\t\tc = stdIn.nextInt();\n\t\t\tif((h|w|c)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] pane = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpane[i][j] = stdIn.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tColor(pane,0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n\tScanner sc;\n\tpublic void run(){\n\t\tsc = new Scanner(System.in);\n\t\twhile(sc.hasNextInt()){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tif(h == 0 && w == 0 && c == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcalc(h,w,c);\n\t\t\t}\n\t\t}\n\t}\n\tint max;\n\tint x[] = new int[]{0,1,0,-1};\n\tint y[] = new int[]{1,0,-1,0};\n\tpublic void calc(int h, int w, int c){\n\t\tmax = 0;\n\t\tint[][] panel = new int[h][w];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tpanel[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tcalcPanel(panel, h, w, c, 1);\n\t\tSystem.out.println(max);\n\t}\n\tpublic void calcPanel(int[][] panel, int h, int w, int c, int count){\n\t\tif(count == 5){\n\t\t\tint[][] newPanel = change(panel, h, w, c);\n\t\t\tcheck(newPanel, h, w);\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 1; i < 7; i++){\n\t\t\t\tint[][] newPanel = change(panel, h, w, i);\n\t\t\t\tcalcPanel(newPanel, h, w, c, count + 1);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void check(int[][] panel, int h, int w){\n\t\tint[][] checkPanel = new int[h][w];\n\t\tcheckPanel[0][0] = 1;\n\t\t\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\t\tlist.add(new int[]{0,0});\n\t\t\n\t\tint m = 1;\n\t\t\n\t\twhile(list.size() != 0){\n\t\t\tint i = list.get(0)[0];\n\t\t\tint j = list.get(0)[1];\n\t\t\tlist.remove(0);\n\t\t\t\n\t\t\tfor(int t = 0; t < 4; t++){\n\t\t\t\tint i1 = i + x[t];\n\t\t\t\tint j1 = j + y[t];\n\t\t\t\tif(i1 >= 0 && i1 < h && j1 >= 0 && j1 < w){\n\t\t\t\t\tif(checkPanel[i1][j1] == 0 && panel[i1][j1] == panel[0][0]){\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tlist.add(new int[]{i1, j1});\n\t\t\t\t\t\tcheckPanel[i1][j1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m > max) max = m;\n\t}\n\tpublic int[][] change(int[][] panel, int h, int w, int color){\n\t\tint[][] newPanel = new int[h][w];\n\t\tint[][] checkPanel = new int[h][w];\n\t\tnewPanel[0][0] = color;\n\t\tcheckPanel[0][0] = 1;\n\t\t\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\t\tlist.add(new int[]{0,0});\n\t\t\n\t\twhile(list.size() != 0){\n\t\t\tint i = list.get(0)[0];\n\t\t\tint j = list.get(0)[1];\n\t\t\tlist.remove(0);\n\t\t\t\n\t\t\tfor(int t = 0; t < 4; t++){\n\t\t\t\tint i1 = i + x[t];\n\t\t\t\tint j1 = j + y[t];\n\t\t\t\t\n\t\t\t\tif(i1 >= 0 && i1 < h && j1 >= 0 && j1 < w){\n\t\t\t\t\tif(checkPanel[i1][j1] == 0 && panel[i1][j1] == panel[0][0]){\n\t\t\t\t\t\tnewPanel[i1][j1] = color;\n\t\t\t\t\t\tlist.add(new int[]{i1, j1});\n\t\t\t\t\t\tcheckPanel[i1][j1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(newPanel[i][j] == 0){\n\t\t\t\t\tnewPanel[i][j] = panel[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newPanel;\n\t}\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Identically Colored Panels Connection\n */\npublic class Main {\n\n\tenum COLOR {\n\t\tNONE, YELLOW, PINK, RED, PURPLE, GREEN, BLUE,\n\t}\n\n\tstatic int[][] DIR = {\n\t\t\t{1, 0},\n\t\t\t{0, 1},\n\t\t\t{-1, 0},\n\t\t\t{0, -1},\n\t};\n\n\tstatic COLOR tc;\n\tstatic int max = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st;\n\n\t\t\tst = new StringTokenizer(line);\n\n\t\t\tint h, w;\n\t\t\th = parseInt(st.nextToken());\n\t\t\tw = parseInt(st.nextToken());\n\t\t\ttc = COLOR.values()[parseInt(st.nextToken())];\n\t\t\tif ((h | w) == 0) break;\n\n\t\t\tCOLOR[][] pane = new COLOR[h + 2][w + 2];\n\n\t\t\tfor (COLOR[] pp : pane) {\n\t\t\t\tArrays.fill(pp, COLOR.NONE);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tpane[i + 1][j + 1] = COLOR.values()[st.nextToken().charAt(0) - '0'];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tmax = 0;\n\n\t\t\tsolve(pane, 5);\n\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static void solve(COLOR[][] pane, int r) {\n\n\t\tif (r == 0) {\n\t\t\tif (pane[1][1] == tc) {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int i = 0; i < pane.length; i++) {\n\t\t\t\t\tfor (int j = 0; j < pane[i].length; j++) {\n\t\t\t\t\t\tif (pane[i][j] == tc) {\n\t\t\t\t\t\t\tboolean conn = false;\n\t\t\t\t\t\t\tfor (int[] dir : DIR) {\n\t\t\t\t\t\t\t\tint ny, nx;\n\t\t\t\t\t\t\t\tny = i + dir[0];\n\t\t\t\t\t\t\t\tnx = j + dir[1];\n\t\t\t\t\t\t\t\tif (pane[ny][nx] == tc) conn |= true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (conn) count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count == 0) count = 1;\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tCOLOR pc = pane[1][1];\n\n\t\tfor (COLOR nc : COLOR.values()) {\n\t\t\tif (nc != COLOR.NONE && nc != pc) {\n\t\t\t\tCOLOR[][] _pane = new COLOR[pane.length][];\n\t\t\t\tfor (int i = 0; i < pane.length; i++) {\n\t\t\t\t\t_pane[i] = Arrays.copyOf(pane[i], pane[i].length);\n\t\t\t\t}\n\t\t\t\t_pane[1][1] = nc;\n\t\t\t\t//\n\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\tqueue.offer(new int[]{1, 1});\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tint[] q = queue.poll();\n\t\t\t\t\tfor (int[] dir : DIR) {\n\t\t\t\t\t\tint ny, nx;\n\t\t\t\t\t\tny = q[0] + dir[0];\n\t\t\t\t\t\tnx = q[1] + dir[1];\n\t\t\t\t\t\tif (_pane[ny][nx] == pc) {\n\t\t\t\t\t\t\t_pane[ny][nx] = nc;\n\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsolve(_pane, r - 1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int h,w,c,max;\n\tstatic byte[][] panel;\n\tstatic byte[] v1={0,1,0,-1};\n\tstatic byte[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\th=cin.nextInt();\n\t\t\tw=cin.nextInt();\n\t\t\tc=cin.nextInt();\n\t\t\tmax=-1;\n\t\t\tif(h+w+c==0)break;\n\t\t\tpanel=new byte[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[i][j]=cin.nextByte();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\tstatic void bt(int depth){\n\t\tif(depth==5){\n\t\t\tint ans=0;\n\t\t\tif(panel[0][0]==c){\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\t\t\tSystem.out.print(panel[i][j]+\" \");\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\t\t\tq.add(new int[]{0,0});\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\tint[] aaa=q.poll();\n\t\t\t\t\tint x=aaa[0];\n\t\t\t\t\tint y=aaa[1];\n\t\t\t\t\tif(panel[x][y]==-1)continue;\n\t\t\t\t\tpanel[x][y]=-1;\n\t\t\t\t\tans++;\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tint xx=x+v1[j];\n\t\t\t\t\t\tint yy=y+v2[j];\n\t\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\t\tif(panel[xx][yy]!=c)continue;\n\t\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(ans);\t\n\t\t\t\tmax=Math.max(ans,max);\n\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(byte i=1;i<=6;i++){\n\t\t\tif(panel[0][0]==i)continue;\n\t\t\tbyte[][] cp = new byte[h][w];\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcp[k][j]=panel[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint color=panel[0][0];\n\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\tq.add(new byte[]{0,0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte x=aaa[0];\n\t\t\t\tbyte y=aaa[1];\n\t\t\t\tpanel[x][y]=i;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte xx=(byte) (x+v1[j]);\n\t\t\t\t\tbyte  yy=(byte) (y+v2[j]);\n\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\tif(panel[xx][yy]!=color)continue;\n\t\t\t\t\tq.add(new byte[]{xx,yy});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(depth+1);\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[k][j]=cp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\n\tint h, w, c;\n\tint[] colors;\n\tint[][] tmp;\n\tint[] dy = { 1, 0, -1, 0 };\n\tint[] dx = { 0, 1, 0, -1 };\n\tint bColor, aColor;\n\tint sum;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scan.nextInt();\n\t\t\tw = scan.nextInt();\n\t\t\tc = scan.nextInt();\n\t\t\tif (h + w + c == 0)\n\t\t\t\treturn;\n\n\t\t\tint[][] panel = new int[h][w];\n\t\t\ttmp = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tpanel[i][j] = scan.nextInt();\n\t\t\t}\n\t\t\tcolors = new int[6];\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\t\tfor (int j = 1; j <= 6; j++) {\n\t\t\t\t\tfor (int k = 1; k <= 6; k++) {\n\t\t\t\t\t\tfor (int l = 1; l <= 6; l++) {\n\t\t\t\t\t\t\tcolors[0] = i;\n\t\t\t\t\t\t\tcolors[1] = j;\n\t\t\t\t\t\t\tcolors[2] = k;\n\t\t\t\t\t\t\tcolors[3] = l;\n\t\t\t\t\t\t\tcolors[4] = c;\n\t\t\t\t\t\t\tfor (int _i = 0; _i < h; _i++) {\n\t\t\t\t\t\t\t\tfor (int _j = 0; _j < w; _j++)\n\t\t\t\t\t\t\t\t\ttmp[_i][_j] = panel[_i][_j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpaint();\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\t\tcount(0, 0);\n\t\t\t\t\t\t\tans = Math.max(ans, sum);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid paint() {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tbColor = tmp[0][0];\n\t\t\taColor = colors[i];\n\t\t\tif (bColor == aColor)\n\t\t\t\tcontinue;\n\t\t\tdfs(0, 0);\n\t\t}\n\t}\n\tvoid dfs(int y, int x) {\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(y + \" \" + x);\n\t\tif (y < 0 || x < 0 || y >= h || x >= w)\n\t\t\treturn;\n\t\tif (tmp[y][x] != bColor)\n\t\t\treturn;\n\t\ttmp[y][x] = aColor;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tdfs(y + dy[i], x + dx[i]);\n\t}\n\tvoid count(int y, int x) {\n\t\tif (y < 0 || x < 0 || y >= h || x >= w)\n\t\t\treturn;\n\t\tif (tmp[y][x] != c)\n\t\t\treturn;\n\t\ttmp[y][x] = 0;\n\t\tsum++;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tcount(y + dy[i], x + dx[i]);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  /**\n   * ??±???????????¢?´¢\n   *\n   * @return count ??? max\n   */\n  int dfs(byte[][] p, byte depth) {\n    if (depth >= 5) {\n      return count(p, c);\n    }\n    int max = 0;\n    for (byte i = 1; i <= 6; ++i) {\n      byte[][] next = new byte[h][w];\n      for (int y = 0; y < h; ++y) {\n        for (int x = 0; x < w; ++x) {\n          next[y][x] = p[y][x];\n        }\n      }\n      paint(next, i);\n      int res = dfs(next, (byte) (depth + 1));\n      max = Math.max(max, res);\n    }\n    return max;\n  }\n\n  byte[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0}\n  };\n\n  /**\n   * ???????????¢?´¢??§????????????\n   */\n  int count(byte[][] p, byte color) {\n    if (p[0][0] != color) {\n      return 0;\n    }\n    boolean[][] done = new boolean[h][w];\n    Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\n    queue.add(new Pair<>(0, 0));\n    done[0][0] = true;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Pair<Integer, Integer> point = queue.poll();\n      ++cnt;\n      for (byte[] d : ofs) {\n        int nx = point.f + d[0];\n        int ny = point.s + d[1];\n        if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n          continue;\n        }\n        if (done[ny][nx]) {\n          continue;\n        }\n        done[ny][nx] = true;\n        if (p[ny][nx] != color) {\n          continue;\n        }\n        Pair<Integer, Integer> next = new Pair<>(nx, ny);\n        queue.add(next);\n      }\n    }\n    return cnt;\n  }\n\n  /**\n   * ???????????¢?´¢??§?????£?????????\n   */\n  void paint(byte[][] p, byte color) {\n    boolean[][] done = new boolean[h][w];\n    Queue<Pair<Byte, Byte>> queue = new LinkedList<>();\n    queue.add(new Pair<>((byte) 0, (byte) 0));\n    done[0][0] = true;\n    int atom = p[0][0];\n    while (queue.size() > 0) {\n      Pair<Byte, Byte> point = queue.poll();\n      p[point.s][point.f] = color;\n      for (byte[] d : ofs) {\n        byte nx = (byte) (point.f + d[0]);\n        byte ny = (byte) (point.s + d[1]);\n        if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n          continue;\n        }\n        if (done[ny][nx]) {\n          continue;\n        }\n        done[ny][nx] = true;\n        if (p[ny][nx] != atom) {\n          continue;\n        }\n        Pair<Byte, Byte> next = new Pair<>(nx, ny);\n        queue.add(next);\n      }\n    }\n  }\n\n  byte h, w, c;\n\n  void run() {\n    for (; ; ) {\n      h = (byte) ni();\n      w = (byte) ni();\n      c = (byte) ni();\n      if (h == 0) {\n        break;\n      }\n      byte[][] p = new byte[h][w];\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          p[i][j] = (byte) ni();\n        }\n      }\n      System.out.println(dfs(p, (byte) 0));\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "public\nclass ProbC\n{\n  private static\n  final int ColorNum = 6;\n\n  public static\n  void main (\n    String args[ ]\n    )\n  {\n    java.util.Scanner scanner\n      = new java.util.Scanner ( System.in );\n\n    while ( true )\n    {\n      int[ ][ ] panel;\n      int       h, w, c;\n\n      h = scanner.nextInt ( );\n      w = scanner.nextInt ( );\n      c = scanner.nextInt ( );\n      if ( h == 0 && w == 0 && c == 0 ) break;\n\n      panel = new int[ h ][ w ];\n      for ( int j = 0; j < h; ++j )\n      for ( int i = 0; i < w; ++i )\n      {\n        panel[ j ][ i ] = scanner.nextInt ( );\n      }\n\n      System.out.format ( \"%d\\n\", solve ( panel, c ) );\n    }\n\n    return ;\n  }\n\n  public static\n  int solve (\n    int[ ][ ]   panel,\n    int         c\n    )\n  {\n    int[ ]  p = new int[ 5 ];\n    int     res = 0;\n\n    p[ 4 ] = c;\n    for ( p[ 0 ] = 1; p[ 0 ] <= ColorNum; ++p[ 0 ] )\n    for ( p[ 1 ] = 1; p[ 1 ] <= ColorNum; ++p[ 1 ] )\n    for ( p[ 2 ] = 1; p[ 2 ] <= ColorNum; ++p[ 2 ] )\n    for ( p[ 3 ] = 1; p[ 3 ] <= ColorNum; ++p[ 3 ] )\n    {\n      int[ ][ ] clone\n        = new int[ panel.length ][ ];\n\n      /* Copies panel to clone by deep copy */\n      for ( int i = 0; i < panel.length; ++i )\n      {\n        clone[ i ] = panel[ i ].clone ( );\n      }\n\n      res = Math.max ( res, test ( clone, p ) );\n    }\n\n    return ( res );\n  }\n\n  private static\n  int test (\n    int[ ][ ]   panel,\n    int[ ]      param\n    )\n  {\n    for ( int c : param )\n    {\n      simulate ( panel, 0, 0, panel[ 0 ][ 0 ], c );\n    }\n\n    return\n      count ( panel, 0, 0, panel[ 0 ][ 0 ] );\n  }\n\n  private static\n  void simulate (\n    int[ ][ ]   panel,\n    int         x,\n    int         y,\n    int         pc,\n    int         nc\n    )\n  {\n    if ( nc == pc )               return ;\n    if ( x < 0 || y < 0\n      || y >= panel.length\n      || x >= panel[ y ].length ) return ;\n    if ( panel[ y ][ x ] != pc )  return ;\n\n    panel[ y ][ x ] = nc;\n\n    simulate ( panel, x - 1 , y     , pc, nc );\n    simulate ( panel, x     , y - 1 , pc, nc );\n    simulate ( panel, x + 1 , y     , pc, nc );\n    simulate ( panel, x     , y + 1 , pc, nc );\n\n    return ;\n  }\n\n  private static\n  int count (\n    int[ ][ ]   panel,\n    int         x,\n    int         y,\n    int         c\n    )\n  {\n    int res;\n\n    if ( x < 0 || y < 0\n      || y >= panel.length\n      || x >= panel[ y ].length ) return ( 0 );\n    if ( panel[ y ][ x ] != c )   return ( 0 );\n\n    /* Flags not to recount this point */\n    panel[ y ][ x ] = -1;\n\n    res  = 1;\n    res += count ( panel, x - 1 , y     , c );\n    res += count ( panel, x     , y - 1 , c );\n    res += count ( panel, x + 1 , y     , c );\n    res += count ( panel, x     , y + 1 , c );\n\n    return ( res );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tint H;\n\tint W;\n\tint C;\n\tint[][] map;\n\tint[] DR = {1, 0, -1, 0};\n\tint[] DC = {0, 1,  0, -1};\n\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tH = nextInt();\n\t\t\tW = nextInt();\n\t\t\tC = nextInt();\n\t\t\tif (H == 0) break;\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tfor(int r = 0; r < H; r++){\n\t\t\t\tfor(int c = 0; c < W; c++){\n\t\t\t\t\tmap[r][c] = nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(recur(map, 0));\n\t\t}\n\t}\n\t\n\tpublic int recur(int[][] map, int cnt){\n\t\tif(cnt == 5){\n\t\t\treturn countrecur(map, 0, 0);\n\t\t}else{\n\t\t\tint ans = 0;\n\t\t\tint cc = map[0][0];\n\t\t\tint[][] nmap = new int[H][W];\n\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\tif(cc == i) continue;\n\t\t\t\tfor(int r = 0; r < H; r++){\n\t\t\t\t\tfor(int c = 0; c < W; c++){\n\t\t\t\t\t\tnmap[r][c] = map[r][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tflip(nmap, 0, 0, cc, i);\n\t\t\t\tans = Math.max(ans, recur(nmap, cnt + 1));\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\t\n\tpublic void flip(int[][] map, int r, int c, int color, int nc){\n\t\tif(r < 0 || r >= H || c < 0 || c >= W || map[r][c] != color){\n\t\t\treturn;\n\t\t}\n\t\tmap[r][c] = nc;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tflip(map, r + DR[i], c + DC[i], color, nc);\n\t\t}\n\t}\n\t\n\t\n\tpublic int countrecur(int[][] map, int r, int c){\n\t\tif(r < 0 || r >= H || c < 0 || c >= W || map[r][c] != C){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tint ans = 1;\n\t\t\tmap[r][c] = 0;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tans += countrecur(map, r + DR[i], c + DC[i]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\n\tpublic static int nextInt() {\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static long nextLong() {\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif (str.charAt(0) == '-') {\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (; i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (!('0' <= c && c <= '9'))\n\t\t\t\tthrow new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\n\tpublic static String next() {\n\t\tint c;\n\t\twhile (!isAlNum(c = read())) {\n\t\t}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char) c);\n\t\twhile (isAlNum(c = read())) {\n\t\t\tbuild.append((char) c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\n\tprivate static int read() {\n\t\tif (bufferLength < 0)\n\t\t\tthrow new RuntimeException();\n\t\tif (bufferIndex >= bufferLength) {\n\t\t\ttry {\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufferLength <= 0)\n\t\t\t\treturn (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\n\tprivate static boolean isAlNum(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1174();\n\t}\n\tclass AOJ1174{\n\t\tAOJ1174(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tC=sc.nextInt();\n\t\t\t\tif((H|(W|C))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tint H,W,C;\n\t\tint[][][] b;\n\t\tfinal int[] vx={0,-1,0,1},vy={-1,0,1,0};\n\t\tvoid solve(){\n\t\t\tb=new int[6][W][H];\n\t\t\tfor(int h=0; h<H; ++h)for(int w=0; w<W; ++w)\tb[0][w][h]=sc.nextInt();\n\t\t\tSystem.out.println(dfs(b,0,b[0][0][0]));\n\t\t}\n\t\tint dfs(int[][][] b,int depth,int last){\n\t\t\tif(depth>=4)\treturn cnt(change(depth, C));\n\t\t\tint ret=0;\n\t\t\tfor(int c=1; c<=6; ++c){\n\t\t\t\tif(c==last)\tcontinue;\n\t\t\t\tchange(depth, c);\n\t\t\t\tret=max(ret, dfs(b, depth+1, c));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tint[][] change(int d,int target){\n\t\t\tfor(int w=0; w<W; ++w)for(int h=0; h<H; ++h)\tb[d+1][w][h]=b[d][w][h];\n\t\t\tLinkedList<Pair> open=new LinkedList<Pair>();\n\t\t\topen.add(new Pair(0,0));\n\t\t\tboolean[][] closed=new boolean[W][H];\n\t\t\tclosed[0][0]=true;\n\t\t\tb[d+1][0][0]=target;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPair now=open.poll();\n\t\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\t\tint xx=now.x+vx[v], yy=now.y+vy[v];\n\t\t\t\t\tif(!(0<=xx&&xx<W && 0<=yy&&yy<H))\tcontinue;\n\t\t\t\t\tif(b[d][xx][yy]!=b[d][0][0])\tcontinue;\n\t\t\t\t\tif(b[d+1][xx][yy]==target)\tcontinue;\n\t\t\t\t\tif(closed[xx][yy])\tcontinue;\n\t\t\t\t\tb[d+1][xx][yy]=target;\n\t\t\t\t\topen.add(new Pair(xx,yy));\n\t\t\t\t\tclosed[xx][yy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn b[d+1];\n\t\t}\n\t\tint cnt(int[][] a){\n\t\t\tLinkedList<Pair> open=new LinkedList<Pair>();\n\t\t\topen.add(new Pair(0,0));\n\t\t\tboolean[][] closed=new boolean[W][H];\n\t\t\tclosed[0][0]=true;\n\t\t\tint cnt=1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPair now=open.poll();\n\t\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\t\tint xx=now.x+vx[v], yy=now.y+vy[v];\n\t\t\t\t\tif(!(0<=xx&&xx<W && 0<=yy&&yy<H))\tcontinue;\n\t\t\t\t\tif(a[xx][yy]!=a[0][0])\tcontinue;\n\t\t\t\t\tif(closed[xx][yy])\tcontinue;\n\t\t\t\t\topen.add(new Pair(xx,yy));\n\t\t\t\t\tclosed[xx][yy]=true;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int h=0; h<H; ++h){\n//\t\t\t\tfor(int w=0; w<W; ++w)\tSystem.out.print(a[w][h]+\" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println(cnt);\n//\t\t\tSystem.out.println();\n\t\t\treturn cnt;\n\t\t}\n\t\tclass Pair{\n\t\t\tint x,y;\n\t\t\tPair(int x,int y){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint w = in.nextInt(),h = in.nextInt(),c = in.nextInt();\n\t\t\tif(w+h+c==0)break;\n\t\t\tnew AOJ1174().doIt(w, h, c);\n\t\t}\n\t}\n\t\n\tclass AOJ1174{\n\t\tint max = 0;\n\t\tint[][] map;\n\t\tint h,w,c;\n\t\tint sx[] = {0,1,-1,0};\n\t\tint sy[] = {1,0,0,-1};\n\t\tboolean sw[][],flg[][];\n\t\tvoid dfs_2(int x,int y){\n\t\t\tsw[y][x] = true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+sx[i];\n\t\t\t\tint ny = y+sy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||sw[ny][nx]||map[ny][nx]!=c)continue;\n\t\t\t\tdfs_2(nx,ny);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid set(){\n\t\t\tif(map[0][0]!=c)return;\n\t\t\tsw = new boolean[h][w];\n\t\t\tint cnt = 0;\n\t\t\tdfs_2(0, 0);\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(sw[i][s])cnt++;\n\t\t\tmax = Math.max(max, cnt);\n\t\t}\n\t\t\n\t\tvoid color_change(int x,int y,int color,int from){\n\t\t\tflg[y][x] = true;\n\t\t\tmap[y][x] = color;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = sx[i]+x;\n\t\t\t\tint ny = sy[i]+y;\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||flg[ny][nx]||map[ny][nx]!=from)continue;\n\t\t\t\tcolor_change(nx, ny, color,from);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid dfs(int fase){\n\t\t\tif(fase==5){\n\t\t\t\tset();return;\n\t\t\t}\n\t\t\tfor(int j=1;j<=6;j++){\n\t\t\t\tif(j==map[0][0])continue;\n\t\t\t\tint memo[][] = new int[h][w];\n\t\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)memo[i][s] = map[i][s];\n\t\t\t\tflg = new boolean[h][w];\n\t\t\t\tcolor_change(0, 0, j,map[0][0]);\n\t\t\t\tdfs(fase+1);\n\t\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)map[i][s] = memo[i][s];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid print(int[][] m){// deba\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int s=0;s<w;s++)System.out.print(m[i][s]+\" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt(int h,int w,int c){\n\t\t\tmap = new int[h][w];\n\t\t\tthis.h = h;this.w = w;this.c = c;\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)map[i][s] = in.nextInt();\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * \n */\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * @author kumar1\n * \n */\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\ttry {\n\t\t\tsolve();\n\t\t} catch (IOException e) {\n\t\t\t// TODO 自動生成された catch ブロック\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * @throws IOException\n\t * \n\t */\n\tprivate static void solve() throws IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tArrayList<ArrayList<Byte>> list = new ArrayList<ArrayList<Byte>>();\n\t\t//File file = new File(\"ccase.txt\");\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(file));\n\t\tString s;\n\t\twhile ((s = in.readLine()) != null) {\n\t\t\tScanner scan = new Scanner(s);\n\t\t\tint n = 0;\n\t\t\tArrayList<Byte> l = new ArrayList<Byte>();\n\t\t\twhile (scan.hasNextInt()) {\n\t\t\t\tn = scan.nextInt();\n\t\t\t\tl.add((byte) n);\n\t\t\t}\n\t\t\tlist.add(l);\n\t\t\tscan.close();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tin.close();\n\t\t//System.out.println(list);\n\t\tfor (int i = 0; i < list.size();) {\n\t\t\tif (list.get(i).get(0) == 0)\n\t\t\t\tbreak;\n\t\t\tint h, w, c;\n\t\t\th = list.get(i).get(0);\n\t\t\tw = list.get(i).get(1);\n\t\t\tc = list.get(i).get(2);\n\t\t\tans(c, list.subList(i + 1, i + 1 + h));\n\t\t\ti = i + 1 + h;\n\t\t}\n\t}\n\n\t/**\n\t * @param h\n\t * @param w\n\t * @param c\n\t * @param subList\n\t */\n\tprivate static void ans(int c, List<ArrayList<Byte>> list) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t//System.out.println(list);\n\t\tbyte[][] arr = new byte[list.size()][list.get(0).size()];\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tfor(int j = 0; j < list.get(0).size(); j++) {\n\t\t\t\tarr[i][j] = list.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tdfs(arr, 1, 3, 0, 0);\n\t\tdfs(arr, arr[0][0], 6, 0, 0);\n\t\tfor(int j=0; j < arr.length; j++) {\n\t\t\tfor(int k=0; k < arr[0].length; k++) {\n\t\t\t\tSystem.out.print(arr[j][k] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(count(arr, arr[0][0], 0, 0, 1));\n\t\t*/\n\t\tSystem.out.println(pat(c, arr, 0));\n\t}\n\n\t/**\n\t * @param c : 最後の色\n\t * @param arr : 基板の配列\n\t * @param i : ループ回数\n\t * @return\n\t */\n\tprivate static int pat(int c, byte[][] arr, int i) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tbyte[][] carr;\n\t\ti++;\n\t\tif(i > 4) { // 5回目はc\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], c, 0, 0);\n\t\t\t/*\n\t\t\tfor(int j=0; j < carr.length; j++) {\n\t\t\t\tfor(int k=0; k < carr[0].length; k++) {\n\t\t\t\t\tSystem.out.print(carr[j][k] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\t\t\n\t\t\treturn count(carr, c, 0, 0, 1);\n\t\t}\n\t\tint max = 0;\n\t\t// 1, 2, 3, 4回目は全色\n\t\tfor(int j=1; j <= 6; j++) {\n\t\t\tif(arr[0][0] == j)\n\t\t\t\tcontinue;\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], j, 0, 0);\n\t\t\tint n = pat(c, carr, i);\n\t\t\tif(max < n) {\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\n\t/**\n\t * @param c : 値がcの要素の数を求める\n\t * @return\n\t */\n\tprivate static int count(byte[][] carr, int c, int x, int y, int cnt) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = 0;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\t\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == c)\n\t\t\t\t\tcnt = count(carr, c, nx, ny, cnt + 1);\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\t/**\n\t * @param carr\n\t * @param j : dfsした結果置換するやつ\n\t * @param x : x座標\n\t * @param y : y座標\n\t */\n\tprivate static void dfs(byte[][] carr, int before, int after, int x, int y) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = (byte) after;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == before && before != after)\n\t\t\t\t\tdfs(carr, before, after, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static byte[][] cp2dIntArray(byte[][] x) {\n\t\tbyte[][] ret = new byte[x.length][];\n\t\tfor(int i=0; i < x.length; i++)\n\t\t\tret[i] = x[i].clone();\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n  \npublic class Main {\n     \n    static int H, W, C;\n    static int[][] P;\n    \n    static int[][] p;\n    static boolean[][] check;\n    \n    static int[] dx = {0, 1, 0, -1};\n    static int[] dy = {1, 0, -1, 0};\n    \n    static int calc(int[] order)\n    {\n    \tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tp[y][x] = P[y][x];\n\t\t\t}\n\t\t}\n    \t\n    \tfor (int i = 0; i < 6; i++) {\n    \t\tint color = p[0][0];\n    \t\t\n    \t\tfor (int y = 0; y < H; y++) {\n    \t\t\tfor (int x = 0; x < W; x++) {\n    \t\t\t\tcheck[y][x] = false;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tLinkedList<Point> queue = new LinkedList<Point>();\n    \t\tqueue.offer(new Point(0, 0));\n    \t\twhile(!queue.isEmpty())\n    \t\t{\n    \t\t\tPoint poi = queue.poll();\n    \t\t\tif( poi.x < 0 || W <= poi.x || poi.y < 0 || H <= poi.y )  continue;\n    \t\t\tif(check[poi.y][poi.x] == true) continue;\n    \t\t\t\n    \t\t\tcheck[poi.y][poi.x] = true;\n    \t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint x = poi.x + dx[j];\n\t\t\t\t\tint y = poi.y + dy[j];\n\t\t\t\t\tif( x < 0 || W <= x || y < 0 || H <= y )  continue;\n\t\t\t\t\t\n\t\t\t\t\tif(p[y][x] == color) queue.offer(new Point(x, y));\n\t\t\t\t}\n    \t\t}\n    \t\t\n    \t\tif(i == 5) break;\n    \t\t\n    \t\tfor (int y = 0; y < H; y++) {\n    \t\t\tfor (int x = 0; x < W; x++) {\n    \t\t\t\tif(check[y][x] == true) p[y][x] = order[i];\n    \t\t\t}\n    \t\t}\n\t\t}\n    \t\n    \tint count = 0;\n    \tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tif(check[y][x] == true) count++;\n\t\t\t}\n\t\t}\n    \t\n    \treturn count;\n    }\n     \n    static void start()\n    {\n    \tint max = 0;\n    \tp = new int[H][W];\n    \tcheck = new boolean[H][W];\n    \t\n        for (int i0 = 1; i0 <= 6; i0++) {\n        \t\n        \tfor (int i1 = 1; i1 <= 6; i1++) {\n        \t\t\n        \t\tfor (int i2 = 1; i2 <= 6; i2++) {\n        \t\t\t\n        \t\t\tfor (int i3 = 1; i3 <= 6; i3++) {\n        \t\t\t\t\n        \t\t\t\tmax = Math.max(max, calc(new int[]{i0, i1, i2, i3, C}));\n        \t\t\t}\n        \t\t}\n    \t\t}\n\t\t}\n        \n        System.out.println(max);\n    }\n      \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n            H = sca.nextInt();\n            W = sca.nextInt();\n            C = sca.nextInt();\n            if(H == 0) break;\n             \n             P = new int[H][W];\n             for (int y = 0; y < H; y++) {\n\t\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\t\tP[y][x] = sca.nextInt();\n\t\t\t\t}\n\t\t\t}\n            \n            start();\n        }\n         \n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tScanner sc = new Scanner(in);\n\tint h, w, c;\n\tint[] order = new int[5];\n\tint max;\n\tint[][] p;\n\tint[][] q;\n\t\n\tint calc() {\n\t\tint ans = 0;\n\t\tQueue<Integer> qx = new LinkedList<Integer>();\n\t\tQueue<Integer> qy = new LinkedList<Integer>();\n\t\tint[] dx = {-1, 0, 1, 0};\n\t\tint[] dy = {0, -1, 0, 1};\n\t\tint x, y;\n\t\tboolean[][] check = new boolean[h][w]; \n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 0; j < h; j++)\n\t\t\t\tArrays.fill(check[j], false);\n\t\t\tqx.add(0); qy.add(0);\n\t\t\tcheck[0][0] = true;\n\t\t\tint color = q[0][0];\n\t\t\twhile(!qx.isEmpty()) {\n\t\t\t\tx = qx.poll();\n\t\t\t\ty = qy.poll();\n\t\t\t\tq[x][y] = order[i];\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (x+dx[j] >= 0 &&\n\t\t\t\t\t\tx+dx[j] < h &&\n\t\t\t\t\t\ty+dy[j] >= 0 &&\n\t\t\t\t\t\ty+dy[j] < w &&\n\t\t\t\t\t\t!check[x+dx[j]][y+dy[j]] &&\n\t\t\t\t\t\tq[x+dx[j]][y+dy[j]] == color) {\n\t\t\t\t\t\tcheck[x+dx[j]][y+dy[j]] = true;\n\t\t\t\t\t\tqx.add(x+dx[j]);\n\t\t\t\t\t\tqy.add(y+dy[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < h; j++)\n\t\t\tArrays.fill(check[j], false);\n\t\tqx.add(0); qy.add(0);\n\t\tcheck[0][0] = true;\n\t\twhile(!qx.isEmpty()) {\n\t\t\tx = qx.poll();\n\t\t\ty = qy.poll();\n\t\t\tans++;\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (x+dx[j] >= 0 &&\n\t\t\t\t\tx+dx[j] < h &&\n\t\t\t\t\ty+dy[j] >= 0 &&\n\t\t\t\t\ty+dy[j] < w &&\n\t\t\t\t\t!check[x+dx[j]][y+dy[j]] &&\n\t\t\t\t\tq[x+dx[j]][y+dy[j]] == order[4]) {\n\t\t\t\t\tcheck[x+dx[j]][y+dy[j]] = true;\n\t\t\t\t\tqx.add(x+dx[j]);\n\t\t\t\t\tqy.add(y+dy[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tvoid copy() {\n\t\tfor (int i = 0; i < h; i++)\n\t\t\t for (int j = 0; j < w; j++)\n\t\t\t\t q[i][j] = p[i][j];\n\t\t\t\n\t}\n\t\n\tvoid recursion(int d) {\n\t\t if (d == 4) {\n\t\t\t copy();\n\t\t\t max = Math.max(calc(), max);\n\t\t } else {\n\t\t\t for (int i = 1; i <= 6; i++) {\n\t\t\t\t order[d] = i;\n\t\t\t\t recursion(d+1);\n\t\t\t }\n\t\t }\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile(true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif (h == 0 && w == 0 && c == 0)\n\t\t\t\tbreak;\n\t\t\tp = new int[h][w];\n\t\t\tq = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tp[i][j] = sc.nextInt();\n\t\t\t\n\t\t\tmax = 0;\n\t\t\torder[4] = c;\n\t\t\trecursion(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic class Grid\n\t{\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tpublic Grid(int x0, int y0)\n\t\t{\n\t\t\tx = x0;\n\t\t\ty = y0;\n\t\t}\n\t}\n\t\n\tstatic int colors = 6;\n\tstatic int tar = 5;\n\tstatic int c = 0;\n\tstatic int[][] pan;\n\tstatic int w, h;\t\n\tstatic int max = -1;\n\tstatic void fil(int[] ar)\n\t{\n//\t\tint k = 0;\n\t\t\n//\t\tint[][] m = pan.clone();\n\t\t\n\t\tArrayList<Grid> pen = new ArrayList<Grid>();\n\t\tpen.add(new Grid(0,0));\n\t\t\n\t\tboolean[][] in = new boolean[w][h];\n\t\tin[0][0] = true;\n\t\t\n\t\tint check = 0;\n\t\twhile(check < pen.size())\n\t\t{\n\t\t\tGrid p = pen.get(check);\n//\t\t\tSystem.out.println(\"Checking \" + p.x + \" \" + p.y);\n\t\t\tfor(int d = 0; d < 4; d++)\n\t\t\t{\n\t\t\t\tint xp = p.x;\n\t\t\t\tint yp = p.y;\n\t\t\t\t\n\t\t\t\tif(d==0)xp++;\n\t\t\t\telse if(d==1)xp--;\n\t\t\t\telse if(d==2)yp++;\n\t\t\t\telse if(d==3)yp--;\n\t\t\t\t\n\t\t\t\tif(xp >= 0 && xp < w && yp >= 0 && yp < h)\n\t\t\t\t{\n\t\t\t\t\tif(!in[xp][yp] && pan[xp][yp] == pan[0][0])\n\t\t\t\t\t{\n//\t\t\t\t\t\tif(true)System.out.println(\"COL \" + pan[0][0] + \", \" + xp + \" \" + yp);\n\t\t\t\t\t\tpen.add(new Grid(xp, yp));\n\t\t\t\t\t\tin[xp][yp] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tcheck++;\n\t\t}\n\t\t\n\n\t\t\n\t\tboolean debug = false;\n\t\tif(ar[0] == 5 && ar[1] == 2 && ar[2] == 3 && ar[3] == 1 && ar[4] == 4)\n\t\t{\n//\t\t\tdebug = true;\n\t\t}\n\t\t\n\t\tif(debug)System.out.println(Arrays.toString(ar));\n\n\t\t\n\t\t\n\t\t\n\t\tfor(int i = 0; i < 5; i++)\n\t\t{\n\t\t\tint col = ar[i];\n\t\t\tint cursize = pen.size();\n\t\t\t\n\t\t\tif(debug)System.out.println(\"doing col \" + col + \" (->\" + (col+1) + \"), cursize \" + cursize);\n\t\t\tif(debug)\n\t\t\t{\n\t\t\t\tfor(Grid p : pen)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"panel \" + p.x + \" \" + p.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int pi = 0; pi < pen.size(); pi++)\n\t\t\t{\n\t\t\t\tGrid p = pen.get(pi);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(pi < cursize || pan[p.x][p.y] == col)\n\t\t\t\tfor(int d = 0; d < 4; d++)\n\t\t\t\t{\n\t\t\t\t\tint xp = p.x;\n\t\t\t\t\tint yp = p.y;\n\t\t\t\t\t\n\t\t\t\t\tif(d==0)xp++;\n\t\t\t\t\telse if(d==1)xp--;\n\t\t\t\t\telse if(d==2)yp++;\n\t\t\t\t\telse if(d==3)yp--;\n\t\t\t\t\t\n\t\t\t\t\tif(xp >= 0 && xp < w && yp >= 0 && yp < h)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!in[xp][yp] && pan[xp][yp] == col)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(debug)System.out.println(\"COL \" + col + \", \" + xp + \" \" + yp);\n\t\t\t\t\t\t\tpen.add(new Grid(xp, yp));\n\t\t\t\t\t\t\tin[xp][yp] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmax = Math.max(max, pen.size());\n\t\tif(debug)System.out.println(pen.size());\n\t}\n\t\t\t\n\tstatic void cyc(int[] ar, int t)\n\t{\n\t\tif(t <= 3)\n\t\t{\n\t\t\tfor(int i = 0; i < colors; i++)\n\t\t\t{\n\t\t\t\tif(t <= 0 || ar[t-1] != i)\n\t\t\t\t{\n\t\t\t\t\tint[] arc = ar.clone();\n\t\t\t\t\tarc[t] = i;\n\t\t\t\t\tcyc(arc, t+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc++;\n\t\t\tar[4] = tar;\n\t\t\tfil(ar);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n//\t\tSystem.out.println(c);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\ttar = sc.nextInt()-1;\n\t\t\t\n\t\t\tif(h == 0 && w == 0 && tar == -1)return;\n\t\t\t\n\t\t\tpan = new int[w][h];\n\t\t\tmax = -1;\n\t\t\t\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tpan[x][y] = sc.nextInt()-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcyc(new int[]{0, -1, -1, -1 ,-1}, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    \n    StringTokenizer st;\n    private static boolean end = false;\n\n    public static void main ( String [] args ) throws IOException\n    {\n\twhile(!end){\n\t    new Main().cal();\n\t}\n\t\n    }\n\nint turn;\nint max;\nint h;\nint w;\nint c;\n\n    private void cal() throws IOException \n    {\n\n\tint result;\n\n\tint[][] panel;\n\tboolean[][] sameColor;\n\n\n\tst = new StringTokenizer(br.readLine());\n\th = Integer.parseInt(st.nextToken());\n\tw = Integer.parseInt(st.nextToken());\n\tc = Integer.parseInt(st.nextToken());\n\tif( h == 0 && w == 0 && c == 0){\n\t\tend = true;\n\t\treturn;\t\n\t}\n\n\tpanel = new int[h][w];\n\n\tfor( int i = 0; i < h; i++){\n\t\tst = new StringTokenizer(br.readLine());\t\t\n\t\tfor( int j = 0; j < w; j++){\n\t\t\tpanel[i][j] = Integer.parseInt(st.nextToken());\n\t\t}\n\t}\t\n\n\tsameColor = new boolean[h][w];\n\tsameColor[0][0] = true;\n\tresult = 1;\n\tboolean nomore = false;\n\twhile(!nomore){\n\t\tint tempNum = result;\n\t\tresult = changePoint(sameColor, result, panel);\n\t\tif(tempNum == result){\n\t\t\tnomore = true;\n\t\t}\n\t}\n\n\tturn = 0;\n\tmax = 0;\n\n\tnextTurn(result, sameColor, panel);\n\n\tSystem.out.println(max);\n\n    }\n\n\n    private void nextTurn(int result, boolean[][] sameColor, int[][] panel){\n\tturn++;\n\tif( turn == 5 ){\n\t\tresult = changeColor(c, result, sameColor, panel);\n\t\tif( result > max )\tmax = result;\n\n\n\t}\n\telse {\n\tfor( int col = 1; col < 7 ;col++){\n\t\tboolean[][] tmpsameColor = new boolean[h][w];\n\t\tint[][] tmppanel = new int[h][w];\n\t\tfor(int l=0; l < h; l++){\n\t\tfor(int k=0; k < w; k++){\n\t\t\ttmpsameColor[l][k] = sameColor[l][k];\n\t\t\ttmppanel[l][k] = panel[l][k];\n\t\t}\n\t\t}\n\t\tif( col == panel[0][0] ) continue;\n\t\tint tmpresult = changeColor(col, result, sameColor, panel);\n\t\tnextTurn(tmpresult, sameColor, panel);\n\t\tfor(int l=0; l < h; l++){\n\t\tfor(int k=0; k < w; k++){\n\t\t\tsameColor[l][k] = tmpsameColor[l][k];\n\t\t\tpanel[l][k] = tmppanel[l][k];\n\t\t}\n\t\t}\n\t\n\t}\n\t}\n\tturn--;\n    }\n\n\n    private int changeColor(int col, int result, boolean[][] sameColor, int[][] panel){\n\tfor(int l=0; l< h; l++){\n\tfor(int k=0; k< w; k++){\n\t\tif( sameColor[l][k] )\tpanel[l][k] = col;\n\t}\n\t}\n\n\tboolean nomore = false;\n\twhile(!nomore){\n\t\tint tempNum = result;\n\t\tresult = changePoint(sameColor, result, panel);\n\t\tif(tempNum == result){\n\t\t\tnomore = true;\n\t\t}\n\t}\n\treturn result;\n    }\n\n   private int changePoint(boolean[][] sameColor,int result , int[][] panel){\n\tfor(int i=0; i < h; i++){\n\tfor(int j=0; j < w; j++){\n\tif(sameColor[i][j])\tcontinue;\n\telse if( i+1 < h && panel[i][j] == panel[i+1][j] && sameColor[i+1][j] ){\n\t\t\tsameColor[i][j] = true;\n\t\t\tresult++;\n\t}\n\telse if( i-1 >= 0 && panel[i][j] == panel[i-1][j] && sameColor[i-1][j] ){\n\t\t\tsameColor[i][j] = true;\n\t\t\tresult++;\n\t}\n\telse if( j+1 < w && panel[i][j] == panel[i][j+1] && sameColor[i][j+1] ){\n\t\t\tsameColor[i][j] = true;\n\t\t\tresult++;\n\t}\n\telse if( j-1 >= 0 && panel[i][j] == panel[i][j-1] && sameColor[i][j-1] ){\n\t\t\tsameColor[i][j] = true;\n\t\t\tresult++;\n\t}\n\t}\n\t}\n\treturn result;\n   }\n\n\n   private void printPanel(int[][] panel, boolean[][] sameColor){\n\tfor(int i =0; i< h; i++){\n\tfor(int j =0; j< w; j++){\n\t\tSystem.out.print(panel[i][j]+\" \");\n\t}\n\tSystem.out.println();\n\t}\n\tfor(int i =0; i< h; i++){\n\tfor(int j =0; j< w; j++){\n\tif(sameColor[i][j])\n\t\tSystem.out.print(\"1 \");\n\telse\tSystem.out.print(\"0 \");\n\t}\n\tSystem.out.println();\n\t}\n  }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * \n */\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * @author kumar1\n * \n */\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\ttry {\n\t\t\tsolve();\n\t\t} catch (IOException e) {\n\t\t\t// TODO 自動生成された catch ブロック\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * @throws IOException\n\t * \n\t */\n\tprivate static void solve() throws IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t//File file = new File(\"ccase.txt\");\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(file));\n\t\tString s;\n\t\twhile ((s = in.readLine()) != null) {\n\t\t\tScanner scan = new Scanner(s);\n\t\t\tint n = 0;\n\t\t\tArrayList<Integer> l = new ArrayList<Integer>();\n\t\t\twhile (scan.hasNextInt()) {\n\t\t\t\tn = scan.nextInt();\n\t\t\t\tl.add(n);\n\t\t\t}\n\t\t\tlist.add(l);\n\t\t\tscan.close();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tin.close();\n\t\t//System.out.println(list);\n\t\tfor (int i = 0; i < list.size();) {\n\t\t\tif (list.get(i).get(0) == 0)\n\t\t\t\tbreak;\n\t\t\tint h, w, c;\n\t\t\th = list.get(i).get(0);\n\t\t\tw = list.get(i).get(1);\n\t\t\tc = list.get(i).get(2);\n\t\t\tans(c, list.subList(i + 1, i + 1 + h));\n\t\t\ti = i + 1 + h;\n\t\t}\n\t}\n\n\t/**\n\t * @param h\n\t * @param w\n\t * @param c\n\t * @param subList\n\t */\n\tprivate static void ans(int c, List<ArrayList<Integer>> list) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t//System.out.println(list);\n\t\tint[][] arr = new int[list.size()][list.get(0).size()];\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tfor(int j = 0; j < list.get(0).size(); j++) {\n\t\t\t\tarr[i][j] = list.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tdfs(arr, 1, 3, 0, 0);\n\t\tdfs(arr, arr[0][0], 6, 0, 0);\n\t\tfor(int j=0; j < arr.length; j++) {\n\t\t\tfor(int k=0; k < arr[0].length; k++) {\n\t\t\t\tSystem.out.print(arr[j][k] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(count(arr, arr[0][0], 0, 0, 1));\n\t\t*/\n\t\tSystem.out.println(pat(c, arr, 0));\n\t}\n\n\t/**\n\t * @param c : 最後の色\n\t * @param arr : 基板の配列\n\t * @param i : ループ回数\n\t * @return\n\t */\n\tprivate static int pat(int c, int[][] arr, int i) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tint[][] carr;\n\t\ti++;\n\t\tif(i > 4) { // 5回目はc\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], c, 0, 0);\n\t\t\t/*\n\t\t\tfor(int j=0; j < carr.length; j++) {\n\t\t\t\tfor(int k=0; k < carr[0].length; k++) {\n\t\t\t\t\tSystem.out.print(carr[j][k] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\t\t\n\t\t\treturn count(carr, c, 0, 0, 1);\n\t\t}\n\t\tint max = 0;\n\t\t// 1, 2, 3, 4回目は全色\n\t\tfor(int j=1; j <= 6; j++) {\n\t\t\tif(arr[0][0] == j)\n\t\t\t\tcontinue;\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], j, 0, 0);\n\t\t\tint n = pat(c, carr, i);\n\t\t\tif(max < n) {\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\n\t/**\n\t * @param c : 値がcの要素の数を求める\n\t * @return\n\t */\n\tprivate static int count(int[][] carr, int c, int x, int y, int cnt) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = 0;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == c)\n\t\t\t\t\tcnt = count(carr, c, nx, ny, cnt + 1);\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\t/**\n\t * @param carr\n\t * @param j : dfsした結果置換するやつ\n\t * @param x : x座標\n\t * @param y : y座標\n\t */\n\tprivate static void dfs(int[][] carr, int before, int after, int x, int y) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = after;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == before && before != after)\n\t\t\t\t\tdfs(carr, before, after, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static int[][] cp2dIntArray(int[][] x) {\n\t\tint[][] ret = new int[x.length][];\n\t\tfor(int i=0; i < x.length; i++)\n\t\t\tret[i] = x[i].clone();\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Identically Colored Panels Connection\n */\npublic class Main {\n\n\tenum COLOR {\n\t\tNONE, YELLOW, PINK, RED, PURPLE, GREEN, BLUE,\n\t}\n\n\tstatic int[][] DIR = {\n\t\t\t{1, 0},\n\t\t\t{0, 1},\n\t\t\t{-1, 0},\n\t\t\t{0, -1},\n\t};\n\n\tstatic COLOR tc;\n\tstatic int max = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st;\n\n\t\t\tst = new StringTokenizer(line);\n\n\t\t\tint h, w;\n\t\t\th = parseInt(st.nextToken());\n\t\t\tw = parseInt(st.nextToken());\n\t\t\ttc = COLOR.values()[parseInt(st.nextToken())];\n\t\t\tif ((h | w) == 0) break;\n\n\t\t\tCOLOR[][] pane = new COLOR[h + 2][w + 2];\n\n\t\t\tfor (COLOR[] pp : pane) {\n\t\t\t\tArrays.fill(pp, COLOR.NONE);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tpane[i + 1][j + 1] = COLOR.values()[st.nextToken().charAt(0) - '0'];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tmax = 0;\n\n\t\t\tsolve(pane, 5);\n\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tstatic void solve(COLOR[][] pane, int r) {\n\n\t\tif (r == 0) {\n\t\t\tif (pane[1][1] == tc) {\n\t\t\t\tint count = 0;\n\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\tqueue.offer(new int[]{1, 1});\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tint[] q = queue.poll();\n\t\t\t\t\tfor (int[] dir : DIR) {\n\t\t\t\t\t\tint ny, nx;\n\t\t\t\t\t\tny = q[0] + dir[0];\n\t\t\t\t\t\tnx = q[1] + dir[1];\n\t\t\t\t\t\tif (pane[ny][nx] == tc) {\n\t\t\t\t\t\t\tpane[ny][nx] = COLOR.NONE;\n\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count == 0) count = 1;\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tCOLOR pc = pane[1][1];\n\n\t\tfor (COLOR nc : COLOR.values()) {\n\t\t\tif (nc != COLOR.NONE && nc != pc) {\n\t\t\t\tCOLOR[][] _pane = copy(pane);\n\t\t\t\t_pane[1][1] = nc;\n\t\t\t\t//\n\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\tqueue.offer(new int[]{1, 1});\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tint[] q = queue.poll();\n\t\t\t\t\tfor (int[] dir : DIR) {\n\t\t\t\t\t\tint ny, nx;\n\t\t\t\t\t\tny = q[0] + dir[0];\n\t\t\t\t\t\tnx = q[1] + dir[1];\n\t\t\t\t\t\tif (_pane[ny][nx] == pc) {\n\t\t\t\t\t\t\t_pane[ny][nx] = nc;\n\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsolve(_pane, r - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic COLOR[][] copy(COLOR[][] pane) {\n\t\tCOLOR[][] _pane = new COLOR[pane.length][];\n\t\tfor (int i = 0; i < pane.length; i++) {\n\t\t\t_pane[i] = pane[i].clone();\n\t\t}\n\t\treturn _pane;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int h, w, c;\n\tstatic int a[][];\n\tstatic int dx[] = {-1, 0, 0, 1};\n\tstatic int dy[] = {0, -1, 1, 0};\n\t\n\tpublic static int f(int k) {\n\t\tint b[][] = new int[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tb[i][j] = a[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (k == 6) {\n\t\t\tint cnt = count(c, 0, 0);\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ta[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\tint max = 0;\n\t\tfor (int q = 1; q <= 6; q++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ta[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (q != a[0][0]) {\n\t\t\t\tchange(b, q, 0, 0);\n\t\t\t\tmax = Math.max(max, f(k + 1));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ta[i][j] = b[i][j];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\t\n\tpublic static void change(int b[][], int c, int x, int y) {\n\t\tint k = b[0][0];\n\t\ta[y][x] = c;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (0 <= x + dx[i] && x + dx[i] < w && 0 <= y + dy[i] && y + dy[i] < h) {\n\t\t\t\tif (a[y + dy[i]][x + dx[i]] == k) {\n\t\t\t\t\tchange(b, c, x + dx[i], y + dy[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int count(int k, int x, int y) {\n\t\tint cnt = 1;\n\t\ta[y][x] = -1;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (0 <= x + dx[i] && x + dx[i] < w && 0 <= y + dy[i] && y + dy[i] < h) {\n\t\t\t\tif (a[y + dy[i]][x + dx[i]] == k) {\n\t\t\t\t\tcnt += count(k, x + dx[i], y + dy[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif ((h | w | c) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(f(1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main\n{\n\tstatic int[] D = { 1, 0, -1, 0 };\n\tstatic int w, h, c;\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true)\n\t\t{\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif ((h|w|c)==0)break;\n\n\t\t\tint[] board = new int[w * h];\n\t\t\tfor (int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tboard[y * w + x] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count(board, 5));\n\t\t}\n\t}\n\n\tstatic int count(int[] board, int t)\n\t{\n\t\tif (t == 0)\n\t\t{\n\t\t\treturn countColor(board);\n\t\t}\n\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= 6; i++)\n\t\t{\n\t\t\tif (board[0] == i) continue;\n\t\t\tint[] cb = Arrays.copyOf(board, board.length);\n\t\t\tchangeColor(cb, 0, 0, cb[0], i);\n\t\t\tmax = Math.max(max, count(cb, t - 1));\n\t\t}\n\t\treturn max;\n\t}\n\n\tstatic int countColor(int[] board)\n\t{\n\t\treturn countColor(board, 0, 0);\n\t}\n\n\tstatic int countColor(int[] board, int x, int y)\n\t{\n\t\tint count = 0;\n\t\tif (0 <= x && x < w && 0 <= y && y < h && board[y * w + x] == c)\n\t\t{\n\t\t\tcount++;\n\t\t\tboard[y * w + x] = 0;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint x2 = x + D[i];\n\t\t\t\tint y2 = y + D[(i + 1) % 4];\n\t\t\t\tcount += countColor(board, x2, y2);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tstatic void changeColor(int[] board, int x, int y, int c, int d)\n\t{\n\t\tif (0 <= x && x < w && 0 <= y && y < h && board[y * w + x] == c)\n\t\t{\n\t\t\tboard[y * w + x] = d;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint x2 = x + D[i];\n\t\t\t\tint y2 = y + D[(i + 1) % 4];\n\t\t\t\tchangeColor(board, x2, y2, c, d);\n\t\t\t}\n\t\t}\n\t}\n}\n/*\n3 5 5\n1 6 3 2 5\n2 5 4 6 1\n1 2 4 1 5\n4 5 6\n1 5 6 1 2\n1 4 6 3 2\n1 5 2 3 2\n1 1 2 3 2\n1 1 5\n1\n1 8 6\n1 2 3 4 5 1 2 3\n8 1 1\n1\n2\n3\n4\n5\n1\n2\n3\n8 8 6\n5 2 5 2 6 5 4 2\n4 2 2 2 5 2 2 2\n4 4 4 2 5 2 2 2\n6 4 5 2 2 2 6 6\n6 6 5 5 2 2 6 6\n6 2 5 4 2 2 6 6\n2 4 4 4 6 2 2 6\n2 2 2 5 5 2 2 2\n8 8 2\n3 3 5 4 1 6 2 3\n2 3 6 4 3 6 2 2\n4 1 6 6 6 4 4 4\n2 5 3 6 3 6 3 5\n3 1 3 4 1 5 6 3\n1 6 6 3 5 1 5 3\n2 4 2 2 2 6 5 3\n4 1 3 6 1 5 5 4\n0 0 0\n*/"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Identically Colored Panels Connection\n */\npublic class Main {\n\n\tenum COLOR {\n\t\tNONE, YELLOW, PINK, RED, PURPLE, GREEN, BLUE,\n\t}\n\n\tstatic int[][] DIR = {\n\t\t\t{1, 0},\n\t\t\t{0, 1},\n\t\t\t{-1, 0},\n\t\t\t{0, -1},\n\t};\n\n\tstatic COLOR tc;\n\tstatic int max = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st;\n\n\t\t\tst = new StringTokenizer(line);\n\n\t\t\tint h, w;\n\t\t\th = parseInt(st.nextToken());\n\t\t\tw = parseInt(st.nextToken());\n\t\t\ttc = COLOR.values()[parseInt(st.nextToken())];\n\t\t\tif ((h | w) == 0) break;\n\n\t\t\tCOLOR[][] pane = new COLOR[h + 2][w + 2];\n\n\t\t\tfor (COLOR[] pp : pane) {\n\t\t\t\tArrays.fill(pp, COLOR.NONE);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tpane[i + 1][j + 1] = COLOR.values()[st.nextToken().charAt(0) - '0'];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tmax = 0;\n\n\t\t\tsolve(pane, 5);\n\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tstatic void solve(COLOR[][] pane, int r) {\n\n\t\tif (r == 0) {\n\t\t\tif (pane[1][1] == tc) {\n\t\t\t\tint count = 0;\n\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\tqueue.offer(new int[]{1, 1});\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tint[] q = queue.poll();\n\t\t\t\t\tfor (int[] dir : DIR) {\n\t\t\t\t\t\tint ny, nx;\n\t\t\t\t\t\tny = q[0] + dir[0];\n\t\t\t\t\t\tnx = q[1] + dir[1];\n\t\t\t\t\t\tif (pane[ny][nx] == tc) {\n\t\t\t\t\t\t\tpane[ny][nx] = COLOR.NONE;\n\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count == 0) count = 1;\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tCOLOR pc = pane[1][1];\n\n\t\tfor (COLOR nc : COLOR.values()) {\n\t\t\tif (nc != COLOR.NONE && nc != pc) {\n\t\t\t\tif (r == 1 && nc != tc) break;\n\t\t\t\tCOLOR[][] _pane = copy(pane);\n\t\t\t\t_pane[1][1] = nc;\n\t\t\t\t//\n\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\tqueue.offer(new int[]{1, 1});\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tint[] q = queue.poll();\n\t\t\t\t\tfor (int[] dir : DIR) {\n\t\t\t\t\t\tint ny, nx;\n\t\t\t\t\t\tny = q[0] + dir[0];\n\t\t\t\t\t\tnx = q[1] + dir[1];\n\t\t\t\t\t\tif (_pane[ny][nx] == pc) {\n\t\t\t\t\t\t\t_pane[ny][nx] = nc;\n\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsolve(_pane, r - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic COLOR[][] copy(COLOR[][] pane) {\n\t\tCOLOR[][] _pane = new COLOR[pane.length][];\n\t\tfor (int i = 0; i < pane.length; i++) {\n\t\t\t_pane[i] = pane[i].clone();\n\t\t}\n\t\treturn _pane;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tint H, W, C;\n\tint[][] map;\n\tboolean visit[][];\n\tint max, cnt;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tC = sc.nextInt();\n\t\t\tif ((H | W | C) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap = new int[H][W];\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] use = new boolean[6];\n\t\t\tint[] parm = new int[5];\n\t\t\tmakePerm(0, parm, use);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tvoid makePerm(int n, int[] parm, boolean use[]) {\n\t\tif (n == 4) {\n\t\t\tparm[n] = C;\n\t\t\tsolve(parm);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tparm[n] = i;\n\t\t\tmakePerm(n + 1, parm, use);\n\t\t}\n\t}\n\n\tvoid solve(int parm[]) {\n\t\tint field[][] = new int[H][W];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfield[i][j] = map[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tvisit = new boolean[H][W];\n\t\t\tint first = field[0][0];\n\t\t\tdfs(field, parm[i], first, visit, 0, 0);\n\t\t}\n\t\tvisit = new boolean[H][W];\n\t\tif (field[0][0] == C && !visit[0][0]) {\n\t\t\tcnt = 1;\n\t\t\tcntMap(field, visit, 0, 0);\n\t\t\tmax = Math.max(max, cnt);\n\t\t}\n\t}\n\n\tvoid dfs(int[][] field, int num, int first, boolean[][] visit, int h, int w) {\n\t\tfield[h][w] = num;\n\t\tvisit[h][w] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dy[i];\n\t\t\tint nw = w + dx[i];\n\t\t\tif (nh >= 0 && nh < H && nw >= 0 && nw < W && !visit[nh][nw]\n\t\t\t\t\t&& field[nh][nw] == first) {\n\t\t\t\tdfs(field, num, first, visit, nh, nw);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid cntMap(int[][] field, boolean[][] visitf, int h, int w) {\n\t\tvisit[h][w] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dy[i];\n\t\t\tint nw = w + dx[i];\n\t\t\tif (nh >= 0 && nh < H && nw >= 0 && nw < W && !visit[nh][nw]\n\t\t\t\t\t&& field[nh][nw] == C) {\n\t\t\t\tcnt++;\n\t\t\t\tcntMap(field, visit, nh, nw);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1174();\n\t}\n\tclass AOJ1174{\n\t\tAOJ1174(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt(); W=sc.nextInt(); C=sc.nextInt();\n\t\t\t\tif((H|(W|C))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tint H,W,C;\n\t\tint[][][] b;\n\t\tfinal int[] vx={0,-1,0,1},vy={-1,0,1,0};\n\t\tvoid solve(){\n\t\t\tb=new int[6][W][H];\n\t\t\tfor(int h=0; h<H; ++h)for(int w=0; w<W; ++w)\tb[0][w][h]=sc.nextInt();\n\t\t\tSystem.out.println(backtracking(b,0,b[0][0][0]));\n\t\t}\n\t\tint backtracking(int[][][] b,int depth,int last){\n\t\t\tif(depth>=4)\treturn cnt(chg(depth, C));\n\t\t\tint ret=0;\n\t\t\tfor(int c=1; c<=6; ++c){\n\t\t\t\tif(c==last)\tcontinue;\n\t\t\t\tchg(depth, c);\n\t\t\t\tret=max(ret, backtracking(b, depth+1, c));\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tint[][] chg(int d,int target){\n\t\t\tfor(int w=0; w<W; ++w)for(int h=0; h<H; ++h)\tb[d+1][w][h]=b[d][w][h];\n\t\t\tb[d+1][0][0]=target;\n\t\t\tchg(d,0,0,target);\n\t\t\treturn b[d+1];\n\t\t}\n\t\tvoid chg(int d,int x,int y,int target){\n\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\tint nx=x+vx[v],ny=y+vy[v];\n\t\t\t\tif(!(0<=nx&&nx<W && 0<=ny&&ny<H))\tcontinue;\n\t\t\t\tif(b[d][nx][ny]!=b[d][0][0])\tcontinue;\n\t\t\t\tif(b[d+1][nx][ny]==target)\tcontinue;\n\t\t\t\tb[d+1][nx][ny]=target;\n\t\t\t\tchg(d,nx,ny,target);\n\t\t\t}\n\t\t}\n\t\tint cnt(int[][] a){\n\t\t\treturn cnt(a,0,0,a[0][0]);\n\t\t}\n\t\tint cnt(int[][] a,int x,int y,int c){\n\t\t\tint ret=1;\n\t\t\ta[x][y]=-1;\n\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\tint nx=x+vx[v],ny=y+vy[v];\n\t\t\t\tif(!(0<=nx&&nx<W && 0<=ny&&ny<H))\tcontinue;\n\t\t\t\tif(a[nx][ny]!=c)\tcontinue;\n\t\t\t\tret+=cnt(a, nx, ny, c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint w,h,c;\n\tint max;\n\tint[][] panel;\n\tvoid run() {\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif (w == 0 && h == 0 && c == 0) break;\n\t\t\tpanel = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) panel[i][j] = sc.nextInt();\n\t\t\tmax = 0;\n\t\t\tBFS( 0 );\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tint cntColor( int color, int chclr, int x, int y ) {\n//\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++){\n//\t\t\tSystem.out.print(panel[i][j] + \" \");\n//\t\t\tif (j==w)System.out.println();\n//\t\t}\n//\t\tSystem.out.println();\n\t\t\n\t\tint cnt=1;\n\t\tif( panel[y][x] != color )return 0;\n\t\tpanel[y][x] = chclr;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif( panel[y+dy[i]][x+dx[i]] == color ) \n\t\t\t\tcnt += cntColor( color, chclr, x+dx[i], y+dy[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid BFS( int cnt ) {\n\t\tif( cnt == 5 ) {\n//\t\t\tSystem.out.println(panel[1][1] + \" \" + c);\n\t\t\tif( panel[1][1] == c ) {\n//\t\t\t\tprintMap();\n//\t\t\t\tSystem.out.println();\n\t\t\t\tmax = Math.max(max, cntColor(c,0,1,1));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint[][] tmp = new int[h+2][w+2];\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++){\n\t\t\ttmp[i][j] = panel[i][j];\n//\t\t\tSystem.out.print(tmp[i][j] + \" \");\n//\t\t\tif (j==w)System.out.println();\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=6;i++) {\n\t\t\tif(panel[1][1] != i)\n\t\t\t\tcntColor( panel[1][1], i, 1, 1 );\n\t\t\tBFS( cnt+1 );\n\t\t\tfor(int j=1;j<=h;j++) for(int k=1;k<=w;k++)\n\t\t\t\tpanel[j][k] = tmp[j][k];\n\t\t}\n\t}\n\t\n\tpublic void printMap(){\n\t\tfor(int i=1;i<=h;i++) {\n\t\t\tfor (int j=1;j<=w;j++) System.out.print(panel[i][j] +\" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main( String[] args ) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  int h, w, c;\n\n  int[][] field;\n\n  int dfs(int depth) {\n    if ( depth == 4 ) {\n      fill( depth, c );\n      return fill( depth + 1, 7 );\n    }\n\n    int max = 0;\n    for ( int r = 1; r <= 6; ++r ) {\n      fill( depth, r );\n//      debug( depth );\n//      for ( int[] a : field ) {\n//        for ( int v : a ) {\n//          System.err.print( ( ( v >> ( depth * 3 ) ) & 7 ) );\n//          System.err.print( \":\" + ( ( v >> ( ( depth + 1 ) * 3 ) ) & 7 ) + \" \" );\n//        }\n//        System.err.println();\n//      }\n      max = Math.max( max, dfs( depth + 1 ) );\n    }\n    return max;\n  }\n\n  int[][] ofs = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\n\n  int fill(int depth, int color) {\n    int cnt = 0;\n    Queue<Integer> qx = new LinkedList<Integer>();\n    Queue<Integer> qy = new LinkedList<Integer>();\n    qx.add( 0 );\n    qy.add( 0 );\n    boolean[][] done = new boolean[h][w];\n    boolean[][] ok = new boolean[h + 2][w + 2];\n    for ( int i = 1; i <= h; ++i ) {\n      for ( int j = 1; j <= w; ++j ) {\n        ok[ i ][ j ] = true;\n      }\n    }\n    int atom = ( field[ 0 ][ 0 ] >> ( depth * 3 ) ) & 7;\n    int mask = ~( 7 << ( ( depth + 1 ) * 3 ) );\n    for ( int i = 0; i < h; ++i ) {\n      for ( int j = 0; j < w; ++j ) {\n        field[ i ][ j ] &= mask;\n        field[ i ][ j ] |= ( ( field[ i ][ j ] >> ( depth * 3 ) ) & 7 ) << ( ( depth + 1 ) * 3 );\n      }\n    }\n    field[ 0 ][ 0 ] &= mask;\n    field[ 0 ][ 0 ] |= color << ( ( depth + 1 ) * 3 );\n    done[ 0 ][ 0 ] = true;\n    ++cnt;\n    while (qx.size() > 0) {\n      int x = qx.poll();\n      int y = qy.poll();\n\n      for ( int[] d : ofs ) {\n        int nx = x + d[ 0 ];\n        int ny = y + d[ 1 ];\n        if ( ok[ ny + 1 ][ nx + 1 ] && !done[ ny ][ nx ]\n            && ( ( field[ ny ][ nx ] >> ( depth * 3 ) ) & 7 ) == atom ) {\n          done[ ny ][ nx ] = true;\n          field[ ny ][ nx ] &= mask;\n          field[ ny ][ nx ] |= color << ( ( depth + 1 ) * 3 );\n          qx.add( nx );\n          qy.add( ny );\n          ++cnt;\n        }\n      }\n    }\n\n    return cnt;\n  }\n\n  void run() {\n    for ( ;; ) {\n      h = ni();\n      w = ni();\n      c = ni();\n      if ( ( h | w | c ) == 0 ) {\n        break;\n      }\n\n      field = new int[h][w];\n      for ( int i = 0; i < h; ++i ) {\n        for ( int j = 0; j < w; ++j ) {\n          field[ i ][ j ] = ni();\n        }\n      }\n\n      System.out.println( dfs( 0 ) );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int h,w,c,max;\n\tstatic int[][] panel;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\th=cin.nextInt();\n\t\t\tw=cin.nextInt();\n\t\t\tc=cin.nextInt();\n\t\t\tmax=-1;\n\t\t\tif(h+w+c==0)break;\n\t\t\tpanel=new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[i][j]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\tstatic void bt(int depth){\n\t\tif(depth==5){\n\t\t\tint ans=0;\n\t\t\tif(panel[0][0]==c){\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\t\t\tSystem.out.print(panel[i][j]+\" \");\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\t\t\tq.add(new int[]{0,0});\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\n\t\t\t\t\tint[] aaa=q.poll();\n\t\t\t\t\tint x=aaa[0];\n\t\t\t\t\tint y=aaa[1];\n\t\t\t\t\tif(panel[x][y]==-1)continue;\n\t\t\t\t\tpanel[x][y]=-1;\n\t\t\t\t\tans++;\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tint xx=x+v1[j];\n\t\t\t\t\t\tint yy=y+v2[j];\n\t\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\t\tif(panel[xx][yy]!=c)continue;\n\t\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(ans);\t\n\t\t\t\tmax=Math.max(ans,max);\n\t\t\t\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tif(panel[0][0]==i)continue;\n\t\t\tint[][] cp = new int[h][w];\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcp[k][j]=panel[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint color=panel[0][0];\n\t\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\t\tq.add(new int[]{0,0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] aaa=q.poll();\n\t\t\t\tint x=aaa[0];\n\t\t\t\tint y=aaa[1];\n\t\t\t\tpanel[x][y]=i;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tint xx=x+v1[j];\n\t\t\t\t\tint yy=y+v2[j];\n\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\tif(panel[xx][yy]!=color)continue;\n\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(depth+1);\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[k][j]=cp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tif (h == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint w = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\n\t\t\tint[][] panel = new int[h][w];\n\t\t\tint[][] dummy = new int[h][w];\n\t\t\tfor (int i = 0; i < panel.length; i++) {\n\t\t\t\tfor (int j = 0; j < panel[i].length; j++) {\n\t\t\t\t\tpanel[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int i1 = 1; i1 <= 6; i1++) {\n\t\t\t\tfor (int i2 = 1; i2 <= 6; i2++) {\n\t\t\t\t\tfor (int i3 = 1; i3 <= 6; i3++) {\n\t\t\t\t\t\tfor (int i4 = 1; i4 <= 6; i4++) {\n\t\t\t\t\t\t\tfor (int i = 0; i < dummy.length; i++) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < dummy[0].length; j++) {\n\t\t\t\t\t\t\t\t\tdummy[i][j] = panel[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcheck(dummy, i1);\n\t\t\t\t\t\t\tcheck(dummy, i2);\n\t\t\t\t\t\t\tcheck(dummy, i3);\n\t\t\t\t\t\t\tcheck(dummy, i4);\n\t\t\t\t\t\t\tcheck(dummy, c);\n\t\t\t\t\t\t\tmax = Math.max(max, check(dummy, c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\t\t\tSystem.gc(); // 1テストケースごとにメモリを解放\n\t\t}\n\n\t}\n\n\tstatic int check(int[][] dummy, int c) {\n\t\tint old = dummy[0][0];\n\t\tboolean[][] used = new boolean[dummy.length][dummy[0].length];\n\t\tDeque<Integer[]> deque = new ArrayDeque<Integer[]>();\n\t\tInteger[] first = { 0, 0 };\n\t\tdeque.add(first);\n\t\tused[0][0] = true;\n\t\tdummy[0][0] = c;\n\t\tint ret = 1;\n\n\t\tint[][] dir = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\t\twhile (!deque.isEmpty()) {\n\t\t\tInteger[] poll = deque.poll();\n\t\t\tint i = poll[0];\n\t\t\tint j = poll[1];\n\n\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\tif (i + dir[k][0] >= 0 && i + dir[k][0] < dummy.length && j + dir[k][1] >= 0\n\t\t\t\t\t\t&& j + dir[k][1] < dummy[0].length && !used[i + dir[k][0]][j + dir[k][1]]\n\t\t\t\t\t\t&& dummy[i + dir[k][0]][j + dir[k][1]] == old) {\n\t\t\t\t\tInteger[] put = { i + dir[k][0], j + dir[k][1] };\n\t\t\t\t\tdeque.add(put);\n\t\t\t\t\tused[i + dir[k][0]][j + dir[k][1]] = true;\n\t\t\t\t\tdummy[i + dir[k][0]][j + dir[k][1]] = c;\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tif (h == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint w = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\n\t\t\tint[][] panel = new int[h][w];\n\t\t\tint[][] dummy = new int[h][w];\n\t\t\tfor (int i = 0; i < panel.length; i++) {\n\t\t\t\tfor (int j = 0; j < panel[i].length; j++) {\n\t\t\t\t\tpanel[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int i1 = 1; i1 <= 6; i1++) {\n\t\t\t\tfor (int i2 = 1; i2 <= 6; i2++) {\n\t\t\t\t\tfor (int i3 = 1; i3 <= 6; i3++) {\n\t\t\t\t\t\tfor (int i4 = 1; i4 <= 6; i4++) {\n\t\t\t\t\t\t\tfor (int i = 0; i < dummy.length; i++) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < dummy[0].length; j++) {\n\t\t\t\t\t\t\t\t\tdummy[i][j] = panel[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcheck(dummy, i1);\n\t\t\t\t\t\t\tcheck(dummy, i2);\n\t\t\t\t\t\t\tcheck(dummy, i3);\n\t\t\t\t\t\t\tcheck(dummy, i4);\n\t\t\t\t\t\t\tcheck(dummy, c);\n\t\t\t\t\t\t\tmax = Math.max(max, check(dummy, c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tstatic int check(int[][] dummy, int c) {\n\t\tint old = dummy[0][0];\n\t\tboolean[][] used = new boolean[dummy.length][dummy[0].length];\n\t\tDeque<Integer[]> deque = new ArrayDeque<Integer[]>();\n\t\tInteger[] first = { 0, 0 };\n\t\tdeque.add(first);\n\t\tused[0][0] = true;\n\t\tdummy[0][0] = c;\n\t\tint ret = 1;\n\n\t\tint[][] dir = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\t\twhile (!deque.isEmpty()) {\n\t\t\tInteger[] poll = deque.poll();\n\t\t\tint i = poll[0];\n\t\t\tint j = poll[1];\n\n\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\tif (i + dir[k][0] >= 0 && i + dir[k][0] < dummy.length && j + dir[k][1] >= 0\n\t\t\t\t\t\t&& j + dir[k][1] < dummy[0].length && !used[i + dir[k][0]][j + dir[k][1]]\n\t\t\t\t\t\t&& dummy[i + dir[k][0]][j + dir[k][1]] == old) {\n\t\t\t\t\tInteger[] put = { i + dir[k][0], j + dir[k][1] };\n\t\t\t\t\tdeque.add(put);\n\t\t\t\t\tused[i + dir[k][0]][j + dir[k][1]] = true;\n\t\t\t\t\tdummy[i + dir[k][0]][j + dir[k][1]] = c;\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    public static void main ( String [] args ) throws IOException\n\n\n    {\n    \t\n\tnew Main().cal();\n    }\n\n \n    private void cal() throws IOException \n    {\n    \twhile(true){\n\t    String[] buffer=br.readLine().split(\"\\\\s\");\n    \t\n\t    int height=Integer.parseInt(buffer[0]);\n\n\n\t    int width=Integer.parseInt(buffer[1]);\n\t    int objectColor = Integer.parseInt(buffer[2]);\n\t    int[][] arr=new int[height][width];\n\t    int max=0;\n    \t\t\n\t    if(height==0 && width==0 && objectColor==0)\n\t    \tbreak;\n    \t\t\n\t    for(int i=0;i<height;i++){\n\t    \tString[] temp=br.readLine().split(\"\\\\s\");\n\t    \tfor(int j=0;j<width;j++)\n\t    \t\tarr[i][j]=Integer.parseInt(temp[j]);\n\t    \t}\n    \t\t\n\t    for(int i=1;i<7;i++)\n\t\tfor(int j=1;j<7;j++)\n\t\t    for(int k=1;k<7;k++)\n\t\t\tfor(int m=1;m<7;m++){\n\t\t\t    int temp=checkColor(0,0,change(arr,m,k,j,i,objectColor),objectColor);\n\t\t\t\t\t\t\n\t    \t\t\t\t\tif(max<temp){\n\t    \t\t\t\t\t\tmax=temp;\n\t\t\t\t\t\t\t/*\t\tfor(int z=0;z<height;z++){\n\t\t\t\t\t\t\t    for(int x=0;x<width;x++)\n\t\t\t\t\t\t\t\tSystem.out.print(change(arr,m,k,j,i,objectColor)[z][x]+\" \");\n\t\t\t\t\t\t\t\tSystem.out.println(\"\");\t\t    }\t\t\tSystem.out.println(\"max : \"+max);\n\t\t\t\t\t\t*/\t\n\t\t\t\t\t\t}}\n\t    \n\t    System.out.println(max);\n    \t}\n\n    \t\n    }\n    public int[][] change(int[][] arr,int m,int k,int j,int i,int Color){\n\n\n    \tint[][]tempArr=(int[][]) clone(arr);\n\tint initial=tempArr[0][0];\n\n\tchangeCell(tempArr,0,0,m,initial);\n\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=m;\n\n     \tchangeCell(tempArr,0,0,k,m);\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=k;\n\n    \tchangeCell(tempArr,0,0,j,k); \n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=j;\n\n    \tchangeCell(tempArr,0,0,i,j);\n \n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=i;\n\n    \tchangeCell(tempArr,0,0,Color,i);\n\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=Color;\n\n    \treturn tempArr; \n    }\n    \n    public static Object[] clone(int[][] arr){\n    \t\tif(arr==null)\n    \t\t\t\treturn null;\n    \t\telse {\n\t\t    int[][] temp=new int[arr.length][arr[0].length];\n\t\t    for(int i=0;i<arr.length;i++)\n\t\t\tfor(int j=0;j<arr[0].length;j++)\n\t\t\t    temp[i][j]=arr[i][j];\n\t\t    \n    \t\t\t\treturn temp;\n\t\t}\n    }\n    \n    public int checkColor(int a,int b,int[][] checkingArr,int Color){\n    \t\n    \t\tif(a>=0 && b>=0 &&a<checkingArr.length&& b<checkingArr[0].length&&checkingArr[a][b]==Color){\n\t\t    checkingArr[a][b]=0;\n\t\t    return 1+\ncheckColor(a-1,b,checkingArr,Color)+checkColor(a+1,b,checkingArr,Color)+\ncheckColor(a,b-1,checkingArr,Color)+checkColor(a,b+1,checkingArr,Color);\n    \t\t}\n    \t\telse \n    \t\t\t\treturn 0;\n    }\n    \n    public void changeCell(int[][] tempArr,int a, int b,int c,int d){\n\n    \ttempArr[a][b]=0;\n    \t\n    \tif(a>0 && tempArr[a-1][b]==d)\n    \t\tchangeCell(tempArr,a-1,b,c,d);\n    \tif(b>0 && tempArr[a][b-1]==d)\n    \t\tchangeCell(tempArr,a,b-1,c,d);\n    \tif(a<tempArr.length-1 && tempArr[a+1][b]==d)\n    \t\tchangeCell(tempArr,a+1,b,c,d);\n    \tif(b<tempArr[0].length-1 && tempArr[a][b+1]==d)\n    \t\tchangeCell(tempArr,a,b+1,c,d);\n\t\n\n\n    \t\n    }\n\n    \n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic byte h,w,c;\n\tstatic int max;\n\tstatic byte[][] panel;\n\tstatic byte[] v1={0,1,0,-1};\n\tstatic byte[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\th=cin.nextByte();\n\t\t\tw=cin.nextByte();\n\t\t\tc=cin.nextByte();\n\t\t\tmax=-1;\n\t\t\tif(h+w+c==0)break;\n\t\t\tpanel=new byte[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[i][j]=cin.nextByte();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\tstatic void bt(int depth){\n\t\tif(depth==4){\n\t\t\tif(panel[0][0]==c){\n\t\t\t\tmax=Math.max(count(),max);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbyte[][] cp = new byte[h][w];\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcp[k][j]=panel[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint color=panel[0][0];\n\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\tq.add(new byte[]{0,0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte x=aaa[0];\n\t\t\t\tbyte y=aaa[1];\n\t\t\t\tif(panel[x][y]!=color)continue;\n\t\t\t\tpanel[x][y]=c;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte xx=(byte) (x+v1[j]);\n\t\t\t\t\tbyte  yy=(byte) (y+v2[j]);\n\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\tif(panel[xx][yy]!=color)continue;\n\t\t\t\t\tq.add(new byte[]{xx,yy});\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax=Math.max(count(),max);\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[k][j]=cp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t\t\n\t\t}\n\t\tfor(byte i=1;i<=6;i++){\n\t\t\tif(panel[0][0]==i)continue;\n\t\t\tbyte[][] cp = new byte[h][w];\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcp[k][j]=panel[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint color=panel[0][0];\n//\t\t\tint count=count();\n\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\tq.add(new byte[]{0,0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tbyte[] aaa=q.poll();\n\t\t\t\tbyte x=aaa[0];\n\t\t\t\tbyte y=aaa[1];\n\t\t\t\tif(panel[x][y]!=color)continue;\n\t\t\t\tpanel[x][y]=i;\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tbyte xx=(byte) (x+v1[j]);\n\t\t\t\t\tbyte  yy=(byte) (y+v2[j]);\n\t\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\t\tif(panel[xx][yy]!=color)continue;\n\t\t\t\t\tq.add(new byte[]{xx,yy});\n\t\t\t\t}\n\t\t\t}\n//\t\t\tif(count!=count())\n\t\t\t\tbt(depth+1);\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpanel[k][j]=cp[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic int count(){\n\t\tint ans=0;\n\t\tbyte[][] cp = new byte[h][w];\n\t\tfor(int k=0;k<h;k++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcp[k][j]=panel[k][j];\n\t\t\t}\n\t\t}\n\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\tq.add(new byte[]{0,0});\n\t\twhile(!q.isEmpty()){\n\t\t\t\n\t\t\tbyte[] aaa=q.poll();\n\t\t\tbyte x=aaa[0];\n\t\t\tbyte y=aaa[1];\n\t\t\tif(cp[x][y]==-1)continue;\n\t\t\tcp[x][y]=-1;\n\t\t\tans++;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tbyte xx=(byte) (x+v1[j]);\n\t\t\t\tbyte yy=(byte) (y+v2[j]);\n\t\t\t\tif(xx<0||yy<0||xx>=h||yy>=w)continue;\n\t\t\t\tif(cp[xx][yy]!=c)continue;\n\t\t\t\tq.add(new byte[]{xx,yy});\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = true;\n\tstatic final int[] d = { 0, 1, 0, -1 };\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint h = ir.nextInt();\n\t\t\tint w = ir.nextInt();\n\t\t\tint c = ir.nextInt();\n\t\t\tif (h == 0 && w == 0 && c == 0)\n\t\t\t\treturn;\n\t\t\tint[][] p = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tp[i] = ir.nextIntArray(w);\n\t\t\tout.println(dfs(0, p, h, w, c));\n\t\t}\n\t}\n\n\tstatic int dfs(int t, int[][] p, int h, int w, int c) {\n\t\tint ret = 1;\n\t\tDeque<int[]> que = new ArrayDeque<int[]>();\n\t\tque.offerLast(new int[] { 0, 0 });\n\t\tboolean[][] adj = new boolean[h][w];\n\t\tadj[0][0] = true;\n\t\twhile (!que.isEmpty()) {\n\t\t\tint[] f = que.pollFirst();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = f[0] + d[i];\n\t\t\t\tint ny = f[1] + d[i ^ 1];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w && !adj[nx][ny] && p[f[0]][f[1]] == p[nx][ny]) {\n\t\t\t\t\tadj[nx][ny] = true;\n\t\t\t\t\tque.offerLast(new int[] { nx, ny });\n\t\t\t\t\tif (t == 5)\n\t\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (t == 5)\n\t\t\treturn ret;\n\t\tint b = p[0][0];\n\t\tif (t == 4) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (adj[i][j])\n\t\t\t\t\t\tp[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = dfs(t + 1, p, h, w, c);\n\t\t} else {\n\t\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\t\tif (i == b)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tif (adj[j][k])\n\t\t\t\t\t\t\tp[j][k] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret = Math.max(ret, dfs(t + 1, p, h, w, c));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (adj[i][j])\n\t\t\t\t\tp[i][j] = b;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int h,w;\n\tstatic int[][] p=new int[9][9];\n\tstatic int c, size;\n\t\n\tstatic void dfs1(int[][] cpp,int count) {\n\t\tint[][] cp=new int[9][9];\n\t\tfor(int i=1; i<=6; i++) {\n\t\t\tif(count==5 && i!=c) continue;\n\t\t\tif(i==cpp[1][1]) continue;\n\t\t\tfor(int x=1; x<=h; x++) {\n\t\t\t\tfor(int y=1; y<=w; y++) {\n\t\t\t\t\tcp[x][y]=cpp[x][y];\n\t\t\t\t\t//System.out.print(cp[x][y]);\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t//System.out.println();\n\t\t\tif(count==6) {\n\t\t\t\tdfs(cp, 1,1,cp[1][1], 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//System.out.println(cp[1][1]+\" \"+i);\n\t\t\t\tdfs(cp, 1,1,cp[1][1],i);\n\t\t\t}\n\t\t\tif(count==6) {\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int x=1; x<=h; x++) {\n\t\t\t\t\tfor(int y=1; y<=w; y++) {\n\t\t\t\t\t\tif(cp[x][y]==0) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsize=Math.max(sum, size);\n\t\t\t\t//System.out.println(\"size=\"+size);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdfs1(cp, count+1);\n\t\t}\n\t}\n\t\n\tstatic void dfs(int[][] cp, int x, int y, int c1, int c2) {//c1変化前　c2変化後\n\t\tif(x>=1 && x<=h && y>=1 && y<=w) {\n\t\t\tif(cp[x][y]==c1) {\n\t\t\t\tcp[x][y]=c2;\n\t\t\t\tdfs(cp, x+1, y, c1, c2);\n\t\t\t\tdfs(cp, x-1, y, c1, c2);\n\t\t\t\tdfs(cp, x, y+1, c1, c2);\n\t\t\t\tdfs(cp, x, y-1, c1, c2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\th=sc.nextInt();\n\t\t\t\tw=sc.nextInt();\n\t\t\t\tc=sc.nextInt();\n\t\t\t\tif(h+w+c==0) break;\n\t\t\t\t\n\t\t\t\tfor(int i=1; i<=h; i++) {\n\t\t\t\t\tfor(int j=1; j<=w; j++) {\n\t\t\t\t\t\tp[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsize=0;\n\t\t\t\tdfs1(p, 1);\n\t\t\t\tSystem.out.println(size);\n\t\t\t}\n\n\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic boolean hasNext(int[] r,int[] a){\n\t\tfor(int i=r.length-1;i>=0;i--){\n\t\t\tif(a[i]+1<r[i])return true;\n\t\t}\n\t\treturn false;\n\t}\n\tstatic boolean next(int[] r,int[] a){\n\t\tfor(int i=r.length-1;i>=0;i--){\n\t\t\tif(a[i]+1<r[i]){\n\t\t\t\ta[i]++;return true;\n\t\t\t}else{\n\t\t\t\ta[i]=0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tclass P{\n\t\tint x,y;\n\t\tP(int _y,int _x){\n\t\t\tx=_x;y=_y;\n\t\t}\n\t}\n\n\tfinal int[] dx=new int[]{1,0,-1,0},dy=new int[]{0,1,0,-1};\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt(),C=sc.nextInt()-1;\n\t\t\tif(H==0 && W==0)return;\n\t\t\tint[][] map=new int[H][W];\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++)\n\t\t\t\tmap[h][w]=sc.nextInt()-1;\n\n\t\t\tint M=0;\n\t\t\tfor(int[] is=new int[5],R=new int[]{6,6,6,6,6};hasNext(R,is);next(R,is)){\n\t\t\t\tif(is[4]!=C)continue;\n\t\t\t\tboolean[][] passed=new boolean[H][W];\n\n\t\t\t\tQueue<P> que=new LinkedList<P>();\n\t\t\t\tpassed[0][0]=true;\n\t\t\t\tint c=map[0][0];\n\t\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\t\t//キューに突っ込む\n\t\t\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\t\t\tif(passed[h][w])que.add(new P(h,w));\n\t\t\t\t\t}\n\t\t\t\t\tQueue<P> tmp=new LinkedList<P>();\n\t\t\t\t\twhile(!que.isEmpty()){\n\t\t\t\t\t\tP p=que.poll();\n\t\t\t\t\t\tfor(int di=0;di<4;di++){\n\t\t\t\t\t\t\tint x=p.x+dx[di],y=p.y+dy[di];\n\t\t\t\t\t\t\tif(0<=x && x< W && 0<=y && y<H){\n\t\t\t\t\t\t\t\tif(map[y][x]==c && !passed[y][x]){\n\t\t\t\t\t\t\t\t\tque.add(new P(y,x));\n\t\t\t\t\t\t\t\t\tpassed[y][x]=true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i+1==6)break;\n\n\t\t\t\t\t//next\n\t\t\t\t\tque=tmp;\n\t\t\t\t\t//color change\n\t\t\t\t\tc=is[i];\n\t\t\t\t}\n\n\t\t\t\tint co=0;\n\t\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\t\tif(passed[h][w])co++;\n\t\t\t\t}\n\t\t\t\tM=max(co,M);\n\t\t\t}\n\t\t\tln(M);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    Scanner sc;\n\n    int h, w, c;\n    int[][] p;\n    boolean[][] done; // biribiri用フラグ\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    Main() {\n        sc = new Scanner(System.in);\n    }\n\n    boolean init() {\n        h = sc.nextInt();\n        w = sc.nextInt();\n        c = sc.nextInt();\n\n        if (h == 0 && w == 0 && c == 0) return false;\n\n        p = new int[h][w];\n        for (int i = 0; i < h; i++) \n            for (int j = 0; j < w; j++) \n                p[i][j] = sc.nextInt();\n\n        return true;\n    }\n\n    void debug_p() {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) \n                System.out.print(p[i][j] + \" \");\n            System.out.println(\"\");\n        }\n    }\n\n    void run() {\n        while (init()) {\n            System.out.println(solve());\n        }\n    }\n\n    int solve() {\n        return max_panel(0);\n    }\n\n    int dx[] = {0, 1, 0, -1},\n        dy[] = {1, 0, -1, 0};\n\n    int count(int y, int x) {\n        done = new boolean[h][w];\n        return count_dfs(y, x);\n    }\n\n    int count_dfs(int y, int x) {\n        if (p[y][x] != c) return 0;\n        done[y][x] = true;\n        int cnt = 1;\n        for (int i = 0; i < 4; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (0 <= ny && ny < h && 0 <= nx && nx < w && !done[ny][nx]) {\n                cnt += count_dfs(ny, nx);\n            }\n        }\n        return cnt;\n    }\n\n    void change_color(int color) {\n        done = new boolean[h][w];\n        biribiri(0, 0, color);\n//        debug_p();\n    }\n\n    void biribiri(int y, int x, int color) {\n        done[y][x] = true;\n//        System.out.printf(\"%d,%d: %d\\n\", x, y, color);\n        int prev = color;\n        for (int i = 0; i < 4; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (0 <= ny && ny < h && 0 <= nx && nx < w && p[y][x] == p[ny][nx] && !done[ny][nx]) {\n                biribiri(ny, nx, color);\n            }\n        }\n        p[y][x] = color;\n    }\n\n    int max_panel(int time) {\n//        System.out.printf(\"%d \", time);\n        if (time == 4) {\n            int cnt;\n            int _p[][] = new int[h][w];\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                    _p[i][j] = p[i][j];\n            change_color(c);\n            cnt = count(0, 0);\n//            debug_p();\n            for (int i = 0; i < h; i++) \n                for (int j = 0; j < w; j++)\n                    p[i][j] = _p[i][j];\n//            System.out.printf(\"%d\\n\", cnt);\n            return cnt; \n        }\n        int cnt = 0;\n        for (int color = 1; color <= 6; color++) {\n            int _p[][] = new int[h][w];\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                    _p[i][j] = p[i][j];\n            change_color(color);\n            cnt = Math.max(cnt, max_panel(time+1));\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                    p[i][j] = _p[i][j];\n        }\n        return cnt;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main {\n\tint chkP[][]; \n\tstatic final int NUM_COLOR = 6;\n\tvoid run(){\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = s.nextInt();\n\t\t\tint w = s.nextInt();\n\t\t\tint c = s.nextInt();\n\t\t\tif(h == 0 && w == 0 && c == 0)break;\n\t\t\tint p[][] = new int[h][w];\n\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t\t\tp[i][j] = s.nextInt();\n\t\t\tint max = 0;\n\t\t\tfor(int t1 = 1;t1 <= NUM_COLOR;t1++){\n\t\t\t\tfor(int t2 = 1;t2 <= NUM_COLOR;t2++){\n\t\t\t\t\tfor(int t3 = 1;t3 <= NUM_COLOR;t3++){\n\t\t\t\t\t\tfor(int t4 = 1;t4 <= NUM_COLOR;t4++){\n\t\t\t\t\t\t\tint workP[][] = new int[h][w];\n\t\t\t\t\t\t\tchkP = new int[h][w];\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\t\t\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t\t\t\t\t\t\tchkP[i][j] = 1;\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\t\t\t\t\tSystem.arraycopy(p[i], 0, workP[i], 0, p[i].length);\n\t\t\t\t\t\t\t//System.out.println(t1 + \" \" + t2 + \" \" + t3 + \" \" + t4 );\n\t\t\t\t\t\t\tworkP = changeColor(workP,t1,0,0);\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\t\t\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t\t\t\t\t\t\tchkP[i][j] = 1;\n\t\t\t\t\t\t\tworkP = changeColor(workP,t2,0,0);\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\t\t\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t\t\t\t\t\t\tchkP[i][j] = 1;\n\t\t\t\t\t\t\tworkP = changeColor(workP,t3,0,0);\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\t\t\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t\t\t\t\t\t\tchkP[i][j] = 1;\n\t\t\t\t\t\t\tworkP = changeColor(workP,t4,0,0);\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\t\t\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t\t\t\t\t\t\tchkP[i][j] = 1;\n\t\t\t\t\t\t\tworkP = changeColor(workP,c,0,0);\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\t\t\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t\t\t\t\t\t\tchkP[i][j] = 1;\n\t\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\t\tcnt = cntColor(workP,c,0,0);\n\t\t\t\t\t\t\tmax = Math.max(max,cnt);\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tint[][] changeColor(int[][] panel,int color,int x,int y){\n\t\tchkP[x][y] = -1; \n\t\tif(x + 1 < panel.length    ){\n\t\t\tif( chkP[x + 1][y] != -1 ){\n\t\t\t\tif( panel[x + 1][y] == panel[x][y]){\n\t\t\t\t\tpanel = changeColor(panel,color,x + 1,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x     > 0               ){\n\t\t\tif(chkP[x - 1][y] != -1 ){\n\t\t\t\tif(panel[x - 1][y] == panel[x][y]){\n\t\t\t\t\tpanel = changeColor(panel,color,x - 1,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(y + 1 < panel[x].length ){\n\t\t\tif( chkP[x][y + 1] != -1 ){\n\t\t\t\tif(panel[x][y + 1] == panel[x][y]){\n\t\t\t\t\tpanel = changeColor(panel,color,x,y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(y     > 0               ){\n\t\t\tif(chkP[x][y - 1] != -1 ){\n\t\t\t\tif(panel[x][y - 1] == panel[x][y]){\n\t\t\t\t\tpanel = changeColor(panel,color,x,y - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpanel[x][y] = color;\n\t\treturn panel;\n\t}\n\n\tint cntColor(int[][] panel,int color,int x,int y){\n\t\tchkP[x][y] = -1; \n\t\tint cnt = 0;\n\t\tif(x + 1 < panel.length    && chkP[x + 1][y] != -1 && panel[x + 1][y] == panel[x][y])cnt += cntColor(panel,color,x + 1,y);\n\t\tif(x     > 0               && chkP[x - 1][y] != -1 && panel[x - 1][y] == panel[x][y])cnt += cntColor(panel,color,x - 1,y);\n\t\tif(y + 1 < panel[x].length && chkP[x][y + 1] != -1 && panel[x][y + 1] == panel[x][y])cnt += cntColor(panel,color,x,y + 1);\n\t\tif(y     > 0               && chkP[x][y - 1] != -1 && panel[x][y - 1] == panel[x][y])cnt += cntColor(panel,color,x,y - 1);\n\t\tcnt++;\n\t\treturn cnt;\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\t\n\t\twhile(h != 0 || w != 0 || c != 0){\n\t\t\tint[][] p = new int[h + 2][w + 2];\n\t\t\tfor(int i = 1; i <= h; i++){\n\t\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\t\tp[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint size = 0;\n\t\t\tfor(int i = 1; i < p[1][1]; i++){\n\t\t\t\tsize = Math.max(size, func(p, c, 1, i));\n\t\t\t}\n\t\t\tfor(int i = p[1][1] + 1; i <= 6; i++){\n\t\t\t\tsize = Math.max(size, func(p, c, 1, i));\n\t\t\t}\n\t\t\tSystem.out.println(size);\n\t\t\t\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tsc.close();\n\t}\n\tstatic int func(int[][] p, int c, int cnt, int drw){\n\t\tint size = 0;\n\t\tint oc = p[1][1];\n\t\t\n\t\tboolean[][] chk = new boolean[p.length][p[0].length];\n\t\tfor(int i = 0; i < p.length; i++){\n\t\t\tArrays.fill(chk[i], false);\n\t\t}\n\t\tint[][] cp = new int[p.length][p[0].length];\n\t\tfor(int i = 0; i < p.length; i++){\n\t\t\tfor(int j = 0; j < p[0].length; j++){\n\t\t\t\tcp[i][j] = p[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<A> list = new LinkedList<A>();\n\t\t\n\t\tlist.push(new A(1, 1));\n\t\twhile(!list.isEmpty()){\n\t\t\tA a = list.poll();\n\t\t\tif(!chk[a.h][a.w]){\n\t\t\t\tcp[a.h][a.w] = drw;\n\t\t\t\tchk[a.h][a.w] = true;\n\t\t\t\t\n\t\t\t\tif(!chk[a.h - 1][a.w] && p[a.h - 1][a.w] == oc){\n\t\t\t\t\tlist.add(new A(a.h - 1, a.w));\n\t\t\t\t}\n\t\t\t\tif(!chk[a.h + 1][a.w] && p[a.h + 1][a.w] == oc){\n\t\t\t\t\tlist.add(new A(a.h + 1, a.w));\n\t\t\t\t}\n\t\t\t\tif(!chk[a.h][a.w - 1] && p[a.h][a.w - 1] == oc){\n\t\t\t\t\tlist.add(new A(a.h, a.w - 1));\n\t\t\t\t}\n\t\t\t\tif(!chk[a.h][a.w + 1] && p[a.h][a.w + 1] == oc){\n\t\t\t\t\tlist.add(new A(a.h, a.w + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(cnt == 5){\n\t\t\tfor(int i = 0; i < p.length; i++){\n\t\t\t\tArrays.fill(chk[i], false);\n\t\t\t}\n\t\t\tlist.push(new A(1, 1));\n\t\t\twhile(!list.isEmpty()){\n\t\t\t\tA a = list.poll();\n\t\t\t\tif(!chk[a.h][a.w]){\n\t\t\t\t\tsize++;\n\t\t\t\t\tchk[a.h][a.w] = true;\n\t\t\t\t\tif(!chk[a.h - 1][a.w] && cp[a.h - 1][a.w] == c){\n\t\t\t\t\t\tlist.add(new A(a.h - 1, a.w));\n\t\t\t\t\t}\n\t\t\t\t\tif(!chk[a.h + 1][a.w] && cp[a.h + 1][a.w] == c){\n\t\t\t\t\t\tlist.add(new A(a.h + 1, a.w));\n\t\t\t\t\t}\n\t\t\t\t\tif(!chk[a.h][a.w - 1] && cp[a.h][a.w - 1] == c){\n\t\t\t\t\t\tlist.add(new A(a.h, a.w - 1));\n\t\t\t\t\t}\n\t\t\t\t\tif(!chk[a.h][a.w + 1] && cp[a.h][a.w + 1] == c){\n\t\t\t\t\t\tlist.add(new A(a.h, a.w + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(cnt == 4){\n\t\t\tsize = Math.max(size, func(cp, c, cnt + 1, c));\n\t\t}else{\n\t\t\tfor(int i = 1; i < cp[1][1]; i++){\n\t\t\t\tsize = Math.max(size, func(cp, c, cnt + 1, i));\n\t\t\t}\n\t\t\tfor(int i = cp[1][1] + 1; i <= 6; i++){\n\t\t\t\tsize = Math.max(size, func(cp, c, cnt + 1, i));\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\n}\nclass A{\n\tint h;\n\tint w;\n\tA(int h, int w){\n\t\tthis.h = h;\n\t\tthis.w = w;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    int h,w,c;\n    int max;\n    int from,to;\n    int ans;\n    int[][] panel2;\n    int[] dx = {1,-1,0,0};\n    int[] dy = {0,0,1,-1};\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\th = sc.nextInt();\n\twhile(h!=0){\n\t    ans = 0;\n\t    w = sc.nextInt();\n\t    c = sc.nextInt();\n\t    int[][] panel = new int[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    panel[i][j] = sc.nextInt();\n\t\t}\n\t    }\n\t    \n\t    max = Integer.MIN_VALUE;\n\t    dfs(0,panel);\n\t    System.out.println(max);\n\n\t    h = sc.nextInt();\n\t}\n    }\n\n    //深さ優先探索\n    void dfs(int count, int[][] panel){\n\tif(count==4){\n\t    if(panel[0][0]==c){return;}\n\t    from = panel[0][0]; to = c;\n\t    panel2 = panel;\n\t    change(0,0);\n\n\t    ans = 0;\n\t    from = c; to = 7;\n\t    change(0,0);\n\t    max = Math.max(max,ans);\n\t    return;\n\t}\n\n\t//パネルのコピー作成\n\tpanel2 = new int[h][w];\n\tfor(int i=0; i<h; i++){\n\t    for(int j=0; j<w; j++){\n\t\tpanel2[i][j] = panel[i][j];\n\t    }\n\t}\n\tfor(int i=1; i<=6; i++){\n\t    if(i==panel[0][0])continue;\n\t    from = panel[0][0]; to = i;\n\t    change(0,0);\n\t    dfs(count+1,panel2);\n\t    for(int k=0; k<h; k++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    panel2[k][j] = panel[k][j];\n\t\t}\n\t    }\n\t}\n    }\n\n    //パネルの色を変える\n    void change(int x, int y){\n\tpanel2[y][x] = to;\n\tans++;\n\tfor(int k=0; k<4; k++){\n\t    int nx = x+dx[k];\n\t    int ny = y+dy[k];\n\t    if(ny<h && ny>=0 && nx<w && nx>=0 && panel2[ny][nx]==from){\n\t\tchange(nx,ny);\n\t    }\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\tfinal int INF = Integer.MAX_VALUE;\n\tint ans,h,w,c;\n\tint [][] work;\n\t\n\tclass C{\n\t\tint x,y;\n\t\tpublic C(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tprivate void doit() {\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif((w|h|c) == 0) break;\n\t\t\tint [][] data = new int[h][w];\n\t\t\tfor(int i=0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tdfs(0,data);\n\t\t\tSystem.out.println(ans);\n\t\t\t//debug\n//\t\t\twork = deepcopy(data);\n//\t\t\tpaint(0,0,work[0][0],6);\n//\t\t\tdisp(work);\n//\t\t\tpaint(0,0,work[0][0],3);\n//\t\t\tdisp(work);\n//\t\t\tpaint(0,0,work[0][0],4);\n//\t\t\tdisp(work);\n//\t\t\tpaint(0,0,work[0][0],2);\n//\t\t\tdisp(work);\n//\t\t\tpaint(0,0,work[0][0],5);\n//\t\t\tdisp(work);\n//\t\t\tSystem.out.println(getA(5));\n\t\t}\n\t}\n\tprivate void dfs(int deep, int[][] data) {\n\t\t//System.out.println(\"deep= \" + deep);\n\t\tif(deep == 4){\n\t\t\t//c を塗る\n\t\t\twork = deepcopy(data);\n\t\t\tint before = data[0][0];\n\t\t\t//disp(work);\n\t\t\tif(before != c){\n\t\t\t\tpaint(0,0,before, c);\n\t\t\t}\n\t\t\t//disp(work);\n\t\t\t//calc a area\n\t\t\tint area = getA(c);\n\t\t\tans = Math.max(ans, area);\n\t\t}\n\t\telse{\n\t\t\tfor(int i=1; i <= 6; i++){\n\t\t\t\t//c を塗る\n\t\t\t\twork = deepcopy(data);\n\t\t\t\tint before = data[0][0];\n\t\t\t\tif(before != i){\n\t\t\t\t\tpaint(0,0,before, i);\n\t\t\t\t}\n\t\t\t\tint [][] nextdata = deepcopy(work);\n\t\t\t\tdfs(deep+1,nextdata);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tprivate void disp(int[][] work2) {\n\t\tSystem.out.println(\"disp= \");\n\t\tfor(int i =0; i < work2.length; i++){\n\t\t\tfor(int j = 0; j < work2[i].length; j++){\n\t\t\t\tSystem.out.print(work2[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"disp end\");\n\t}\n\tprivate int getA(int c) {\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(0, 0));\n\t\tboolean [][] close = new boolean[h][w];\n\t\tclose[0][0] = true;\n\t\tint count = 0;\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\tcount++;\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tint xx = vx[i] + now.x;\n\t\t\t\tint yy = vy[i] + now.y;\n\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\tif(work[yy][xx] == c){\n\t\t\t\t\tif(close[yy][xx]) continue;\n\t\t\t\t\topen.add(new C(xx,yy));\n\t\t\t\t\tclose[yy][xx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tprivate void paint(int x,int y, int before, int c) {\n\t\twork[y][x] = c;\n\t\tfor(int i=0; i < 4; i++){\n\t\t\tint xx = vx[i] + x;\n\t\t\tint yy = vy[i] + y;\n\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\tif(work[yy][xx] != before) continue;\n\t\t\tpaint(xx,yy,before,c);\n\t\t}\n\t}\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0<= xx && xx < w && 0 <= yy && yy < h ){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate int[][] deepcopy(int[][] data) {\n\t\tint [][] res = new int[data.length][data[0].length];\n\t\tfor(int i=0; i < data.length; i++){\n\t\t\tfor(int j = 0;  j < data[i].length; j++){\n\t\t\t\tres[i][j] = data[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSystem.setIn(new FileInputStream(\"src/aoj1174/input.txt\"));\n\t\t\t// System.setOut(new PrintStream(new FileOutputStream(\"src/aoj1172/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\n\t\twhile (sc.hasNext()) {\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint H, W, C;\n\tvoid solve() {\n\t\tH = sc.nextInt();\n\t\tW = sc.nextInt();\n\t\tC = sc.nextInt();\n\t\tif (H == 0) return;\n\n\t\tint[][] table = new int[H][W];\n\t\tfor (int h = 0; h < H; h++)\n\t\t\tfor (int w = 0; w < W; w++) {\n\t\t\t\ttable[h][w] = sc.nextInt();\n\t\t\t}\n\n\t\tint[][] t = new int[H][W];\n\n\t\tint ans = 0;\n\t\tint limit = 6 * 6 * 6 * 6 * 6;\n\t\tfor (int process = 0; process < limit; process++) {\n\n\t\t\tfor (int h = 0; h < H; h++)\n\t\t\t\tfor (int w = 0; w < W; w++)\n\t\t\t\t\tt[h][w] = table[h][w];\n\n\t\t\tint[] cs = new int[5];\n\t\t\tint p = process;\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tcs[i] = 1 + (p % 6);\n\t\t\t\tp /= 6;\n\t\t\t}\n\t\t\tif (cs[4] != C) continue;\n\t\t\tif (cs[0] == cs[1] || cs[1] == cs[2] || cs[2] == cs[3] || cs[3] == cs[4]) continue;\n\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tpaint(0, 0, t, cs[i], t[0][0]);\n\t\t\t}\n\t\t\tint cur = count(0, 0, t, C);\n\t\t\tans = max(ans, cur);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid paint(int r, int c, int[][] t, int updated, int init) {\n\t\tif (0 <= r && r < H && 0 <= c && c < W) {\n\t\t\tif (t[r][c] == init && init != updated) {\n\t\t\t\tt[r][c] = updated;\n\t\t\t\tpaint(r + 1, c, t, updated, init);\n\t\t\t\tpaint(r - 1, c, t, updated, init);\n\t\t\t\tpaint(r, c + 1, t, updated, init);\n\t\t\t\tpaint(r, c - 1, t, updated, init);\n\t\t\t}\n\t\t}\n\t}\n\n\tint count(int r, int c, int[][]t, int target) {\n\t\tint ans = 0;\n\t\tif (0 <= r && r < H && 0 <= c && c < W) {\n\t\t\tif (t[r][c] == target) {\n\t\t\t\tt[r][c] = -1;\n\t\t\t\tans++;\n\t\t\t\tans += count(r + 1, c, t, target);\n\t\t\t\tans += count(r - 1, c, t, target);\n\t\t\t\tans += count(r, c + 1, t, target);\n\t\t\t\tans += count(r, c - 1, t, target);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class circle implements Cloneable{\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    \n    StringTokenizer st;\n    private static boolean end = false;\n\n    public static void main ( String [] args ) throws IOException\n    {\n\twhile(!end){\n\t    new circle().cal();\n\t}\n\t\n    }\n\nint turn;\nint max;\nint h;\nint w;\nint c;\n\n    private void cal() throws IOException \n    {\n\n\tint result;\n\n\tint[][] panel;\n\tboolean[][] sameColor;\n\n\n\tst = new StringTokenizer(br.readLine());\n\th = Integer.parseInt(st.nextToken());\n\tw = Integer.parseInt(st.nextToken());\n\tc = Integer.parseInt(st.nextToken());\n\tif( h == 0 && w == 0 && c == 0){\n\t\tend = true;\n\t\treturn;\t\n\t}\n\n\tpanel = new int[h][w];\n\n\tfor( int i = 0; i < h; i++){\n\t\tst = new StringTokenizer(br.readLine());\t\t\n\t\tfor( int j = 0; j < w; j++){\n\t\t\tpanel[i][j] = Integer.parseInt(st.nextToken());\n\t\t}\n\t}\t\n\n\tsameColor = new boolean[h][w];\n\tsameColor[0][0] = true;\n\tresult = 1;\n\tboolean nomore = false;\n\twhile(!nomore){\n\t\tint tempNum = result;\n\t\tresult = changePoint(sameColor, result, panel);\n\t\tif(tempNum == result){\n\t\t\tnomore = true;\n\t\t}\n\t}\n\n\tturn = 0;\n\tmax = 0;\n\n\tnextTurn(result, sameColor, panel);\n\n\tSystem.out.println(max);\n\n    }\n\n\n    private void nextTurn(int result, boolean[][] sameColor, int[][] panel){\n\tturn++;\n\tif( turn == 5 ){\n\t\tresult = changeColor(c, result, sameColor, panel);\n\t\tif( result > max )\tmax = result;\n\n\n\t}\n\telse {\n\tfor( int col = 1; col < 7 ;col++){\n\t\tboolean[][] tmpsameColor = new boolean[h][w];\n\t\tint[][] tmppanel = new int[h][w];\n\t\tfor(int l=0; l < h; l++){\n\t\tfor(int k=0; k < w; k++){\n\t\t\ttmpsameColor[l][k] = sameColor[l][k];\n\t\t\ttmppanel[l][k] = panel[l][k];\n\t\t}\n\t\t}\n\t\tif( col == panel[0][0] ) continue;\n\t\tint tmpresult = changeColor(col, result, sameColor, panel);\n\t\tnextTurn(tmpresult, sameColor, panel);\n\t\tfor(int l=0; l < h; l++){\n\t\tfor(int k=0; k < w; k++){\n\t\t\tsameColor[l][k] = tmpsameColor[l][k];\n\t\t\tpanel[l][k] = tmppanel[l][k];\n\t\t}\n\t\t}\n\t\n\t}\n\t}\n\tturn--;\n    }\n\n\n    private int changeColor(int col, int result, boolean[][] sameColor, int[][] panel){\n\tfor(int l=0; l< h; l++){\n\tfor(int k=0; k< w; k++){\n\t\tif( sameColor[l][k] )\tpanel[l][k] = col;\n\t}\n\t}\n\n\tboolean nomore = false;\n\twhile(!nomore){\n\t\tint tempNum = result;\n\t\tresult = changePoint(sameColor, result, panel);\n\t\tif(tempNum == result){\n\t\t\tnomore = true;\n\t\t}\n\t}\n\treturn result;\n    }\n\n   private int changePoint(boolean[][] sameColor,int result , int[][] panel){\n\tfor(int i=0; i < h; i++){\n\tfor(int j=0; j < w; j++){\n\tif(sameColor[i][j])\tcontinue;\n\telse if( i+1 < h && panel[i][j] == panel[i+1][j] && sameColor[i+1][j] ){\n\t\t\tsameColor[i][j] = true;\n\t\t\tresult++;\n\t}\n\telse if( i-1 >= 0 && panel[i][j] == panel[i-1][j] && sameColor[i-1][j] ){\n\t\t\tsameColor[i][j] = true;\n\t\t\tresult++;\n\t}\n\telse if( j+1 < w && panel[i][j] == panel[i][j+1] && sameColor[i][j+1] ){\n\t\t\tsameColor[i][j] = true;\n\t\t\tresult++;\n\t}\n\telse if( j-1 >= 0 && panel[i][j] == panel[i][j-1] && sameColor[i][j-1] ){\n\t\t\tsameColor[i][j] = true;\n\t\t\tresult++;\n\t}\n\t}\n\t}\n\treturn result;\n   }\n\n\n   private void printPanel(int[][] panel, boolean[][] sameColor){\n\tfor(int i =0; i< h; i++){\n\tfor(int j =0; j< w; j++){\n\t\tSystem.out.print(panel[i][j]+\" \");\n\t}\n\tSystem.out.println();\n\t}\n\tfor(int i =0; i< h; i++){\n\tfor(int j =0; j< w; j++){\n\tif(sameColor[i][j])\n\t\tSystem.out.print(\"1 \");\n\telse\tSystem.out.print(\"0 \");\n\t}\n\tSystem.out.println();\n\t}\n  }\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * \n */\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * @author kumar1\n * \n */\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\ttry {\n\t\t\tsolve();\n\t\t} catch (IOException e) {\n\t\t\t// TODO 自動生成された catch ブロック\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * @throws IOException\n\t * \n\t */\n\tprivate static void solve() throws IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tArrayList<ArrayList<Byte>> list = new ArrayList<ArrayList<Byte>>();\n\t\t//File file = new File(\"ccase.txt\");\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(file));\n\t\tString s;\n\t\twhile ((s = in.readLine()) != null) {\n\t\t\tScanner scan = new Scanner(s);\n\t\t\tint n = 0;\n\t\t\tArrayList<Byte> l = new ArrayList<Byte>();\n\t\t\twhile (scan.hasNextInt()) {\n\t\t\t\tn = scan.nextInt();\n\t\t\t\tl.add((byte) n);\n\t\t\t}\n\t\t\tlist.add(l);\n\t\t\tscan.close();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tin.close();\n\t\t//System.out.println(list);\n\t\tfor (int i = 0; i < list.size();) {\n\t\t\tif (list.get(i).get(0) == 0)\n\t\t\t\tbreak;\n\t\t\tint h, w, c;\n\t\t\th = list.get(i).get(0);\n\t\t\tw = list.get(i).get(1);\n\t\t\tc = list.get(i).get(2);\n\t\t\tans(c, list.subList(i + 1, i + 1 + h));\n\t\t\ti = i + 1 + h;\n\t\t}\n\t}\n\n\t/**\n\t * @param h\n\t * @param w\n\t * @param c\n\t * @param subList\n\t */\n\tprivate static void ans(int c, List<ArrayList<Byte>> list) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t//System.out.println(list);\n\t\tbyte[][] arr = new byte[list.size()][list.get(0).size()];\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tfor(int j = 0; j < list.get(0).size(); j++) {\n\t\t\t\tarr[i][j] = list.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tdfs(arr, 1, 3, 0, 0);\n\t\tdfs(arr, arr[0][0], 6, 0, 0);\n\t\tfor(int j=0; j < arr.length; j++) {\n\t\t\tfor(int k=0; k < arr[0].length; k++) {\n\t\t\t\tSystem.out.print(arr[j][k] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(count(arr, arr[0][0], 0, 0, 1));\n\t\t*/\n\t\tSystem.out.println(pat(c, arr, 0));\n\t}\n\n\t/**\n\t * @param c : 最後の色\n\t * @param arr : 基板の配列\n\t * @param i : ループ回数\n\t * @return\n\t */\n\tprivate static int pat(int c, byte[][] arr, int i) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tbyte[][] carr;\n\t\ti++;\n\t\tif(i > 4) { // 5回目はc\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], c, 0, 0);\n\t\t\t/*\n\t\t\tfor(int j=0; j < carr.length; j++) {\n\t\t\t\tfor(int k=0; k < carr[0].length; k++) {\n\t\t\t\t\tSystem.out.print(carr[j][k] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\t\t\n\t\t\treturn count(carr, c, 0, 0, 1);\n\t\t}\n\t\tint max = 0;\n\t\t// 1, 2, 3, 4回目は全色\n\t\tfor(int j=1; j <= 6; j++) {\n\t\t\tif(arr[0][0] == j)\n\t\t\t\tcontinue;\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tint cnb = count(carr, carr[0][0], 0, 0, 1);\n\t\t\tdfs(carr, carr[0][0], j, 0, 0);\n\t\t\tint cna = count(carr, carr[0][0], 0, 0, 1);\n\t\t\tint n = cna;\n\t\t\tif(cnb != cna)\n\t\t\t\tn = pat(c, carr, i);\n\t\t\tif(max < n) {\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\n\t/**\n\t * @param c : 値がcの要素の数を求める\n\t * @return\n\t */\n\tprivate static int count(byte[][] arr, int c, int x, int y, int cnt) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tbyte[][] carr = cp2dIntArray(arr);\n\t\treturn countr(carr, c, x, y, cnt);\n\t}\n\t\n\tprivate static int countr(byte[][] carr, int c, int x, int y, int cnt) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = 0;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\t\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == c)\n\t\t\t\t\tcnt = countr(carr, c, nx, ny, cnt + 1);\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\t/**\n\t * @param carr\n\t * @param j : dfsした結果置換するやつ\n\t * @param x : x座標\n\t * @param y : y座標\n\t */\n\tprivate static void dfs(byte[][] carr, int before, int after, int x, int y) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = (byte) after;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == before && before != after)\n\t\t\t\t\tdfs(carr, before, after, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static byte[][] cp2dIntArray(byte[][] x) {\n\t\tbyte[][] ret = new byte[x.length][];\n\t\tfor(int i=0; i < x.length; i++)\n\t\t\tret[i] = x[i].clone();\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * \n */\npackage kako2011;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * @author kumar1\n * \n */\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\ttry {\n\t\t\tsolve();\n\t\t} catch (IOException e) {\n\t\t\t// TODO 自動生成された catch ブロック\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * @throws IOException\n\t * \n\t */\n\tprivate static void solve() throws IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t//File file = new File(\"ccase.txt\");\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader in = new BufferedReader(new FileReader(file));\n\t\tString s;\n\t\twhile ((s = in.readLine()) != null) {\n\t\t\tScanner scan = new Scanner(s);\n\t\t\tint n = 0;\n\t\t\tArrayList<Integer> l = new ArrayList<Integer>();\n\t\t\twhile (scan.hasNextInt()) {\n\t\t\t\tn = scan.nextInt();\n\t\t\t\tl.add(n);\n\t\t\t}\n\t\t\tlist.add(l);\n\t\t\tscan.close();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tin.close();\n\t\t//System.out.println(list);\n\t\tfor (int i = 0; i < list.size();) {\n\t\t\tif (list.get(i).get(0) == 0)\n\t\t\t\tbreak;\n\t\t\tint h, w, c;\n\t\t\th = list.get(i).get(0);\n\t\t\tw = list.get(i).get(1);\n\t\t\tc = list.get(i).get(2);\n\t\t\tans(c, list.subList(i + 1, i + 1 + h));\n\t\t\ti = i + 1 + h;\n\t\t}\n\t}\n\n\t/**\n\t * @param h\n\t * @param w\n\t * @param c\n\t * @param subList\n\t */\n\tprivate static void ans(int c, List<ArrayList<Integer>> list) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t//System.out.println(list);\n\t\tint[][] arr = new int[list.size()][list.get(0).size()];\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tfor(int j = 0; j < list.get(0).size(); j++) {\n\t\t\t\tarr[i][j] = list.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tdfs(arr, 1, 3, 0, 0);\n\t\tdfs(arr, arr[0][0], 6, 0, 0);\n\t\tfor(int j=0; j < arr.length; j++) {\n\t\t\tfor(int k=0; k < arr[0].length; k++) {\n\t\t\t\tSystem.out.print(arr[j][k] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(count(arr, arr[0][0], 0, 0, 1));\n\t\t*/\n\t\tSystem.out.println(pat(c, arr, 0));\n\t}\n\n\t/**\n\t * @param c : 最後の色\n\t * @param arr : 基板の配列\n\t * @param i : ループ回数\n\t * @return\n\t */\n\tprivate static int pat(int c, int[][] arr, int i) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tint[][] carr;\n\t\ti++;\n\t\tif(i > 4) { // 5回目はc\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], c, 0, 0);\n\t\t\t/*\n\t\t\tfor(int j=0; j < carr.length; j++) {\n\t\t\t\tfor(int k=0; k < carr[0].length; k++) {\n\t\t\t\t\tSystem.out.print(carr[j][k] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\t\t\t\n\t\t\treturn count(carr, c, 0, 0, 1);\n\t\t}\n\t\tint max = 0;\n\t\t// 1, 2, 3, 4回目は全色\n\t\tfor(int j=1; j <= 6; j++) {\n\t\t\tif(arr[0][0] == j)\n\t\t\t\tcontinue;\n\t\t\tcarr = cp2dIntArray(arr);\n\t\t\tdfs(carr, carr[0][0], j, 0, 0);\n\t\t\tint n = pat(c, carr, i);\n\t\t\tif(max < n) {\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\n\t/**\n\t * @param c : 値がcの要素の数を求める\n\t * @return\n\t */\n\tprivate static int count(int[][] carr, int c, int x, int y, int cnt) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = 0;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == c)\n\t\t\t\t\tcnt = count(carr, c, nx, ny, cnt + 1);\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\t/**\n\t * @param carr\n\t * @param j : dfsした結果置換するやつ\n\t * @param x : x座標\n\t * @param y : y座標\n\t */\n\tprivate static void dfs(int[][] carr, int before, int after, int x, int y) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tcarr[y][x] = after;\n\t\tint[][] n = new int[4][2];\n\t\tn[0][0] = y; n[0][1] = x + 1;\n\t\tn[1][0] = y; n[1][1] = x - 1;\n\t\tn[2][0] = y + 1; n[2][1] = x;\n\t\tn[3][0] = y - 1; n[3][1] = x;\n\t\tfor(int i=0; i < 4; i++) {\n\t\t\tint nx = n[i][1];\n\t\t\tint ny = n[i][0];\n\t\t\tif(0 <= nx && nx < carr[0].length && 0 <= ny && ny < carr.length) {\n\t\t\t\tif(carr[ny][nx] == before && before != after)\n\t\t\t\t\tdfs(carr, before, after, nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static int[][] cp2dIntArray(int[][] x) {\n\t\tint[][] ret = new int[x.length][];\n\t\tfor(int i=0; i < x.length; i++)\n\t\t\tret[i] = x[i].clone();\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CIdenticallyColoredPanelsConnection solver = new CIdenticallyColoredPanelsConnection();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CIdenticallyColoredPanelsConnection {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int h = in.nextInt(), w = in.nextInt(), c = in.nextInt();\n            while (h != 0 || w != 0 || c != 0) {\n                int[][] p = new int[h][w];\n                for (int i = 0; i < h; i++) {\n                    for (int j = 0; j < w; j++) {\n                        p[i][j] = in.nextInt();\n                    }\n                }\n\n                int ans = 0;\n                for (int i = 0; i < 6 * 6 * 6 * 6; i++) {\n                    CIdenticallyColoredPanelsConnection.Board board = new CIdenticallyColoredPanelsConnection.Board(h, w, p);\n                    int t = i;\n                    for (int j = 0; j < 4; j++) {\n                        int color = (t % 6) + 1;\n                        t /= 6;\n                        board.dfs(color);\n                    }\n                    board.dfs(c);\n                    ans = Math.max(ans, board.dfs(-1));\n                }\n                out.println(ans);\n\n                h = in.nextInt();\n                w = in.nextInt();\n                c = in.nextInt();\n            }\n        }\n\n        private static class Board {\n            private static final int[] DX = {0, 1, 0, -1};\n            private static final int[] DY = {1, 0, -1, 0};\n            int h;\n            int w;\n            int[][] p;\n            boolean[][] visited;\n\n            Board(int h, int w, int[][] p) {\n                this.h = h;\n                this.w = w;\n                this.p = new int[h][w];\n                this.visited = new boolean[h][w];\n                for (int i = 0; i < h; i++) {\n                    System.arraycopy(p[i], 0, this.p[i], 0, w);\n                }\n            }\n\n            int dfs(int to) {\n                for (int i = 0; i < h; i++) {\n                    Arrays.fill(visited[i], false);\n                }\n                return dfs(0, 0, p[0][0], to);\n            }\n\n            int dfs(int y, int x, int from, int to) {\n                int cnt = 1;\n                visited[y][x] = true;\n                p[y][x] = to;\n                for (int i = 0; i < 4; i++) {\n                    int nx = x + DX[i], ny = y + DY[i];\n                    if (nx < 0 || ny < 0 || nx == w || ny == h || visited[ny][nx]) {\n                        continue;\n                    }\n                    if (from == p[ny][nx]) {\n                        cnt += dfs(ny, nx, from, to);\n                    }\n                }\n                return cnt;\n            }\n\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static int[] dx = {1, 0, -1, 0};\n\tpublic static int[] dy = {0, 1, 0, -1};\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = in.nextInt();\n\t\t\tint w = in.nextInt();\n\t\t\tint c = in.nextInt();\n\t\t\tif(h==0) break;\n\t\t\tint[][] p = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tp[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(h*w <= 5){\n\t\t\t\tSystem.out.println(h*w);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinit(p[0][0], c);\n\t\t\tDeque<Integer> qu;\n\t\t\tBitSet conb = new BitSet(h*w);\n\t\t\tBitSet next = new BitSet(h*w);\n\t\t\tBitSet inqu = new BitSet(h*w);\n\t\t\tint res = 0;\n\t\t\tdo{\n\t\t\t\tqu = new LinkedList<Integer>();\n\t\t\t\tqu.add(0);\n\t\t\t\tint idx = 0;\n\t\t\t\tconb.clear();\n\t\t\t\tnext.clear();\n\t\t\t\tinqu.clear();\n\t\t\t\tinqu.set(0);\n\t\t\t\twhile(!qu.isEmpty()){\n\t\t\t\t\tint panel = qu.poll();\n\t\t\t\t\tinqu.clear(panel);\n\t\t\t\t\tint x = panel % w;\n\t\t\t\t\tint y = panel / w;\n\t\t\t\t\tif(p[y][x] != counter[idx]){\n\t\t\t\t\t\tif(next.get(panel)){\n\t\t\t\t\t\t\tif(idx == 5) break;\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\t\tqu.add(panel);\n\t\t\t\t\t\t\tinqu.set(panel);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinqu.set(panel);\n\t\t\t\t\t\tnext.set(panel);\n\t\t\t\t\t\tqu.add(panel);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconb.set(panel);\n\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\tint nx = x+dx[i];\n\t\t\t\t\t\tint ny = y+dy[i];\n\t\t\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\t\t\t\tint np = ny*w+nx;\n\t\t\t\t\t\tif(inqu.get(np) || conb.get(np)) continue;\n\t\t\t\t\t\tqu.push(np);\n\t\t\t\t\t\tinqu.set(np);\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tif(conb.cardinality() == 15){\n//\t\t\t\t\tfor(int i=0; i<h; i++){\n//\t\t\t\t\t\tfor(int j=0; j<w; j++){\n//\t\t\t\t\t\t\tSystem.out.print(conb.get(i*w+j)?1:0);\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println();\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t\tres = Math.max(res, conb.cardinality());\n\t\t\t}while(!incCount());\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static int[] debug = {1,6,3,4,2,5};\n\tpublic static boolean debug(){\n\t\tfor(int i=0; i<6; i++){\n\t\t\tif(debug[i] != counter[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void init(int begin, int end){\n\t\tcounter = new int[6];\n\t\tcounter[0] = begin;\n\t\tcounter[5] = end;\n\t}\n\n\tpublic static int[] counter;\n\tpublic static boolean incCount(){\n\t\tfor(int i=1; i<5; i++){\n\t\t\tcounter[i]++;\n\t\t\tif(counter[i] <= 6) break;\n\t\t\tcounter[i] = 0;\n\t\t\tif(i==4) return true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package vol11;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P1174\n{\n\tstatic int[] D = { 1, 0, -1, 0 };\n\tstatic int w, h, c;\n\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true)\n\t\t{\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif ((h|w|c)==0)break;\n\n\t\t\tint[] board = new int[w * h];\n\t\t\tfor (int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tboard[y * w + x] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count(board, 5));\n\t\t}\n\t}\n\n\tstatic int count(int[] board, int t)\n\t{\n\t\tif (t == 0)\n\t\t{\n\t\t\treturn countColor(board);\n\t\t}\n\n\t\tint max = 0;\n\t\tfor (int i = 1; i <= 6; i++)\n\t\t{\n\t\t\tif (board[0] == i) continue;\n\t\t\tint[] cb = Arrays.copyOf(board, board.length);\n\t\t\tchangeColor(cb, 0, 0, cb[0], i);\n\t\t\tmax = Math.max(max, count(cb, t - 1));\n\t\t}\n\t\treturn max;\n\t}\n\n\tstatic int countColor(int[] board)\n\t{\n\t\treturn countColor(board, 0, 0);\n\t}\n\n\tstatic int countColor(int[] board, int x, int y)\n\t{\n\t\tint count = 0;\n\t\tif (0 <= x && x < w && 0 <= y && y < h && board[y * w + x] == c)\n\t\t{\n\t\t\tcount++;\n\t\t\tboard[y * w + x] = 0;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint x2 = x + D[i];\n\t\t\t\tint y2 = y + D[(i + 1) % 4];\n\t\t\t\tcount += countColor(board, x2, y2);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tstatic void changeColor(int[] board, int x, int y, int c, int d)\n\t{\n\t\tif (0 <= x && x < w && 0 <= y && y < h && board[y * w + x] == c)\n\t\t{\n\t\t\tboard[y * w + x] = d;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint x2 = x + D[i];\n\t\t\t\tint y2 = y + D[(i + 1) % 4];\n\t\t\t\tchangeColor(board, x2, y2, c, d);\n\t\t\t}\n\t\t}\n\t}\n}\n/*\n3 5 5\n1 6 3 2 5\n2 5 4 6 1\n1 2 4 1 5\n4 5 6\n1 5 6 1 2\n1 4 6 3 2\n1 5 2 3 2\n1 1 2 3 2\n1 1 5\n1\n1 8 6\n1 2 3 4 5 1 2 3\n8 1 1\n1\n2\n3\n4\n5\n1\n2\n3\n8 8 6\n5 2 5 2 6 5 4 2\n4 2 2 2 5 2 2 2\n4 4 4 2 5 2 2 2\n6 4 5 2 2 2 6 6\n6 6 5 5 2 2 6 6\n6 2 5 4 2 2 6 6\n2 4 4 4 6 2 2 6\n2 2 2 5 5 2 2 2\n8 8 2\n3 3 5 4 1 6 2 3\n2 3 6 4 3 6 2 2\n4 1 6 6 6 4 4 4\n2 5 3 6 3 6 3 5\n3 1 3 4 1 5 6 3\n1 6 6 3 5 1 5 3\n2 4 2 2 2 6 5 3\n4 1 3 6 1 5 5 4\n0 0 0\n*/"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int max = 0;\n\tstatic int h, w, c;\n\tstatic int n;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tmax = 0;\n\t\t\tif (h == 0)\n\t\t\t\tbreak;\n\t\t\tint panel[][] = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tpanel[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor(panel, 1);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tprivate static void color(int[][] panel, int num) {\n\t\tif (num == 6) {\n\t\t\tint[][] copypanel = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tcopypanel[i] = panel[i].clone();\n\t\t\tcopypanel[0][0] = 0;\n\t\t\tn = 1;\n\t\t\tcountpanel(copypanel, 0, 0);\n\t\t\tif (n > max) {\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (int col = 1; col <= 6; col++) {\n\t\t\t// System.err.println(num + \":\" + col);\n\t\t\tif (panel[0][0] == col)\n\t\t\t\tcontinue;\n\n\t\t\tint[][] copypanel = new int[h][];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tcopypanel[i] = panel[i].clone();\n\n\t\t\tcopypanel[0][0] = col;\n\t\t\tconnect(copypanel, 0, 0, col, panel[0][0]);\n\t\t\tcolor(copypanel, num + 1);\n\t\t}\n\n\t}\n\n\tprivate static void countpanel(int[][] panel, int i, int j) {\n//\t\tdebugp(panel);\n\t\tif (j + 1 < w) {\n\t\t\tif (panel[i][j + 1] == c) {\n\t\t\t\tpanel[i][j + 1] = 0;\n\t\t\t\tn++;\n\t\t\t\tcountpanel(panel, i, j + 1);\n\t\t\t}\n\t\t}\n\t\tif (j - 1 >= 0) {\n\t\t\tif (panel[i][j - 1] == c) {\n\t\t\t\tpanel[i][j - 1] = 0;\n\t\t\t\tn++;\n\t\t\t\tcountpanel(panel, i, j - 1);\n\t\t\t}\n\t\t}\n\t\tif (i + 1 < h) {\n\t\t\tif (panel[i + 1][j] == c) {\n\t\t\t\tpanel[i + 1][j] = 0;\n\t\t\t\tn++;\n\t\t\t\tcountpanel(panel, i + 1, j);\n\t\t\t}\n\t\t}\n\t\tif (i - 1 >= 0) {\n\t\t\tif (panel[i - 1][j] == c) {\n\t\t\t\tpanel[i - 1][j] = 0;\n\t\t\t\tn++;\n\t\t\t\tcountpanel(panel, i - 1, j);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void debugp(int[][] panel) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tSystem.err.print(panel[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.err.println();\n\t\t}\n\t}\n\n\tprivate static int countcolor(int[][] panel) {\n\t\tint n = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (panel[i][j] == c) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\tprivate static void connect(int[][] panel, int i, int j, int newcol,\n\t\t\tint oldcol) {\n\t\tif (j + 1 < w && panel[i][j + 1] == oldcol) {\n\t\t\tpanel[i][j + 1] = newcol;\n\t\t\tconnect(panel, i, j + 1, newcol, oldcol);\n\t\t}\n\t\tif (j - 1 >= 0 && panel[i][j - 1] == oldcol) {\n\t\t\tpanel[i][j - 1] = newcol;\n\t\t\tconnect(panel, i, j - 1, newcol, oldcol);\n\t\t}\n\t\tif (i + 1 < h && panel[i + 1][j] == oldcol) {\n\t\t\tpanel[i + 1][j] = newcol;\n\t\t\tconnect(panel, i + 1, j, newcol, oldcol);\n\t\t}\n\t\tif (i - 1 >= 0 && panel[i - 1][j] == oldcol) {\n\t\t\tpanel[i - 1][j] = newcol;\n\t\t\tconnect(panel, i - 1, j, newcol, oldcol);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif(h==0 && w==0 && c==0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tfield =new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t\t\n\t}\n\n\tint h;\n\tint w;\n\tint c;\n\tint[][] field;\n\tpublic void solve() {\n\t\tvisited = new boolean[7][h*w];\n\t\tint res = 0;\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tres =Math.max(res, rec(1, field[0][0], i));\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tboolean[][] visited;\n\tprivate int rec(int cur, int cc, int nc) {\n\t\tif(cur == 6)\n\t\t\treturn count();\n\t\t\n\t\tint mask = (1<<3)-1;\n\t\t\n\t\tQueue<int[]> queue = new LinkedList<int[]>();\n\t\tqueue.add(new int[]{0, 0});\n\t\tArrays.fill(visited[cur], false);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] p = queue.poll();\n\t\t\tint x = p[0];\n\t\t\tint y = p[1];\n\t\t\tif(visited[cur][y*w+x])\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[cur][y*w+x] = true;\n\t\t\tfield[y][x] = (field[y][x] << 3) + nc;  \n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif((field[ny][nx]&mask)==cc)\n\t\t\t\t\tqueue.add(new int[]{nx, ny});\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i=1;i<=6;i++)\n\t\t\tret = Math.max(ret, rec(cur+1, field[0][0]&mask, i));\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(visited[cur][i*w+j]){\n\t\t\t\t\tfield[i][j] >>=3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\treturn ret;\n\t}\n\n\tprivate int count() {\n\t\tint res = 0;\n\t\tint mask = (1<<3)-1;\n\t\t\n\t\tQueue<int[]> queue = new LinkedList<int[]>();\n\t\tqueue.add(new int[]{0, 0});\n\t\tArrays.fill(visited[6], false);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] p = queue.poll();\n\t\t\tint x = p[0];\n\t\t\tint y = p[1];\n\t\t\tif(visited[6][y*w+x])\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[6][y*w+x] = true;  \n\t\t\tres++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif((field[ny][nx]&mask)==c)\n\t\t\t\t\tqueue.add(new int[]{nx, ny});\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(res);\n\t\treturn res;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint w = in.nextInt(),h = in.nextInt(),c = in.nextInt();\n\t\t\tif(w+h+c==0)break;\n\t\t\tnew AOJ1174().doIt(w, h, c);\n\t\t}\n\t}\n\t\n\tclass AOJ1174{\n\t\tint max = 0;\n\t\tint[][] map;\n\t\tint h,w,c;\n\t\tint sx[] = {0,1,-1,0};\n\t\tint sy[] = {1,0,0,-1};\n\t\tboolean sw[][],flg[][];\n\t\tvoid dfs_2(int x,int y){\n\t\t\tsw[y][x] = true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+sx[i];\n\t\t\t\tint ny = y+sy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||sw[ny][nx]||map[ny][nx]!=c)continue;\n\t\t\t\tdfs_2(nx,ny);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid set(){\n\t\t\tif(map[0][0]!=c)return;\n\t\t\tsw = new boolean[h][w];\n\t\t\tint cnt = 0;\n\t\t\tdfs_2(0, 0);\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(sw[i][s])cnt++;\n\t\t\tmax = Math.max(max, cnt);\n\t\t}\n\t\t\n\t\tvoid color_change(int x,int y,int color,int from){\n\t\t\tflg[y][x] = true;\n\t\t\tmap[y][x] = color;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = sx[i]+x;\n\t\t\t\tint ny = sy[i]+y;\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||flg[ny][nx]||map[ny][nx]!=from)continue;\n\t\t\t\tcolor_change(nx, ny, color,from);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid dfs(int fase){\n\t\t\tif(fase==5){\n\t\t\t\tset();return;\n\t\t\t}\n\t\t\tint memo[][] = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)memo[i][s] = map[i][s];\n\t\t\tfor(int j=1;j<=6;j++){\n\t\t\t\tif(j==map[0][0])continue;\n\t\t\t\tflg = new boolean[h][w];\n\t\t\t\tcolor_change(0, 0, j,map[0][0]);\n\t\t\t\tdfs(fase+1);\n\t\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)map[i][s] = memo[i][s];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid print(int[][] m){// deba\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int s=0;s<w;s++)System.out.print(m[i][s]+\" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt(int h,int w,int c){\n\t\t\tmap = new int[h][w];\n\t\t\tthis.h = h;this.w = w;this.c = c;\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)map[i][s] = in.nextInt();\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tint c;\t\t// 最終色\n\tint h;\n\tint w;\n\tint max;\t\t// 結合パネル数最大\n\tint tmp;\t\t// 局地的結合パネル数算出保持\n\tboolean[][] comb;\t\t// 結合パネル範囲(true)\n\t\n\t// pane[i][j]から移動できる同色パネル結合\n\tvoid Join(int[][] pane, int i, int j){\n\t\t// 配列外アクセスもしくは探索済みまたは同色でない\n\t\tif(i<0||i>=h||j<0||j>=w||comb[i][j]==true||pane[i][j]!=pane[0][0]){\n\t\t\treturn;\n\t\t}\n\t\ttmp++;\t\t// 局地的結合パネルインクリメント\n\t\tcomb[i][j] = true;\t\t// 探索済\n\t\t// 遷移先\n\t\tJoin(pane,i+1,j);\n\t\tJoin(pane,i,j+1);\n\t\tJoin(pane,i-1,j);\n\t\tJoin(pane,i,j-1);\n\t}\n\t\n\tvoid Color(int pane[][], int cnt){\n\t\tcomb = new boolean[h][w];\n\t\ttmp = 0;\n\t\tJoin(pane,0,0);\t\t// 結合する\n\t\tmax = Math.max(max,tmp);\t\t// 最大値更新\n\t\tif(cnt==4){\n\t\t\t// 5回目彩色\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(comb[j][k]){\n\t\t\t\t\t\tpane[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tColor(pane,++cnt);\t// 再帰\n\t\t\treturn;\n\t\t}\n\t\telse if(cnt==5){\n\t\t\treturn;\n\t\t}\n\t\t// 4回目以下\n\t\tcnt++;\n\t\tfor(int i=1;i<=6;i++){\t\t// 6色試す\n\t\t\t// 現在の階層の色と結合情報を退避させる\n\t\t\tint[][] copy = new int[h][w];\n\t\t\tboolean[][] copy_comb = new boolean[h][w];\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tcopy[j][k] = pane[j][k];\n\t\t\t\t\tcopy_comb[j][k] = comb[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// i色に設定\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(comb[j][k]){\n\t\t\t\t\t\tpane[j][k] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tColor(pane,cnt);\t\t// 再帰\n\t\t\t// 退避情報を次回の為に戻す\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tpane[j][k] = copy[j][k];\n\t\t\t\t\tcomb[j][k] = copy_comb[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = stdIn.nextInt();\n\t\t\tw = stdIn.nextInt();\n\t\t\tc = stdIn.nextInt();\n\t\t\tif((h|w|c)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] pane = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tpane[i][j] = stdIn.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tColor(pane,0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  int h, w, c;\n\n  int[][] field;\n\n  int dfs(int depth) {\n    if ( depth == 4 ) {\n      pre( depth );\n      fill_( 0, 0, depth, c );\n      pre( depth + 1 );\n      return fill_( 0, 0, depth + 1, 7 );\n    }\n\n    int max = 0;\n    for ( int r = 1; r <= 6; ++r ) {\n      pre( depth );\n      fill_( 0, 0, depth, r );\n      // debug( depth, r );\n      // for ( int[] a : field ) {\n      // for ( int v : a ) {\n      // System.err.print( ( ( v >> ( depth * 3 ) ) & 7 ) );\n      // System.err.print( \":\" + ( ( v >> ( ( depth + 1 ) * 3 ) ) & 7 ) + \" \" );\n      // }\n      // System.err.println();\n      // }\n      max = Math.max( max, dfs( depth + 1 ) );\n    }\n    return max;\n  }\n\n  void pre(int depth) {\n    int mask = ~( 7 << ( ( depth + 1 ) * 3 ) );\n    for ( int i = 0; i < h; ++i ) {\n      for ( int j = 0; j < w; ++j ) {\n        field[ i ][ j ] &= mask;\n        field[ i ][ j ] |= ( ( field[ i ][ j ] >> ( depth * 3 ) ) & 7 ) << ( ( depth + 1 ) * 3 );\n      }\n    }\n  }\n\n  int[][] ofs = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\n\n  // int fill(int depth, int color) {\n  // int cnt = 0;\n  // Queue<Integer> qx = new LinkedList<Integer>();\n  // Queue<Integer> qy = new LinkedList<Integer>();\n  // qx.add( 0 );\n  // qy.add( 0 );\n  // boolean[][] done = new boolean[h][w];\n  // boolean[][] ok = new boolean[h + 2][w + 2];\n  // for ( int i = 1; i <= h; ++i ) {\n  // for ( int j = 1; j <= w; ++j ) {\n  // ok[ i ][ j ] = true;\n  // }\n  // }\n  // int atom = ( field[ 0 ][ 0 ] >> ( depth * 3 ) ) & 7;\n  // int mask = ~( 7 << ( ( depth + 1 ) * 3 ) );\n  // for ( int i = 0; i < h; ++i ) {\n  // for ( int j = 0; j < w; ++j ) {\n  // field[ i ][ j ] &= mask;\n  // field[ i ][ j ] |= ( ( field[ i ][ j ] >> ( depth * 3 ) ) & 7 ) << ( (\n  // depth + 1 ) * 3 );\n  // }\n  // }\n  // field[ 0 ][ 0 ] &= mask;\n  // field[ 0 ][ 0 ] |= color << ( ( depth + 1 ) * 3 );\n  // done[ 0 ][ 0 ] = true;\n  // ++cnt;\n  // while (qx.size() > 0) {\n  // int x = qx.poll();\n  // int y = qy.poll();\n  //\n  // for ( int[] d : ofs ) {\n  // int nx = x + d[ 0 ];\n  // int ny = y + d[ 1 ];\n  // if ( ok[ ny + 1 ][ nx + 1 ] && !done[ ny ][ nx ]\n  // && ( ( field[ ny ][ nx ] >> ( depth * 3 ) ) & 7 ) == atom ) {\n  // done[ ny ][ nx ] = true;\n  // field[ ny ][ nx ] &= mask;\n  // field[ ny ][ nx ] |= color << ( ( depth + 1 ) * 3 );\n  // qx.add( nx );\n  // qy.add( ny );\n  // ++cnt;\n  // }\n  // }\n  // }\n  //\n  // return cnt;\n  // }\n\n  int fill_(int x, int y, int depth, int color) {\n    int cnt = 1;\n    int atom = ( field[ y ][ x ] >> ( depth * 3 ) ) & 7;\n    int mask = ~( 7 << ( ( depth + 1 ) * 3 ) );\n    field[ y ][ x ] &= mask;\n    field[ y ][ x ] |= color << ( ( depth + 1 ) * 3 );\n    for ( int[] d : ofs ) {\n      int nx = x + d[ 0 ];\n      int ny = y + d[ 1 ];\n      if ( 0 <= nx && nx < w && 0 <= ny && ny < h\n          && ( ( field[ ny ][ nx ] >> ( depth * 3 ) ) & 7 ) == atom\n          && ( ( field[ ny ][ nx ] >> ( ( depth + 1 ) * 3 ) ) & 7 ) != color ) {\n        cnt += fill_( nx, ny, depth, color );\n      }\n    }\n    return cnt;\n  }\n\n  void run() {\n    for ( ;; ) {\n      h = ni();\n      w = ni();\n      c = ni();\n      if ( ( h | w | c ) == 0 ) {\n        break;\n      }\n\n      field = new int[h][w];\n      for ( int i = 0; i < h; ++i ) {\n        for ( int j = 0; j < w; ++j ) {\n          field[ i ][ j ] = ni();\n        }\n      }\n\n      System.out.println( dfs( 0 ) );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\twhile(true){\n\t\t\tint w = in.nextInt(),h = in.nextInt(),c = in.nextInt();\n\t\t\tif(w+h+c==0)break;\n\t\t\tnew AOJ1174().doIt(w, h, c);\n\t\t}\n\t}\n\t\n\tclass AOJ1174{\n\t\tint max = 0;\n\t\tint[][] map;\n\t\tint h,w,c;\n\t\tint sx[] = {0,1,-1,0};\n\t\tint sy[] = {1,0,0,-1};\n\t\tboolean sw[][],flg[][];\n\t\tvoid dfs_2(int x,int y){\n\t\t\tsw[y][x] = true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+sx[i];\n\t\t\t\tint ny = y+sy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||sw[ny][nx]||map[ny][nx]!=c)continue;\n\t\t\t\tdfs_2(nx,ny);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid set(){\n\t\t\tif(map[0][0]!=c)return;\n\t\t\tsw = new boolean[h][w];\n\t\t\tint cnt = 0;\n\t\t\tdfs_2(0, 0);\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(sw[i][s])cnt++;\n\t\t\tmax = Math.max(max, cnt);\n\t\t}\n\t\t\n\t\tvoid color_change(int x,int y,int color,int from){\n\t\t\tflg[y][x] = true;\n\t\t\tmap[y][x] = color;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = sx[i]+x;\n\t\t\t\tint ny = sy[i]+y;\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||flg[ny][nx]||map[ny][nx]!=from)continue;\n\t\t\t\tcolor_change(nx, ny, color,from);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid dfs(int fase){\n//\t\t\tprint(map);\n//\t\t\tSystem.out.println();\n\t\t\tif(fase==5){\n\t\t\t\tset();return;\n\t\t\t}\n\t\t\tfor(int j=1;j<=6;j++){\n\t\t\t\tint memo[][] = new int[h][w]; \n\t\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)memo[i][s] = map[i][s];\n\t\t\t\tflg = new boolean[h][w];\n\t\t\t\tcolor_change(0, 0, j,map[0][0]);\n\t\t\t\tdfs(fase+1);\n\t\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)map[i][s] = memo[i][s];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid print(int[][] m){\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int s=0;s<w;s++)System.out.print(m[i][s]+\" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt(int h,int w,int c){\n\t\t\tmap = new int[h][w];\n\t\t\tthis.h = h;this.w = w;this.c = c;\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)map[i][s] = in.nextInt();\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif(h==0 && w==0 && c==0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tfield =new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t\t\n\t}\n\n\tint h;\n\tint w;\n\tint c;\n\tint[][] field;\n\tpublic void solve() {\n\t\tvisited = new boolean[7][h*w];\n\t\tint res = 0;\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tres =Math.max(res, rec(1, field[0][0], i));\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tboolean[][] visited;\n\tQueue<Integer> queue = new LinkedList<Integer>();\n\tprivate int rec(int cur, int cc, int nc) {\n\t\tif(cur == 6)\n\t\t\treturn count();\n\t\t\n\t\tint mask = (1<<3)-1;\n\t\t\n\t\tqueue.add(0);\n\t\tArrays.fill(visited[cur], false);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint p = queue.poll();\n\t\t\tint x = p&(0x07);\n\t\t\tint y = p>>3;\n\t\t\tif(visited[cur][y*w+x])\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[cur][y*w+x] = true;\n\t\t\tfield[y][x] = (field[y][x] << 3) + nc;  \n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif((field[ny][nx]&mask)==cc)\n\t\t\t\t\tqueue.add(ny<<3+nx);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i=1;i<=6;i++)\n\t\t\tret = Math.max(ret, rec(cur+1, field[0][0]&mask, i));\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(visited[cur][i*w+j]){\n\t\t\t\t\tfield[i][j] >>=3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\treturn ret;\n\t}\n\n\tprivate int count() {\n\t\tint res = 0;\n\t\tint mask = (1<<3)-1;\n\t\t\n\t\tqueue.add(0);\n\t\tArrays.fill(visited[6], false);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint p = queue.poll();\n\t\t\tint x = p&0x07;\n\t\t\tint y = p>>3;\n\t\t\tif(visited[6][y*w+x])\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[6][y*w+x] = true;  \n\t\t\tres++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif((field[ny][nx]&mask)==c)\n\t\t\t\t\tqueue.add(ny<<3+nx);\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(res);\n\t\treturn res;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "// Identically Colored Panels Connection\nimport java.util.*;\n\npublic class Main {\n\tstatic int w, h;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tint c = scanner.nextInt();\n\t\t\tif ((h | w | c) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] field = new int[w][h];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[j][i] = scanner.nextInt();\n\t\t\tint result = 0;\n\t\t\tfor (int i = 1; i < 7; i++) {\n\t\t\t\tif (i != field[0][0]) {\n\t\t\t\t\tint[][] tfield1 = changeField(field, i);\n\t\t\t\t\tfor (int j = 1; j < 7; j++) {\n\t\t\t\t\t\tif (j != tfield1[0][0]) {\n\t\t\t\t\t\t\tint[][] tfield2 = changeField(tfield1, j);\n\t\t\t\t\t\t\tfor (int k = 1; k < 7; k++)\n\t\t\t\t\t\t\t\tif (k != tfield2[0][0]) {\n\t\t\t\t\t\t\t\t\tint[][] tfield3 = changeField(tfield2, k);\n\t\t\t\t\t\t\t\t\tfor (int l = 1; l < 7; l++) {\n\t\t\t\t\t\t\t\t\t\tif (l != tfield3[0][0]) {\n\t\t\t\t\t\t\t\t\t\t\tint[][] tfield4 = changeField(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttfield3, l);\n\t\t\t\t\t\t\t\t\t\t\tif (l == c) {\n\t\t\t\t\t\t\t\t\t\t\t\tresult = Math.max(result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount(tfield4, 0, 0));\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tint[][] tfield5 = changeField(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttfield4, c);\n\t\t\t\t\t\t\t\t\t\t\t\tresult = Math.max(result,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount(tfield5, 0, 0));\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult = Math.max(result, count(tfield1, 0, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tscanner.close();\n\t}\n\n\tstatic int[][] changeField(int[][] field, int change) {\n\t\tint[][] result = new int[w][h];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tresult[j][i] = field[j][i];\n\t\tchangeColor(result, change, 0, 0);\n\t\treturn result;\n\t}\n\n\tstatic void changeColor(int[][] field, int change, int x, int y) {\n\t\tint b = field[x][y];\n\t\tfield[x][y] = change;\n\t\tif (x > 0 && b == field[x - 1][y])\n\t\t\tchangeColor(field, change, x - 1, y);\n\t\tif (x < w - 1 && b == field[x + 1][y])\n\t\t\tchangeColor(field, change, x + 1, y);\n\t\tif (y > 0 && b == field[x][y - 1])\n\t\t\tchangeColor(field, change, x, y - 1);\n\t\tif (y < h - 1 && b == field[x][y + 1])\n\t\t\tchangeColor(field, change, x, y + 1);\n\t}\n\n\tstatic int count(int[][] field, int x, int y) {\n\t\tint result = 1;\n\t\tint b = field[x][y];\n\t\tfield[x][y] = 0;\n\t\tif (x > 0 && b == field[x - 1][y])\n\t\t\tresult += count(field, x - 1, y);\n\t\tif (x < w - 1 && b == field[x + 1][y])\n\t\t\tresult += count(field, x + 1, y);\n\t\tif (y > 0 && b == field[x][y - 1])\n\t\t\tresult += count(field, x, y - 1);\n\t\tif (y < h - 1 && b == field[x][y + 1])\n\t\t\tresult += count(field, x, y + 1);\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tprivate static void copy(int w, int h, int[][] map, int[][] new_map){\n\t\tfor(int m = 0; m < h; m++){\n\t\t\tfor(int n = 0; n < w; n++){\n\t\t\t\tnew_map[m][n] = map[m][n];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static int count(int x, int y, int[][] map, boolean[][] visited){\n\t\tint counter = 0;\n\t\tif(!visited[y][x]){\n\t\t\tcounter++;\n\t\t\tvisited[y][x] = true;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(x != 0 && map[y][x] == map[y][x-1]){\n\t\t\tcounter += count(x-1,y,map, visited);\n\t\t}\n\t\t\n\t\tif(x != map[0].length-1 && map[y][x] == map[y][x+1]){\n\t\t\tcounter += count(x+1,y,map, visited);\n\t\t}\n\t\t\n\t\tif(y != 0 && map[y][x] == map[y-1][x]){\n\t\t\tcounter += count(x,y-1,map, visited);\n\t\t}\n\t\t\n\t\tif(y != map.length-1 && map[y][x] == map[y+1][x]){\n\t\t\tcounter += count(x,y+1,map, visited);\n\t\t}\n\t\t\n\t\treturn counter;\n\t}\n\t\n\tprivate static void change(int x, int y, int[][] old_map, int[][] new_map, int color, boolean[][] visited){\n\t\tif(!visited[y][x]){\n\t\t\tnew_map[y][x] = color;\n\t\t\tvisited[y][x] = true;\n\t\t}else{\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(x != 0 && old_map[y][x] == old_map[y][x-1]){\n\t\t\tchange(x-1,y,old_map,new_map,color,visited);\n\t\t}\n\t\t\n\t\tif(x != old_map[0].length-1 && old_map[y][x] == old_map[y][x+1]){\n\t\t\tchange(x+1,y,old_map,new_map,color,visited);\n\t\t}\n\t\t\n\t\tif(y != 0 && old_map[y][x] == old_map[y-1][x]){\n\t\t\tchange(x,y-1,old_map,new_map,color,visited);\n\t\t}\n\t\t\n\t\tif(y != old_map.length-1 && old_map[y][x] == old_map[y+1][x]){\n\t\t\tchange(x,y+1,old_map,new_map,color,visited);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint color = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0 && color == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] first = new int[h][w];\n\t\t\tint[][] second = new int[h][w];\n\t\t\tint[][] third = new int[h][w];\n\t\t\tint[][] forth = new int[h][w];\n\t\t\tint[][] last = new int[h][w];\n\t\t\t\n\t\t\tint max = -1;\n\t\t\t\n\t\t\tfor(int i = 1; i <= 6 ; i++){\n\t\t\t\tcopy(w,h,map, first);\n\t\t\t\tchange(0,0,map,first,i,new boolean[h][w]);\n\t\t\t\tfor(int j = 1; j <= 6; j++){\n\t\t\t\t\tcopy(w,h,first, second);\n\t\t\t\t\tchange(0,0,first,second,j,new boolean[h][w]);\n\t\t\t\t\tfor(int k = 1; k <= 6; k++){\n\t\t\t\t\t\tcopy(w,h,second, third);\n\t\t\t\t\t\tchange(0,0,second,third,k,new boolean[h][w]);\n\t\t\t\t\t\tfor(int l = 1; l <= 6; l++){\n\t\t\t\t\t\t\tcopy(w,h,third, forth);\n\t\t\t\t\t\t\tchange(0,0,third,forth,l,new boolean[h][w]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcopy(w,h,forth, last);\n\t\t\t\t\t\t\tchange(0,0,forth,last,color,new boolean[h][w]);\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tfor(int m = 0; m < h; m++){\n\t\t\t\t\t\t\t\tfor(int n = 0; n < w; n++){\n\t\t\t\t\t\t\t\t\tSystem.out.print(last[m][n] + \" \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tint c = count(0,0,last, new boolean[h][w]);\n\t\t\t\t\t\t\tif(max < c){\n\t\t\t\t\t\t\t\tmax = c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t\t\n\t}\n}\t"
  },
  {
    "language": "Java",
    "code": "public\nclass Main\n{\n  private static\n  final int ColorNum = 6;\n\n  public static\n  void main (\n    String args[ ]\n    )\n  {\n    java.util.Scanner scanner\n      = new java.util.Scanner ( System.in );\n\n    while ( true )\n    {\n      int[ ][ ] panel;\n      int       h, w, c;\n\n      h = scanner.nextInt ( );\n      w = scanner.nextInt ( );\n      c = scanner.nextInt ( );\n      if ( h == 0 && w == 0 && c == 0 ) break;\n\n      panel = new int[ h ][ w ];\n      for ( int j = 0; j < h; ++j )\n      for ( int i = 0; i < w; ++i )\n      {\n        panel[ j ][ i ] = scanner.nextInt ( );\n      }\n\n      System.out.format ( \"%d\\n\", solve ( panel, c ) );\n    }\n\n    return ;\n  }\n\n  public static\n  int solve (\n    int[ ][ ]   panel,\n    int         c\n    )\n  {\n    int[ ]  p = new int[ 5 ];\n    int     res = 0;\n\n    p[ 4 ] = c;\n    for ( p[ 0 ] = 1; p[ 0 ] <= ColorNum; ++p[ 0 ] )\n    for ( p[ 1 ] = 1; p[ 1 ] <= ColorNum; ++p[ 1 ] )\n    for ( p[ 2 ] = 1; p[ 2 ] <= ColorNum; ++p[ 2 ] )\n    for ( p[ 3 ] = 1; p[ 3 ] <= ColorNum; ++p[ 3 ] )\n    {\n      int[ ][ ] clone\n        = new int[ panel.length ][ ];\n\n      /* Copies panel to clone by deep copy */\n      for ( int i = 0; i < panel.length; ++i )\n      {\n        clone[ i ] = panel[ i ].clone ( );\n      }\n\n      res = Math.max ( res, test ( clone, p ) );\n    }\n\n    return ( res );\n  }\n\n  private static\n  int test (\n    int[ ][ ]   panel,\n    int[ ]      param\n    )\n  {\n    for ( int c : param )\n    {\n      simulate ( panel, 0, 0, panel[ 0 ][ 0 ], c );\n    }\n\n    return\n      count ( panel, 0, 0, panel[ 0 ][ 0 ] );\n  }\n\n  private static\n  void simulate (\n    int[ ][ ]   panel,\n    int         x,\n    int         y,\n    int         pc,\n    int         nc\n    )\n  {\n    if ( nc == pc )               return ;\n    if ( x < 0 || y < 0\n      || y >= panel.length\n      || x >= panel[ y ].length ) return ;\n    if ( panel[ y ][ x ] != pc )  return ;\n\n    panel[ y ][ x ] = nc;\n\n    simulate ( panel, x - 1 , y     , pc, nc );\n    simulate ( panel, x     , y - 1 , pc, nc );\n    simulate ( panel, x + 1 , y     , pc, nc );\n    simulate ( panel, x     , y + 1 , pc, nc );\n\n    return ;\n  }\n\n  private static\n  int count (\n    int[ ][ ]   panel,\n    int         x,\n    int         y,\n    int         c\n    )\n  {\n    int res;\n\n    if ( x < 0 || y < 0\n      || y >= panel.length\n      || x >= panel[ y ].length ) return ( 0 );\n    if ( panel[ y ][ x ] != c )   return ( 0 );\n\n    /* Flags not to recount this point */\n    panel[ y ][ x ] = -1;\n\n    res  = 1;\n    res += count ( panel, x - 1 , y     , c );\n    res += count ( panel, x     , y - 1 , c );\n    res += count ( panel, x + 1 , y     , c );\n    res += count ( panel, x     , y + 1 , c );\n\n    return ( res );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    int h,w,c;\n    int max;\n    int from,to;\n    int ans;\n    int[][] panel2;\n    int[] dx = {1,-1,0,0};\n    int[] dy = {0,0,1,-1};\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\th = sc.nextInt();\n\twhile(h!=0){\n\t    ans = 0;\n\t    w = sc.nextInt();\n\t    c = sc.nextInt();\n\t    int[][] panel = new int[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    panel[i][j] = sc.nextInt();\n\t\t}\n\t    }\n\t    \n\t    max = Integer.MIN_VALUE;\n\t    identically(0,panel);\n\t    System.out.println(max);\n\n\t    h = sc.nextInt();\n\t}\n    }\n\n    void identically(int count, int[][] panel){\n\tif(count==4){\n\t    if(panel[0][0]==c){return;}\n\t    from = panel[0][0]; to = c;\n\t    panel2 = panel;\n\t    change(0,0);\n\n\t    ans = 0;\n\t    from = c; to = 7;\n\t    change(0,0);\n\t    max = Math.max(max,ans);\n\t    return;\n\t}\n\n\tpanel2 = new int[h][w];\n\tfor(int i=0; i<h; i++){\n\t    for(int j=0; j<w; j++){\n\t\tpanel2[i][j] = panel[i][j];\n\t    }\n\t}\n\tfor(int i=1; i<=6; i++){\n\t    if(i==panel[0][0])continue;\n\t    from = panel[0][0]; to = i;\n\t    change(0,0);\n\t    identically(count+1,panel2);\n\t    for(int k=0; k<h; k++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    panel2[k][j] = panel[k][j];\n\t\t}\n\t    }\n\t}\n    }\n\n    void change(int x, int y){\n\tpanel2[y][x] = to;\n\tans++;\n\tfor(int k=0; k<4; k++){\n\t    int nx = x+dx[k];\n\t    int ny = y+dy[k];\n\t    if(ny<h && ny>=0 && nx<w && nx>=0 && panel2[ny][nx]==from){\n\t\tchange(nx,ny);\n\t    }\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  /**\n   * ??±???????????¢?´¢\n   *\n   * @return count ??? max\n   */\n  int dfs(int[][] p, int depth) {\n    if (depth >= 5) {\n      return count(p, c);\n    }\n    int max = 0;\n\n    int[][] dup = new int[h][w];\n    for (int y = 0; y < h; ++y) {\n      for (int x = 0; x < w; ++x) {\n        dup[y][x] = p[y][x];\n      }\n    }\n    for (int i = 1; i <= 6; ++i) {\n      paint(p, i);\n      int res = dfs(p, depth + 1);\n      max = Math.max(max, res);\n      for (int y = 0; y < h; ++y) {\n        for (int x = 0; x < w; ++x) {\n          p[y][x] = dup[y][x];\n        }\n      }\n    }\n    return max;\n  }\n\n  int[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0}\n  };\n\n  /**\n   * ???????????¢?´¢??§????????????\n   */\n  int count(int[][] p, int color) {\n    if (p[0][0] != color) {\n      return 0;\n    }\n    boolean[][] done = new boolean[h][w];\n    Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\n    queue.add(new Pair<>(0, 0));\n    done[0][0] = true;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Pair<Integer, Integer> point = queue.poll();\n      ++cnt;\n      for (int[] d : ofs) {\n        int nx = point.f + d[0];\n        int ny = point.s + d[1];\n        if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n          continue;\n        }\n        if (done[ny][nx]) {\n          continue;\n        }\n        done[ny][nx] = true;\n        if (p[ny][nx] != color) {\n          continue;\n        }\n        Pair<Integer, Integer> next = new Pair<>(nx, ny);\n        queue.add(next);\n      }\n    }\n    return cnt;\n  }\n\n  /**\n   * ???????????¢?´¢??§?????£?????????\n   */\n  void paint(int[][] p, int color) {\n    boolean[][] done = new boolean[h][w];\n    Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\n    queue.add(new Pair<>(0, 0));\n    done[0][0] = true;\n    int atom = p[0][0];\n    while (queue.size() > 0) {\n      Pair<Integer, Integer> point = queue.poll();\n      p[point.s][point.f] = color;\n      for (int[] d : ofs) {\n        int nx = point.f + d[0];\n        int ny = point.s + d[1];\n        if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n          continue;\n        }\n        if (done[ny][nx]) {\n          continue;\n        }\n        done[ny][nx] = true;\n        if (p[ny][nx] != atom) {\n          continue;\n        }\n        Pair<Integer, Integer> next = new Pair<>(nx, ny);\n        queue.add(next);\n      }\n    }\n  }\n\n  int h, w, c;\n\n  void run() {\n    for (; ; ) {\n      h = ni();\n      w = ni();\n      c = ni();\n      if (h == 0) {\n        break;\n      }\n      int[][] p = new int[h][w];\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          p[i][j] = ni();\n        }\n      }\n      System.out.println(dfs(p, 0));\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w, c;\n    int[][] p, p2;\n    int[] num = new int[5];\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt(); w = sc.nextInt(); c = sc.nextInt();\n            if(h==0 && w==0 && c==0) break;\n\n            p = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p[i][j] = sc.nextInt();\n\n            System.out.println(rec(0));\n            System.gc();\n        }\n    }\n\n    int rec(int cnt){\n        if(cnt==5){\n            if(num[4]!=c) return 0;\n            p2 = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p2[i][j] = p[i][j];\n            for(int i=0; i<5; i++){\n                if(num[i]==p2[0][0]) continue;\n                changeColor(num[i]);\n            }\n            int cc = changeColor(num[4]);\n            return cc;\n        }\n        int res = 0;\n        for(int i=1; i<=6; i++){\n            num[cnt] = i;\n            res = Math.max(res, rec(cnt + 1));\n        }\n        return res;\n    }\n\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n\n    int changeColor(int color){\n        int before = p2[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        p2[0][0] = color;\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        int cnt = 0;\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n            cnt++;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p2[ny][nx]!=before || v[ny][nx]) continue;\n                p2[ny][nx] = color;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tint H, W, C;\n\tint[][] map;\n\tint[][] field;\n\tboolean visit[][];\n\tint max, cnt;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tC = sc.nextInt();\n\t\t\tif ((H | W | C) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap = new int[H][W];\n\t\t\tfield = new int[H][W];\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] parm = new int[5];\n\t\t\tmakePerm(0, parm);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tvoid makePerm(int n, int[] parm) {\n\t\tif (n == 4) {\n\t\t\tparm[n] = C;\n\t\t\tsolve(parm);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tif (n == 3 && i == C) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparm[n] = i;\n\t\t\tmakePerm(n + 1, parm);\n\t\t}\n\t}\n\n\tvoid solve(int parm[]) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfield[i][j] = map[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tvisit = new boolean[H][W];\n\t\t\tint first = field[0][0];\n\t\t\tdfs(parm[i], first, visit, 0, 0);\n\t\t}\n\t\tvisit = new boolean[H][W];\n\t\tif (field[0][0] == C && !visit[0][0]) {\n\t\t\tcnt = 1;\n\t\t\tcntMap(field, visit, 0, 0);\n\t\t\tmax = Math.max(max, cnt);\n\t\t}\n\t}\n\n\tvoid dfs(int num, int first, boolean[][] visit, int h, int w) {\n\t\tfield[h][w] = num;\n\t\tvisit[h][w] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dy[i];\n\t\t\tint nw = w + dx[i];\n\t\t\tif (nh >= 0 && nh < H && nw >= 0 && nw < W && !visit[nh][nw]\n\t\t\t\t\t&& field[nh][nw] == first) {\n\t\t\t\tdfs(num, first, visit, nh, nw);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid cntMap(int[][] field, boolean[][] visitf, int h, int w) {\n\t\tvisit[h][w] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dy[i];\n\t\t\tint nw = w + dx[i];\n\t\t\tif (nh >= 0 && nh < H && nw >= 0 && nw < W && !visit[nh][nw]\n\t\t\t\t\t&& field[nh][nw] == C) {\n\t\t\t\tcnt++;\n\t\t\t\tcntMap(field, visit, nh, nw);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tif (h==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] col = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\t\tcol[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] temp = new int[h][w];\n\t\t\tint[] p = {1,1,1,1,c};\n\t\t\tint ans = 0;\n\t\t\tdo {\n\t\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\t\t\ttemp[i][j] = col[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tUnionFind uf = new UnionFind(h*w);\n\t\t\t\tfor(int i=0;i<6;i++) {\n\t\t\t\t\tfor(int j=0;j<h-1;j++) {\n\t\t\t\t\t\tfor(int k=0;k<w;k++) {\n\t\t\t\t\t\t\tif (temp[j][k] == temp[j+1][k]) {\n\t\t\t\t\t\t\t\tuf.union(j*w+k, (j+1)*w+k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=0;j<h;j++) {\n\t\t\t\t\t\tfor(int k=0;k<w-1;k++) {\n\t\t\t\t\t\t\tif (temp[j][k] == temp[j][k+1]) {\n\t\t\t\t\t\t\t\tuf.union(j*w+k, j*w+k+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i==5) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=0;j<h*w;j++) {\n\t\t\t\t\t\tif (uf.isConnected(0, j)) {\n\t\t\t\t\t\t\ttemp[j/w][j%w] = p[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans,uf.size(0));\n\t\t\t} while(next(p));\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic boolean next(int[] p) {\n\t\tlong num = 0;\n\t\tfor(int i=3;i>=0;i--) {\n\t\t\tnum*=6;\n\t\t\tnum+=(p[i]-1);\n\t\t}\n\t\tnum+=1;\n\t\t//System.out.println(num);\n\t\tif (num >= 6*6*6*6) {\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tp[i] = (int) (num%6+1);\n\t\t\tnum/=6;\n\t\t}\n\t\treturn true;\n\t}\n}\nclass UnionFind {\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tpublic void union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tprivate int root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(data);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int h;\n\tstatic int w;\n\tstatic int c;\n\tstatic int cnt;\n\tstatic int[][] p;\n\tstatic int[][] tmp;\n\tstatic int[][] move = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\tstatic int[] order;\n\tstatic boolean[][] jud;\n\t\n\tstatic void e() {\n\t\tfor(int k=0; k<5; k++) {\n\t\t\tif(tmp[0][0] == order[k]) continue;\n\t\t\tf(0, 0, tmp[0][0], order[k]);\n\t\t}\n\t\tcnt = 0;\n\t\tjud = new boolean[h][w];\n\t\tv(0, 0);\n\t}\n\t\n\tstatic void v(int i, int j) {\n\t\tif(tmp[i][j] != c) return;\n\t\tcnt++;\n\t\tjud[i][j] = true;\n\t\tfor(int k=0; k<4; k++) {\n\t\t\tint newi = i + move[k][0];\n\t\t\tint newj = j + move[k][1];\n\t\t\tif(0 <= newi && newi < h && 0 <= newj && newj < w && !jud[newi][newj]) {\n\t\t\t\tv(newi, newj);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void f(int i, int j, int from, int to) {\n\t\tif(tmp[i][j] != from) return;\n\t\ttmp[i][j] = to;\n\t\tfor(int k=0; k<4; k++) {\n\t\t\tint newi = i + move[k][0];\n\t\t\tint newj = j + move[k][1];\n\t\t\tif(0 <= newi && newi < h && 0 <= newj && newj < w) {\n\t\t\t\tf(newi, newj, from, to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif(h + w + c == 0) break;\n\t\t\tp = new int[h][w];\n\t\t\ttmp = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\tp[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\torder = new int[5];\n\t\t\tfor(int i=1; i<=6; i++) {\n\t\t\t\tfor(int j=1; j<=6; j++) {\n\t\t\t\t\tfor(int k=1; k<=6; k++) {\n\t\t\t\t\t\tfor(int l=1; l<=6; l++) {\n\t\t\t\t\t\t\torder[0] = i;\n\t\t\t\t\t\t\torder[1] = j;\n\t\t\t\t\t\t\torder[2] = k;\n\t\t\t\t\t\t\torder[3] = l;\n\t\t\t\t\t\t\torder[4] = c;\n\t\t\t\t\t\t\tfor(int x=0; x<h; x++) {\n\t\t\t\t\t\t\t\tfor(int y=0; y<w; y++) {\n\t\t\t\t\t\t\t\t\ttmp[x][y] = p[x][y];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\te();\n\t\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint h, w, c;\n\tint max;\n\tint count;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif( (h|w|c) == 0 ) break;\n\t\t\tmax = 0;\n\t\t\tbyte[][] map = new byte[h+2][w+2];\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\tmap[i][j] = sc.nextByte();\n\t\t\t}\n\t\t\tdfs(0, map);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int cnt, byte[][] map) {\n\n\t\tif(cnt == 5) {\n//\t\t\tfor(byte[] a: map)\n//\t\t\tdebug(a);\n\t\t\tif( map[1][1] != c ) return;\n\t\t\tbyte[][] tmp = new byte[h+2][w+2];\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++)\n\t\t\t\ttmp[i][j] = map[i][j];\n\t\t\tcount = 0;\n\t\t\texchange(tmp, 1, 1, tmp[1][1], (byte)0);\n\t\t\tmax = max(max, count);\n\t\t}\n\t\telse {\n\t\t\tfor(byte c=1;c<=6;c++) {\n\t\t\t\tif(c == map[1][1]) continue;\n\t\t\t\tbyte[][] tmp = new byte[h+2][w+2];\n\t\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++)\n\t\t\t\t\ttmp[i][j] = map[i][j];\n\t\t\t\tcount = 0;\n\t\t\t\texchange(tmp, 1, 1, tmp[1][1], c);\n\t\t\t\tdfs(cnt+1, tmp);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\tvoid exchange(byte[][] map, int x, int y, byte c, byte ex) {\n\t\tcount++;\n\t\tmap[y][x] = ex;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tif(map[y+dy[i]][x+dx[i]] == c) exchange(map, x+dx[i], y+dy[i], c, ex);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    public static void main ( String [] args ) throws IOException\n\n\n    {\n    \t\n\tnew Main().cal();\n    }\n\n \n    private void cal() throws IOException \n    {\n    \twhile(true){\n\t    String[] buffer=br.readLine().split(\"\\\\s\");\n    \t\n\t    int height=Integer.parseInt(buffer[0]);\n\n\n\t    int width=Integer.parseInt(buffer[1]);\n\t    int objectColor = Integer.parseInt(buffer[2]);\n\t    int[][] arr=new int[height][width];\n\t    int max=0;\n    \t\t\n\t    if(height==0 && width==0 && objectColor==0)\n\t    \tbreak;\n    \t\t\n\t    for(int i=0;i<height;i++){\n\t    \tString[] temp=br.readLine().split(\"\\\\s\");\n\t    \tfor(int j=0;j<width;j++)\n\t    \t\tarr[i][j]=Integer.parseInt(temp[j]);\n\t    \t}\n    \t\t\n\t    for(int i=1;i<7;i++)\n\t    \tif(i!=objectColor)\n\t    \t\tfor(int j=1;j<7;j++)\n\t    \t\t\tfor(int k=1;k<7;k++)\n\t    \t\t\t\tfor(int m=1;m<7;m++){\n\t    \t\t\t\t\tif(i==j || j==k || k==m||m==objectColor)\n\t    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t\t\t\n\t    \t\t\t\t\tint temp=checkColor(0,0,change(arr,m,k,j,i,objectColor),objectColor);\n\t\t\t\t\t\t\n\t    \t\t\t\t\tif(max<temp){\n\t    \t\t\t\t\t\tmax=temp;\n\t\t\t\t\t\t\t/*\tfor(int z=0;z<height;z++){\n\t\t\t\t\t\t\t    for(int x=0;x<width;x++)\n\t\t\t\t\t\t\t\tSystem.out.print(change(arr,m,k,j,i,objectColor)[z][x]+\" \");\n\t\t\t\t\t\t\t    System.out.println(\"\");\t\t    }\t\t\tSystem.out.println(\"max : \"+max);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t*/\t}}\n\t    \n\t    System.out.println(max);\n    \t}\n\n    \t\n    }\n    public int[][] change(int[][] arr,int m,int k,int j,int i,int Color){\n\n\n    \tint[][]tempArr=(int[][]) clone(arr);\n\tint initial=tempArr[0][0];\n\n\tchangeCell(tempArr,0,0,m,initial);\n\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=m;\n\n     \tchangeCell(tempArr,0,0,k,m);\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=k;\n\n    \tchangeCell(tempArr,0,0,j,k); \n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=j;\n\n    \tchangeCell(tempArr,0,0,i,j);\n \n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=i;\n\n    \tchangeCell(tempArr,0,0,Color,i);\n\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=Color;\n\n    \treturn tempArr; \n    }\n    \n    public static Object[] clone(int[][] arr){\n    \t\tif(arr==null)\n    \t\t\t\treturn null;\n    \t\telse {\n\t\t    int[][] temp=new int[arr.length][arr[0].length];\n\t\t    for(int i=0;i<arr.length;i++)\n\t\t\tfor(int j=0;j<arr[0].length;j++)\n\t\t\t    temp[i][j]=arr[i][j];\n\t\t    \n    \t\t\t\treturn temp;\n\t\t}\n    }\n    \n    public int checkColor(int a,int b,int[][] checkingArr,int Color){\n    \t\n    \t\tif(a>=0 && b>=0 &&a<checkingArr.length&& b<checkingArr[0].length&&checkingArr[a][b]==Color){\n\t\t    checkingArr[a][b]=0;\n\t\t    return 1+\ncheckColor(a-1,b,checkingArr,Color)+checkColor(a+1,b,checkingArr,Color)+\ncheckColor(a,b-1,checkingArr,Color)+checkColor(a,b+1,checkingArr,Color);\n    \t\t}\n    \t\telse \n    \t\t\t\treturn 0;\n    }\n    \n    public void changeCell(int[][] tempArr,int a, int b,int c,int d){\n\n    \ttempArr[a][b]=0;\n    \t\n    \tif(a>0 && tempArr[a-1][b]==d)\n    \t\tchangeCell(tempArr,a-1,b,c,d);\n    \tif(b>0 && tempArr[a][b-1]==d)\n    \t\tchangeCell(tempArr,a,b-1,c,d);\n    \tif(a<tempArr.length-1 && tempArr[a+1][b]==d)\n    \t\tchangeCell(tempArr,a+1,b,c,d);\n    \tif(b<tempArr[0].length-1 && tempArr[a][b+1]==d)\n    \t\tchangeCell(tempArr,a,b+1,c,d);\n\t\n\n\n    \t\n    }\n\n    \n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint[] dx = { 1, 0, -1, 0 };\n\tint[] dy = { 0, 1, 0, -1 };\n\tint H, W, C;\n\tint[][] map;\n\tint[][] field;\n\tboolean visit[][];\n\tint max, cnt;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tC = sc.nextInt();\n\t\t\tif ((H | W | C) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap = new int[H][W];\n\t\t\tfield = new int[H][W];\n\t\t\tmax = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] use = new boolean[6];\n\t\t\tint[] parm = new int[5];\n\t\t\tmakePerm(0, parm, use);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tvoid makePerm(int n, int[] parm, boolean use[]) {\n\t\tif (n == 4) {\n\t\t\tparm[n] = C;\n\t\t\tsolve(parm);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tparm[n] = i;\n\t\t\tmakePerm(n + 1, parm, use);\n\t\t}\n\t}\n\n\tvoid solve(int parm[]) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfield[i][j] = map[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tvisit = new boolean[H][W];\n\t\t\tint first = field[0][0];\n\t\t\tdfs(parm[i], first, visit, 0, 0);\n\t\t}\n\t\tvisit = new boolean[H][W];\n\t\tif (field[0][0] == C && !visit[0][0]) {\n\t\t\tcnt = 1;\n\t\t\tcntMap(field, visit, 0, 0);\n\t\t\tmax = Math.max(max, cnt);\n\t\t}\n\t}\n\n\tvoid dfs(int num, int first, boolean[][] visit, int h, int w) {\n\t\tfield[h][w] = num;\n\t\tvisit[h][w] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dy[i];\n\t\t\tint nw = w + dx[i];\n\t\t\tif (nh >= 0 && nh < H && nw >= 0 && nw < W && !visit[nh][nw]\n\t\t\t\t\t&& field[nh][nw] == first) {\n\t\t\t\tdfs(num, first, visit, nh, nw);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid cntMap(int[][] field, boolean[][] visitf, int h, int w) {\n\t\tvisit[h][w] = true;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dy[i];\n\t\t\tint nw = w + dx[i];\n\t\t\tif (nh >= 0 && nh < H && nw >= 0 && nw < W && !visit[nh][nw]\n\t\t\t\t\t&& field[nh][nw] == C) {\n\t\t\t\tcnt++;\n\t\t\t\tcntMap(field, visit, nh, nw);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n\npublic class Main {\n\t\n\tpublic static final int[][] move_dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\t\n\tpublic static boolean is_ok(int x, int y, int w, int h){\n\t\tif(x < 0 || x >= w || y < 0 || y >= h){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void change(int x, int y, int prev_color, int next_color, int[][] map, int h, int w){\n\t\tif(map[y][x] != prev_color){\n\t\t\treturn;\n\t\t}\n\t\tmap[y][x] = next_color;\n\t\t\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(!is_ok(nx, ny, w, h)){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] != prev_color){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tchange(nx, ny, prev_color, next_color, map, h, w);\n\t\t}\n\t}\n\t\n\tpublic static int count(int x, int y, int[][] map, int h, int w){\n\t\tint ret = 0;\n\t\t\n\t\tfinal int color = map[y][x];\n\t\tmap[y][x] = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(!is_ok(nx, ny, w, h)){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] != color){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tret += count(nx, ny, map, h, w);\n\t\t}\n\t\t\n\t\treturn ret + 1;\n\t}\n\t\n\tpublic static int[][] clone(int[][] array, int h, int w){\n\t\tint[][] ret = new int[h][w];\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tret[i][j] = array[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void copy(int[][] dst, int[][] src, int h, int w){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tdst[i][j] = src[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int dfs(int[][] map, int pur_color, int deep, int h, int w){\n\t\tif(deep == 0){\n\t\t\tif(map[0][0] != pur_color){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\treturn count(0, 0, map, h, w);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] prev = clone(map, h, w);\n\t\tint ret = 0;\n\t\t\n\t\tfor(int color = 1; color < 7; color++){\n\t\t\tif(color == map[0][0]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tchange(0, 0, map[0][0], color, map, h, w);\n\t\t\t\n\t\t\tret = Math.max(ret, dfs(map, pur_color, deep - 1, h, w));\n\t\t\t\n\t\t\tcopy(map, prev, h, w);\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int c = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(map, c, 5, h, w));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif(h==0 && w==0 && c==0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tfield =new int[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tfield[i][j] = sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t\t\n\t}\n\n\tint h;\n\tint w;\n\tint c;\n\tint[][] field;\n\tpublic void solve() {\n\t\tvisited = new boolean[7][h*w];\n\t\tint res = 0;\n\t\tfor(int i=1;i<=6;i++){\n\t\t\tres =Math.max(res, rec(1, field[0][0], i));\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tboolean[][] visited;\n\tQueue<Integer> queue = new LinkedList<Integer>();\n\tprivate int rec(int cur, int cc, int nc) {\n\t\tif(cur == 6)\n\t\t\treturn count();\n\t\t\n\t\tint mask = (1<<3)-1;\n\t\t\n\t\tqueue.add(0);\n\t\tArrays.fill(visited[cur], false);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint p = queue.poll();\n\t\t\tint x = p&(0x07);\n\t\t\tint y = p>>3;\n\t\t\tif(visited[cur][y*w+x])\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[cur][y*w+x] = true;\n\t\t\tfield[y][x] = (field[y][x] << 3) + nc;  \n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif((field[ny][nx]&mask)==cc)\n\t\t\t\t\tqueue.add((ny<<3)+nx);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i=1;i<=6;i++)\n\t\t\tret = Math.max(ret, rec(cur+1, field[0][0]&mask, i));\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(visited[cur][i*w+j]){\n\t\t\t\t\tfield[i][j] >>=3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\treturn ret;\n\t}\n\n\tprivate int count() {\n\t\tint res = 0;\n\t\tint mask = (1<<3)-1;\n\t\t\n\t\tqueue.add(0);\n\t\tArrays.fill(visited[6], false);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint p = queue.poll();\n\t\t\tint x = p&0x07;\n\t\t\tint y = p>>3;\n\t\t\tif(visited[6][y*w+x])\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[6][y*w+x] = true;  \n\t\t\tres++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i];\n\t\t\t\tint ny = y+dy[i];\n\t\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif((field[ny][nx]&mask)==c)\n\t\t\t\t\tqueue.add((ny<<3)+nx);\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(res);\n\t\treturn res;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\tstatic final int NUM_COLOR = 6;\n\tvoid run(){\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = s.nextInt();\n\t\t\tint w = s.nextInt();\n\t\t\tint c = s.nextInt();\n\t\t\tif(h == 0 && w == 0 && c == 0)break;\n\t\t\tint p[][] = new int[h][w];\n\t\t\tfor(int i = 0;i < h;i++)\n\t\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t\t\tp[i][j] = s.nextInt();\n\t\t\tint max = 0;\n\t\t\tfor(int t1 = 1;t1 <= NUM_COLOR;t1++){\n\t\t\t\tfor(int t2 = 1;t2 <= NUM_COLOR;t2++){\n\t\t\t\t\tfor(int t3 = 1;t3 <= NUM_COLOR;t3++){\n\t\t\t\t\t\tfor(int t4 = 1;t4 <= NUM_COLOR;t4++){\n\t\t\t\t\t\t\tint workP[][] = new int[h][w];\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\t\t\t\t\tworkP[i] = Arrays.copyOf(p[i],p[i].length);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//System.out.println(t1 + \" \" + t2 + \" \" + t3 + \" \" + t4 );\n\t\t\t\t\t\t\tchangeColor(workP,t1,0,0,1);\n\t\t\t\t\t\t\tchangeColor(workP,t2,0,0,1);\n\t\t\t\t\t\t\tchangeColor(workP,t3,0,0,1);\n\t\t\t\t\t\t\tchangeColor(workP,t4,0,0,1);\n\t\t\t\t\t\t\tchangeColor(workP,c,0,0,1);\n\t\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\t\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\t\t\t\t\tcnt = cntWColor(workP,c,0,0);}}\n\t\t\t\t\t\t\tmax = Math.max(max,cnt);\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tSystem.out.println(cnt);\n\t\t\t\t\t\t\tSystem.out.println(t1 +\":\" +t2 +\":\" +t3 + \":\" +t4 +\":\" + cnt);\n\t\t\t\t\t\t\tfor(int i = 0;i < workP.length;i++){\n\t\t\t\t\t\t\t\tfor(int j = 0;j < workP[i].length;j++){\n\t\t\t\t\t\t\t\t\tSystem.out.print(workP[i][j] + \" \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tint[][] changeColor(int[][] panel,int color,int x,int y,int dir){\n\t\tif(dir != 0 && x + 1 < panel.length && panel[x+1][y] == panel[x][y])\n\t\t\tpanel = changeColor(panel,color,x+1,y,1);\n\t\tif(dir != 1 && x > 0 && panel[x-1][y] == panel[x][y])\n\t\t\tpanel = changeColor(panel,color,x-1,y,0);\n\t\tif(dir != 2 && y + 1 < panel[x].length && panel[x][y+1] == panel[x][y])\n\t\t\tpanel = changeColor(panel,color,x,y+1,3);\n\t\tif(dir != 3 && y > 0 && panel[x][y-1] == panel[x][y])\n\t\t\tpanel = changeColor(panel,color,x,y-1,2);\n\t\tpanel[x][y] = color;\n\t\treturn panel;\n\t}\n\n\tint cntWColor(int[][] panel,int color,int x,int y){\n\t\tint cnt = 0;\n\t\tif(x + 1 < panel.length){\n\t\t\tif(panel[x+1][y] == panel[x][y])cnt += cntWColor(panel,color,x+1,y);\n\t\t}\n\t\tif(y + 1 < panel[x].length){\n\t\t\tif(panel[x][y+1] == panel[x][y])cnt += cntHColor(panel,color,x,y+1);\n\t\t}\n\t\tcnt++;\n\t\treturn cnt;\n\t}\n\n\tint cntHColor(int[][] panel,int color,int x,int y){\n\t\tint cnt = 0;\n\t\tif(y + 1 < panel[x].length){\n\t\t\tif(panel[x][y+1] == panel[x][y])cnt += cntHColor(panel,color,x,y+1);\n\t\t}\n\t\tcnt++;\n\t\treturn cnt;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic boolean hasNext(int[] r,int[] a){\n\t\tfor(int i=r.length-1;i>=0;i--){\n\t\t\tif(a[i]+1<r[i])return true;\n\t\t}\n\t\treturn false;\n\t}\n\tstatic boolean next(int[] r,int[] a){\n\t\tfor(int i=r.length-1;i>=0;i--){\n\t\t\tif(a[i]+1<r[i]){\n\t\t\t\ta[i]++;return true;\n\t\t\t}else{\n\t\t\t\ta[i]=0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tclass P{\n\t\tint x,y;\n\t\tP(int _y,int _x){\n\t\t\tx=_x;y=_y;\n\t\t}\n\t}\n\n\tfinal int[] dx=new int[]{1,0,-1,0},dy=new int[]{0,1,0,-1};\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint H=sc.nextInt(),W=sc.nextInt(),C=sc.nextInt()-1;\n\t\t\tif(H==0 && W==0)return;\n\t\t\tint[][] map=new int[H][W];\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++)\n\t\t\t\tmap[h][w]=sc.nextInt()-1;\n\n\t\t\tP[][] pmap=new P[H][W];\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++)pmap[h][w]=new P(h,w);\n\n\t\t\tint M=0;\n\t\t\tfor(int[] is=new int[5],R=new int[]{6,6,6,6,6};hasNext(R,is);next(R,is)){\n\t\t\t\tif(is[4]!=C)continue;\n\t\t\t\tboolean[][] passed=new boolean[H][W];\n\n\t\t\t\tQueue<P> que=new LinkedList<P>();\n\t\t\t\tpassed[0][0]=true;\n\t\t\t\tint c=map[0][0];\n\t\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\t\t//キューに突っ込む\n\t\t\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\t\t\tif(passed[h][w])que.add(pmap[h][w]);\n\t\t\t\t\t}\n\t\t\t\t\tQueue<P> tmp=new LinkedList<P>();\n\t\t\t\t\twhile(!que.isEmpty()){\n\t\t\t\t\t\tP p=que.poll();\n\t\t\t\t\t\tfor(int di=0;di<4;di++){\n\t\t\t\t\t\t\tint x=p.x+dx[di],y=p.y+dy[di];\n\t\t\t\t\t\t\tif(0<=x && x< W && 0<=y && y<H){\n\t\t\t\t\t\t\t\tif(map[y][x]==c && !passed[y][x]){\n\t\t\t\t\t\t\t\t\tque.add(pmap[y][x]);\n\t\t\t\t\t\t\t\t\tpassed[y][x]=true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i+1==6)break;\n\n\t\t\t\t\t//next\n\t\t\t\t\tque=tmp;\n\t\t\t\t\t//color change\n\t\t\t\t\tc=is[i];\n\t\t\t\t}\n\n\t\t\t\tint co=0;\n\t\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\t\tif(passed[h][w])co++;\n\t\t\t\t}\n\t\t\t\tM=max(co,M);\n\t\t\t}\n\t\t\tln(M);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint[][][] map;\n\tboolean[][] visited = new boolean[40][40];\n\t\n\tint targetc;\n\tint[] vx = {1, 0, -1, 0}, vy = {0, 1, 0, -1};\n\tint dfs2(int x, int y, int[][] a) {\n\t\tif (a[y][x] != targetc || visited[y][x]) return 0;\n\t\t\n\t\tvisited[y][x] = true;\n\t\tint h = a.length, w = a[0].length;\n\t\tint res = 1;\n\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\tint nx = x + vx[d], ny = y + vy[d];\n\t\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h) {\n\t\t\t\tres += dfs2(nx, ny, a);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid dfs3(int origin, int c, int x, int y, int num) {\n\t\tif (visited[y][x]) return;\n\t\tvisited[y][x] = true;\n\t\t\n\t\tint h = map[0].length, w = map[0][0].length;\n\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\tint nx = x + vx[d], ny = y + vy[d];\n\t\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && (origin == map[num][ny][nx])) {\n\t\t\t\tdfs3(origin, c, nx, ny, num);\n\t\t\t}\n\t\t}\n\t\tmap[num][y][x] = c;\n\t}\n\t\n\tint dfs(int color, int num) {\n\t\tint h = map[0].length, w = map[0][0].length;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tmap[num+1][i][j] = map[num][i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < visited.length; i++) Arrays.fill(visited[i], false);\n\t\tdfs3(map[num+1][0][0], color, 0, 0, num + 1);\n\t\t\n\t\tif (num == 4) {\n\t\t\tfor (int i = 0; i < visited.length; i++) Arrays.fill(visited[i], false);\n\t\t\tint x = dfs2(0, 0, map[5]);\n\n\t\t\treturn x;\n\t\t} else {\n\t\t\tint res = 0;\n\t\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\t\tres = Math.max(res, dfs(i, num + 1));\n\t\t\t}\n\t\t\treturn res;\t\t\t\n\t\t}\n\t}\n\t\n//\tint[] order = {6, 3, 4, 2, 5};\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint h = in.nextInt(), w = in.nextInt();\n\t\t\ttargetc = in.nextInt();\n\t\t\t\n\t\t\tif (h == 0) break;\n\t\t\t\n\t\t\tmap = new int[7][h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[0][i] = in.nextIntArray(w);\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 1; i <= 6; i++)\n\t\t\t\tres = Math.max(res, dfs(i, 0));\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tScanner sc = new Scanner(in);\n\tint h, w, c;\n\tint[] order = new int[5];\n\tint max;\n\tint[][] p;\n\tint[][] q;\n\t\n\tQueue<Integer> qx = new LinkedList<Integer>();\n\tQueue<Integer> qy = new LinkedList<Integer>();\n\t\n\t\n\tint calc() {\n\t\tint ans = 0;\n\t\tint[] dx = {-1, 0, 1, 0};\n\t\tint[] dy = {0, -1, 0, 1};\n\t\tint x, y;\n\t\tboolean[][] check = new boolean[h][w]; \n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 0; j < h; j++)\n\t\t\t\tArrays.fill(check[j], false);\n\t\t\tqx.add(0); qy.add(0);\n\t\t\tcheck[0][0] = true;\n\t\t\tint color = q[0][0];\n\t\t\twhile(!qx.isEmpty()) {\n\t\t\t\tx = qx.poll();\n\t\t\t\ty = qy.poll();\n\t\t\t\tq[x][y] = order[i];\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tif (x+dx[j] >= 0 &&\n\t\t\t\t\t\tx+dx[j] < h &&\n\t\t\t\t\t\ty+dy[j] >= 0 &&\n\t\t\t\t\t\ty+dy[j] < w &&\n\t\t\t\t\t\t!check[x+dx[j]][y+dy[j]] &&\n\t\t\t\t\t\tq[x+dx[j]][y+dy[j]] == color) {\n\t\t\t\t\t\tcheck[x+dx[j]][y+dy[j]] = true;\n\t\t\t\t\t\tqx.add(x+dx[j]);\n\t\t\t\t\t\tqy.add(y+dy[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < h; j++)\n\t\t\tArrays.fill(check[j], false);\n\t\tqx.add(0); qy.add(0);\n\t\tcheck[0][0] = true;\n\t\twhile(!qx.isEmpty()) {\n\t\t\tx = qx.poll();\n\t\t\ty = qy.poll();\n\t\t\tans++;\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (x+dx[j] >= 0 &&\n\t\t\t\t\tx+dx[j] < h &&\n\t\t\t\t\ty+dy[j] >= 0 &&\n\t\t\t\t\ty+dy[j] < w &&\n\t\t\t\t\t!check[x+dx[j]][y+dy[j]] &&\n\t\t\t\t\tq[x+dx[j]][y+dy[j]] == order[4]) {\n\t\t\t\t\tcheck[x+dx[j]][y+dy[j]] = true;\n\t\t\t\t\tqx.add(x+dx[j]);\n\t\t\t\t\tqy.add(y+dy[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tvoid copy() {\n\t\tfor (int i = 0; i < h; i++)\n\t\t\t for (int j = 0; j < w; j++)\n\t\t\t\t q[i][j] = p[i][j];\n\t\t\t\n\t}\n\t\n\tvoid recursion(int d) {\n\t\t if (d == 4) {\n\t\t\t copy();\n\t\t\t max = Math.max(calc(), max);\n\t\t } else {\n\t\t\t for (int i = 1; i <= 6; i++) {\n\t\t\t\t order[d] = i;\n\t\t\t\t recursion(d+1);\n\t\t\t }\n\t\t }\n\t\t\n\t}\n\t\n\tvoid run() {\n\t\twhile(true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tif (h == 0 && w == 0 && c == 0)\n\t\t\t\tbreak;\n\t\t\tp = new int[h][w];\n\t\t\tq = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tp[i][j] = sc.nextInt();\n\t\t\t\n\t\t\tmax = 0;\n\t\t\torder[4] = c;\n\t\t\trecursion(0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w, c;\n    int max;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt(); w = sc.nextInt(); c = sc.nextInt();\n            if(h==0 && w==0 && c==0) break;\n\n            int[][] p = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p[i][j] = sc.nextInt();\n\n            max = 0;\n            rec(p, 0);\n            System.out.println(max);\n        }\n    }\n\n    void rec(int[][] p, int cnt){\n        if(p[0][0]==c){\n            //p = changeColor(p, c);\n            max = Math.max(max, countColor(p));\n        }\n        if(cnt==5) return; \n\n        for(int i=1; i<=6; i++){\n            if(i==p[0][0]) continue;\n            int[][] p2 = new int[h][w];\n            for(int j=0; j<h; j++)\n                for(int k=0; k<w; k++) p2[j][k] = p[j][k];\n            //System.out.println(\"cnt:\"+cnt+\" color:\"+i);\n            p2 = changeColor(p2, i);\n            rec(p2, cnt + 1);\n        }\n    }\n\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n\n    int[][] changeColor(int[][] p, int color){\n        /*\n        System.out.println(\"before\");\n        for(int i=0; i<h; i++)\n            System.out.println(Arrays.toString(p[i]));\n        */\n        int before = p[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        p[0][0] = color;\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p[ny][nx]!=before) continue;\n                p[ny][nx] = color;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        /*\n        System.out.println(\"after\");\n        for(int i=0; i<h; i++)\n            System.out.println(Arrays.toString(p[i]));\n        */\n        return p;\n    }\n    int countColor(int[][] p){\n        int target = p[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        int cnt = 0;\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n            cnt++;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p[ny][nx]!=target) continue;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  /**\n   * ??±???????????¢?´¢\n   *\n   * @return count ??? max\n   */\n  int dfs(int[][] p, int depth) {\n    if (depth >= 5) {\n      return count(p, c);\n    }\n    int max = 0;\n    for (int i = 1; i <= 6; ++i) {\n      int[][] next = new int[h][w];\n      for (int y = 0; y < h; ++y) {\n        for (int x = 0; x < w; ++x) {\n          next[y][x] = p[y][x];\n        }\n      }\n      paint(next, i);\n      int res = dfs(next, depth + 1);\n      max = Math.max(max, res);\n    }\n    return max;\n  }\n\n  int[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0}\n  };\n\n  /**\n   * ???????????¢?´¢??§????????????\n   */\n  int count(int[][] p, int color) {\n    if (p[0][0] != color) {\n      return 0;\n    }\n    boolean[][] done = new boolean[h][w];\n    Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\n    queue.add(new Pair<>(0, 0));\n    done[0][0] = true;\n    int cnt = 0;\n    while (queue.size() > 0) {\n      Pair<Integer, Integer> point = queue.poll();\n      ++cnt;\n      for (int[] d : ofs) {\n        int nx = point.f + d[0];\n        int ny = point.s + d[1];\n        if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n          continue;\n        }\n        if (done[ny][nx]) {\n          continue;\n        }\n        done[ny][nx] = true;\n        if (p[ny][nx] != color) {\n          continue;\n        }\n        Pair<Integer, Integer> next = new Pair<>(nx, ny);\n        queue.add(next);\n      }\n    }\n    return cnt;\n  }\n\n  /**\n   * ???????????¢?´¢??§?????£?????????\n   */\n  void paint(int[][] p, int color) {\n    boolean[][] done = new boolean[h][w];\n    Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\n    queue.add(new Pair<>(0, 0));\n    done[0][0] = true;\n    int atom = p[0][0];\n    while (queue.size() > 0) {\n      Pair<Integer, Integer> point = queue.poll();\n      p[point.s][point.f] = color;\n      for (int[] d : ofs) {\n        int nx = point.f + d[0];\n        int ny = point.s + d[1];\n        if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n          continue;\n        }\n        if (done[ny][nx]) {\n          continue;\n        }\n        done[ny][nx] = true;\n        if (p[ny][nx] != atom) {\n          continue;\n        }\n        Pair<Integer, Integer> next = new Pair<>(nx, ny);\n        queue.add(next);\n      }\n    }\n  }\n\n  int h, w, c;\n\n  void run() {\n    for (; ; ) {\n      h = ni();\n      w = ni();\n      c = ni();\n      if (h == 0) {\n        break;\n      }\n      int[][] p = new int[h][w];\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n          p[i][j] = ni();\n        }\n      }\n      System.out.println(dfs(p, 0));\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w, c;\n    int max;\n    int[][] p;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            h = sc.nextInt(); w = sc.nextInt(); c = sc.nextInt();\n            if(h==0 && w==0 && c==0) break;\n\n            p = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p[i][j] = sc.nextInt();\n\n            max = 0;\n            rec(0);\n            System.out.println(max);\n        }\n    }\n\n    int[] num = new int[5];\n\n    void rec(int cnt){\n        if(cnt==5){\n            if(num[4]!=c) return;\n            int[][] p2 = new int[h][w];\n            for(int i=0; i<h; i++)\n                for(int j=0; j<w; j++) p2[i][j] = p[i][j];\n            for(int i=0; i<5; i++){\n                if(num[i]==p2[0][0]) continue;\n                p2 = changeColor(p2, num[i]);\n            }\n            int cc = countColor(p2);\n            max = Math.max(max, cc);\n            return;\n        }\n\n        for(int i=1; i<=6; i++){\n            num[cnt] = i;\n            rec(cnt + 1);\n        }\n    }\n\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n\n    int[][] changeColor(int[][] p, int color){\n        /*\n        System.out.println(\"before\");\n        for(int i=0; i<h; i++)\n            System.out.println(Arrays.toString(p[i]));\n        */\n        int before = p[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        p[0][0] = color;\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p[ny][nx]!=before) continue;\n                p[ny][nx] = color;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        /*\n        System.out.println(\"after\");\n        for(int i=0; i<h; i++)\n            System.out.println(Arrays.toString(p[i]));\n        */\n        return p;\n    }\n    int countColor(int[][] p){\n        int target = p[0][0];\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        q.add(new int[]{0, 0});\n        boolean[][] v = new boolean[h][w];\n\n        int cnt = 0;\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n            cnt++;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || p[ny][nx]!=target) continue;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  int h, w, c;\n\n  int[][] field;\n\n  int dfs(int depth) {\n    if ( depth == 4 ) {\n      fill( c );\n//      debug(\"!!!!\", res, \"!!!!\");\n      return fill( c );\n    }\n\n    int[][] dup = new int[h][w];\n    for ( int i = 0; i < h; ++i ) {\n      for ( int j = 0; j < w; ++j ) {\n        dup[ i ][ j ] = field[ i ][ j ];\n      }\n    }\n    int max = 0;\n    for ( int r = 1; r <= 6; ++r ) {\n      fill( r );\n//      debug(depth);\n//      for(int[] a : field) debug(a);\n      max = Math.max( max, dfs( depth + 1 ) );\n      for ( int i = 0; i < h; ++i ) {\n        for ( int j = 0; j < w; ++j ) {\n          field[ i ][ j ] = dup[ i ][ j ];\n        }\n      }\n    }\n    return max;\n  }\n\n  int[][] ofs = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\n\n  int fill(int color) {\n    int cnt = 0;\n    Queue<Integer> qx = new LinkedList<Integer>();\n    Queue<Integer> qy = new LinkedList<Integer>();\n    qx.add( 0 );\n    qy.add( 0 );\n    boolean[][] done = new boolean[h][w];\n    boolean[][] ok = new boolean[h + 2][w + 2];\n    for ( int i = 1; i <= h; ++i ) {\n      for ( int j = 1; j <= w; ++j ) {\n        ok[ i ][ j ] = true;\n      }\n    }\n    int atom = field[ 0 ][ 0 ];\n    field[ 0 ][ 0 ] = color;\n    done[ 0 ][ 0 ] = true;\n    ++cnt;\n    while (qx.size() > 0) {\n      int x = qx.poll();\n      int y = qy.poll();\n\n      for ( int[] d : ofs ) {\n        int nx = x + d[ 0 ];\n        int ny = y + d[ 1 ];\n        if ( ok[ ny + 1 ][ nx + 1 ] && !done[ ny ][ nx ]\n            && field[ ny ][ nx ] == atom ) {\n          done[ ny ][ nx ] = true;\n          field[ ny ][ nx ] = color;\n          qx.add( nx );\n          qy.add( ny );\n          ++cnt;\n        }\n      }\n    }\n\n    return cnt;\n  }\n\n  void run() {\n    for ( ;; ) {\n      h = ni();\n      w = ni();\n      c = ni();\n      if ( ( h | w | c ) == 0 ) {\n        break;\n      }\n\n      field = new int[h][w];\n      for ( int i = 0; i < h; ++i ) {\n        for ( int j = 0; j < w; ++j ) {\n          field[ i ][ j ] = ni();\n        }\n      }\n\n      System.out.println( dfs( 0 ) );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Identically Colored Panels Connection\n */\npublic class Main {\n\n\tenum COLOR {\n\t\tNONE, YELLOW, PINK, RED, PURPLE, GREEN, BLUE,\n\t}\n\n\tstatic int[][] DIR = {\n\t\t\t{1, 0},\n\t\t\t{0, 1},\n\t\t\t{-1, 0},\n\t\t\t{0, -1},\n\t};\n\n\tstatic COLOR tc;\n\tstatic int max = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st;\n\n\t\t\tst = new StringTokenizer(line);\n\n\t\t\tint h, w;\n\t\t\th = parseInt(st.nextToken());\n\t\t\tw = parseInt(st.nextToken());\n\t\t\ttc = COLOR.values()[parseInt(st.nextToken())];\n\t\t\tif ((h | w) == 0) break;\n\n\t\t\tCOLOR[][] pane = new COLOR[h + 2][w + 2];\n\n\t\t\tfor (COLOR[] pp : pane) {\n\t\t\t\tArrays.fill(pp, COLOR.NONE);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tpane[i + 1][j + 1] = COLOR.values()[st.nextToken().charAt(0) - '0'];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tmax = 0;\n\n\t\t\tsolve(pane, 5);\n\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tstatic void solve(COLOR[][] pane, int r) {\n\n\t\tif (r == 0) {\n\t\t\tif (pane[1][1] == tc) {\n\t\t\t\tint count = 0;\n\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\tqueue.offer(new int[]{1, 1});\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tint[] q = queue.poll();\n\t\t\t\t\tfor (int[] dir : DIR) {\n\t\t\t\t\t\tint ny, nx;\n\t\t\t\t\t\tny = q[0] + dir[0];\n\t\t\t\t\t\tnx = q[1] + dir[1];\n\t\t\t\t\t\tif (pane[ny][nx] == tc) {\n\t\t\t\t\t\t\tpane[ny][nx] = COLOR.NONE;\n\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count == 0) count = 1;\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tCOLOR pc = pane[1][1];\n\n\t\tfor (COLOR nc : COLOR.values()) {\n\t\t\tif (nc != COLOR.NONE && nc != pc) {\n\t\t\t\tif (r == 1 && nc != tc) continue;\n\t\t\t\tCOLOR[][] _pane = copy(pane);\n\t\t\t\t_pane[1][1] = nc;\n\t\t\t\t//\n\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\tqueue.offer(new int[]{1, 1});\n\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\tint[] q = queue.poll();\n\t\t\t\t\tfor (int[] dir : DIR) {\n\t\t\t\t\t\tint ny, nx;\n\t\t\t\t\t\tny = q[0] + dir[0];\n\t\t\t\t\t\tnx = q[1] + dir[1];\n\t\t\t\t\t\tif (_pane[ny][nx] == pc) {\n\t\t\t\t\t\t\t_pane[ny][nx] = nc;\n\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsolve(_pane, r - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic COLOR[][] copy(COLOR[][] pane) {\n\t\tCOLOR[][] _pane = new COLOR[pane.length][];\n\t\tfor (int i = 0; i < pane.length; i++) {\n\t\t\t_pane[i] = pane[i].clone();\n\t\t}\n\t\treturn _pane;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class pannel {\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    public static void main ( String [] args ) throws IOException\n\n\n    {\n    \t\n\tnew pannel().cal();\n    }\n\n \n    private void cal() throws IOException \n    {\n    \twhile(true){\n\t    String[] buffer=br.readLine().split(\"\\\\s\");\n    \t\n\t    int height=Integer.parseInt(buffer[0]);\n\n\n\t    int width=Integer.parseInt(buffer[1]);\n\t    int objectColor = Integer.parseInt(buffer[2]);\n\t    int[][] arr=new int[height][width];\n\t    int max=0;\n    \t\t\n\t    if(height==0 && width==0 && objectColor==0)\n\t    \tbreak;\n    \t\t\n\t    for(int i=0;i<height;i++){\n\t    \tString[] temp=br.readLine().split(\"\\\\s\");\n\t    \tfor(int j=0;j<width;j++)\n\t    \t\tarr[i][j]=Integer.parseInt(temp[j]);\n\t    \t}\n    \t\t\n\t    for(int i=1;i<7;i++)\n\t    \tif(i!=objectColor)\n\t    \t\tfor(int j=1;j<7;j++)\n\t    \t\t\tfor(int k=1;k<7;k++)\n\t    \t\t\t\tfor(int m=1;m<7;m++){\n\t    \t\t\t\t\tif(i==j || j==k || k==m||m==objectColor)\n\t    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t\t\t\n\t    \t\t\t\t\tint temp=checkColor(0,0,change(arr,m,k,j,i,objectColor),objectColor);\n\t\t\t\t\t\t\n\t    \t\t\t\t\tif(max<temp){\n\t    \t\t\t\t\t\tmax=temp;\n\t\t\t\t\t\t\t/*\tfor(int z=0;z<height;z++){\n\t\t\t\t\t\t\t    for(int x=0;x<width;x++)\n\t\t\t\t\t\t\t\tSystem.out.print(change(arr,m,k,j,i,objectColor)[z][x]+\" \");\n\t\t\t\t\t\t\t    System.out.println(\"\");\t\t    }\t\t\tSystem.out.println(\"max : \"+max);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t*/\t}}\n\t    \n\t    System.out.println(max);\n    \t}\n\n    \t\n    }\n    public int[][] change(int[][] arr,int m,int k,int j,int i,int Color){\n\n\n    \tint[][]tempArr=(int[][]) clone(arr);\n\tint initial=tempArr[0][0];\n\n\tchangeCell(tempArr,0,0,m,initial);\n\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=m;\n\n     \tchangeCell(tempArr,0,0,k,m);\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=k;\n\n    \tchangeCell(tempArr,0,0,j,k); \n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=j;\n\n    \tchangeCell(tempArr,0,0,i,j);\n \n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=i;\n\n    \tchangeCell(tempArr,0,0,Color,i);\n\n\tfor(int x=0;x<arr.length;x++)\n\t    for(int y=0;y<arr[0].length;y++)\n\t\tif(tempArr[x][y]==0)\n\t\t    tempArr[x][y]=Color;\n\n    \treturn tempArr; \n    }\n    \n    public static Object[] clone(int[][] arr){\n    \t\tif(arr==null)\n    \t\t\t\treturn null;\n    \t\telse {\n\t\t    int[][] temp=new int[arr.length][arr[0].length];\n\t\t    for(int i=0;i<arr.length;i++)\n\t\t\tfor(int j=0;j<arr[0].length;j++)\n\t\t\t    temp[i][j]=arr[i][j];\n\t\t    \n    \t\t\t\treturn temp;\n\t\t}\n    }\n    \n    public int checkColor(int a,int b,int[][] checkingArr,int Color){\n    \t\n    \t\tif(a>=0 && b>=0 &&a<checkingArr.length&& b<checkingArr[0].length&&checkingArr[a][b]==Color){\n\t\t    checkingArr[a][b]=0;\n\t\t    return 1+\ncheckColor(a-1,b,checkingArr,Color)+checkColor(a+1,b,checkingArr,Color)+\ncheckColor(a,b-1,checkingArr,Color)+checkColor(a,b+1,checkingArr,Color);\n    \t\t}\n    \t\telse \n    \t\t\t\treturn 0;\n    }\n    \n    public void changeCell(int[][] tempArr,int a, int b,int c,int d){\n\n    \ttempArr[a][b]=0;\n    \t\n    \tif(a>0 && tempArr[a-1][b]==d)\n    \t\tchangeCell(tempArr,a-1,b,c,d);\n    \tif(b>0 && tempArr[a][b-1]==d)\n    \t\tchangeCell(tempArr,a,b-1,c,d);\n    \tif(a<tempArr.length-1 && tempArr[a+1][b]==d)\n    \t\tchangeCell(tempArr,a+1,b,c,d);\n    \tif(b<tempArr[0].length-1 && tempArr[a][b+1]==d)\n    \t\tchangeCell(tempArr,a,b+1,c,d);\n\t\n\n\n    \t\n    }\n\n    \n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n    static int h, w, c;\n    static int[][] map;\n    static Deque<ArrayList<Point>> stack;\n    static int max;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            h = sc.nextInt();\n            w = sc.nextInt();\n            c = sc.nextInt();\n            if ((h | w | c) == 0) {\n                break;\n            }\n            map = new int[h][w];\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    map[i][j] = sc.nextInt();\n                }\n            }\n            stack = new ArrayDeque<>();\n            max = Integer.MIN_VALUE;\n            dp(1);\n            System.out.println(max);\n        }\n\n    }\n\n    public static void dp(int k) {\n        int col = map[0][0];\n        if (k == 5) {\n            if (col == c) {\n                return;\n            }\n            ArrayList<Point> pos = new ArrayList<>();\n            fill(0, 0, col, c, pos);\n            ArrayList<Point> pos2 = new ArrayList<>();\n            fill(0, 0, c, 10, pos2);\n            for (Point p : pos2) {\n                map[p.y][p.x] = c;\n            }\n            for (Point p : pos) {\n                map[p.y][p.x] = col;\n            }\n            max = Math.max(pos2.size(), max);\n            return;\n        }\n        for (int i = 1; i <= 6; i++) {\n            if (i == col) {\n                continue;\n            }\n            ArrayList<Point> pos = new ArrayList<>();\n            fill(0, 0, col, i, pos);\n            dp(k + 1);\n            for (Point p : pos) {\n                map[p.y][p.x] = col;\n            }\n        }\n    }\n\n    public static void arrayDump(int[][] a) {\n        for (int i = 0, l = a.length; i < l; i++) {\n            for (int j = 0, l2 = a[0].length; j < l2; j++) {\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    public static void fill(int y, int x, int colFrom, int colTo, ArrayList<Point> pos) {\n        if (y < 0 || x < 0 || y >= h || x >= w) {\n            return;\n        }\n        if (map[y][x] != colFrom) {\n            return;\n        }\n        map[y][x] = colTo;\n        pos.add(new Point(y, x));\n        fill(y + 1, x, colFrom, colTo, pos);\n        fill(y - 1, x, colFrom, colTo, pos);\n        fill(y, x + 1, colFrom, colTo, pos);\n        fill(y, x - 1, colFrom, colTo, pos);\n    }\n\n    public static class Point {\n        int x;\n        int y;\n\n        Point(int y, int x) {\n            this.x = x;\n            this.y = y;\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tif (h == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint w = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\n\t\t\tint[][] panel = new int[h][w];\n\t\t\tfor (int i = 0; i < panel.length; i++) {\n\t\t\t\tfor (int j = 0; j < panel[i].length; j++) {\n\t\t\t\t\tpanel[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint max = 0;\n\t\t\tfor (int i1 = 1; i1 <= 6; i1++) {\n\t\t\t\tfor (int i2 = 1; i2 <= 6; i2++) {\n\t\t\t\t\tfor (int i3 = 1; i3 <= 6; i3++) {\n\t\t\t\t\t\tfor (int i4 = 1; i4 <= 6; i4++) {\n\t\t\t\t\t\t\tint[][] dummy = new int[h][w];\n\t\t\t\t\t\t\tfor (int i = 0; i < dummy.length; i++) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < dummy[0].length; j++) {\n\t\t\t\t\t\t\t\t\tdummy[i][j] = panel[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcheck(dummy, i1);\n\t\t\t\t\t\t\tcheck(dummy, i2);\n\t\t\t\t\t\t\tcheck(dummy, i3);\n\t\t\t\t\t\t\tcheck(dummy, i4);\n\t\t\t\t\t\t\tcheck(dummy, c);\n\t\t\t\t\t\t\tmax = Math.max(max, check(dummy, c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(max);\n\t\t}\n\n\t}\n\n\tstatic int check(int[][] dummy, int c) {\n\t\tint old = dummy[0][0];\n\t\tboolean[][] used = new boolean[dummy.length][dummy[0].length];\n\t\tDeque<Integer[]> deque = new ArrayDeque<Integer[]>();\n\t\tInteger[] first = { 0, 0 };\n\t\tdeque.add(first);\n\t\tused[0][0] = true;\n\t\tdummy[0][0] = c;\n\t\tint ret = 1;\n\n\t\tint[][] dir = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\t\twhile (!deque.isEmpty()) {\n\t\t\tInteger[] poll = deque.poll();\n\t\t\tint i = poll[0];\n\t\t\tint j = poll[1];\n\n\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\tif (i + dir[k][0] >= 0 && i + dir[k][0] < dummy.length && j + dir[k][1] >= 0\n\t\t\t\t\t\t&& j + dir[k][1] < dummy[0].length && !used[i + dir[k][0]][j + dir[k][1]]\n\t\t\t\t\t\t&& dummy[i + dir[k][0]][j + dir[k][1]] == old) {\n\t\t\t\t\tInteger[] put = { i + dir[k][0], j + dir[k][1] };\n\t\t\t\t\tdeque.add(put);\n\t\t\t\t\tused[i + dir[k][0]][j + dir[k][1]] = true;\n\t\t\t\t\tdummy[i + dir[k][0]][j + dir[k][1]] = c;\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Identically Colored Panels Connection\npublic class Main{\n\n\tint h, w, t;\n\tint[][] o;\n\tint[][] tmp;\n\tint[] order;\n\tboolean[][] u;\n\tint max, c;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\n\tvoid e(){\n\t\tfor(int k=0;k<5;k++){\n\t\t\tif(tmp[0][0]==order[k])continue;\n\t\t\tflip(0, 0, tmp[0][0], order[k]);\n\t\t}\n\t\tc = 0;\n\t\tu = new boolean[h][w];\n\t\tv(0, 0);\n\t}\n\n\tvoid v(int i, int j){\n\t\tif(tmp[i][j]!=t)return;\n\t\tc++;\n\t\tu[i][j] = true;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&!u[ni][nj]){\n\t\t\t\tv(ni, nj);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid flip(int i, int j, int from, int to){\n\t\tif(tmp[i][j]!=from)return;\n\t\ttmp[i][j] = to;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w)flip(ni, nj, from, to);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tt = sc.nextInt();\n\t\t\tif((h|w|t)==0)break;\n\t\t\to = new int[h][w];\n\t\t\ttmp = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)o[i][j]=sc.nextInt();\n\t\t\tmax = 0;\n\t\t\torder = new int[5];\n\t\t\tfor(int i=1;i<=6;i++){\n\t\t\t\tfor(int j=1;j<=6;j++){\n\t\t\t\t\tfor(int k=1;k<=6;k++){\n\t\t\t\t\t\tfor(int l=1;l<=6;l++){\n\t\t\t\t\t\t\torder[0] = i;\n\t\t\t\t\t\t\torder[1] = j;\n\t\t\t\t\t\t\torder[2] = k;\n\t\t\t\t\t\t\torder[3] = l;\n\t\t\t\t\t\t\torder[4] = t;\n\t\t\t\t\t\t\tfor(int x=0;x<h;x++)for(int y=0;y<w;y++)tmp[x][y]=o[x][y];\n\t\t\t\t\t\t\te();\n\t\t\t\t\t\t\tmax = Math.max(max, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\n/*!!!GORIOSHI PROGRAM!!!*/\nnamespace V1174_1{\n    public class Program{\n        public static void Main(string[] args){\n            var sr = new StreamReader();\n            //---------------------------------\n            var dx = new[]{0, 1, 0, -1};\n            var dy = new[]{1, 0, -1, 0};\n            while(true){\n                var H = sr.Next<int>();\n                var W = sr.Next<int>();\n                var C = sr.Next<int>();\n                var P = sr.Next<int>(H, W);\n                if(H == 0 && W == 0 && C == 0) break;\n\n                var max = 0;\n                Func<int, int, bool> isInside = (x, y) => 0 <= x && x < W && 0 <= y && y < H;\n                Action<int[][], int, int> dfs1 = null;\n                dfs1 = (p, cnt, nc) =>{\n                    var cc = p[0][0];\n                    if(nc == cc) return;\n\n                    if(cnt == 5){\n                        var res = 0;\n                        if(cc == C){\n                            Action<int, int> dfs3 = null;\n                            dfs3 = (x, y) =>{\n                                res++;\n                                p[y][x] = -1;\n                                for(var i = 0; i < 4; i++){\n                                    var nx = x + dx[i];\n                                    var ny = y + dy[i];\n                                    if(isInside(nx, ny) && p[ny][nx] == cc){\n                                        dfs3(nx, ny);\n                                    }\n                                }\n                            };\n                            dfs3(0, 0);\n                        }\n                        max = Math.Max(max, res);\n                        return;\n                    }\n                    \n                    Action<int, int> dfs2 = null;\n                    dfs2 = (x, y) =>{\n                        p[y][x] = nc;\n                        for(var i = 0; i < 4; i++){\n                            var nx = x + dx[i];\n                            var ny = y + dy[i];\n                            if(isInside(nx, ny) && p[ny][nx] == cc){\n                                dfs2(nx, ny);\n                            }\n                        }\n                    };\n                    dfs2(0, 0);\n\n                    for(var i = 1; i <= 6; i++){\n                        dfs1(p.DeepCopy(), cnt + 1, i);\n                    }\n                };\n\n                for(var i = 1; i <= 6; i++){\n                    dfs1(P.DeepCopy(), 0, i);\n                }\n\n                Console.WriteLine(max);\n            }\n            //---------------------------------\n        }\n    }\n\n    public static class ExMethod{\n        public static T[] DeepCopy<T>(this T[] src){\n            var res = new T[src.Length];\n            for(var i = 0; i < src.Length; i++){\n                res[i] = src[i];\n            }\n            return res;\n        }\n\n        public static T[][] DeepCopy<T>(this T[][] src){\n            var res = new T[src.Length][];\n            for(var i = 0; i < src.Length; i++){\n                res[i] = src[i].DeepCopy();\n            }\n            return res;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Threading;\n\n/*!!!GORIOSHI PROGRAM!!!*/\nnamespace V1174_1{\n    public class Program{\n        public static void Main(string[] args){\n            var sr = new StreamReader();\n            //---------------------------------\n            var dx = new[]{0, 1, 0, -1};\n            var dy = new[]{1, 0, -1, 0};\n            while(true){\n                var H = sr.Next<int>();\n                var W = sr.Next<int>();\n                var C = sr.Next<int>();\n                var P = sr.Next<int>(H, W);\n                if(H == 0 && W == 0 && C == 0) break;\n\n                var max = 0;\n                Func<int, int, bool> isInside = (x, y) => 0 <= x && x < W && 0 <= y && y < H;\n                Action<int[][], int, int> dfs1 = null;\n                dfs1 = (p, cnt, nc) =>{\n                    var cc = p[0][0];\n                    if(nc == cc) return;\n\n                    if(cnt == 5){\n                        var res = 0;\n                        if(cc == C){\n                            Action<int, int> dfs3 = null;\n                            dfs3 = (x, y) =>{\n                                res++;\n                                p[y][x] = -1;\n                                for(var i = 0; i < 4; i++){\n                                    var nx = x + dx[i];\n                                    var ny = y + dy[i];\n                                    if(isInside(nx, ny) && p[ny][nx] == cc){\n                                        dfs3(nx, ny);\n                                    }\n                                }\n                            };\n                            dfs3(0, 0);\n                        }\n                        max = Math.Max(max, res);\n                        return;\n                    }\n                    \n                    Action<int, int> dfs2 = null;\n                    dfs2 = (x, y) =>{\n                        p[y][x] = nc;\n                        for(var i = 0; i < 4; i++){\n                            var nx = x + dx[i];\n                            var ny = y + dy[i];\n                            if(isInside(nx, ny) && p[ny][nx] == cc){\n                                dfs2(nx, ny);\n                            }\n                        }\n                    };\n                    dfs2(0, 0);\n\n                    for(var i = 1; i <= 6; i++){\n                        dfs1(p.DeepCopy(), cnt + 1, i);\n                    }\n                };\n\n                for(var i = 1; i <= 6; i++){\n                    dfs1(P.DeepCopy(), 0, i);\n                }\n\n                Console.WriteLine(max);\n                //Array.ForEach(P, a => Console.WriteLine(string.Join(\" \", a)));\n            }\n\n            Thread.Sleep(5000);\n            //---------------------------------\n        }\n    }\n\n    public static class ExMethod{\n        public static T[] DeepCopy<T>(this T[] src){\n            var res = new T[src.Length];\n            for(var i = 0; i < src.Length; i++){\n                res[i] = src[i];\n            }\n            return res;\n        }\n\n        public static T[][] DeepCopy<T>(this T[][] src){\n            var res = new T[src.Length][];\n            for(var i = 0; i < src.Length; i++){\n                res[i] = src[i].DeepCopy();\n            }\n            return res;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Math;\nusing System;\n\npublic class P\n{\n    public int t { get; set; }\n    public int c { get; set; }\n    public string via { get; set; }\n}\n\npublic class P2\n{\n    public int x { get; set; }\n    public int y { get; set; }\n\n}\n\npublic class Hello\n{\n    public static int[,] map; public static int h, w;\n    public static int[] dx, dy;\n\n    public static void Main()\n    {\n        dx = new int[] { 0, 1, 0, -1 };\n        dy = new int[] { 1, 0, -1, 0 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            h = int.Parse(line[0]);\n            w = int.Parse(line[1]);\n            var L = int.Parse(line[2]);\n            if (h == 0 && w == 0 && L == 0) break;\n            map = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++) map[i, j] = int.Parse(line[j]);\n            }\n            var ans = getAns(L);\n            Console.WriteLine(ans);\n        }\n    }\n    static int go1(string via)\n    {\n        var map2 = new int[h, w];\n        var st = new Stack<P2>();\n        for (int i = 0; i < h; i++)\n            for (int j = 0; j < w; j++) map2[i, j] = map[i, j];\n        for (int i = 0; i < 5; i++)\n        {\n            var a = int.Parse(via[i].ToString());\n            var a0 = map2[0, 0];\n            st.Push(new P2 { x = 0, y = 0 });\n            while (st.Count() > 0)\n            {\n                var ww = st.Pop();\n                map2[ww.x, ww.y] = a;\n                for (int j = 0; j < 4; j++)\n                {\n                    var nx = ww.x + dx[j];\n                    var ny = ww.y + dy[j];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && map2[nx, ny] == a0)\n                        st.Push(new P2 { x = nx, y = ny });\n                }\n            }\n        }\n        var c00 = map2[0, 0];\n        var visited = new bool[h, w];\n        st.Push(new P2 { x = 0, y = 0 });\n        var count = 0;\n        while (st.Count() > 0)\n        {\n            var ww = st.Pop();\n            if (map2[ww.x, ww.y] == c00)\n            {\n                if (!visited[ww.x, ww.y]) count++;\n                visited[ww.x, ww.y] = true;\n                for (int j = 0; j < 4; j++)\n                {\n                    var nx = ww.x + dx[j];\n                    var ny = ww.y + dy[j];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w && !visited[nx, ny])\n                        st.Push(new P2 { x = nx, y = ny });\n                }\n            }\n        }\n        return count;\n    }\n    static int getAns(int L)\n    {\n        var ans = 0;\n        var a = map[0, 0];\n        var st = new Stack<P>();\n        st.Push(new P { t = 0, c = a, via = \"\" });\n        while (st.Count() > 0)\n        {\n            var w = st.Pop();\n            if (w.t == 5)\n            {\n                var tt = go1(w.via);\n                ans = Max(ans, tt);\n                continue;\n            }\n            if (w.t == 4 && w.c != L)\n            {\n                st.Push(new P { t = 5, c = L, via = w.via + L.ToString() });\n                continue;\n            }\n            if (w.t == 4 && w.c == L) continue;\n            for (int i = 1; i <= 6; i++)\n                if (i != w.c) st.Push(new P { t = w.t + 1, c = i, via = w.via + i.ToString() });\n        }\n        return ans;\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x,first,color){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var X=x+dx[i];\n      var Y=y+dy[i];\n      if(X<0 || Y<0 || X>=w || Y>=h)continue;\n      if(yx[Y][X]==first){\n         yx[Y][X]=color;\n         cnt++;\n         bomb(Y,X,first,color);\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar all=[];\nvar loop=function (ary){\n   if(ary.length==4)all.push(ary);\n   else{\n      for(var i=1;i<=6;i++)loop(ary.concat(i));\n   }\n};\nloop([]);\nwhile(true){\n   var hwc=arr.shift();\n   if(hwc==\"0 0 0\")break;\n   hwc=hwc.split(\" \").map(Number);\n   var h=hwc[0];\n   var w=hwc[1];\n   var c=hwc[2];\n   var panel=[]\n   for(var i=0;i<h;i++)panel.push(arr.shift().split(\" \").map(Number));\n   var max=0;\n   var yx=[];\n   var cnt=1;\n   all.forEach(function(v,index){\n      yx=[];\n      for(var i=0;i<h;i++)yx.push(panel[i].slice());\n      v=v.concat(c);\n      v.forEach(function(value){\n         var first=yx[0][0];\n         yx[0][0]=value;\n         if(value!=first)bomb(0,0,first,value);\n      });\n      cnt=1;\n      yx[0][0]=0;\n      bomb(0,0,c,0);\n      max=Math.max(max,cnt);\n   });\n   console.log(max);\n}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, q, h, w, col, visited)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n        end\n    end\n    f[sy][sx] = col\n    while q.size > 0\n        cy, cx = q.shift\n        f = bfs(f,cy,cx,q,h,w,col,visited)\n    end\n    return f\nend\ndef count(f, sy, sx, q, h, w, visited)\n    c = 0\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n            c += 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        c += count(f,cy,cx,q,h,w,visited)\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,[],h,w,[]) == 1\n    o.select!{|od| od[4] == c}\n    max = 1\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,[],h,w,col,[])\n        end\n        c = count(pp,0,0,[],h,w,[])\n        max = c if c > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, h, w, col)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n            end\n        end\n        f[sy][sx] = col\n    end\n    return f\nend\ndef count(f, sy, sx, h, w)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    c = 1\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n                c += 1\n            end\n        end\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,h,w) == 1\n    o.select!{|od| od[4] == c}\n    max = 0\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,h,w,col)\n        end\n        cnt = count(pp,0,0,h,w)\n        max = cnt if cnt > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, h, w, col)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n            end\n        end\n        f[sy][sx] = col\n    end\n    return f\nend\ndef count(f, sy, sx, h, w)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    c = 1\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n                c += 1\n            end\n        end\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,h,w) == 1\n    o.select!{|od| od[0] != od[1] && od[1] != od[2] && od[2] != od[3] && od[3] != od[4]}\n    o.select!{|od| od[4] == c}\n    max = 0\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,h,w,col)\n        end\n        cnt = count(pp,0,0,h,w)\n        max = cnt if cnt > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, h, w, col)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n            end\n        end\n        f[sy][sx] = col\n    end\n    return f\nend\ndef count(f, sy, sx, h, w)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    c = 1\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n                c += 1\n            end\n        end\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    #o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,h,w) == 1\n    o.select!{|od| od[4] == c}\n    max = 0\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,h,w,col)\n        end\n        cnt = count(pp,0,0,h,w)\n        max = cnt if cnt > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, q, h, w, col, visited)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n        end\n    end\n    f[sy][sx] = col\n    while q.size > 0\n        cy, cx = q.shift\n        f = bfs(f,cy,cx,q,h,w,col,visited)\n    end\n    return f\nend\ndef count(f, sy, sx, q, h, w, visited)\n    c = 0\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n            c += 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        c += count(f,cy,cx,q,h,w,visited)\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,[],h,w,[]) == 1\n    o.select!{|od| od[4] == c}\n    max = 1\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        next\n        od.each do |col|\n            pp = bfs(pp,0,0,[],h,w,col,[])\n        end\n        max = count(pp,0,0,[],h,w,[]) if count(pp,0,0,[],h,w,[]) > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 1174.rb: Identically Colored Panels Connection\n#\n\n### constant\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\nMAX_K = 5\n\n### global variables\n\n### subroutines\n\ndef count_area\n  return 0 if $flds[0][0] != $c\n\n  used = $h.times.map{$w.times.map{false}}\n\n  ar = 1\n  used[0][0] = true\n  q = [[0, 0]]\n\n  while ! q.empty?\n    x0, y0 = q.shift\n    DXYS.each do |dx, dy|\n      x1 = x0 + dx\n      y1 = y0 + dy\n      if x1 >= 0 && x1 < $w && y1 >= 0 && y1 < $h &&\n          $flds[y1][x1] == $c && ! used[y1][x1]\n        ar +=1 \n        used[y1][x1] = true\n        q << [x1, y1]\n      end\n    end\n  end\n\n  ar\nend\n\ndef paint(c)\n  return [] if $flds[0][0] == c\n\n  c0 = $flds[0][0]\n  $flds[0][0] = c\n  q = [[0, 0]]\n  i = 0\n\n  while i < q.length\n    x0, y0 = q[i]\n    i += 1\n    DXYS.each do |dx, dy|\n      x1 = x0 + dx\n      y1 = y0 + dy\n      if x1 >= 0 && x1 < $w && y1 >= 0 && y1 < $h && $flds[y1][x1] == c0\n        q << [x1, y1]\n      end\n    end\n  end\n\n  q\nend\n\ndef count_rec(k)\n  c0 = $flds[0][0]\n\n  if k >= MAX_K\n    return if c0 == $c\n\n    changed = paint($c)\n    ar = count_area()\n    $max_ar = ar if $max_ar < ar\n    changed.each{|x, y| $flds[y][x] = c0}\n    return\n  end\n\n  for c1 in (1..6)\n    next if c0 == c1\n\n    changed = paint(c1)\n    count_rec(k + 1)\n    changed.each{|x, y| $flds[y][x] = c0}\n  end\nend\n\n### main\n\nloop do\n  $h, $w, $c = gets.split.map(&:to_i)\n  break if ($h | $w | $c) == 0\n\n  $flds = $h.times.map{gets.split.map(&:to_i)}\n  #p $flds\n\n  $max_ar = 0\n  count_rec(1)\n\n  p $max_ar\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\nMAX_K = 5\nMAX_C = 6\n\n### subroutines\n\ndef count_area(flds)\n  return 0 if flds[0] != $c\n\n  used = $hw.times.map{false}\n\n  ar = 1\n  used[0] = true\n  q = [[0, 0]]\n\n  while ! q.empty?\n    x0, y0 = q.shift\n    DXYS.each do |dx, dy|\n      x1 = x0 + dx\n      y1 = y0 + dy\n      if x1 >= 0 && x1 < $w && y1 >= 0 && y1 < $h\n        id = y1 * $w + x1\n        if flds[id] == $c && ! used[id]\n          ar += 1\n          used[id] = true\n          q << [x1, y1]\n        end\n      end\n    end\n  end\n\n  ar\nend\n\ndef paint(c, flds)\n  c0 = flds[0]\n  return if c0 == c\n\n  flds[0] = c\n  q = [[0, 0]]\n\n  while ! q.empty?\n    x0, y0 = q.shift\n    DXYS.each do |dx, dy|\n      x1 = x0 + dx\n      y1 = y0 + dy\n      if x1 >= 0 && x1 < $w && y1 >= 0 && y1 < $h\n        id = y1 * $w + x1\n        if flds[id] == c0\n          flds[id] = c\n          q << [x1, y1]\n        end\n      end\n    end\n  end\nend\n\ndef count_rec(k, flds)\n  c0 = flds[0]\n\n  if k == 1\n    return if c0 == $c\n\n    paint($c, flds)\n    ar = count_area(flds)\n    $max_ar = ar if $max_ar < ar\n    return\n  end\n\n  for c1 in (1..MAX_C)\n    next if c0 == c1\n\n    flds0 = flds.clone\n    paint(c1, flds0)\n    count_rec(k - 1, flds0)\n  end\nend\n\n### main\n\nloop do\n  $h, $w, $c = gets.split.map(&:to_i)\n  break if ($h | $w | $c) == 0\n\n  $hw = $h * $w\n\n  flds = []\n  $h.times.each{flds += gets.split.map(&:to_i)}\n  #p $flds\n\n  $max_ar = 0\n  count_rec(MAX_K, flds)\n\n  p $max_ar\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, q, h, w, col, visited)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n        end\n    end\n    f[sy][sx] = col\n    while q.size > 0\n        cy, cx = q.shift\n        f = bfs(f,cy,cx,q,h,w,col,visited)\n    end\n    return f\nend\ndef count(f, sy, sx, q, h, w, visited)\n    c = 0\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n            c += 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        c += count(f,cy,cx,q,h,w,visited)\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,[],h,w,[]) == 1\n    o.select!{|od| od[4] == c}\n    max = 1\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,[],h,w,col,[])\n        end\n        max = count(pp,0,0,[],h,w,[]) if count(pp,0,0,[],h,w,[]) > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, q, h, w, col, visited)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n        end\n    end\n    f[sy][sx] = col\n    while q.size > 0\n        cy, cx = q.shift\n        f = bfs(f,cy,cx,q,h,w,col,visited)\n    end\n    return f\nend\ndef count(f, sy, sx, q, h, w, visited)\n    c = 0\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n            c += 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        c += count(f,cy,cx,q,h,w,visited)\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,[],h,w,[]) == 1\n    o.select!{|od| od[4] == c}\n    max = 1\n    next\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,[],h,w,col,[])\n        end\n        max = count(pp,0,0,[],h,w,[]) if count(pp,0,0,[],h,w,[]) > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, h, w, col)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n            end\n        end\n        f[sy][sx] = col\n    end\n    return f\nend\ndef count(f, sy, sx, h, w)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    c = 1\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n                c += 1\n            end\n        end\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,h,w) == 1\n    o.select!{|od| od[0] != od[1] && od[1] != od[2] && od[2] != od[3] && od[3] != od[4]}\n    o.select!{|od| od[4] == c}\n    p o.size\n    max = 0\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,h,w,col)\n        end\n        cnt = count(pp,0,0,h,w)\n        max = cnt if cnt > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\ndef f(a, c, n, prev_group_size = 0)\n    g = group(a, 0, 0)\n    return g.size if n == 0\n\n    return g.size if g.size <= prev_group_size\n\n    max = 0\n    (n == 1 ? [c] : (1..6).to_a - [a[0][0]]).each do |k|\n        b = (0..a.size-1).map do |i|\n            (0..a[0].size-1).map do |j|\n                g.include?([i, j]) ? k : a[i][j]\n            end\n        end\n        m = f(b, c, n-1, g.size)\n        max = m if m > max\n    end\n    max\nend\n\ndef group(a, i, j)\n    reached = Set[[i, j]]\n    stack = [[i, j]]\n    until stack.empty?\n        y, x = stack.pop\n        [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |dy, dx|\n            v, u = y + dy, x + dx\n            next if v < 0 || v >= a.size || u < 0 || u >= a[0].size\n            next if a[v][u] != a[i][j]\n            pos = [v, u]\n            next if reached.include?(pos)\n            reached << pos\n            stack << pos\n        end\n    end\n    reached\nend\n\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0\n    a = (1..h).map { gets.split.map(&:to_i) }\n    p f(a, c, 5)\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, q, h, w, col, visited)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n        end\n    end\n    f[sy][sx] = col\n    while q.size > 0\n        cy, cx = q.shift\n        f = bfs(f,cy,cx,q,h,w,col,visited)\n    end\n    return f\nend\ndef count(f, sy, sx, q, h, w, visited)\n    c = 0\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n            c += 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        c += count(f,cy,cx,q,h,w,visited)\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,[],h,w,[]) == 1\n    o.select!{|od| od[4] == c}\n    max = 1\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,[],h,w,col,[])\n        end\n        next\n        max = count(pp,0,0,[],h,w,[]) if count(pp,0,0,[],h,w,[]) > max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, q, h, w, col, visited)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n        end\n    end\n    f[sy][sx] = col\n    while q.size > 0\n        cy, cx = q.shift\n        f = bfs(f,cy,cx,q,h,w,col,visited)\n    end\n    return f\nend\ndef count(f, sy, sx, q, h, w, visited)\n    c = 0\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx]== f[sy][sx] && !visited.include?([cy,cx])\n            q.push([cy,cx])\n            visited.push([cy,cx])\n            c += 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        c += count(f,cy,cx,q,h,w,visited)\n    end\n    return c\nend\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0 && w == 0 && c == 0\n    p = h.times.map{gets.split.map(&:to_i)}\n    o = (1..6).to_a.repeated_permutation(5).to_a\n    o.select!{|od| od[0] == p[0][1] || od[0] == p[1][0]} if h > 1 && w > 1 && count(p,0,0,[],h,w,[]) == 1\n    o.select!{|od| od[4] == c}\n    max = 1\n    o.each_with_index do |od, i|\n        pp = Marshal.load(Marshal.dump(p))\n        od.each do |col|\n            pp = bfs(pp,0,0,[],h,w,col,[])\n        end\n        max = [max, count(pp,0,0,[],h,w,[])].max\n    end\n    puts max\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\ndef f(a, c, n)\n    g = group(a, 0, 0)\n    return g.size if n == 0\n\n    max = 0\n    (n == 1 ? [c] : (1..6).to_a - [a[0][0]]).each do |k|\n        b = (0..a.size-1).map do |i|\n            (0..a[0].size-1).map do |j|\n                g.include?([i, j]) ? k : a[i][j]\n            end\n        end\n        m = f(b, c, n-1)\n        max = m if m > max\n    end\n    max\nend\n\ndef group(a, i, j)\n    reached = Set[[i, j]]\n    stack = [[i, j]]\n    until stack.empty?\n        y, x = stack.pop\n        [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |dy, dx|\n            v, u = y + dy, x + dx\n            next if v < 0 || v >= a.size || u < 0 || u >= a[0].size\n            next if a[v][u] != a[i][j]\n            pos = [v, u]\n            next if reached.include?(pos)\n            reached << pos\n            stack << pos\n        end\n    end\n    reached\nend\n\nloop do\n    h, w, c = gets.split.map(&:to_i)\n    break if h == 0\n    a = (1..h).map { gets.split.map(&:to_i) }\n    p f(a, c, 5)\nend"
  },
  {
    "language": "PHP",
    "code": "<?php\n  /*\n    AOJ 1174\n    title:Identically Colored Panels Connection\n    @kankichi573\n   */\nfunction paint($h,$w,$y,$x,&$p,$org,$c)\n{\n  if($org==$c)\n    return;\n \n  if($p[$y][$x]!=$org)\n    return;\n  $p[$y][$x]=$c;\n  if($x>0)\n    paint($h,$w,$y,$x-1,$p,$org,$c);\n  if($x<$w-1)\n    paint($h,$w,$y,$x+1,$p,$org,$c);\n  if($y>0)\n    paint($h,$w,$y-1,$x,$p,$org,$c);\n  if($y<$h-1)\n    paint($h,$w,$y+1,$x,$p,$org,$c);\n  \n}\n\nfunction count_($h,$w,$p,$c)\n{\n $r=array();\n $r=$p;\n $newcolor=$c+10;\n paint($h,$w,0,0,$r,$c,$newcolor);\n $cnt=0;\n for($i=0;$i<$h;$i++)\n   for($j=0;$j<$w;$j++)\n     $cnt+=($r[$i][$j]==$newcolor)?1:0;\n return($cnt);\n}\nfunction dump($h,$w,$q)\n{\n    for($i=0;$i<$h;$i++)\n      {\n\tfor($j=0;$j<$w;$j++)\n\t  fprintf(STDOUT,\"%d \",$q[$i][$j]);\n\tfprintf(STDOUT,\"\\n\");\n      }\n    fprintf(STDOUT,\"---------\\n\");\n}\n\nfunction solve($h,$w,$p,$c,$turn)\n{\n  $q=array();\n  if($turn==1)\n    {\n      $q=$p;\n      $org=$q[0][0];\n      paint($h,$w,0,0,$q,$org,$c);\n      $ret=count_($h,$w,$q,$c);\n      return($ret);\n    }\n\n  $max=0;\n   \n  for($color=1;$color<=6;$color++)\n    {\n      if($color==$p[0][0])\n\tcontinue;\n      $q=$p;\n      $org=$q[0][0];\n      paint($h,$w,0,0,$q,$org,$color);\n      $ret=solve($h,$w,$q,$c,$turn-1);\n      $max=max($max,$ret);\n    }\n  return($max);\n}\n\n//MAIN\n$p=array();\nwhile(fscanf(STDIN,\"%d %d %d\",$h,$w,$c)&&($h||$w||$c))\n  {\n    for($i=0;$i<$h;$i++)\n      {\n\t$buf=fgets(STDIN);\n\t$p[$i][0]=strtok($buf,\" \\n\\t\");\n\tfor($j=1;$j<$w;$j++)\t\n\t  $p[$i][$j]=strtok(\" \\n\\t\");\n      }\n    $ret=solve($h,$w,$p,$c,5);\n    fprintf(STDOUT,\"%d\\n\",$ret);\n  }\nreturn(0);\n?>"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=5):\n        # print(ope)\n        if ope[0] == board[0][0] or ope[-1] != C - 1 or any(ope[i] == ope[i + 1] for i in range(4)):\n            continue\n        ps = [(0, 0)]\n        tmp_board = copy.deepcopy(board)\n        for color in ope:\n            now_c = tmp_board[0][0]\n            if now_c == color:\n                continue\n\n            for r, c in ps:\n                tmp_board[r][c] = color\n            stack = ps[:]\n            while stack:\n                r, c = stack.pop()\n                for dr, dc in drc:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n                        tmp_board[nr][nc] = color\n                        stack.append((nr, nc))\n                        ps.append((nr, nc))\n        for r, c in ps:\n            tmp_board[r][c] = -1\n        stack = ps[:]\n        while stack:\n            r, c = stack.pop()\n            for dr, dc in drc:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == C - 1:\n                    tmp_board[nr][nc] = -1\n                    stack.append((nr, nc))\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\ndef dfs(x,y,s,c):\n    global tmpp\n    if not(0<=x<W and 0<=y<H):\n        return\n    elif tmpp[y][x] != s:\n        return\n    else:\n        tmpp[y][x] = c\n        dfs(x+1,y,s,c)\n        dfs(x-1,y,s,c)\n        dfs(x,y+1,s,c)\n        dfs(x,y-1,s,c)\n\ndef calc(x,y):\n    global tmpp\n    if not(0<=x<W and 0<=y<H):\n        return 0\n    elif tmpp[y][x] != C:\n        return 0\n    else:\n        tmpp[y][x] = -1\n        return calc(x+1,y) + calc(x-1,y) + calc(x,y+1) + calc(x,y-1) + 1\n\n\n\nwhile True:\n    H,W,C = inpl()\n    if H == 0:\n        break\n    pp = [inpl() for _ in range(H)]\n    ans = 0\n\n    for arg in itertools.product(range(1,7),repeat=4):\n        colors = list(arg) + [C]\n        tmpp = [p[:] for p in pp]\n        for c in colors:\n            if tmpp[0][0] == c:\n                continue\n            else:\n                dfs(0,0,tmpp[0][0],c)\n\n        ans = max(calc(0,0),ans)\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#2005_c\n\"\"\"\nn = int(input())\nk = list(\"mcxi\")\nfor i in range(n):\n    d = {\"m\":0,\"c\":0,\"x\":0,\"i\":0}\n    a,b  = input().split()\n    a = list(a)\n    b = list(b)\n    a.insert(0,1)\n    b.insert(0,1)\n    for j in range(1,len(a)):\n        if a[j] in k:\n            if a[j-1] in k:\n                d[a[j]] += 1\n            else:\n                d[a[j]] += int(a[j-1])\n    for j in range(1,len(b))[::-1]:\n        if b[j] in k:\n            if b[j-1] in k:\n                d[b[j]] += 1\n            else:\n                d[b[j]] += int(b[j-1])\n            if d[b[j]] >= 10:\n                l = b[j]\n                while d[l] >= 10:\n                    d[l] -= 10\n                    l = k[k.index(l)-1]\n                    d[l] += 1\n    for j in k:\n        if d[j]:\n            if d[j] == 1:\n                print(j,end = \"\")\n            else:\n                print(str(d[j])+j,end = \"\")\n    print()\n\"\"\"\n\n#2017_c\n\"\"\"\nwhile 1:\n    h, w = map(int, input().split())\n    if h == w == 0:\n        break\n    s = [list(map(int, input().split())) for i in range(h)]\n\n    ans = 0\n    for u in range(h):\n        for d in range(u+2,h):\n            for l in range(w):\n                for r in range(l+2,w):\n                    m = float(\"inf\")\n                    for i in range(u,d+1):\n                        m = min(m,s[i][l],s[i][r])\n                    for i in range(l,r+1):\n                        m = min(m,s[u][i],s[d][i])\n                    f = 1\n                    su = 0\n                    for i in range(u+1,d):\n                        for j in range(l+1,r):\n                            su += (m-s[i][j])\n                            if s[i][j] >= m:\n                                f = 0\n                                break\n                        if not f:\n                            break\n                    if f:\n                        ans = max(ans,su)\n    print(ans)\n\"\"\"\n\n#2016_c\n\"\"\"\nwhile 1:\n    m,n = map(int, input().split())\n    if m == n == 0:\n        break\n    ma = 7368791\n    d = [0]*(ma+1)\n    z = m\n    for i in range(n):\n        while d[z]:\n            z += 1\n        j = z\n        while j <= ma:\n            d[j] = 1\n            j += z\n    for j in range(z,ma+1):\n        if not d[j]:\n            print(j)\n            break\n\"\"\"\n\n#2018_c\n\"\"\"\ndef factorize(n):\n    if n < 4:\n        return [1,n]\n    i = 2\n    l = [1]\n    while i**2 <= n:\n        if n%i == 0:\n            l.append(i)\n            if n//i != i:\n                l.append(n//i)\n        i += 1\n    l.append(n)\n    l.sort()\n    return l\nwhile 1:\n    b = int(input())\n    if b == 0:\n        break\n    f = factorize(2*b)\n    for n in f[::-1]:\n        a = 1-n+(2*b)//n\n        if a >= 1 and a%2 == 0:\n            print(a//2,n)\n            break\n\"\"\"\n\n#2010_c\n\"\"\"\nimport sys\ndp = [100]*1000000\ndp_2 = [100]*1000000\ndp[0] = 0\ndp_2[0] = 0\nfor i in range(1,181):\n    s = i*(i+1)*(i+2)//6\n    for j in range(s,1000000):\n        if dp[j-s]+1 < dp[j]:\n            dp[j] = dp[j-s]+1\n    if s%2:\n        for j in range(s,1000000):\n            if dp_2[j-s]+1 < dp_2[j]:\n                dp_2[j] = dp_2[j-s]+1\nwhile 1:\n    m = int(sys.stdin.readline())\n    if m == 0:\n        break\n    print(dp[m],dp_2[m])\n\"\"\"\n\n#2015_c\n\"\"\"\nfrom collections import deque\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    s = [input() for i in range(n)]\n    d = [s[i].count(\".\") for i in range(n)]\n    m = max(d)\n    c = [s[i][-1] for i in range(n)]\n    q = deque()\n    for i in range(1,m+1)[::-1]:\n        j = 0\n        while j < n:\n            for k in range(j,n):\n                if d[k] == i:break\n            else:\n                break\n            j = k\n            op = c[j-1]\n            while j < n and d[j] == i:\n                q.append(j)\n                j += 1\n            j = k\n            if op == \"+\":\n                k = 0\n                while q:\n                    x = q.pop()\n                    k += int(c[x])\n                    c.pop(x)\n                    d.pop(x)\n                    n -= 1\n            else:\n                k = 1\n                while q:\n                    x = q.pop()\n                    k *= int(c[x])\n                    c.pop(x)\n                    d.pop(x)\n                    n -= 1\n            c[j-1] = k\n    print(c[0])\n\"\"\"\n\n#2013_c\n\"\"\"\nfrom collections import defaultdict\n\ndef parse_expr(s,i):\n    i += 1\n    if s[i] == \"[\":\n        q = []\n        while s[i] != \"]\":\n            e,i = parse_expr(s,i)\n            q.append(e)\n        return (calc(q),i+1)\n    else:\n        n,i = parse_num(s,i)\n        return (calc([n]),i+1)\n\ndef parse_num(s,i):\n    m = int(s[i])\n    i += 1\n    while f_num[s[i]]:\n        m *= 10\n        m += int(s[i])\n        i += 1\n    return (m,i)\n\ndef calc(q):\n    if len(q) == 1:\n        return (q[0]+1)//2\n    q.sort()\n    return sum(q[:len(q)//2+1])\n\nf_num = defaultdict(lambda : 0)\nfor i in range(10):\n    f_num[str(i)] = 1\n\nn = int(input())\nfor i in range(n):\n    s = input()\n    print(parse_expr(s,0)[0])\n\"\"\"\n\n#2003_C\n\"\"\"\nwhile 1:\n    w,h = LI()\n    if w == h == 0:\n        break\n    s = SR(h)\n    dp = [[0]*w for i in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if s[y][x].isdecimal():\n                dp[y][x] = max(dp[y-1][x],dp[y][x-1])*10+int(s[y][x])\n    ans = 0\n    for i in dp:\n        ans = max(ans,max(i))\n    print(ans)\n\"\"\"\n#2008_C\n\"\"\"def parse_formula(s,i):\n    if s[i] == \"-\":\n        i += 1\n        e,i = parse_formula(s,i)\n        return 2-e,i\n    elif s[i] == \"(\":\n        i += 1\n        e1,i = parse_formula(s,i)\n        op = s[i]\n        i += 1\n        e2,i = parse_formula(s,i)\n        i += 1\n        return calc(op,e1,e2),i\n    else:\n        return int(s[i]),i+1\n\ndef calc(op,a,b):\n    if op == \"*\":\n        return min(a,b)\n    else:\n        return max(a,b)\n\nwhile 1:\n    s = S()\n    if s[0] == \".\":\n        break\n    t = []\n    f = defaultdict(int)\n    for p in range(3):\n        f[\"P\"] = p\n        for q in range(3):\n            f[\"Q\"] = q\n            for r in range(3):\n                f[\"R\"] = r\n                t.append([f[s[i]] if s[i] in \"PQR\" else s[i] for i in range(len(s))])\n    ans = 0\n    for s in t:\n        if parse_formula(s,0)[0] == 2:\n            ans += 1\n    print(ans)\n\"\"\"\n#2011_C\nd = [(1,0),(-1,0),(0,1),(0,-1)]\ndef dfs(dep,s):\n    global ans\n    if dep == 5:\n        b = bfs(s)\n        m = 0\n        for i in b:\n            m += sum(i)\n        ans = max(ans, m)\n    else:\n        if dep < 4:\n            for i in range(6):\n                b = bfs(s)\n                dfs(dep+1,[[i+1 if b[y][x] else s[y][x] for x in range(w)] for y in range(h)])\n        else:\n            b = bfs(s)\n            dfs(dep+1,[[c if b[y][x] else s[y][x] for x in range(w)] for y in range(h)])\n\ndef bfs(s):\n    b = [[0]*w for i in range(h)]\n    b[0][0] = 1\n    q = deque([(0,0)])\n    while q:\n        y,x = q.popleft()\n        for dy,dx in d:\n            y_ = y+dy\n            x_ = x+dx\n            if 0 <= y_ < h and 0 <= x_ < w:\n                if not b[y_][x_] and s[y_][x_] == s[0][0]:\n                    b[y_][x_] = 1\n                    q.append((y_,x_))\n    return b\n\nwhile 1:\n    h,w,c = LI()\n    if h == 0:\n        break\n    s = LIR(h)\n    ans = 0\n    dfs(0,s)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n\n    while True:\n        h,w,c = LI()\n        if h == 0:\n            break\n        a = [LI() for _ in range(h)]\n        mc = max(map(max,a))\n        d = collections.defaultdict(int)\n        for i in range(h):\n            for j in range(w):\n                d[(i,j)] = a[i][j]\n\n        def f(c,s):\n            ff = True\n            ts = s\n            while ff:\n                r = set()\n                ff = False\n                for i,j in ts:\n                    for di,dj in dd:\n                        ni = i + di\n                        nj = j + dj\n                        if d[(ni,nj)] == c and not (ni,nj) in ts:\n                            ff = True\n                            r.add((ni,nj))\n                ts = ts | r\n            return ts\n\n        r = 0\n        s = f(a[0][0], set([(0,0)]))\n        for ca in itertools.product(range(1,mc+1), repeat=4):\n            ts = s\n            for nc in ca:\n                ts = f(nc, ts)\n            ts = f(c, ts)\n            if r < len(ts):\n                r = len(ts)\n        rr.append(r)\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys,copy,itertools as it\nsys.setrecursionlimit(10000)\n\ndxy = zip([1,0,-1,0],[0,1,0,-1])\ndef check(A):\n    if A[0] == _P[0][0] or A[-1] != c: return False\n    for i in xrange(1,len(A)):\n        if A[i-1] == A[i]: return False\n    return True\n    \ndef rec(x,y,b,c):\n    P[y][x] = c\n    for dx,dy in dxy:\n        nx,ny = x+dx,y+dy\n        if 0 <= nx < w and 0 <= ny < h and P[ny][nx] == b:\n            rec(nx,ny,b,c)\n    \nwhile 1:\n    h,w,c = map(int,raw_input().split())\n    if h == 0: break\n    _P = [map(int,raw_input().split()) for i in xrange(h)]\n\n    ans = 0\n    for change in it.product(range(1,7),repeat = 5):\n        if not check(change): continue\n        P = copy.deepcopy(_P)\n        for c in change: rec(0,0,P[0][0],c)\n        rec(0,0,P[0][0],0)\n        ans = max(ans, sum(p.count(0) for p in P))\n\n    print ans\n    "
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=5):\n        # print(ope)\n        if ope[0] == board[0][0] or ope[-1] != C - 1 or any(ope[i] == ope[i + 1] for i in range(4)):\n            continue\n        ps = [(0, 0)]\n        tmp_board = copy.deepcopy(board)\n        for color in ope:\n            now_c = tmp_board[0][0]\n            if now_c == color:\n                continue\n\n            for r, c in ps:\n                tmp_board[r][c] = color\n            stack = ps[:]\n            while stack:\n                r, c = stack.pop()\n                for dr, dc in drc:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n                        tmp_board[nr][nc] = color\n                        stack.append((nr, nc))\n                        ps.append((nr, nc))\n        for r, c in ps:\n            tmp_board[r][c] = -1\n        stack = ps[:]\n        while stack:\n            r, c = stack.pop()\n            for dr, dc in drc:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == C - 1:\n                    tmp_board[nr][nc] = -1\n                    stack.append((nr, nc))\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        # print(ope)\n        ps = [(0, 0)]\n        tmp_board = copy.deepcopy(board)\n        for color in itertools.chain(ope, (C - 1,)):\n            now_c = tmp_board[0][0]\n            if now_c == color:\n                continue\n\n            for r, c in ps:\n                tmp_board[r][c] = color\n            stack = ps[:]\n            while stack:\n                r, c = stack.pop()\n                for dr, dc in drc:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n                        tmp_board[nr][nc] = color\n                        stack.append((nr, nc))\n                        ps.append((nr, nc))\n        for r, c in ps:\n            tmp_board[r][c] = -1\n        stack = ps[:]\n        while stack:\n            r, c = stack.pop()\n            for dr, dc in drc:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == C - 1:\n                    tmp_board[nr][nc] = -1\n                    stack.append((nr, nc))\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\ndef dfs(r, c, now_c, next_c):\n    tmp_board[r][c] = next_c\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n            dfs(nr, nc, now_c, next_c)\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        # print(ope)\n        if ope[0] == board[0][0] or ope[-1] == C - 1 or any(ope[i] == ope[i + 1] for i in range(3)):\n            continue\n        tmp_board = copy.deepcopy(board)\n        for color in itertools.chain(ope, (C - 1, )):\n            dfs(0, 0, tmp_board[0][0], color)\n        dfs(0, 0, tmp_board[0][0], -1)\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\n\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        # print(ope)\n        tmp_board = copy.deepcopy(board)\n        for color in itertools.chain(ope, (C - 1,)):\n            now_c = tmp_board[0][0]\n            if now_c == color:\n                continue\n            stack = [(0, 0)]\n            while stack:\n                r, c = stack.pop()\n                if tmp_board[r][c] == color:\n                    continue\n                tmp_board[r][c] = color\n                for dr, dc in drc:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n                        stack.append((nr, nc))\n        stack = [(0, 0)]\n        while stack:\n            r, c = stack.pop()\n            if tmp_board[r][c] == -1:\n                continue\n            tmp_board[r][c] = -1\n            for dr, dc in drc:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == C - 1:\n                    stack.append((nr, nc))\n        ans = max(ans, sum(row.count(-1) for row in tmp_board))\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "direct = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\ndef comb(color, mp, pos):\n  end = len(pos)\n  ind = 0\n  while ind < end:\n    x, y = pos[ind]\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) not in pos and mp[ny][nx] == color:\n        pos.append((nx, ny))\n        end += 1\n    ind += 1\n\ndef search(rest, now_color, goal_color, pos, mp):\n  if rest == 0:\n    return len(pos)\n  if rest == 1:\n    if now_color != goal_color:\n      next_pos = pos[:]\n      comb(goal_color, mp, next_pos)\n      return len(next_pos)\n    else:\n      return 0\n\n  ret = 0\n  for next_color in range(1, 7):\n    if next_color != now_color:\n      next_pos = pos[:]\n      comb(next_color, mp, next_pos)\n      ret = max(ret, search(rest - 1, next_color, goal_color, next_pos, mp))\n  return ret\n\ndef main():\n  while True:\n    h, w, c = map(int, input().split())\n    if h == 0:\n      break\n    mp = [[-1] + list(map(int, input().split())) + [-1] for _ in range(h)]\n    mp.insert(0, [-1] * (w + 2))\n    mp.append([-1] * (w + 2))\n    init_pos = [(1, 1)]\n    init_color = mp[1][1]\n    comb(init_color, mp, init_pos)\n    print(search(5, init_color, c, init_pos, mp))\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\ndef dfs(r, c, now_c, next_c):\n    tmp_board[r][c] = next_c\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n            dfs(nr, nc, now_c, next_c)\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=5):\n        # print(ope)\n        if ope[0] == board[0][0] or ope[-1] != C - 1 or any(ope[i] == ope[i + 1] for i in range(4)):\n            continue\n        tmp_board = copy.deepcopy(board)\n        for color in ope:\n            dfs(0, 0, tmp_board[0][0], color)\n        dfs(0, 0, tmp_board[0][0], -1)\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        # print(ope)\n        ps = [(0, 0)]\n        tmp_board = copy.deepcopy(board)\n        for color in itertools.chain(ope, (C - 1,)):\n            now_c = tmp_board[0][0]\n            if now_c == color:\n                continue\n\n            for r, c in ps:\n                tmp_board[r][c] = color\n            stack = ps[:]\n            while stack:\n                r, c = stack.pop()\n                for dr, dc in drc:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n                        tmp_board[nr][nc] = color\n                        stack.append((nr, nc))\n                        ps.append((nr, nc))\n        for r, c in ps:\n            tmp_board[r][c] = -1\n        stack = ps[:]\n        while stack:\n            r, c = stack.pop()\n            for dr, dc in drc:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == C - 1:\n                    tmp_board[nr][nc] = -1\n                    stack.append((nr, nc))\n        ans = max(ans, sum(row.count(-1) for row in tmp_board))\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\ndef dfs(r, c, now_c, next_c):\n    tmp_board[r][c] = next_c\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n            dfs(nr, nc, now_c, next_c)\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=5):\n        # print(ope)\n        if ope[0] == board[0][0] or ope[-1] != C - 1 or any(ope[i] == ope[i + 1] for i in range(4)):\n            continue\n        tmp_board = copy.deepcopy(board)\n        for color in ope:\n            dfs(0, 0, tmp_board[0][0], color)\n        dfs(0, 0, tmp_board[0][0], -1)\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\n\ndef dfs(r, c, now_c, next_c):\n    tmp_board[r][c] = next_c\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n            dfs(nr, nc, now_c, next_c)\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        if ope[0] == board[0][0] or ope[-1] == C - 1 or any(ope[i] == ope[i + 1] for i in range(3)):\n            continue\n        tmp_board = copy.deepcopy(board)\n        for color in ope:\n            dfs(0, 0, tmp_board[0][0], color)\n        dfs(0, 0, tmp_board[0][0], C - 1)\n        dfs(0, 0, tmp_board[0][0], -1)\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "direct = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\ndef comb(color, mp, pos):\n  next_pos = pos[:]\n  end = len(next_pos)\n  ind = 0\n  while ind < end:\n    x, y = next_pos[ind]\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) not in next_pos and mp[ny][nx] == color:\n        next_pos.append((nx, ny))\n        end += 1\n    ind += 1\n  return next_pos\n\ndef search(rest, now_color, goal_color, pos, mp):\n  if rest == 1:\n    if now_color != goal_color:\n      next_pos = comb(goal_color, mp, pos)\n      return len(next_pos)\n    return 0\n\n  ret = 0\n  for next_color in range(1, 7):\n    if next_color != now_color:\n      next_pos = comb(next_color, mp, pos)\n      ret = max(ret, search(rest - 1, next_color, goal_color, next_pos, mp))\n  return ret\n\ndef main():\n  while True:\n    h, w, c = map(int, input().split())\n    if h == 0:\n      break\n    mp = [[-1] + list(map(int, input().split())) + [-1] for _ in range(h)]\n    mp.insert(0, [-1] * (w + 2))\n    mp.append([-1] * (w + 2))\n    init_pos = [(1, 1)]\n    init_color = mp[1][1]\n    init_pos = comb(init_color, mp, init_pos)\n    print(search(5, init_color, c, init_pos, mp))\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\ndef dfs(r, c, now_c, next_c):\n    tmp_board[r][c] = next_c\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n            dfs(nr, nc, now_c, next_c)\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        # print(ope)\n        if ope[0] == board[0][0] or ope[-1] == C - 1 or any(ope[i] == ope[i + 1] for i in range(3)):\n            continue\n        tmp_board = copy.deepcopy(board)\n        for color in itertools.chain(ope, (C - 1, )):\n            dfs(0, 0, tmp_board[0][0], color)\n        dfs(0, 0, tmp_board[0][0], -1)\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\ndx=[0,0,1,-1]\ndy=[1,-1,0,0]\n\ndef dfs(y,x,color,precolor):\n    if color==precolor:\n        return\n    P[y][x]=color\n    for i in range(4):\n        mx=x+dx[i]\n        my=y+dy[i]\n        if 0<=mx<w and 0<=my<h and P[my][mx]==precolor:\n            dfs(my,mx,color,precolor)\n\ndef panelnum(y,x,color):\n    global cnt\n    if P[y][x]==color:\n        P[y][x]=\"B\"\n        cnt+=1\n    else:\n        return cnt\n    for i in range(4):\n        mx=x+dx[i]\n        my=y+dy[i]\n        if 0<=mx<w and 0<=my<h and P[my][mx]==color:\n            panelnum(my,mx,color)\n    return cnt\n\nwhile True:\n    h,w,c=map(int,raw_input().split())\n    if h==w==c==0:break\n    Panel=[map(int,raw_input().split()) for i in range(h)]\n    maxInt=0\n    for i in range(1,7):\n        for j in range(1,7):\n            for k in range(1,7):\n                for l in range(1,7):\n                    cnt=0\n                    P=deepcopy(Panel)\n                    dfs(0,0,i,P[0][0])\n                    dfs(0,0,j,P[0][0])\n                    dfs(0,0,k,P[0][0])\n                    dfs(0,0,l,P[0][0])\n                    dfs(0,0,c,P[0][0])\n                    s=panelnum(0,0,c)\n                    maxInt=max(maxInt,s)\n    print maxInt"
  },
  {
    "language": "Python",
    "code": "import copy\nimport heapq\n\nvec=[(0,1),(0,-1),(1,0),(-1,0)]\n\ndef printField(field):\n  for i in xrange(len(field)):\n    print \"\".join(map(str,field[i]))\n\ndef counter(field):\n  c=field[0][0]\n  field[0][0]=0\n  q=[]\n  count=1\n  heapq.heappush(q,(0,0))\n  while q:\n    x,y=heapq.heappop(q)\n    for dx,dy in vec:\n      if x+dx<0 or len(field)<=x+dx or y+dy<0 or len(field[0])<=y+dy: continue\n      if field[x+dx][y+dy]==c:\n        count+=1\n        field[x+dx][y+dy]=0\n        heapq.heappush(q,(x+dx,y+dy))\n  return count\n\ndef changeColor(c, field):\n  newField=copy.deepcopy(field)\n  newField[0][0]=c\n  q=[]\n  changed={}\n  heapq.heappush(q,(0,0))\n  changed[(0,0)]=True\n  while q:\n    x,y=heapq.heappop(q)\n    for dx,dy in vec:\n      if x+dx<0 or len(field)<=x+dx or y+dy<0 or len(field[0])<=y+dy: continue\n      if newField[x+dx][y+dy]==field[0][0]:\n        if (x+dx,y+dy) not in changed:\n          newField[x+dx][y+dy]=c\n          changed[(x+dx,y+dy)]=True\n          heapq.heappush(q,(x+dx,y+dy))\n  return newField\n\ndef electro(count, field, last):\n  if count==4:\n    newField=changeColor(last, field)\n    return counter(newField)\n  maxSize=0\n  for i in xrange(1,7):\n    newField=changeColor(i, field)\n    maxSize=max(maxSize, electro(count+1,newField,last))\n  return maxSize\n\nwhile True:\n  h,w,c=map(int,raw_input().split())\n  if h==0: break\n  field=[]\n  for i in xrange(h):\n    field.append(map(int,raw_input().split()))\n  print electro(0,field,c)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        # print(ope)\n        ps = [(0, 0)]\n        tmp_board = copy.deepcopy(board)\n        for color in itertools.chain(ope, (C - 1,)):\n            now_c = tmp_board[0][0]\n            if now_c == color:\n                continue\n\n            for r, c in ps:\n                tmp_board[r][c] = color\n            stack = ps[:]\n            while stack:\n                r, c = stack.pop()\n                for dr, dc in drc:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n                        tmp_board[nr][nc] = color\n                        stack.append((nr, nc))\n        for r, c in ps:\n            tmp_board[r][c] = -1\n        stack = ps[:]\n        while stack:\n            r, c = stack.pop()\n            for dr, dc in drc:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == C - 1:\n                    tmp_board[nr][nc] = -1\n                    stack.append((nr, nc))\n        ans = max(ans, sum(row.count(-1) for row in tmp_board))\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        # print(ope)\n        tmp_board = copy.deepcopy(board)\n        for color in itertools.chain(ope, (C - 1,)):\n            now_c = tmp_board[0][0]\n            if now_c == color:\n                continue\n            stack = [(0, 0)]\n            while stack:\n                r, c = stack.pop()\n                if tmp_board[r][c] == color:\n                    continue\n                tmp_board[r][c] = color\n                for dr, dc in drc:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n                        stack.append((nr, nc))\n        stack = [(0, 0)]\n        while stack:\n            r, c = stack.pop()\n            if tmp_board[r][c] == -1:\n                continue\n            tmp_board[r][c] = -1\n            for dr, dc in drc:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == C - 1:\n                    stack.append((nr, nc))\n        ans = max(ans, sum(row.count(-1) for row in tmp_board))\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\np_copy = []\n\n\ndef change(y):\n    global p_copy\n    x = p_copy[0][0]\n    que = deque()\n    que.append((0, 0))\n    memo = {(0, 0): 1}\n    while len(que) > 0:\n        i, j = que.popleft()\n        p_copy[i][j] = y\n        if i + 1 < h and p_copy[i + 1][j] == x and (i + 1, j) not in memo:\n            que.append((i + 1, j))\n            memo[(i + 1, j)] = 1\n        if j + 1 < w and p_copy[i][j + 1] == x and (i, j + 1) not in memo:\n            que.append((i, j + 1))\n            memo[(i, j + 1)] = 1\n        if i - 1 >= 0 and p_copy[i - 1][j] == x and (i - 1, j) not in memo:\n            que.append((i - 1, j))\n            memo[(i - 1, j)] = 1\n        if j - 1 >= 0 and p_copy[i][j - 1] == x and (i, j - 1) not in memo:\n            que.append((i, j - 1))\n            memo[(i, j - 1)] = 1\n\n\ndef count():\n    global p_copy\n    res = 0\n    que = deque()\n    if p_copy[0][0] == c:\n        que.append((0, 0))\n    memo = {(0, 0): 1}\n    while len(que) > 0:\n        i, j = que.popleft()\n        res += 1\n        if i + 1 < h and p_copy[i + 1][j] == c and (i + 1, j) not in memo:\n            que.append((i + 1, j))\n            memo[(i + 1, j)] = 1\n        if j + 1 < w and p_copy[i][j + 1] == c and (i, j + 1) not in memo:\n            que.append((i, j + 1))\n            memo[(i, j + 1)] = 1\n        if i - 1 >= 0 and p_copy[i - 1][j] == c and (i - 1, j) not in memo:\n            que.append((i - 1, j))\n            memo[(i - 1, j)] = 1\n        if j - 1 >= 0 and p_copy[i][j - 1] == c and (i, j - 1) not in memo:\n            que.append((i, j - 1))\n            memo[(i, j - 1)] = 1\n    return res\n\n\n_max = 0\n\n\ndef solve(p, n, before):\n    global _max, p_copy\n    if n == 1:\n        change(c)\n        temp = count()\n        if temp > _max:\n            _max = temp\n        return\n    for k in range(1, 7):\n        if k == before:\n            continue\n        p_copy = [[j for j in i] for i in p]\n        change(k)\n        solve(p_copy, n - 1, k)\n\n\nwhile True:\n    h, w, c = map(int, input().split())\n    if h | w | c == 0:\n        break\n    p_list = [list(map(int, input().split()))for i in range(h)]\n    solve(p_list, 5, -1)\n    print(_max)\n    _max = 0\n"
  },
  {
    "language": "Python",
    "code": "direct = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\ndef comb(target_color, mp, pos):\n  next_pos = pos[:]\n  end = len(next_pos)\n  ind = 0\n  while ind < end:\n    x, y = next_pos[ind]\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if mp[ny][nx] == target_color and (nx, ny) not in next_pos:\n        next_pos.append((nx, ny))\n        end += 1\n    ind += 1\n  return next_pos\n\ndef search(rest, now_color, goal_color, pos, mp):\n  if rest == 1:\n    if now_color != goal_color:\n      next_pos = comb(goal_color, mp, pos)\n      return len(next_pos)\n    return 0\n\n  ret = 0\n  for next_color in range(1, 7):\n    if next_color != now_color:\n      next_pos = comb(next_color, mp, pos)\n      ret = max(ret, search(rest - 1, next_color, goal_color, next_pos, mp))\n  return ret\n\ndef main():\n  while True:\n    h, w, c = map(int, input().split())\n    if h == 0:\n      break\n    mp = [[-1] + list(map(int, input().split())) + [-1] for _ in range(h)]\n    mp.insert(0, [-1] * (w + 2))\n    mp.append([-1] * (w + 2))\n    init_pos = [(1, 1)]\n    init_color = mp[1][1]\n    init_pos = comb(init_color, mp, init_pos)\n    print(search(5, init_color, c, init_pos, mp))\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\n\n\ndef dfs(r, c, now_c, next_c):\n    tmp_board[r][c] = next_c\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n            dfs(nr, nc, now_c, next_c)\n\n\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        if ope[0] == board[0][0] or ope[-1] == C - 1 or any(ope[i] == ope[i + 1] for i in range(3)):\n            continue\n        tmp_board = copy.deepcopy(board)\n        for color in ope:\n            dfs(0, 0, tmp_board[0][0], color)\n        dfs(0, 0, tmp_board[0][0], C - 1)\n        dfs(0, 0, tmp_board[0][0], -1)\n        cand = sum(row.count(-1) for row in tmp_board)\n        if cand > ans:\n            ans = cand\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import copy\nimport itertools\nimport sys\n\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\ndrc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nC_NUM = 6\nwhile True:\n    H, W, C = map(int, input().split())\n    if not (H | W | C):\n        break\n    board = [[int(x) - 1 for x in input().split()] for _ in range(H)]\n    ans = 0\n    for ope in itertools.product(range(C_NUM), repeat=4):\n        # print(ope)\n        tmp_board = copy.deepcopy(board)\n        for color in itertools.chain(ope, (C - 1,)):\n            now_c = tmp_board[0][0]\n            if now_c == color:\n                continue\n\n            tmp_board[0][0] = color\n            stack = [(0, 0)]\n            while stack:\n                r, c = stack.pop()\n                for dr, dc in drc:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == now_c:\n                        tmp_board[nr][nc] = color\n                        stack.append((nr, nc))\n        tmp_board[0][0] = -1\n        stack = [(0, 0)]\n        while stack:\n            r, c = stack.pop()\n            for dr, dc in drc:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < H and 0 <= nc < W and tmp_board[nr][nc] == C - 1:\n                    tmp_board[nr][nc] = -1\n                    stack.append((nr, nc))\n        ans = max(ans, sum(row.count(-1) for row in tmp_board))\n    print(ans)"
  }
]