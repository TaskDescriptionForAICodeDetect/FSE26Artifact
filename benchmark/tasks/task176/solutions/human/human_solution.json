[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (a % b != 0 || b == 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (num != -1) {\n\t\t\t\t\tstack_num.push(num);\n\t\t\t\t\tnum = -1;\n\t\t\t\t\twhile (stack_op.top() == '*' || stack_op.top() == '/') {\n\t\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nvoid solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) flag &= eq.evaluate(s_map);\n\t\tif (flag) {\n\t\t\tputs(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\tputs(\"No\");\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (stack_op.top() == '*' || stack_op.top() == '/') {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) {\n\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t}\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tif (a != n) return false;\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) flag &= eq.evaluate(s_map);\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<bool, MAX_N> used;\narray<char, 128> letters;\narray<bool, 128> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint factor(string::const_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\tthrow \"parse error\";\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tint tmp;\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t++it;\n\t\t\ttmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_minus[expression[i - 1]] = true;\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_minus[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w, -1));\n\tint next = 0;\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\tif(idx[k][j] == -1) idx[k][j] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\tif(idx[i][k] == -1) idx[i][k] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used[i]) continue;\n\t\tif(is_operator[in[i]] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\t\tif(in[i] == '-' && not_minus[idx]) continue;\n\t\tif(i && !used[i - 1] && in[i] == in[i - 1]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[in[i]]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tused[i] = true;\n\t\tif(dfs(expressions, next, idx + 1)) return true;\n\t\tused[i] = false;\n\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tis_operator.fill(false);\n\tis_operator['+'] = true;\n\tis_operator['-'] = true;\n\tis_operator['*'] = true;\n\tis_operator['/'] = true;\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tused.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\t\tsort(in.begin(), in.begin() + n);\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tif (stack_op.empty()) return false;\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tif (stack_num.empty()) return false;\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tif (stack_num.empty()) return false;\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (a % b != 0 || b == 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (stack_op.top() == '*' || stack_op.top() == '/') {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) {\n\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t}\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tif (a != n) return false;\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) flag &= eq.evaluate(s_map);\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nconstexpr int tsurai=123456789;\n\nint parse_int(const std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i]-'0';\n  while (++i < s.length() && isdigit(s[i])) {\n    res = res*10 + s[i]-'0';\n  }\n  return res;\n}\n\nint fourt(const std::string &s, size_t &i) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length() && isdigit(s[i])) {\n    int cur=parse_int(s, i);\n    while (i < s.length() && s[i] != '=') {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (tmp == 0 || cur % tmp) return tsurai;\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n    if (sgn == '+') {\n      res += cur;\n    } else {\n      res -= cur;\n    }\n    if (i < s.length() && s[i] != '=') {\n      sgn = s[i++];\n    }\n  }\n  return res;\n}\n\nbool valid(const std::vector<std::string> &eqs, const std::vector<char> &cs) {\n  for (/* not const */ std::string eq: eqs) {\n    for (char &ch: eq)\n      if (ch >= 'A' && ch <= 'Z')\n        ch = cs[ch-'A'];\n\n    if (eq[0] == '=' || eq.back() == '=')\n      return false;\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] != '0') {\n        do {\n          ++i;\n        } while (i < eq.length() && isdigit(eq[i]));\n      } else {\n        if (i+1 < eq.length() && isdigit(eq[i+1]))\n          return false;\n      }\n    }\n\n    size_t i=0;\n    if (!isdigit(eq[i])) return false;\n    int lhs=fourt(eq, i);\n    if (lhs == tsurai) return false;\n    assert(eq[i] == '=');\n    ++i;\n    if (!isdigit(eq[i])) return false;\n    int rhs=fourt(eq, i);\n    if (rhs == tsurai) return false;\n    assert(i == eq.length());\n    \n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0)\n    return 1;\n\n  size_t ph='A';  // placeholder\n  std::vector<std::string> s(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] == '.')\n        s[i][j] = ph++;\n    }\n  }\n\n  std::vector<std::string> eqs;\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> cs(n);\n  for (size_t i=0; i<n; ++i)\n    scanf(\" %c\", &cs[i]);\n\n  std::sort(cs.begin(), cs.end());\n  do {\n    if (valid(eqs, cs))\n      return !printf(\"Yes\\n\");\n  } while (std::next_permutation(cs.begin(), cs.end()));\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <exception>\n#include <fstream>\nusing namespace std;\n\nconst int LIM = 10;\n\nint H, W, n;\nchar pz[12][12];\n\nvector<int> bx, by;\nbool used[LIM];\nvector<char> ch;\n\nclass Evaluator {\npublic:\n    static int num(string &s, int &k) {\n        int a = 0;\n        while (isdigit(s[k])) {\n            a = a * 10 + (s[k] - '0'); ++k;\n        }\n        return a;\n    }\n    static int mul(string &s, int &k) {\n        int a = num(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '*') a *= mul(s, ++k);\n            else if (s[k] == '/') {\n                int b = mul(s, ++k);\n                if (b == 0) throw 0; // DivisionByZero\n                else if (a % b != 0) throw 1; // LeavingRemaindar\n                a /= b;\n            }\n            else break;\n        }\n        return a;\n    }\n    static int add(string &s, int &k) {\n        int a = mul(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '+') a += mul(s, ++k);\n            else if (s[k] == '-') a -= mul(s, ++k);\n            else break;\n        }\n        return a;\n    }\n    static bool eq(string &s, int &k) {\n        int a = add(s, k);\n        if (k < (int)s.size() && s[k] == '=') {\n            int b = add(s, ++k);\n            if (k < (int)s.size()) return false;\n            return a == b;\n        }\n        return false;\n    }\n    static bool run(string s) {\n        int k; bool ret;\n        try {\n            ret = eq(s, k=0);\n        } catch (int) {\n            ret = false;\n        }\n        return ret;\n    }\n};\n\nbool issymbol(char c) {\n    return c=='+' || c=='-' || c=='*' || c=='/' || c=='=';\n}\n\nbool ok(int x, int y, char c) {\n    bool ver = true, hor = true;\n    if (pz[y-1][x] == '#' && pz[y+1][x] == '#') ver = false;\n    if (pz[y][x-1] == '#' && pz[y][x+1] == '#') hor = false;\n    if (issymbol(c)) {\n        if (pz[y-1][x] == '#' || pz[y+1][x] == '#' || issymbol(pz[y-1][x]) || issymbol(pz[y+1][x])) ver = false;\n        if (pz[y][x-1] == '#' || pz[y][x+1] == '#' || issymbol(pz[y][x-1]) || issymbol(pz[y][x+1])) hor = false;\n        if ( ! ver && ! hor) return false;\n    } else if (c == '0') {\n        if (pz[y-1][x] == '/' || pz[y][x-1] == '/' || isdigit(pz[y+1][x]) || isdigit(pz[y][x+1])) return false;\n    } else {\n        if (pz[y-1][x] == '0' || pz[y][x-1] == '0') return false;\n    }\n    int tx, ty; string s; bool blank;\n    if (ver) {\n        blank=false; s=c; ty=y-1;\n        while (pz[ty][x] != '#') {\n            s=pz[ty][x]+s;\n            blank|=(pz[ty][x]=='.');\n            --ty;\n        }\n        ty=y+1;\n        while (pz[ty][x] != '#') {\n            s+=pz[ty][x];\n            blank|=(pz[ty][x]=='.');\n            ++ty;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    if (hor) {\n        blank=false; s=c; tx=x-1;\n        while (pz[y][tx] != '#') {\n            s=pz[y][tx]+s;\n            blank|=(pz[y][tx]=='.');\n            --tx;\n        }\n        tx=x+1;\n        while (pz[y][tx] != '#') {\n            s+=pz[y][tx];\n            blank|=(pz[y][tx]=='.');\n            ++tx;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    return true;\n}\n\nstring solve(int k, int si) {\n    if (n <= k) return \"Yes\";\n    for (int i=si; i<n; ++i) {\n        if ( ! used[i] && ok(bx[i], by[i], ch[k])) {\n            used[i] = true;\n            pz[by[i]][bx[i]] = ch[k];\n            string res = solve(k+1, (n<=k+1 || ch[k+1]==ch[k]) ? i+1 : 0);\n            used[i] = false;\n            pz[by[i]][bx[i]] = '.';\n            if (res == \"Yes\") return res;\n        }\n    }\n    return \"No\";\n}\n\nbool cmb(const char& l, const char& r) {\n    if (l == '=') return true;\n    if (r == '=') return false;\n    return l < r;\n}\n\nint main() {\n    while (cin >> H >> W, H) {\n        for (int i=0; i<12; ++i) {\n            for (int j=0; j<12; ++j) {\n                pz[i][j] = '#';\n            }\n        }\n        bx.clear(); by.clear();\n        for (int i=1; i<=H; ++i) {\n            for (int j=1; j<=W; ++j) {\n                cin >> pz[i][j];\n                if (pz[i][j] == '.') {\n                    bx.push_back(j);\n                    by.push_back(i);\n                }\n            }\n        }\n        cin >> n;\n        ch.clear();\n        char c;\n        for (int i=0; i<n; ++i) {\n            cin >> c;\n            ch.push_back(c);\n        }\n        sort(ch.begin(), ch.end(), cmb);\n        memset(used, false, sizeof used);\n        cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<set>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\ntypedef pair<pair<int,int>, string> ppiis;\n\nset<ppiis> BADHEQS, BADVEQS;\n\n\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADHEQS.insert(make_pair(make_pair(x,y),eq));\n        return false; \n      }\n    } catch (int ex) {\n      BADHEQS.insert(make_pair(make_pair(x,y),eq));\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADVEQS.insert(make_pair(make_pair(x,y),eq));\n        return false; \n      }\n    } catch(int ex) {\n      BADVEQS.insert(make_pair(make_pair(x,y),eq));\n      return false;\n    }\n  }\n  return true;\n}\n\nint factorial(int x) {\n  int sum = 1;\n  for (int i = 1; i <= x; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\nbool does_include_badeq() {\n  for (auto dat : BADHEQS) {\n    int x = dat.first.first, y = dat.first.second;\n    string eq = dat.second;\n    if (geth(x,y) == eq) return true;\n  }\n\n  for (auto dat : BADVEQS) {\n    int x = dat.first.first, y = dat.first.second;\n    string eq = dat.second;\n    if (getv(x,y) == eq) return true;\n  }\n\n  return false;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  int consid = 0;\n  do {\n    fill_blank();\n    if (does_include_badeq()) continue;\n    if (is_illegal_operand()) continue;\n    if (solved()) {\n//      cout << consid << \" / \" << factorial(n) << endl;\n      return true; \n    } else {\n/*      REP(y, H) {\n        REP(x, W) {\n          cout << TABLE[x][y]; \n        }\n        cout << endl;\n      }\n      cout << endl;\n      consid++;*/\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n//  cout << consid << \" / \" << factorial(n) << endl;\n  return false;\n}\n\nvoid init() {\n  BADHEQS.clear(); BADVEQS.clear();\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) ((l)<=(x) && (x)<(r))\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1])) ){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint parse(int l, int r, const string &s){\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=l;i<r;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  return (parse(0,p,s) == parse(p+1,s.size(),s));\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n\n    cin >> n;\n    rep(i,n)cin >> c[i];\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (!stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\t\n\tvector< Equation > eqs = findEquations();\n\t\n\t//do {\n\tfor_(REP,0,10000) {\n\t\trandom_shuffle(symbol, symbol + n);\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) {\n\t\t\tflag &= eq.evaluate(s_map);\n\t\t\tif (!flag) break;\n\t\t}\n\t\tif (flag) return true;\n\t}\n\t//} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n \nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n \nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n   \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n   \n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n \nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n \n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\npair<int,int> BLANKS[NMAX];\n \nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H; \n}\n \nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n \nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n \nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n \nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n \n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n \nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false;\n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n \n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false;\n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    try {\n      for (int i = 0; i < n; i++) {\n        TABLE[BLANKS[i].first][BLANKS[i].second] = BLOCK[i];\n        if (VSOLVABLE[i] and incorrect\n        }\n      }\n    } catch (int ex) {\n      continue;\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n  return false;\n}\n \nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n \nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n \n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n \n    int idx = 0;\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n      if (not PRINTED[x][y]) {\n        BLANKS[idx] = make_pair(x, y);\n        idx++;\n      }\n    }\n\n \n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n \nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n \nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n   \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n   \n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n \nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n \n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\npair<int,int> BLANKS[NMAX];\n \nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H; \n}\n \nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n \nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n \nbool is_operand(char c) { // {{{\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n} // }}}\n \nbool is_illegal_operand() { // {{{\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n \n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n \nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false;\n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n \n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false;\n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n} // }}}\n\nbool solve() { // {{{\n  sort(BLOCK, BLOCK + n);\n  do {\n    try {\n      for (int i = 0; i < n; i++) {\n        TABLE[BLANKS[i].first][BLANKS[i].second] = BLOCK[i];\n        if (VSOLVABLE[i] and incorrect\n        }\n      }\n    } catch (int ex) {\n      continue;\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n  return false;\n} // }}}\n \nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n} // }}}\n \nint main() { // {{{\n  while (cin >> H >> W and H + W) {\n    init();\n \n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n \n    int idx = 0;\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n      if (not PRINTED[x][y]) {\n        BLANKS[idx] = make_pair(x, y);\n        idx++;\n      }\n    }\n\n \n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n} // }}}\n\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint idx;\nchar s[11];\nbool res;\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex2(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Ex1(){\n\tint a=Ex2();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-'){\n\t\tchar op=s[idx++];\n\t\tint b=Ex2();\n\t\tASRT;\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex1();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex1();\n\tASRT;\n\tif(a!=b || s[idx]) res=false;\n\treturn 0;\n}\n\nbool parse(){\n\tif(strlen(s)<=2) return true;\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nbool calc_no_space(){\n\trep(i,h){\n\t\tint p=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\trep(k,j-p) s[k]=B[i][p+k];\n\t\t\t\t\ts[j-p]='\\0';\n\t\t\t\t\tif(strchr(s,'.')==0 && !parse()) return false;\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\tint p=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\trep(k,i-p) s[k]=B[p+k][j];\n\t\t\t\t\ts[i-p]='\\0';\n\t\t\t\t\tif(strchr(s,'.')==0 && !parse()) return false;\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nchar key[10];\nint n,qx[10],qy[10];\nbool dfs(int k,bool *used){\n\tif(k==n) return true;\n\n\trep(l,n) if(!used[l]) {\n\t\tused[l]=true;\n\t\tB[qy[k]][qx[k]]=key[l];\n\n\t\tbool ok=true;\n\t\tint x1=qx[k],x2=qx[k];\n\t\twhile(x1>=0 && B[qy[k]][x1]!='#') x1--; x1++;\n\t\twhile(x2< w && B[qy[k]][x2]!='#') x2++;\n\t\trep(j,x2-x1) s[j]=B[qy[k]][x1+j];\n\t\ts[x2-x1]='\\0';\n\t\tif(count(s,s+x2-x1,'.')==0 && !parse()) ok=false;\n\n\t\tint y1=qy[k],y2=qy[k];\n\t\twhile(y1>=0 && B[y1][qx[k]]!='#') y1--; y1++;\n\t\twhile(y2< h && B[y2][qx[k]]!='#') y2++;\n\t\trep(i,y2-y1) s[i]=B[y1+i][qx[k]];\n\t\ts[y2-y1]='\\0';\n\t\tif(count(s,s+y2-y1,'.')==0 && !parse()) ok=false;\n\n\t\tif(ok && dfs(k+1,used)) return true;\n\n\t\tused[l]=false;\n\t\tB[qy[k]][qx[k]]='.';\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tbool used[10]={};\n\t\tputs(calc_no_space()&&dfs(0,used)?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n \nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n \nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n   \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n   \n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n \nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n \n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\npair<int,int> BLANKS[NMAX];\n \nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H; \n} // }}}\n \nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n \nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n \nbool is_operand(char c) { // {{{\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n} // }}}\n \nbool is_illegal_operand() { // {{{\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n \n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n} // }}} \n \nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n \nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false;\n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n \n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false;\n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n} // }}}\n\nbool solve() { // {{{\n  sort(BLOCK, BLOCK + n);\n  do {\n    try {\n      for (int i = 0; i < n; i++) {\n        TABLE[BLANKS[i].first][BLANKS[i].second] = BLOCK[i];\n        if (VSOLVABLE[i] and incorrect\n        }\n      }\n    } catch (int ex) {\n      continue;\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n  return false;\n} // }}}\n \nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n} // }}}\n \nint main() { // {{{\n  while (cin >> H >> W and H + W) {\n    init();\n \n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n \n    int idx = 0;\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n      if (not PRINTED[x][y]) {\n        BLANKS[idx] = make_pair(x, y);\n        idx++;\n      }\n    }\n\n \n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n} // }}}\n\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\nint calc(string s)\n{\n  istringstream iss( s );\n  vector<int> num;\n  vector<char> op;\n  int n;\n  char c;\n  while( iss >> n ){    \n    num.push_back( n );\n    if( iss >> c )op.push_back( c );\n    else break;\n  }\n  \n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    else assert( false && \"invalid op\" );\n    num.erase( num.begin() + i + 1);\n    op.erase( op.begin() + i );\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\nbool check_syntax(string s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\n\nstruct F{\n  vector< pair<int, int> > v;\n};\n\nbool solve(char p[], int size, int h, int w)\n{\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  vector< pair<int, int> > emp;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp.push_back( make_pair(i, j) );\n    }\n  }\n\n  if( emp.size() != size )return false;\n\n\n  char puz[H][W];\n  vector<F> v;\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ) v.push_back( f );\n    }\n  }  \n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ) v.push_back( f );\n    }\n  }\n\n  //clog << v.size() << endl;\n\n  sort( p, p + size );\n  do{\n\n    for(int i=0; i<size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    /*\n    cout << endl;\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tcout << g[i][j];\n      }\n      cout << endl;\n    }\n    */\n    bool flg = true;\n    for(int i=0; i<v.size() && flg; ++i){\n      string s;\n      for(int j=0; j<v[i].v.size(); ++j){\n\tint a = v[i].v[j].first;\n\tint b = v[i].v[j].second;\n\ts += g[a][b];\n      }\n      //cout << \"F : \" << s << endl;\n      if( !check_syntax(s) ) flg = false;\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( cin >> h >> w && (h | w) ){\n\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tcin >> g[i][j];\n      }\n    }\n\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n\n    cout << ( solve(m, n, h, w) ? \"Yes\" : \"No\" ) << endl;\n    //clog << ( solve(m, n, h, w) ? \"Yes\" : \"No\" ) << endl;\n\n  }\n\n  //cout << calc(\"2\") << endl;\n  //cout << calc(\"8+23\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e15;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nll parse(int L, int R, const string &s){\n  assert(R-L>1);\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=L;i<R;i++)res = res*10LL + (ll)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  assert(p!=(int)s.size());\n  ll a = parse(0,p,s);\n  ll b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 14)) return false;\n    if(k == L) return true;\n    vector<int> perm;\n    for(int i = 0; i < vc.size(); i++) if(!used[i]) perm.push_back(i);\n    random_shuffle(perm.begin(), perm.end());\n    for(auto i : perm) {\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  if (i == s.length()) {\n    succ = false;\n    return -1;\n  }\n\n  if (s[i] == '+' || s[i] == '-') {\n    succ = false;\n    return -1;\n  }\n\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (cur % tmp > 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq.back() == '=') return false;\n    if (!isdigit(eq[0]) || !isdigit(eq.back())) return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') return false;\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n    if (!succ) return false;\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;                           // 空白の数\nstring p;                        // リストの文字\nvector<vector<string> > formula; // パズル中の数式\nstring change;                   // 各空白に入れる文字\nbool error;                      // 式計算のエラー有無\n\nint calculate(const string& s, int a, int b)\n{\n    if(a > b){\n        error = true;\n        return 0;\n    }\n\n    int k = b;\n    while(k >= a && s[k] != '*' && s[k] != '/')\n        -- k;\n    if(k >= a){\n        int x = calculate(s, a, k-1);\n        int y = calculate(s, k+1, b);\n        if(s[k] == '*'){\n            return x * y;\n        }else{\n            if(y == 0 || x % y != 0){\n                error = true;\n                return 0;\n            }\n            return x / y;\n        }\n    }\n\n    k = b;\n    while(k >= a && s[k] != '+' && s[k] != '-')\n        -- k;\n    if(k >= a){\n        int x = calculate(s, a, k-1);\n        int y = calculate(s, k+1, b);\n        if(s[k] == '+')\n            return x + y;\n        else\n            return x - y;\n    }\n\n    if(s[a] == '0'){\n        error = true;\n        return 0;\n    }\n\n    int ret = 0;\n    for(int i=a; i<=b; ++i){\n        ret *= 10;\n        ret += s[i] - '0';\n    }\n\n    return ret;\n}\n\nbool check(const string& s)\n{\n    int k = s.find('=');\n    if(k == string::npos)\n        return false;\n\n    error = false;\n    bool ret = calculate(s, 0, k-1) == calculate(s, k+1, s.size()-1);\n    return !error && ret;\n}\n\nbool solve(int x, bitset<10> bs)\n{\n    if(x == n)\n        return true;\n\n    for(int i=0; i<n; ++i){\n        if(bs[i])\n            continue;\n        bs[i] = true;\n\n        change[x] = p[i];\n        bool ok = true;\n        for(unsigned j=0; j<formula[x].size(); ++j){\n            string t = formula[x][j];\n            for(unsigned k=0; k<t.size(); ++k){\n                if(isalpha(t[k]))\n                    t[k] = change[t[k]-'a'];\n            }\n            if(!check(t))\n                ok = false;\n        }\n\n        if(ok && solve(x+1, bs))\n            return true;\n\n        bs[i] = false;\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> h >> w;\n        if(h == 0)\n            return 0;\n\n        vector<string> s(h+2, string(w+2, '#'));\n        int tmp = 0;\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> s[i][j];\n                if(s[i][j] == '.'){\n                    s[i][j] = 'a' + tmp;\n                    ++ tmp;\n                }\n            }\n        }\n\n        cin >> n;\n        p.assign(n, ' ');\n        for(int i=0; i<n; ++i)\n            cin >> p[i];\n\n        bool ng = false;\n        formula.assign(n, vector<string>());\n        for(int i=0; i<h+2; ++i){\n            char c = 0;\n            string t;\n            for(int j=0; j<w+2; ++j){\n                if(s[i][j] != '#'){\n                    t += s[i][j];\n                    if(isalpha(s[i][j]))\n                        c = s[i][j];\n                }else{\n                    if(t.size() > 2){\n                        if(c == 0){\n                            if(!check(t))\n                                ng = true;\n                        }else{\n                            formula[c-'a'].push_back(t);\n                        }\n                    }\n                    t = \"\";\n                }\n            }\n        }\n        for(int j=0; j<w+2; ++j){\n            char c = 0;\n            string t;\n            for(int i=0; i<h+2; ++i){\n                if(s[i][j] != '#'){\n                    t += s[i][j];\n                    if(isalpha(s[i][j]))\n                        c = s[i][j];\n                }else{\n                    if(t.size() > 2){\n                        if(c == 0){\n                            if(!check(t))\n                                ng = true;\n                        }else{\n                            formula[c-'a'].push_back(t);\n                        }\n                    }\n                    t = \"\";\n                }\n            }\n        }\n        if(ng){\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        change.assign(n, ' ');\n        if(solve(0, 0))\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  if (i == s.length()) {\n    succ = false;\n    return -1;\n  }\n\n  if (s[i] == '+' || s[i] == '-') {\n    succ = false;\n    return -1;\n  }\n\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (cur % tmp > 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq.back() == '=') return false;\n    if (!isdigit(eq[0]) || !isdigit(eq.back())) return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') {\n        if (i+1 < eq.length() && isdigit(eq[i+1]))\n          return false;\n      }\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n    if (!succ) return false;\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <string> VS;\ntypedef vector <char> VC;\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> PPP;\ntypedef map <PII, int> M_PII_I;\ntypedef map <int, PII> M_I_PII;\ntypedef map <int, PPP> M_I_PPP;\ntypedef map <int, int> M_I_I;\ntypedef map <int, VI> M_I_VI;\ntypedef map <string, int> M_S_I;\ntypedef ostringstream OSS;\n\nconst int NONE = INT_MAX;\n\nint h, w;\nVS M;\nVC O;\nint O_cnt;\nM_PII_I D_ID; // 座標 => '.' の ID\nM_I_PII D_ID_rev; // '.' の ID => 座標\nint D_ID_cnt;\nM_I_VI D_to_E; // '.'が含まれる式ID取得 1対多\nM_I_I E_to_D_cnt; // 式が含む'.'の個数\nM_I_PPP E_ID; // 式ID => ( 座標, 向き, 長さ )\nint E_ID_cnt;\n\nvoid init_global() {\n    M.clear();\n    O.clear();\n    O_cnt = 0;\n    D_ID.clear();\n    D_ID_rev.clear();\n    D_ID_cnt = 0;\n    D_to_E.clear();\n    E_to_D_cnt.clear();\n    E_ID.clear();\n    E_ID_cnt = 0;\n}\n\n// util\nstring toString( PII info ) {\n    OSS oss;\n    oss << \"(\" << info.first << \", \" << info.second << \")\";\n    return oss.str();\n}\n\nstring toString( PPP info ) {\n    OSS oss;\n    oss << toString( info.first ) << \", \" << toString( info.second );\n    return oss.str();\n}\n\nbool isOperation( char c ) {\n    return c < '0' || c > '9';\n}\n\nbool isNumber( char c ) {\n    return c >= '0' && c <= '9';\n}\n\n//\nM_S_I memo;\nint eval( string s ) {\n    if ( memo.count( s ) ) return memo[s];\n    int n = s.size();\n    // debug\n    // cout << \"@eval: \" << s << endl;\n\n    // 演算子\n    char OP[20];\n    int OP_cnt = 0;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( isOperation( s[i] ) ) {\n            OP[OP_cnt ++] = s[i];\n        }\n    }\n\n    int NUM[20] = {};\n    int NUM_cnt = 0;\n    int mul = 1;\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( isOperation( s[i] ) ) {\n            // 区切り\n            NUM_cnt ++;\n            mul = 1;\n        } else {\n            NUM[NUM_cnt] += ( s[i] - '0' ) * mul;\n            mul *= 10;\n        }\n    }\n    NUM_cnt ++;\n    reverse( NUM, NUM + NUM_cnt );\n\n    // *, /\n\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' || OP[i] == '-' ) continue;\n        if ( OP[i] == '*' ) {\n            NUM[i] *= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        } else if ( OP[i] == '/' ) {\n            if ( NUM[i+1] == 0 ) return memo[s] = NONE;\n            if ( NUM[i] % NUM[i+1] != 0 ) return memo[s] = NONE;\n            NUM[i] /= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        }\n    }\n    \n    int res = NUM[0];\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' ) {\n            res += NUM[i+1];\n        } else {\n            res -= NUM[i+1];\n        }\n    }\n\n    // debug\n    // cout << res << endl;\n\n    return memo[s] = res;\n}\n\nbool check2( string& s ) {\n    int n = s.size();\n    if ( isOperation( s[n-1] ) ) return false;\n    if ( s[0] != '-' && isOperation( s[0] ) ) return false;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( isOperation( s[i] ) && isOperation( s[i + 1] ) ) return false;\n    }\n    bool flag = true;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( flag ) {\n            if ( s[i] == '0' && isNumber( s[i + 1] ) ) return false;\n            flag = false;\n        } else if ( isOperation( s[i] ) ) {\n            flag = true;\n        }\n    }\n    return true;\n}\n\nbool check( string& s ) {\n    int n = s.size();\n    string left, right;\n    bool flag = true;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            flag = false;\n        } else if ( flag ) {\n            left += s[i];\n        } else {\n            right += s[i];\n        }\n    }\n    return ( check2( left ) && check2( right ) ) ? eval( left ) == eval( right ) : false;\n}\n\nbool used[11];\nM_I_I E_to_D;\nconst int dr[2] = { 0, 1 };\nconst int dc[2] = { 1, 0 };\nbool backtrack( int k ) {\n    if ( k >= D_ID_cnt ) {\n        bool flag = true;\n        for ( int i = 0; i < D_ID_cnt; ++ i ) {\n            if ( E_to_D[i] != E_to_D_cnt[i] ) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n    for ( int i = 0; i < O_cnt; ++ i ) {\n        if ( used[i] ) continue;\n        int r = D_ID_rev[i].first;\n        int c = D_ID_rev[i].second;\n        used[i] = true;\n        M[r][c] = O[i];\n        for ( VI::iterator it_i = D_to_E[i].begin(); it_i != D_to_E[i].end(); ++ it_i ) {\n            E_to_D[*it_i] ++;\n        }\n        for ( VI::iterator it_i = D_to_E[i].begin(); it_i != D_to_E[i].end(); ++ it_i ) {\n            int eid = *it_i;\n            // debug\n            // cout << eid << \": \" << toString( E_ID[eid] ) << \", \" << E_to_D[eid] << \" == \" << E_to_D_cnt[eid] << endl;\n            if ( E_to_D[eid] == E_to_D_cnt[eid] ) {\n                PPP& info = E_ID[eid];\n                string exp = \"\";\n                int r = info.first.first;\n                int c = info.first.second;\n                for ( int j = 0; j < info.second.second; ++ j ) {\n                    exp += M[r][c];\n                    r += dr[info.second.first];\n                    c += dc[info.second.first];\n                }\n                // debug\n                // cout << eid << \": \" << toString( E_ID[eid] ) << \", \" << E_to_D[eid] << \" == \" << E_to_D_cnt[eid] << \" \";\n                // cout << exp << \", \" << check( exp ) << endl;\n                if ( check( exp ) && backtrack( k + 1 ) ) return true;\n            } else {\n                if ( backtrack( k + 1 ) ) return true;\n            }\n        }\n        for ( VI::iterator it_i = D_to_E[i].begin(); it_i != D_to_E[i].end(); ++ it_i ) {\n            E_to_D[*it_i] --;\n        }\n        used[i] = false;\n    }\n    return false;\n}\n\nbool solve() {\n    E_to_D.clear();\n    fill( used, used + 11, false );\n    return backtrack( 0 );\n    /*\n    const int dr[2] = { 0, 1 };\n    const int dc[2] = { 1, 0 };\n    do {\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            // cout << i << \": \" << O[i] << \", \" << toString( D_ID_rev[i] ) << endl;\n            PII& d = D_ID_rev[i];\n            M[d.first][d.second] = O[i];\n        }\n        bool flag = true;\n        for ( int i = 0; i < E_ID_cnt; ++ i ) {\n            PPP& info = E_ID[i];\n            string exp = \"\";\n            int r = info.first.first;\n            int c = info.first.second;\n            for ( int j = 0; j < info.second.second; ++ j ) {\n                exp += M[r][c];\n                r += dr[info.second.first];\n                c += dc[info.second.first];\n            }\n            if ( ! check( exp ) ) {\n                // cout << exp << endl;\n                flag = false;\n                break;\n            }\n        }\n        if ( flag ) return true;\n    } while ( next_permutation( O.begin(), O.end() ) );\n    */\n}\n\nvoid getID() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == '.' ) {\n                int did = D_ID_cnt ++;\n                D_ID[PII( i, j )] = did;\n                D_ID_rev[did] = PII( i, j );\n            }\n        }\n    }\n}\n\nbool notValid( string s ) {\n    int n = s.size();\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            return ! ( i >= 1 && ( n - ( i + 1 ) ) >= 1 );\n        }\n    }\n    return true;\n}\n\nvoid addExpression( int& si, int& sj, int i, int j, int dir, string& exp, VI& ids ) {\n    if ( notValid( exp ) ) {\n        ids.clear();\n        exp.clear();\n        return;\n    }\n    int eid = E_ID_cnt ++;\n    E_to_D_cnt[eid] = 0;\n    for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n        D_to_E[*it_i].push_back( eid );\n        E_to_D_cnt[eid] ++;\n    }\n    E_ID[eid] = PPP( PII( si, sj ), PII( dir, (int)exp.size() ) );\n\n    // debug\n    // cout << (eid) << \", \" << dir << \", \" << exp << \": \" << toString( E_ID[eid] ) << endl;\n    // for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n    //    cout << \"\\t\" << *it_i << \": \" << toString( D_ID_rev[*it_i] ) << endl;\n    //}\n\n    si = i;\n    sj = j + 1;\n    ids.clear();\n    exp.clear();\n}\n\nvoid getExpressions() {\n    // 横\n    for ( int i = 0; i < h; ++ i ) {\n        string exp;\n        VI ids;\n        int si = i;\n        int sj = 0;\n        for ( int j = 0; j < w; ++ j ) {\n            char c = M[i][j];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, i, j, 0, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(i,j)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 0, exp, ids );\n    }\n    // 縦\n    for ( int i = 0; i < w; ++ i ) {\n        string exp;\n        VI ids;\n        int si = 0;\n        int sj = i;\n        for ( int j = 0; j < h; ++ j ) {\n            char c = M[j][i];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, j, i, 1, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(j,i)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 1, exp, ids );\n    }\n}\n\nint main() {\n    while ( cin >> h >> w && h && w ) {\n        init_global();\n\n        // input\n        M = VS(h);\n        for ( int i = 0; i < h; ++ i ) {\n            cin >> M[i];\n        }\n        cin >> O_cnt;\n        O = VC(O_cnt);\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            cin >> O[i];\n        }\n        sort( O.begin(), O.end() );\n\n        getID();\n        getExpressions();\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 12)) return false;\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cctype>\n#include<cstring>\n#include<iomanip>\n#include<set>\n#include<map>\n\n#define NMAX 11\n#define MAX 16\n\nusing namespace std;\n\ntypedef pair<const char *, int > parsed;\ntypedef pair<bool,int> bnfm;\n\nparsed expr(const char *);\nparsed term(const char *);\nparsed fact(const char *);\n\nbnfm Ex(int pos, const string &s);\nbnfm N0(int pos, const string &s);\n\nparsed expr(const char *p){\n  parsed r = term(p);\n  if( r.first == NULL ) return r; // parse error\n  while( *(r.first)=='+' || *(r.first)=='-' ){\n    const char *op = r.first;\n    parsed l = term(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='+' ){\n      r.first = l.first;\n      r.second = r.second + l.second;\n    }else{\n      r.first = l.first;\n      r.second = r.second - l.second;\n    }\n  }\n  return r;\n}\n\nparsed term(const char *p){\n  parsed r = fact(p);\n  if( r.first == NULL ) return r;\n  while( *(r.first)=='*' || *(r.first)=='/' ){\n    const char *op = r.first;\n    parsed l = fact(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='*' ){\n      r.first = l.first;\n      r.second = r.second * l.second;\n    }else{\n      r.first = l.first;\n      if( l.second == 0 || r.second % l.second != 0 ) return parsed(NULL,-1);\n      r.second = int(r.second / l.second);\n    }\n  }\n  return r;\n}\n\ninline parsed fact(const char *p){\n  if( *p=='(' ){\n    // new expression\n    parsed tp = expr(p+1);\n    if( tp.first == NULL ) return tp;\n    return parsed(tp.first+1, tp.second);\n  }\n  if( *p=='-' ){\n    // negative fact\n    parsed tp = fact(p+1);\n    if( tp.first == NULL ) return tp;\n    tp.second *= -1;\n    return tp;\n  }\n  if( isdigit(*p) ){\n    // number\n    int num = *p - '0';\n    while( isdigit(*(++p)) ){\n      num *= 10;\n      num += *p - '0';\n    }\n    return parsed(p,num);\n  }else assert(0); return parsed(NULL,0);\n}\n\ninline bool Eq(const string &s){\n  int pos = 0;\n  bnfm r = Ex(pos,s);\n  if( !r.first ) return false;\n  pos = r.second;\n  if( pos >= s.length() ) return false;\n  if( s[pos] != '=' ) return false;\n  ++pos;\n  r = Ex(pos,s);\n  if( !r.first ) return false;\n  if( r.second < s.length() ) return false;\n  return true;\n}\n\nbnfm Ex(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm(false,pos);\n  bnfm r = N0(pos,s);\n  if( !r.first ) return bnfm(false,r.second);\n  pos = r.second;\n  if( pos >= s.length() ) return bnfm(true,pos);\n  while( s[ pos ] == '+' || s[ pos ] == '-' || s[ pos ] == '*' || s[ pos ] == '/' ){\n    bnfm r = N0( pos+1, s );\n    if( !r.first ) return bnfm(false,r.second);\n    pos = r.second;\n    if( pos >= s.length() ) break;\n  }\n  return bnfm(true,pos);\n}\n\nbnfm N0(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm( false,pos );\n  if( !isdigit( s[pos] ) ) return bnfm(false,pos+1);\n  if( s[pos] == '0' ){\n    if( pos + 1 < s.length() ){\n      if( isdigit( s[pos+1] ) ) return bnfm(false,pos+2);\n    }\n    return bnfm(true,pos+1);\n  }else{\n    while( isdigit(s[pos]) ){\n      ++pos;\n      if( pos >= s.length() ) break;\n    }\n    return bnfm(true,pos);\n  }\n}\n\nbool Evaluate(const string &s){\n  string s1,s2;\n  int i,j;\n  for(i = 0; i < s.length(); ++i){\n    if( s[i] == '=' ) break;\n    else s1 += s[i];\n  }\n  for(j=i+1; j < s.length(); ++j){\n    s2 += s[j];\n  }\n  parsed p1 = expr(s1.c_str());\n  parsed p2 = expr(s2.c_str());\n  if( p1.first == NULL || p2.first == NULL ) return false;\n  if( p1.second == p2.second ) return true;\n  else return false;\n}\n\nbool Judge(const vector<string> &eqs){\n\n  for(int i = 0; i < eqs.size(); ++i){\n    if( eqs[i].find('.') == string::npos ){\n      if( !Eq(eqs[i]) ) return false;\n      if( !Evaluate( eqs[i] ) ) return false;\n    }\n  }\n  return true;\n  /*\n  const int di [] = {-1,0,1,0};\n  const int dj [] = {0,1,0,-1};\n\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( pzl[i+1][j+1] != '#' ){ \n\tfor(int l = 0; l < sizeof(di)/sizeof(*di); ++l){\n\t  if( l == 1 || l == 2 ) continue;\n\t  int ti = i + 1 + di[l]; int tj = j + 1 + dj[l];\n\t  if( pzl[ti][tj] == '#' ){\n\t    int dir = (l+2)%(sizeof(di)/sizeof(*di));\n\t    ti = i+1+di[dir]; tj = j+1+dj[dir];\n\t    string eq;\n\t    eq += pzl[i+1][j+1];\n\t    while(pzl[ti][tj]!='#'){\n\t      eq += pzl[ti][tj]; ti += di[dir]; tj += dj[dir];\n\t    }\n\t    if( eq.length() >= 3 && eq.find('.') == string::npos ){\n\t      if( !Eq(eq) ) return false;\n\t      if( !Evaluate( eq ) ) return false;\n\t    }\n\t    eq.clear();\n\t  }\n\t}\n      }\n    }\n  }\n  return true;\n  */\n}\n\nbool operator<(const pair<int,int> &a, const pair<int,int> &b){\n  return a.first == b.first ? a.second < b.second : a.first < b.first;\n}\n\nbool dfs(int n, int now,\n\t const vector<pair<int,int> > &hole_pos,\n\t map< pair<int,int>, vector< pair<int,int> > > &meq,\n\t const vector<string> &eqs,\n\t bool vis[NMAX], char holes[NMAX], int H, int W, char pzl[][MAX] ){\n\n  if( !Judge( eqs ) ){\n    return false;\n  }else if( now == hole_pos.size() ){\n    return true;\n  }\n\n  for(int i = 0; i < n; ++i){\n    if( !vis[i] ){\n      const vector< pair<int,int> > &v = meq[ hole_pos[now] ];\n      vector<string> teqs = eqs;\n      //cout << \"DOT POS=\" << hole_pos[now].first << ' ' << hole_pos[now].second << \" : \";\n      for(int j = 0; j < v.size(); ++j){\n\t//cout << v[j].first << ' ' << v[j].second << ',';\n\tteqs[ v[j].first ][ v[j].second ] = holes[ i ];\n      }\n      /*\n      cout << endl;\n      for(int j = 0; j < teqs.size(); ++j){\n\tcout << teqs[j] << endl;\n      }\n      cout << endl;\n      */\n\n      vis[i]=true;\n      if( dfs( n, now+1, hole_pos, meq, teqs, vis, holes, H,W, pzl) ) return true;\n      vis[i]=false;\n\n    }\n  }\n  return false;\n}\n\nint main(void){\n  while(true){\n    int H,W;\n    char pzl[MAX][MAX];\n    bool vis[NMAX]={false,};\n    vector< pair<int,int> > hole_pos;\n    vector<string> eqs;\n    map< pair<int,int>, vector< pair<int,int> > > meq;\n\n    for(int i = 0; i < MAX; ++i)\n      for(int j = 0; j < MAX; ++j)\n\tpzl[i][j]='#';\n    \n    cin >> H >> W;\n    if( H == 0 && W == 0) break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> pzl[i+1][j+1];\n\tif(pzl[i+1][j+1] == '.' ){\n\t  hole_pos.push_back( make_pair(i+1,j+1) );\n\t}\n      }\n    }\n    \n    int n,num=0;\n    cin >> n;\n    int p[n];\n    char holes[n];\n    for(int i = 0; i < n; ++i){\n      char d; cin >> d; holes[num++] = d; p[i] = i;\n    }\n\n    const int di [] = {-1,0,1,0};\n    const int dj [] = {0,1,0,-1};\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif( pzl[i+1][j+1] != '#' ){ \n\t  for(int l = 0; l < sizeof(di)/sizeof(*di); ++l){\n\t    if( l == 1 || l == 2 ) continue;\n\t    int ti = i + 1 + di[l]; int tj = j + 1 + dj[l];\n\t    if( pzl[ti][tj] == '#' ){\n\t      int dir = (l+2)%(sizeof(di)/sizeof(*di));\n\t      ti = i+1; tj = j+1;\n\t      string eq;\n\t      vector< pair<int,int> > poss;\n\t      vector<int> ats;\n\t      while(pzl[ti][tj]!='#'){\n\t\teq += pzl[ti][tj];\n\t\tif( pzl[ti][tj] == '.' ){\n\t\t  poss.push_back( make_pair( ti, tj ) );\n\t\t  ats.push_back( eq.length()-1 );\n\t\t}\n\t\tti += di[dir]; tj += dj[dir];\n\t      }\n\t      if( eq.length() >= 3 ){\n\t\teqs.push_back( eq );\n\t\t//cout << \"EQ : \" << eq << endl;\n\t\t//cout << \"DOT ATS : \"; \n\t\tfor(int i = 0; i < poss.size(); ++i){\n\t\t  //cout << ats[i] << ' ';\n\t\t  meq[ poss[i] ].push_back( make_pair( eqs.size()-1, ats[i] ) );\n\t\t}\n\t\t//cout << endl;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    if( dfs(n,0,hole_pos,meq,eqs,vis,holes,H,W,pzl) ){\n      cout << \"Yes\" << endl;\n    }else{\n      cout << \"No\" <<endl;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint eval_fact(const string &exp, int &pos) {\n    int val = 0;\n    if(!isdigit(exp.at(pos))) throw \"invalid factor\";\n    while(pos < exp.size() && isdigit(exp.at(pos))) {\n        val *= 10;\n        val += exp.at(pos++)-'0';\n    }\n    return val;\n}\n\nint eval_term(const string &exp, int &pos) {\n    int lhs = eval_fact(exp, pos);\n    while(pos < exp.size()) {\n        char op = exp.at(pos++);\n        if(op == '*') {\n            int rhs = eval_fact(exp, pos);\n            lhs *= rhs;\n        }\n        else if(op == '/') {\n            int rhs = eval_fact(exp, pos);\n            if(rhs == 0 || lhs % rhs != 0) throw \"invalid division\";\n            lhs /= rhs;\n        }\n        else {\n            pos--;\n            break;\n        }\n    }\n    return lhs;\n}\n\nint eval_expression(const string &exp,int &pos) {\n    int lhs = eval_term(exp, pos);\n    while(pos < exp.size()) {\n        char op = exp.at(pos++);\n        if(op == '+') {\n            int rhs = eval_term(exp, pos);\n            lhs += rhs;\n        }\n        else if(op == '-') {\n            int rhs = eval_term(exp, pos);\n            lhs -= rhs;\n        }\n        else {\n            pos--;\n            break;\n        }\n    }\n    return lhs;\n}\n\nint eval(const string &exp) {\n    int pos = 0;\n    if(exp.size() == 0) return 0;\n    int val = eval_expression(exp, pos);\n    if(pos != exp.size()) throw \"invalid expression\";\n    return val;\n}\n\nbool check(const vector<string> &v) {\n    bool ok = true;\n    int H = v.size();\n    for(int r = 0; r < H; ++r) {\n        int start = 0;\n        while(start < v[r].size()) {\n            int bl = v[r].find('#', start);\n            string eq = v[r].substr(start, bl-start);\n            int epos = eq.find('=');\n            if(eq.size() > 1 && epos != string::npos) {\n                string lhs = eq.substr(0, epos), rhs = eq.substr(epos+1);\n                //cout << eq << '$' << lhs << ' ' << rhs << endl;\n                try {\n                    if(eval(lhs) != eval(rhs)) {\n                        return false;\n                        break;\n                    }\n                } catch (const char *str) {\n                    return false;\n                    break;\n                }\n            }\n            start = bl+1;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while(true) {\n        int H, W;\n        cin >> H >> W;\n        if(!H && !W) break;\n\n        vector<string> field(H);\n        vector<pair<int,int> > space;\n        for(int i = 0; i < H; ++i) {\n            cin >> field[i];\n            field[i] += '#';\n            for(int j = 0; j < W; ++j)\n                if(field[i][j] == '.') space.push_back(make_pair(i, j));\n        }\n\n        int N;\n        cin >> N;\n        vector<char> piece(N);\n        for(int i = 0; i < N; ++i) cin >> piece[i];\n\n        sort(piece.begin(), piece.end());\n        bool hasans = false;\n        do {\n            vector<string> tmp = field;\n            for(int i = 0; i < N; ++i) {\n                pair<int,int> s = space[i];\n                tmp[s.first][s.second] = piece[i];\n            }\n            if(!check(tmp)) continue;\n\n            vector<string> tmpt(W);\n            for(int r = 0; r < H; ++r) {\n                for(int c = 0; c < W; ++c) {\n                    tmpt[c] += tmp[r][c];\n                }\n            }\n            for(int i = 0; i < tmpt.size(); ++i) tmpt[i] += '#';\n\n            if(!check(tmpt)) continue;\n\n            hasans = true;\n            break;\n        } while(next_permutation(piece.begin(), piece.end()));\n        cout << (hasans?\"Yes\":\"No\") << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int INF = 1<<24;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  string num = \"\";\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  while(pos < s.size() && isdigit(s[pos])) {\n    num += s[pos++];\n  }\n  if(num[0] == '0') {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  return atoi(num.c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int value = getNum(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      value = getNum(s, pos);\n      if(value == INF) return INF;\n      x *= value;\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == INF) return INF;\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn INF;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int value = term(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x += value;\n    } else if(s[pos] == '-') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x -= value;\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n\n      }\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n    sort(V.begin(), V.end());\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch(int ex) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    if(!isNum(s[pos])){flag=true;}\n\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),z;\n    if(pos==len)return res;\n    else if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      z=getNum();\n      if(z==0){flag=true;z=1;}\n      else if(res%z!=0)flag=true;\n      return res/z;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len)break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n\n  for(int i=0;i<(int)w.size();i++){\n    if(compute(i)==false)return false;\n  }\n  return true;\n}\n\nbool compute(int x){\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF){\n    return false;\n  }\n\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (PRINTED[x][y]) continue;\n    TABLE[x][y] = BLOCK[i++];\n    const int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};\n    REP(j, 4) {\n      int nx = x + dx[j], ny = y + dy[j];\n      if (is_operand(TABLE[x][y]) and legal(nx, ny) and \n          is_operand(TABLE[nx][ny])) {\n        throw NotEquationExc;\n      }\n    }\n  }\n}\n\nchar TEMP[100];\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false; \n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    try { fill_blank(); } catch (int ex) { continue; }\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) ((l)<=(x) && (x)<(r))\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint parse(int L, int R, const string &s){\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=L;i<R;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  int a = parse(0,p,s);\n  int b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      assert(false);\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\npii number(const string& s,int i)\n{\n\tint x=0;\n\tif(i>=s.size() || !isdigit(s[i])) throw __func__;\n\tfor(int len=0;i<s.size() && isdigit(s[i]);i++,len++){\n\t\tif(len==1 && x==0) throw __func__;\n\t\tx=x*10+s[i]-'0';\n\t}\n\treturn mp(x,i);\n}\npii term(const string& s,int i)\n{\n\tint x; tie(x,i)=number(s,i);\n\twhile(i<s.size() && (s[i]=='*' || s[i]=='/')){\n\t\tchar op=s[i];\n\t\tint y; tie(y,i)=number(s,i+1);\n\t\tif(op=='*') x*=y;\n\t\tif(op=='/'){\n\t\t\tif(y==0 || x%y>0) throw \"zero div\";\n\t\t\tx/=y;\n\t\t}\n\t}\n\treturn mp(x,i);\n}\npii expr(const string& s,int i)\n{\n\tint x; tie(x,i)=term(s,i);\n\twhile(i<s.size()){\n\t\tchar op=s[i];\n\t\tif(op!='+' && op!='-') throw __func__;\n\t\tint y; tie(y,i)=term(s,i+1);\n\t\tif(op=='+') x+=y;\n\t\tif(op=='-') x-=y;\n\t}\n\treturn mp(x,i);\n}\nint expr(const string& s)\n{\n\ttry{\n\t\tint res=expr(s,0).first;\n\t\treturn res;\n\t}\n\tcatch(const char* msg){\n\t\t//dump(msg);\n\t\treturn INF;\n\t}\n}\n\nbool check(const vs& grid,const vector<pii>& f)\n{\n\tstring s;\n\tfor(auto p:f) s+=grid[p.first][p.second];\n\tif(count(all(s),'=')!=1) return false;\n\tint eq=s.find('=');\n\tif(eq==0 || eq==s.size()-1) return false;\n\tstring a=s.substr(0,eq),b=s.substr(eq+1);\n\t\n\tint x=expr(a),y=expr(b);\n\t//dump(mt(s,x,y));\n\tif(x==INF || y==INF || x!=y)\n\t\treturn false;\n\treturn true;\n}\n\nbool solve(int i,vs& grid,string& cs,vector<pii>& ps,vector<vector<pii>>& fs,vvi& ds)\n{\n\tint n=ps.size();\n\tif(i==n) return true;\n\t\n\tfor(char& c:cs) if(c!='X'){\n\t\tgrid[ps[i].first][ps[i].second]=c; c='X';\n\t\tif(all_of(all(ds[i]),[&](int j){return check(grid,fs[j]);}))\n\t\t\tif(solve(i+1,grid,cs,ps,fs,ds))\n\t\t\t\treturn true;\n\t\tc=grid[ps[i].first][ps[i].second];\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint n; cin>>n;\n\t\tstring cs(n,'~');\n\t\trep(i,n) cin>>cs[i];\n\t\t\n\t\tvector<pii> ps;\n\t\tvector<vector<pii>> fs;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='.') ps.emplace_back(i,j);\n\t\t\tif(grid[i][j]!='#'){\n\t\t\t\tif((i==0 || grid[i-1][j]=='#') && i<h-1 && grid[i+1][j]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=i;k<h && grid[k][j]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(k,j);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t\tif((j==0 || grid[i][j-1]=='#') && j<w-1 && grid[i][j+1]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=j;k<w && grid[i][k]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(i,k);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvvi ds(n+1);\n\t\t{\n\t\t\tvi vis(fs.size());\n\t\t\trep(i,n+1){\n\t\t\t\trep(j,fs.size()) if(!vis[j]){\n\t\t\t\t\tstring s;\n\t\t\t\t\tfor(auto p:fs[j]) s+=grid[p.first][p.second];\n\t\t\t\t\tif(count(all(s),'.')==0){\n\t\t\t\t\t\tds[i].push_back(j);\n\t\t\t\t\t\tvis[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<n) grid[ps[i].first][ps[i].second]='?';\n\t\t\t}\n\t\t\trep(i,n)\n\t\t\t\tgrid[ps[i].first][ps[i].second]='.';\n\t\t\trotate(begin(ds),1+all(ds));\n\t\t}\n\t\t\n\t\tif(!all_of(all(ds[n]),[&](int j){return check(grid,fs[j]);})){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<(solve(0,grid,cs,ps,fs,ds)?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) throw IncorrectExc;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) throw IncorrectExc;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\ntypedef pair<int,int> Error;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nbool includestr(string lhs, string rhs) {\n  string::iterator lit = lhs.begin();\n  string::iterator rit = rhs.begin();\n  while (lit != lhs.end()) {\n    if (*lit != *rit) { return false; }\n    lit++; rit++;\n  }\n  return true;\n}\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw Error(p, NotEquationExc); }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw Error(p, NotEquationExc); }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw Error(p, NegIntExc); }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw Error(p, OutOfIntExc); \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw Error(p, LackNumExc); }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw Error(p, NotNumExc); }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and includestr(hbadeq, geth(hbadx, hbady))) \n    return false;\n  if (vbadflag and includestr(vbadeq, geth(vbadx, vbady))) \n    return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (Error ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq.substr(0, ex.first);\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        return false;\n      }\n    } catch(Error ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq.substr(0, ex.first);\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nconstexpr int tsurai=123456789;\n\nint parse_int(const std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i]-'0';\n  while (++i < s.length() && isdigit(s[i])) {\n    res = res*10 + s[i]-'0';\n  }\n  return res;\n}\n\nint fourt(const std::string &s, size_t &i) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length() && isdigit(s[i])) {\n    int cur=parse_int(s, i);\n    while (i < s.length() && s[i] != '=') {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (tmp == 0 || cur % tmp) return tsurai;\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n    if (sgn == '+') {\n      res += cur;\n    } else {\n      res -= cur;\n    }\n    if (i < s.length() && s[i] != '=') {\n      sgn = s[i++];\n    }\n  }\n  return res;\n}\n\nbool valid(const std::vector<std::string> &eqs, const std::vector<char> &cs) {\n  for (/* not const */ std::string eq: eqs) {\n    for (char &ch: eq)\n      if (ch >= 'A' && ch <= 'Z')\n        ch = cs[ch-'A'];\n\n    if (eq[0] == '=' || !isdigit(eq.back()))\n      return false;\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] != '0') {\n        do {\n          ++i;\n        } while (i < eq.length() && isdigit(eq[i]));\n      } else {\n        if (i+1 < eq.length() && isdigit(eq[i+1]))\n          return false;\n      }\n    }\n\n    size_t i=0;\n    if (!isdigit(eq[i])) return false;\n    int lhs=fourt(eq, i);\n    if (lhs == tsurai) return false;\n    assert(eq[i] == '=');\n    ++i;\n    if (!isdigit(eq[i])) return false;\n    int rhs=fourt(eq, i);\n    if (rhs == tsurai) return false;\n    assert(i == eq.length());\n    \n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0)\n    return 1;\n\n  size_t ph='A';  // placeholder\n  std::vector<std::string> s(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] == '.')\n        s[i][j] = ph++;\n    }\n  }\n\n  std::vector<std::string> eqs;\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> cs(n);\n  for (size_t i=0; i<n; ++i)\n    scanf(\" %c\", &cs[i]);\n\n  std::sort(cs.begin(), cs.end());\n  do {\n    if (valid(eqs, cs))\n      return !printf(\"Yes\\n\");\n  } while (std::next_permutation(cs.begin(), cs.end()));\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  if (i == s.length()) {\n    succ = false;\n    return -1;\n  }\n\n  if (s[i] == '+' || s[i] == '-') {\n    succ = false;\n    return -1;\n  }\n\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (cur % tmp != 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq.back() == '=') return false;\n    if (!isdigit(eq[0]) || !isdigit(eq.back())) return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') {\n        if (i+1 < eq.length() && isdigit(eq[i+1]))\n          return false;\n      }\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n    if (!succ) return false;\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct invalid {};\ntypedef const char *Iterator;\n\nint eval_factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw invalid();\n  }\n  if (*it < '0' || '9' < *it) {\n    throw invalid();\n  }\n  int val = *it - '0';\n  ++it;\n  if (val == 0) {\n    return val;\n  }\n  while (it != last && '0' <= *it && *it <= '9') {\n    val = 10*val + (*it - '0');\n    ++it;\n  }\n  return val;\n}\n\nint eval_term(Iterator& it, const Iterator& last)\n{\n  int val = eval_factor(it, last);\n  while (it != last && (*it == '*' || *it == '/')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_factor(it, last);\n    if (op == '*') {\n      val *= x;\n    } else {\n      if (x == 0 || val % x != 0) {\n        throw invalid();\n      }\n      val /= x;\n    }\n  }\n  return val;\n}\n\nint eval_expr(Iterator& it, const Iterator& last)\n{\n  int val = eval_term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_term(it, last);\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return val;\n}\n\nbool check(Iterator it, const Iterator& last) try\n{\n  const int l = eval_expr(it, last);\n  if (it == last || *it != '=') {\n    return false;\n  }\n  ++it;\n  const int r = eval_expr(it, last);\n  return it == last && l == r;\n} catch (const invalid&) {\n  return false;\n}\n\nstatic const int M = 15;\n\nbool extract_expr(char (*dst)[M], pair<int,int> (*tbl)[2], const char rows[M][M], int H, int W, int& s)\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (j == 0 || rows[i][j-1] == '#') {\n        const int k = j;\n        ++j;\n        while (j < W && rows[i][j] != '#') {\n          ++j;\n        }\n        if (j-k > 2) {\n          for (int l = k; l < j; l++) {\n            dst[s][l] = rows[i][l];\n            if (rows[i][l] >= 'a') {\n              pair<int,int> *t = tbl[rows[i][l]-'a'];\n              if (t[0].first != -1) {\n                t[1].first = s;\n                t[1].second = l;\n              } else {\n                t[0].first = s;\n                t[0].second = l;\n              }\n            }\n          }\n          dst[s][j-k] = '\\0';\n          ++s;\n;       }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(char (*exprs)[M], int s, char *cards, int N, const pair<int,int> (*tbl)[2])\n{\n  do {\n    for (int i = 0; i < N; i++) {\n      if (tbl[i][0].first >= 0) {\n        exprs[tbl[i][0].first][tbl[i][0].second] = cards[i];\n      }\n      if (tbl[i][1].first >= 0) {\n        exprs[tbl[i][1].first][tbl[i][1].second] = cards[i];\n      }\n    }\n    for (int i = 0; i < s; i++) {\n      if (!check(exprs[i], exprs[i]+strlen(exprs[i]))) {\n        goto FAIL;\n      }\n    }\n    return true;\nFAIL:\n    ;\n  } while (next_permutation(cards, cards+N));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (scanf(\"%d %d\", &H, &W) != EOF && H != 0) {\n    char rows[M][M], cols[M][M];\n    int n = 0;\n    for (int i = 0; i < H; i++) {\n      scanf(\"%s\", rows[i]);\n      for (int j = 0; j < W; j++) {\n        if (rows[i][j] == '.') {\n          rows[i][j] = 'a' + n;\n          ++n;\n        }\n        cols[j][i] = rows[i][j];\n        cols[j][H] = '\\0';\n      }\n    }\n    int N;\n    scanf(\"%d\", &N);\n    char cards[M];\n    for (int i = 0; i < N; i++) {\n      char buf[4];\n      scanf(\"%s\", buf);\n      cards[i] = buf[0];\n    }\n    sort(cards, cards+N);\n    cards[N] = '\\0';\n\n    static char exprs[100][M];\n    static pair<int,int> tbl[10][2];\n    for (int i = 0; i < 10; i++) {\n      tbl[i][0].first = tbl[i][1].second = -1;\n    }\n    int s = 0;\n    if (!extract_expr(exprs, tbl, rows, H, W, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (!extract_expr(exprs, tbl, cols, W, H, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (s == 0) {\n      puts(\"Yes\");\n      continue;\n    }\n    if (solve(exprs, s, cards, N, tbl)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id, bool f=1) {\n  if (s.size() < 2) return 1;\n  // if (f) {\n  //   if ((id == 0 || isoperator(s[id-1])) && (!isdigit(s[id]) || s[id] == '0')) return 0;\n  //   if ((id == s.size()-1 || isoperator(s[id+1])) && !isdigit(s[id])) return 0;\n  // }\n  REP(i,s.size()-1) {\n    if ((i==0 || !isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return 0;\n    if (isoperator(s[i]) && isoperator(s[i+1])) return 0;\n  }\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == pos.size()) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // assert(pos.size() == n);\n    bool ok = 1;\n    FOR(it, v) ok &= check(*it,0,0);\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (ok&&dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nbool hbegin[HMAX][WMAX], vbegin[HMAX][WMAX];\nP blanks[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nbool incorrect(string str) { return equation(str).value != 1; }\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.first][p.second] = block[i];\n\n        P q = vsolvables[i];\n        if (q.first != -1 and incorrect(getv(q.first, q.second)))\n          throw IncorrectExc;\n\n        q = hsolvables[i];\n        if (incorrect(geth(q.first, q.second)))\n          throw IncorrectExc;\n      }\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n    hbegin[x][y] = false;\n    vbegin[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y);\n  if (v.find(\".\", 0) == string::npos) {\n    int x = p.X, y = p.Y;\n    while (legal(x, y) and table[x][y]) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X, p.Y);\n  if (h.find(\".\", 0) == string::npos) {\n    int x = p.X, y = p.Y;\n    while (legal(x, y) and table[x][y]) x--;\n    return P(--x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    REP(y, H) REP(x, W) { // {{{\n      if (table[x][y]!='#' and legal(x+1,y) and table[x+1][y]!='#'\n          and (!legal(x-1,y) or table[x-1][y] == '#')) {\n        hbegin[x][y] = true;\n      }\n      if (table[x][y]!='#' and legal(x,y+1) and table[x][y+1]!='#'\n          and (!legal(x,y-1) or table[x][y-1] == '#')) {\n        vbegin[x][y] = true;\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <string> VS;\ntypedef vector <char> VC;\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> PPP;\ntypedef map <PII, int> M_PII_I;\ntypedef map <int, PII> M_I_PII;\ntypedef map <int, PPP> M_I_PPP;\ntypedef map <int, int> M_I_I;\ntypedef map <int, VI> M_I_VI;\ntypedef map <string, int> M_S_I;\ntypedef ostringstream OSS;\n\nconst int NONE = INT_MAX;\n\nint h, w;\nVS M;\nVC O;\nint O_cnt;\nM_PII_I D_ID; // 座標 => '.' の ID\nM_I_PII D_ID_rev; // '.' の ID => 座標\nint D_ID_cnt;\nM_I_VI D_to_E; // '.'が含まれる式ID取得 1対多\nM_I_PPP E_ID; // 式ID => ( 座標, 向き, 長さ )\nint E_ID_cnt;\n\nvoid init_global() {\n    M.clear();\n    O.clear();\n    O_cnt = 0;\n    D_ID.clear();\n    D_ID_rev.clear();\n    D_ID_cnt = 0;\n    D_to_E.clear();\n    E_ID.clear();\n    E_ID_cnt = 0;\n}\n\n// util\nstring toString( PII info ) {\n    OSS oss;\n    oss << \"(\" << info.first << \", \" << info.second << \")\";\n    return oss.str();\n}\n\nstring toString( PPP info ) {\n    OSS oss;\n    oss << toString( info.first ) << \", \" << toString( info.second );\n    return oss.str();\n}\n\nbool isOperation( char c ) {\n    return c < '0' || c > '9';\n}\n\nbool isNumber( char c ) {\n    return c >= '0' && c <= '9';\n}\n\n//\nM_S_I memo;\nint eval( string s ) {\n    if ( memo.count( s ) ) return memo[s];\n    int n = s.size();\n    // debug\n    // cout << \"@eval: \" << s << endl;\n\n    // 演算子\n    char OP[20];\n    int OP_cnt = 0;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( isOperation( s[i] ) ) {\n            OP[OP_cnt ++] = s[i];\n        }\n    }\n\n    int NUM[20] = {};\n    int NUM_cnt = 0;\n    int mul = 1;\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( isOperation( s[i] ) ) {\n            // 区切り\n            NUM_cnt ++;\n            mul = 1;\n        } else {\n            NUM[NUM_cnt] += ( s[i] - '0' ) * mul;\n            mul *= 10;\n        }\n    }\n    NUM_cnt ++;\n    reverse( NUM, NUM + NUM_cnt );\n\n    // *, /\n\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' || OP[i] == '-' ) continue;\n        if ( OP[i] == '*' ) {\n            NUM[i] *= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        } else if ( OP[i] == '/' ) {\n            if ( NUM[i+1] == 0 ) return memo[s] = NONE;\n            if ( NUM[i] % NUM[i+1] != 0 ) return memo[s] = NONE;\n            NUM[i] /= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        }\n    }\n    \n    int res = NUM[0];\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' ) {\n            res += NUM[i+1];\n        } else {\n            res -= NUM[i+1];\n        }\n    }\n\n    // debug\n    // cout << res << endl;\n\n    return memo[s] = res;\n}\n\nbool check2( string& s ) {\n    int n = s.size();\n    if ( isOperation( s[n-1] ) ) return false;\n    if ( s[0] != '-' && isOperation( s[0] ) ) return false;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( isOperation( s[i] ) && isOperation( s[i + 1] ) ) return false;\n    }\n    bool flag = true;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( flag ) {\n            if ( s[i] == '0' && isNumber( s[i + 1] ) ) return false;\n            flag = false;\n        } else if ( isOperation( s[i] ) ) {\n            flag = true;\n        }\n    }\n    return true;\n}\n\nbool check( string& s ) {\n    int n = s.size();\n    string left, right;\n    bool flag = true;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            flag = false;\n        } else if ( flag ) {\n            left += s[i];\n        } else {\n            right += s[i];\n        }\n    }\n    return ( check2( left ) && check2( right ) ) ? eval( left ) == eval( right ) : false;\n}\n\nbool solve() {\n    sort( O.begin(), O.end() );\n    const int dr[2] = { 0, 1 };\n    const int dc[2] = { 1, 0 };\n    do {\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            // cout << i << \": \" << O[i] << \", \" << toString( D_ID_rev[i] ) << endl;\n            PII& d = D_ID_rev[i];\n            M[d.first][d.second] = O[i];\n        }\n        bool flag = true;\n        for ( int i = 0; i < E_ID_cnt; ++ i ) {\n            PPP& info = E_ID[i];\n            string exp = \"\";\n            int r = info.first.first;\n            int c = info.first.second;\n            for ( int j = 0; j < info.second.second; ++ j ) {\n                exp += M[r][c];\n                r += dr[info.second.first];\n                c += dc[info.second.first];\n            }\n            if ( ! check( exp ) ) {\n                // cout << exp << endl;\n                flag = false;\n                break;\n            }\n        }\n        if ( flag ) return true;\n    } while ( next_permutation( O.begin(), O.end() ) );\n    return false;\n}\n\nvoid getID() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == '.' ) {\n                int did = D_ID_cnt ++;\n                D_ID[PII( i, j )] = did;\n                D_ID_rev[did] = PII( i, j );\n            }\n        }\n    }\n}\n\nbool notValid( string s ) {\n    int n = s.size();\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            return ! ( i >= 1 && ( n - ( i + 1 ) ) >= 1 );\n        }\n    }\n    return true;\n}\n\nvoid addExpression( int& si, int& sj, int i, int j, int dir, string& exp, VI& ids ) {\n    if ( notValid( exp ) ) {\n        ids.clear();\n        exp.clear();\n        return;\n    }\n    int eid = E_ID_cnt ++;\n    for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n        D_to_E[*it_i].push_back( eid );\n    }\n    E_ID[eid] = PPP( PII( si, sj ), PII( dir, (int)exp.size() ) );\n\n    // debug\n    // cout << (eid) << \", \" << dir << \", \" << exp << \": \" << toString( E_ID[eid] ) << endl;\n    // for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n    //    cout << \"\\t\" << *it_i << \": \" << toString( D_ID_rev[*it_i] ) << endl;\n    //}\n\n    si = i;\n    sj = j + 1;\n    ids.clear();\n    exp.clear();\n}\n\nvoid getExpressions() {\n    // 横\n    for ( int i = 0; i < h; ++ i ) {\n        string exp;\n        VI ids;\n        int si = i;\n        int sj = 0;\n        for ( int j = 0; j < w; ++ j ) {\n            char c = M[i][j];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, i, j, 0, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(i,j)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 0, exp, ids );\n    }\n    // 縦\n    for ( int i = 0; i < w; ++ i ) {\n        string exp;\n        VI ids;\n        int si = 0;\n        int sj = i;\n        for ( int j = 0; j < h; ++ j ) {\n            char c = M[j][i];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, j, i, 1, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(j,i)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 1, exp, ids );\n    }\n}\n\nint main() {\n    while ( cin >> h >> w && h && w ) {\n        init_global();\n\n        // input\n        M = VS(h);\n        for ( int i = 0; i < h; ++ i ) {\n            cin >> M[i];\n        }\n        cin >> O_cnt;\n        O = VC(O_cnt);\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            cin >> O[i];\n        }\n\n        getID();\n        getExpressions();\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    if(!isNum(s[pos])){flag=true;return 0;}\n\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),z;\n    if(pos==len)return res;\n    else if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      z=getNum();\n      if(z==0){flag=true;z=1;}\n      if(res%z!=0)flag=true;\n      return res/z;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len)break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n\n  for(int i=0;i<(int)w.size();i++){\n    if(compute(i)==false)return false;\n  }\n  return true;\n}\n\nbool compute(int x){\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF){\n    return false;\n  }\n\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e15;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  if(!isdigit(s[0]) || !isdigit(s.back()))return false;\n  return true;\n}\n\nll parse(int L, int R, const string &s){\n  assert(R!=L);\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=L;i<R;i++)res = res*10LL + (ll)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  assert(p!=(int)s.size());\n  ll a = parse(0,p,s);\n  ll b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 15)) return false;\n    if(k == L) return true;\n    vector<int> perm;\n    for(int i = 0; i < vc.size(); i++) if(!used[i]) perm.push_back(i);\n    random_shuffle(perm.begin(), perm.end());\n    for(auto i : perm) {\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    srand(time(NULL));\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <time.h>\nclock_t start, en;\n\nusing namespace std;\n// 4:37\n// 4:40 coding\n\nvector< pair<int,int> > pos;\nvector<string> expr;\n\nchar nowtable[128];\nstring s;\nint p;\nint A();\nint B();\nint C();\nint D();\nint calc(string _str){\n\ttry{\n\t\tp = 0;\n\t\ts = _str;\n\t\ts += \"~\";\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( s[i] >= 'A' && s[i] <= 'Z' ){\n\t\t\t\tif( nowtable[s[i]] == 0 ) return 2;\n\t\t\t\ts[i] = nowtable[s[i]];\n\t\t\t}\n\t\t}\n\t\tint res = A();\n\t\t\n\t\tif( s[p] != '~' ) throw \"not end\";\n\t\treturn res;\n\t}catch(const char *msg){\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\nint A(){\n\t\n\tint x = B();\n\tif( s[p] == '=' ){\n\t\tp++;\n\t\tint y = B();\n\t\treturn x == y;\n\t}else{\n\t\tthrow \"A\";\n\t}\n}\nint B(){\n\tint x = C();\n\twhile( s[p] == '+' || s[p] == '-' ){\n\t\tif( s[p] == '+'){\n\t\t\tp++;\n\t\t\tx += C();\n\t\t}else{\n\t\t\tp++;\n\t\t\tx -= C();\n\t\t}\n\t}\n\treturn x;\n}\nint C(){\n\tint x = D();\n\twhile( s[p] == '*' || s[p] == '/' ){\n\t\tif( s[p] == '*'){\n\t\t\tp++;\n\t\t\tx *= D();\n\t\t}else{\n\t\t\tp++;\n\t\t\tint r = D();\n\t\t\tif(r==0) throw \"zero\";\n\t\t\tif(x%r) throw \"modulo\";\n\t\t\tx /= r;\n\t\t}\n\t}\n\treturn x;\n}\nint D(){\n\t\n\tint x = 0;\n\n\tif( !(s[p]>='1'&&s[p]<='9') ) throw \"wrong number\";\n\twhile( s[p]>='1'&&s[p]<='9'){\n\t\tx = x*10+s[p++]-'0';\n\t}\n\t\n\treturn x;\n}\n\nchar t[12][12];\nvector<char> use;\n\nint used[10];\nvector<string> hoge;\nint check(){\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint r = calc(hoge[i]);\n\t\tif( r == 2 ) continue;\n\t\tif( !r ) return 0;\n\t}\n\treturn 1;\n}\nint N;\nint dfs(){\n\t//en=clock();\n\t//if( (double)(en - start) / CLOCKS_PER_SEC > 0.1 ) return 0;\n\tif( !check() ) return 0;\n\tvector< pair<int,int> > v;\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint c = 0;\n\t\tfor(int j = 0 ; j < hoge[i].size() ; j++){\n\t\t\tif( nowtable[hoge[i][j]] == 0 ){\n\t\t\t\t\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif(c){\n\t\t\tv.push_back(make_pair(c,i));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tif( v.size() == 0 ) return 1;\n\t\n\tint idx = v[0].second;\n\tfor(int j = 0 ; j < hoge[idx].size() ; j++){\n\t\tif( nowtable[hoge[idx][j]] == 0 ){\n\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\tif( !used[k] ){\n\t\t\t\t\tnowtable[hoge[idx][j]] = use[k];\n\t\t\t\t\tused[k] = true;\n\t\t\t\t\tif( dfs() ) return true;\n\t\t\t\t\tused[k] = false;\n\t\t\t\t\tnowtable[hoge[idx][j]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\n\tint H,W;\n\twhile( cin >> H >> W && H){\n\t\tstart=clock();\n\t\tfor(int i = 0 ; i < 128 ; i++) nowtable[i] = -1;\n\t\tfor(int i = 0 ; i < 10 ; i++) used[i] = 0;\n\t\tfor(int i = 'A' ; i <= 'Z' ; i++) nowtable[i] = 0;\n\t\tuse.clear();\n\t\thoge.clear();\n\t\tfor(int i = 0 ; i < 12 ; i++)\n\t\t\tfor(int j = 0 ; j < 12 ; j++)\n\t\t\t\tt[i][j] = '#';\n\t\n\t\tchar tmpAlpha = 'A';\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> t[i+1][j+1];\n\t\t\t\tif( t[i+1][j+1] == '.' ){\n\t\t\t\t\tt[i+1][j+1] = tmpAlpha++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tchar c; cin >> c;\n\t\t\tuse.push_back(c);\n\t\t}\n\t\tvector<string> id;\n\t\t\n\t\tsort(use.begin(),use.end());\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( t[i][j-1] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = j;\n\t\t\t\t\twhile( t[i][k] != '#' ){\n\t\t\t\t\t\tstr += t[i][k++];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( t[i-1][j] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = i;\n\t\t\t\t\twhile( t[k][j] != '#' ){\n\t\t\t\t\t\tstr += t[k++][j];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tdo{\n\t\t\tfor(int i = 0 ; i < N ; i++)\n\t\t\t\tnowtable['A'+i] = use[i];\n\t\t\tif( check() ){\n\t\t\t\tans = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}while(next_permutation(use.begin(),use.end()));\n\t\t\n\t\tcout << (ans?\"Yes\":\"No\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n\n  void init(){ pos=0;len=s.size();flag=false;}\n\n  int head2Num(){\n    if(!isNum(s[pos]))flag=true;\n\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    char ch;\n    while(s[pos]=='*'||s[pos]=='/'){\n      ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      else if(ch=='/'){\n\tif(num==0){flag=true;num=1;}\n\tif(res%num>0)flag=true;\n\tres/=num;\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3&&e>0){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3&&e>0){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3&&e>0){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3&&e>0){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n\n  for(int i=0;i<(int)w.size();i++){\n    if(compute(i)==false)return false;\n  }\n  return true;\n}\n\nbool compute(int x){\n\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.s.push_back('=');\n  b.s.push_back('=');\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF){\n    return false;\n  }\n\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <exception>\n#include <fstream>\nusing namespace std;\n\nconst int LIM = 10;\n\nint H, W, n;\nchar pz[12][12];\n\nvector<int> bx, by;\nbool used[LIM];\nvector<char> ch;\n\nclass Evaluator {\npublic:\n    static int num(string &s, int &k) {\n        int a = 0;\n        while (isdigit(s[k])) {\n            a = a * 10 + (s[k] - '0'); ++k;\n        }\n        return a;\n    }\n    static int mul(string &s, int &k) {\n        int a = num(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '*') a *= mul(s, ++k);\n            else if (s[k] == '/') {\n                int b = mul(s, ++k);\n                if (b == 0) throw 0; // DivisionByZero\n                else if (a % b != 0) throw 1; // LeavingRemaindar\n                a /= b;\n            }\n            else break;\n        }\n        return a;\n    }\n    static int add(string &s, int &k) {\n        int a = mul(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '+') a += mul(s, ++k);\n            else if (s[k] == '-') a -= mul(s, ++k);\n            else break;\n        }\n        return a;\n    }\n    static bool eq(string &s, int &k) {\n        int a = add(s, k);\n        if (k < (int)s.size() && s[k] == '=') {\n            int b = add(s, ++k);\n            if (k < (int)s.size()) return false;\n            return a == b;\n        }\n        return false;\n    }\n    static bool run(string s) {\n        int k; bool ret;\n        try {\n            ret = eq(s, k=0);\n        } catch (int) {\n            ret = false;\n        }\n        return ret;\n    }\n};\n\nbool issymbol(char c) {\n    return c=='+' || c=='-' || c=='*' || c=='/' || c=='=';\n}\n\nbool ok(int x, int y, char c) {\n    bool ver = true, hor = true;\n    if (pz[y-1][x] == '#' && pz[y+1][x] == '#') ver = false;\n    if (pz[y][x-1] == '#' && pz[y][x+1] == '#') hor = false;\n    if (issymbol(c)) {\n        if (pz[y-1][x] == '#' || pz[y+1][x] == '#' || issymbol(pz[y-1][x]) || issymbol(pz[y+1][x])) ver = false;\n        if (pz[y][x-1] == '#' || pz[y][x+1] == '#' || issymbol(pz[y][x-1]) || issymbol(pz[y][x+1])) hor = false;\n        if ( ! ver && ! hor) return false;\n    } else if (c == '0') {\n        if (pz[y-1][x] == '/' || pz[y][x-1] == '/' || isdigit(pz[y+1][x]) || isdigit(pz[y][x+1])) return false;\n    }\n    int tx, ty; string s; bool blank;\n    if (ver) {\n        blank=false; s=c; ty=y-1;\n        while (pz[ty][x] != '#') {\n            s=pz[ty][x]+s;\n            blank|=(pz[ty][x]=='.');\n            --ty;\n        }\n        ty=y+1;\n        while (pz[ty][x] != '#') {\n            s+=pz[ty][x];\n            blank|=(pz[ty][x]=='.');\n            ++ty;\n        }\n        for (int i=1; i<(int)s.size()-1; ++i) {\n            if ((i == 0 || issymbol(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return false;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    if (hor) {\n        blank=false; s=c; tx=x-1;\n        while (pz[y][tx] != '#') {\n            s=pz[y][tx]+s;\n            blank|=(pz[y][tx]=='.');\n            --tx;\n        }\n        tx=x+1;\n        while (pz[y][tx] != '#') {\n            s+=pz[y][tx];\n            blank|=(pz[y][tx]=='.');\n            ++tx;\n        }\n        for (int i=0; i<(int)s.size()-1; ++i) {\n            if ((i == 0 || issymbol(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return false;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    return true;\n}\n\nstring solve(int k, int si) {\n    if (n <= k) return \"Yes\";\n    for (int i=si; i<n; ++i) {\n        if ( ! used[i] && ok(bx[i], by[i], ch[k])) {\n            used[i] = true;\n            pz[by[i]][bx[i]] = ch[k];\n            string res = solve(k+1, (n<=k+1 || ch[k+1]==ch[k]) ? i+1 : 0);\n            used[i] = false;\n            pz[by[i]][bx[i]] = '.';\n            if (res == \"Yes\") return res;\n        }\n    }\n    return \"No\";\n}\n\nbool cmb(const char& l, const char& r) {\n    if (l == '=') return true;\n    if (r == '=') return false;\n    return l < r;\n}\n\nint main() {\n    while (cin >> H >> W, H) {\n        for (int i=0; i<12; ++i) {\n            for (int j=0; j<12; ++j) {\n                pz[i][j] = '#';\n            }\n        }\n        bx.clear(); by.clear();\n        for (int i=1; i<=H; ++i) {\n            for (int j=1; j<=W; ++j) {\n                cin >> pz[i][j];\n                if (pz[i][j] == '.') {\n                    bx.push_back(j);\n                    by.push_back(i);\n                }\n            }\n        }\n        cin >> n;\n        ch.clear();\n        char c;\n        for (int i=0; i<n; ++i) {\n            cin >> c;\n            ch.push_back(c);\n        }\n        sort(ch.begin(), ch.end(), cmb);\n        memset(used, false, sizeof used);\n        cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntuple<int,int> number(const string& s,int i)\n{\n\tint x=0;\n\tif(i>=s.size() || !isdigit(s[i])) return mt(INF,-1);\n\tfor(int len=0;i<s.size() && isdigit(s[i]);i++,len++){\n\t\tif(len==1 && x==0) return mt(INF,-1);\n\t\tx=x*10+s[i]-'0';\n\t}\n\treturn mt(x,i);\n}\ntuple<int,int> term(const string& s,int i)\n{\n\tint x; tie(x,i)=number(s,i);\n\tif(i==-1) return mt(INF,-1);\n\twhile(i<s.size() && (s[i]=='*' || s[i]=='/')){\n\t\tchar op=s[i];\n\t\tint y; if(get<1>(tie(y,i)=number(s,i+1))==-1) return mt(INF,-1);\n\t\tif(op=='*') x*=y;\n\t\tif(op=='/'){\n\t\t\tif(y==0 || x%y>0) return mt(INF,-1);\n\t\t\tx/=y;\n\t\t}\n\t}\n\treturn mt(x,i);\n}\ntuple<int,int> expr(const string& s,int i)\n{\n\tint x; if(get<1>(tie(x,i)=term(s,i))==-1) return mt(INF,-1);\n\twhile(i<s.size()){\n\t\tchar op=s[i];\n\t\tif(op!='+' && op!='-') return mt(INF,-1);\n\t\tint y; if(get<1>(tie(y,i)=term(s,i+1))==-1) return mt(INF,-1);\n\t\tif(op=='+') x+=y;\n\t\tif(op=='-') x-=y;\n\t}\n\treturn mt(x,i);\n}\n\nbool check(const vector<char*>& f)\n{\n\tstring s; for(char* p:f) s+=*p;\n\tif(count(all(s),'=')!=1) return false;\n\tint eq=s.find('=');\n\tif(eq==0 || eq==s.size()-1) return false;\n\tstring a=s.substr(0,eq),b=s.substr(eq+1);\n\tauto x=get<0>(expr(a,0)),y=get<0>(expr(b,0));\n\treturn x!=INF && y!=INF && x==y;\n}\n\nbool solve(int i,vs& grid,string& cs,const vi& is,const vi& js,const vector<vector<char*>>& fs,const vvi& ds)\n{\n\tif(i==cs.size()) return true;\n\t\n\tfor(char& c:cs) if(c!='X'){\n\t\tgrid[is[i]][js[i]]=c; c='X';\n\t\tif(all_of(all(ds[i]),[&](int j){return check(fs[j]);}))\n\t\t\tif(solve(i+1,grid,cs,is,js,fs,ds))\n\t\t\t\treturn true;\n\t\tc=grid[is[i]][js[i]];\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint n; cin>>n;\n\t\tstring cs(n,'~');\n\t\trep(i,n) cin>>cs[i];\n\t\t\n\t\tvi is,js;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='.'){\n\t\t\tis.push_back(i);\n\t\t\tjs.push_back(j);\n\t\t}\n\t\tvector<vector<char*>> fs;\n\t\trep(i,h) rep(j,w) if(grid[i][j]!='#'){\n\t\t\tif((i==0 || grid[i-1][j]=='#') && i<h-1 && grid[i+1][j]!='#'){\n\t\t\t\tvector<char*> f;\n\t\t\t\tfor(int k=i;k<h && grid[k][j]!='#';k++)\n\t\t\t\t\tf.push_back(&grid[k][j]);\n\t\t\t\tfs.push_back(f);\n\t\t\t}\n\t\t\tif((j==0 || grid[i][j-1]=='#') && j<w-1 && grid[i][j+1]!='#'){\n\t\t\t\tvector<char*> f;\n\t\t\t\tfor(int k=j;k<w && grid[i][k]!='#';k++)\n\t\t\t\t\tf.push_back(&grid[i][k]);\n\t\t\t\tfs.push_back(f);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(any_of(all(fs),[&](const vector<char*>& f)->bool{\n\t\t\t\tstring s; for(char* p:f) s+=*p;\n\t\t\t\treturn s.find('.')==-1 && !check(f);\n\t\t\t})){\n\t\t\tcout<<\"No!\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvvi ds(n);\n\t\t{\n\t\t\tvi vis(fs.size());\n\t\t\trep(i,n){\n\t\t\t\tgrid[is[i]][js[i]]='?';\n\t\t\t\trep(j,fs.size()) if(!vis[j]){\n\t\t\t\t\tstring s; for(char* p:fs[j]) s+=*p;\n\t\t\t\t\tif(s.find('.')==-1)\n\t\t\t\t\t\tds[i].push_back(j),vis[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,n) grid[is[i]][js[i]]='.';\n\t\t}\n\t\t\n\t\tcout<<(solve(0,grid,cs,is,js,fs,ds)?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int INF = 1<<24;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  //  int st = pos;\n  //  int l = 0;\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  if(pos+1 < s.size() && s[pos] == '0' && isdigit(s[pos+1])) {\n    //if(s[st] == '0') {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  string num = \"\";\n  while(pos < s.size() && isdigit(s[pos])) {\n    num += s[pos++];\n  }\n\n  return atoi(num.c_str());\n  //return atoi(s.substr(st, l).c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int value = getNum(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      value = getNum(s, pos);\n      if(value == INF) return INF;\n      x *= value;\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == INF) return INF;\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn INF;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int value = term(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x += value;\n    } else if(s[pos] == '-') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x -= value;\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n\n      }\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n    sort(T, T+N);\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 15)) return false;\n    if(k == L) return true;\n    vector<int> perm;\n    for(int i = 0; i < vc.size(); i++) if(!used[i]) perm.push_back(i);\n    random_shuffle(perm.begin(), perm.end());\n    for(auto i : perm) {\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// 4:37\n// 4:40 coding\n\n\nchar nowtable[128];\nstring s;\nint p;\nint A();\nint B();\nint C();\nint D();\nint calc(string _str){\n\ttry{\n\t\tp = 0;\n\t\ts = _str;\n\t\ts += \"~\";\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( s[i] >= 'A' && s[i] <= 'Z' ){\n\t\t\t\tif( nowtable[s[i]] == 0 ) return 2;\n\t\t\t\ts[i] = nowtable[s[i]];\n\t\t\t}\n\t\t}\n\t\tint res = A();\n\t\t\n\t\tif( s[p] != '~' ) throw \"not end\";\n\t\treturn res;\n\t}catch(const char *msg){\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\nint A(){\n\t\n\tint x = B();\n\tif( s[p] == '=' ){\n\t\tp++;\n\t\tint y = B();\n\t\treturn x == y;\n\t}else{\n\t\tthrow \"A\";\n\t}\n}\nint B(){\n\tint x = C();\n\twhile( s[p] == '+' || s[p] == '-' ){\n\t\tif( s[p] == '+'){\n\t\t\tp++;\n\t\t\tx += C();\n\t\t}else{\n\t\t\tp++;\n\t\t\tx -= C();\n\t\t}\n\t}\n\treturn x;\n}\nint C(){\n\tint x = D();\n\twhile( s[p] == '*' || s[p] == '/' ){\n\t\tif( s[p] == '*'){\n\t\t\tp++;\n\t\t\tx *= D();\n\t\t}else{\n\t\t\tp++;\n\t\t\tint r = D();\n\t\t\tif(r==0) throw \"zero\";\n\t\t\tif(x%r) throw \"modulo\";\n\t\t\tx /= r;\n\t\t}\n\t}\n\treturn x;\n}\nint D(){\n\t\n\tint x = 0;\n\n\tif( !(s[p]>='1'&&s[p]<='9') ) throw \"wrong number\";\n\twhile( s[p]>='1'&&s[p]<='9'){\n\t\tx = x*10+s[p++]-'0';\n\t}\n\t\n\treturn x;\n}\n\nchar t[12][12];\nvector<char> use;\n\nint used[10];\nvector<string> hoge;\nint check(){\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint r = calc(hoge[i]);\n\t\tif( r == 2 ) continue;\n\t\tif( !r ) return 0;\n\t}\n\treturn 1;\n}\nint N;\nint dfs(){\n\tif( !check() ) return 0;\n\tvector< pair<int,int> > v;\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint c = 0;\n\t\tfor(int j = 0 ; j < hoge[i].size() ; j++){\n\t\t\tif( nowtable[hoge[i][j]] == 0 ){\n\t\t\t\t\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif(c){\n\t\t\tv.push_back(make_pair(c,i));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tif( v.size() == 0 ) return 1;\n\t\n\tint idx = v[0].second;\n\tfor(int j = 0 ; j < hoge[idx].size() ; j++){\n\t\tif( nowtable[hoge[idx][j]] == 0 ){\n\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\tif( !used[k] ){\n\t\t\t\t\tnowtable[hoge[idx][j]] = use[k];\n\t\t\t\t\tused[k] = true;\n\t\t\t\t\tif( dfs() ) return true;\n\t\t\t\t\tused[k] = false;\n\t\t\t\t\tnowtable[hoge[idx][j]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\t\n\tint H,W;\n\twhile( cin >> H >> W && H){\n\t\tfor(int i = 0 ; i < 128 ; i++) nowtable[i] = -1;\n\t\tfor(int i = 0 ; i < 10 ; i++) used[i] = 0;\n\t\tfor(int i = 'A' ; i <= 'Z' ; i++) nowtable[i] = 0;\n\t\tuse.clear();\n\t\thoge.clear();\n\t\tfor(int i = 0 ; i < 12 ; i++)\n\t\t\tfor(int j = 0 ; j < 12 ; j++)\n\t\t\t\tt[i][j] = '#';\n\t\n\t\tchar tmpAlpha = 'A';\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> t[i+1][j+1];\n\t\t\t\tif( t[i+1][j+1] == '.' ){\n\t\t\t\t\tt[i+1][j+1] = tmpAlpha++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tchar c; cin >> c;\n\t\t\tuse.push_back(c);\n\t\t}\n\t\tint ans = 0;\n\t\tvector<string> id;\n\t\t\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( t[i][j-1] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = j;\n\t\t\t\t\twhile( t[i][k] != '#' ){\n\t\t\t\t\t\tstr += t[i][k++];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( t[i-1][j] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = i;\n\t\t\t\t\twhile( t[k][j] != '#' ){\n\t\t\t\t\t\tstr += t[k++][j];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (dfs()?\"Yes\":\"No\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > 1000000) return false;\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!(isdigit(str[i]) && str[i]!='0')) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id, bool f=1) {\n  if (s.size() < 2) return 1;\n  if (f) {\n    if ((id == 0 || isoperator(s[id-1])) && (!isdigit(s[id]) || s[id] == '0')) return 0;\n    if ((id == s.size()-1 || isoperator(s[id+1])) && !isdigit(s[id])) return 0;\n  }\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    assert(pos.size() == n);\n    bool ok = 1;\n    FOR(it, v) ok &= check(*it,0,0);\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (ok&&dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false; \n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!(isdigit(str[i]) && str[i]!='0')) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id) {\n  if (s.size() < 2) return 1;\n  if ((id == 0 || isoperator(s[id-1])) && (!isdigit(s[id]) || s[id] == '0')) return 0;\n  if ((id == s.size()-1 || isoperator(s[id+1])) && !isdigit(s[id])) return 0;\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          continue;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) continue;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) continue;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nconstexpr int tsurai=123456789;\n\nint parse_int(const std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i]-'0';\n  while (++i < s.length() && isdigit(s[i])) {\n    res = res*10 + s[i]-'0';\n  }\n  return res;\n}\n\nint fourt(const std::string &s, size_t &i) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length() && isdigit(s[i])) {\n    int cur=parse_int(s, i);\n    while (i < s.length() && s[i] != '=') {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (tmp == 0 || cur % tmp) return tsurai;\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n    if (sgn == '+') {\n      res += cur;\n    } else {\n      res -= cur;\n    }\n    if (i < s.length() && s[i] != '=') {\n      sgn = s[i++];\n    }\n  }\n  return res;\n}\n\nbool valid(const std::vector<std::string> &eqs, const std::vector<char> &cs) {\n  for (/* not const */ std::string eq: eqs) {\n    for (char &ch: eq)\n      if (ch >= 'A' && ch <= 'Z')\n        ch = cs[ch-'A'];\n\n    if (eq[0] == '=' || eq.back() == '=')\n      return false;\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] != '0') {\n        do {\n          ++i;\n        } while (i < eq.length() && isdigit(eq[i]));\n      } else {\n        if (i+1 < eq.length() && isdigit(eq[i+1]))\n          return false;\n      }\n    }\n\n    size_t i=0;\n    if (!isdigit(eq[i])) return false;\n    int lhs=fourt(eq, i);\n    if (lhs == tsurai) return false;\n    assert(eq[i] == '=');\n    ++i;\n    if (!isdigit(eq[i])) return false;\n    int rhs=fourt(eq, i);\n    if (rhs == tsurai) return false;\n    assert(i == eq.length());\n    \n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0)\n    return 1;\n\n  size_t ph='A';  // placeholder\n  std::vector<std::string> s(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] == '.')\n        s[i][j] = ph++;\n    }\n  }\n\n  std::vector<std::string> eqs;\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> cs(n);\n  for (size_t i=0; i<n; ++i)\n    scanf(\" %c\", &cs[i]);\n\n  std::sort(cs.begin(), cs.end());\n  do {\n    if (valid(eqs, cs))\n      return !printf(\"Yes\\n\");\n  } while (std::next_permutation(cs.begin(), cs.end()));\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int UND = 1<<30;\nint h, w;\nchar pz[12][12];\nchar cur[12][12];\nbool used[12][12];\n\nbool ans;\n\nclass Parser\n{\npublic:\n\tstring exp;\n\tint p;\n\tvoid Eq (void );\n\tint Ex (void );\n\tint N (void );\n};\n\nvoid Parser::Eq (void )\n{\n\tint value1 = 0, value2 = 0;\n#if DEBUG\n\tcout << \"exp: \" << exp << endl;\n#endif\n\tvalue1 = Ex();\n\n\tif (value1 == UND ) ans = false;\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tint val = 0;\n\t\tif (exp[p] == '+' ){\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue1 += val;\n\t\t}else{\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue1 -= val;\t\t\n\t\t} // end if\n\t} // end while\n\n\tif (exp[p] == '=' ){\n\t\t++p;\n\t} // end if\n\n\tvalue2 = Ex();\t\t\t\n\n\tif (value2 == UND ) ans = false;\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tint val = 0;\n\t\tif (exp[p] == '+' ){\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue2 += val;\n\t\t}else{\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue2 -= val;\t\t\n\t\t} // end if\n\t} // end while\n\n\tif (value1 != value2 )\n\t\tans = false;\n#if DEBUG\n\tcout << \"ans: \" << (ans ? \"YES\" : \"NO\" ) << endl;\n#endif\n}\n\nint Parser::Ex (void )\n{\n\tint value = N();\n\n\tif (value == UND ) ans = false;\n\n\twhile (exp[p] == '*' || exp[p] == '/' ){\n\t\tif (exp[p] == '*' ){\n\t\t\t++p;\n\t\t\tint val = N();\n\t\t\tif (val == UND ){\n\t\t\t\tvalue = UND;\n\t\t\t\tans = false;\n\t\t\t}else{\n\t\t\t\tvalue *= val;\n\t\t\t} // end if\n\t\t}else{\n\t\t\t++p;\n\t\t\tint val = N();\n//\t\t\tif (value != 0 && val != 0 && value % val == 0 ){\n\t\t\tif (value != UND && val != UND && val != 0 && value % val == 0 ){\n\t\t\t\tvalue /= val;\n\t\t\t}else{\n\t\t\t\tvalue = UND;\n\t\t\t\tans = false;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end while\n\t\n\treturn value;\n}\n\nint Parser::N (void )\n{\n\tint value = 0;\n\tint cnt = 0;\n\tchar first = 0;\n\tif (!isdigit(exp[p] ) )\n\t\treturn UND;\n\n\twhile (isdigit(exp[p] ) ){\n\t\tif (cnt == 0 ){\n\t\t\tfirst = exp[p];\n\t\t} // end if\n\t\tvalue *= 10;\n\t\tvalue += (exp[p] - '0');\n\t\tcnt++;\n\t\tp++;\n\t} // end while\n\n\tif ( (first == '0' && cnt > 1 ) || (cnt > 2 ) )\n\t\tans = false;\n\n\treturn value;\n}\n\nvoid disp_pz (void )\n{\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tcout << cur[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep \n}\n\n\nvoid make_pz (vector<char> ope )\n{\n\tmemset (cur, 0, sizeof (cur ) );\n\tint k = 0;\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tif (pz[i][j] == '.' ){\n\t\t\t\tcur[i][j] = ope[k++];\n\t\t\t}else{\n\t\t\t\tcur[i][j] = pz[i][j];\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n#if DEBUG\n\tdisp_pz ();\n\tcout << endl;\n#endif\n}\n\nbool evaluate_exp (string exp )\n{\n\tParser parser;\n\tparser.exp = exp;\n\tparser.p = 0;\n\tans = true;\n\tparser.Eq();\n\n\treturn ans;\t\n}\n\nbool is_correct (void )\n{\n\tconst int dir[][2] = { { 0, 0 }, { 1, 0 }, { 0, 1 } };\n\n\tmemset (used, false, sizeof (used ) );\n\tstack<P> u;\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tif (cur[i][j] != '#' ){\n\t\t\t\tint k1 = 0, k2 = 0;\n\t\t\t\tif (!used[i][j] ){\n\t\t\t\t\tk1 = 0, k2 = 2;\n\t\t\t\t}else{ // if (used[i][j] )\n\t\t\t\t\tint dsum = 0;\n\t\t\t\t\trep (d, 3 ){\n\t\t\t\t\t\tint ni = i + dir[d][0];\n\t\t\t\t\t\tint nj = j + dir[d][1];\n\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= h || nj >= w || cur[ni][nj] == '#' ) continue;\n\t\t\t\t\t\tif (!used[ni][nj] ){\n\t\t\t\t\t\t\tdsum += d;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end rep\n\t\t\t\t\tswitch (dsum ){\n\t\t\t\t\t\tcase 1: k1 = 0, k2 = 1; break;\n\t\t\t\t\t\tcase 2: k1 = 1, k2 = 2; break;\n\t\t\t\t\t\tcase 3: k1 = 0, k2 = 2; break;\n\t\t\t\t\t\tdefault: k1 = 0, k2 = 0; break;\n\t\t\t\t\t} // end switch\n\t\t\t\t} // end if\n\t\t\t\tfor (int k = k1; k < k2; k++ ){\n\t\t\t\t\tbool equ = false;\n\t\t\t\t\tstring exp = \"\";\n\t\t\t\t\tfor (int e = (k == 0 ? i : j ); e < (k == 0 ? h : w ); e++ ){\n\t\t\t\t\t\tint row = (k == 0 ? e : i );\n\t\t\t\t\t\tint col = (k == 0 ? j : e );\n\t\t\t\t\t\tif (cur[row][col] != '#' ){\n\t\t\t\t\t\t\tif (cur[row][col] != '=' ){\n\t\t\t\t\t\t\t\texp += cur[row][col];\n\t\t\t\t\t\t\t\tused[row][col] = true;\n\t\t\t\t\t\t\t\tu.push (P (row, col ) );\n\t\t\t\t\t\t\t}else\n\t\t\t\t\t\t\tif (!equ ){\n\t\t\t\t\t\t\t\texp += cur[row][col];\n\t\t\t\t\t\t\t\tused[row][col] = true;\n\t\t\t\t\t\t\t\tu.push (P (row, col ) );\n\t\t\t\t\t\t\t\tequ = true;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif (equ ){\n\t\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twhile (!u.empty() ){\n\t\t\t\t\t\t\t\t\tP c = u.top(); u.pop();\n\t\t\t\t\t\t\t\t\tused[c.first][c.second] = false;\n\t\t\t\t\t\t\t\t} // end while\n\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end for\n\t\t\t\t\tif (!exp.empty() ){\n\t\t\t\t\t\tif (equ ){\n\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twhile (!u.empty() ){\n\t\t\t\t\t\t\t\tP c = u.top(); u.pop();\n\t\t\t\t\t\t\t\tused[c.first][c.second] = false;\n\t\t\t\t\t\t\t} // end while\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end if\n\t\t\t\t} // end for\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\treturn true;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.indian_puzzle\", \"r\", stdin );\n//\twhile (scanf (\"%d %d\", &h, &w ) && h && w ){\n\twhile (cin >> h >> w && h && w ){\n//\t\tcout << \"h: \" << h << \" w: \" << w << endl;\n\t\tmemset (pz, 0, sizeof (pz ) );\n\t\trep (i, h ){\n\t\t\tstring in = \"\";\n\t\t\tcin >> in;\n\t\t\trep (j, w ){\n\t\t\t\tpz[i][j] = in[j];\n//\t\t\t\tscanf (\"%c\", &pz[i][j] );\n\t\t\t} // end rep\n\t\t} // end rep\n\t\t\n//\t\tdisp_pz ();\n\n\t\tint n;\n\t\tcin >> n;\n//\t\tscanf (\"%d\", &n );\n\t\tvector<char> ope (n, 0 );\n\t\trep (i, n ){\n//\t\t\tscanf (\"%c\", ope[i] );\n\t\t\tcin >> ope[i];\n\t\t} // end rep\n\t\tsort (ALL (ope ) );\n\t\tbool found = false;\n\t\tdo{\n\t\t\tmake_pz (ope );\n\t\t\tif (is_correct () ){\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t}while (next_permutation (ALL (ope ) ) );\n\t\t\n\t\tif (found ){\n\t\t\tprintf (\"Yes\\n\" );\n\t\t}else{\n\t\t\tprintf (\"No\\n\" );\n\t\t} // end if\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct invalid {};\ntypedef const char *Iterator;\n\nint eval_factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw invalid();\n  }\n  if (*it < '0' || '9' < *it) {\n    throw invalid();\n  }\n  int val = *it - '0';\n  ++it;\n  if (val == 0) {\n    return val;\n  }\n  while (it != last && '0' <= *it && *it <= '9') {\n    val = 10*val + (*it - '0');\n    ++it;\n  }\n  return val;\n}\n\nint eval_term(Iterator& it, const Iterator& last)\n{\n  int val = eval_factor(it, last);\n  while (it != last && (*it == '*' || *it == '/')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_factor(it, last);\n    if (op == '*') {\n      val *= x;\n    } else {\n      val /= x;\n    }\n  }\n  return val;\n}\n\nint eval_expr(Iterator& it, const Iterator& last)\n{\n  int val = eval_term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_term(it, last);\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return val;\n}\n\nbool check(Iterator it, const Iterator& last) try\n{\n  const int l = eval_expr(it, last);\n  if (it == last || *it != '=') {\n    return false;\n  }\n  ++it;\n  const int r = eval_expr(it, last);\n  return it == last && l == r;\n} catch (const invalid&) {\n  return false;\n}\n\nstatic const int M = 15;\n\nbool extract_expr(char (*dst)[M], pair<int,int> (*tbl)[2], const char rows[M][M], int H, int W, int& s)\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (j == 0 || rows[i][j-1] == '#') {\n        const int k = j;\n        ++j;\n        while (j < W && rows[i][j] != '#') {\n          ++j;\n        }\n        if (j-k > 2) {\n          bool b = false;\n          for (int l = k; l < j; l++) {\n            dst[s][l] = rows[i][l];\n            if (rows[i][l] >= 'a') {\n              b = true;\n              pair<int,int> *t = tbl[rows[i][l]-'a'];\n              if (t[0].first != -1) {\n                t[1].first = s;\n                t[1].second = l;\n              } else {\n                t[0].first = s;\n                t[0].second = l;\n              }\n            }\n          }\n          if (b) {\n            dst[s][j-k] = '\\0';\n            ++s;\n          } else {\n            if (!check(rows[i]+k, rows[i]+j)) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(char (*exprs)[M], int s, char *cards, int N, const pair<int,int> (*tbl)[2])\n{\n  do {\n    for (int i = 0; i < N; i++) {\n      if (tbl[i][0].first >= 0) {\n        exprs[tbl[i][0].first][tbl[i][0].second] = cards[i];\n      }\n      if (tbl[i][1].first >= 0) {\n        exprs[tbl[i][1].first][tbl[i][1].second] = cards[i];\n      }\n    }\n    for (int i = 0; i < s; i++) {\n      if (!check(exprs[i], exprs[i]+strlen(exprs[i]))) {\n        goto FAIL;\n      }\n    }\n    return true;\nFAIL:\n    ;\n  } while (next_permutation(cards, cards+N));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (scanf(\"%d %d\", &H, &W) != EOF && H != 0) {\n    char rows[M][M], cols[M][M];\n    int n = 0;\n    for (int i = 0; i < H; i++) {\n      scanf(\"%s\", rows[i]);\n      for (int j = 0; j < W; j++) {\n        if (rows[i][j] == '.') {\n          rows[i][j] = 'a' + n;\n          ++n;\n        }\n        cols[j][i] = rows[i][j];\n        cols[j][H] = '\\0';\n      }\n    }\n    int N;\n    scanf(\"%d\", &N);\n    char cards[M];\n    for (int i = 0; i < N; i++) {\n      char buf[4];\n      scanf(\"%s\", buf);\n      cards[i] = buf[0];\n    }\n    sort(cards, cards+N);\n    cards[N] = '\\0';\n\n    static char exprs[20][M];\n    static pair<int,int> tbl[10][2];\n    for (int i = 0; i < 10; i++) {\n      tbl[i][0].first = tbl[i][1].second = -1;\n    }\n    int s = 0;\n    if (!extract_expr(exprs, tbl, rows, H, W, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (!extract_expr(exprs, tbl, cols, W, H, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (solve(exprs, s, cards, N, tbl)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if (legal(q) and incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if (legal(q) and incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) continue;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) continue;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "puts \"Hello World\""
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if ((not legal(q)) or incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if ((not legal(q)) or incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) goto INCORRECT;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) goto INCORRECT;\n      }\n      return true;\n\nINCORRECT:\n      ;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <exception>\n#include <fstream>\nusing namespace std;\n\nconst int LIM = 10;\n\nint H, W, n;\nchar pz[12][12];\n\nvector<int> bx, by;\nbool used[LIM];\nvector<char> ch;\n\nclass Evaluator {\npublic:\n    static int num(string &s, int &k) {\n        int a = 0;\n        while (isdigit(s[k])) {\n            a = a * 10 + (s[k] - '0'); ++k;\n        }\n        return a;\n    }\n    static int mul(string &s, int &k) {\n        int a = num(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '*') a *= mul(s, ++k);\n            else if (s[k] == '/') {\n                int b = mul(s, ++k);\n                if (b == 0) throw 0; // DivisionByZero\n                else if (a % b != 0) throw 1; // LeavingRemaindar\n                a /= b;\n            }\n            else break;\n        }\n        return a;\n    }\n    static int add(string &s, int &k) {\n        int a = mul(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '+') a += mul(s, ++k);\n            else if (s[k] == '-') a -= mul(s, ++k);\n            else break;\n        }\n        return a;\n    }\n    static bool eq(string &s, int &k) {\n        int a = add(s, k);\n        if (k < (int)s.size() && s[k] == '=') {\n            int b = add(s, ++k);\n            if (k < (int)s.size()) return false;\n            return a == b;\n        }\n        return false;\n    }\n    static bool run(string s) {\n        int k; bool ret;\n        try {\n            ret = eq(s, k=0);\n        } catch (int) {\n            ret = false;\n        }\n        return ret;\n    }\n};\n\nbool issymbol(char c) {\n    return c=='+' || c=='-' || c=='*' || c=='/' || c=='=';\n}\n\nbool ok(int x, int y, char c) {\n    bool ver = true, hor = true;\n    if (pz[y-1][x] == '#' && pz[y+1][x] == '#') ver = false;\n    if (pz[y][x-1] == '#' && pz[y][x+1] == '#') hor = false;\n    if (issymbol(c)) {\n        if (pz[y-1][x] == '#' || pz[y+1][x] == '#' || issymbol(pz[y-1][x]) || issymbol(pz[y+1][x])) ver = false;\n        if (pz[y][x-1] == '#' || pz[y][x+1] == '#' || issymbol(pz[y][x-1]) || issymbol(pz[y][x+1])) hor = false;\n        if ( ! ver && ! hor) return false;\n    } else if (c == '0') {\n        if (pz[y-1][x] == '/' || pz[y][x-1] == '/' || isdigit(pz[y+1][x]) || isdigit(pz[y][x+1])) return false;\n    }\n    int tx, ty; string s; bool blank;\n    if (ver) {\n        blank=false; s=c; ty=y-1;\n        while (pz[ty][x] != '#') {\n            s=pz[ty][x]+s;\n            blank|=(pz[ty][x]=='.');\n            --ty;\n        }\n        ty=y+1;\n        while (pz[ty][x] != '#') {\n            s+=pz[ty][x];\n            blank|=(pz[ty][x]=='.');\n            ++ty;\n        }\n        if (blank) return true;\n        for (int i=1; i<(int)s.size()-1; ++i) {\n            if ((i == 0 || ! isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return false;\n        }\n        if (1<(int)s.size() && ! Evaluator::run(s)) return false;\n    }\n    if (hor) {\n        blank=false; s=c; tx=x-1;\n        while (pz[y][tx] != '#') {\n            s=pz[y][tx]+s;\n            blank|=(pz[y][tx]=='.');\n            --tx;\n        }\n        tx=x+1;\n        while (pz[y][tx] != '#') {\n            s+=pz[y][tx];\n            blank|=(pz[y][tx]=='.');\n            ++tx;\n        }\n        if (blank) return true;\n        for (int i=0; i<(int)s.size()-1; ++i) {\n            if ((i == 0 || ! isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return false;\n        }\n        if (1<(int)s.size() && ! Evaluator::run(s)) return false;\n    }\n    return true;\n}\n\nstring solve(int k, int si) {\n    if (n <= k) return \"Yes\";\n    for (int i=si; i<n; ++i) {\n        if ( ! used[i] && ok(bx[i], by[i], ch[k])) {\n            used[i] = true;\n            pz[by[i]][bx[i]] = ch[k];\n            string res = solve(k+1, (n<=k+1 || ch[k+1]==ch[k]) ? i+1 : 0);\n            used[i] = false;\n            pz[by[i]][bx[i]] = '.';\n            if (res == \"Yes\") return res;\n        }\n    }\n    return \"No\";\n}\n\nbool cmb(const char& l, const char& r) {\n    if (l == '=') return true;\n    if (r == '=') return false;\n    return l < r;\n}\n\nint main() {\n    while (cin >> H >> W, H) {\n        for (int i=0; i<12; ++i) {\n            for (int j=0; j<12; ++j) {\n                pz[i][j] = '#';\n            }\n        }\n        bx.clear(); by.clear();\n        for (int i=1; i<=H; ++i) {\n            for (int j=1; j<=W; ++j) {\n                cin >> pz[i][j];\n                if (pz[i][j] == '.') {\n                    bx.push_back(j);\n                    by.push_back(i);\n                }\n            }\n        }\n        cin >> n;\n        ch.clear();\n        char c;\n        for (int i=0; i<n; ++i) {\n            cin >> c;\n            ch.push_back(c);\n        }\n        sort(ch.begin(), ch.end(), cmb);\n        memset(used, false, sizeof used);\n        cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct invalid {};\ntypedef const char *Iterator;\n\nint eval_factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw invalid();\n  }\n  if (*it < '0' || '9' < *it) {\n    throw invalid();\n  }\n  int val = *it - '0';\n  ++it;\n  if (val == 0) {\n    return val;\n  }\n  while (it != last && '0' <= *it && *it <= '9') {\n    val = 10*val + (*it - '0');\n    ++it;\n  }\n  return val;\n}\n\nint eval_term(Iterator& it, const Iterator& last)\n{\n  int val = eval_factor(it, last);\n  while (it != last && (*it == '*' || *it == '/')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_factor(it, last);\n    if (op == '*') {\n      val *= x;\n    } else {\n      val /= x;\n    }\n  }\n  return val;\n}\n\nint eval_expr(Iterator& it, const Iterator& last)\n{\n  int val = eval_term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_term(it, last);\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return val;\n}\n\nbool check(Iterator it, const Iterator& last) try\n{\n  const int l = eval_expr(it, last);\n  if (it == last || *it != '=') {\n    return false;\n  }\n  ++it;\n  const int r = eval_expr(it, last);\n  return it == last && l == r;\n} catch (const invalid&) {\n  return false;\n}\n\nstatic const int M = 15;\n\nbool extract_expr(char (*dst)[M], pair<int,int> (*tbl)[2], const char rows[M][M], int H, int W, int& s)\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (j == 0 || rows[i][j-1] == '#') {\n        const int k = j;\n        ++j;\n        while (j < W && rows[i][j] != '#') {\n          ++j;\n        }\n        if (j-k > 2) {\n          bool b = false;\n          for (int l = k; l < j; l++) {\n            dst[s][l] = rows[i][l];\n            if (rows[i][l] >= 'a') {\n              b = true;\n              pair<int,int> *t = tbl[rows[i][l]-'a'];\n              if (t[0].first != -1) {\n                t[1].first = s;\n                t[1].second = l;\n              } else {\n                t[0].first = s;\n                t[0].second = l;\n              }\n            }\n          }\n          dst[s][j-k] = '\\0';\n          ++s;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(char (*exprs)[M], int s, char *cards, int N, const pair<int,int> (*tbl)[2])\n{\n  do {\n    for (int i = 0; i < N; i++) {\n      if (tbl[i][0].first >= 0) {\n        exprs[tbl[i][0].first][tbl[i][0].second] = cards[i];\n      }\n      if (tbl[i][1].first >= 0) {\n        exprs[tbl[i][1].first][tbl[i][1].second] = cards[i];\n      }\n    }\n    for (int i = 0; i < s; i++) {\n      if (!check(exprs[i], exprs[i]+strlen(exprs[i]))) {\n        goto FAIL;\n      }\n    }\n    return true;\nFAIL:\n    ;\n  } while (next_permutation(cards, cards+N));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (scanf(\"%d %d\", &H, &W) != EOF && H != 0) {\n    char rows[M][M], cols[M][M];\n    int n = 0;\n    for (int i = 0; i < H; i++) {\n      scanf(\"%s\", rows[i]);\n      for (int j = 0; j < W; j++) {\n        if (rows[i][j] == '.') {\n          rows[i][j] = 'a' + n;\n          ++n;\n        }\n        cols[j][i] = rows[i][j];\n        cols[j][H] = '\\0';\n      }\n    }\n    int N;\n    scanf(\"%d\", &N);\n    char cards[M];\n    for (int i = 0; i < N; i++) {\n      char buf[4];\n      scanf(\"%s\", buf);\n      cards[i] = buf[0];\n    }\n    sort(cards, cards+N);\n    cards[N] = '\\0';\n\n    static char exprs[100][M];\n    static pair<int,int> tbl[10][2];\n    for (int i = 0; i < 10; i++) {\n      tbl[i][0].first = tbl[i][1].second = -1;\n    }\n    int s = 0;\n    if (!extract_expr(exprs, tbl, rows, H, W, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (!extract_expr(exprs, tbl, cols, W, H, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (s == 0) {\n      puts(\"Yes\");\n      continue;\n    }\n    if (solve(exprs, s, cards, N, tbl)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, MAX_N> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint parse(const string &s, int l, int r) {\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '+') return parse(s, l, i) + parse(s, i + 1, r);\n\t\tif(s[i] == '-') return parse(s, l, i) - parse(s, i + 1, r);\n\t}\n\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '*') return parse(s, l, i) * parse(s, i + 1, r);\n\t\tif(s[i] == '/') {\n\t\t\tconst int left = parse(s, l, i);\n\t\t\tconst int right = parse(s, i + 1, r);\n\n\t\t\tif(right == 0) throw \"division by zero\";\n\t\t\tif(left % right) throw \"division leaving a remainder\";\n\n\t\t\treturn left / right;\n\t\t}\n\t}\n\n\tif(r <= l || !isdigit(s[l]) || (s[l] == '0' && r - l > 1)) throw \"parse error\";\n\treturn stoi(s.substr(l, r - l));\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tif(parse(left, 0, left.size()) != parse(right, 0, right.size())) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w));\n\tint next = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '.') idx[i][j] = next++;\n\t\t}\n\t}\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tif(is_operator[i] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[i]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e] = true;\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tis_operator.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t\tif(in[i] == '+' || in[i] == '-' || in[i] == '*' || in[i] == '/') {\n\t\t\t\tis_operator[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  if (i == s.length()) {\n    succ = false;\n    return -1;\n  }\n\n  if (s[i] == '+' || s[i] == '-') {\n    succ = false;\n    return -1;\n  }\n\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (tmp == 0 || cur % tmp != 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq.back() == '=') return false;\n    if (!isdigit(eq[0]) || !isdigit(eq.back())) return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') {\n        if (i+1 < eq.length() && isdigit(eq[i+1]))\n          return false;\n      }\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n    if (!succ) return false;\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  string num = \"\";\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return -1;\n  }\n  while(pos < s.size() && isdigit(s[pos])) {\n    num += s[pos++];\n  }\n  if(num[0] == '0') {\n    pos = s.size();\n    flag = true;\n    return -1;\n  }\n  return atoi(num.c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int x = getNum(s, pos);\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      x *= getNum(s, pos);\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn -1;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int x = term(s, pos);\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      x += term(s, pos);\n    } else if(s[pos] == '-') {\n      ++pos;\n      x -= term(s, pos);\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nbool check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (!stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\t\n\tvector< Equation > eqs = findEquations();\n\t\n\t//do {\n\tfor_(REP,0,20000) {\n\t\trandom_shuffle(symbol, symbol + n);\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) {\n\t\t\tflag &= eq.evaluate(s_map);\n\t\t\tif (!flag) break;\n\t\t}\n\t\tif (flag) return true;\n\t}\n\t//} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int INF = 1<<24;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  int st = pos;\n  int l;\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  while(pos < s.size() && isdigit(s[pos])) {\n    //    num += s[pos++];\n    ++pos;\n    ++l;\n  }\n  //if(num[0] == '0') {\n  if(s[st] == '0') {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  return atoi(s.substr(st, l).c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int value = getNum(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      value = getNum(s, pos);\n      if(value == INF) return INF;\n      x *= value;\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == INF) return INF;\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn INF;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int value = term(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x += value;\n    } else if(s[pos] == '-') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x -= value;\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n\n      }\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n    sort(T, T+N);\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct invalid {};\ntypedef const char *Iterator;\n\nint eval_factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw invalid();\n  }\n  if (*it < '0' || '9' < *it) {\n    throw invalid();\n  }\n  int val = *it - '0';\n  ++it;\n  if (val == 0) {\n    return val;\n  }\n  while (it != last && '0' <= *it && *it <= '9') {\n    val = 10*val + (*it - '0');\n    ++it;\n  }\n  return val;\n}\n\nint eval_term(Iterator& it, const Iterator& last)\n{\n  int val = eval_factor(it, last);\n  while (it != last && (*it == '*' || *it == '/')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_factor(it, last);\n    if (op == '*') {\n      val *= x;\n    } else {\n      val /= x;\n    }\n  }\n  return val;\n}\n\nint eval_expr(Iterator& it, const Iterator& last)\n{\n  int val = eval_term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_term(it, last);\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return val;\n}\n\nbool check(Iterator it, const Iterator& last) try\n{\n  const int l = eval_expr(it, last);\n  if (it == last || *it != '=') {\n    return false;\n  }\n  ++it;\n  const int r = eval_expr(it, last);\n  return it == last && l == r;\n} catch (const invalid&) {\n  return false;\n}\n\nstatic const int M = 15;\nbool valid(const char rows[M][M], int H, int W)\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (rows[i][j] != '#') {\n        if (j == 0 || rows[i][j-1] == '#') {\n          const int k = j;\n          ++j;\n          while (j < W && rows[i][j] != '#') {\n            ++j;\n          }\n          if (j-k > 2) {\n            if (!check(rows[i]+k, rows[i]+j)) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(char rows[M][M], char cols[M][M], int H, int W, const pair<int,int> *spaces, char *cards, int N)\n{\n  sort(cards, cards+N);\n  do {\n    for (int i = 0; i < N; i++) {\n      rows[spaces[i].first][spaces[i].second] = cards[i];\n      cols[spaces[i].second][spaces[i].first] = cards[i];\n    }\n    if (valid(rows, H, W) && valid(cols, W, H)) {\n      return true;\n    }\n  } while (next_permutation(cards, cards+N));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (scanf(\"%d %d\", &H, &W) != EOF && H != 0) {\n    char rows[M][M], cols[M][M];\n    pair<int,int> spaces[M];\n    pair<int,int> *p = spaces;\n    for (int i = 0; i < H; i++) {\n      scanf(\"%s\", rows[i]);\n      for (int j = 0; j < W; j++) {\n        cols[j][i] = rows[i][j];\n        cols[j][H] = '\\0';\n        if (rows[i][j] == '.') {\n          p->first = i;\n          p->second = j;\n          ++p;\n        }\n      }\n    }\n    int N;\n    scanf(\"%d\", &N);\n    char cards[M];\n    for (int i = 0; i < N; i++) {\n      char buf[4];\n      scanf(\"%s\", buf);\n      cards[i] = buf[0];\n    }\n    cards[N] = '\\0';\n    if (solve(rows, cols, H, W, spaces, cards, N)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, 128> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint factor(string::const_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\tthrow \"parse error\";\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tint tmp;\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t++it;\n\t\t\ttmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_minus[expression[i - 1]] = true;\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_minus[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w, -1));\n\tint next = 0;\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\tif(idx[k][j] == -1) idx[k][j] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\tif(idx[i][k] == -1) idx[i][k] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tconst char c = in[i];\n\t\tif(is_operator[c] && not_operator[idx]) continue;\n\t\tif(c == '0' && not_zero[idx]) continue;\n\t\tif(c == '-' && not_minus[idx]) continue;\n\n\t\tletters[idx] = c;\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[c]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tis_operator.fill(false);\n\tis_operator['+'] = true;\n\tis_operator['-'] = true;\n\tis_operator['*'] = true;\n\tis_operator['/'] = true;\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\t\trandom_shuffle(in.begin(), in.begin() + n);\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<int> bx, by;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bx.push_back(x); by.push_back(y); grid[y][x] = bx.size() - 1 + 'a';}\n\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    \n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*'){\n\tres*=num;\n      }\n      if(ch=='/'){\n\tif(num!=0&&res%num>=0)res/=num;\n\telse flag=true;\n\t\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w;\n\nbool solve();\nbool check();\nbool compute();\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(!check())return false;\n  }while(next_permutation(u,u+N));\n  return true;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++){\n    v=w[i];\n    if(compute())return true;\n  }\n  return false;\n}\n\nbool compute(){\n  for(int i=0;i<(int)v.size();i++)\n      if('A'<=v[i]&&v[i]<='Z')v[i]=u[v[i]-'A'];\n  string a=\"\",b=\"\";\n  bool flg=false;\n  b.push_back(v[0]);\n  for(int i=1;i<(int)v.size();i++){\n      if(!isNum(v[i-1])&&!isNum(v[i]))return false;\n      if(v[i]=='=')flg=true;\n      else if(flg)a.push_back(v[i]);\n      else b.push_back(v[i]);\n  }\n  if(!isNum(v[0])||!isNum(v[v.size()-1]))return false;\n\n\n  if(v[0]=='0'&&isNum(v[1]))return false;\n\n  if(flg==false)return false;\n\n  calcStr x,y;\n  x.s=a;\n  x.init();\n  y.s=b;\n  y.init();\n\n  int A = x.getAns();\n  int B = y.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) ((l)<=(x) && (x)<(r))\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1])) ){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint parse(int l, int r, const string &s){\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  int res = 0;\n  for(int i=l;i<r;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  return (parse(0,p,s) == parse(p+1,s.size(),s));\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n\n    cin >> n;\n    rep(i,n)cin >> c[i];\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (r == 0) throw 0;\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(char *s) {\n  try {\n    int n = strlen(s);\n    int pos = -1;\n    REP(i,strlen(s)) if (s[i]=='=') pos = i;\n    if (pos == -1 || pos == 0 || pos == n-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<n; ++i) str[i-pos-1] = s[i]; str[n-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\n\nchar a[10][10];\nchar b[10];\n\nchar eq[100][11];\n\nint h,w;\n\nbool inserted[10][10];\n\npii pos[100];\nint posNum;\nint eqNum;\nbool visited[10][10][2];\n\nvector<pii> ididx[10][10];\nint dotNum[100];\n\nbool bfs(int y, int x, int dy, int dx) {\n  char s[11];\n  int idx = 0;\n  vector<pii> v;\n  vector<int> id;\n  while(valid(y,x,h,w)) {\n    visited[y][x][dy] = 1;\n    if (a[y][x] == '#') break;\n    if (a[y][x] == '.') {\n      v.push_back(pii(y,x));\n      id.push_back(idx);\n    }\n    s[idx++] = a[y][x];\n    y += dy;\n    x += dx;\n  }\n  if (idx >= 2) {\n    s[idx] = 0;\n    if (v.size() == 0 && !check(s)) return 0;\n    dotNum[eqNum] = v.size();\n    strcpy(eq[eqNum], s);\n    REP(i,v.size()) {\n      int y = v[i].first, x = v[i].second;\n      ididx[y][x].push_back(pii(eqNum,id[i]));\n      if (!inserted[y][x]) {\n        pos[posNum++] = pii(y,x);\n        inserted[y][x] = 1;\n      }\n    }\n    eqNum++;\n  }\n  return 1;\n}\n\nbool checkOp(int id, int idx) {\n  int n = strlen(eq[id]);\n  if (idx && isoperator(eq[id][idx-1])) return 1;\n  if (idx+1<n && isoperator(eq[id][idx+1])) return 1;\n  return 0;\n}\n\nbool numOnly[100];\nint n;\n\nbool dfs(int S, int now) {\n  if (now == posNum) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  FOR(it, ididx[y][x]) {\n    dotNum[it->first]--;\n  }\n  REP(i,n) {\n    if (S>>i&1) continue;\n    if (!isdigit(b[i]) && numOnly[now]) continue;\n    bool f = 1;\n    FOR(it, ididx[y][x]) {\n      int id = it->first;\n      int idx = it->second;\n      eq[id][idx] = b[i];\n      if (dotNum[id] == 0) {\n        f &= check(eq[id]);\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n  }\n  FOR(it, ididx[y][x]) {\n    eq[it->first][it->second] = '.';\n    dotNum[it->first]++;\n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    memset(inserted,0,sizeof(inserted));\n    memset(visited,0,sizeof(visited));\n    posNum = 0, eqNum = 0;\n    REP(i,h)REP(j,w)ididx[i][j].clear();\n    memset(dotNum,0,sizeof(dotNum));\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (!visited[i][j][1]) bfs(i,j,1,0);\n        if (!visited[i][j][0]) bfs(i,j,0,1);\n      }\n    }\n    memset(numOnly,0,sizeof(numOnly));\n    REP(i,posNum) {\n      FOR(it, ididx[pos[i].first][pos[i].second]) {\n        numOnly[i] = checkOp(it->first,it->second);\n      }\n    }\n    int noEqNum = 0;\n    REP(i,eqNum) {\n      bool f = 0;\n      REP(j,strlen(eq[i])) f |= (eq[i][j]=='=');\n      if (!f) noEqNum++;\n    }\n    int beqNum = 0;\n    REP(i,n) if (b[i]=='=') beqNum++;\n    if ((noEqNum+1)/2 > beqNum) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    // REP(i,eqNum) cout << eq[i] << endl;\n    // REP(i,posNum) {\n    //   cout << numOnly[i] << endl;\n    //   cout << pos[i].first << \" \" << pos[i].second << endl;\n    //   FOR(it, ididx[pos[i].first][pos[i].second]) {\n    //     cout << it->first << \":\" << it->second << endl;\n    //   }cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          NotMultExc = 5;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    cout << \"r_:\" << r.value << \",\" << r_\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  int value = 0;\n  bool flag = false;\n  while (isdigit(s[p])) {\n    if (flag and value == 0) {\n      throw NotNumExc;\n    }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 14, WMAX = 14, NMAX = 15;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string& S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string& symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string& S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (!stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string& S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string& symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tstring s_map(symbol, symbol + n);\n\tsort(s_map.begin(), s_map.end());\n\t\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tbool flag = true;\n\t\tfor (Equation& eq : eqs) {\n\t\t\tflag &= eq.evaluate(s_map);\n\t\t\tif (!flag) break;\n\t\t}\n\t\tif (flag) return true;\n\t} while (next_permutation(s_map.begin(), s_map.end()));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            ret /= factor(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1) if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end());\n    return ans;\n}\n\nbool requireString(char m[15][15], vector<string> &s){\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                string str;\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                string str;\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nvector<pair<int, int>> spacePoints(vector<string> s){\n    vector<pair<int, int>> ret;\n    rep(i,s.size()){\n        rep(j,s[i].size()){\n            if(s[i][j] == '.') ret.emplace_back(make_pair(i,j));\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> h >> w,h){\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n        \n        vector<pair<int, int>> space;\n        rep(i,h) rep(j,w){\n            cin >> m[i + 1][j + 1];\n            if(m[i + 1][j + 1] == '.') space.emplace_back(make_pair(i + 1,j + 1));\n        }\n\n        int n;\n        cin >> n;\n        vector<char> v;\n        rep(i,n){\n            char x;\n            cin >> x;\n            v.emplace_back(x);\n        }\n\n        vector<string> s;\n\n        bool f = false;\n        do{\n            rep(i,n) m[ space[i].first ][ space[i].second ] = v[i];\n            f |= requireString(m,s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nchar B[10][10];             // ??????????????¢\nint n;\nchar ds[10];                    // ??????????????????\n\nint BrankX[10], BrankY[10];     // ???????????§?¨?\n\n// ????????????\nconst int dx[4] = {0, 0, -1, 1};\nconst int dy[4] = {-1, 1, 0, 0};\nenum dir {up, down, lft, rgt};\n\n// ?????????????????§?¨????????´???????\nvector<int> UD_X, UD_Y;         // ???????????????????????????\nvector<int> LR_X, LR_Y;         // ???????????????????????????\n\n// dfs??§?????¨\nbool used[10];\n\n// ???????§£?????§?????¨\nint idxX;                       // ?§£???????????????X??§?¨?\nint idxY;                       // ?§£???????????????Y??§?¨?\ndir direc;                      // ?????¨?§£????????????????????? down or rgt\nconst int NG = 99999999;        // ????????£?????????????????¨?????????\n\nchar Board(int x, int y)\n{\n  return B[y][x];\n}\n\nbool inBoard(int x, int y)\n{\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\n// (x,y)?????????????£???????????????¨???true\nbool isWhite(int x, int y)\n{\n  return inBoard(x, y) && (Board(x, y) != '#');\n}\n\nbool isOperator(char op)\n{\n  return (op == '+' || op == '-' ||\n          op == '*' || op == '/' ||\n          op == '=');\n}\n\nint N0()\n{\n  if (!isdigit(Board(idxX, idxY))) return NG;\n\n  string vals;\n  while (isdigit(Board(idxX, idxY)))\n  {\n    vals += Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n  }\n  if (vals[0] == '0' && vals.length() > 1) return NG;\n\n  return atoi(vals.c_str());\n}\n\nint Ex0()\n{\n  int val = N0();\n  if (val == NG) return NG;\n\n  while (Board(idxX, idxY) == '*' || Board(idxX, idxY) == '/')\n  {\n    char op = Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n\n    int b = N0();\n    if (op == '*') val *= b;\n    if (op == '/') val /= b;\n  }\n  return val;\n}\n\n// (idxX, idxY)???????§??????????????¨?????????????????????????\n// ????????¢??°?????????????????¨(idxX, idxY)?????????????£???????????????¨?????¨???\nint Ex()\n{\n  int val = Ex0();              // *??¨/??§?¨???????????????°\n  if (val == NG) return NG;\n\n  while (Board(idxX, idxY) == '+' || Board(idxX, idxY) == '-')\n  {\n    char op = Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n\n    int b = Ex();\n    if (b == NG) return NG;\n    if (op == '+') val += b;\n    if (op == '-') val -= b;\n  }\n  return val;\n}\n\n// ??¨??¨????????£????????¢????????????????????¨????????????????????£?????????????????????????????????\nbool isCorrectBoard()\n{\n  // ????????????\n  for (int i=0;i<UD_X.size();i++)\n  {\n    idxX = UD_X[i];\n    idxY = UD_Y[i];\n    direc = down;\n\n    // (idxX, idxY)???????§????????????????\n    int lhs = Ex();\n    if (lhs == NG) return false;\n\n    // ???????¬????=???????????????\n    if (inBoard(idxY, idxX) && Board(idxX, idxY) != '=') return false;\n\n    // = ?????????????????????\n    idxX += dx[down];\n    idxY += dy[down];\n    // ????????????????¨????\n    int rhs = Ex();\n    if (rhs == NG) return false;\n\n    if (isWhite(idxX, idxY)) return false;\n\n    if (lhs != rhs) return false;\n  }\n  // ???????????????????????¨?????£??????\n\n  // ????????????\n  for (int i=0;i<LR_X.size();i++)\n  {\n    idxX = LR_X[i];\n    idxY = LR_Y[i];\n    direc = rgt;\n\n    // (idxX, idxY)???????§????????????????\n    int lhs = Ex();\n    if (lhs == NG) return false;\n\n    // ???????¬????=???????????????\n    if (!inBoard(idxY, idxX) && Board(idxX, idxY) != '=') return false;\n\n    // = ?????????????????????\n    idxX += dx[rgt];\n    idxY += dy[rgt];\n    // ????????????????¨????\n    int rhs = Ex();\n    if (rhs == NG) return false;\n\n    if (isWhite(idxX, idxY)) return false;\n\n    if (lhs != rhs) return false;\n  }\n  // ???????????????????????¨?????£??????\n\n  return true;\n}\n\nvoid print_Board()\n{\n  for (int i=0;i<H;i++)\n  {\n    for (int j=0;j<W;j++)\n      cout << B[i][j];\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid print_Brank()\n{\n  for (int i=0;i<n;i++)\n  {\n    printf(\"(%d, %d) \", BrankX[i], BrankY[i]);\n  }\n  printf(\"\\n\");\n}\n\n// 1???b-1????????????????????????????????\\??£???????????¨?????????\n// ??????????????¢?´¢????????£???????????¢????????¨????????°true?????????\nbool dfs(int b)\n{\n  //cout << b << endl;\n  if (b == n)\n  {\n    // ??¨??¨????????£???????????????\n    // ?????¢?????£??????????????????????¢??????????\n    // ??£???????????¢??????true????????????????????????false?????????\n    print_Board();\n    return isCorrectBoard();\n  }\n  else\n  {\n    int x = BrankX[b], y = BrankY[b];\n    // ??°????????\\???????????????????????????????????????\n    bool digitp = false;\n    // ??¨??????????¨???????????????°??°????????\\???\n    for (int i=0;i<4;i++)\n    {\n      if (inBoard(x+dx[i], y+dy[i]) && isOperator(Board(x+dx[i], y+dy[i])))\n      {\n        digitp = true;\n        break;\n      }\n    }\n    // ?????????????????????????????????????????°??°????????\\???\n    if (isWhite(x+dx[up], y+dy[up]) && !isWhite(x+dx[down], y+dy[down])) digitp=true;\n    if (isWhite(x+dx[down], y+dy[down]) && !isWhite(x+dx[up], y+dy[up])) digitp=true;\n    if (isWhite(x+dx[lft], y+dy[lft]) && !isWhite(x+dx[rgt], y+dy[rgt])) digitp=true;\n    if (isWhite(x+dx[rgt], y+dy[rgt]) && !isWhite(x+dx[lft], y+dy[lft])) digitp=true;\n\n    // (x,y)?????????????????\\????????¢?´¢????¶???????\n    for (int i=0;i<n;i++)\n    {\n      if (used[i]) continue;\n      if (digitp && isOperator(ds[i])) continue;\n\n      used[i] = true;\n      B[y][x] = ds[i];\n      if (dfs(b+1)) return true;\n      used[i] = false;\n    }\n    return false;\n  }\n}\n\nint main()\n{\n  while (cin >> H >> W)\n  {\n    if (H == 0) return 0;\n    for (int i=0;i<H;i++) cin >> B[i];\n    cin >> n;\n    for (int i=0;i<n;i++) cin >> ds[i];\n\n    // ????????¨????????§?¨????????????£?????????\n    int k = 0;\n    for (int y=0;y<H;y++)\n      for (int x=0;x<W;x++)\n        if (Board(x, y) == '.') { BrankX[k] = x; BrankY[k] = y; k++; }\n\n    print_Brank();\n    //assert(k == n);\n\n    // ?????????????????§??????\n    UD_X.clear(); UD_Y.clear();\n    LR_X.clear(); LR_Y.clear();\n    // ???????????????????????????????????§??????\n    for (int i=0;i<H;i++)\n      for (int j=0;j<W;j++)\n      {\n        if (!isWhite(j + dx[up], i + dy[up]) &&\n            isWhite(j + dx[down], i + dy[down]))\n        {\n          UD_X.push_back(j);\n          UD_Y.push_back(i);\n        }\n      }\n    // ???????????????????????????????????§??????\n    for (int i=0;i<H;i++)\n      for (int j=0;j<W;j++)\n      {\n        if (!isWhite(j + dx[lft], i + dy[lft]) &&\n            isWhite(j + dx[rgt], i + dy[rgt]))\n        {\n          LR_X.push_back(j);\n          LR_Y.push_back(i);\n        }\n      }\n\n    //print_Start();\n\n    // DFS??§??¨??¢?´¢\n    for (int i=0;i<n;i++) used[i]=false;\n\n    if (dfs(0)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    if(!isNum(s[pos])){flag=true;return 0;}\n\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),z;\n    if(pos==len)return res;\n    else if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      z=getNum();\n      if(z==0){flag=true;z=1;}\n      else if(res%z!=0)flag=true;\n      return res/z;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len)break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n\n  for(int i=0;i<(int)w.size();i++){\n    if(compute(i)==false)return false;\n  }\n  return true;\n}\n\nbool compute(int x){\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF){\n    return false;\n  }\n\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nbool inserted[10][10];\n\nvector<pii> pos;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    if (a[y][x] == '.' && !inserted[y][x]) {\n      pos.push_back(pii(y,x));\n      inserted[y][x] = 1;\n    }\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (r == 0) throw 0;\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id, bool f=1) {\n  if (s.size() < 2) return 1;\n  // if (f) {\n  //   if ((id == 0 || isoperator(s[id-1])) && (!isdigit(s[id]) || s[id] == '0')) return 0;\n  //   if ((id == s.size()-1 || isoperator(s[id+1])) && !isdigit(s[id])) return 0;\n  // }\n  REP(i,s.size()-1) {\n    if ((i==0 || !isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return 0;\n    if (isoperator(s[i]) && isoperator(s[i+1])) return 0;\n  }\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == pos.size()) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    memset(inserted,0,sizeof(inserted));\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        // if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // assert(pos.size() == n);\n    bool ok = 1;\n    FOR(it, v) ok &= check(*it,0,0);\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (ok&&dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (!stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) {\n\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t}\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tif (a != n) return false;\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) {\n\t\t\tflag &= eq.evaluate(s_map);\n\t\t\tif (!flag) break;\n\t\t}\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if(s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if(!isdigit(s[i]) && (i==0 || !isdigit(s[i-1]))){\n      return false;\n    }\n  }\n  return isdigit(s.back());\n}\n\nint parse(int L, int R, const string &s){\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=L;i<R;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  assert(p!=(int)s.size());\n  int a = parse(0,p,s);\n  int b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <string> VS;\ntypedef vector <char> VC;\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> PPP;\ntypedef map <PII, int> M_PII_I;\ntypedef map <int, PII> M_I_PII;\ntypedef map <int, PPP> M_I_PPP;\ntypedef map <int, int> M_I_I;\ntypedef map <int, VI> M_I_VI;\ntypedef map <string, int> M_S_I;\ntypedef ostringstream OSS;\n\nconst int NONE = INT_MAX;\n\nint h, w;\nVS M;\nVC O;\nint O_cnt;\nM_PII_I D_ID; // 座標 => '.' の ID\nM_I_PII D_ID_rev; // '.' の ID => 座標\nint D_ID_cnt;\nM_I_VI D_to_E; // '.'が含まれる式ID取得 1対多\nM_I_I E_to_D_cnt; // 式が含む'.'の個数\nM_I_PPP E_ID; // 式ID => ( 座標, 向き, 長さ )\nint E_ID_cnt;\n\nvoid init_global() {\n    M.clear();\n    O.clear();\n    O_cnt = 0;\n    D_ID.clear();\n    D_ID_rev.clear();\n    D_ID_cnt = 0;\n    D_to_E.clear();\n    E_to_D_cnt.clear();\n    E_ID.clear();\n    E_ID_cnt = 0;\n}\n\n// util\nstring toString( PII info ) {\n    OSS oss;\n    oss << \"(\" << info.first << \", \" << info.second << \")\";\n    return oss.str();\n}\n\nstring toString( PPP info ) {\n    OSS oss;\n    oss << toString( info.first ) << \", \" << toString( info.second );\n    return oss.str();\n}\n\nbool isOperation( char c ) {\n    return c < '0' || c > '9';\n}\n\nbool isNumber( char c ) {\n    return c >= '0' && c <= '9';\n}\n\n//\nM_S_I memo;\nint eval( string s ) {\n    if ( memo.count( s ) ) return memo[s];\n    int n = s.size();\n    // debug\n    // cout << \"@eval: \" << s << endl;\n\n    // 演算子\n    char OP[20];\n    int OP_cnt = 0;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( isOperation( s[i] ) ) {\n            OP[OP_cnt ++] = s[i];\n        }\n    }\n\n    int NUM[20] = {};\n    int NUM_cnt = 0;\n    int mul = 1;\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( isOperation( s[i] ) ) {\n            // 区切り\n            NUM_cnt ++;\n            mul = 1;\n        } else {\n            NUM[NUM_cnt] += ( s[i] - '0' ) * mul;\n            mul *= 10;\n        }\n    }\n    NUM_cnt ++;\n    reverse( NUM, NUM + NUM_cnt );\n\n    // *, /\n\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' || OP[i] == '-' ) continue;\n        if ( OP[i] == '*' ) {\n            NUM[i] *= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        } else if ( OP[i] == '/' ) {\n            if ( NUM[i+1] == 0 ) return memo[s] = NONE;\n            if ( NUM[i] % NUM[i+1] != 0 ) return memo[s] = NONE;\n            NUM[i] /= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        }\n    }\n    \n    int res = NUM[0];\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' ) {\n            res += NUM[i+1];\n        } else {\n            res -= NUM[i+1];\n        }\n    }\n\n    // debug\n    // cout << res << endl;\n\n    return memo[s] = res;\n}\n\nbool check2( string& s ) {\n    int n = s.size();\n    if ( isOperation( s[n-1] ) ) return false;\n    if ( s[0] != '-' && isOperation( s[0] ) ) return false;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( isOperation( s[i] ) && isOperation( s[i + 1] ) ) return false;\n    }\n    bool flag = true;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( flag ) {\n            if ( s[i] == '0' && isNumber( s[i + 1] ) ) return false;\n            flag = false;\n        } else if ( isOperation( s[i] ) ) {\n            flag = true;\n        }\n    }\n    return true;\n}\n\nbool check( string& s ) {\n    int n = s.size();\n    string left, right;\n    bool flag = true;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            flag = false;\n        } else if ( flag ) {\n            left += s[i];\n        } else {\n            right += s[i];\n        }\n    }\n    return ( check2( left ) && check2( right ) ) ? eval( left ) == eval( right ) : false;\n}\n\nbool used[11];\nM_I_I E_to_D;\nconst int dr[2] = { 0, 1 };\nconst int dc[2] = { 1, 0 };\nbool backtrack( int k ) {\n    if ( k >= D_ID_cnt ) {\n        bool flag = true;\n        for ( int i = 0; i < D_ID_cnt; ++ i ) {\n            if ( E_to_D[i] != E_to_D_cnt[i] ) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n    for ( int i = 0; i < O_cnt; ++ i ) {\n        int r = D_ID_rev[i].first;\n        int c = D_ID_rev[i].second;\n        used[i] = true;\n        M[r][c] = O[i];\n        for ( VI::iterator it_i = D_to_E[i].begin(); it_i != D_to_E[i].end(); ++ it_i ) {\n            E_to_D[*it_i] ++;\n        }\n        for ( VI::iterator it_i = D_to_E[i].begin(); it_i != D_to_E[i].end(); ++ it_i ) {\n            int eid = *it_i;\n            // debug\n            // cout << eid << \": \" << toString( E_ID[eid] ) << \", \" << E_to_D[eid] << \" == \" << E_to_D_cnt[eid] << endl;\n            if ( E_to_D[eid] == E_to_D_cnt[eid] ) {\n                PPP& info = E_ID[eid];\n                string exp = \"\";\n                int r = info.first.first;\n                int c = info.first.second;\n                for ( int j = 0; j < info.second.second; ++ j ) {\n                    exp += M[r][c];\n                    r += dr[info.second.first];\n                    c += dc[info.second.first];\n                }\n                // debug\n                // cout << eid << \": \" << toString( E_ID[eid] ) << \", \" << E_to_D[eid] << \" == \" << E_to_D_cnt[eid] << \" \";\n                // cout << exp << \", \" << check( exp ) << endl;\n                if ( check( exp ) && backtrack( k + 1 ) ) return true;\n            } else {\n                if ( backtrack( k + 1 ) ) return true;\n            }\n        }\n        for ( VI::iterator it_i = D_to_E[i].begin(); it_i != D_to_E[i].end(); ++ it_i ) {\n            E_to_D[*it_i] --;\n        }\n        used[i] = false;\n    }\n    return false;\n}\n\nbool solve() {\n    E_to_D.clear();\n    fill( used, used + 11, false );\n    return backtrack( 0 );\n    /*\n    const int dr[2] = { 0, 1 };\n    const int dc[2] = { 1, 0 };\n    do {\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            // cout << i << \": \" << O[i] << \", \" << toString( D_ID_rev[i] ) << endl;\n            PII& d = D_ID_rev[i];\n            M[d.first][d.second] = O[i];\n        }\n        bool flag = true;\n        for ( int i = 0; i < E_ID_cnt; ++ i ) {\n            PPP& info = E_ID[i];\n            string exp = \"\";\n            int r = info.first.first;\n            int c = info.first.second;\n            for ( int j = 0; j < info.second.second; ++ j ) {\n                exp += M[r][c];\n                r += dr[info.second.first];\n                c += dc[info.second.first];\n            }\n            if ( ! check( exp ) ) {\n                // cout << exp << endl;\n                flag = false;\n                break;\n            }\n        }\n        if ( flag ) return true;\n    } while ( next_permutation( O.begin(), O.end() ) );\n    */\n}\n\nvoid getID() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == '.' ) {\n                int did = D_ID_cnt ++;\n                D_ID[PII( i, j )] = did;\n                D_ID_rev[did] = PII( i, j );\n            }\n        }\n    }\n}\n\nbool notValid( string s ) {\n    int n = s.size();\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            return ! ( i >= 1 && ( n - ( i + 1 ) ) >= 1 );\n        }\n    }\n    return true;\n}\n\nvoid addExpression( int& si, int& sj, int i, int j, int dir, string& exp, VI& ids ) {\n    if ( notValid( exp ) ) {\n        ids.clear();\n        exp.clear();\n        return;\n    }\n    int eid = E_ID_cnt ++;\n    E_to_D_cnt[eid] = 0;\n    for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n        D_to_E[*it_i].push_back( eid );\n        E_to_D_cnt[eid] ++;\n    }\n    E_ID[eid] = PPP( PII( si, sj ), PII( dir, (int)exp.size() ) );\n\n    // debug\n    // cout << (eid) << \", \" << dir << \", \" << exp << \": \" << toString( E_ID[eid] ) << endl;\n    // for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n    //    cout << \"\\t\" << *it_i << \": \" << toString( D_ID_rev[*it_i] ) << endl;\n    //}\n\n    si = i;\n    sj = j + 1;\n    ids.clear();\n    exp.clear();\n}\n\nvoid getExpressions() {\n    // 横\n    for ( int i = 0; i < h; ++ i ) {\n        string exp;\n        VI ids;\n        int si = i;\n        int sj = 0;\n        for ( int j = 0; j < w; ++ j ) {\n            char c = M[i][j];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, i, j, 0, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(i,j)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 0, exp, ids );\n    }\n    // 縦\n    for ( int i = 0; i < w; ++ i ) {\n        string exp;\n        VI ids;\n        int si = 0;\n        int sj = i;\n        for ( int j = 0; j < h; ++ j ) {\n            char c = M[j][i];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, j, i, 1, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(j,i)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 1, exp, ids );\n    }\n}\n\nint main() {\n    while ( cin >> h >> w && h && w ) {\n        init_global();\n\n        // input\n        M = VS(h);\n        for ( int i = 0; i < h; ++ i ) {\n            cin >> M[i];\n        }\n        cin >> O_cnt;\n        O = VC(O_cnt);\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            cin >> O[i];\n        }\n        sort( O.begin(), O.end() );\n\n        getID();\n        getExpressions();\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (r == 0) throw 0;\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(char *s) {\n  try {\n    int n = strlen(s);\n    int pos = -1;\n    REP(i,strlen(s)) if (s[i]=='=') pos = i;\n    if (pos == -1 || pos == 0 || pos == n-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<n; ++i) str[i-pos-1] = s[i]; str[n-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\n\nchar a[10][10];\nchar b[10];\n\nchar eq[100][11];\n\nint h,w;\n\nbool inserted[10][10];\n\npii pos[100];\nint posNum;\nint eqNum;\nbool visited[10][10][2];\n\nvector<pii> ididx[10][10];\nint dotNum[100];\n\nbool bfs(int y, int x, int dy, int dx) {\n  char s[11];\n  int idx = 0;\n  vector<pii> v;\n  vector<int> id;\n  while(valid(y,x,h,w)) {\n    visited[y][x][dy] = 1;\n    if (a[y][x] == '#') break;\n    if (a[y][x] == '.') {\n      v.push_back(pii(y,x));\n      id.push_back(idx);\n    }\n    s[idx++] = a[y][x];\n    y += dy;\n    x += dx;\n  }\n  if (idx >= 2) {\n    s[idx] = 0;\n    if (v.size() == 0 && !check(s)) return 0;\n    dotNum[eqNum] = v.size();\n    strcpy(eq[eqNum], s);\n    REP(i,v.size()) {\n      int y = v[i].first, x = v[i].second;\n      ididx[y][x].push_back(pii(eqNum,id[i]));\n      if (!inserted[y][x]) {\n        pos[posNum++] = pii(y,x);\n        inserted[y][x] = 1;\n      }\n    }\n    eqNum++;\n  }\n  return 1;\n}\n\nbool checkOp(int id, int idx) {\n  int n = strlen(eq[id]);\n  if (id==0 || id==n-1) return 1;\n  if (isoperator(eq[id][idx-1])) return 1;\n  if (isoperator(eq[id][idx+1])) return 1;\n  return 0;\n}\n\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,1,0,-1};\n\nbool isNumOnly(int now, int y, int x) {\n  FOR(it, ididx[y][x]) {\n    int id=it->first;\n    int idx=it->second;\n    if (checkOp(id,idx)) return 1;\n  }\n  return 0;\n}\n\nbool isHead(int now, int y, int x) {\n  FOR(it, ididx[y][x]) {\n    int id=it->first;\n    int idx=it->second;\n    if (idx==0 || isoperator(eq[id][idx-1]))return 1;\n  }\n  return 0;\n}\n\nbool numOnly[100];\n\nint n;\n\nbool dfs(int S, int now) {\n  if (now == posNum) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  FOR(it, ididx[y][x]) {\n    dotNum[it->first]--;\n  }\n  REP(i,n) {\n    if (S>>i&1) continue;\n    if (!isdigit(b[i]) && isNumOnly(now,y,x)) continue;\n    if (b[i] == '0' && isHead(now,y,x)) continue;\n    bool f = 1;\n    FOR(it, ididx[y][x]) {\n      int id = it->first;\n      int idx = it->second;\n      eq[id][idx] = b[i];\n      if (dotNum[id] == 0) {\n        f &= check(eq[id]);\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n  }\n  FOR(it, ididx[y][x]) {\n    eq[it->first][it->second] = '.';\n    dotNum[it->first]++;\n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    memset(inserted,0,sizeof(inserted));\n    memset(visited,0,sizeof(visited));\n    posNum = 0, eqNum = 0;\n    REP(i,h)REP(j,w)ididx[i][j].clear();\n    memset(dotNum,0,sizeof(dotNum));\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (!visited[i][j][1]) bfs(i,j,1,0);\n        if (!visited[i][j][0]) bfs(i,j,0,1);\n      }\n    }\n    memset(numOnly,0,sizeof(numOnly));\n    REP(i,posNum) {\n      FOR(it, ididx[pos[i].first][pos[i].second]) {\n        numOnly[i] = checkOp(it->first,it->second);\n      }\n    }\n    // REP(i,eqNum) cout << eq[i] << endl;\n    // REP(i,posNum) {\n    //   cout << numOnly[i] << endl;\n    //   cout << pos[i].first << \" \" << pos[i].second << endl;\n    //   FOR(it, ididx[pos[i].first][pos[i].second]) {\n    //     cout << it->first << \":\" << it->second << endl;\n    //   }cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = false;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 14)) return false;\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2328\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<sstream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nconst int VMAX = 100;\nconst int INF = 1e7;\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[VMAX];\nbool used[VMAX];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, cap, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  used[v] = true;\n\n  for (int i = 0; i < G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] and e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n\n  while (true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nconst int NMAX = 60, MMAX = 600, LMAX = 52;\n\nvector<int> coefficients[NMAX];\nint from[MMAX], to[MMAX];\n\nvoid init(int N) {\n  REP(i, N) {\n    coefficients[i].clear();\n  }\n}\n\nvoid init_flow(int v) {\n  REP(i, v) {\n    G[i].clear();\n  }\n}\n\nvector<string> split_by(char div, string str) {\n  vector<string> xs;\n  string x;\n  for (char c : str) {\n    if (c == div) {\n      xs.push_back(x);\n      x = \"\";\n    } else {\n      x.push_back(c);\n    }\n  }\n  xs.push_back(x);\n  return xs;\n}\n\npair<int,int> factor2pair(string factor) {\n  int a, n;\n  pair<int,int> p;\n  cout << \"(\" << factor << \":\";\n  auto index = factor.find('x', 0);\n  if (index == string::npos) {\n    istringstream is(factor);\n    is >> a;\n    p = pair<int,int>(a,0);\n  } else if (factor.find('^', 0) == string::npos) {\n    factor = factor.substr(0, factor.length() - 1);\n    cout << \"<<\" << factor << \">>\";\n    istringstream is((factor.empty() ? \"1\" : factor));\n    is >> a;\n    p = pair<int,int>(a, 1);\n  } else {\n    string astr = factor.substr(0, index - 1),\n           nstr = factor.substr(index + 2);\n    cout << \"<\" << astr << \" \" << nstr << \">\";\n    istringstream is(astr);\n    is >> a;\n    is.clear();\n    is.str(nstr);\n    is >> n;\n    p = pair<int,int>(a,n);\n  }\n    cout << p.first << \",\" << p.second << \")\" << endl;\n  return p;\n}\n\nvector<int> polynomial2vector(string poly) {\n  vector<string> factors = split_by('+', poly);\n  vector<int> ans(LMAX);\n  for (string factor : factors) {\n    pair<int,int> p = factor2pair(factor);\n    ans[p.first] = p.second;\n  }\n  return ans;\n}\n\nstring vector2polynomial(vector<int> poly) {\n  string ans = \"\";\n  for (int i = 0, len = poly.size(); i < len; i++) {\n    if (! poly[i]) continue;\n    ans = poly[i] + (i == 0 ? \"\":\"x\") \n      + (i <= 1 ? \"\":\"^\" + to_string(i))+ ans;\n  }\n  return (ans.empty() ? \"0\" : ans);\n}\n\nint get_coefficient(int m, int l) {\n  return coefficients[m][l];\n}\n\nint main() {\n  int N, M;\n  while (cin >> N >> M and N) {\n    init(N);\n    REP(i, M) {\n      int u, v;\n      string poly;\n      cin >> u >> v >> poly;\n\n      from[i] = u;\n      to[i] = v;\n      coefficients[i] = polynomial2vector(poly);\n    }\n\n    int lmax;\n    vector<int> ans;\n\n    REP(l, lmax) {\n      init_flow(N);\n      REP(m, M) {\n        add_edge(from[m], to[m], get_coefficient(m, l));\n        add_edge(to[m], from[m], get_coefficient(m, l));\n      }\n      ans.push_back(max_flow(1, N));\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    cout << vector2polynomial(ans) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n \nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n \nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n   \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n   \n  return t;\n}\n \n \nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n \nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n \nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n \n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\nvector<pair<int,int> > BLANKS;\n \nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  for (int i = 0; i < n; i++) {\n    TABLE[BLANKS[i].first][BLANKS[i].second] = BLOCK[i];\n  }\n}\n \nchar TEMP[100];\n \nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    y++;\n  }\n  return str;\n}\n \nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    x++;\n  }\n  return str;\n}\n \nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n \nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n \n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n \nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false;\n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n \n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false;\n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (solved()) {\n      return true;\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n  return false;\n}\n \nvoid init() {\n  REP(y, H) REP(x, W) {\n    BLANKS.clear();\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n \nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n \n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n \n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n      if (not PRINTED[x][y]) {\n        BLANKS.push_back(make_pair(x, y));\n      }\n    }\n\n \n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if ((not legal(q)) or incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if ((not legal(q)) or incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) throw 1;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) throw 2;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15], vector<string> &s){\n    vector<pair<int, int>> ver, hor;\n    range(i,1,h + 1){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                ver.emplace_back(make_pair(i,j));\n            }\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                hor.emplace_back(make_pair(i,j));\n            }\n        }\n    }\n\n    string str;\n    for(auto p:ver){\n        int i = p.first;\n        int j = p.second;\n        str = \"\";\n        for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n        if(not sintaxCheck(str)) return false;\n        s.emplace_back(str);\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n\n    for(auto p:hor){\n        int i = p.first;\n        int j = p.second;\n        str = \"\";\n        for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n        if(not sintaxCheck(str)) return false;\n        s.emplace_back(str);\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h){\n                rep(j,w){\n                    scanf(\"%c\",&m[i + 1][j + 1]);\n                    if(m[i + 1][j + 1] == '.'){\n                        y[k] = i + 1;\n                        x[k] = j + 1;\n                        k++;\n                    }\n                }\n               scanf(\"%*c\");\n            }\n        }\n\n        //if(not check(m)){\n        //    cout << \"NO\" << endl;\n        //    continue;\n        //}\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n\n        vector<string> s;\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m,s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\n// BNF\n// <Eq> ::= <Ex> = <Ex>\n// <Ex> ::= <N0> | <Ex> <Op> <N0> \n// <N0> ::= <N> | 0\n// <N>  ::= <D> | <N> <D> | <N> 0\n// <Op> ::= + | - | ~ | \n// <D>  ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n\nint idx;\nchar s[11];\nbool res; // s ª³µ¢®©Ç¤©\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-' || s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex();\n\tASRT;\n\tif(a!=b || s[idx]) res=false; // = ª¬§µÈ¢©AÜ¾ãëÉ¶ª êÎÔá¢\n}\n\nbool parse(){\n\tif(!s[1] || !s[2]) return true; // ·³ 2 ÈºÈç³\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nvector<int> head[2][10],tail[2][10];\nvoid preprocess(){\n\t// ¡ûüÉ®ªüéêðñ\n\trep(i,h){\n\t\thead[0][i].clear();\n\t\ttail[0][i].clear();\n\n\t\tint p=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\thead[0][i].push_back(p);\n\t\t\t\t\ttail[0][i].push_back(j);\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// cûüÉ®ªüéêðñ\n\trep(j,w){\n\t\thead[1][j].clear();\n\t\ttail[1][j].clear();\n\n\t\tint p=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\thead[1][j].push_back(p);\n\t\t\t\t\ttail[1][j].push_back(i);\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool isvalid(){\n\t// ¡ûüÌ®Ì`FbN\n\trep(i,h){\n\t\trep(k,head[0][i].size()){\n\t\t\trep(l,tail[0][i][k]-head[0][i][k]) s[l]=B[i][head[0][i][k]+l];\n\t\t\ts[tail[0][i][k]-head[0][i][k]]='\\0';\n\t\t\tif(!parse()) return false;\n\t\t}\n\t}\n\n\t// cûüÌ®Ì`FbN\n\trep(j,w){\n\t\trep(k,head[1][j].size()){\n\t\t\trep(l,tail[1][j][k]-head[1][j][k]) s[l]=B[head[1][j][k]+l][j];\n\t\t\ts[tail[1][j][k]-head[1][j][k]]='\\0';\n\t\t\tif(!parse()) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tint n; scanf(\"%d\",&n);\n\t\tchar key[10];\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\tint qx[10],qy[10];\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tpreprocess();\n\n\t\tbool ok=false;\n\t\tif(n==0) ok=isvalid();\n\t\telse{\n\t\t\tint p[]={0,1,2,3,4,5,6,7,8,9};\n\t\t\tdo{\n\t\t\t\trep(k,n) B[qy[k]][qx[k]]=key[p[k]];\n\t\t\t\tif(isvalid()){ ok=true; break; }\n\t\t\t}while(next_permutation(p,p+n));\n\t\t}\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<bool, MAX_N> used;\narray<char, 128> letters;\narray<bool, 128> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint factor(string::const_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\tthrow \"parse error\";\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t{\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\t}\n\t\tcase '/':\n\t\t{\n\t\t\t++it;\n\t\t\tconst int tmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t{\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\t}\n\t\tcase '-':\n\t\t{\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid calc(int &x, int &y, int dx, int dy) {\n\twhile(true) {\n\t\tconst int nx = x + dx;\n\t\tconst int ny = y + dy;\n\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && puzzle[ny][nx] != '#') {\n\t\t\tx = nx;\n\t\t\ty = ny;\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t\tif(i + 1 == expression.size()) {\n\t\t\t\t\tnot_operator[expression[i]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_operator[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w, -1));\n\tint next = 0;\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i, g = i;\n\t\t\t\tcalc(j, s, 0, -1);\n\t\t\t\tcalc(j, g, 0, 1);\n\n\t\t\t\tif(s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\tif(idx[k][j] == -1) idx[k][j] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j, g = j;\n\t\t\t\tcalc(s, i, -1, 0);\n\t\t\t\tcalc(g, i, 1, 0);\n\n\t\t\t\tif(s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\tif(idx[i][k] == -1) idx[i][k] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used[i]) continue;\n\t\tif(is_operator[in[i]] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\t\tif(i && !used[i - 1] && in[i] == in[i - 1]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[in[i]]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tused[i] = true;\n\t\tif(dfs(expressions, next, idx + 1)) return true;\n\t\tused[i] = false;\n\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tis_operator.fill(false);\n\tis_operator['+'] = true;\n\tis_operator['-'] = true;\n\tis_operator['*'] = true;\n\tis_operator['/'] = true;\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tused.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\t\tsort(in.begin(), in.begin() + n);\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0) ? \"Yes\\n\" : \"No\\n\");\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!(isdigit(str[i]) && str[i]!='0')) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id) {\n  if (s.size() < 2) return 1;\n  if ((id == 0 || isoperator(s[id-1])) && !isdigit(s[id])) return 0;\n  if (count(ALL(s),'=') >= 2) return 0;\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) ((l)<=(x) && (x)<(r))\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1])) ){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint parse(int l, int r, const string &s){\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=l;i<r;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  int a = parse(0,p,s);\n  int b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n\n    cin >> n;\n    rep(i,n)cin >> c[i];\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <string> VS;\ntypedef vector <char> VC;\ntypedef pair <int, int> PII;\ntypedef pair <int, char> PIC;\ntypedef vector <PIC> VPIC;\ntypedef pair <PII, PII> PPP;\ntypedef map <PII, int> M_PII_I;\ntypedef map <int, PII> M_I_PII;\ntypedef map <int, PPP> M_I_PPP;\ntypedef map <int, int> M_I_I;\ntypedef map <int, VI> M_I_VI;\ntypedef map <string, int> M_S_I;\ntypedef map <string, bool> M_S_B;\ntypedef ostringstream OSS;\n\nconst int NONE = INT_MAX;\n\nint h, w;\nVS M;\nVC O;\nint O_cnt;\nVI R;\nM_PII_I D_ID; // 座標 => '.' の ID\nM_I_PII D_ID_rev; // '.' の ID => 座標\nint D_ID_cnt;\nM_I_VI D_to_E; // '.'が含まれる式ID取得 1対多\nM_I_I E_to_D_cnt; // 式が含む'.'の個数\nM_I_PPP E_ID; // 式ID => ( 座標, 向き, 長さ )\nint E_ID_cnt;\n\nvoid init_global() {\n    M.clear();\n    O.clear();\n    O_cnt = 0;\n    R.clear();\n    D_ID.clear();\n    D_ID_rev.clear();\n    D_ID_cnt = 0;\n    D_to_E.clear();\n    E_to_D_cnt.clear();\n    E_ID.clear();\n    E_ID_cnt = 0;\n}\n\n// util\nstring toString( PII info ) {\n    OSS oss;\n    oss << \"(\" << info.first << \", \" << info.second << \")\";\n    return oss.str();\n}\n\nstring toString( PPP info ) {\n    OSS oss;\n    oss << toString( info.first ) << \", \" << toString( info.second );\n    return oss.str();\n}\n\nbool isOperation( char c ) {\n    return c < '0' || c > '9';\n}\n\nbool isNumber( char c ) {\n    return c >= '0' && c <= '9';\n}\n\n//\nM_S_I memo;\nint eval( string s ) {\n    if ( memo.count( s ) ) return memo[s];\n    int n = s.size();\n    // debug\n    // cout << \"@eval: \" << s << endl;\n\n    // 演算子\n    char OP[20];\n    int OP_cnt = 0;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( isOperation( s[i] ) ) {\n            OP[OP_cnt ++] = s[i];\n        }\n    }\n\n    int NUM[20] = {};\n    int NUM_cnt = 0;\n    int mul = 1;\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( isOperation( s[i] ) ) {\n            // 区切り\n            NUM_cnt ++;\n            mul = 1;\n        } else {\n            NUM[NUM_cnt] += ( s[i] - '0' ) * mul;\n            mul *= 10;\n        }\n    }\n    NUM_cnt ++;\n    reverse( NUM, NUM + NUM_cnt );\n\n    // *, /\n\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' || OP[i] == '-' ) continue;\n        if ( OP[i] == '*' ) {\n            NUM[i] *= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        } else if ( OP[i] == '/' ) {\n            if ( NUM[i+1] == 0 ) return memo[s] = NONE;\n            if ( NUM[i] % NUM[i+1] != 0 ) return memo[s] = NONE;\n            NUM[i] /= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        }\n    }\n    \n    int res = NUM[0];\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' ) {\n            res += NUM[i+1];\n        } else {\n            res -= NUM[i+1];\n        }\n    }\n\n    // debug\n    // cout << res << endl;\n\n    return memo[s] = res;\n}\n\nbool check2( string& s ) {\n    int n = s.size();\n    if ( isOperation( s[n-1] ) ) return false;\n    if ( s[0] != '-' && isOperation( s[0] ) ) return false;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( isOperation( s[i] ) && isOperation( s[i + 1] ) ) return false;\n    }\n    bool flag = true;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( flag ) {\n            if ( s[i] == '0' && isNumber( s[i + 1] ) ) return false;\n            flag = false;\n        } else if ( isOperation( s[i] ) ) {\n            flag = true;\n        }\n    }\n    return true;\n}\n\nM_S_B memo_check;\nbool check( string& s ) {\n    if ( memo_check.count( s ) ) return memo_check[s];\n    int n = s.size();\n    string left, right;\n    bool flag = true;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            flag = false;\n        } else if ( flag ) {\n            left += s[i];\n        } else {\n            right += s[i];\n        }\n    }\n    return memo_check[s] = ( ( check2( left ) && check2( right ) ) ? eval( left ) == eval( right ) : false );\n}\n\nbool used[11];\nM_I_I E_to_D;\nconst int dr[2] = { 0, 1 };\nconst int dc[2] = { 1, 0 };\nbool backtrack( int k ) {\n    /*\n    cout << \"k: \" << k << \" (before)\" << endl;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << M[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n    if ( k >= 1 ) return false;\n    */\n\n    if ( k >= D_ID_cnt ) {\n        return true;\n    }\n\n    for ( int i = 0; i < O_cnt; ++ i ) {\n        int did = R[k];\n        if ( used[i] ) continue;\n        int r = D_ID_rev[did].first;\n        int c = D_ID_rev[did].second;\n        used[i] = true;\n        M[r][c] = O[i];\n\n        // '.' がすべて埋まってたら式を評価する\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            E_to_D[eid] ++;\n        }\n        bool flag = true;\n\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            if ( E_to_D[eid] == E_to_D_cnt[eid] ) {\n                PPP& info = E_ID[eid];\n                string exp = \"\";\n                int r = info.first.first;\n                int c = info.first.second;\n                for ( int j = 0; j < info.second.second; ++ j ) {\n                    exp += M[r][c];\n                    r += dr[info.second.first];\n                    c += dc[info.second.first];\n                }\n                if ( ! check( exp ) ) {\n                    flag = false;\n                    break;\n                }\n            }\n        }\n\n        if ( flag && backtrack( k + 1 ) ) return true;\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            E_to_D[eid] --;\n        }\n\n        used[i] = false;\n    }\n    return false;\n}\n\nbool solve() {\n    E_to_D.clear();\n    fill( used, used + 11, false );\n    return backtrack( 0 );\n    /*\n    const int dr[2] = { 0, 1 };\n    const int dc[2] = { 1, 0 };\n    do {\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            // cout << i << \": \" << O[i] << \", \" << toString( D_ID_rev[i] ) << endl;\n            PII& d = D_ID_rev[i];\n            M[d.first][d.second] = O[i];\n        }\n        bool flag = true;\n        for ( int i = 0; i < E_ID_cnt; ++ i ) {\n            PPP& info = E_ID[i];\n            string exp = \"\";\n            int r = info.first.first;\n            int c = info.first.second;\n            for ( int j = 0; j < info.second.second; ++ j ) {\n                exp += M[r][c];\n                r += dr[info.second.first];\n                c += dc[info.second.first];\n            }\n            if ( ! check( exp ) ) {\n                // cout << exp << endl;\n                flag = false;\n                break;\n            }\n        }\n        if ( flag ) return true;\n    } while ( next_permutation( O.begin(), O.end() ) );\n    */\n}\n\nvoid getID() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == '.' ) {\n                int did = D_ID_cnt ++;\n                D_ID[PII( i, j )] = did;\n                D_ID_rev[did] = PII( i, j );\n            }\n        }\n    }\n}\n\nbool notValid( string s ) {\n    int n = s.size();\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            return ! ( i >= 1 && ( n - ( i + 1 ) ) >= 1 );\n        }\n    }\n    return true;\n}\n\nvoid addExpression( int& si, int& sj, int i, int j, int dir, string& exp, VI& ids ) {\n    if ( notValid( exp ) ) {\n        ids.clear();\n        exp.clear();\n        return;\n    }\n    int eid = E_ID_cnt ++;\n    E_to_D_cnt[eid] = 0;\n    for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n        D_to_E[*it_i].push_back( eid );\n        E_to_D_cnt[eid] ++;\n    }\n    E_ID[eid] = PPP( PII( si, sj ), PII( dir, (int)exp.size() ) );\n\n    // debug\n    // cout << (eid) << \", \" << dir << \", \" << exp << \": \" << toString( E_ID[eid] ) << endl;\n    // for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n    //    cout << \"\\t\" << *it_i << \": \" << toString( D_ID_rev[*it_i] ) << endl;\n    //}\n\n    si = i;\n    sj = j + 1;\n    ids.clear();\n    exp.clear();\n}\n\nvoid getExpressions() {\n    // 横\n    for ( int i = 0; i < h; ++ i ) {\n        string exp;\n        VI ids;\n        int si = i;\n        int sj = 0;\n        for ( int j = 0; j < w; ++ j ) {\n            char c = M[i][j];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, i, j, 0, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(i,j)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 0, exp, ids );\n    }\n    // 縦\n    for ( int i = 0; i < w; ++ i ) {\n        string exp;\n        VI ids;\n        int si = 0;\n        int sj = i;\n        for ( int j = 0; j < h; ++ j ) {\n            char c = M[j][i];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, j, i, 1, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(j,i)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 1, exp, ids );\n    }\n}\n\nint main() {\n    while ( cin >> h >> w && h && w ) {\n        init_global();\n\n        // input\n        M = VS(h);\n        for ( int i = 0; i < h; ++ i ) {\n            cin >> M[i];\n        }\n        cin >> O_cnt;\n        O = VC(O_cnt);\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            cin >> O[i];\n        }\n        sort( O.begin(), O.end() );\n\n        getID();\n        getExpressions();\n\n        R = VI( D_ID_cnt );\n        for ( int i = 0; i < D_ID_cnt; ++ i ) R[i] = i;\n\n        M_I_VI tmp = D_to_E;\n        for ( int i = 0; i < D_ID_cnt; ++ i ) {\n            for ( int j = i + 1; j < D_ID_cnt; ++ j ) {\n                if ( tmp[i].size() > tmp[j].size() ) {\n                    swap( tmp[i], tmp[j] );\n                    swap( R[i], R[j] );\n                }\n            }\n        }\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n\n  void init(){ pos=0;len=s.size();flag=false;}\n\n  int head2Num(){\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    char ch;\n    while(s[pos]=='*'||s[pos]=='/'){\n      ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      else if(ch=='/'){\n\tif(num==0){flag=true;num=1;}\n\tif(res%num>0)flag=true;\n\tres/=num;\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    if(!isNum(s[0]))return INF;\n    for(int i=1;i+1<len;i++)if(!isNum(s[i-1])&&!isNum(s[i]))return INF;\n\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3&&e>0&&e<tmp.size()){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3&&e>0&&e<tmp.size()){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3&&e>0&&e<tmp.size()){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3&&e>0){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++){\n    if(!compute(i))return false;\n  }\n  return true;\n}\n\nbool compute(int x){\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.s.push_back('=');\n  b.s.push_back('=');\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\nstatic char m[15][15];\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(vector<string> &s){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        end_parse = false;\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h){\n                rep(j,w){\n                    scanf(\"%c\",&m[i + 1][j + 1]);\n                    if(m[i + 1][j + 1] == '.'){\n                        y[k] = i + 1;\n                        x[k] = j + 1;\n                        k++;\n                    }\n                }\n               scanf(\"%*c\");\n            }\n        }\n\n        //if(not check(m)){\n        //    cout << \"NO\" << endl;\n        //    continue;\n        //}\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n\n        vector<string> s;\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nconstexpr int tsurai=123456789;\n\nint parse_int(const std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i]-'0';\n  while (++i < s.length() && isdigit(s[i])) {\n    res = res*10 + s[i]-'0';\n  }\n  return res;\n}\n\nint fourt(const std::string &s, size_t &i) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length() && isdigit(s[i])) {\n    int cur=parse_int(s, i);\n    while (i < s.length() && s[i] != '=') {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (tmp == 0 || cur % tmp) return tsurai;\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n    if (sgn == '+') {\n      res += cur;\n    } else {\n      res -= cur;\n    }\n    if (i < s.length() && s[i] != '=') {\n      sgn = s[i++];\n    }\n  }\n  return res;\n}\n\nbool valid(const std::vector<std::string> &eqs, const std::vector<char> &cs) {\n  for (/* not const */ std::string eq: eqs) {\n    for (char &ch: eq)\n      if (ch >= 'A' && ch <= 'Z')\n        ch = cs[ch-'A'];\n\n    if (eq[0] == '=' || eq.back() == '=')\n      return false;\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] != '0') {\n        do {\n          ++i;\n        } while (i < eq.length() && isdigit(eq[i]));\n      } else {\n        if (i+1 < eq.length() && isdigit(eq[i+1]))\n          return false;\n      }\n    }\n\n    size_t i=0;\n    if (!isdigit(eq[i])) return false;\n    int lhs=fourt(eq, i);\n    assert(eq[i] == '=');\n    ++i;\n    if (!isdigit(eq[i])) return false;\n    int rhs=fourt(eq, i);\n    assert(i == eq.length());\n    \n    if (lhs == tsurai || rhs == tsurai || lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0)\n    return 1;\n\n  size_t ph='A';  // placeholder\n  std::vector<std::string> s(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] == '.')\n        s[i][j] = ph++;\n    }\n  }\n\n  std::vector<std::string> eqs;\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> cs(n);\n  for (size_t i=0; i<n; ++i)\n    scanf(\" %c\", &cs[i]);\n\n  std::sort(cs.begin(), cs.end());\n  do {\n    if (valid(eqs, cs))\n      return !printf(\"Yes\\n\");\n  } while (std::next_permutation(cs.begin(), cs.end()));\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n \nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n \nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n   \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n \n//  cout << (t.value ? \"T\" : \"F\") << endl;\n   \n  return t;\n}\n \n \nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n \nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n \nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n \n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n \nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n \nvector<pair<int,int>> blanks;\n \nvoid fill_blank() {\n  int i = 0;\n  REP(i, n) {\n    int x = blanks[i].first, y = blanks[i].second;\n    TABLE[x][y] = BLOCK[i];\n  }\n}\n \nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    y++;\n  }\n  return str;\n}\n \nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    x++;\n  }\n  return str;\n}\n \nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n \nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n \n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n \nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false;\n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n \n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false;\n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n \nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n \nvoid init() {\n  blanks.clear();\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n \nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n \n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n        if (row[x] == '.') {\n          blanks.push_back(make_pair(x, y));\n        }\n      }\n    }\n \n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n \n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define UNKNOWN 20\n#define UI unsigned int\nusing namespace std;\nint h,w,n;\nchar m[10][10], r[10];\n//vector<string> form;\nstring form[1000];\nUI formLen;\nint map[10]; // u·¶ÖÌÊ\n\nconst int UNCAL = -1111111;\nconst int PLUS  = UNCAL -1;\nconst int MINUS = PLUS  -1;\nint cal( string s ){\n  string a;\n  int v[10];\n  UI vLen=0;//vector<int> v;\n  bool isNum=true;\n  int kind=0; // 0:+,- 1:* 2:/\n  for( UI i=0;i<s.length();i++ ){\n    if( isNum ){\n      a=\"\";\n      while( i<s.length() && '0'<=s[i] && s[i]<='9' ) a+=s[i++];\n      --i;\n\n      if( a.length()==0 ) return UNCAL;\n      if( a[0]=='0' && a.length()!=1 ) return UNCAL;\n      int number = atoi( a.c_str() );\n\n      if( kind==0 ) v[vLen++]=number;\n      else if( kind==1 ){ // *\n\tv[ vLen-1 ] *= number;\n      }else{ // /\n\tif( number==0 ) return UNCAL;\n\tif( v[vLen-1]%number !=0 ) return UNCAL;\n\tv[ vLen-1 ] /= number;\n      }\n    }else{\n      kind = 0;\n      if( s[i]=='+' )      v[ vLen++ ] = PLUS;\n      else if( s[i]=='-' ) v[ vLen++ ] = MINUS;\n      else if( s[i]=='*' ) kind=1;\n      else if( s[i]=='/' ) kind=2;\n      else return UNCAL;\n    }\n    isNum = !isNum;\n  }\n  if( vLen==0 ) return UNCAL;\n\n  int ret = v[0];\n  for( UI i=1;i<vLen;i+=2 ){\n    if( v[i]==PLUS && i+1<vLen ) ret += v[i+1];\n    else if( v[i]==MINUS && i+1<vLen ) ret-=v[i+1];\n    else return UNCAL;\n  }\n\n  return ret;\n}\n\nbool checkForm( string s ){\n  int a,b;\n  UI i=s.find(\"=\");\n\n  if( i==string::npos || i+1==s.length() )\n    return false;\n  if( (a=cal(s.substr(0,i)))==UNCAL )\n    return false;\n  b = cal( s.substr( i+1 ) );\n\n  return a==b;\n}\n\n\n/* i¶ÚÌóðu··é\n   j-1 ÔÚÜÅÌ form ÍNAµÄ¢éÆ·éB\n */\nbool solve(int i,UI j){\n  string s;\n  // ®`FbN\n  for( ; j<formLen;j++ ){\n    s=\"\";\n    UI k;\n    for( k=0;k<form[j].length();k++ ){\n      if( form[j][k]<10 ){   // ¢mÌ¶iójª¶Ý\n\tif( form[j][k]<i )\n\t  s = s + r[ map[(int)form[j][k]] ];\n\telse                 // ¢è¶ª¶Ý·é®\n\t  k = form[j].length()+100;\n      }else\n\ts = s + form[j][k];\n    }\n    if( k>form[j].length() ) break;\n    if( !checkForm( s ) ) // ®ÆÈçÈ©Á½\n      return false;\n  }\n\n  if( j==formLen ) return true;\n  if( i==n ) return false;\n\n  // i+1 ÔÚÌ`FbN\n  // map[i+1] É map[j]!=map[i][j] ( j<i )ÆÈélðãü\n  for( int k=0,l;k<n;k++ ){\n    map[i] = k;\n    for( l=0;l<i;l++ )\n      if( map[i] == map[l] ) break;\n    if( l!=i ) continue;\n    if( solve( i+1,j ) )\n      return true;    \n  }\n  return false;\n}\n\nint main(){\n  while( cin>>h>>w && (h||w) ){\n    int in=0; // ó}XCfbNX\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> m[i][j];\n\tif( m[i][j]=='.' ) m[i][j]=in++;\n      }\n    cin >> n;\n    for( int i=0;i<n;i++ )\n      cin >> r[i];\n\n    formLen=0;\n    string s;\n    // ¡ûüÌ®\n    for( int i=0;i<h;i++ ){\n      for( int j=0;j<w;j++ ){\n\ts=\"\";\n\twhile( m[i][j]=='#' ) j++;\n\twhile( j<w && m[i][j]!='#' ) s+=m[i][j++];\n\tif( s.length()>2 ) form[formLen++] = s;\n      }\n    }\n    // cûüÌ®\n    for( int j=0;j<w;j++ ){\n      for( int i=0;i<h;i++ ){\n\ts=\"\";\n\twhile( m[i][j]=='#' ) i++;\n\twhile( i<h && m[i][j]!='#' ) s+=m[i++][j];\n\tif( s.length()>2 ) form[formLen++] = s;\n      }\n    }\n\n    if( solve( 0,0 ) ) cout << \"Yes\" << endl;\n    else               cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int INF = 1<<24;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  //  int st = pos;\n  //  int l = 0;\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  if(s[pos] == '0' && pos+1 < s.size() && isdigit(s[pos+1])) {\n    //if(s[st] == '0') {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  string num = \"\";\n  while(pos < s.size() && isdigit(s[pos])) {\n    num += s[pos++];\n  }\n\n  return atoi(num.c_str());\n  //return atoi(s.substr(st, l).c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int value = getNum(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      value = getNum(s, pos);\n      if(value == INF) return INF;\n      x *= value;\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == INF) return INF;\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn INF;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int value = term(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x += value;\n    } else if(s[pos] == '-') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x -= value;\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n\n      }\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n    sort(T, T+N);\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15]){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nbool check(char m[15][15]){\n    vector<int> s;\n    bool f;\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++){\n                    if(m[k][j] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++){\n                    str.push_back(m[i][k]);\n                    if(m[i][k] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h){\n                rep(j,w){\n                    scanf(\"%c\",&m[i + 1][j + 1]);\n                    if(m[i + 1][j + 1] == '.'){\n                        y[k] = i + 1;\n                        x[k] = j + 1;\n                        k++;\n                    }\n                }\n               scanf(\"%*c\");\n            }\n        }\n\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n        if(not check(m)){\n            cout << \"NO\" << endl;\n            continue;\n        }\n\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\nstring puzzle[MAX_SIZE];\n\nint n;\nchar in[MAX_N];\n\nchar letters[128];\n\nint parse(const string &s, int l, int r) {\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '+') return parse(s, l, i) + parse(s, i + 1, r);\n\t\tif(s[i] == '-') return parse(s, l, i) - parse(s, i + 1, r);\n\t}\n\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '*') return parse(s, l, i) * parse(s, i + 1, r);\n\t\tif(s[i] == '/') {\n\t\t\tconst int left = parse(s, l, i);\n\t\t\tconst int right = parse(s, i + 1, r);\n\n\t\t\tif(right == 0) throw \"division by zero\";\n\t\t\tif(left % right) throw \"division leaving a remainder\";\n\n\t\t\treturn left / right;\n\t\t}\n\t}\n\n\tif(r <= l || !isdigit(s[l]) || (s[l] == '0' && r - l > 1)) throw \"parse error\";\n\treturn stoi(s.substr(l, r - l));\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tif(parse(left, 0, left.size()) != parse(right, 0, right.size())) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w));\n\tint next = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '.') idx[i][j] = next++;\n\t\t}\n\t}\n\n\tvector<pair<int, vector<int>>> expressions;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> tmp;\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\ttmp.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\texpressions.emplace_back(max_index, tmp);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> tmp;\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\ttmp.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\texpressions.emplace_back(max_index, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tletters[idx] = in[i];\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\ntypedef long long int lli;\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\ninline\nint calc(const string &s)\n{\n  istringstream iss( s );\n\n  static int num[11];\n  static char op[11];\n  int num_size = 0;\n  int op_size = 0;\n\n  static int n;\n  static char c;\n\n  while( iss >> n ){    \n    num[ num_size++ ] = n;\n    if( iss >> c )op[ op_size++ ] = c;\n    else break;\n  }\n  \n  for(int i=0; i<op_size; ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    num[i+1] = 0;\n    op[i] = '+';\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op_size; ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\ninline\nbool check_syntax(const string &s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\nstruct F{\n  pair<int, int> v[11];\n  int v_size;\n  F(){ v_size = 0; }  \n};\n\ninline\nstring build(F f)\n{\n  string s;\n  for(int i=0; i<f.v_size; ++i){\n    s += g[ f.v[i].first ][ f.v[i].second ];\n  }\n  return s;\n}\n\ninline\nlli cpy(char c)\n{\n  if( isdigit(c) ) return c - '0';\n  if( c == '+' ) return 10;\n  if( c == '*' ) return 11;\n  if( c == '/' ) return 12;\n  if( c == '-' ) return 13;\n  return -(1LL << 60);\n}\n\nset<lli> valid, invalid;\nbool solve(char p[], int size, int h, int w)\n{\n  int i, j;\n\n  for(i=0; i<h; ++i){\n    for(j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      static const int di[] = {0, 0, -1, 1};\n      static const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  static pair<int, int> emp[10 * 10 + 1];\n  int emp_size = 0;\n  for(i=0; i<h; ++i){\n    for(j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp[emp_size++] = make_pair(i, j);\n    }\n  }\n\n  if( emp_size != size )return false;\n\n  static char puz[H][W];\n  static F v[1000];  \n\n  fill( v, v + 1000, F() );\n\n  int v_size = 0;\n\n  copy( g[0], g[H], puz[0] );\n  for(i=0; i<h; ++i){\n    for(j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v[ f.v_size++ ] = make_pair(ni, nj);\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v_size ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }  \n\n  if( v_size == 0 )return true;\n  \n  copy( g[0], g[H], puz[0] );\n  for(i=0; i<h; ++i){\n    for(j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v[ f.v_size++ ] = make_pair(ni, nj);\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v_size ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }\n\n  sort( p, p + size );\n  do{\n    \n    for(i=0; i<emp_size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    bool flg = true;\n    static int a, b;\n    static lli h;\n    for(i=0; i<v_size && flg; ++i){\n      string s;\n      h = 0;\n      for(j=0; j<v[i].v_size; ++j){\n\ta = v[i].v[j].first;\n\tb = v[i].v[j].second;\n\ts += g[a][b];\n\th = ((h + cpy( g[a][b] )) * 19LL) % (1LL << 61);\n      }\n      if( invalid.count( h ) ) flg = false;\n      else if( valid.count( h ) ) flg = true;\n      else if( !check_syntax(s) ){\n\tinvalid.insert( h );\n\tflg = false;\n      }\n      else valid.insert( h );\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w, i, j;\n  while( scanf(\"%d%d\\n\", &h, &w) != EOF && (h | w) ){\n    for(i=0; i<h; ++i){\n      for(j=0; j<w; ++j){\n\tscanf(\"%c\", &g[i][j]);\n      }\n      scanf(\"\\n\");\n    }\n    static int n;\n    static char m[10];\n    cin >> n;\n    for(i=0; i<n; ++i){\n      cin >> m[i];\n    }\n    puts( solve(m, n, h, w) ? \"Yes\" : \"No\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nbool ck(); bool ck2(bool,int,int,int);\nbool rec(); bool rec2(bool,int,int,int);\n\nint h,w,n;\nchar bd[10][11];\nchar lst[10];\n\nint eval(char *expr,int s,int t)\n{\n\t//dbg(expr); for(int i=s;i<t;i++)assert(expr[i]!='.');\n\tint p=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='+'||expr[p]=='-')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\treturn expr[p]=='+'?a+b:a-b;\n\t}\n\tp=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='*'||expr[p]=='/')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\tif(expr[p]=='/'&&(b==0||a%b!=0))return inf;\n\t\treturn expr[p]=='*'?a*b:a/b;\n\t}\n\t\n\tint ret=0;\n\tfor(p=t-1;p>=s;p--)ret*=10,ret+=expr[p]-'0';\n\treturn ret;\n}\nbool ck2(bool tate,int y,int b,int x)\n{\n\tchar lhs[11]={0},rhs[11]={0}; int l=0,r=0;\n\tif(tate)\n\t{\n\t\tfor(;b<y;b++)\n\t\t{\n\t\t\tif(bd[b][x]=='=')break;\n\t\t\tlhs[l++]=bd[b][x];\n\t\t}\n\t\tb++;\n\t\tfor(;b<y;b++)rhs[r++]=bd[b][x];\n\t}\n\telse\n\t{\n\t\tfor(;b<x;b++)\n\t\t{\n\t\t\tif(bd[y][b]=='=')break;\n\t\t\tlhs[l++]=bd[y][b];\n\t\t}\n\t\tb++;\n\t\tfor(;b<x;b++)rhs[r++]=bd[y][b];\n\t}\n\t\n\tint a=eval(lhs,0,l); b=eval(rhs,0,r);\n\treturn a!=inf&&b!=inf&&a==b;\n}\nbool ck()\n{\n\trep(i,h)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(j,w+1)\n\t\t{\n\t\t\tif(j==w||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&!dot)\n\t\t\t\t{\n\t\t\t\t\tif(!ck2(0,i,beg,j))return 0;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=j+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\trep(j,w)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(i,h+1)\n\t\t{\n\t\t\tif(i==h||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&!dot)\n\t\t\t\t{\n\t\t\t\t\tif(!ck2(1,i,beg,j))return 0;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=i+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\t\n\treturn 1;\n}\nbool rec2(bool tate,int y,int b,int x)\n{\n\t//cerr<<tate<<\" \"<<y<<\" \"<<b<<\" \"<<x<<endl;\n\tif(tate)\n\t{\n\t\tassert(b<=y);\n\t\tif(y==b)return ck()&&rec();\n\t\tif(bd[b][x]!='.')return rec2(1,y,b+1,x);\n\t\trep(i,n)if(lst[i])\n\t\t{\n\t\t\tbd[b][x]=lst[i]; lst[i]=0;\n\t\t\tif(rec2(1,y,b+1,x))return 1;\n\t\t\tlst[i]=bd[b][x]; bd[b][x]='.';\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(x==b)return ck()&&rec();\n\t\tif(bd[y][b]!='.')return rec2(0,y,b+1,x);\n\t\trep(i,n)if(lst[i])\n\t\t{\n\t\t\tbd[y][b]=lst[i]; lst[i]=0;\n\t\t\tif(rec2(0,y,b+1,x))return 1;\n\t\t\tlst[i]=bd[y][b]; bd[y][b]='.';\n\t\t}\n\t}\n\treturn 0;\n}\nbool rec()\n{\n\trep(i,h)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(j,w+1)\n\t\t{\n\t\t\tif(j==w||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&dot)\n\t\t\t\t{\n\t\t\t\t\tif(rec2(0,i,beg,j))return 1;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=j+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\trep(j,w)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(i,h+1)\n\t\t{\n\t\t\tif(i==h||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&dot)\n\t\t\t\t{\n\t\t\t\t\tif(rec2(1,i,beg,j))return 1;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=i+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\t\n\trep(i,h)rep(j,w)if(bd[i][j]=='.')return 0;\n\treturn ck();\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\trep(i,h)scanf(\"%s\",bd[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n)scanf(\" %c\",lst+i);\n\t\t\n\t\tputs(rec()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (!stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) {\n\t\t\tflag &= eq.evaluate(s_map);\n\t\t\tif (!flag) break;\n\t\t}\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 15)) return false;\n    if(k == L) return true;\n    vector<int> perm;\n    for(int i = 0; i < vc.size(); i++) if(!used[i]) perm.push_back(i);\n    random_shuffle(perm.begin(), perm.end());\n    for(auto i : perm) {\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    srand(time(NULL));\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n\n  void init(){ pos=0;len=s.size();flag=false;}\n\n  int head2Num(){\n    if(!isNum(s[pos]))flag=true;\n\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    char ch;\n    while(s[pos]=='*'||s[pos]=='/'){\n      ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      else if(ch=='/'){\n\tif(num==0){flag=true;num=1;}\n\tif(res%num>0)flag=true;\n\tres/=num;\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]==')'){pos++;break;}\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n\n  for(int i=0;i<(int)w.size();i++){\n    if(compute(i)==false)return false;\n  }\n  return true;\n}\n\nbool compute(int x){\n\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.s.push_back('=');\n  b.s.push_back('=');\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF){\n    return false;\n  }\n\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tbool evaluated;\n\tbool evaluated_ans;\n\t\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t\t\n\t\tevaluated = true;\n\t\tfor (char c : A) evaluated &= (isdigit(c) || c == '+' || c == '-' || c == '*' || c == '/');\n\t\tfor (char c : B) evaluated &= (isdigit(c) || c == '+' || c == '-' || c == '*' || c == '/');\n\t\t\n\t\tevaluated_ans = false;\n\t\tif (evaluated) evaluated_ans = evaluate(\"\");\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (!stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tif (evaluated_ans) return true;\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) {\n\t\t\tflag &= eq.evaluate(s_map);\n\t\t\tif (!flag) break;\n\t\t}\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 15)) return false;\n    if(k == L) return true;\n    vector<int> perm;\n    for(int i = 0; i < vc.size(); i++) if(!used[i]) perm.push_back(i);\n    random_shuffle(perm.begin(), perm.end());\n    for(auto i : perm) {\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    srand(time(NULL));\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n        if(++iter > (1 << 15) && rand() % 5 == 0) ans = true;\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) ((l)<=(x) && (x)<(r))\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if(  s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint parse(int l, int r, const string &s){\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=l;i<r;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  int a = parse(0,p,s);\n  int b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (a % b != 0 || b == 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (num != -1) {\n\t\t\t\t\tstack_num.push(num);\n\t\t\t\t\tnum = -1;\n\t\t\t\t\twhile (stack_op.top() == '*' || stack_op.top() == '/') {\n\t\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tif (a != n) return false;\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) flag &= eq.evaluate(s_map);\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (cur % tmp > 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq[0] == '-') return false;\n    if (!isdigit(eq[0]) || !isdigit(eq.back())) return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') return false;\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct invalid {};\ntypedef const char *Iterator;\n\nint eval_factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw invalid();\n  }\n  if (*it < '0' || '9' < *it) {\n    throw invalid();\n  }\n  int val = *it - '0';\n  ++it;\n  if (val == 0) {\n    return val;\n  }\n  while (it != last && '0' <= *it && *it <= '9') {\n    val = 10*val + (*it - '0');\n    ++it;\n  }\n  return val;\n}\n\nint eval_term(Iterator& it, const Iterator& last)\n{\n  int val = eval_factor(it, last);\n  while (it != last && (*it == '*' || *it == '/')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_factor(it, last);\n    if (op == '*') {\n      val *= x;\n    } else {\n      val /= x;\n    }\n  }\n  return val;\n}\n\nint eval_expr(Iterator& it, const Iterator& last)\n{\n  int val = eval_term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_term(it, last);\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return val;\n}\n\nbool check(Iterator it, const Iterator& last) try\n{\n  const int l = eval_expr(it, last);\n  if (it == last || *it != '=') {\n    return false;\n  }\n  ++it;\n  const int r = eval_expr(it, last);\n  return it == last && l == r;\n} catch (const invalid&) {\n  return false;\n}\n\nstatic const int M = 15;\n\nbool extract_expr(char (*dst)[M], pair<int,int> (*tbl)[2], const char rows[M][M], int H, int W, int& s)\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (j == 0 || rows[i][j-1] == '#') {\n        const int k = j;\n        ++j;\n        while (j < W && rows[i][j] != '#') {\n          ++j;\n        }\n        if (j-k > 2) {\n          bool b = false;\n          for (int l = k; l < j; l++) {\n            dst[s][l] = rows[i][l];\n            if (rows[i][l] >= 'a') {\n              b = true;\n              pair<int,int> *t = tbl[rows[i][l]-'a'];\n              if (t[0].first != -1) {\n                t[1].first = s;\n                t[1].second = l;\n              } else {\n                t[0].first = s;\n                t[0].second = l;\n              }\n            }\n          }\n          dst[s][j-k] = '\\0';\n          ++s;\n          if (!b && !check(rows[i]+k, rows[i]+j)) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(char (*exprs)[M], int s, char *cards, int N, const pair<int,int> (*tbl)[2])\n{\n  do {\n    for (int i = 0; i < N; i++) {\n      if (tbl[i][0].first >= 0) {\n        exprs[tbl[i][0].first][tbl[i][0].second] = cards[i];\n      }\n      if (tbl[i][1].first >= 0) {\n        exprs[tbl[i][1].first][tbl[i][1].second] = cards[i];\n      }\n    }\n    for (int i = 0; i < s; i++) {\n      if (!check(exprs[i], exprs[i]+strlen(exprs[i]))) {\n        goto FAIL;\n      }\n    }\n    return true;\nFAIL:\n    ;\n  } while (next_permutation(cards, cards+N));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (scanf(\"%d %d\", &H, &W) != EOF && H != 0) {\n    char rows[M][M], cols[M][M];\n    int n = 0;\n    for (int i = 0; i < H; i++) {\n      scanf(\"%s\", rows[i]);\n      for (int j = 0; j < W; j++) {\n        if (rows[i][j] == '.') {\n          rows[i][j] = 'a' + n;\n          ++n;\n        }\n        cols[j][i] = rows[i][j];\n        cols[j][H] = '\\0';\n      }\n    }\n    int N;\n    scanf(\"%d\", &N);\n    char cards[M];\n    for (int i = 0; i < N; i++) {\n      char buf[4];\n      scanf(\"%s\", buf);\n      cards[i] = buf[0];\n    }\n    sort(cards, cards+N);\n    cards[N] = '\\0';\n\n    static char exprs[100][M];\n    static pair<int,int> tbl[10][2];\n    for (int i = 0; i < 10; i++) {\n      tbl[i][0].first = tbl[i][1].second = -1;\n    }\n    int s = 0;\n    if (!extract_expr(exprs, tbl, rows, H, W, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (!extract_expr(exprs, tbl, cols, W, H, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (s == 0) {\n      puts(\"Yes\");\n      continue;\n    }\n    if (solve(exprs, s, cards, N, tbl)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*'){\n\tres*=num;\n      }\n      if(ch=='/'){\n\tif(num!=0&&res%num>=0)res/=num;\n\telse flag=true;\n\t\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w;\n\nbool solve();\nbool check();\nbool compute();\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++){\n    v=w[i];\n    if(compute())return true;\n  }\n  return false;\n}\n\nbool compute(){\n  for(int i=0;i<(int)v.size();i++)\n      if('A'<=v[i]&&v[i]<='Z')v[i]=u[v[i]-'A'];\n  string a=\"\",b=\"\";\n  bool flg=false;\n  b.push_back(v[0]);\n  for(int i=1;i<(int)v.size();i++){\n      if(!isNum(v[i-1])&&!isNum(v[i]))return false;\n      if(!isNum(v[i-1])&&v[i]=='0')return false;\n      if(v[i-1]=='0'&&v[i]=='0')return false;\n      if(v[i]=='=')flg=true;\n      else if(flg)a.push_back(v[i]);\n      else b.push_back(v[i]);\n  }\n  if(!isNum(v[0])||!isNum(v[v.size()-1]))return false;\n\n  if(v[0]=='0'&&isNum(v[1]))return false;\n\n  if(flg==false)return false;\n\n  calcStr x,y;\n  x.s=a;\n  x.init();\n  y.s=b;\n  y.init();\n\n  int A = x.getAns();\n  int B = y.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint idx;\nchar s[11];\nbool res;\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-' || s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex();\n\tASRT;\n\tif(a!=b || s[idx]) res=false;\n}\n\nbool parse(){\n\tif(strlen(s)<=2) return true;\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nbool calc_no_space(){\n\trep(i,h){\n\t\tint p=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\trep(k,j-p) s[k]=B[i][p+k];\n\t\t\t\t\ts[j-p]='\\0';\n\t\t\t\t\tif(strchr(s,'.')==0 && !parse()) return false;\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\tint p=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\trep(k,i-p) s[k]=B[p+k][j];\n\t\t\t\t\ts[i-p]='\\0';\n\t\t\t\t\tif(strchr(s,'.')==0 && !parse()) return false;\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nchar key[10];\nint n,qx[10],qy[10];\nbool dfs(int k,bool *used){\n\tif(k==n) return true;\n\n\trep(l,n) if(!used[l]) {\n\t\tused[l]=true;\n\t\tB[qy[k]][qx[k]]=key[l];\n\n\t\tbool ok=true;\n\t\tint x1=qx[k],x2=qx[k];\n\t\twhile(x1>=0 && B[qy[k]][x1]!='#') x1--; x1++;\n\t\twhile(x2< w && B[qy[k]][x2]!='#') x2++;\n\t\trep(j,x2-x1) s[j]=B[qy[k]][x1+j];\n\t\ts[x2-x1]='\\0';\n\t\tif(count(s,s+x2-x1,'.')==0 && !parse()) ok=false;\n\n\t\tint y1=qy[k],y2=qy[k];\n\t\twhile(y1>=0 && B[y1][qx[k]]!='#') y1--; y1++;\n\t\twhile(y2< w && B[y2][qx[k]]!='#') y2++;\n\t\trep(i,y2-y1) s[i]=B[y1+i][qx[k]];\n\t\ts[y2-y1]='\\0';\n\t\tif(count(s,s+y2-y1,'.')==0 && !parse()) ok=false;\n\n\t\tbool ok2=false;\n\t\tif(ok && dfs(k+1,used)) ok2=true;\n\n\t\tused[l]=false;\n\t\tB[qy[k]][qx[k]]='.';\n\n\t\tif(ok2) return true;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tbool used[10]={};\n\t\tputs(calc_no_space()&&dfs(0,used)?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<int,int> num(const string &f, int i) {\n  int n = 0;\n  if (i >= f.size() || !isdigit(f[i])) throw \"puee\";\n  while(i < f.size()) {\n    if(!isdigit(f[i])) return make_pair(n,i);\n    n *= 10;\n    n += f[i] - '0';\n    ++i;\n  }\n  return make_pair(n,i);\n}\n\nbool ispm(char c) { return c == '+' || c == '-'; }\nbool istd(char c) { return c == '*' || c == '/'; }\n\npair<int,int> mult(const string &f, int i) {\n  int n;\n  tie(n,i) = num(f,i);\n  while(i != f.size() && istd(f[i])) {\n    auto np = num(f,i+1);\n    if(f[i] == '*') {\n      n *= np.first;\n    }else if(f[i] == '/') {\n      if (np.first == 0) throw \"guee\";\n      n /= np.first;\n    }\n    i = np.second;\n  }\n  return make_pair(n,i);\n}\n\npair<int,int> add(const string &f, int i) {\n  int n;\n  tie(n,i) = mult(f,i);\n  while(i != f.size() && ispm(f[i])) {\n    auto np = mult(f,i+1);\n    if(f[i] == '+') {\n      n += np.first;\n    }else if(f[i] == '-') {\n      n -= np.first;\n    }\n    i = np.second;\n  }\n  return make_pair(n,i);\n}\n\nbool is_valid(const string &f, int st, int ed) {\n  int p,q;\n  try {\n    tie(p,st) = add(f, st);\n    if (st >= ed) return false;\n    tie(q,st) = add(f, st+1);\n  } catch(...) {\n    return false;\n  }\n  return st == ed && p == q;\n}\n\nbool is_invalid(const string &f, int st, int ed) {\n  string s = \"+-*/=\";\n  bool prev = true;\n  for(int i=st;i < ed; ++i) {\n    if(s.find(f[i]) != string::npos) {\n      if (prev) return true;\n      prev = true;\n    } else {\n      prev = false;\n    }\n  }\n  return prev;\n}\n\nbool is_closed(const string &f, int st, int ed) {\n  for(int i=st;i < ed;++i) if (f[i] == '.') return false;\n  return true;\n}\n\nbool is_valid_2_impl(const vector<string> &tb) {\n  for(auto &line : tb) {\n    int old = 0;\n    REP(i,line.size()) {\n      if(!i) continue;\n      if (line[i] == '#') {\n        if (i-old-1 >= 3){\n          if(is_closed(line,old+1,i)\n              && !is_valid(line,old+1,i)) return false;\n        }\n        old = i;\n      }\n    }\n  }\n  return true;\n}\n\nbool is_valid_2(const vector<string> &tb) {\n  if(!is_valid_2_impl(tb)) return false;\n  vector<string> tr(tb[0].size());\n  REP(i,tb.size())\n    REP(j,tb[0].size())\n      tr[j] += tb[i][j];\n  return is_valid_2_impl(tr);\n}\n\nbool is_bad(const string &str, int s, int t) {\n  return is_invalid(str,s,t) ||\n    (is_closed(str,s,t) && !is_valid(str,s,t));\n}\n\nbool search(vector<string> &tb, vector<tuple<int,int>> op, const vector<string> &v) {\n  if (op.empty()) return true;\n  int i,j;\n  tie(i,j) = op.back();\n  op.pop_back();\n  int n=v.size();\n  REP(k,n) {\n    auto cp = v;\n    cp.erase(begin(cp)+k);\n    tb[i][j] = v[k][0];\n    int s,t;\n    s=t=i;\n    while(tb[s][j] != '#') --s;\n    while(tb[t][j] != '#') ++t;\n    ++s;\n    int l=t-s;\n    if (t-s >= 3) {\n      string str;\n      REP(m,l) str += tb[s+m][j];\n      if(is_bad(str,0,l)) continue;\n    }\n    s=t=j;\n    while(tb[i][s] != '#') --s;\n    while(tb[i][t] != '#') ++t;\n    ++s;\n    if(t-s >= 3 && is_bad(tb[i],s,t)) continue;\n    if (search(tb,op,cp)){\n      tb[i][j] = '.';\n      return true;\n    }\n  }\n  tb[i][j] = '.';\n  return false;\n}\n\nint main() {\n  while(1){\n    int h,w;\n    cin>>h>>w;\n    if(!h) break;\n    vector<string> tb(h+2,string(w+2,'#'));\n    REP(i,h){\n      string l;\n      cin>>l;\n      tb[i+1] = '#' + l + '#';\n    }\n    h+=2;w+=2;\n    int n;\n    cin>>n;\n    vector<string> v(n);\n    REP(i,n) cin>>v[i];\n    vector<tuple<int,int>> op;\n    REP(i,h)REP(j,w)if(tb[i][j]=='.')op.emplace_back(i,j);\n    if (!is_valid_2(tb)) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    bool ans = search(tb,op,v);\n    if (ans)\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    return res;\n}\nchar select[10];\nbool used[10];\nint H, W, L;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select[k] = vc[i];\n        used[i] = true;\n        for(auto s : check[k]){\n            string s1, s2;\n            for(auto& c : s) {\n                if(islower(c)){\n                    c = select[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<int> bx, by;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bx.push_back(x); by.push_back(y); grid[y][x] = bx.size() - 1 + 'a';}\n\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 1 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 1 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\nint calc(string s)\n{\n  istringstream iss( s );\n  vector<int> num;\n  vector<char> op;\n  int n;\n  char c;\n  while( iss >> n ){    \n    num.push_back( n );\n    if( iss >> c )op.push_back( c );\n    else break;\n  }\n  \n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    else assert( false && \"invalid op\" );\n    num.erase( num.begin() + i + 1);\n    op.erase( op.begin() + i );\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\nbool check_syntax(string s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\n\nstruct F{\n  vector< pair<int, int> > v;\n  F(){ v.clear(); }\n};\n\nstring build(F f)\n{\n  string s;\n  for(int i=0; i<f.v.size(); ++i){\n    s += g[ f.v[i].first ][ f.v[i].second ];\n  }\n  return s;\n}\n\nbool solve(char p[], int size, int h, int w)\n{\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n\n  //puts(\"0001\");\n\n  static pair<int, int> emp[10 * 10 + 1];\n  int emp_size = 0;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp[emp_size++] = make_pair(i, j);\n    }\n  }\n\n  //puts(\"0002\");\n\n  if( emp_size != size )return false;\n\n  static char puz[H][W];\n  static F v[1000];  \n\n  fill( v, v + 1000, F() );\n\n  int v_size = 0;\n\n  //puts(\"0003\");\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }  \n\n\n  if( v_size == 0 )return true;\n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }\n\n  sort( p, p + size );\n  do{\n\n    for(int i=0; i<emp_size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    bool flg = true;\n    for(int i=0; i<v_size && flg; ++i){\n      string s;\n      for(int j=0; j<v[i].v.size(); ++j){\n\tint a = v[i].v[j].first;\n\tint b = v[i].v[j].second;\n\ts += g[a][b];\n      }\n      if( !check_syntax(s) ) flg = false;\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( scanf(\"%d%d\\n\", &h, &w) != EOF && (h | w) ){\n\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tscanf(\"%c\", &g[i][j]);\n      }\n      scanf(\"\\n\");\n    }\n\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n\n    puts( solve(m, n, h, w) ? \"Yes\" : \"No\" );\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if (incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if (incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) goto INCORRECT;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) goto INCORRECT;\n      }\n      return true;\n\nINCORRECT:\n      ;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  string num = \"\";\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return -1;\n  }\n  while(pos < s.size() && isdigit(s[pos])) {\n    num += s[pos++];\n  }\n  if(num[0] == '0') {\n    pos = s.size();\n    flag = true;\n    return -1;\n  }\n  return atoi(num.c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int x = getNum(s, pos);\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      x *= getNum(s, pos);\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn -1;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int x = term(s, pos);\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      x += term(s, pos);\n    } else if(s[pos] == '-') {\n      ++pos;\n      x -= term(s, pos);\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  int cnt;\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n    ++cnt;\n  } while(x < W && y < H);\n\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b ? cnt : 0;\n}\n\nbool judge() {\n  int a;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(a = check(j, i, 0) == 0) return false;\n\tj += a;\n      }\n    }\n  }\n  for(int j = 0; j < W; ++j) {\n    for(int i = 0; i < H; ++i) {\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(a = check(j, i, 1) == 0) return false;\n\ti += a;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  if (r.p >= s.size()) throw IterExceedExc;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  if (p >= s.size()) throw IterExceedExc;\n  result r = factor(s, p);\n  while (r.p+1 < s.size() and (s[r.p] == '+' or s[r.p] == '-')) {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = term(s, p);\n  while (r.p+1 < s.size() and (s[r.p] == '*' or s[r.p] == '/')) {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (p >= s.size()) { throw IterExceedExc; }\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (p < s.size() and isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch(int ex) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, MAX_N> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint parse(const string &s, int l, int r) {\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '+') return parse(s, l, i) + parse(s, i + 1, r);\n\t\tif(s[i] == '-') return parse(s, l, i) - parse(s, i + 1, r);\n\t}\n\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '*') return parse(s, l, i) * parse(s, i + 1, r);\n\t\tif(s[i] == '/') {\n\t\t\tconst int left = parse(s, l, i);\n\t\t\tconst int right = parse(s, i + 1, r);\n\n\t\t\tif(right == 0) throw \"division by zero\";\n\t\t\tif(left % right) throw \"division leaving a remainder\";\n\n\t\t\treturn left / right;\n\t\t}\n\t}\n\n\tif(r <= l || !isdigit(s[l]) || (s[l] == '0' && r - l > 1)) throw \"parse error\";\n\treturn stoi(s.substr(l, r - l));\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tif(parse(left, 0, left.size()) != parse(right, 0, right.size())) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w));\n\tint next = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '.') idx[i][j] = next++;\n\t\t}\n\t}\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tif(is_operator[i] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[i]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e] = true;\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tis_operator.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t\tif(in[i] == '+' || in[i] == '-' || in[i] == '*' || in[i] == '/') {\n\t\t\t\tis_operator[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15]){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nbool check(char m[15][15]){\n    vector<int> s;\n    requireString(m);\n    return 0;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h){\n                rep(j,w){\n                    scanf(\"%c\",&m[i + 1][j + 1]);\n                    if(m[i + 1][j + 1] == '.'){\n                        y[k] = i + 1;\n                        x[k] = j + 1;\n                        k++;\n                    }\n                }\n               scanf(\"%*c\");\n            }\n        }\n\n       // if(check(m)){\n       //     cout << \"NO\" << endl;\n       //     continue;\n       // }\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar a[13][13],e[10];\nmap<pair<int,int>,int> b,c;\nvector<pair<int,int> > d;\nint f[10],n;\nbool fj(int x,int y,int dx,int dy){\n  int i,j;\n  string s;\n  for(i=0;a[y+dy*i][x+dx*i]!='#';++i)\n    s+=a[y+dy*i][x+dx*i];\n  int ln=s.length();\n  vector<pair<int,char> > h;\n  for(i=0;i<ln;i=j+1){\n    for(j=i+1;j<ln&&'0'<=s[j]&&s[j]<='9';++j);\n    string t=s.substr(i,j-i);\n    if(j-i>1&&t[0]=='0')\n      return false;\n    h.push_back(make_pair(atoi(t.c_str()),'\\0'));\n    if(j<ln)\n      h.push_back(make_pair(0,s[j]));\n  }\n  for(i=0;i<(int)h.size();++i){\n    if(h[i].second=='*'){\n      h[i-1].first*=h[i+1].first;\n      h.erase(h.begin()+i,h.begin()+i+2);\n      i-=2;\n    }\n    if(h[i].second=='/'){\n      if(h[i+1].first==0||h[i-1].first%h[i+1].first)\n\treturn false;\n      h[i-1].first/=h[i+1].first;\n      h.erase(h.begin()+i,h.begin()+i+2);\n      i-=2;\n    }\n  }\n  for(i=0;i<(int)h.size();++i){\n    if(h[i].second=='+'){\n      h[i-1].first+=h[i+1].first;\n      h.erase(h.begin()+i,h.begin()+i+2);\n      i-=2;\n    }\n    if(h[i].second=='-'){\n      h[i-1].first-=h[i+1].first;\n      h.erase(h.begin()+i,h.begin()+i+2);\n      i-=2;\n    }\n  }\n  return h[0].first==h[2].first;\n}\nbool fi(int p){\n  int i;\n  if(p==n)\n    return true;\n  map<pair<int,int>,int>::iterator it=b.end(),jt=c.end();\n  bool g=false;  \n  for(i=0;a[d[p].first][d[p].second-i-1]!='#';++i);\n  if(b.count(make_pair(d[p].first,d[p].second-i))){\n    it=b.lower_bound(make_pair(d[p].first,d[p].second-i));\n    --(*it).second;\n    if(!(a[d[p].first][d[p].second-1]=='.'||('0'<=a[d[p].first][d[p].second-1]&&a[d[p].first][d[p].second-1]<='9'))||\n       !(a[d[p].first][d[p].second+1]=='.'||('0'<=a[d[p].first][d[p].second+1]&&a[d[p].first][d[p].second+1]<='9')))\n      g=true;\n  }\n  for(i=0;a[d[p].first-i-1][d[p].second]!='#';++i);\n  if(c.count(make_pair(d[p].first-i,d[p].second))){\n    jt=c.lower_bound(make_pair(d[p].first-i,d[p].second));\n    --(*jt).second;\n    if(!(a[d[p].first-1][d[p].second]=='.'||('0'<=a[d[p].first-1][d[p].second]&&a[d[p].first-1][d[p].second]<='9'))||\n       !(a[d[p].first+1][d[p].second]=='.'||('0'<=a[d[p].first+1][d[p].second]&&a[d[p].first+1][d[p].second]<='9')))\n      g=true;\n  }\n  for(i=0;i<n;++i){\n    if(f[i]||(g&&('0'>e[i]||e[i]>'9')))\n      continue;\n    a[d[p].first][d[p].second]=e[i];\n    if((it!=b.end()&&!(*it).second&&!fj((*it).first.second,(*it).first.first,1,0))||\n       (jt!=c.end()&&!(*jt).second&&!fj((*jt).first.second,(*jt).first.first,0,1)))\n      continue;\n    f[i]=-1;    \n    if(fi(p+1))    \n      return true;\n    f[i]=0;\n  }\n  a[d[p].first][d[p].second]='.';\n  if(it!=b.end())\n    ++(*it).second;\n  if(jt!=c.end())\n    ++(*jt).second;\n  return false;\n}\nint main(){\n  int i,j,k;\n  int h,w;\n  while(cin>>h>>w,h||w){\n    //char a[13][13];\n    for(i=0;i<13;++i)\n      for(j=0;j<13;++j)\n\ta[i][j]='#';\n    for(i=1;i<=h;++i){\n      cin>>&a[i][1];\n      for(j=0;a[i][j];++j);\n      a[i][j]='#';\n    }\n    //map<pair<int,int>,int> b,c;\n    //vector<pair<int,int> > d;\n    b.clear();\n    c.clear();\n    d.clear();\n    for(i=1;i<=h;++i){\n      for(j=1;j<=w;++j){\n\tif(a[i][j]=='#')\n\t  continue;\n\tif(a[i][j-1]=='#'&&a[i][j+1]!='#'&&a[i][j+2]!='#')\n\t  b[make_pair(i,j)]=0;\n\tif(a[i-1][j]=='#'&&a[i+1][j]!='#'&&a[i+2][j]!='#')\n\t  c[make_pair(i,j)]=0;\n\tif(a[i][j]=='.'){\n\t  for(k=0;a[i][j-k-1]!='#';++k);\n\t  if(b.count(make_pair(i,j-k)))\n\t    ++b[make_pair(i,j-k)];\n\t  for(k=0;a[i-k-1][j]!='#';++k);\n\t  if(c.count(make_pair(i-k,j)))\n\t    ++c[make_pair(i-k,j)];\n\t  d.push_back(make_pair(i,j));\n\t}\n      }\n    }\n    //int n;\n    cin>>n;\n    //char e[10];\n    for(i=0;i<n;++i)\n      cin>>e[i];\n    //int f[10];\n    memset(f,0,sizeof(f));\n    if(fi(0))\n      cout<<\"Yes\"<<endl;\n    else\n      cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nconst int TYPE_EQUATION = 1;\nconst int TYPE_EXPR = 2;\n\nstruct Result {\n\tResult(int _t, int _v = 0, int _p = 0) : t(_t), v(_v), p(_p) { }\n\tint t, v, p;\n};\n\n#define PARSER_DECL(name) Result name (const char *s, int p, int d)\n\nPARSER_DECL(equation);\nPARSER_DECL(expr);\nPARSER_DECL(term);\nPARSER_DECL(number);\n\nPARSER_DECL(equation){\n\tResult r = expr(s, p, d);\n\tif(s[r.p] != '='){ throw \"equals not found\"; }\n\tResult q = expr(s, r.p + d, d);\n\tif(s[q.p] != '#'){ throw \"equation is infinished\"; }\n\treturn Result(TYPE_EQUATION, r.v == q.v, q.p);\n}\nPARSER_DECL(expr){\n\tResult r = term(s, p, d);\n\twhile(s[r.p] == '+' || s[r.p] == '-'){\n\t\tResult q = term(s, r.p + d, d);\n\t\tif(s[r.p] == '+'){\n\t\t\tr.v += q.v;\n\t\t}else{\n\t\t\tr.v -= q.v;\n\t\t}\n\t\tr.p = q.p;\n\t}\n\treturn r;\n}\nPARSER_DECL(term){\n\tResult r = number(s, p, d);\n\twhile(s[r.p] == '*' || s[r.p] == '/'){\n\t\tResult q = number(s, r.p + d, d);\n\t\tif(s[r.p] == '*'){\n\t\t\tr.v *= q.v;\n\t\t}else{\n\t\t\tif(q.v == 0){ throw \"zero division\"; }\n\t\t\tif(r.v % q.v != 0){ throw \"can't divide\"; }\n\t\t\tr.v /= q.v;\n\t\t}\n\t\tr.p = q.p;\n\t}\n\treturn r;\n}\nPARSER_DECL(number){\n\tif(!isdigit(s[p])){ throw \"invalid number\"; }\n\tResult r(TYPE_EXPR, 0, p);\n\twhile(isdigit(s[r.p])){\n\t\tr.v = r.v * 10 + s[r.p] - '0';\n\t\tr.p += d;\n\t}\n\tif(r.p > p + d && s[p] == '0'){ throw \"leading zero\"; }\n\treturn r;\n}\n\nint main(){\n\twhile(true){\n\t\tchar field[11 * 11];\n\t\tint H, W;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0){ break; }\n\t\tvector<int> blanks;\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tchar *p = field + i * 11;\n\t\t\tcin >> p;\n\t\t\tp[W] = '#';\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tif(p[j] == '.'){ blanks.push_back(i * 11 + j); }\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= W; ++i){\n\t\t\tfield[H * 11 + i] = '#';\n\t\t}\n\t\tvector<pii> heads;\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tchar *l0 = field + (i - 1) * 11;\n\t\t\tchar *l1 = l0 + 11, *l2 = l1 + 11, *l3 = l2 + 11;\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tif(l1[j] == '#'){ continue; }\n\t\t\t\tif(i < H - 2){\n\t\t\t\t\tbool isHead = (i == 0 || l0[j] == '#');\n\t\t\t\t\tif(isHead && l2[j] != '#' && l3[j] != '#'){\n\t\t\t\t\t\theads.push_back(pii(i * 11 + j, 11));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j < W - 2){\n\t\t\t\t\tbool isHead = (j == 0 || l1[j - 1] == '#');\n\t\t\t\t\tif(isHead && l1[j + 1] != '#' && l1[j + 2] != '#'){\n\t\t\t\t\t\theads.push_back(pii(i * 11 + j, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<char> tokens(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\ttokens[i] = s[0];\n\t\t}\n\t\tsort(tokens.begin(), tokens.end());\n\t\tbool accept = false;\n\t\tdo {\n\t\t\tfor(int i = 0; i < n; ++i){ field[blanks[i]] = tokens[i]; }\n\t\t\tbool valid = true;\n\t\t\tfor(int i = 0; i < heads.size(); ++i){\n\t\t\t\ttry {\n\t\t\t\t\tResult r = equation(field, heads[i].first, heads[i].second);\n\t\t\t\t\tif(r.v == 0){\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}catch(const char *verdict){\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(valid){\n\t\t\t\taccept = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while(next_permutation(tokens.begin(), tokens.end()));\n\t\tcout << (accept ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const char* &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const char* &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const char* &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch(int ex) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<bool, 1 << MAX_N> NG;\narray<char, 128> letters;\narray<bool, 128> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint factor(string::const_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\tthrow \"parse error\";\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tint tmp;\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t++it;\n\t\t\ttmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_minus[expression[i - 1]] = true;\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_minus[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w, -1));\n\tint next = 0;\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\tif(idx[k][j] == -1) idx[k][j] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\tif(idx[i][k] == -1) idx[i][k] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\tif(NG[used]) return false;\n\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tconst char c = in[i];\n\t\tif(is_operator[c] && not_operator[idx]) continue;\n\t\tif(c == '0' && not_zero[idx]) continue;\n\t\tif(c == '-' && not_minus[idx]) continue;\n\n\t\tletters[idx] = c;\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[c]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\n\tNG[used] = true;\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tis_operator.fill(false);\n\tis_operator['+'] = true;\n\tis_operator['-'] = true;\n\tis_operator['*'] = true;\n\tis_operator['/'] = true;\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\t\trandom_shuffle(in.begin(), in.begin() + n);\n\n\t\tconst auto expressions = construct();\n\t\tNG.fill(false);\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\ntypedef vector <char> VC;\ntypedef pair <int, int> PII;\ntypedef vector <PII> VP;\ntypedef vector <int> VI;\n\nbool check( char c ) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n\nint calc( string a, bool& f ) {\n    f = true;\n    int n = a.size();\n    VI D;\n    VC O;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( check( a[i] ) ) {\n            O.push_back( a[i] );\n        }\n    }\n    string tmp = \"+-*/\";\n    for ( int i = 0; i < 4; ++ i ) {\n        replace( a.begin(), a.end(), tmp[i], ' ' );\n    }\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( a[i] == ' ' && a[i+1] == '0' ) {\n            f = false;\n            return 0;\n        }\n    }\n    istringstream is( a );\n    int d;\n    while ( is >> d ) D.push_back( d );\n    int m = D.size();\n\n    // *, /\n    for ( int i = 0; i + 1 < m; ++ i ) {\n        if ( O[i] == '*' ) {\n            D[i] = D[i] * D[i + 1];\n            D.erase( D.begin() + i + 1 );\n            O.erase( O.begin() + i );\n            -- i;\n            -- m;\n        } else if ( O[i] == '/' ) {\n            if ( D[i] % D[i+1] != 0 ) {\n                f = false;\n                return 0;\n            }\n            D[i] = D[i] / D[i + 1];\n            D.erase( D.begin() + i + 1 );\n            O.erase( O.begin() + i );\n            -- i;\n            -- m;\n        }\n    }\n\n    int answer = D[0];\n    for ( int i = 1; i < m; ++ i ) {\n        if ( O[i - 1] == '+' ) answer += D[i];\n        else answer -= D[i];\n    }\n    return answer;\n}\n\nbool check( string e ) {\n    if ( check( e[0] ) ) return false;\n    if ( check( e[e.size()-1] ) ) return false;\n    for ( int i = 0; i + 1 < (int)e.size(); ++ i ) {\n        if ( check( e[i] ) && check( e[i+1] ) ) return false;\n        if ( e[i] == '=' && check( e[i+1] ) ) return false;\n    }\n    \n    replace( e.begin(), e.end(), '=', ' ' );\n    istringstream is( e );\n    string a;\n    string b;\n    is >> a >> b;\n    bool f = true;\n    int na = calc( a, f );\n    int nb = calc( b, f );\n    return f && nb == na;\n}\n\nbool check( VS T ) {\n    int H = T.size();\n    int W = T[0].size();\n\n    for ( int i = 0; i < H; ++ i ) {\n        replace( T[i].begin(), T[i].end(), '#', ' ' );\n    }\n\n    VS E;\n    for ( int i = 0; i < H; ++ i ) {\n        istringstream is( T[i] );\n        string e;\n        while ( is >> e ) {\n            if ( e.size() >= 3 ) E.push_back( e );\n        }\n    }\n    for ( int i = 0; i < W; ++ i ) {\n        string t( H, ' ' );\n        for ( int j = 0; j < H; ++ j ) t[j] = T[j][i];\n        istringstream is( t );\n        string e;\n        while ( is >> e ) {\n            if ( e.size() >= 3 ) E.push_back( e );\n        }\n    }\n\n    for ( VS ::iterator it_i = E.begin(); it_i != E.end(); ++ it_i ) {\n        if ( ! check( *it_i ) ) return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    int W, H;\n    while ( cin >> H >> W ) {\n        if ( W == 0 && H == 0 ) break;\n        \n        VS L( H );\n        for ( int i = 0; i < H; ++ i ) {\n            cin >> L[i];\n        }\n        \n        int n = 0;\n        cin >> n;\n        \n        VP B;\n        for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n                if ( L[i][j] == '.' ) {\n                    B.push_back( PII( i, j ) ); \n                }\n            }\n        }\n        sort( B.begin(), B.end() );\n        \n        VC O( n );\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> O[i];\n        }\n        sort( O.begin(), O.end() );\n        \n        bool flag = false;\n        do {\n            VS T = L;\n            for ( int i = 0; i < n; ++ i ) {\n                int r = B[i].first;\n                int c = B[i].second;\n                T[r][c] = O[i];\n            }\n            if ( check( T ) ) {\n                flag = true;\n                break;\n            }\n        } while ( next_permutation( O.begin(), O.end() ) );\n        \n        cout << ( flag ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint idx;\nchar s[11];\nbool res;\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-' || s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex();\n\tASRT;\n\tif(a!=b || s[idx]) res=false;\n}\n\nbool parse(){\n\tif(!s[1] || !s[2]) return true;\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nbool isvalid(){\n\trep(i,h){\n\t\tint head=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(head==-1) head=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(head!=-1){\n\t\t\t\t\trep(k,j-head) s[k]=B[i][head+k];\n\t\t\t\t\ts[j-head]='\\0';\n\t\t\t\t\tif(!parse()) return false;\n\t\t\t\t\thead=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(j,w){\n\t\tint head=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(head==-1) head=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(head!=-1){\n\t\t\t\t\trep(k,i-head) s[k]=B[head+k][j];\n\t\t\t\t\ts[i-head]='\\0';\n\t\t\t\t\tif(!parse()) return false;\n\t\t\t\t\thead=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tint n; scanf(\"%d\",&n);\n\t\tchar key[10];\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\tint qx[10],qy[10];\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tbool ok=false;\n\t\tif(n==0) ok=isvalid();\n\t\telse{\n\t\t\tint p[]={0,1,2,3,4,5,6,7,8,9};\n\t\t\tdo{\n\t\t\t\trep(k,n) B[qy[k]][qx[k]]=key[p[k]];\n\t\t\t\tif(isvalid()){ ok=true; break; }\n\t\t\t}while(next_permutation(p,p+n));\n\t\t}\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = factor(s, p);\n  while (r.p < s.size() and (s[r.p] == '+' or s[r.p] == '-')) {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = term(s, p);\n  while (r.p < s.size() and (s[r.p] == '*' or s[r.p] == '/')) {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (p < s.size() and isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\ntypedef long long int lli;\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\ninline\nint calc(const string &s)\n{\n  istringstream iss( s );\n\n  static int num[11];\n  static char op[11];\n  int num_size = 0;\n  int op_size = 0;\n\n  static int n;\n  static char c;\n\n  while( iss >> n ){    \n    num[ num_size++ ] = n;\n    if( iss >> c )op[ op_size++ ] = c;\n    else break;\n  }\n  \n  for(int i=0; i<op_size; ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    num[i+1] = 0;\n    op[i] = '+';\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op_size; ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\ninline\nbool check_syntax(const string &s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\nstruct F{\n  vector< pair<int, int> > v;\n  F(){ v.clear(); }\n};\n\ninline\nstring build(F f)\n{\n  string s;\n  for(int i=0; i<f.v.size(); ++i){\n    s += g[ f.v[i].first ][ f.v[i].second ];\n  }\n  return s;\n}\n\ninline\nlli cpy(char c)\n{\n  if( isdigit(c) ) return c - '0';\n  if( c == '+' ) return 10;\n  if( c == '*' ) return 11;\n  if( c == '/' ) return 12;\n  if( c == '-' ) return 13;\n  return -(1LL << 60);\n}\n\nset<lli> valid, invalid;\nbool solve(char p[], int size, int h, int w)\n{\n  int i, j;\n\n  for(i=0; i<h; ++i){\n    for(j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      static const int di[] = {0, 0, -1, 1};\n      static const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  static pair<int, int> emp[10 * 10 + 1];\n  int emp_size = 0;\n  for(i=0; i<h; ++i){\n    for(j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp[emp_size++] = make_pair(i, j);\n    }\n  }\n\n  if( emp_size != size )return false;\n\n  static char puz[H][W];\n  static F v[1000];  \n\n  fill( v, v + 1000, F() );\n\n  int v_size = 0;\n\n  copy( g[0], g[H], puz[0] );\n  for(i=0; i<h; ++i){\n    for(j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }  \n\n  if( v_size == 0 )return true;\n  \n  copy( g[0], g[H], puz[0] );\n  for(i=0; i<h; ++i){\n    for(j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }\n\n  sort( p, p + size );\n  do{\n    \n    for(i=0; i<emp_size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    bool flg = true;\n    static int a, b;\n    static lli h;\n    for(i=0; i<v_size && flg; ++i){\n      string s;\n      h = 0;\n      for(j=0; j<v[i].v.size(); ++j){\n\ta = v[i].v[j].first;\n\tb = v[i].v[j].second;\n\ts += g[a][b];\n\th = ((h + cpy( g[a][b] )) * 19LL) % (1LL << 61);\n      }\n      if( invalid.count( h ) ) flg = false;\n      else if( valid.count( h ) ) flg = true;\n      else if( !check_syntax(s) ){\n\tinvalid.insert( h );\n\tflg = false;\n      }\n      else valid.insert( h );\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w, i, j;\n  while( scanf(\"%d%d\\n\", &h, &w) != EOF && (h | w) ){\n    for(i=0; i<h; ++i){\n      for(j=0; j<w; ++j){\n\tscanf(\"%c\", &g[i][j]);\n      }\n      scanf(\"\\n\");\n    }\n    static int n;\n    static char m[10];\n    cin >> n;\n    for(i=0; i<n; ++i){\n      cin >> m[i];\n    }\n    puts( solve(m, n, h, w) ? \"Yes\" : \"No\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint idx;\nchar s[11];\nbool res;\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-' || s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex();\n\tASRT;\n\tif(a!=b || s[idx]) res=false;\n}\n\nbool parse(){\n\tif(strlen(s)<=2) return true;\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nvector<int> head[2][10],tail[2][10];\nvoid preprocess(){\n\trep(i,h){\n\t\thead[0][i].clear();\n\t\ttail[0][i].clear();\n\n\t\tint p=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\thead[0][i].push_back(p);\n\t\t\t\t\ttail[0][i].push_back(j);\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\thead[1][j].clear();\n\t\ttail[1][j].clear();\n\n\t\tint p=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\thead[1][j].push_back(p);\n\t\t\t\t\ttail[1][j].push_back(i);\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool calc_no_space(){\n\trep(i,h){\n\t\trep(k,head[0][i].size()){\n\t\t\trep(l,tail[0][i][k]-head[0][i][k]) s[l]=B[i][head[0][i][k]+l];\n\t\t\ts[tail[0][i][k]-head[0][i][k]]='\\0';\n\t\t\tif(strchr(s,'.')==0){\n\t\t\t\tif(!parse()) return false;\n\t\t\t\thead[0][i].erase(head[0][i].begin()+k);\n\t\t\t\ttail[0][i].erase(tail[0][i].begin()+k);\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\trep(k,head[1][j].size()){\n\t\t\trep(l,tail[1][j][k]-head[1][j][k]) s[l]=B[head[1][j][k]+l][j];\n\t\t\ts[tail[1][j][k]-head[1][j][k]]='\\0';\n\t\t\tif(strchr(s,'.')==0){\n\t\t\t\tif(!parse()) return false;\n\t\t\t\thead[1][j].erase(head[1][j].begin()+k);\n\t\t\t\ttail[1][j].erase(tail[1][j].begin()+k);\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool isvalid(){\n\trep(i,h){\n\t\trep(k,head[0][i].size()){\n\t\t\trep(l,tail[0][i][k]-head[0][i][k]) s[l]=B[i][head[0][i][k]+l];\n\t\t\ts[tail[0][i][k]-head[0][i][k]]='\\0';\n\t\t\tif(!parse()) return false;\n\t\t}\n\t}\n\n\trep(j,w){\n\t\trep(k,head[1][j].size()){\n\t\t\trep(l,tail[1][j][k]-head[1][j][k]) s[l]=B[head[1][j][k]+l][j];\n\t\t\ts[tail[1][j][k]-head[1][j][k]]='\\0';\n\t\t\tif(!parse()) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tint n; scanf(\"%d\",&n);\n\t\tchar key[10];\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\tint qx[10],qy[10];\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tpreprocess();\n\n\t\tbool ok=false;\n\t\tif(calc_no_space()){\n\t\t\tint p[]={0,1,2,3,4,5,6,7,8,9};\n\t\t\tif(n==10) n--;\n\t\t\tdo{\n\t\t\t\trep(k,n) B[qy[k]][qx[k]]=key[p[k]];\n\t\t\t\tif(isvalid()){ ok=true; break; }\n\t\t\t}while(next_permutation(p,p+n));\n\t\t}\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nint BADHX, BADHY, BADVX, BADVY;\nstring BADHEQ, BADVEQ;\n\nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADHX = x, BADHY = y;\n        BADHEQ = eq;\n        return false; \n      }\n    } catch (int ex) {\n      BADHX = x, BADHY = y;\n      BADHEQ = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADVX = x, BADVY = y;\n        BADVEQ = eq;\n        return false; \n      }\n    } catch(int ex) {\n      BADVX = x, BADVY = y;\n      BADVEQ = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nint factorial(int x) {\n  int sum = 1;\n  for (int i = 1; i <= x; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  int consid = 0;\n  do {\n    fill_blank();\n    if (BADHEQ == geth(BADHX, BADHY)) continue;\n    if (BADVEQ == getv(BADVX, BADVY)) continue;\n    if (is_illegal_operand()) continue;\n    if (solved()) {\n      //cout << consid << \" / \" << factorial(n) << endl;\n      return true; \n    } else {\n/*      REP(y, H) {\n        REP(x, W) {\n          cout << TABLE[x][y]; \n        }\n        cout << endl;\n      }\n      cout << endl;*/\n      consid++;\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n//  cout << consid << \" / \" << factorial(n) << endl;\n  return false;\n}\n\nvoid init() {\n  BADHX = BADHY = BADVX = BADVY = -1;\n  BADHEQ = BADVEQ = \"No\";\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <string> VS;\ntypedef vector <char> VC;\ntypedef pair <int, int> PII;\ntypedef pair <int, char> PIC;\ntypedef vector <PIC> VPIC;\ntypedef pair <PII, PII> PPP;\ntypedef map <PII, int> M_PII_I;\ntypedef map <int, PII> M_I_PII;\ntypedef map <int, PPP> M_I_PPP;\ntypedef map <int, int> M_I_I;\ntypedef map <int, VI> M_I_VI;\ntypedef map <string, int> M_S_I;\ntypedef map <string, bool> M_S_B;\ntypedef ostringstream OSS;\n\nconst int NONE = INT_MAX;\n\nint h, w;\nVS M;\nVC O;\nint O_cnt;\nVI R;\nM_PII_I D_ID; // 座標 => '.' の ID\nM_I_PII D_ID_rev; // '.' の ID => 座標\nint D_ID_cnt;\nM_I_VI D_to_E; // '.'が含まれる式ID取得 1対多\nM_I_I E_to_D_cnt; // 式が含む'.'の個数\nM_I_PPP E_ID; // 式ID => ( 座標, 向き, 長さ )\nint E_ID_cnt;\n\nvoid init_global() {\n    M.clear();\n    O.clear();\n    O_cnt = 0;\n    R.clear();\n    D_ID.clear();\n    D_ID_rev.clear();\n    D_ID_cnt = 0;\n    D_to_E.clear();\n    E_to_D_cnt.clear();\n    E_ID.clear();\n    E_ID_cnt = 0;\n}\n\n// util\nstring toString( PII info ) {\n    OSS oss;\n    oss << \"(\" << info.first << \", \" << info.second << \")\";\n    return oss.str();\n}\n\nstring toString( PPP info ) {\n    OSS oss;\n    oss << toString( info.first ) << \", \" << toString( info.second );\n    return oss.str();\n}\n\nbool isOperation( char c ) {\n    return c < '0' || c > '9';\n}\n\nbool isNumber( char c ) {\n    return c >= '0' && c <= '9';\n}\n\n//\nM_S_I memo;\nint eval( string s ) {\n    if ( memo.count( s ) ) return memo[s];\n    int n = s.size();\n    // debug\n    // cout << \"@eval: \" << s << endl;\n\n    // 演算子\n    char OP[20];\n    int OP_cnt = 0;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( isOperation( s[i] ) ) {\n            OP[OP_cnt ++] = s[i];\n        }\n    }\n\n    int NUM[20] = {};\n    int NUM_cnt = 0;\n    int mul = 1;\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( isOperation( s[i] ) ) {\n            // 区切り\n            NUM_cnt ++;\n            mul = 1;\n        } else {\n            NUM[NUM_cnt] += ( s[i] - '0' ) * mul;\n            mul *= 10;\n        }\n    }\n    NUM_cnt ++;\n    reverse( NUM, NUM + NUM_cnt );\n\n    // *, /\n\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' || OP[i] == '-' ) continue;\n        if ( OP[i] == '*' ) {\n            NUM[i] *= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        } else if ( OP[i] == '/' ) {\n            if ( NUM[i+1] == 0 ) return memo[s] = NONE;\n            if ( NUM[i] % NUM[i+1] != 0 ) return memo[s] = NONE;\n            NUM[i] /= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        }\n    }\n    \n    int res = NUM[0];\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' ) {\n            res += NUM[i+1];\n        } else {\n            res -= NUM[i+1];\n        }\n    }\n\n    // debug\n    // cout << res << endl;\n\n    return memo[s] = res;\n}\n\nbool check2( string& s ) {\n    int n = s.size();\n    if ( isOperation( s[n-1] ) ) return false;\n    if ( s[0] != '-' && isOperation( s[0] ) ) return false;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( isOperation( s[i] ) && isOperation( s[i + 1] ) ) return false;\n    }\n    bool flag = true;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( flag ) {\n            if ( s[i] == '0' && isNumber( s[i + 1] ) ) return false;\n            flag = false;\n        } else if ( isOperation( s[i] ) ) {\n            flag = true;\n        }\n    }\n    return true;\n}\n\nM_S_B memo_check;\nbool check( string& s ) {\n    if ( memo_check.count( s ) ) return memo_check[s];\n    int n = s.size();\n    string left, right;\n    bool flag = true;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            flag = false;\n        } else if ( flag ) {\n            left += s[i];\n        } else {\n            right += s[i];\n        }\n    }\n    return memo_check[s] = ( ( check2( left ) && check2( right ) ) ? eval( left ) == eval( right ) : false );\n}\n\nbool used[11];\nM_I_I E_to_D;\nconst int dr[2] = { 0, 1 };\nconst int dc[2] = { 1, 0 };\nbool backtrack( int k ) {\n    /* debug\n    cout << \"k: \" << k << endl;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << M[i][j] << \", \";\n        }\n        cout << endl;\n    }\n    */\n\n    if ( k >= D_ID_cnt ) {\n        return true;\n    }\n\n    for ( int i = 0; i < O_cnt; ++ i ) {\n        int did = R[k];\n        if ( used[i] ) continue;\n        int r = D_ID_rev[did].first;\n        int c = D_ID_rev[did].second;\n        used[i] = true;\n        M[r][c] = O[i];\n\n        // '.' がすべて埋まってたら式を評価する\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            E_to_D[eid] ++;\n        }\n        bool flag = true;\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            if ( E_to_D[eid] == E_to_D_cnt[eid] ) {\n                PPP& info = E_ID[eid];\n                string exp = \"\";\n                int r = info.first.first;\n                int c = info.first.second;\n                for ( int j = 0; j < info.second.second; ++ j ) {\n                    exp += M[r][c];\n                    r += dr[info.second.first];\n                    c += dc[info.second.first];\n                }\n                if ( ! check( exp ) ) flag = false;\n            }\n        }\n        if ( flag && backtrack( k + 1 ) ) return true;\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            E_to_D[eid] --;\n        }\n\n        used[i] = false;\n    }\n    return false;\n}\n\nbool solve() {\n    E_to_D.clear();\n    fill( used, used + 11, false );\n    return backtrack( 0 );\n    /*\n    const int dr[2] = { 0, 1 };\n    const int dc[2] = { 1, 0 };\n    do {\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            // cout << i << \": \" << O[i] << \", \" << toString( D_ID_rev[i] ) << endl;\n            PII& d = D_ID_rev[i];\n            M[d.first][d.second] = O[i];\n        }\n        bool flag = true;\n        for ( int i = 0; i < E_ID_cnt; ++ i ) {\n            PPP& info = E_ID[i];\n            string exp = \"\";\n            int r = info.first.first;\n            int c = info.first.second;\n            for ( int j = 0; j < info.second.second; ++ j ) {\n                exp += M[r][c];\n                r += dr[info.second.first];\n                c += dc[info.second.first];\n            }\n            if ( ! check( exp ) ) {\n                // cout << exp << endl;\n                flag = false;\n                break;\n            }\n        }\n        if ( flag ) return true;\n    } while ( next_permutation( O.begin(), O.end() ) );\n    */\n}\n\nvoid getID() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == '.' ) {\n                int did = D_ID_cnt ++;\n                D_ID[PII( i, j )] = did;\n                D_ID_rev[did] = PII( i, j );\n            }\n        }\n    }\n}\n\nbool notValid( string s ) {\n    int n = s.size();\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            return ! ( i >= 1 && ( n - ( i + 1 ) ) >= 1 );\n        }\n    }\n    return true;\n}\n\nvoid addExpression( int& si, int& sj, int i, int j, int dir, string& exp, VI& ids ) {\n    if ( notValid( exp ) ) {\n        ids.clear();\n        exp.clear();\n        return;\n    }\n    int eid = E_ID_cnt ++;\n    E_to_D_cnt[eid] = 0;\n    for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n        D_to_E[*it_i].push_back( eid );\n        E_to_D_cnt[eid] ++;\n    }\n    E_ID[eid] = PPP( PII( si, sj ), PII( dir, (int)exp.size() ) );\n\n    // debug\n    // cout << (eid) << \", \" << dir << \", \" << exp << \": \" << toString( E_ID[eid] ) << endl;\n    // for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n    //    cout << \"\\t\" << *it_i << \": \" << toString( D_ID_rev[*it_i] ) << endl;\n    //}\n\n    si = i;\n    sj = j + 1;\n    ids.clear();\n    exp.clear();\n}\n\nvoid getExpressions() {\n    // 横\n    for ( int i = 0; i < h; ++ i ) {\n        string exp;\n        VI ids;\n        int si = i;\n        int sj = 0;\n        for ( int j = 0; j < w; ++ j ) {\n            char c = M[i][j];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, i, j, 0, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(i,j)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 0, exp, ids );\n    }\n    // 縦\n    for ( int i = 0; i < w; ++ i ) {\n        string exp;\n        VI ids;\n        int si = 0;\n        int sj = i;\n        for ( int j = 0; j < h; ++ j ) {\n            char c = M[j][i];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, j, i, 1, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(j,i)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 1, exp, ids );\n    }\n}\n\nint main() {\n    while ( cin >> h >> w && h && w ) {\n        init_global();\n\n        // input\n        M = VS(h);\n        for ( int i = 0; i < h; ++ i ) {\n            cin >> M[i];\n        }\n        cin >> O_cnt;\n        O = VC(O_cnt);\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            cin >> O[i];\n        }\n        sort( O.begin(), O.end() );\n\n        getID();\n        getExpressions();\n\n        R = VI( D_ID_cnt );\n        for ( int i = 0; i < D_ID_cnt; ++ i ) R[i] = i;\n\n        M_I_VI tmp = D_to_E;\n        for ( int i = 0; i < D_ID_cnt; ++ i ) {\n            for ( int j = i + 1; j < D_ID_cnt; ++ j ) {\n                if ( tmp[i].size() > tmp[j].size() ) {\n                    swap( tmp[i], tmp[j] );\n                    swap( R[i], R[j] );\n                }\n            }\n        }\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nint BADHX, BADHY, BADVX, BADVY;\nstring BADHEQ, BADVEQ;\n\nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADHX = x, BADHY = y;\n        BADHEQ = eq;\n        return false; \n      }\n    } catch (int ex) {\n      BADHX = x, BADHY = y;\n      BADHEQ = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADVX = x, BADVY = y;\n        BADVEQ = eq;\n        return false; \n      }\n    } catch(int ex) {\n      BADVX = x, BADVY = y;\n      BADVEQ = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nint factorial(int x) {\n  int sum = 1;\n  for (int i = 1; i <= x; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\nbool nextperm() {\n  while (next_permutation(BLOCK,BLOCK + n)) {\n    fill_blank();\n    if (BADHEQ != geth(BADHX, BADHY) and BADVEQ != getv(BADVX, BADVY)) {\n //     cout << \"o\" << BADHEQ << \" \" << geth(BADHX,BADHY) << \" \" << BADVEQ << \" \" << getv(BADVX, BADVY) << endl;\n      return true;\n    }/* else {\n      cout << \"x\" << BADHEQ << \" \" << geth(BADHX,BADHY) << \" \" << BADVEQ << \" \" << getv(BADVX, BADVY) << endl;\n    }*/\n  }\n  return false;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n//  int consid = 0;\n  do {\n    if (BADHEQ == geth(BADHX, BADHY)) continue;\n    if (BADVEQ == getv(BADVX, BADVY)) continue;\n    if (is_illegal_operand()) continue;\n    if (solved()) {\n//      cout << consid << \" / \" << factorial(n) << endl;\n      return true; \n    }/* else {\n      REP(y, H) {\n        REP(x, W) {\n          cout << TABLE[x][y]; \n        }\n        cout << endl;\n      }\n      cout << endl;\n      consid++;\n    }*/\n  } while (nextperm());\n//  cout << consid << \" / \" << factorial(n) << endl;\n  return false;\n}\n\nvoid init() {\n  BADHX = BADHY = BADVX = BADVY = -1;\n  BADHEQ = BADVEQ = \"No\";\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e15;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nll parse(int L, int R, const string &s){\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=L;i<R;i++)res = res*10LL + (ll)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  assert(p!=(int)s.size());\n  ll a = parse(0,p,s);\n  ll b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;                           // 空白の数\nstring p;                        // リストの文字\nvector<vector<string> > formula; // パズル中の数式\nstring change;                   // 各空白に入れる文字\nbool error;                      // 式計算のエラー有無\n\nint calculate(const string& s, int a, int b)\n{\n    if(a > b){\n        error = true;\n        return 0;\n    }\n\n    int k = b;\n    while(k >= a && s[k] != '*' && s[k] != '/')\n        -- k;\n    if(k >= a){\n        int x = calculate(s, a, k-1);\n        int y = calculate(s, k+1, b);\n        if(s[k] == '*'){\n            return x * y;\n        }else{\n            if(y == 0 || x % y != 0){\n                error = true;\n                return 0;\n            }\n            return x / y;\n        }\n    }\n\n    k = b;\n    while(k >= a && s[k] != '+' && s[k] != '-')\n        -- k;\n    if(k >= a){\n        int x = calculate(s, a, k-1);\n        int y = calculate(s, k+1, b);\n        if(s[k] == '+')\n            return x + y;\n        else\n            return x - y;\n    }\n\n    if(b > a && s[a] == '0'){\n        error = true;\n        return 0;\n    }\n\n    int ret = 0;\n    for(int i=a; i<=b; ++i){\n        ret *= 10;\n        ret += s[i] - '0';\n    }\n\n    return ret;\n}\n\nbool check(const string& s)\n{\n    int k = s.find('=');\n    if(k == string::npos)\n        return false;\n\n    error = false;\n    bool ret = calculate(s, 0, k-1) == calculate(s, k+1, s.size()-1);\n    return !error && ret;\n}\n\nbool solve(int x, bitset<10> bs)\n{\n    if(x == n)\n        return true;\n\n    for(int i=0; i<n; ++i){\n        if(bs[i])\n            continue;\n        bs[i] = true;\n\n        change[x] = p[i];\n        bool ok = true;\n        for(unsigned j=0; j<formula[x].size(); ++j){\n            string t = formula[x][j];\n            for(unsigned k=0; k<t.size(); ++k){\n                if(isalpha(t[k]))\n                    t[k] = change[t[k]-'a'];\n            }\n            if(!check(t))\n                ok = false;\n        }\n\n        if(ok && solve(x+1, bs))\n            return true;\n\n        bs[i] = false;\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> h >> w;\n        if(h == 0)\n            return 0;\n\n        vector<string> s(h+2, string(w+2, '#'));\n        int tmp = 0;\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> s[i][j];\n                if(s[i][j] == '.'){\n                    s[i][j] = 'a' + tmp;\n                    ++ tmp;\n                }\n            }\n        }\n\n        cin >> n;\n        p.assign(n, ' ');\n        for(int i=0; i<n; ++i)\n            cin >> p[i];\n\n        bool ng = false;\n        formula.assign(n, vector<string>());\n        for(int i=0; i<h+2; ++i){\n            char c = 0;\n            string t;\n            for(int j=0; j<w+2; ++j){\n                if(s[i][j] != '#'){\n                    t += s[i][j];\n                    if(isalpha(s[i][j]))\n                        c = s[i][j];\n                }else{\n                    if(t.size() > 2){\n                        if(c == 0){\n                            if(!check(t))\n                                ng = true;\n                        }else{\n                            formula[c-'a'].push_back(t);\n                        }\n                    }\n                    t = \"\";\n                }\n            }\n        }\n        for(int j=0; j<w+2; ++j){\n            char c = 0;\n            string t;\n            for(int i=0; i<h+2; ++i){\n                if(s[i][j] != '#'){\n                    t += s[i][j];\n                    if(isalpha(s[i][j]))\n                        c = s[i][j];\n                }else{\n                    if(t.size() > 2){\n                        if(c == 0){\n                            if(!check(t))\n                                ng = true;\n                        }else{\n                            formula[c-'a'].push_back(t);\n                        }\n                    }\n                    t = \"\";\n                }\n            }\n        }\n        if(ng){\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        change.assign(n, ' ');\n        if(solve(0, 0))\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch(int ex) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <exception>\nusing namespace std;\n\nconst int LIM = 10;\n\nint H, W, n;\nchar pz[12][12];\n\nvector<int> bx, by;\nbool used[LIM];\nvector<char> ch;\n\nclass Evaluator {\npublic:\n    static int num(string &s, int &k) {\n        int a = 0;\n        while (isdigit(s[k])) {\n            a = a * 10 + (s[k] - '0'); ++k;\n        }\n        return a;\n    }\n    static int mul(string &s, int &k) {\n        int a = num(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '*') a *= mul(s, ++k);\n            else if (s[k] == '/') {\n                int b = mul(s, ++k);\n                if (b == 0) throw 0; // DivisionByZero\n                else if (a % b != 0) throw 1; // LeavingRemaindar\n                a /= b;\n            }\n            else break;\n        }\n        return a;\n    }\n    static int add(string &s, int &k) {\n        int a = mul(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '+') a += mul(s, ++k);\n            else if (s[k] == '-') a -= mul(s, ++k);\n            else break;\n        }\n        return a;\n    }\n    static bool eq(string &s, int &k) {\n        int a = add(s, k);\n        if (k < (int)s.size() && s[k] == '=') {\n            int b = add(s, ++k);\n            if (k < (int)s.size()) return false;\n            return a == b;\n        }\n        return false;\n    }\n    static bool run(string s) {\n        int k; bool ret;\n        try {\n            ret = eq(s, k=0);\n        } catch (int) {\n            ret = false;\n        }\n        return ret;\n    }\n};\n\nbool issymbol(char c) {\n    return c=='+' || c=='-' || c=='*' || c=='/' || c=='=';\n}\n\nbool ok(int x, int y, char c) {\n    bool ver = true, hor = true;\n    if (pz[y-1][x] == '#' && pz[y+1][x] == '#') ver = false;\n    if (pz[y][x-1] == '#' && pz[y][x+1] == '#') hor = false;\n    if (issymbol(c)) {\n        if (pz[y-1][x] == '#' || pz[y+1][x] == '#' || issymbol(pz[y-1][x]) || issymbol(pz[y+1][x])) ver = false;\n        if (pz[y][x-1] == '#' || pz[y][x+1] == '#' || issymbol(pz[y][x-1]) || issymbol(pz[y][x+1])) hor = false;\n        if ( ! ver && ! hor) return false;\n    } else if (c == '0') {\n        if (pz[y-1][x] == '/' || pz[y][x-1] == '/' || isdigit(pz[y+1][x]) || isdigit(pz[y][x+1])) return false;\n    } else {\n        if (pz[y-1][x] == '0' || pz[y][x-1] == '0') return false;\n    }\n    int tx, ty; string s; bool blank;\n    if (ver) {\n        blank=false; s=c; ty=y-1;\n        while (pz[ty][x] != '#') {\n            s=pz[ty][x]+s;\n            blank|=(pz[ty][x]=='.');\n            --ty;\n        }\n        ty=y+1;\n        while (pz[ty][x] != '#') {\n            s+=pz[ty][x];\n            blank|=(pz[ty][x]=='.');\n            ++ty;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    if (hor) {\n        blank=false; s=c; tx=x-1;\n        while (pz[y][tx] != '#') {\n            s=pz[y][tx]+s;\n            blank|=(pz[y][tx]=='.');\n            --tx;\n        }\n        tx=x+1;\n        while (pz[y][tx] != '#') {\n            s+=pz[y][tx];\n            blank|=(pz[y][tx]=='.');\n            ++tx;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    return true;\n}\n\nstring solve(int k, int si) {\n    if (n <= k) return \"Yes\";\n    for (int i=si; i<n; ++i) {\n        if ( ! used[i] && ok(bx[i], by[i], ch[k])) {\n            used[i] = true;\n            pz[by[i]][bx[i]] = ch[k];\n            string res = solve(k+1, (n<=k+1 || ch[k+1]==ch[k]) ? i+1 : 0);\n            used[i] = false;\n            pz[by[i]][bx[i]] = '.';\n            if (res == \"Yes\") return res;\n        }\n    }\n    return \"No\";\n}\n\nbool cmb(const char& l, const char& r) {\n    if (l == '=') return true;\n    if (r == '=') return false;\n    return l < r;\n}\n\nint main() {\n    while (cin >> H >> W, H) {\n        for (int i=0; i<12; ++i) {\n            for (int j=0; j<12; ++j) {\n                pz[i][j] = '#';\n            }\n        }\n        bx.clear(); by.clear();\n        for (int i=1; i<=H; ++i) {\n            for (int j=1; j<=W; ++j) {\n                cin >> pz[i][j];\n                if (pz[i][j] == '.') {\n                    bx.push_back(j);\n                    by.push_back(i);\n                }\n            }\n        }\n        cin >> n;\n        ch.clear();\n        char c;\n        for (int i=0; i<n; ++i) {\n            cin >> c;\n            ch.push_back(c);\n        }\n        sort(ch.begin(), ch.end(), cmb);\n        memset(used, false, sizeof used);\n        cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, MAX_N> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint term(string::const_iterator &it) {\n\tint res = number(it);\n\twhile(true) {\n\t\tint tmp;\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t\t++it;\n\t\t\tres *= number(it);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t++it;\n\t\t\ttmp = number(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_minus[expression[i - 1]] = true;\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_minus[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w));\n\tint next = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '.') idx[i][j] = next++;\n\t\t}\n\t}\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tif(is_operator[i] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\t\tif(in[i] == '-' && not_minus[idx]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[i]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tis_operator.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t\tif(in[i] == '+' || in[i] == '-' || in[i] == '*' || in[i] == '/') {\n\t\t\t\tis_operator[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) {\n                end_parse = 1;\n                return 1e7;\n            }\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0){\n                end_parse = true;\n                return 1e7;\n            }\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        int tmp = expression(begin);\n        return (ret == tmp);\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    end_parse = 0;\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15]){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool check(char m[15][15]){\n    bool f;\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++){\n                    if(m[k][j] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++){\n                    if(m[i][k] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[i][k];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        int k = 0;\n        rep(i,h){\n            rep(j,w){\n                scanf(\"%c\",&m[i + 1][j + 1]);\n                if(m[i + 1][j + 1] == '.'){\n                    y[k] = i + 1;\n                    x[k++] = j + 1;\n                }\n            }\n            scanf(\"%*c\");\n        }\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n        if(not check(m)){\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"Yes\" : \"No\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!(isdigit(str[i]) && str[i]!='0')) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse(const string &s) {\n  REP(i,s.size()) str[i] = s[i];\n  str[s.size()] = '\\0';\n  int id = 0;\n  Int res = exp(id);\n  if (id != s.size()) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id) {\n  if (s.size() < 2) return 1;\n  if ((id == 0 || isoperator(s[id-1])) && !isdigit(s[id])) return 0;\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1) return 0;\n    Int a = parse(s.substr(0,pos));\n    Int b = parse(s.substr(pos+1));\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) throw IncorrectExc;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) throw IncorrectExc;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<set>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\ntypedef pair<pair<int,int>, string> ppiis;\n\nset<ppiis> BADHEQS, BADVEQS;\n\n\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADHEQS.insert(make_pair(make_pair(x,y),eq));\n        return false; \n      }\n    } catch (int ex) {\n      BADHEQS.insert(make_pair(make_pair(x,y),eq));\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADVEQS.insert(make_pair(make_pair(x,y),eq));\n        return false; \n      }\n    } catch(int ex) {\n      BADVEQS.insert(make_pair(make_pair(x,y),eq));\n      return false;\n    }\n  }\n  return true;\n}\n\nint factorial(int x) {\n  int sum = 1;\n  for (int i = 1; i <= x; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\nbool does_include_badeq() {\n  for (auto dat : BADHEQS) {\n    int x = dat.first.first, y = dat.first.second;\n    string eq = dat.second;\n    if (geth(x,y) == eq) return true;\n  }\n\n  for (auto dat : BADVEQS) {\n    int x = dat.first.first, y = dat.first.second;\n    string eq = dat.second;\n    if (getv(x,y) == eq) return true;\n  }\n\n  return false;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  int consid = 0;\n  do {\n    fill_blank();\n    if (does_include_badeq()) continue;\n    if (is_illegal_operand()) continue;\n    if (solved()) {\n//      cout << consid << \" / \" << factorial(n) << endl;\n      return true; \n    } else {\n/*      REP(y, H) {\n        REP(x, W) {\n          cout << TABLE[x][y]; \n        }\n        cout << endl;\n      }\n      cout << endl;\n      consid++;*/\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n//  cout << consid << \" / \" << factorial(n) << endl;\n  return false;\n}\n\nvoid init() {\n  BADHEQS.clear(); BADVEQS.clear();\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#define UNKNOWN 20\n#define UI unsigned int\n#define DEBUG false\nusing namespace std;\nint h,w,n;\nchar m[10][10], r[10];\nvector<string> form;\nint map[10]; // u·¶ÖÌÊ\n\nvoid prF( string s ){\n  for( UI i=0;i<s.length();i++ ){\n    if( s[i]<10 ) cout << \".\";\n    else cout << s[i];\n  }\n  cout << endl;\n}\n\nconst int UNCAL = -1111111;\nconst int PLUS  = UNCAL -1;\nconst int MINUS = PLUS  -1;\nint cal( string s ){\n  //  cout << \"s=\"<< s << endl;\n\n  string a;\n  vector<int> v;\n  bool isNum=true;\n  int kind=0; // 0:+,- 1:* 2:/\n  for( UI i=0;i<s.length();i++ ){\n    if( isNum ){\n      a=\"\";\n      while( i<s.length() && '0'<=s[i] && s[i]<='9' ) a+=s[i++];\n      --i;\n      //      cout << \" a=\"<< a << endl;\n\n      if( a.length()==0 ) return UNCAL;\n      if( a[0]=='0' && a.length()!=1 ) return UNCAL;\n      int number = atoi( a.c_str() );\n\n      if( kind==0 ) v.push_back( number );\n      else if( kind==1 ){ // *\n\tv[ v.size()-1 ] *= number;\n      }else{ // /\n\tif( number==0 ) return UNCAL;\n\tif( v[v.size()-1]%number !=0 ) return UNCAL;\n\tv[ v.size()-1 ] /= number;\n      }\n    }else{\n      kind = 0;\n      if( s[i]=='+' )      v.push_back( PLUS );\n      else if( s[i]=='-' ) v.push_back( MINUS );\n      else if( s[i]=='*' ) kind=1;\n      else if( s[i]=='/' ) kind=2;\n      else return UNCAL;\n    }\n    isNum = !isNum;\n  }\n  if( v.size()==0 ) return UNCAL;\n\n  int ret = v[0];\n  for( UI i=1;i<v.size();i+=2 ){\n    if( v[i]==PLUS && i+1<v.size() ) ret += v[i+1];\n    else if( v[i]==MINUS && i+1<v.size() ) ret-=v[i+1];\n    else return UNCAL;\n  }\n\n  return ret;\n}\n\nbool checkForm( string s ){\n  int a,b;\n  UI i=s.find(\"=\");\n\n  if( i==string::npos || i+1==s.length() )\n    return false;\n  if( (a=cal(s.substr(0,i)))==UNCAL )\n    return false;\n  b = cal( s.substr( i+1 ) );\n\n  if( DEBUG ){\n    if( a==b )\n      cout << \" checkForm :\"<< s \n\t   << \" \" << \"a=\"<<a <<\" b=\"<< b << endl;\n  }\n  return a==b;\n}\n\n\n/* i¶ÚÌóðu··é\n   j-1 ÔÚÜÅÌ form ÍNAµÄ¢éÆ·éB\n */\nbool solve(int i,UI j){\n  if( DEBUG ){\n    cout << \"solve \"<<i<<\",\"<<j << \"  \";\n    for( int a=0;a<i;a++ )\n      cout << \" \" << map[a];\n    cout << endl;\n  }\n\n  string s;\n  // ®`FbN\n  for( ; j<form.size();j++ ){\n    s=\"\";\n    UI k;\n    for( k=0;k<form[j].length();k++ ){\n      if( form[j][k]<10 ){   // ¢mÌ¶iójª¶Ý\n\tif( form[j][k]<i )\n\t  s = s + r[ map[(int)form[j][k]] ];\n\telse                 // ¢è¶ª¶Ý·é®\n\t  k = form[j].length()+100;\n      }else\n\ts = s + form[j][k];\n    }\n    if( k>form[j].length() ) break;\n    if( !checkForm( s ) ) // ®ÆÈçÈ©Á½\n      return false;\n  }\n  if( DEBUG )\n    cout << \" j=\"<<j <<\" size=\"<< form.size()  <<  endl;\n\n  if( j==form.size() ) return true;\n  if( i==n ) return false;\n\n  // i+1 ÔÚÌ`FbN\n  // map[i+1] É map[j]!=map[i][j] ( j<i )ÆÈélðãü\n  for( int k=0,l;k<n;k++ ){\n    map[i] = k;\n    for( l=0;l<i;l++ )\n      if( map[i] == map[l] ) break;\n    if( l!=i ) continue;\n    if( solve( i+1,j ) )\n      return true;    \n  }\n  return false;\n}\n\nint main(){\n  /*\n  cout << \"checkForm : \" << checkForm(\"*=1\") << endl;\n  cout << cal(\"2/5\") << endl;\n  return 0;\n  */\n  // test end\n\n  while( cin>>h>>w && (h||w) ){\n    int in=0; // ó}XCfbNX\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> m[i][j];\n\tif( m[i][j]=='.' ) m[i][j]=in++;\n      }\n    cin >> n;\n    for( int i=0;i<n;i++ )\n      cin >> r[i];\n\n    form.clear();\n    string s;\n    // ¡ûüÌ®\n    for( int i=0;i<h;i++ ){\n      for( int j=0;j<w;j++ ){\n\ts=\"\";\n\twhile( m[i][j]=='#' ) j++;\n\twhile( j<w && m[i][j]!='#' ) s+=m[i][j++];\n\tif( s.length()>2 ) form.push_back( s );\n      }\n    }\n    // cûüÌ®\n    for( int j=0;j<w;j++ ){\n      for( int i=0;i<h;i++ ){\n\ts=\"\";\n\twhile( m[i][j]=='#' ) i++;\n\twhile( i<h && m[i][j]!='#' ) s+=m[i++][j];\n\tif( s.length()>2 ) form.push_back( s );\n      }\n    }\n\n    if( DEBUG ){\n      for( UI i=0;i<form.size();i++ ){\n\tcout << \" \";\n\tprF( form[i] );\n      }\n    }\n\n    if( solve( 0,0 ) ) cout << \"Yes\" << endl;\n    else               cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false; \n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\n//int expr(const string& s)\n//{\n//\tint x; char op1;\n//\tfor(int i=0,j=0,k=0;i<s.size();i++){\n//\t\tint y=0; char op2;\n//\t\tfor(j=i;j<s.size();j++){\n//\t\t\tint z=0;\n//\t\t\tfor(k=j;k<s.size() && isdigit(s[k]);k++){\n//\t\t\t\tif(j<k && z==0) return INF; // /0\\d+/\n//\t\t\t\tz=z*10+s[k]-'0';\n//\t\t\t}\n//\t\t\tif(j==i) y=z;\n//\t\t\telse{\n//\t\t\t\tassert(op2=='*' || op2=='/');\n//\t\t\t\tif(op2=='*') y*=z;\n//\t\t\t\telse if(z && y%z==0) y/=z;\n//\t\t\t\telse return INF;\n//\t\t\t}\n//\t\t\tj=k;\n//\t\t\tif(i==s.size()) break;\n//\t\t\tif(s[j]!='*' && s[j]!='/') break;\n//\t\t\top2=s[j];\n//\t\t}\n//\t\tif(i==0) x=y;\n//\t\telse{\n//\t\t\tassert(op1=='+' || op1=='-');\n//\t\t\tif(op1=='+') x+=y;\n//\t\t\tif(op1=='-') x-=y;\n//\t\t}\n//\t\ti=j;\n//\t\tif(i==s.size()) break;\n//\t\tif(s[i]!='+' && s[i]!='-') return INF;\n//\t\top1=s[i];\n//\t}\n//\treturn x;\n//}\npii number(const string& s,int i)\n{\n\tint x=0;\n\tif(i>=s.size() || !isdigit(s[i])) throw __func__;\n\tfor(int len=0;i<s.size() && isdigit(s[i]);i++,len++){\n\t\tif(len==1 && x==0) throw __func__;\n\t\tx=x*10+s[i]-'0';\n\t}\n\treturn mp(x,i);\n}\npii term(const string& s,int i)\n{\n\tint x; tie(x,i)=number(s,i);\n\twhile(i<s.size() && (s[i]=='*' || s[i]=='/')){\n\t\tchar op=s[i];\n\t\tint y; tie(y,i)=number(s,i+1);\n\t\tif(op=='*') x*=y;\n\t\tif(op=='/'){\n\t\t\tif(y==0 || x%y>0) throw \"zero div\";\n\t\t\tx/=y;\n\t\t}\n\t}\n\treturn mp(x,i);\n}\npii expr(const string& s,int i)\n{\n\tint x; tie(x,i)=term(s,i);\n\twhile(i<s.size()){\n\t\tchar op=s[i];\n\t\tif(op!='+' && op!='-') throw __func__;\n\t\tint y; tie(y,i)=term(s,i+1);\n\t\tif(op=='+') x+=y;\n\t\tif(op=='-') x-=y;\n\t}\n\treturn mp(x,i);\n}\nint expr(const string& s)\n{\n\ttry{\n\t\tint res=expr(s,0).first;\n\t\treturn res;\n\t}\n\tcatch(const char* msg){\n\t\t//dump(msg);\n\t\treturn INF;\n\t}\n}\n\nbool check(const vs& grid,const vector<pii>& f)\n{\n\tstring s;\n\tfor(auto p:f) s+=grid[p.first][p.second];\n\tif(count(all(s),'=')!=1) return false;\n\tint eq=s.find('=');\n\tif(eq==0 || eq==s.size()-1) return false;\n\tstring a=s.substr(0,eq),b=s.substr(eq+1);\n\t\n\tint x=expr(a),y=expr(b);\n\t//dump(mt(s,x,y));\n\tif(x==INF || y==INF || x!=y)\n\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint n; cin>>n;\n\t\tstring cs(n,'~');\n\t\trep(i,n) cin>>cs[i];\n\t\t\n\t\tvector<pii> ps;\n\t\tvector<vector<pii>> fs;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='.') ps.emplace_back(i,j);\n\t\t\tif(grid[i][j]!='#'){\n\t\t\t\tif((i==0 || grid[i-1][j]=='#') && i<h-1 && grid[i+1][j]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=i;k<h && grid[k][j]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(k,j);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t\tif((j==0 || grid[i][j-1]=='#') && j<w-1 && grid[i][j+1]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=j;k<w && grid[i][k]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(i,k);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvvi ds(n+1);\n\t\t{\n\t\t\tvi vis(fs.size());\n\t\t\trep(i,n+1){\n\t\t\t\trep(j,fs.size()) if(!vis[j]){\n\t\t\t\t\tstring s;\n\t\t\t\t\tfor(auto p:fs[j]) s+=grid[p.first][p.second];\n\t\t\t\t\tif(count(all(s),'.')==0){\n\t\t\t\t\t\tds[i].push_back(j);\n\t\t\t\t\t\tvis[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<n) grid[ps[i].first][ps[i].second]='?';\n\t\t\t}\n\t\t\trep(i,n)\n\t\t\t\tgrid[ps[i].first][ps[i].second]='.';\n\t\t\trotate(begin(ds),1+all(ds));\n\t\t}\n\t\t\n\t\tif(!all_of(all(ds[n]),[&](int j){return check(grid,fs[j]);})){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tstring res=\"No\";\n\t\tvi is(n); iota(all(is),0);\n\t\tdo{\n\t\t\tint i=0;\n\t\t\tfor(;i<n;i++){\n\t\t\t\tgrid[ps[i].first][ps[i].second]=cs[is[i]];\n\t\t\t\tif(!all_of(all(ds[i]),[&](int j){return check(grid,fs[j]);})) break;\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\t//for(auto l:grid) cout<<l<<endl;\n\t\t\t\tres=\"Yes\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treverse(i+1+all(is));\n\t\t}while(next_permutation(all(is)));\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <exception>\nusing namespace std;\n\nconst int LIM = 10;\n\nint H, W, n;\nchar pz[12][12];\n\nvector<int> bx, by;\nbool used[LIM];\nvector<char> ch;\n\nclass Evaluator {\npublic:\n    static int num(string &s, int &k) {\n        int a = 0;\n        while (isdigit(s[k])) {\n            a = a * 10 + (s[k] - '0'); ++k;\n        }\n        return a;\n    }\n    static int mul(string &s, int &k) {\n        int a = num(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '*') a *= mul(s, ++k);\n            else if (s[k] == '/') {\n                int b = mul(s, ++k);\n                if (b == 0) throw 0; // DivisionByZero\n                else if (a % b != 0) throw 1; // LeavingRemaindar\n                a /= b;\n            }\n            else break;\n        }\n        return a;\n    }\n    static int add(string &s, int &k) {\n        int a = mul(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '+') a += mul(s, ++k);\n            else if (s[k] == '-') a -= mul(s, ++k);\n            else break;\n        }\n        return a;\n    }\n    static bool eq(string &s, int &k) {\n        int a = add(s, k);\n        if (k < (int)s.size() && s[k] == '=') {\n            int b = add(s, ++k);\n            if (k < (int)s.size()) return false;\n            return a == b;\n        }\n        return false;\n    }\n    static bool run(string s) {\n        int k; bool ret;\n        try {\n            ret = eq(s, k=0);\n        } catch (int) {\n            ret = false;\n        }\n        return ret;\n    }\n};\n\nbool issymbol(char c) {\n    return c=='+' || c=='-' || c=='*' || c=='/' || c=='=';\n}\n\nbool ok(int x, int y, char c) {\n    bool ver = true, hor = true;\n    if (pz[y-1][x] == '#' && pz[y+1][x] == '#') ver = false;\n    if (pz[y][x-1] == '#' && pz[y][x+1] == '#') hor = false;\n    if (issymbol(c)) {\n        if (pz[y-1][x] == '#' || pz[y+1][x] == '#' || issymbol(pz[y-1][x]) || issymbol(pz[y+1][x])) ver = false;\n        if (pz[y][x-1] == '#' || pz[y][x+1] == '#' || issymbol(pz[y][x-1]) || issymbol(pz[y][x+1])) hor = false;\n        if ( ! ver && ! hor) return false;\n    }\n    int tx, ty; string s; bool blank;\n    if (ver) {\n        blank=false; s=c; ty=y-1;\n        while (pz[ty][x] != '#') {\n            s=pz[ty][x]+s;\n            blank|=(pz[ty][x]=='.');\n            --ty;\n        }\n        ty=y+1;\n        while (pz[ty][x] != '#') {\n            s+=pz[ty][x];\n            blank|=(pz[ty][x]=='.');\n            ++ty;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    if (hor) {\n        blank=false; s=c; tx=x-1;\n        while (pz[y][tx] != '#') {\n            s=pz[y][tx]+s;\n            blank|=(pz[y][tx]=='.');\n            --tx;\n        }\n        tx=x+1;\n        while (pz[y][tx] != '#') {\n            s+=pz[y][tx];\n            blank|=(pz[y][tx]=='.');\n            ++tx;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    return true;\n}\n\nstring solve(int k) {\n    if (n <= k) return \"Yes\";\n    for (int i=0; i<n; ++i) {\n        if ( ! used[i] && ok(bx[i], by[i], ch[k])) {\n            used[i] = true;\n            pz[by[i]][bx[i]] = ch[k];\n            string res = solve(k+1);\n            used[i] = false;\n            pz[by[i]][bx[i]] = '.';\n            if (res == \"Yes\") return res;\n        }\n    }\n    return \"No\";\n}\n\nint main() {\n    while (cin >> H >> W, H) {\n        for (int i=0; i<12; ++i) {\n            for (int j=0; j<12; ++j) {\n                pz[i][j] = '#';\n            }\n        }\n        bx.clear(); by.clear();\n        for (int i=1; i<=H; ++i) {\n            for (int j=1; j<=W; ++j) {\n                cin >> pz[i][j];\n                if (pz[i][j] == '.') {\n                    bx.push_back(j);\n                    by.push_back(i);\n                }\n            }\n        }\n        cin >> n;\n        ch.clear();\n        char c;\n        for (int i=0; i<n; ++i) {\n            cin >> c;\n            ch.push_back(c);\n        }\n        sort(ch.begin(), ch.end());\n        memset(used, false, sizeof used);\n        cout << solve(0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) throw IncorrectExc;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) throw IncorrectExc;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e15;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nll parse(int L, int R, const string &s){\n  assert(R!=L);\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=L;i<R;i++)res = res*10LL + (ll)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  assert(p!=(int)s.size());\n  ll a = parse(0,p,s);\n  ll b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<int> bx, by;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bx.push_back(x); by.push_back(y); grid[y][x] = bx.size() - 1 + 'a';}\n\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15], vector<string> &s){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h){\n                rep(j,w){\n                    scanf(\"%c\",&m[i + 1][j + 1]);\n                    if(m[i + 1][j + 1] == '.'){\n                        y[k] = i + 1;\n                        x[k] = j + 1;\n                        k++;\n                    }\n                }\n               scanf(\"%*c\");\n            }\n        }\n\n        //if(not check(m)){\n        //    cout << \"NO\" << endl;\n        //    continue;\n        //}\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n\n        vector<string> s;\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m,s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cctype>\n#include<cstring>\n#include<iomanip>\n\n\n#define MAX 256\nusing namespace std;\n\n\ntypedef pair<const char *, int > parsed;\ntypedef pair<bool,int> bnfm;\n\nparsed expr(const char *);\nparsed term(const char *);\nparsed fact(const char *);\n\nbnfm Ex(int pos, const string &s);\nbnfm N0(int pos, const string &s);\n\nparsed expr(const char *p){\n  parsed r = term(p);\n  if( r.first == NULL ) return r; // parse error\n  while( *(r.first)=='+' || *(r.first)=='-' ){\n    const char *op = r.first;\n    parsed l = term(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='+' ){\n      r.first = l.first;\n      r.second = r.second + l.second;\n    }else{\n      r.first = l.first;\n      r.second = r.second - l.second;\n    }\n  }\n  return r;\n}\n\nparsed term(const char *p){\n  parsed r = fact(p);\n  if( r.first == NULL ) return r;\n  while( *(r.first)=='*' || *(r.first)=='/' ){\n    const char *op = r.first;\n    parsed l = fact(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='*' ){\n      r.first = l.first;\n      r.second = r.second * l.second;\n    }else{\n      r.first = l.first;\n      if( l.second == 0 || r.second % l.second != 0 ) return parsed(NULL,-1);\n      r.second = int(r.second / l.second);\n    }\n  }\n  return r;\n}\n\nparsed fact(const char *p){\n  if( *p=='(' ){\n    // new expression\n    parsed tp = expr(p+1);\n    if( tp.first == NULL ) return tp;\n    return parsed(tp.first+1, tp.second);\n  }\n  if( *p=='-' ){\n    // negative fact\n    parsed tp = fact(p+1);\n    if( tp.first == NULL ) return tp;\n    tp.second *= -1;\n    return tp;\n  }\n  if( isdigit(*p) ){\n    // number\n    int num = *p - '0';\n    while( isdigit(*(++p)) ){\n      num *= 10;\n      num += *p - '0';\n    }\n    return parsed(p,num);\n  }else assert(0); return parsed(NULL,0);\n}\n\nbool Eq(const string &s){\n  int pos = 0;\n  bnfm r = Ex(pos,s);\n  if( !r.first ) return false;\n  pos = r.second;\n  if( pos >= s.length() ) return false;\n  if( s[pos] != '=' ) return false;\n  ++pos;\n  r = Ex(pos,s);\n  if( !r.first ) return false;\n  if( r.second < s.length() ) return false;\n  return true;\n}\n\nbnfm Ex(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm(false,pos);\n  bnfm r = N0(pos,s);\n  if( !r.first ) return bnfm(false,r.second);\n  pos = r.second;\n  if( pos >= s.length() ) return bnfm(true,pos);\n  while( s[ pos ] == '+' || s[ pos ] == '-' || s[ pos ] == '*' || s[ pos ] == '/' ){\n    bnfm r = N0( pos+1, s );\n    if( !r.first ) return bnfm(false,r.second);\n    pos = r.second;\n    if( pos >= s.length() ) break;\n  }\n  return bnfm(true,pos);\n}\n\nbnfm N0(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm( false,pos );\n  if( !isdigit( s[pos] ) ) return bnfm(false,pos+1);\n  if( s[pos] == '0' ){\n    if( pos + 1 < s.length() ){\n      if( isdigit( s[pos+1] ) ) return bnfm(false,pos+2);\n    }\n    return bnfm(true,pos+1);\n  }else{\n    while( isdigit(s[pos]) ){\n      ++pos;\n      if( pos >= s.length() ) break;\n    }\n    return bnfm(true,pos);\n  }\n}\n\nbool Evaluate(const string &s){\n  string s1,s2;\n  int i,j;\n  for(i = 0; i < s.length(); ++i){\n    if( s[i] == '=' ) break;\n    else s1 += s[i];\n  }\n  for(j=i+1; j < s.length(); ++j){\n    s2 += s[j];\n  }\n  parsed p1 = expr(s1.c_str());\n  parsed p2 = expr(s2.c_str());\n  if( p1.first == NULL || p2.first == NULL ) return false;\n  if( p1.second == p2.second ) return true;\n  else return false;\n}\n\nint main(void){\n  while(true){\n    bool NG;\n    int H,W;\n    char pzl[MAX][MAX],org_pzl[MAX][MAX];\n    for(int i = 0; i < MAX; ++i)for(int j = 0; j < MAX; ++j)pzl[i][j]=org_pzl[i][j]='#';\n\n    cin >> H >> W;\n    if( H == 0 && W == 0) break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> pzl[i+1][j+1];\n\torg_pzl[i+1][j+1] = pzl[i+1][j+1];\n      }\n    }\n    \n    int n,num=0;\n    cin >> n;\n    int p[n];\n    char holes[n];\n    for(int i = 0; i < n; ++i){\n      char d; cin >> d; holes[num++] = d; p[i] = i;\n    }\n    \n    int *c,*pc,*q,k,t;\n    \n    int cnt = 0;\n    c = new int[n];\n    for(k=1,q=p,pc=c;k<=n;)*q++=*pc++=k++;k=1;pc=c;\n    do{t=*(p+k);*(p+k)=*(q=p+((k&1)?*pc:0));*q=t;\n    \n      NG=false;\n      num = 0;\n      vector<string> eqs;\n      const int di [] = {-1,0,1,0};\n      const int dj [] = {0,1,0,-1};\n \n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  if( pzl[i+1][j+1] == '.' ){\n\t    pzl[i+1][j+1] = holes[ p[num]-1 ];\n\t    ++num;\n\t  }\n\t}\n      }\n      \n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  if( pzl[i+1][j+1] != '#' ){ \n\t    for(int l = 0; l < sizeof(di)/sizeof(*di); ++l){\n\t      if( l == 1 || l == 2 ) continue;\n\t      int ti = i + 1 + di[l]; int tj = j + 1 + dj[l];\n\t      if( pzl[ti][tj] == '#' ){\n\t\tint dir = (l+2)%(sizeof(di)/sizeof(*di));\n\t\tti = i+1+di[dir]; tj = j+1+dj[dir];\n\t\tstring eq;\n\t\teq += pzl[i+1][j+1];\n\t\twhile(pzl[ti][tj]!='#'){\n\t\t  eq += pzl[ti][tj]; ti += di[dir]; tj += dj[dir];\n\t\t}\n\t\tif( eq.length() >= 3 ){\n\t\t  eqs.push_back( eq );\n\t\t}\n\t\teq.clear();\n\t      }\n\t    }\n\t  }\n\t}\n      }\n\n      for(int i = 0; i < eqs.size(); ++i){\n\t//cout << \"EQUATION : \" << eqs[i] << \" VALID? : \" << Eq(eqs[i]) << endl; \n\tif( !Eq(eqs[i]) ){ NG=true; break; }\n\tif( !Evaluate(eqs[i]) ){ NG=true; break; }\n      }\n      \n      if( !NG ){\n\tbreak;\n      }\n\n      for(int i = 0; i < MAX; ++i){\n\tfor(int j = 0; j < MAX; ++j){\n\t  pzl[i][j] = org_pzl[i][j];\n\t}\n      }\n      \n    k=1;pc = c;while(*pc==0)*pc++=k++;(*pc)--;}while(k<n);\n    delete [] c;\n    \n    if( NG ){\n      cout << \"No\" << endl;\n    }else{\n      cout << \"Yes\" <<endl;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, 128> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint factor(string::const_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\tthrow \"parse error\";\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tint tmp;\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t++it;\n\t\t\ttmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_minus[expression[i - 1]] = true;\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_minus[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w, -1));\n\tint next = 0;\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\tif(idx[k][j] == -1) idx[k][j] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\tif(idx[i][k] == -1) idx[i][k] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tconst char c = in[i];\n\t\tif(is_operator[c] && not_operator[idx]) continue;\n\t\tif(c == '0' && not_zero[idx]) continue;\n\t\tif(c == '-' && not_minus[idx]) continue;\n\n\t\tletters[idx] = c;\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[c]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tis_operator.fill(false);\n\tis_operator['+'] = true;\n\tis_operator['-'] = true;\n\tis_operator['*'] = true;\n\tis_operator['/'] = true;\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\n\nll term(int &i);\nll fact(int &i);\n\nll exp(int &i) {\n  ll p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      ll a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nll term(int &i) {\n  ll p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nll fact(int &i) {\n  ll p = 0;\n  if (!(isdigit(str[i]) && str[i]!='0')) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nll parse(const string &s) {\n  REP(i,s.size()) str[i] = s[i];\n  str[s.size()] = '\\0';\n  int id = 0;\n  ll res = exp(id);\n  if (id != s.size()) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id) {\n  if (s.size() < 2) return 1;\n  if ((id == 0 || isoperator(s[id-1])) && !isdigit(s[id])) return 0;\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1) return 0;\n    ll a = parse(s.substr(0,pos));\n    ll b = parse(s.substr(pos+1));\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    const int dy[4] = {-1,0,1,0};\n    const int dx[4] = {0,1,0,-1};\n    REP(i,h)REP(j,w) {\n      ng[i][j] = 0;\n      REP(k,4) {\n        int y=i+dy[k];\n        int x=j+dx[k];\n        if(!valid(y,x,h,w)) continue;\n        if (!isdigit(a[y][x]) && a[y][x] != '#' && a[y][x] != '.') ng[i][j] = 1;\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <string> VS;\ntypedef vector <char> VC;\ntypedef pair <int, int> PII;\ntypedef pair <int, char> PIC;\ntypedef vector <PIC> VPIC;\ntypedef pair <PII, PII> PPP;\ntypedef map <PII, int> M_PII_I;\ntypedef map <int, PII> M_I_PII;\ntypedef map <int, PPP> M_I_PPP;\ntypedef map <int, int> M_I_I;\ntypedef map <int, VI> M_I_VI;\ntypedef map <string, int> M_S_I;\ntypedef map <string, bool> M_S_B;\ntypedef ostringstream OSS;\n\nconst int NONE = INT_MAX;\n\nint h, w;\nVS M;\nVC O;\nint O_cnt;\nVI R;\nM_PII_I D_ID; // 座標 => '.' の ID\nM_I_PII D_ID_rev; // '.' の ID => 座標\nint D_ID_cnt;\nM_I_VI D_to_E; // '.'が含まれる式ID取得 1対多\nM_I_I E_to_D_cnt; // 式が含む'.'の個数\nM_I_PPP E_ID; // 式ID => ( 座標, 向き, 長さ )\nint E_ID_cnt;\n\nvoid init_global() {\n    M.clear();\n    O.clear();\n    O_cnt = 0;\n    R.clear();\n    D_ID.clear();\n    D_ID_rev.clear();\n    D_ID_cnt = 0;\n    D_to_E.clear();\n    E_to_D_cnt.clear();\n    E_ID.clear();\n    E_ID_cnt = 0;\n}\n\n// util\nstring toString( PII info ) {\n    OSS oss;\n    oss << \"(\" << info.first << \", \" << info.second << \")\";\n    return oss.str();\n}\n\nstring toString( PPP info ) {\n    OSS oss;\n    oss << toString( info.first ) << \", \" << toString( info.second );\n    return oss.str();\n}\n\nbool isOperation( char c ) {\n    return c < '0' || c > '9';\n}\n\nbool isNumber( char c ) {\n    return c >= '0' && c <= '9';\n}\n\n//\nM_S_I memo;\nint eval( string s ) {\n    if ( memo.count( s ) ) return memo[s];\n    int n = s.size();\n    // debug\n    // cout << \"@eval: \" << s << endl;\n\n    // 演算子\n    char OP[20];\n    int OP_cnt = 0;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( isOperation( s[i] ) ) {\n            OP[OP_cnt ++] = s[i];\n        }\n    }\n\n    int NUM[20] = {};\n    int NUM_cnt = 0;\n    int mul = 1;\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( isOperation( s[i] ) ) {\n            // 区切り\n            NUM_cnt ++;\n            mul = 1;\n        } else {\n            NUM[NUM_cnt] += ( s[i] - '0' ) * mul;\n            mul *= 10;\n        }\n    }\n    NUM_cnt ++;\n    reverse( NUM, NUM + NUM_cnt );\n\n    // *, /\n\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' || OP[i] == '-' ) continue;\n        if ( OP[i] == '*' ) {\n            NUM[i] *= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        } else if ( OP[i] == '/' ) {\n            if ( NUM[i+1] == 0 ) return memo[s] = NONE;\n            if ( NUM[i] % NUM[i+1] != 0 ) return memo[s] = NONE;\n            NUM[i] /= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        }\n    }\n    \n    int res = NUM[0];\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' ) {\n            res += NUM[i+1];\n        } else {\n            res -= NUM[i+1];\n        }\n    }\n\n    // debug\n    // cout << res << endl;\n\n    return memo[s] = res;\n}\n\nbool check2( string& s ) {\n    int n = s.size();\n    if ( isOperation( s[n-1] ) ) return false;\n    if ( s[0] != '-' && isOperation( s[0] ) ) return false;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( isOperation( s[i] ) && isOperation( s[i + 1] ) ) return false;\n    }\n    bool flag = true;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( flag ) {\n            if ( s[i] == '0' && isNumber( s[i + 1] ) ) return false;\n            flag = false;\n        } else if ( isOperation( s[i] ) ) {\n            flag = true;\n        }\n    }\n    return true;\n}\n\nM_S_B memo_check;\nbool check( string& s ) {\n    if ( memo_check.count( s ) ) return memo_check[s];\n    int n = s.size();\n    string left, right;\n    bool flag = true;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            flag = false;\n        } else if ( flag ) {\n            left += s[i];\n        } else {\n            right += s[i];\n        }\n    }\n    return memo_check[s] = ( ( check2( left ) && check2( right ) ) ? eval( left ) == eval( right ) : false );\n}\n\nbool used[11];\nM_I_I E_to_D;\nconst int dr[2] = { 0, 1 };\nconst int dc[2] = { 1, 0 };\nbool backtrack( int k ) {\n    /* debug\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << M[i][j] << \", \";\n        }\n        cout << endl;\n    }\n    */\n\n    if ( k >= D_ID_cnt ) {\n        bool flag = true;\n        for ( int i = 0; i < D_ID_cnt; ++ i ) {\n            if ( E_to_D[i] != E_to_D_cnt[i] ) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n    for ( int i = 0; i < O_cnt; ++ i ) {\n        int did = R[k];\n        if ( used[i] ) continue;\n        int r = D_ID_rev[did].first;\n        int c = D_ID_rev[did].second;\n        used[i] = true;\n        M[r][c] = O[i];\n\n        // '.' がすべて埋まってたら式を評価する\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            E_to_D[eid] ++;\n        }\n        bool flag = true;\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            if ( E_to_D[eid] == E_to_D_cnt[eid] ) {\n                PPP& info = E_ID[eid];\n                string exp = \"\";\n                int r = info.first.first;\n                int c = info.first.second;\n                for ( int j = 0; j < info.second.second; ++ j ) {\n                    exp += M[r][c];\n                    r += dr[info.second.first];\n                    c += dc[info.second.first];\n                }\n                if ( ! check( exp ) ) flag = false;\n            }\n        }\n        if ( flag && backtrack( k + 1 ) ) return true;\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            E_to_D[eid] --;\n        }\n\n        used[i] = false;\n    }\n    return false;\n}\n\nbool solve() {\n    E_to_D.clear();\n    fill( used, used + 11, false );\n    return backtrack( 0 );\n    /*\n    const int dr[2] = { 0, 1 };\n    const int dc[2] = { 1, 0 };\n    do {\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            // cout << i << \": \" << O[i] << \", \" << toString( D_ID_rev[i] ) << endl;\n            PII& d = D_ID_rev[i];\n            M[d.first][d.second] = O[i];\n        }\n        bool flag = true;\n        for ( int i = 0; i < E_ID_cnt; ++ i ) {\n            PPP& info = E_ID[i];\n            string exp = \"\";\n            int r = info.first.first;\n            int c = info.first.second;\n            for ( int j = 0; j < info.second.second; ++ j ) {\n                exp += M[r][c];\n                r += dr[info.second.first];\n                c += dc[info.second.first];\n            }\n            if ( ! check( exp ) ) {\n                // cout << exp << endl;\n                flag = false;\n                break;\n            }\n        }\n        if ( flag ) return true;\n    } while ( next_permutation( O.begin(), O.end() ) );\n    */\n}\n\nvoid getID() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == '.' ) {\n                int did = D_ID_cnt ++;\n                D_ID[PII( i, j )] = did;\n                D_ID_rev[did] = PII( i, j );\n            }\n        }\n    }\n}\n\nbool notValid( string s ) {\n    int n = s.size();\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            return ! ( i >= 1 && ( n - ( i + 1 ) ) >= 1 );\n        }\n    }\n    return true;\n}\n\nvoid addExpression( int& si, int& sj, int i, int j, int dir, string& exp, VI& ids ) {\n    if ( notValid( exp ) ) {\n        ids.clear();\n        exp.clear();\n        return;\n    }\n    int eid = E_ID_cnt ++;\n    E_to_D_cnt[eid] = 0;\n    for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n        D_to_E[*it_i].push_back( eid );\n        E_to_D_cnt[eid] ++;\n    }\n    E_ID[eid] = PPP( PII( si, sj ), PII( dir, (int)exp.size() ) );\n\n    // debug\n    // cout << (eid) << \", \" << dir << \", \" << exp << \": \" << toString( E_ID[eid] ) << endl;\n    // for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n    //    cout << \"\\t\" << *it_i << \": \" << toString( D_ID_rev[*it_i] ) << endl;\n    //}\n\n    si = i;\n    sj = j + 1;\n    ids.clear();\n    exp.clear();\n}\n\nvoid getExpressions() {\n    // 横\n    for ( int i = 0; i < h; ++ i ) {\n        string exp;\n        VI ids;\n        int si = i;\n        int sj = 0;\n        for ( int j = 0; j < w; ++ j ) {\n            char c = M[i][j];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, i, j, 0, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(i,j)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 0, exp, ids );\n    }\n    // 縦\n    for ( int i = 0; i < w; ++ i ) {\n        string exp;\n        VI ids;\n        int si = 0;\n        int sj = i;\n        for ( int j = 0; j < h; ++ j ) {\n            char c = M[j][i];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, j, i, 1, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(j,i)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 1, exp, ids );\n    }\n}\n\nint main() {\n    while ( cin >> h >> w && h && w ) {\n        init_global();\n\n        // input\n        M = VS(h);\n        for ( int i = 0; i < h; ++ i ) {\n            cin >> M[i];\n        }\n        cin >> O_cnt;\n        O = VC(O_cnt);\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            cin >> O[i];\n        }\n        sort( O.begin(), O.end() );\n\n        getID();\n        getExpressions();\n\n        R = VI( D_ID_cnt );\n        for ( int i = 0; i < D_ID_cnt; ++ i ) R[i] = i;\n\n        M_I_VI tmp = D_to_E;\n        for ( int i = 0; i < D_ID_cnt; ++ i ) {\n            for ( int j = i + 1; j < D_ID_cnt; ++ j ) {\n                if ( tmp[i].size() > tmp[j].size() ) {\n                    swap( tmp[i], tmp[j] );\n                    swap( R[i], R[j] );\n                }\n            }\n        }\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint expr(const string& s)\n{\n\tint x; char op1;\n\tfor(int i=0,j=0,k=0;i<s.size();i++){\n\t\tint y=0; char op2;\n\t\tfor(j=i;j<s.size();j++){\n\t\t\tint z=0;\n\t\t\tfor(k=j;k<s.size() && isdigit(s[k]);k++){\n\t\t\t\tif(j<k && z==0) return INF; // /0\\d+/\n\t\t\t\tz=z*10+s[k]-'0';\n\t\t\t}\n\t\t\tif(j==i) y=z;\n\t\t\telse{\n\t\t\t\tassert(op2=='*' || op2=='/');\n\t\t\t\tif(op2=='*') y*=z;\n\t\t\t\telse if(z && y%z==0) y/=z;\n\t\t\t\telse return INF;\n\t\t\t}\n\t\t\tj=k;\n\t\t\tif(i==s.size()) break;\n\t\t\tif(s[j]!='*' && s[j]!='/') break;\n\t\t\top2=s[j];\n\t\t}\n\t\tif(i==0) x=y;\n\t\telse{\n\t\t\tassert(op1=='+' || op1=='-');\n\t\t\tif(op1=='+') x+=y;\n\t\t\tif(op1=='-') x-=y;\n\t\t}\n\t\ti=j;\n\t\tif(i==s.size()) break;\n\t\tif(s[i]!='+' && s[i]!='-') return INF;\n\t\top1=s[i];\n\t}\n\treturn x;\n}\n\nbool check(const vs& grid,const vector<pii>& f)\n{\n\tstring s;\n\tfor(auto p:f) s+=grid[p.first][p.second];\n\tif(count(all(s),'=')!=1) return false;\n\tint eq=s.find('=');\n\tif(eq==0 || eq==s.size()-1) return false;\n\tstring a=s.substr(0,eq),b=s.substr(eq+1);\n\t\n\tint x=expr(a),y=expr(b);\n\tif(x==INF || y==INF || x!=y)\n\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint n; cin>>n;\n\t\tstring cs(n,'~');\n\t\trep(i,n) cin>>cs[i];\n\t\t\n\t\tvector<pii> ps;\n\t\tvector<vector<pii>> fs;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='.') ps.emplace_back(i,j);\n\t\t\tif(grid[i][j]!='#'){\n\t\t\t\tif((i==0 || grid[i-1][j]=='#') && i<h-1 && grid[i+1][j]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=i;k<h && grid[k][j]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(k,j);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t\tif((j==0 || grid[i][j-1]=='#') && j<w-1 && grid[i][j+1]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=j;k<w && grid[i][k]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(i,k);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvvi ds(n+1);\n\t\t{\n\t\t\tvi vis(fs.size());\n\t\t\trep(i,n+1){\n\t\t\t\trep(j,fs.size()) if(!vis[j]){\n\t\t\t\t\tstring s;\n\t\t\t\t\tfor(auto p:fs[j]) s+=grid[p.first][p.second];\n\t\t\t\t\tif(count(all(s),'.')==0){\n\t\t\t\t\t\tds[i].push_back(j);\n\t\t\t\t\t\tvis[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<n) grid[ps[i].first][ps[i].second]='?';\n\t\t\t}\n\t\t\trep(i,n)\n\t\t\t\tgrid[ps[i].first][ps[i].second]='.';\n\t\t\trotate(begin(ds),1+all(ds));\n\t\t}\n\t\t\n\t\tif(!all_of(all(ds[n]),[&](int j){return check(grid,fs[j]);})){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tstring res=\"No\";\n\t\tvi is(n); iota(all(is),0);\n\t\tdo{\n\t\t\tint i=0;\n\t\t\tfor(;i<n;i++){\n\t\t\t\tgrid[ps[i].first][ps[i].second]=cs[is[i]];\n\t\t\t\tif(!all_of(all(ds[i]),[&](int j){return check(grid,fs[j]);})) break;\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\t//rep(i,h) cout<<grid[i]<<endl;\n\t\t\t\tres=\"Yes\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treverse(i+1+all(is));\n\t\t}while(next_permutation(all(is)));\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15], vector<string> &s){\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                string str;\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                string str;\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nvector<pair<int, int>> spacePoints(vector<string> s){\n    vector<pair<int, int>> ret;\n    rep(i,s.size()){\n        rep(j,s[i].size()){\n            if(s[i][j] == '.') ret.emplace_back(make_pair(i,j));\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> h >> w,h){\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        vector<pair<int, int>> space;\n        rep(i,h) rep(j,w){\n            cin >> m[i + 1][j + 1];\n            if(m[i + 1][j + 1] == '.') space.emplace_back(make_pair(i + 1,j + 1));\n        }\n\n        int n;\n        cin >> n;\n        vector<char> v;\n        rep(i,n){\n            char x;\n            cin >> x;\n            v.emplace_back(x);\n        }\n\n        vector<string> s;\n\n        bool f = false;\n        do{\n            rep(i,n) m[ space[i].first ][ space[i].second ] = v[i];\n            f |= requireString(m,s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\nstring puzzle[MAX_SIZE];\n\nint n;\nchar in[MAX_N];\n\nchar letters[128];\n\nint parse(const string &s, int l, int r) {\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '+') return parse(s, l, i) + parse(s, i + 1, r);\n\t\tif(s[i] == '-') return parse(s, l, i) - parse(s, i + 1, r);\n\t}\n\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '*') return parse(s, l, i) * parse(s, i + 1, r);\n\t\tif(s[i] == '/') {\n\t\t\tconst int left = parse(s, l, i);\n\t\t\tconst int right = parse(s, i + 1, r);\n\n\t\t\tif(right == 0) throw \"division by zero\";\n\t\t\tif(left % right) throw \"division leaving a remainder\";\n\n\t\t\treturn left / right;\n\t\t}\n\t}\n\n\tif(r <= l || !isdigit(s[l]) || (s[l] == '0' && r - l > 1)) throw \"parse error\";\n\treturn stoi(s.substr(l, r - l));\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tif(parse(left, 0, left.size()) != parse(right, 0, right.size())) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w));\n\tint next = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '.') idx[i][j] = next++;\n\t\t}\n\t}\n\n\tvector<pair<int, vector<int>>> expressions;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> tmp;\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\ttmp.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\texpressions.emplace_back(max_index, tmp);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> tmp;\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\ttmp.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\texpressions.emplace_back(max_index, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tletters[idx] = in[i];\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <string> VS;\ntypedef vector <char> VC;\ntypedef pair <int, int> PII;\ntypedef pair <int, char> PIC;\ntypedef vector <PIC> VPIC;\ntypedef pair <PII, PII> PPP;\ntypedef map <PII, int> M_PII_I;\ntypedef map <int, PII> M_I_PII;\ntypedef map <int, PPP> M_I_PPP;\ntypedef map <int, int> M_I_I;\ntypedef map <int, VI> M_I_VI;\ntypedef map <string, int> M_S_I;\ntypedef map <string, bool> M_S_B;\ntypedef ostringstream OSS;\n\nconst int NONE = INT_MAX;\n\nint h, w;\nVS M;\nVC O;\nint O_cnt;\nVI R;\nM_PII_I D_ID; // 座標 => '.' の ID\nM_I_PII D_ID_rev; // '.' の ID => 座標\nint D_ID_cnt;\nM_I_VI D_to_E; // '.'が含まれる式ID取得 1対多\nM_I_I E_to_D_cnt; // 式が含む'.'の個数\nM_I_PPP E_ID; // 式ID => ( 座標, 向き, 長さ )\nint E_ID_cnt;\n\nvoid init_global() {\n    M.clear();\n    O.clear();\n    O_cnt = 0;\n    R.clear();\n    D_ID.clear();\n    D_ID_rev.clear();\n    D_ID_cnt = 0;\n    D_to_E.clear();\n    E_to_D_cnt.clear();\n    E_ID.clear();\n    E_ID_cnt = 0;\n}\n\n// util\nstring toString( PII info ) {\n    OSS oss;\n    oss << \"(\" << info.first << \", \" << info.second << \")\";\n    return oss.str();\n}\n\nstring toString( PPP info ) {\n    OSS oss;\n    oss << toString( info.first ) << \", \" << toString( info.second );\n    return oss.str();\n}\n\nbool isOperation( char c ) {\n    return c < '0' || c > '9';\n}\n\nbool isNumber( char c ) {\n    return c >= '0' && c <= '9';\n}\n\n//\nM_S_I memo;\nint eval( string s ) {\n    if ( memo.count( s ) ) return memo[s];\n    int n = s.size();\n    // debug\n    // cout << \"@eval: \" << s << endl;\n\n    // 演算子\n    char OP[20];\n    int OP_cnt = 0;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( isOperation( s[i] ) ) {\n            OP[OP_cnt ++] = s[i];\n        }\n    }\n\n    int NUM[20] = {};\n    int NUM_cnt = 0;\n    int mul = 1;\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( isOperation( s[i] ) ) {\n            // 区切り\n            NUM_cnt ++;\n            mul = 1;\n        } else {\n            NUM[NUM_cnt] += ( s[i] - '0' ) * mul;\n            mul *= 10;\n        }\n    }\n    NUM_cnt ++;\n    reverse( NUM, NUM + NUM_cnt );\n\n    // *, /\n\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' || OP[i] == '-' ) continue;\n        if ( OP[i] == '*' ) {\n            NUM[i] *= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        } else if ( OP[i] == '/' ) {\n            if ( NUM[i+1] == 0 ) return memo[s] = NONE;\n            if ( NUM[i] % NUM[i+1] != 0 ) return memo[s] = NONE;\n            NUM[i] /= NUM[i+1];\n            for ( int j = i + 1; j + 2 < NUM_cnt; ++ j ) {\n                NUM[j] = NUM[j+2];\n            }\n            NUM_cnt -= 2;\n            OP_cnt --;\n        }\n    }\n    \n    int res = NUM[0];\n    for ( int i = 0; i < OP_cnt; ++ i ) {\n        if ( OP[i] == '+' ) {\n            res += NUM[i+1];\n        } else {\n            res -= NUM[i+1];\n        }\n    }\n\n    // debug\n    // cout << res << endl;\n\n    return memo[s] = res;\n}\n\nbool check2( string& s ) {\n    int n = s.size();\n    if ( isOperation( s[n-1] ) ) return false;\n    if ( s[0] != '-' && isOperation( s[0] ) ) return false;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( isOperation( s[i] ) && isOperation( s[i + 1] ) ) return false;\n    }\n    bool flag = true;\n    for ( int i = 0; i + 1 < n; ++ i ) {\n        if ( flag ) {\n            if ( s[i] == '0' && isNumber( s[i + 1] ) ) return false;\n            flag = false;\n        } else if ( isOperation( s[i] ) ) {\n            flag = true;\n        }\n    }\n    return true;\n}\n\nM_S_B memo_check;\nbool check( string& s ) {\n    if ( memo_check.count( s ) ) return memo_check[s];\n    int n = s.size();\n    string left, right;\n    bool flag = true;\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            flag = false;\n        } else if ( flag ) {\n            left += s[i];\n        } else {\n            right += s[i];\n        }\n    }\n    return memo_check[s] = ( ( check2( left ) && check2( right ) ) ? eval( left ) == eval( right ) : false );\n}\n\nbool used[11];\nM_I_I E_to_D;\nconst int dr[2] = { 0, 1 };\nconst int dc[2] = { 1, 0 };\nbool backtrack( int k ) {\n    /* debug\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            cout << M[i][j] << \", \";\n        }\n        cout << endl;\n    }\n    */\n\n    if ( k >= D_ID_cnt ) {\n        bool flag = true;\n        for ( int i = 0; i < D_ID_cnt; ++ i ) {\n            if ( E_to_D[i] != E_to_D_cnt[i] ) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n    for ( int i = 0; i < O_cnt; ++ i ) {\n        int did = R[k];\n        if ( used[i] ) continue;\n        int r = D_ID_rev[did].first;\n        int c = D_ID_rev[did].second;\n        used[i] = true;\n        M[r][c] = O[i];\n\n        // '.' がすべて埋まってたら式を評価する\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            E_to_D[eid] ++;\n        }\n        bool flag = true;\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            if ( E_to_D[eid] == E_to_D_cnt[eid] ) {\n                PPP& info = E_ID[eid];\n                string exp = \"\";\n                int r = info.first.first;\n                int c = info.first.second;\n                for ( int j = 0; j < info.second.second; ++ j ) {\n                    exp += M[r][c];\n                    r += dr[info.second.first];\n                    c += dc[info.second.first];\n                }\n                if ( ! check( exp ) ) flag = false;\n            }\n        }\n        if ( flag && backtrack( k + 1 ) ) return true;\n        for ( VI::iterator it_i = D_to_E[did].begin(); it_i != D_to_E[did].end(); ++ it_i ) {\n            int eid = *it_i;\n            E_to_D[eid] --;\n        }\n\n        used[i] = false;\n    }\n    return false;\n}\n\nbool solve() {\n    E_to_D.clear();\n    fill( used, used + 11, false );\n    return backtrack( 0 );\n    /*\n    const int dr[2] = { 0, 1 };\n    const int dc[2] = { 1, 0 };\n    do {\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            // cout << i << \": \" << O[i] << \", \" << toString( D_ID_rev[i] ) << endl;\n            PII& d = D_ID_rev[i];\n            M[d.first][d.second] = O[i];\n        }\n        bool flag = true;\n        for ( int i = 0; i < E_ID_cnt; ++ i ) {\n            PPP& info = E_ID[i];\n            string exp = \"\";\n            int r = info.first.first;\n            int c = info.first.second;\n            for ( int j = 0; j < info.second.second; ++ j ) {\n                exp += M[r][c];\n                r += dr[info.second.first];\n                c += dc[info.second.first];\n            }\n            if ( ! check( exp ) ) {\n                // cout << exp << endl;\n                flag = false;\n                break;\n            }\n        }\n        if ( flag ) return true;\n    } while ( next_permutation( O.begin(), O.end() ) );\n    */\n}\n\nvoid getID() {\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == '.' ) {\n                int did = D_ID_cnt ++;\n                D_ID[PII( i, j )] = did;\n                D_ID_rev[did] = PII( i, j );\n            }\n        }\n    }\n}\n\nbool notValid( string s ) {\n    int n = s.size();\n    for ( int i = 0; i < n; ++ i ) {\n        if ( s[i] == '=' ) {\n            return ! ( i >= 1 && ( n - ( i + 1 ) ) >= 1 );\n        }\n    }\n    return true;\n}\n\nvoid addExpression( int& si, int& sj, int i, int j, int dir, string& exp, VI& ids ) {\n    if ( notValid( exp ) ) {\n        ids.clear();\n        exp.clear();\n        return;\n    }\n    int eid = E_ID_cnt ++;\n    E_to_D_cnt[eid] = 0;\n    for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n        D_to_E[*it_i].push_back( eid );\n        E_to_D_cnt[eid] ++;\n    }\n    E_ID[eid] = PPP( PII( si, sj ), PII( dir, (int)exp.size() ) );\n\n    // debug\n    // cout << (eid) << \", \" << dir << \", \" << exp << \": \" << toString( E_ID[eid] ) << endl;\n    // for ( VI::iterator it_i = ids.begin(); it_i != ids.end(); ++ it_i ) {\n    //    cout << \"\\t\" << *it_i << \": \" << toString( D_ID_rev[*it_i] ) << endl;\n    //}\n\n    si = i;\n    sj = j + 1;\n    ids.clear();\n    exp.clear();\n}\n\nvoid getExpressions() {\n    // 横\n    for ( int i = 0; i < h; ++ i ) {\n        string exp;\n        VI ids;\n        int si = i;\n        int sj = 0;\n        for ( int j = 0; j < w; ++ j ) {\n            char c = M[i][j];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, i, j, 0, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(i,j)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 0, exp, ids );\n    }\n    // 縦\n    for ( int i = 0; i < w; ++ i ) {\n        string exp;\n        VI ids;\n        int si = 0;\n        int sj = i;\n        for ( int j = 0; j < h; ++ j ) {\n            char c = M[j][i];\n            if ( c == '#' ) {\n                if ( exp.empty() ) continue;\n                addExpression( si, sj, j, i, 1, exp, ids );\n                continue;\n            } else if ( c == '.' ) {\n                ids.push_back( D_ID[PII(j,i)] );\n            }\n            exp += c;\n        }\n        if ( exp.empty() ) continue;\n        addExpression( si, sj, NONE, NONE, 1, exp, ids );\n    }\n}\n\nint main() {\n    while ( cin >> h >> w && h && w ) {\n        init_global();\n\n        // input\n        M = VS(h);\n        for ( int i = 0; i < h; ++ i ) {\n            cin >> M[i];\n        }\n        cin >> O_cnt;\n        O = VC(O_cnt);\n        for ( int i = 0; i < O_cnt; ++ i ) {\n            cin >> O[i];\n        }\n        sort( O.begin(), O.end() );\n\n        getID();\n        getExpressions();\n\n        R = VI( D_ID_cnt );\n        for ( int i = 0; i < D_ID_cnt; ++ i ) R[i] = i;\n\n        M_I_VI tmp = D_to_E;\n        for ( int i = 0; i < D_ID_cnt; ++ i ) {\n            for ( int j = i + 1; j < D_ID_cnt; ++ j ) {\n                if ( tmp[i].size() > tmp[j].size() ) {\n                    swap( tmp[i], tmp[j] );\n                    swap( R[i], R[j] );\n                }\n            }\n        }\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvector<pair<int,int>> blanks;\n\nvoid fill_blank() {\n  int i = 0;\n  REP(i, n) {\n    int x = blanks[i].first, y = blanks[i].second;\n    TABLE[x][y] = BLOCK[i];\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false; \n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  blanks.clear();\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n        if (row[x] == '.') {\n          blanks.push_back(make_pair(x, y));\n        }\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll INF = atoll(\"999999999999999\");\nint h,w,n;\nchar t[11][11];\nchar s[10];\nvector<P> v;\nbool used[10];\nvector<ll> val;\nvector<string> op;\n\nstring Op(string str,int &i){\n\tif(str[i]!='+' && str[i]!='-' && str[i]!='*' && str[i]!='/') return \"\";\n\tstring res = \"\";\n\tres += str[i++];\n\treturn i<str.length() ? res : \"\";\n}\n\nstring N(string str,int &i){\n\tstring res = \"\";\n\tif(!isdigit(str[i])) return res;\n\twhile(i<str.length() && isdigit(str[i])) res += str[i++];\n\treturn res;\n}\n\nstring N0(string str,int &i){\n\tif(str[i]=='0'){\n\t\ti++;\n\t\treturn \"0\";\n\t}\n\treturn N(str,i);\n}\n\nll Ex(string str,int &i){\n\tstring tmp;\n\tif(!isdigit(str[i])) return INF;\n\ttmp = N0(str,i);\n\tif(tmp == \"\") return INF;\n\n\tval.push_back(atoll(&tmp[0]));\n\n\twhile(i<str.length() && str[i]!='='){\n\t\ttmp = Op(str,i);\n\t\tif(tmp == \"\") return INF;\n\n\t\tif(!op.empty()){\n\t\t\tstring ops = op.back();\n\t\t\tif(ops==\"*\" || ops==\"/\" || (ops==\"+\" || ops==\"-\") && (tmp==\"+\" || tmp==\"-\")){\n\t\t\t\tll b = val.back(); val.pop_back();\n\t\t\t\tll a = val.back(); val.pop_back();\n\t\t\t\top.pop_back();\n\t\t\t\tif(ops == \"+\") val.push_back(a+b);\n\t\t\t\telse if(ops == \"-\") val.push_back(a-b);\n\t\t\t\telse if(ops == \"*\") val.push_back(a*b);\n\t\t\t\telse if(ops == \"/\"){\n\t\t\t\t\tif(b==0 || a%b!=0) return INF;\n\t\t\t\t\tval.push_back(a/b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\top.push_back(tmp);\n\n\t\ttmp = N0(str,i);\n\t\tif(tmp == \"\") return INF;\n\t\tval.push_back(atoll(&tmp[0]));\n\t}\n\n\twhile(!op.empty()){\n\t\tstring ops = op.back(); op.pop_back();\n\t\tll b = val.back(); val.pop_back();\n\t\tll a = val.back(); val.pop_back();\n\t\tif(ops == \"+\") val.push_back(a+b);\n\t\telse if(ops == \"-\") val.push_back(a-b);\n\t\telse if(ops == \"*\") val.push_back(a*b);\n\t\telse if(ops == \"/\"){\n\t\t\tif(b==0 || a%b!=0) return INF;\n\t\t\tval.push_back(a/b);\n\t\t}\n\t}\n\n\treturn val.back();\n}\n\nbool Eq(string str){\n\tval.clear();\n\top.clear();\n\n\tint i = 0;\n\tll left = Ex(str,i);\n\tif(left == INF) return false;\n\tif(i>=str.length() || str[i++]!='=') return false;\n\tif(i>=str.length()) return false;\n\tll right = Ex(str,i);\n\tif(right == INF) return false;\n\n\treturn left==right;\n}\n\nbool check(void){\n\t//ツ縦ツチツェツッツク\n\trep(j,w){\n\t\tint i = 0;\n\t\twhile(i<h){\n\t\t\tfor(;i<h && t[i][j]=='#';i++); //ツスツタツーツトツ暗環置ツづーツ探ツつキ\n\t\t\tif(i>=h) break;\n\t\t\tstring str = \"\";\n\t\t\tstr += t[i++][j];\n\t\t\tfor(;i<h && t[i][j]!='#';i++) str += t[i][j]; //ツスツタツーツトツ暗環置ツづーツ探ツつキ\n\n\t\t\tif(str.length()>=3 && !Eq(str)) return false;\n\t\t}\n\t}\n\n\t//ツ可。ツチツェツッツク\n\trep(i,h){\n\t\tint j = 0;\n\t\twhile(j<w){\n\t\t\tfor(;j<w && t[i][j]=='#';j++); //ツスツタツーツトツ暗環置ツづーツ探ツつキ\n\t\t\tif(j>=w) break;\n\t\t\tstring str = \"\";\n\t\t\tstr += t[i][j++];\n\t\t\tfor(;j<w && t[i][j]!='#';j++) str += t[i][j]; //ツスツタツーツトツ暗環置ツづーツ探ツつキ\n\n\t\t\tif(str.length()>=3 && !Eq(str)) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool solve(int idx){\n\tif(idx == n) return check();\n\n\trep(i,n) if(!used[i]) {\n\t\tused[i] = true;\n\t\tt[v[idx].second][v[idx].first] = s[i];\n\t\tif(solve(idx+1)) return true;\n\t\tused[i] = false;\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(cin>>h>>w,h){\n\t\tv.clear();\n\t\trep(i,h){\n\t\t\tcin>>t[i];\n\t\t\trep(j,w) if(t[i][j]=='.') v.push_back(P(j,i));\n\t\t}\n\t\tcin>>n;\n\t\trep(i,n) cin>>s[i];\n\n\t\tmemset(used,0,sizeof(used));\n\t\tcout<<(solve(0)?\"Yes\":\"No\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id, bool f=1) {\n  if (s.size() < 2) return 1;\n  // if (f) {\n  //   if ((id == 0 || isoperator(s[id-1])) && (!isdigit(s[id]) || s[id] == '0')) return 0;\n  //   if ((id == s.size()-1 || isoperator(s[id+1])) && !isdigit(s[id])) return 0;\n  // }\n  REP(i,s.size()-1) {\n    if ((i==0 || !isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return 0;\n    if (isoperator(s[i]) && isoperator(s[i+1])) return 0;\n  }\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    assert(pos.size() == n);\n    bool ok = 1;\n    FOR(it, v) ok &= check(*it,0,0);\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (ok&&dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool eval_factor(const string& str, int& p, int& val)\n{\n  if (p >= str.size() || str[p] < '0' || '9' < str[p]) {\n    return false;\n  }\n  val = str[p] - '0';\n  if (str[p] == '0') {\n    val = 0;\n    ++p;\n    return true;\n  }\n  ++p;\n  while (p < str.size() && '0' <= str[p] && str[p] <= '9') {\n    val = 10*val + (str[p] - '0');\n    ++p;\n  }\n  return true;\n}\n\nbool eval_term(const string& str, int& p, int& val)\n{\n  if (!eval_factor(str, p, val)) {\n    return false;\n  }\n  while (p < str.size() && (str[p] == '*' || str[p] == '/')) {\n    const char op = str[p];\n    ++p;\n    int x;\n    if (!eval_factor(str, p, x)) {\n      return false;\n    }\n    if (op == '*') {\n      val *= x;\n    } else {\n      val /= x;\n    }\n  }\n  return true;\n}\n\nbool eval_expr(const string& expr, int& p, int& val)\n{\n  if (!eval_term(expr, p, val)) {\n    return false;\n  }\n  while (p < expr.size() && (expr[p] == '+' || expr[p] == '-')) {\n    const char op = expr[p];\n    ++p;\n    int x;\n    if (!eval_term(expr, p, x)) {\n      return false;\n    }\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return true;\n}\n\nbool check(const string& expr)\n{\n  if (expr.size() == 1) {\n    return true;\n  }\n int p = 0;\n int lhs, rhs;\n if (!eval_expr(expr, p, lhs)) {\n   return false;\n }\n if (p < expr.size() && expr[p] != '=') {\n   return false;\n }\n ++p;\n if (!eval_expr(expr, p, rhs)) {\n   return false;\n }\n return p == expr.size() && lhs == rhs;\n}//\n\nbool valid(const vector<string>& grid)\n{\n  const int H = grid.size(), W = grid[0].size();\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (grid[i][j] != '#') {\n        if (j == 0 || grid[i][j-1] == '#') {\n          string expr(grid[i].begin()+j, find(grid[i].begin()+j, grid[i].end(), '#'));\n          if (!check(expr)) {\n            return false;\n          }\n        }\n        if (i == 0 || grid[i-1][j] == '#') {\n          string expr;\n          for (int k = i; k < H && grid[k][j] != '#'; k++) {\n            expr += grid[k][j];\n          }\n          if (!check(expr)) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(vector<string>& grid, const vector<pair<int,int> >& spaces, vector<char>& cards)\n{\n  sort(cards.begin(), cards.end());\n  do {\n    for (size_t i = 0; i < cards.size(); i++) {\n      grid[spaces[i].first][spaces[i].second] = cards[i];\n    }\n    if (valid(grid)) {\n      return true;\n    }\n  } while (next_permutation(cards.begin(), cards.end()));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (cin >> H >> W && H != 0) {\n    vector<string> grid(H);\n    vector<pair<int,int> > spaces;\n    for (int i = 0; i < H; i++) {\n      cin >> grid[i];\n      for (int j = 0; j < W; j++) {\n        if (grid[i][j] == '.') {\n          spaces.push_back(make_pair(i, j));\n        }\n      }\n    }\n    int N;\n    cin >> N;\n    vector<char> cards(N);\n    for (int i = 0; i < N; i++) {\n      cin >> cards[i];\n    }\n    if (solve(grid, spaces, cards)) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  int value = 0;\n  bool flag = false;\n  while (isdigit(s[p])) {\n    if (flag and value == 0) {\n      throw NotNumExc;\n    }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 14, WMAX = 14, NMAX = 15;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cctype>\n#include<cstring>\n#include<iomanip>\n#include<set>\n#include<map>\n\n#define NMAX 11\n#define MAX 16\n\nusing namespace std;\n\ntypedef pair<const char *, int > parsed;\ntypedef pair<bool,int> bnfm;\n\nparsed expr(const char *);\nparsed term(const char *);\nparsed fact(const char *);\n\nbnfm Ex(int pos, const string &s);\nbnfm N0(int pos, const string &s);\n\nparsed expr(const char *p){\n  parsed r = term(p);\n  if( r.first == NULL ) return r; // parse error\n  while( *(r.first)=='+' || *(r.first)=='-' ){\n    const char *op = r.first;\n    parsed l = term(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='+' ){\n      r.first = l.first;\n      r.second = r.second + l.second;\n    }else{\n      r.first = l.first;\n      r.second = r.second - l.second;\n    }\n  }\n  return r;\n}\n\nparsed term(const char *p){\n  parsed r = fact(p);\n  if( r.first == NULL ) return r;\n  while( *(r.first)=='*' || *(r.first)=='/' ){\n    const char *op = r.first;\n    parsed l = fact(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='*' ){\n      r.first = l.first;\n      r.second = r.second * l.second;\n    }else{\n      r.first = l.first;\n      if( l.second == 0 || r.second % l.second != 0 ) return parsed(NULL,-1);\n      r.second = int(r.second / l.second);\n    }\n  }\n  return r;\n}\n\ninline parsed fact(const char *p){\n  if( *p=='(' ){\n    // new expression\n    parsed tp = expr(p+1);\n    if( tp.first == NULL ) return tp;\n    return parsed(tp.first+1, tp.second);\n  }\n  if( *p=='-' ){\n    // negative fact\n    parsed tp = fact(p+1);\n    if( tp.first == NULL ) return tp;\n    tp.second *= -1;\n    return tp;\n  }\n  if( isdigit(*p) ){\n    // number\n    int num = *p - '0';\n    while( isdigit(*(++p)) ){\n      num *= 10;\n      num += *p - '0';\n    }\n    return parsed(p,num);\n  }else assert(0); return parsed(NULL,0);\n}\n\ninline bool Eq(const string &s){\n  int pos = 0;\n  bnfm r = Ex(pos,s);\n  if( !r.first ) return false;\n  pos = r.second;\n  if( pos >= s.length() ) return false;\n  if( s[pos] != '=' ) return false;\n  ++pos;\n  r = Ex(pos,s);\n  if( !r.first ) return false;\n  if( r.second < s.length() ) return false;\n  return true;\n}\n\nbnfm Ex(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm(false,pos);\n  bnfm r = N0(pos,s);\n  if( !r.first ) return bnfm(false,r.second);\n  pos = r.second;\n  if( pos >= s.length() ) return bnfm(true,pos);\n  while( s[ pos ] == '+' || s[ pos ] == '-' || s[ pos ] == '*' || s[ pos ] == '/' ){\n    bnfm r = N0( pos+1, s );\n    if( !r.first ) return bnfm(false,r.second);\n    pos = r.second;\n    if( pos >= s.length() ) break;\n  }\n  return bnfm(true,pos);\n}\n\nbnfm N0(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm( false,pos );\n  if( !isdigit( s[pos] ) ) return bnfm(false,pos+1);\n  if( s[pos] == '0' ){\n    if( pos + 1 < s.length() ){\n      if( isdigit( s[pos+1] ) ) return bnfm(false,pos+2);\n    }\n    return bnfm(true,pos+1);\n  }else{\n    while( isdigit(s[pos]) ){\n      ++pos;\n      if( pos >= s.length() ) break;\n    }\n    return bnfm(true,pos);\n  }\n}\n\nbool Evaluate(const string &s){\n  string s1,s2;\n  int i,j;\n  for(i = 0; i < s.length(); ++i){\n    if( s[i] == '=' ) break;\n    else s1 += s[i];\n  }\n  for(j=i+1; j < s.length(); ++j){\n    s2 += s[j];\n  }\n  parsed p1 = expr(s1.c_str());\n  parsed p2 = expr(s2.c_str());\n  if( p1.first == NULL || p2.first == NULL ) return false;\n  if( p1.second == p2.second ) return true;\n  else return false;\n}\n\nbool Judge(const vector<string> &eqs){\n\n  for(int i = 0; i < eqs.size(); ++i){\n    if( eqs[i].find('.') == string::npos ){\n      if( !Eq(eqs[i]) ) return false;\n      if( !Evaluate( eqs[i] ) ) return false;\n    }\n  }\n  return true;\n  /*\n  const int di [] = {-1,0,1,0};\n  const int dj [] = {0,1,0,-1};\n\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( pzl[i+1][j+1] != '#' ){ \n\tfor(int l = 0; l < sizeof(di)/sizeof(*di); ++l){\n\t  if( l == 1 || l == 2 ) continue;\n\t  int ti = i + 1 + di[l]; int tj = j + 1 + dj[l];\n\t  if( pzl[ti][tj] == '#' ){\n\t    int dir = (l+2)%(sizeof(di)/sizeof(*di));\n\t    ti = i+1+di[dir]; tj = j+1+dj[dir];\n\t    string eq;\n\t    eq += pzl[i+1][j+1];\n\t    while(pzl[ti][tj]!='#'){\n\t      eq += pzl[ti][tj]; ti += di[dir]; tj += dj[dir];\n\t    }\n\t    if( eq.length() >= 3 && eq.find('.') == string::npos ){\n\t      if( !Eq(eq) ) return false;\n\t      if( !Evaluate( eq ) ) return false;\n\t    }\n\t    eq.clear();\n\t  }\n\t}\n      }\n    }\n  }\n  return true;\n  */\n}\n\nbool operator<(const pair<int,int> &a, const pair<int,int> &b){\n  return a.first == b.first ? a.second < b.second : a.first < b.first;\n}\n\nbool dfs(int n, int now,\n\t const vector<pair<int,int> > &hole_pos,\n\t map< pair<int,int>, vector< pair<int,int> > > &meq,\n\t vector<string> &eqs,\n\t bool vis[NMAX], char holes[NMAX], int H, int W, char pzl[][MAX] ){\n\n  if( !Judge( eqs ) ){\n    return false;\n  }else if( now == hole_pos.size() ){\n    return true;\n  }\n\n  for(int i = 0; i < n; ++i){\n    if( !vis[i] ){\n      const vector< pair<int,int> > &v = meq[ hole_pos[now] ];\n      //vector<string> teqs = eqs;\n      //cout << \"DOT POS=\" << hole_pos[now].first << ' ' << hole_pos[now].second << \" : \";\n      for(int j = 0; j < v.size(); ++j){\n\t//cout << v[j].first << ' ' << v[j].second << ',';\n\teqs[ v[j].first ][ v[j].second ] = holes[ i ];\n      }\n      /*\n      cout << endl;\n      for(int j = 0; j < teqs.size(); ++j){\n\tcout << teqs[j] << endl;\n      }\n      cout << endl;\n      */\n\n      vis[i]=true;\n      if( dfs( n, now+1, hole_pos, meq, eqs, vis, holes, H,W, pzl) ) return true;\n      vis[i]=false;\n\n      for(int j = 0; j < v.size(); ++j){\n\teqs[ v[j].first ][ v[j].second ] = '.';\n      }\n\n    }\n  }\n  return false;\n}\n\nint main(void){\n  while(true){\n    int H,W;\n    char pzl[MAX][MAX];\n    bool vis[NMAX]={false,};\n    vector< pair<int,int> > hole_pos;\n    vector<string> eqs;\n    map< pair<int,int>, vector< pair<int,int> > > meq;\n\n    for(int i = 0; i < MAX; ++i)\n      for(int j = 0; j < MAX; ++j)\n\tpzl[i][j]='#';\n    \n    cin >> H >> W;\n    if( H == 0 && W == 0) break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> pzl[i+1][j+1];\n\tif(pzl[i+1][j+1] == '.' ){\n\t  hole_pos.push_back( make_pair(i+1,j+1) );\n\t}\n      }\n    }\n    \n    int n,num=0;\n    cin >> n;\n    int p[n];\n    char holes[n];\n    for(int i = 0; i < n; ++i){\n      char d; cin >> d; holes[num++] = d; p[i] = i;\n    }\n\n    const int di [] = {-1,0,1,0};\n    const int dj [] = {0,1,0,-1};\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif( pzl[i+1][j+1] != '#' ){ \n\t  for(int l = 0; l < sizeof(di)/sizeof(*di); ++l){\n\t    if( l == 1 || l == 2 ) continue;\n\t    int ti = i + 1 + di[l]; int tj = j + 1 + dj[l];\n\t    if( pzl[ti][tj] == '#' ){\n\t      int dir = (l+2)%(sizeof(di)/sizeof(*di));\n\t      ti = i+1; tj = j+1;\n\t      string eq;\n\t      vector< pair<int,int> > poss;\n\t      vector<int> ats;\n\t      while(pzl[ti][tj]!='#'){\n\t\teq += pzl[ti][tj];\n\t\tif( pzl[ti][tj] == '.' ){\n\t\t  poss.push_back( make_pair( ti, tj ) );\n\t\t  ats.push_back( eq.length()-1 );\n\t\t}\n\t\tti += di[dir]; tj += dj[dir];\n\t      }\n\t      if( eq.length() >= 3 ){\n\t\teqs.push_back( eq );\n\t\t//cout << \"EQ : \" << eq << endl;\n\t\t//cout << \"DOT ATS : \"; \n\t\tfor(int i = 0; i < poss.size(); ++i){\n\t\t  //cout << ats[i] << ' ';\n\t\t  meq[ poss[i] ].push_back( make_pair( eqs.size()-1, ats[i] ) );\n\t\t}\n\t\t//cout << endl;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    if( dfs(n,0,hole_pos,meq,eqs,vis,holes,H,W,pzl) ){\n      cout << \"Yes\" << endl;\n    }else{\n      cout << \"No\" <<endl;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int UND = 1<<30;\nint h, w;\nchar cur[10][11];\nvector <P> dot;\nbool ans;\n\nclass Parser\n{\npublic:\n\tstring exp;\n\tint p;\n\tvoid Eq (void );\n\tint Ex (void );\n\tint N (void );\n};\n\nvoid Parser::Eq (void )\n{\n\tint value1 = 0, value2 = 0;\n#if DEBUG\n\tcout << \"exp: \" << exp << endl;\n#endif\n\tvalue1 = Ex();\n\n\tif (value1 == UND ) ans = false;\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tint val = 0;\n\t\tif (exp[p] == '+' ){\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue1 += val;\n\t\t}else{\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue1 -= val;\t\t\n\t\t} // end if\n\t} // end while\n\n\tif (exp[p] == '=' ){\n\t\t++p;\n\t} // end if\n\n\tvalue2 = Ex();\t\t\t\n\n\tif (value2 == UND ) ans = false;\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tint val = 0;\n\t\tif (exp[p] == '+' ){\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue2 += val;\n\t\t}else{\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue2 -= val;\t\t\n\t\t} // end if\n\t} // end while\n\n\tif (value1 != value2 )\n\t\tans = false;\n#if DEBUG\n\tcout << \"ans: \" << (ans ? \"YES\" : \"NO\" ) << endl;\n#endif\n}\n\nint Parser::Ex (void )\n{\n\tint value = N();\n\n\tif (value == UND ) ans = false;\n\n\twhile (exp[p] == '*' || exp[p] == '/' ){\n\t\tif (exp[p] == '*' ){\n\t\t\t++p;\n\t\t\tint val = N();\n\t\t\tif (val == UND ){\n\t\t\t\tvalue = UND;\n\t\t\t\tans = false;\n\t\t\t}else{\n\t\t\t\tvalue *= val;\n\t\t\t} // end if\n\t\t}else{\n\t\t\t++p;\n\t\t\tint val = N();\n\t\t\tif (value != UND && val != UND && val != 0 && value % val == 0 ){\n\t\t\t\tvalue /= val;\n\t\t\t}else{\n\t\t\t\tvalue = UND;\n\t\t\t\tans = false;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end while\n\t\n\treturn value;\n}\n\nint Parser::N (void )\n{\n\tint value = 0;\n\tint cnt = 0;\n\tchar first = 0;\n\tif (!isdigit(exp[p] ) )\n\t\treturn UND;\n\n\twhile (isdigit(exp[p] ) ){\n\t\tif (cnt == 0 ){\n\t\t\tfirst = exp[p];\n\t\t} // end if\n\t\tvalue *= 10;\n\t\tvalue += (exp[p] - '0');\n\t\tcnt++;\n\t\tp++;\n\t} // end while\n\n\tif ( (first == '0' && cnt > 1 ) || (cnt > 2 ) )\n\t\tans = false;\n\n\treturn value;\n}\n\nvoid disp_pz (void )\n{\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tcout << cur[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep \n}\n\n\nbool make_pz (vector<char> ope )\n{\n\tint k = 0;\n\trep (i, dot.size() ){\n\t\tcur[dot[i].first][dot[i].second] = ope[k++];\n\t} // end rep\n\n#if DEBUG\n\tdisp_pz ();\n\tcout << endl;\n#endif\n\trep (i, h ){\n\t\trep (j, w ) {\n\t\t\tif (cur[i][j] != '#' && !isdigit (cur[i][j] ) ) {\n\t\t\t\tif (i == 0 && j == 0 ) return false;\n\t\t\t\tif (i != 0 && cur[i-1][j] != '#' && !isdigit (cur[i-1][j] ) ) return false;\n\t\t\t\tif (j != 0 && cur[i][j-1] != '#' && !isdigit (cur[i][j-1] ) ) return false;\n\t\t\t\tif (i == h - 1 && j == w - 1 ) return false;\n\t\t\t\tif (i+1 < h && cur[i+1][j] != '#' && !isdigit (cur[i+1][j] ) ) return false;\n\t\t\t\tif (j+1 < w && cur[i][j+1] != '#' && !isdigit (cur[i][j+1] ) ) return false;\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\treturn true;\n}\n\nvoid evaluate_exp (string exp )\n{\n\tif (exp.length() < 3 ) {\n\t\tans = false;\n\t\treturn;\n\t} // end if\n\n//\tcout << exp << endl;\n\tParser parser;\n\tparser.exp = exp;\n\tparser.p = 0;\n\tans = true;\n\tparser.Eq();\n}\n\nbool is_correct (void )\n{\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tstring exp = \"\";\n\t\t\tif (cur[i][j] == '=' ){\n\t\t\t\texp += cur[i][j];\n\t\t\t\tif (i - 1 > 0 ){\n\t\t\t\t\tstring t = \"\";\n\t\t\t\t\tfor (int row = i-1; row >= 0; row-- ){\n\t\t\t\t\t\tif (cur[row][j] != '#' && cur[row][j] != '=' )\n\t\t\t\t\t\t\tt = cur[row][j] + t;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end if\n\t\t\t\t\tif (t.empty() ) continue;\n\t\t\t\t\texp = t + exp;\n\t\t\t\t} // end if\n\t\t\t\tif (i + 1 < h ){\n\t\t\t\t\tstring t = \"\";\n\t\t\t\t\tfor (int row = i+1; row < h; row++ ){\n\t\t\t\t\t\tif (cur[row][j] != '#' && cur[row][j] != '=' )\n\t\t\t\t\t\t\tt += cur[row][j];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end for\n\t\t\t\t\tif (t.empty() ) continue;\n\t\t\t\t\texp += t;\n\t\t\t\t} // end if\n\t\t\t\tif (exp.size() == 1 ) continue;\n\t\t\t\tif (exp[0] == '=' || exp[exp.size() - 1] == '=' ) continue;\n\n\t\t\t\tevaluate_exp (exp );\n\t\t\t\tif (!ans )\n\t\t\t\t\treturn false;\n// for debug\n//cout << exp << endl;\n\n\t\t\t\texp = \"\";\n\t\t\t\texp += cur[i][j];\n\t\t\t\tif (j - 1 > 0 ){\n\t\t\t\t\tstring t = \"\";\n\t\t\t\t\tfor (int col = j-1; col >= 0; col-- ){\n\t\t\t\t\t\tif (cur[i][col] != '#' && cur[i][col] != '=' )\n\t\t\t\t\t\t\tt = cur[i][col] + t;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end if\n\t\t\t\t\tif (t.empty() ) continue;\n\t\t\t\t\texp = t + exp;\n\t\t\t\t} // end if\n\t\t\t\tif (j + 1 < w ){\n\t\t\t\t\tstring t = \"\";\n\t\t\t\t\tfor (int col = i+1; col < w; col++ ){\n\t\t\t\t\t\tif (cur[i][col] != '#' && cur[i][col] != '=' )\n\t\t\t\t\t\t\tt += cur[i][col];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end for\n\t\t\t\t\tif (t.empty() ) continue;\n\t\t\t\t\texp += t;\n\t\t\t\t} // end if\n\t\t\t\tif (exp.size() == 1 ) continue;\n\t\t\t\tif (exp[0] == '=' || exp[exp.size() - 1] == '=' ) continue;\n\n\t\t\t\tevaluate_exp (exp );\n\t\t\t\tif (!ans )\n\t\t\t\t\treturn false;\n\t\t\t\t// for debug\n//\t\t\t\tcout << exp << endl;\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\treturn true;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.indian_puzzle3\", \"r\", stdin );\n\n\twhile (scanf (\"%d %d\", &h, &w ) && h && w ){ \n\t\tmemset (cur, 0, sizeof (cur ) );\n\t\tdot.clear();\n\t\trep (i, h ){\n\t\t\trep (j, w ){\n\t\t\t\tscanf (\" %c\", cur[i]+j );\n\t\t\t\tif (cur[i][j] == '.' )\n\t\t\t\t\tdot.push_back (P (i, j ) );\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tint n;\n\t\tscanf (\"%d\", &n );\n\t\tvector<char> ope (n, 0 );\n\t\trep (i, n ){\n\t\t\tscanf (\" %c\", &ope[i] );\n\t\t} // end rep\n\t\tsort (ALL (ope ) );\n\t\tbool found = false;\n\t\tdo{\n\t\t\tif (!make_pz (ope ) ) continue;\n\n\t\t\tif (is_correct () ){\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t}while (next_permutation (ALL (ope ) ) );\n\t\t\n\t\tif (found ){\n\t\t\tprintf (\"Yes\\n\" );\n\t\t}else{\n\t\t\tprintf (\"No\\n\" );\n\t\t} // end if\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) {\n                end_parse = 1;\n                return 1e7;\n            }\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0){\n                end_parse = true;\n                return 1e7;\n            }\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    end_parse = 0;\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15]){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nbool check(char m[15][15]){\n    bool f;\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++){\n                    if(m[k][j] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++){\n                    str.push_back(m[i][k]);\n                    if(m[i][k] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        int k = 0;\n        rep(i,h){\n            rep(j,w){\n                scanf(\"%c\",&m[i + 1][j + 1]);\n                if(m[i + 1][j + 1] == '.'){\n                    y[k] = i + 1;\n                    x[k++] = j + 1;\n                }\n            }\n            scanf(\"%*c\");\n        }\n\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n        if(not check(m)){\n            cout << \"NO\" << endl;\n            continue;\n        }\n\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"Yes\" : \"No\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<int,int> num(const string &f, int i) {\n  int n = 0;\n  if (i >= f.size() || f[i] < '0' || f[i] > '9') throw \"puee\";\n  while(i < f.size()) {\n    if(f[i] < '0' || f[i] > '9') return make_pair(n,i);\n    n *= 10;\n    n += f[i] - '0';\n    ++i;\n  }\n  return make_pair(n,i);\n}\n\npair<int,int> mult(const string &f, int i) {\n  auto p = num(f,i);\n  while(p.second != f.size()) {\n    if(f[p.second] == '*') {\n      auto np = num(f,p.second+1);\n      p.first *= np.first;\n      p.second = np.second;\n    }else if(f[p.second] == '/') {\n      auto np = num(f,p.second+1);\n      if (np.first == 0) throw \"guee\";\n      p.first /= np.first;\n      p.second = np.second;\n    }else break;\n  }\n  return p;\n}\n\npair<int,int> add(const string &f, int i) {\n  auto p = mult(f,i);\n  while(p.second != f.size()) {\n    if(f[p.second] == '+') {\n      auto np = mult(f,p.second+1);\n      p.first += np.first;\n      p.second = np.second;\n    }else if(f[p.second] == '-') {\n      auto np = mult(f,p.second+1);\n      p.first -= np.first;\n      p.second = np.second;\n    }else break;\n  }\n  return p;\n}\n\nbool is_valid(const string &f, int st, int ed) {\n  auto p = add(f, st);\n  if (p.second >= ed) return false;\n  auto q = add(f, p.second+1);\n  return q.second == ed && p.first == q.first;\n}\n\nbool is_invalid(const string &f, int st, int ed) {\n  string s = \"+-*/=\";\n  bool prev = true;\n  for(int i=st;i < ed; ++i) {\n    if(s.find(f[i]) != string::npos) {\n      if (prev) return true;\n      prev = true;\n    } else {\n      prev = false;\n    }\n  }\n  return prev;\n}\n\nbool is_closed(const string &f, int st, int ed) {\n  for(int i=st;i < ed;++i) if (f[i] == '.') return false;\n  return true;\n}\n\nbool is_valid_2_impl(const vector<string> &tb) {\n  for(auto &line : tb) {\n    int old = 0;\n    REP(i,line.size()) {\n      if(!i) continue;\n      if (line[i] == '#') {\n        if (i-old-1 >= 3){\n          if(is_closed(line,old+1,i)\n              && !is_valid(line,old+1,i)) return false;\n        }\n        old = i;\n      }\n    }\n  }\n  return true;\n}\n\nbool is_valid_2(const vector<string> &tb) {\n  if(!is_valid_2_impl(tb)) return false;\n  vector<string> tr(tb[0].size());\n  REP(i,tb.size()){\n    REP(j,tb[0].size()){\n      tr[j] += tb[i][j];\n    }\n  }\n  return is_valid_2_impl(tr);\n}\n\nbool search(vector<string> &tb, vector<tuple<int,int>> op, const vector<string> &v) {\n  if (op.empty()) return true;\n  int i,j;\n  tie(i,j) = op.back();\n  op.pop_back();\n  int n=v.size();\n  REP(k,n) {\n    auto cp = v;\n    cp.erase(begin(cp)+k);\n    tb[i][j] = v[k][0];\n    int s,t;\n    s=t=i;\n    while(tb[s][j] != '#') --s;\n    while(tb[t][j] != '#') ++t;\n    ++s;\n    if (t-s >= 3) {\n      string str;\n      REP(l,t-s) str += tb[s+l][j];\n      if (is_invalid(str,0,str.size())) continue;\n      try {\n        if(is_closed(str,0,str.size())\n            && !is_valid(str,0,str.size())) continue;\n      } catch(...) {\n        continue;\n      }\n    }\n    s=t=j;\n    while(tb[i][s] != '#') --s;\n    while(tb[i][t] != '#') ++t;\n    ++s;\n    if(t-s >= 3) {\n      if (is_invalid(tb[i],s,t)) continue;\n      try{\n        if(is_closed(tb[i],s,t) && !is_valid(tb[i],s,t)) continue;\n      } catch(...) {\n        continue;\n      }\n    }\n    if (search(tb,op,cp)){\n      tb[i][j] = '.';\n      return true;\n    }\n  }\n  tb[i][j] = '.';\n  return false;\n}\n\nint main() {\n  while(1){\n    int h,w;\n    cin>>h>>w;\n    if(!h) break;\n    vector<string> tb(h+2,string(w+2,'#'));\n    REP(i,h){\n      string l;\n      cin>>l;\n      tb[i+1] = '#' + l + '#';\n    }\n    h+=2;w+=2;\n    int n;\n    cin>>n;\n    vector<string> v(n);\n    REP(i,n) cin>>v[i];\n    vector<tuple<int,int>> op;\n    REP(i,h)REP(j,w)if(tb[i][j]=='.')op.emplace_back(i,j);\n    if (!is_valid_2(tb)) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    bool ans = search(tb,op,v);\n    if (ans)\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\n#define INF 999999999\n\nint h, w, n;\nchar t[12][12];\nchar p[12];\n\nvector<int> blankX;\nvector<int> blankY;\n\nbool used[12];\nbool isOperator[128];\n\n//式の開始地点でないなら, -1が入る\n//式の開始地点なら, どの座標の空白が埋まれば式判定できるか\n//空白が埋まらなくても式判定できるなら, -2が入る\nint gx0[12][12], gy0[12][12];\nint gx1[12][12], gy1[12][12];\n\n//構文解析用変数\nint idxX;\nint idxY;\nint dir;\n\n//右 下 左 上\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\n//w*hの範囲内であるならばtrue\nbool inBoard(int x, int y){\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\n//#でないマス目であるならばtrue\nbool isWhite(int x, int y){\n  if(!inBoard(x, y)) return false;\n  return t[y][x] != '#';\n}\n\n//演算子が含まれるマスならばtrue\nbool containsOperator(int x, int y){\n  if(!inBoard(x, y)) return false;\n  return isOperator[t[y][x]];\n}\n\nint N0(){\n  if(!isdigit(t[idxY][idxX])){\n    return INF;\n  }\n\n  string valStr;\n\n  while(inBoard(idxX, idxY) && isdigit(t[idxY][idxX])){\n    valStr += t[idxY][idxX];\n    idxX += dx[dir];\n    idxY += dy[dir];\n  }\n\n  if(valStr.length() == 1 || valStr[0] != '0'){\n    return atoi(valStr.c_str());\n  }\n  return INF;\n}\n\nint Term(){\n  int lv = N0();\n  if(lv == INF) return INF;\n\n  while(inBoard(idxX, idxY) && (t[idxY][idxX] == '*' || t[idxY][idxX] == '/')){\n    char op = t[idxY][idxX];\n\n    idxX += dx[dir];\n    idxY += dy[dir];\n\n    int rv = N0();\n    if(rv == INF) return INF;\n\n    if(op == '*'){\n      lv *= rv;\n    }\n    else{\n      if(rv == 0 || lv % rv != 0) return INF;\n      lv /= rv;\n    }\n  }\n\n  return lv;\n}\n\nint Ex(){\n  int lv = Term();\n  if(lv == INF) return INF;\n\n  while(inBoard(idxX, idxY) && (t[idxY][idxX] == '+' || t[idxY][idxX] == '-')){\n    char op = t[idxY][idxX];\n\n    idxX += dx[dir];\n    idxY += dy[dir];\n\n    int rv = Term();\n    if(rv == INF) return INF;\n\n    if(op == '+') lv += rv;\n    else          lv -= rv;\n  }\n\n  return lv;\n}\n\nbool isCorrectEq(){\n  //左辺\n  int lv = Ex();\n  if(lv == INF) return false;\n\n  //イコールがあるかどうか\n  if(!inBoard(idxX, idxY) || t[idxY][idxX] != '=') return false;\n  idxX += dx[dir];\n  idxY += dy[dir];\n\n  //右辺\n  int rv = Ex();\n  if(rv == INF) return false;\n\n  return lv == rv;\n}\n\nbool isCorrectBoard(int x, int y){\n  /*\n  cout<<x<<\",\"<<y<<endl;\n  for(int i = 0; i < h; i++){\n    cout << t[i] << endl;\n  }\n  cout<<\"--\\n\";\n  */\n\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(gx0[i][j] == x && gy0[i][j] == y){\n        idxX = j;\n        idxY = i;\n        dir = 0;\n\n        if(!isCorrectEq()) return false;\n      }\n      if(gx1[i][j] == x && gy1[i][j] == y){\n        idxX = j;\n        idxY = i;\n        dir = 1;\n\n        if(!isCorrectEq()) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nbool dfs(int blankIdx){\n  if(blankIdx == n){\n    return true;\n  }\n\n  int x = blankX[blankIdx];\n  int y = blankY[blankIdx];\n  bool digitFlg = false;\n\n  //必ず数字を入れなくてはいけないマスであるかチェック\n  for(int i = 0; i < 4; i++){\n    if(containsOperator(x + dx[i], y + dy[i])){\n      digitFlg = true;\n      break;\n    }\n  }\n  if(isWhite(x + dx[0], y + dy[0]) + isWhite(x + dx[2], y + dy[2]) == 1){\n    digitFlg = true;\n  }\n  if(isWhite(x + dx[1], y + dy[1]) + isWhite(x + dx[3], y + dy[3]) == 1){\n    digitFlg = true;\n  }\n\n  //ピースを当てはめる\n  for(int i = 0; i < n; i++){\n    if(used[i]) continue;\n    if(digitFlg && isOperator[p[i]]) continue;\n\n    used[i] = true;\n    t[y][x] = p[i];\n\n    if(isCorrectBoard(x, y) && dfs(blankIdx + 1)) return true;\n\n    used[i] = false;\n  }\n\n  return false;\n}\n\nint main(){\n  isOperator['+'] = true;\n  isOperator['-'] = true;\n  isOperator['*'] = true;\n  isOperator['/'] = true;\n  isOperator['='] = true;\n\n  while(cin >> h >> w, h || w){\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n    }\n\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      cin >> p[i];\n    }\n\n    blankX.clear();\n    blankY.clear();\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(t[i][j] != '.') continue;\n        blankX.push_back(j);\n        blankY.push_back(i);\n      }\n    }\n\n    memset(gx0, -1, sizeof(gx0));\n    memset(gy0, -1, sizeof(gy0));\n    memset(gx1, -1, sizeof(gx1));\n    memset(gy1, -1, sizeof(gy1));\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(t[i][j] == '#') continue;\n\n        if(!isWhite(i + 1 * dy[2], j + 1 * dx[2]) &&\n            isWhite(i + 1 * dy[0], j + 1 * dx[0]) &&\n            isWhite(i + 2 * dy[0], j + 2 * dx[0])){\n          int x = j;\n          int y = i;\n\n          gx0[i][j] = -2;\n          gy0[i][j] = -2;\n\n          while(inBoard(x, y) && isWhite(x, y)){\n            if(t[y][x] == '.'){\n              gx0[i][j] = x;\n              gy0[i][j] = y;\n            }\n            x += dx[0];\n            y += dy[0];\n          }\n        }\n        if(!isWhite(i + 1 * dy[3], j + 1 * dx[3]) &&\n            isWhite(i + 1 * dy[1], j + 1 * dx[1]) &&\n            isWhite(i + 2 * dy[1], j + 2 * dx[1])){\n          int x = j;\n          int y = i;\n\n          gx1[i][j] = -2;\n          gy1[i][j] = -2;\n\n          while(inBoard(x, y) && isWhite(x, y)){\n            if(t[y][x] == '.'){\n              gx1[i][j] = x;\n              gy1[i][j] = y;\n            }\n            x += dx[1];\n            y += dy[1];\n          }\n        }\n      }\n    }\n\n    bool flg = isCorrectBoard(-2, -2);\n\n    if(!flg){\n      cout << \"No\\n\";\n      continue;\n    }\n\n    memset(used, 0, sizeof(used));\n    cout << (dfs(0) ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define all(c) (c).begin(),(c).end()\ntypedef long long ll;\ntypedef string::const_iterator State;\nstring s;\nvoid consume(State &be, char exp);\nvoid ok(State &be);\nvoid eq(State &be);\nll ex(State &be);\nll term(State &be);\nll num(State &be);\nvoid consume(State &be, char exp){\n\tif(*be==exp) be++;\n\telse throw 0;\n}\nvoid ok(State &be){\n\twhile(be!=s.end()){\n\t\twhile(*be=='#') be++;\n\t\tif(be==s.end()) return;\n\t\tif(*(be+1)=='#'){\n//\t\t\tcout << be-s.begin() << endl;\n\t\t\tbe++;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout << \"eq\" << be-s.begin() << endl;\n\t\teq(be);\n\t\tconsume(be,'#');\n\t}\n}\nvoid eq(State &be){\n\tll l=ex(be);\n\tconsume(be,'=');\n\tll r=ex(be);\n\tif(l!=r) throw 0;\n}\nll ex(State &be){\n\tll ret=term(be);\n\twhile(true){\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tret+=term(be);\n\t\t}else if(*be=='-'){\n\t\t\tbe++;\n\t\t\tret-=term(be);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nll term(State &be){\n\tll ret=num(be);\n\twhile(true){\n\t\tif(*be=='*'){\n\t\t\tbe++;\n\t\t\tret*=num(be);\n\t\t}else if(*be=='/'){\n\t\t\tbe++;\n\t\t\tll div=num(be);\n\t\t\tif(ret%div) throw 0;\n\t\t\telse ret/=div;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nll num(State &be){\n\tll ret=0;\n\tbool fs0=false;\n\tif(!isdigit(*be) || (*be=='0' && isdigit(*(be+1)) )) throw 0;\n\twhile(isdigit(*be)){\n\t\tret*=10;\n\t\tret+=*be-'0';\n\t\tbe++;\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\t\tint h,w,n,cnt=0,doth[10],dotw[10];\n\t\tbool flag=false;\n\t\tscanf(\"%d%d\",&h,&w);\n\t\tif(h==0) break;\n\t\tvector<string> mp;\n\t\trep(i,h){\n\t\t\tstring st;\n\t\t\tcin >> st;\n\t\t\tmp.push_back(st);\n\t\t\trep(j,w){\n\t\t\t\tif(st[j]=='.') doth[cnt]=i,dotw[cnt]=j,cnt++;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tstring var;\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tvar+=c;\n\t\t}\n\t\tint a[10]={};\n\t\trep(i,n) a[i]=i;\n\t\tdo{\n\t\t\trep(i,n){\n//\t\t\t\tcout << i << \" \" << doth[i] << \" \" << dotw[i] << \" \" << a[i] << endl;\n\t\t\t\tmp[doth[i]][dotw[i]]=var[a[i]];\n\t\t\t}\n\t\t\ttry{\n\t\t\t\trep(i,h){\n\t\t\t\t\ts=mp[i]+\"#\";\n\t\t\t\t\tState be=s.begin();\n\t\t\t\t\tok(be);\n\t\t\t\t}\n\t\t\t\trep(i,w){\n\t\t\t\t\ts=\"\";\n\t\t\t\t\trep(j,h) s+=mp[j][i];\n\t\t\t\t\ts+='#';\n\t\t\t\t\tState be=s.begin();\n\t\t\t\t\tok(be);\n\t\t\t\t}\n\t\t\t\tcout << \"Yes\\n\";\n\t\t\t\tflag=true;\n/*\t\t\t\trep(i,h){\n\t\t\t\t\trep(j,w) cout << mp[i][j];\n\t\t\t\t\tcout << endl;\n\t\t\t\t}*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcatch(int error){}\n\t\t}while(next_permutation(a,a+n));\n\t\tif(!flag) printf(\"No\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch(int ex) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool eval_factor(const string& str, int& p, int& val)\n{\n  if (p >= str.size()) {\n    return false;\n  }\n  if (str[p] < '0' || '9' < str[p]) {\n    return false;\n  }\n  val = str[p] - '0';\n  ++p;\n  if (str[p] == '0') {\n    val = 0;\n    return true;\n  }\n  while (p < str.size() && '0' <= str[p] && str[p] <= '9') {\n    val = 10*val + (str[p] - '0');\n    ++p;\n  }\n  return true;\n}\n\nbool eval_term(const string& str, int& p, int& val)\n{\n  if (p >= str.size()) {\n    return false;\n  }\n  if (!eval_factor(str, p, val)) {\n    return false;\n  }\n  while (p < str.size() && (str[p] == '*' || str[p] == '/')) {\n    const char op = str[p];\n    ++p;\n    int x;\n    if (!eval_factor(str, p, x)) {\n      return false;\n    }\n    if (op == '*') {\n      val *= x;\n    } else {\n      val /= x;\n    }\n  }\n  return true;\n}\n\nbool eval_expr(const string& expr, int& p, int& val)\n{\n  if (p >= expr.size()) {\n    return false;\n  }\n  if (!eval_term(expr, p, val)) {\n    return false;\n  }\n  while (p < expr.size() && (expr[p] == '+' || expr[p] == '-')) {\n    const char op = expr[p];\n    ++p;\n    int x;\n    if (!eval_term(expr, p, x)) {\n      return false;\n    }\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return true;\n}\n\nbool check(const string& expr)\n{\n  if (expr.size() == 1) {\n    return true;\n  }\n int p = 0;\n int lhs, rhs;\n if (!eval_expr(expr, p, lhs)) {\n   return false;\n }\n if (p < expr.size() && expr[p] != '=') {\n   return false;\n }\n ++p;\n if (!eval_expr(expr, p, rhs)) {\n   return false;\n }\n return p == expr.size() && lhs == rhs;\n}//\n\nbool valid(const vector<string>& grid)\n{\n  const int H = grid.size(), W = grid[0].size();\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (grid[i][j] != '#') {\n        if (j == 0 || grid[i][j-1] == '#') {\n          string expr(grid[i].begin()+j, find(grid[i].begin()+j, grid[i].end(), '#'));\n          if (!check(expr)) {\n            return false;\n          }\n        }\n        if (i == 0 || grid[i-1][j] == '#') {\n          string expr;\n          for (int k = i; k < H && grid[k][j] != '#'; k++) {\n            expr += grid[k][j];\n          }\n          if (!check(expr)) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(vector<string>& grid, const vector<pair<int,int> >& spaces, vector<char>& cards)\n{\n  sort(cards.begin(), cards.end());\n  do {\n    for (size_t i = 0; i < cards.size(); i++) {\n      grid[spaces[i].first][spaces[i].second] = cards[i];\n    }\n    if (valid(grid)) {\n      return true;\n    }\n  } while (next_permutation(cards.begin(), cards.end()));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (cin >> H >> W && H != 0) {\n    vector<string> grid(H);\n    vector<pair<int,int> > spaces;\n    for (int i = 0; i < H; i++) {\n      cin >> grid[i];\n      for (int j = 0; j < W; j++) {\n        if (grid[i][j] == '.') {\n          spaces.push_back(make_pair(i, j));\n        }\n      }\n    }\n    int N;\n    cin >> N;\n    vector<char> cards(N);\n    for (int i = 0; i < N; i++) {\n      cin >> cards[i];\n    }\n    if (solve(grid, spaces, cards)) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<bool, MAX_N> used;\narray<char, 128> letters;\narray<bool, 128> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint factor(string::const_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\tthrow \"parse error\";\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t{\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\t}\n\t\tcase '/':\n\t\t{\n\t\t\t++it;\n\t\t\tconst int tmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t{\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\t}\n\t\tcase '-':\n\t\t{\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid calc(int &x, int &y, int dx, int dy) {\n\twhile(true) {\n\t\tconst int nx = x + dx;\n\t\tconst int ny = y + dy;\n\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && puzzle[ny][nx] != '#') {\n\t\t\tx = nx;\n\t\t\ty = ny;\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_minus[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w, -1));\n\tint next = 0;\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i, g = i;\n\t\t\t\tcalc(j, s, 0, -1);\n\t\t\t\tcalc(j, g, 0, 1);\n\n\t\t\t\tif(s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\tif(idx[k][j] == -1) idx[k][j] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j, g = j;\n\t\t\t\tcalc(s, i, -1, 0);\n\t\t\t\tcalc(g, i, 1, 0);\n\n\t\t\t\tif(s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\tif(idx[i][k] == -1) idx[i][k] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used[i]) continue;\n\t\tif(is_operator[in[i]] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\t\tif(in[i] == '-' && not_minus[idx]) continue;\n\t\tif(i && !used[i - 1] && in[i] == in[i - 1]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[in[i]]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tused[i] = true;\n\t\tif(dfs(expressions, next, idx + 1)) return true;\n\t\tused[i] = false;\n\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tis_operator.fill(false);\n\tis_operator['+'] = true;\n\tis_operator['-'] = true;\n\tis_operator['*'] = true;\n\tis_operator['/'] = true;\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tused.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\t\tsort(in.begin(), in.begin() + n);\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nchar B[10][10];             // ??????????????¢\nint n;\nchar ds[10];                    // ??????????????????\n\nint BrankX[10], BrankY[10];     // ???????????§?¨?\n\n// ????????????\nconst int dx[4] = {0, 0, -1, 1};\nconst int dy[4] = {-1, 1, 0, 0};\nenum dir {up, down, lft, rgt};\n\n// ?????????????????§?¨????????´???????\nvector<int> UD_X, UD_Y;         // ???????????????????????????\nvector<int> LR_X, LR_Y;         // ???????????????????????????\n\n// dfs??§?????¨\nbool used[10];\n\n// ???????§£?????§?????¨\nint idxX;                       // ?§£???????????????X??§?¨?\nint idxY;                       // ?§£???????????????Y??§?¨?\ndir direc;                      // ?????¨?§£????????????????????? down or rgt\nconst int NG = 99999999;        // ????????£?????????????????¨?????????\n\nbool inBoard(int x, int y)\n{\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nchar Board(int x, int y)\n{\n  if (inBoard(x, y)) return B[y][x];\n  else return '#';\n}\n\n// (x,y)?????????????£???????????????¨???true\nbool isWhite(int x, int y)\n{\n  return inBoard(x, y) && (Board(x, y) != '#');\n}\n\nbool isOperator(char op)\n{\n  return (op == '+' || op == '-' ||\n          op == '*' || op == '/' ||\n          op == '=');\n}\n\nint N0()\n{\n  if (!isdigit(Board(idxX, idxY))) return NG;\n\n  string vals;\n  while (isdigit(Board(idxX, idxY)))\n  {\n    vals += Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n  }\n  if (vals[0] == '0' && vals.length() > 1) return NG;\n\n  return atoi(vals.c_str());\n}\n\nint Ex0()\n{\n  int val = N0();\n  if (val == NG) return NG;\n\n  while (Board(idxX, idxY) == '*' || Board(idxX, idxY) == '/')\n  {\n    char op = Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n\n    int b = N0();\n    if (op == '*') val *= b;\n    if (op == '/') val /= b;\n  }\n  return val;\n}\n\n// (idxX, idxY)???????§??????????????¨?????????????????????????\n// ????????¢??°?????????????????¨(idxX, idxY)?????????????£???????????????¨?????¨???\nint Ex()\n{\n  int val = Ex0();              // *??¨/??§?¨???????????????°\n  if (val == NG) return NG;\n\n  while (Board(idxX, idxY) == '+' || Board(idxX, idxY) == '-')\n  {\n    char op = Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n\n    int b = Ex();\n    if (b == NG) return NG;\n    if (op == '+') val += b;\n    if (op == '-') val -= b;\n  }\n  return val;\n}\n\n// ??¨??¨????????£????????¢????????????????????¨????????????????????£?????????????????????????????????\nbool isCorrectBoard()\n{\n  // ????????????\n  for (int i=0;i<UD_X.size();i++)\n  {\n    idxX = UD_X[i];\n    idxY = UD_Y[i];\n    direc = down;\n\n    // (idxX, idxY)???????§????????????????\n    int lhs = Ex();\n    if (lhs == NG) return false;\n\n    // ???????¬????=???????????????\n    if (inBoard(idxY, idxX) && Board(idxX, idxY) != '=') return false;\n\n    // = ?????????????????????\n    idxX += dx[down];\n    idxY += dy[down];\n    // ????????????????¨????\n    int rhs = Ex();\n    if (rhs == NG) return false;\n\n\n    if (isWhite(idxX, idxY)) return false;\n\n    if (lhs != rhs) return false;\n  }\n  // ???????????????????????¨?????£??????\n\n  // ????????????\n  for (int i=0;i<LR_X.size();i++)\n  {\n    idxX = LR_X[i];\n    idxY = LR_Y[i];\n    direc = rgt;\n\n    // (idxX, idxY)???????§????????????????\n    int lhs = Ex();\n    if (lhs == NG) return false;\n\n    // ???????¬????=???????????????\n    if (!inBoard(idxY, idxX) && Board(idxX, idxY) != '=') return false;\n\n    // = ?????????????????????\n    idxX += dx[direc];\n    idxY += dy[direc];\n\n    // ????????????????¨????\n    int rhs = Ex();\n    if (rhs == NG) return false;\n\n    if (isWhite(idxX, idxY)) return false;\n\n    if (lhs != rhs) return false;\n  }\n  // ???????????????????????¨?????£??????\n\n  return true;\n}\n\nvoid print_Board()\n{\n  for (int i=0;i<H;i++)\n  {\n    for (int j=0;j<W;j++)\n      cout << B[i][j];\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid print_Brank()\n{\n  for (int i=0;i<n;i++)\n  {\n    printf(\"(%d, %d) \", BrankX[i], BrankY[i]);\n  }\n  printf(\"\\n\");\n}\n\nvoid print_Start()\n{\n  for (int i=0;i<UD_X.size();i++)\n  {\n    printf(\"(%d, %d) \", UD_X[i], UD_Y[i]);\n  }\n  printf(\"\\n\");\n  for (int i=0;i<LR_X.size();i++)\n  {\n    printf(\"(%d, %d) \", LR_X[i], LR_Y[i]);\n  }\n  printf(\"\\n\");\n}\n\n// 1???b-1????????????????????????????????\\??£???????????¨?????????\n// ??????????????¢?´¢????????£???????????¢????????¨????????°true?????????\nbool dfs(int b)\n{\n  if (b == n)\n  {\n    // ??¨??¨????????£???????????????\n    // ?????¢?????£??????????????????????¢??????????\n    // ??£???????????¢??????true????????????????????????false?????????\n    //print_Board();\n    return isCorrectBoard();\n  }\n  else\n  {\n    int x = BrankX[b], y = BrankY[b];\n    // ??°????????\\???????????????????????????????????????\n    bool digitp = false;\n    // ??¨??????????¨???????????????°??°????????\\???\n    for (int i=0;i<4;i++)\n    {\n      if (inBoard(x+dx[i], y+dy[i]) && isOperator(Board(x+dx[i], y+dy[i])))\n      {\n        digitp = true;\n        break;\n      }\n    }\n    // ?????????????????????????????????????????°??°????????\\???\n    if (isWhite(x+dx[up], y+dy[up]) && !isWhite(x+dx[down], y+dy[down])) digitp=true;\n    if (isWhite(x+dx[down], y+dy[down]) && !isWhite(x+dx[up], y+dy[up])) digitp=true;\n    if (isWhite(x+dx[lft], y+dy[lft]) && !isWhite(x+dx[rgt], y+dy[rgt])) digitp=true;\n    if (isWhite(x+dx[rgt], y+dy[rgt]) && !isWhite(x+dx[lft], y+dy[lft])) digitp=true;\n\n    // (x,y)?????????????????\\????????¢?´¢????¶???????\n    for (int i=0;i<n;i++)\n    {\n      if (used[i]) continue;\n      if (digitp && isOperator(ds[i])) continue;\n\n      used[i] = true;\n      B[y][x] = ds[i];\n      if (dfs(b+1)) return true;\n      used[i] = false;\n    }\n    return false;\n  }\n}\n\nint main()\n{\n  while (cin >> H >> W)\n  {\n    if (H == 0) return 0;\n    for (int i=0;i<H;i++) cin >> B[i];\n    cin >> n;\n    for (int i=0;i<n;i++) cin >> ds[i];\n\n    // ????????¨????????§?¨????????????£?????????\n    int k = 0;\n    for (int y=0;y<H;y++)\n      for (int x=0;x<W;x++)\n        if (Board(x, y) == '.') { BrankX[k] = x; BrankY[k] = y; k++; }\n\n    //print_Brank();\n\n    // ?????????????????§??????\n    UD_X.clear(); UD_Y.clear();\n    LR_X.clear(); LR_Y.clear();\n    // ???????????????????????????????????§??????\n    for (int y=0;y<H;y++)\n      for (int x=0;x<W;x++)\n      {\n        if (isWhite(x, y) &&\n            !isWhite(x + dx[up], y + dy[up]) &&\n            isWhite(x + dx[down], y + dy[down]))\n        {\n          UD_X.push_back(x);\n          UD_Y.push_back(y);\n        }\n      }\n    // ???????????????????????????????????§??????\n    for (int i=0;i<H;i++)\n      for (int j=0;j<W;j++)\n      {\n        if (isWhite(j, i) &&\n            !isWhite(j + dx[lft], i + dy[lft]) &&\n            isWhite(j + dx[rgt], i + dy[rgt]))\n        {\n          LR_X.push_back(j);\n          LR_Y.push_back(i);\n        }\n      }\n\n    //print_Start();\n\n    // DFS??§??¨??¢?´¢\n    for (int i=0;i<n;i++) used[i]=false;\n\n    if (dfs(0)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n \nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n \nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n   \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n   \n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n \nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n \n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\npair<int,int> BLANKS[NMAX];\n \nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H; \n}\n \nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n \nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n \nbool is_operand(char c) { // {{{\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n} // }}}\n \nbool is_illegal_operand() { // {{{\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n \n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n \nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false;\n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n \n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false;\n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n} // }}}\n\nbool solve() { // {{{\n  sort(BLOCK, BLOCK + n);\n  do {\n    try {\n      for (int i = 0; i < n; i++) {\n        TABLE[BLANKS[i].first][BLANKS[i].second] = BLOCK[i];\n        if (VSOLVABLE[i] and incorrect\n        }\n      }\n    } catch (int ex) {\n      continue;\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n  return false;\n} // }}}\n \nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n} // }}}\n \nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n \n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n \n    int idx = 0;\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n      if (not PRINTED[x][y]) {\n        BLANKS[idx] = make_pair(x, y);\n        idx++;\n      }\n    }\n\n \n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) {\n                end_parse = 1;\n                return 1e7;\n            }\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0){\n                end_parse = true;\n                return 1e7;\n            }\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    end_parse = 0;\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15]){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nbool check(char m[15][15]){\n    vector<int> s;\n    bool f;\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++){\n                    if(m[k][j] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++){\n                    str.push_back(m[i][k]);\n                    if(m[i][k] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h){\n                rep(j,w){\n                    scanf(\"%c\",&m[i + 1][j + 1]);\n                    if(m[i + 1][j + 1] == '.'){\n                        y[k] = i + 1;\n                        x[k] = j + 1;\n                        k++;\n                    }\n                }\n               scanf(\"%*c\");\n            }\n        }\n\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n        if(not check(m)){\n            cout << \"NO\" << endl;\n            continue;\n        }\n\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\nint calc(string s)\n{\n  istringstream iss( s );\n  vector<int> num;\n  vector<char> op;\n  int n;\n  char c;\n  while( iss >> n ){    \n    num.push_back( n );\n    if( iss >> c )op.push_back( c );\n    else break;\n  }\n  \n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    else assert( false && \"invalid op\" );\n    num.erase( num.begin() + i + 1);\n    op.erase( op.begin() + i );\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\nbool check_syntax(string s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\n\nstruct F{\n  vector< pair<int, int> > v;\n  string build(void){\n    string s;\n    for(int i=0; i<v.size(); ++i){\n      s += g[ v[i].first ][ v[i].second ];\n    }\n  }\n};\n\nbool solve(char p[], int size, int h, int w)\n{\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  static pair<int, int> emp[10 * 10 + 1];\n  int emp_size = 0;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp[emp_size++] = make_pair(i, j);\n    }\n  }\n\n  if( emp_size != size )return false;\n\n  static char puz[H][W];\n  static F v[1000];\n  int v_size = 0;\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( f.build() ) )return false;\n\t}\n      }\n    }\n  }  \n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( f.build() ) )return false;\n\t}\n      }\n    }\n  }\n\n  sort( p, p + size );\n  do{\n\n    for(int i=0; i<emp_size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    bool flg = true;\n    for(int i=0; i<v_size && flg; ++i){\n      string s;\n      for(int j=0; j<v[i].v.size(); ++j){\n\tint a = v[i].v[j].first;\n\tint b = v[i].v[j].second;\n\ts += g[a][b];\n      }\n      if( !check_syntax(s) ) flg = false;\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( scanf(\"%d%d\\n\", &h, &w) != EOF && (h | w) ){\n\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tscanf(\"%c\", &g[i][j]);\n      }\n      scanf(\"\\n\");\n    }\n\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n\n    puts( solve(m, n, h, w) ? \"Yes\" : \"No\" );\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) ((l)<=(x) && (x)<(r))\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1])) ){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint parse(int l, int r, const string &s){\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=l;i<r;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  int a = parse(0,p,s);\n  int b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n\n    cin >> n;\n    rep(i,n)cin >> c[i];\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\n#define INF 999999999\n\nint h, w, n;\nchar t[12][12];\nchar p[12];\n\nvector<int> blankX;\nvector<int> blankY;\n\nbool used[12];\nbool isOperator[128];\n\n//式の開始地点でないなら, -1が入る\n//式の開始地点なら, どの座標の空白が埋まれば式判定できるか\n//空白が埋まらなくても式判定できるなら, -2が入る\nint gx0[12][12], gy0[12][12];\nint gx1[12][12], gy1[12][12];\n\n//構文解析用変数\nint idxX;\nint idxY;\nint dir;\n\n//右 下 左 上\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\n//w*hの範囲内であるならばtrue\nbool inBoard(int x, int y){\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\n//#でないマス目であるならばtrue\nbool isWhite(int x, int y){\n  if(!inBoard(x, y)) return false;\n  return t[y][x] != '#';\n}\n\n//演算子が含まれるマスならばtrue\nbool containsOperator(int x, int y){\n  if(!inBoard(x, y)) return false;\n  return isOperator[t[y][x]];\n}\n\nint N0(){\n  if(!isdigit(t[idxY][idxX])){\n    return INF;\n  }\n\n  string valStr;\n\n  while(inBoard(idxX, idxY) && isdigit(t[idxY][idxX])){\n    valStr += t[idxY][idxX];\n    idxX += dx[dir];\n    idxY += dy[dir];\n  }\n\n  if(valStr.length() == 1 || valStr[0] != '0'){\n    return atoi(valStr.c_str());\n  }\n  return INF;\n}\n\nint Term(){\n  int lv = N0();\n  if(lv == INF) return INF;\n\n  while(inBoard(idxX, idxY) && (t[idxY][idxX] == '*' || t[idxY][idxX] == '/')){\n    char op = t[idxY][idxX];\n\n    idxX += dx[dir];\n    idxY += dy[dir];\n\n    int rv = N0();\n    if(rv == INF) return INF;\n\n    if(op == '*'){\n      lv *= rv;\n    }\n    else{\n      if(rv == 0 || lv % rv != 0) return INF;\n      lv /= rv;\n    }\n  }\n\n  return lv;\n}\n\nint Ex(){\n  int lv = Term();\n  if(lv == INF) return INF;\n\n  while(inBoard(idxX, idxY) && (t[idxY][idxX] == '+' || t[idxY][idxX] == '-')){\n    char op = t[idxY][idxX];\n\n    idxX += dx[dir];\n    idxY += dy[dir];\n\n    int rv = Term();\n    if(rv == INF) return INF;\n\n    if(op == '+') lv += rv;\n    else          lv -= rv;\n  }\n\n  return lv;\n}\n\nbool isCorrectEq(){\n  //左辺\n  int lv = Ex();\n  if(lv == INF) return false;\n\n  //イコールがあるかどうか\n  if(!inBoard(idxX, idxY) || t[idxY][idxX] != '=') return false;\n  idxX += dx[dir];\n  idxY += dy[dir];\n\n  //右辺\n  int rv = Ex();\n  if(rv == INF) return false;\n\n  if(isWhite(idxX, idxY)){\n    return false;\n  }\n\n  return lv == rv;\n}\n\nbool isCorrectBoard(int x, int y){\n  /*\n  cout<<x<<\",\"<<y<<endl;\n  for(int i = 0; i < h; i++){\n    cout << t[i] << endl;\n  }\n  cout<<\"--\\n\";\n  */\n\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(gx0[i][j] == x && gy0[i][j] == y){\n        idxX = j;\n        idxY = i;\n        dir = 0;\n\n        if(!isCorrectEq()) return false;\n      }\n      if(gx1[i][j] == x && gy1[i][j] == y){\n        idxX = j;\n        idxY = i;\n        dir = 1;\n\n        if(!isCorrectEq()) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nbool dfs(int blankIdx){\n  if(blankIdx == n){\n    return true;\n  }\n\n  int x = blankX[blankIdx];\n  int y = blankY[blankIdx];\n  bool digitFlg = false;\n\n  //必ず数字を入れなくてはいけないマスであるかチェック\n  for(int i = 0; i < 4; i++){\n    if(containsOperator(x + dx[i], y + dy[i])){\n      digitFlg = true;\n      break;\n    }\n  }\n  if(isWhite(x + dx[0], y + dy[0]) + isWhite(x + dx[2], y + dy[2]) == 1){\n    digitFlg = true;\n  }\n  if(isWhite(x + dx[1], y + dy[1]) + isWhite(x + dx[3], y + dy[3]) == 1){\n    digitFlg = true;\n  }\n\n  //ピースを当てはめる\n  for(int i = 0; i < n; i++){\n    if(used[i]) continue;\n    if(digitFlg && isOperator[p[i]]) continue;\n\n    used[i] = true;\n    t[y][x] = p[i];\n\n    if(isCorrectBoard(x, y) && dfs(blankIdx + 1)) return true;\n\n    used[i] = false;\n  }\n\n  return false;\n}\n\nint main(){\n  isOperator['+'] = true;\n  isOperator['-'] = true;\n  isOperator['*'] = true;\n  isOperator['/'] = true;\n  isOperator['='] = true;\n\n  while(cin >> h >> w, h || w){\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n    }\n\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      cin >> p[i];\n    }\n\n    blankX.clear();\n    blankY.clear();\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(t[i][j] != '.') continue;\n        blankX.push_back(j);\n        blankY.push_back(i);\n      }\n    }\n\n    memset(gx0, -1, sizeof(gx0));\n    memset(gy0, -1, sizeof(gy0));\n    memset(gx1, -1, sizeof(gx1));\n    memset(gy1, -1, sizeof(gy1));\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(t[i][j] == '#') continue;\n\n        if(!isWhite(j + 1 * dx[2], i + 1 * dy[2]) &&\n            isWhite(j + 1 * dx[0], i + 1 * dy[0]) &&\n            isWhite(j + 2 * dx[0], i + 2 * dy[0])){\n          int x = j;\n          int y = i;\n\n          gx0[i][j] = -2;\n          gy0[i][j] = -2;\n\n          while(inBoard(x, y) && isWhite(x, y)){\n            if(t[y][x] == '.'){\n              gx0[i][j] = x;\n              gy0[i][j] = y;\n            }\n            x += dx[0];\n            y += dy[0];\n          }\n        }\n        if(!isWhite(j + 1 * dx[3], i + 1 * dy[3]) &&\n            isWhite(j + 1 * dx[1], i + 1 * dy[1]) &&\n            isWhite(j + 2 * dx[1], i + 2 * dy[1])){\n          int x = j;\n          int y = i;\n\n          gx1[i][j] = -2;\n          gy1[i][j] = -2;\n\n          while(inBoard(x, y) && isWhite(x, y)){\n            if(t[y][x] == '.'){\n              gx1[i][j] = x;\n              gy1[i][j] = y;\n            }\n            x += dx[1];\n            y += dy[1];\n          }\n        }\n      }\n    }\n\n    bool flg = isCorrectBoard(-2, -2);\n\n    if(!flg){\n      cout << \"No\\n\";\n      continue;\n    }\n\n    memset(used, 0, sizeof(used));\n    cout << (dfs(0) ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false; \n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (a % b != 0 || b == 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (num != -1) {\n\t\t\t\t\tstack_num.push(num);\n\t\t\t\t\tnum = -1;\n\t\t\t\t\twhile (stack_op.top() == '*' || stack_op.top() == '/') {\n\t\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nvoid solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) flag &= eq.evaluate(s_map);\n\t\tif (flag) {\n\t\t\tputs(\"Yes\");\n\t\t\treturn;\n\t\t}\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\tputs(\"No\");\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  \n  void init(){ pos=0;len=s.size();  }\n\n  int head2Num(){\n    int res=0;\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      if(ch=='/')res/=num;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    return res;\n  }\n};\n\nint H,W,N,M;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w;\n\nbool solve();\nbool check();\nbool compute();\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++){\n    v=w[i];\n    if(compute())return true;\n  }\n  return false;\n}\n\nbool compute(){\n  for(int i=0;i<(int)v.size();i++)\n      if('A'<=v[i]&&v[i]<='Z')v[i]=u[v[i]-'A'];\n  string a=\"\",b=\"\";\n  bool flg=false;\n  b.push_back(v[0]);\n  for(int i=1;i<(int)v.size();i++){\n      if(!isNum(v[i-1])&&!isNum(v[i]))return false;\n      if(v[i]=='=')flg=true;\n      else if(flg)a.push_back(v[i]);\n      else b.push_back(v[i]);\n  }\n  if(!isNum(v[0])||!isNum(v[v.size()-1]))return false;\n  \n  calcStr x,y;\n  x.s=a;\n  x.init();\n  y.s=b;\n  y.init();\n  \n  return (x.getAns()==y.getAns());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int INF = 1<<24;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  //  int st = pos;\n  //int l = 0;\n  int res = 0;\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  if(pos+1 < s.size() && s[pos] == '0' && isdigit(s[pos+1])) {\n    //if(s[st] == '0') {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  //string num = \"\";\n  while(pos < s.size() && isdigit(s[pos])) {\n    res = res*10+s[pos++]-'0';\n  }\n  return res;\n  //  return atoi(num.c_str());\n  //return atoi(s.substr(st, l).c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int value = getNum(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      value = getNum(s, pos);\n      if(value == INF) return INF;\n      x *= value;\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == INF) return INF;\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn INF;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int value = term(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x += value;\n    } else if(s[pos] == '-') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x -= value;\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n\n      }\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n    sort(T, T+N);\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <time.h>\nclock_t start, en;\n\nusing namespace std;\n// 4:37\n// 4:40 coding\n\nvector< pair<int,int> > pos;\nvector<string> expr;\n\nchar nowtable[128];\nstring s;\nint p;\nint A();\nint B();\nint C();\nint D();\nint calc(string _str){\n\ttry{\n\t\tp = 0;\n\t\ts = _str;\n\t\ts += \"~\";\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( s[i] >= 'A' && s[i] <= 'Z' ){\n\t\t\t\tif( nowtable[s[i]] == 0 ) return 2;\n\t\t\t\ts[i] = nowtable[s[i]];\n\t\t\t}\n\t\t}\n\t\tint res = A();\n\t\t\n\t\tif( s[p] != '~' ) throw \"not end\";\n\t\treturn res;\n\t}catch(const char *msg){\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\nint A(){\n\t\n\tint x = B();\n\tif( s[p] == '=' ){\n\t\tp++;\n\t\tint y = B();\n\t\treturn x == y;\n\t}else{\n\t\tthrow \"A\";\n\t}\n}\nint B(){\n\tint x = C();\n\twhile( s[p] == '+' || s[p] == '-' ){\n\t\tif( s[p] == '+'){\n\t\t\tp++;\n\t\t\tx += C();\n\t\t}else{\n\t\t\tp++;\n\t\t\tx -= C();\n\t\t}\n\t}\n\treturn x;\n}\nint C(){\n\tint x = D();\n\twhile( s[p] == '*' || s[p] == '/' ){\n\t\tif( s[p] == '*'){\n\t\t\tp++;\n\t\t\tx *= D();\n\t\t}else{\n\t\t\tp++;\n\t\t\tint r = D();\n\t\t\tif(r==0) throw \"zero\";\n\t\t\tif(x%r) throw \"modulo\";\n\t\t\tx /= r;\n\t\t}\n\t}\n\treturn x;\n}\nint D(){\n\t\n\tint x = 0;\n\n\tif( !(s[p]>='1'&&s[p]<='9') ) throw \"wrong number\";\n\twhile( s[p]>='1'&&s[p]<='9'){\n\t\tx = x*10+s[p++]-'0';\n\t}\n\t\n\treturn x;\n}\n\nchar t[12][12];\nvector<char> use;\n\nint used[10];\nvector<string> hoge;\nint check(){\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint r = calc(hoge[i]);\n\t\tif( r == 2 ) continue;\n\t\tif( !r ) return 0;\n\t}\n\treturn 1;\n}\nint N;\nint dfs(){\n\ten=clock();\n\tif( (double)(en - start) / CLOCKS_PER_SEC > 0.1 ) return 0;\n\tif( !check() ) return 0;\n\tvector< pair<int,int> > v;\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint c = 0;\n\t\tfor(int j = 0 ; j < hoge[i].size() ; j++){\n\t\t\tif( nowtable[hoge[i][j]] == 0 ){\n\t\t\t\t\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif(c){\n\t\t\tv.push_back(make_pair(c,i));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tif( v.size() == 0 ) return 1;\n\t\n\tint idx = v[0].second;\n\tfor(int j = 0 ; j < hoge[idx].size() ; j++){\n\t\tif( nowtable[hoge[idx][j]] == 0 ){\n\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\tif( !used[k] ){\n\t\t\t\t\tnowtable[hoge[idx][j]] = use[k];\n\t\t\t\t\tused[k] = true;\n\t\t\t\t\tif( dfs() ) return true;\n\t\t\t\t\tused[k] = false;\n\t\t\t\t\tnowtable[hoge[idx][j]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\n\tint H,W;\n\twhile( cin >> H >> W && H){\n\t\tstart=clock();\n\t\tfor(int i = 0 ; i < 128 ; i++) nowtable[i] = -1;\n\t\tfor(int i = 0 ; i < 10 ; i++) used[i] = 0;\n\t\tfor(int i = 'A' ; i <= 'Z' ; i++) nowtable[i] = 0;\n\t\tuse.clear();\n\t\thoge.clear();\n\t\tfor(int i = 0 ; i < 12 ; i++)\n\t\t\tfor(int j = 0 ; j < 12 ; j++)\n\t\t\t\tt[i][j] = '#';\n\t\n\t\tchar tmpAlpha = 'A';\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> t[i+1][j+1];\n\t\t\t\tif( t[i+1][j+1] == '.' ){\n\t\t\t\t\tt[i+1][j+1] = tmpAlpha++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tchar c; cin >> c;\n\t\t\tuse.push_back(c);\n\t\t}\n\t\tint ans = 0;\n\t\tvector<string> id;\n\t\t\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( t[i][j-1] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = j;\n\t\t\t\t\twhile( t[i][k] != '#' ){\n\t\t\t\t\t\tstr += t[i][k++];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( t[i-1][j] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = i;\n\t\t\t\t\twhile( t[k][j] != '#' ){\n\t\t\t\t\t\tstr += t[k++][j];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (dfs()?\"Yes\":\"No\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\ntypedef pair<int,int> Error;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nbool includestr(string lhs, string rhs) {\n  string::iterator lit = lhs.begin();\n  string::iterator rit = rhs.begin();\n  while (lit != lhs.end()) {\n    if (*lit != *rit) { return false; }\n  }\n  return true;\n}\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw Error(p, NotEquationExc); }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw Error(p, NotEquationExc); }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw Error(p, NegIntExc); }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw Error(p, OutOfIntExc); \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw Error(p, LackNumExc); }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw Error(p, NotNumExc); }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and includestr(hbadeq, geth(hbadx, hbady))) \n    return false;\n  if (vbadflag and includestr(vbadeq, geth(vbadx, vbady))) \n    return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (Error ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq.substr(0, ex.first);\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        return false;\n      }\n    } catch(Error ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq.substr(0, ex.first);\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\ntypedef long long int lli;\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\ninline\nint calc(const string &s)\n{\n  istringstream iss( s );\n\n  static int num[11];\n  static char op[11];\n  int num_size = 0;\n  int op_size = 0;\n\n  static int n;\n  static char c;\n\n  while( iss >> n ){    \n    num[ num_size++ ] = n;\n    if( iss >> c )op[ op_size++ ] = c;\n    else break;\n  }\n  \n  for(int i=0; i<op_size; ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    num[i+1] = 0;\n    op[i] = '+';\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op_size; ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\ninline\nbool check_syntax(const string &s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\n\nstruct F{\n  vector< pair<int, int> > v;\n  F(){ v.clear(); }\n};\n\ninline\nstring build(F f)\n{\n  string s;\n  for(int i=0; i<f.v.size(); ++i){\n    s += g[ f.v[i].first ][ f.v[i].second ];\n  }\n  return s;\n}\n\ninline\nlli cpy(char c)\n{\n  if( isdigit(c) ) return c - '0';\n  if( c == '+' ) return 10;\n  if( c == '*' ) return 11;\n  if( c == '/' ) return 12;\n  if( c == '-' ) return 13;\n  return -(1LL << 60);\n}\n\nset<lli> valid, invalid;\nbool solve(char p[], int size, int h, int w)\n{\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  static pair<int, int> emp[10 * 10 + 1];\n  int emp_size = 0;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp[emp_size++] = make_pair(i, j);\n    }\n  }\n\n  if( emp_size != size )return false;\n\n  static char puz[H][W];\n  static F v[1000];  \n\n  fill( v, v + 1000, F() );\n\n  int v_size = 0;\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }  \n\n  if( v_size == 0 )return true;\n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }\n\n  sort( p, p + size );\n  do{\n\n    for(int i=0; i<emp_size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    bool flg = true;\n    for(int i=0; i<v_size && flg; ++i){\n      string s;\n      lli h = 0;\n      for(int j=0; j<v[i].v.size(); ++j){\n\tint a = v[i].v[j].first;\n\tint b = v[i].v[j].second;\n\ts += g[a][b];\n\th = (h + cpy( g[a][b] )) * 19LL;\n\th %= 1LL << 61;\n      }\n      if( invalid.count( h ) ) flg = false;\n      else if( valid.count( h ) ) flg = true;\n      else if( !check_syntax(s) ){\n\tinvalid.insert( h );\n\tflg = false;\n      }\n      else valid.insert( h );\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( scanf(\"%d%d\\n\", &h, &w) != EOF && (h | w) ){\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tscanf(\"%c\", &g[i][j]);\n      }\n      scanf(\"\\n\");\n    }\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n    puts( solve(m, n, h, w) ? \"Yes\" : \"No\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e15;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nll parse(int L, int R, const string &s){\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=L;i<R;i++)res = res*10LL + (ll)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  assert(p!=0 && p+1!=(int)s.size());\n  ll a = parse(0,p,s);\n  ll b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (cur % tmp > 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq[0] == '-') return false;\n    if (!isdigit(eq[0])) return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') return false;\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\n#define INF 999999999\n\nint h, w, n;\nchar t[12][12];\nchar p[12];\n\nvector<int> blankX;\nvector<int> blankY;\n\nbool used[12];\nbool isOperator[128];\n\n//右 下 左 上\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool inBoard(int x, int y){\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\n\n//#でないマス目である場合true\nbool isWhite(int x, int y){\n  if(!inBoard(x, y)) return false;\n  return t[y][x] != '#';\n}\n\n//演算子が含まれるマスならばtrue\nbool containsOperator(int x, int y){\n  if(!inBoard(x, y)) return false;\n  return isOperator[t[y][x]];\n}\n\n//構文解析用変数\nint idxX;\nint idxY;\nint dir;\n\nint N0(){\n  if(!isdigit(t[idxY][idxX])){\n    return INF;\n  }\n\n  string valStr;\n\n  while(inBoard(idxX, idxY) && isdigit(t[idxY][idxX])){\n    valStr += t[idxY][idxX];\n    idxX += dx[dir];\n    idxY += dy[dir];\n  }\n\n  if(valStr.length() == 1 || valStr[0] != '0'){\n    return atoi(valStr.c_str());\n  }\n  return INF;\n}\n\nint Term(){\n  int lv = N0();\n  if(lv == INF) return INF;\n\n  while(inBoard(idxX, idxY) && (t[idxY][idxX] == '*' || t[idxY][idxX] == '/')){\n    char op = t[idxY][idxX];\n\n    idxX += dx[dir];\n    idxY += dy[dir];\n\n    int rv = N0();\n    if(rv == INF) return INF;\n\n    if(op == '*'){\n      lv *= rv;\n    }\n    else{\n      if(rv == 0 || lv % rv != 0){\n        return INF;\n      }\n\n      lv /= rv;\n    }\n  }\n\n  return lv;\n}\n\nint Ex(){\n  int lv = Term();\n  if(lv == INF) return INF;\n\n  while(inBoard(idxX, idxY) && (t[idxY][idxX] == '+' || t[idxY][idxX] == '-')){\n    char op = t[idxY][idxX];\n\n    idxX += dx[dir];\n    idxY += dy[dir];\n\n    int rv = Term();\n    if(rv == INF) return INF;\n\n    if(op == '+') lv += rv;\n    else          lv -= rv;\n  }\n\n  return lv;\n}\n\nbool isCorrectEq(){\n  //左辺\n  int lv = Ex();\n  if(lv == INF) return false;\n\n  //イコールがあるかどうか\n  if(!inBoard(idxX, idxY) || t[idxY][idxX] != '=') return false;\n  idxX += dx[dir];\n  idxY += dy[dir];\n\n  //右辺\n  int rv = Ex();\n  if(rv == INF) return false;\n\n  return lv == rv;\n}\n\nbool isCorrectBoard(){\n  /*\n  for(int i = 0; i < h; i++){\n    cout<<t[i]<<endl;\n  }\n  cout<<\"--\\n\";\n  */\n\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(t[i][j] == '#') continue;\n\n      if( !isWhite(i + 1 * dy[3], j + 1 * dx[3]) &&\n           isWhite(i + 1 * dy[1], j + 1 * dx[1]) &&\n           isWhite(i + 2 * dy[1], j + 2 * dx[1]) ){\n\n        idxX = j;\n        idxY = i;\n        dir = 1;\n\n        if(!isCorrectEq()) return false;\n      }\n      if( !isWhite(i + 1 * dy[2], j + 1 * dx[2]) &&\n           isWhite(i + 1 * dy[0], j + 1 * dx[0]) &&\n           isWhite(i + 2 * dy[0], j + 2 * dx[0]) ){\n\n        idxX = j;\n        idxY = i;\n        dir = 0;\n\n        if(!isCorrectEq()) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nbool dfs(int blankIdx){\n  if(blankIdx == n){\n    return isCorrectBoard();\n  }\n\n  int x = blankX[blankIdx];\n  int y = blankY[blankIdx];\n  bool digitFlg = false;\n\n  //必ず数字を入れなくてはいけないマスであるかチェック\n  for(int i = 0; i < 4; i++){\n    if(containsOperator(x + dx[i], y + dy[i])){\n      digitFlg = true;\n      break;\n    }\n  }\n  if(isWhite(x + dx[0], y + dy[0]) + isWhite(x + dx[2], y + dy[2]) == 1){\n    digitFlg = true;\n  }\n  if(isWhite(x + dx[1], y + dy[1]) + isWhite(x + dx[3], y + dy[3]) == 1){\n    digitFlg = true;\n  }\n\n  //ピースを当てはめる\n  for(int i = 0; i < n; i++){\n    if(used[i]) continue;\n    if(digitFlg && isOperator[p[i]]) continue;\n\n    used[i] = true;\n    t[y][x] = p[i];\n\n    if(dfs(blankIdx + 1)) return true;\n\n    used[i] = false;\n  }\n\n  return false;\n}\n\nint main(){\n  isOperator['+'] = true;\n  isOperator['-'] = true;\n  isOperator['*'] = true;\n  isOperator['/'] = true;\n  isOperator['='] = true;\n\n  while(cin >> h >> w, h || w){\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n    }\n\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      cin >> p[i];\n    }\n\n    blankX.clear();\n    blankY.clear();\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(t[i][j] != '.') continue;\n        blankX.push_back(j);\n        blankY.push_back(i);\n      }\n    }\n\n    memset(used, 0, sizeof(used));\n    cout << (dfs(0) ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint eval_fact(const string &exp, int &pos) {\n    int val = 0;\n    if(!isdigit(exp.at(pos))) throw \"invalid factor\";\n    while(pos < exp.size() && isdigit(exp.at(pos))) {\n        val *= 10;\n        val += exp.at(pos++)-'0';\n    }\n    return val;\n}\n\nint eval_term(const string &exp, int &pos) {\n    int lhs = eval_fact(exp, pos);\n    while(pos < exp.size()) {\n        char op = exp.at(pos++);\n        if(op == '*') {\n            int rhs = eval_fact(exp, pos);\n            lhs *= rhs;\n        }\n        else if(op == '/') {\n            int rhs = eval_fact(exp, pos);\n            if(rhs == 0 || lhs % rhs != 0) throw \"invalid division\";\n            lhs /= rhs;\n        }\n        else {\n            pos--;\n            break;\n        }\n    }\n    return lhs;\n}\n\nint eval_expression(const string &exp,int &pos) {\n    int lhs = eval_term(exp, pos);\n    while(pos < exp.size()) {\n        char op = exp.at(pos++);\n        if(op == '+') {\n            int rhs = eval_term(exp, pos);\n            lhs += rhs;\n        }\n        else if(op == '-') {\n            int rhs = eval_term(exp, pos);\n            lhs -= rhs;\n        }\n        else {\n            pos--;\n            break;\n        }\n    }\n    return lhs;\n}\n\nint eval(const string &exp) {\n    int pos = 0;\n    if(exp.size() == 0) return 0;\n    int val = eval_expression(exp, pos);\n    if(pos != exp.size()) throw \"invalid expression\";\n    return val;\n}\n\nbool check(const vector<string> &v) {\n    bool ok = true;\n    int H = v.size();\n    for(int r = 0; r < H; ++r) {\n        int start = 0;\n        while(start < v[r].size()) {\n            int bl = v[r].find('#', start);\n            if(bl == string::npos) bl = v[r].size();\n            string eq = v[r].substr(start, bl-start);\n            int epos = eq.find('=');\n            if(eq.size() > 1 && epos != string::npos) {\n                string lhs = eq.substr(0, epos), rhs = eq.substr(epos+1);\n                //cout << eq << '$' << lhs << ' ' << rhs << endl;\n                try {\n                    if(eval(lhs) != eval(rhs)) {\n                        return false;\n                        break;\n                    }\n                } catch (const char *str) {\n                    return false;\n                    break;\n                }\n            }\n            start = bl+1;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while(true) {\n        int H, W;\n        cin >> H >> W;\n        if(!H && !W) break;\n\n        vector<string> field(H);\n        vector<pair<int,int> > space;\n        for(int i = 0; i < H; ++i) {\n            cin >> field[i];\n            field[i] += '#';\n            for(int j = 0; j < W; ++j)\n                if(field[i][j] == '.') space.push_back(make_pair(i, j));\n        }\n\n        int N;\n        cin >> N;\n        vector<char> piece(N);\n        for(int i = 0; i < N; ++i) cin >> piece[i];\n\n        sort(piece.begin(), piece.end());\n        bool hasans = false;\n        do {\n            vector<string> tmp = field;\n            for(int i = 0; i < N; ++i) {\n                pair<int,int> s = space[i];\n                tmp[s.first][s.second] = piece[i];\n            }\n            if(!check(tmp)) continue;\n\n            /*\n            vector<string> tmpt(W);\n            for(int r = 0; r < H; ++r) {\n                for(int c = 0; c < W; ++c) {\n                    tmpt[c] += tmp[r][c];\n                }\n            }\n            for(int i = 0; i < tmpt.size(); ++i) tmpt[i] += '#';\n\n            if(!check(tmpt)) continue;\n            */\n\n            hasans = true;\n            break;\n        } while(next_permutation(piece.begin(), piece.end()));\n        cout << (hasans?\"Yes\":\"No\") << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// 4:37\n// 4:40 coding\n\nvector< pair<int,int> > pos;\nvector<string> expr;\n\nchar nowtable[128];\nstring s;\nint p;\nint A();\nint B();\nint C();\nint D();\nint calc(string _str){\n\ttry{\n\t\tp = 0;\n\t\ts = _str;\n\t\ts += \"~\";\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( s[i] >= 'A' && s[i] <= 'Z' ){\n\t\t\t\tif( nowtable[s[i]] == 0 ) return 2;\n\t\t\t\ts[i] = nowtable[s[i]];\n\t\t\t}\n\t\t}\n\t\tint res = A();\n\t\tif( s[p] != '~' ) throw \"not end\";\n\t\treturn res;\n\t}catch(const char *msg){\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\nint A(){\n\t\n\tint x = B();\n\tif( s[p] == '=' ){\n\t\tp++;\n\t\tint y = B();\n\t\treturn x == y;\n\t}else{\n\t\tthrow \"A\";\n\t}\n}\nint B(){\n\tint x = C();\n\twhile( s[p] == '+' || s[p] == '-' ){\n\t\tif( s[p] == '+'){\n\t\t\tp++;\n\t\t\tx += C();\n\t\t}else{\n\t\t\tp++;\n\t\t\tx -= C();\n\t\t}\n\t}\n\treturn x;\n}\nint C(){\n\tint x = D();\n\twhile( s[p] == '*' || s[p] == '/' ){\n\t\tif( s[p] == '*'){\n\t\t\tp++;\n\t\t\tx *= D();\n\t\t}else{\n\t\t\tp++;\n\t\t\tint r = D();\n\t\t\tif(r==0) throw \"zero\";\n\t\t\tif(x%r) throw \"modulo\";\n\t\t\tx /= r;\n\t\t}\n\t}\n\treturn x;\n}\nint D(){\n\t\n\tint x = 0;\n\n\tif( !(s[p]>='1'&&s[p]<='9') ) throw \"wrong number\";\n\twhile( s[p]>='1'&&s[p]<='9'){\n\t\tx = x*10+s[p++]-'0';\n\t}\n\t\n\treturn x;\n}\n\nchar t[12][12];\nvector<char> use;\n\nint used[10];\nvector<string> hoge;\nint check(){\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint r = calc(hoge[i]);\n\t\tif( r == 2 ) continue;\n\t\tif( !r ) return 0;\n\t}\n\treturn 1;\n}\nint N;\nint dfs(){\n\tif( !check() ) return 0;\n\tvector< pair<int,int> > v;\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint c = 0;\n\t\tfor(int j = 0 ; j < hoge[i].size() ; j++){\n\t\t\tif( nowtable[hoge[i][j]] == 0 ){\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif(c){\n\t\t\tv.push_back(make_pair(c,i));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tif( v.size() == 0 ) return 1;\n\t\n\tint idx = v[0].second;\n\tfor(int j = 0 ; j < hoge[idx].size() ; j++){\n\t\tif( nowtable[hoge[idx][j]] == 0 ){\n\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\tif( !used[k] ){\n\t\t\t\t\tnowtable[hoge[idx][j]] = use[k];\n\t\t\t\t\tused[k] = true;\n\t\t\t\t\tif( dfs() ) return true;\n\t\t\t\t\tused[k] = false;\n\t\t\t\t\tnowtable[hoge[idx][j]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\t\n\tint H,W;\n\twhile( cin >> H >> W && H){\n\t\tfor(int i = 0 ; i < 128 ; i++) nowtable[i] = -1;\n\t\tfor(int i = 0 ; i < 10 ; i++) used[i] = 0;\n\t\tfor(int i = 'A' ; i <= 'Z' ; i++) nowtable[i] = 0;\n\t\t\n\t\tfor(int i = 0 ; i < 12 ; i++)\n\t\t\tfor(int j = 0 ; j < 12 ; j++)\n\t\t\t\tt[i][j] = '#';\n\t\n\t\tchar tmpAlpha = 'A';\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> t[i+1][j+1];\n\t\t\t\tif( t[i+1][j+1] == '.' ){\n\t\t\t\t\tt[i+1][j+1] = tmpAlpha++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tchar c; cin >> c;\n\t\t\tuse.push_back(c);\n\t\t}\n\t\tint ans = 0;\n\t\tvector<string> id;\n\t\t\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( t[i][j-1] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = j;\n\t\t\t\t\twhile( t[i][k] != '#' ){\n\t\t\t\t\t\tstr += t[i][k++];\n\t\t\t\t\t}\n\t\t\t\t\t//cout << str << endl;\n\t\t\t\t}\n\t\t\t\tif( t[i-1][j] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = i;\n\t\t\t\t\twhile( t[k][j] != '#' ){\n\t\t\t\t\t\tstr += t[k++][j];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (dfs()?\"yes\":\"no\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << endl;\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  int value = 0;\n  bool flag = false;\n  while (isdigit(s[p])) {\n    if (flag and value == 0) {\n      throw NotNumExc;\n    }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 14, WMAX = 14, NMAX = 15;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    cout << endl;\n    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n/*    cout << \"HBEGIN: \" << endl;\n    REP(y, H) {\n      REP(x, W) {\n        cout << HBEGIN[x][y];\n      }\n      cout << endl;\n    }\n    cout << \"VBEGIN: \" << endl;\n    REP(y, H) {\n      REP(x, W) {\n        cout << VBEGIN[x][y];\n      }\n      cout << endl;\n    }\n*/\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if (incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if (incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) goto INCORRECT;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) goto INCORRECT;\n      }\n      return true;\n\nINCORRECT:\n      ;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\nint H, W;\nchar B[10][10];             // ??????????????¢\nint n;\nchar ds[20];                    // ??????????????????\n\nint BrankX[20], BrankY[20];     // ???????????§?¨?\n\n// ????????????\nconst int dx[4] = {0, 0, -1, 1};\nconst int dy[4] = {-1, 1, 0, 0};\nenum dir {up, down, lft, rgt};\n\n// ?????????????????§?¨????????´???????\nvector<int> UD_X, UD_Y;         // ???????????????????????????\nvector<int> LR_X, LR_Y;         // ???????????????????????????\n\n// dfs??§?????¨\nbool used[10];\n\n// ???????§£?????§?????¨\nint idxX;                       // ?§£???????????????X??§?¨?\nint idxY;                       // ?§£???????????????Y??§?¨?\ndir direc;                      // ?????¨?§£????????????????????? down or rgt\nconst int NG = 99999999;        // ????????£?????????????????¨?????????\n\nchar Board(int x, int y)\n{\n  return B[y][x];\n}\n\nbool inBoard(int x, int y)\n{\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\n// (x,y)?????????????£???????????????¨???true\nbool isWhite(int x, int y)\n{\n  return inBoard(x, y) && (Board(x, y) != '#');\n}\n\nbool isOperator(char op)\n{\n  return (op == '+' || op == '-' ||\n          op == '*' || op == '/' ||\n          op == '=');\n}\n\nint N0()\n{\n  if (!isdigit(Board(idxX, idxY))) return NG;\n\n  string vals;\n  while (isdigit(Board(idxX, idxY)))\n  {\n    vals += Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n  }\n  if (vals[0] == '0' && vals.length() > 1) return NG;\n\n  return atoi(vals.c_str());\n}\n\nint Ex0()\n{\n  int val = N0();\n  if (val == NG) return NG;\n\n  while (Board(idxX, idxY) == '*' || Board(idxX, idxY) == '/')\n  {\n    char op = Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n\n    int b = N0();\n    if (op == '*') val *= b;\n    if (op == '/') val /= b;\n  }\n  return val;\n}\n\n// (idxX, idxY)???????§??????????????¨?????????????????????????\n// ????????¢??°?????????????????¨(idxX, idxY)?????????????£???????????????¨?????¨???\nint Ex()\n{\n  int val = Ex0();              // *??¨/??§?¨???????????????°\n  if (val == NG) return NG;\n\n  while (Board(idxX, idxY) == '+' || Board(idxX, idxY) == '-')\n  {\n    char op = Board(idxX, idxY);\n    idxX += dx[direc];\n    idxY += dy[direc];\n\n    int b = Ex();\n    if (b == NG) return NG;\n    if (op == '+') val += b;\n    if (op == '-') val -= b;\n  }\n  return val;\n}\n\n// ??¨??¨????????£????????¢????????????????????¨????????????????????£?????????????????????????????????\nbool isCorrectBoard()\n{\n  // ????????????\n  for (int i=0;i<UD_X.size();i++)\n  {\n    idxX = UD_X[i];\n    idxY = UD_Y[i];\n    direc = down;\n\n    // (idxX, idxY)???????§????????????????\n    int lhs = Ex();\n    if (lhs == NG) return false;\n\n    // ???????¬????=???????????????\n    if (inBoard(idxY, idxX) && Board(idxX, idxY) != '=') return false;\n\n    // = ?????????????????????\n    idxX += dx[down];\n    idxY += dy[down];\n    // ????????????????¨????\n    int rhs = Ex();\n    if (rhs == NG) return false;\n\n    if (isWhite(idxX, idxY)) return false;\n\n    if (lhs != rhs) return false;\n  }\n  // ???????????????????????¨?????£??????\n\n  // ????????????\n  for (int i=0;i<LR_X.size();i++)\n  {\n    idxX = LR_X[i];\n    idxY = LR_Y[i];\n    direc = rgt;\n\n    // (idxX, idxY)???????§????????????????\n    int lhs = Ex();\n    if (lhs == NG) return false;\n\n    // ???????¬????=???????????????\n    if (!inBoard(idxY, idxX) && Board(idxX, idxY) != '=') return false;\n\n    // = ?????????????????????\n    idxX += dx[rgt];\n    idxY += dy[rgt];\n    // ????????????????¨????\n    int rhs = Ex();\n    if (rhs == NG) return false;\n\n    if (isWhite(idxX, idxY)) return false;\n\n    if (lhs != rhs) return false;\n  }\n  // ???????????????????????¨?????£??????\n\n  return true;\n}\n\nvoid print_Board()\n{\n  for (int i=0;i<H;i++)\n    cout << B[i] << endl;\n  cout << endl;\n}\n\nvoid print_Start()\n{\n  for (int i=0;i<UD_X.size();i++)\n  {\n    printf(\"(%d, %d) \", UD_X[i], UD_Y[i]);\n  }\n  printf(\"\\n\");\n  for (int i=0;i<LR_X.size();i++)\n  {\n    printf(\"(%d, %d) \", LR_X[i], LR_Y[i]);\n  }\n  printf(\"\\n\");\n}\n\n// 1???b-1????????????????????????????????\\??£???????????¨?????????\n// ??????????????¢?´¢????????£???????????¢????????¨????????°true?????????\nbool dfs(int b)\n{\n  if (b == n)\n  {\n    // ??¨??¨????????£???????????????\n    // ?????¢?????£??????????????????????¢??????????\n    // ??£???????????¢??????true????????????????????????false?????????\n    //print_Board();\n    return isCorrectBoard();\n  }\n  else\n  {\n    int x = BrankX[b], y = BrankY[b];\n    // ??°????????\\???????????????????????????????????????\n    bool digitp = false;\n    // ??¨??????????¨???????????????°??°????????\\???\n    for (int i=0;i<4;i++)\n    {\n      if (inBoard(x+dx[i], y+dy[i]) && isOperator(Board(x+dx[i], y+dy[i])))\n      {\n        digitp = true;\n        break;\n      }\n    }\n    // ?????????????????????????????????????????°??°????????\\???\n    if (isWhite(x+dx[up], y+dy[up]) && !isWhite(x+dx[down], y+dy[down])) digitp=true;\n    if (isWhite(x+dx[down], y+dy[down]) && !isWhite(x+dx[up], y+dy[up])) digitp=true;\n    if (isWhite(x+dx[lft], y+dy[lft]) && !isWhite(x+dx[rgt], y+dy[rgt])) digitp=true;\n    if (isWhite(x+dx[rgt], y+dy[rgt]) && !isWhite(x+dx[lft], y+dy[lft])) digitp=true;\n\n    // (x,y)?????????????????\\????????¢?´¢????¶???????\n    for (int i=0;i<n;i++)\n    {\n      if (used[i]) continue;\n      if (digitp && isOperator(ds[i])) continue;\n\n      used[i] = true;\n      B[y][x] = ds[i];\n      if (dfs(b+1)) return true;\n      used[i] = false;\n    }\n    return false;\n  }\n}\n\nint main()\n{\n  while (cin >> H >> W)\n  {\n    if (H == 0) return 0;\n    for (int i=0;i<H;i++) cin >> B[i];\n    cin >> n;\n    for (int i=0;i<n;i++) cin >> ds[i];\n\n    // ????????¨????????§?¨????????????£?????????\n    int k = 0;\n    for (int y=0;y<H;y++)\n      for (int x=0;x<W;x++)\n        if (Board(x, y) == '.') { BrankX[k] = x; BrankY[k] = y; k++; }\n\n    assert(k == n);\n\n    // ?????????????????§??????\n    UD_X.clear(); UD_Y.clear();\n    LR_X.clear(); LR_Y.clear();\n    // ???????????????????????????????????§??????\n    for (int i=0;i<H;i++)\n      for (int j=0;j<W;j++)\n      {\n        if (!isWhite(j + dx[up], i + dy[up]) &&\n            isWhite(j + dx[down], i + dy[down]))\n        {\n          UD_X.push_back(j);\n          UD_Y.push_back(i);\n        }\n      }\n    // ???????????????????????????????????§??????\n    for (int i=0;i<H;i++)\n      for (int j=0;j<W;j++)\n      {\n        if (!isWhite(j + dx[lft], i + dy[lft]) &&\n            isWhite(j + dx[rgt], i + dy[rgt]))\n        {\n          LR_X.push_back(j);\n          LR_Y.push_back(i);\n        }\n      }\n\n    //print_Start();\n\n    // DFS??§??¨??¢?´¢\n    for (int i=0;i<n;i++) used[i]=false;\n\n    if (dfs(0)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\nint calc(string s)\n{\n  istringstream iss( s );\n  vector<int> num;\n  vector<char> op;\n  int n;\n  char c;\n  while( iss >> n ){    \n    num.push_back( n );\n    if( iss >> c )op.push_back( c );\n    else break;\n  }\n  \n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    else assert( false && \"invalid op\" );\n    num.erase( num.begin() + i + 1);\n    op.erase( op.begin() + i );\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\nbool check_syntax(string s)\n{\n  //cout << \"F : \" << s << endl;\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\nbool valid(int h, int w)\n{\n  char puz[H][W];\n  vector<string> v;\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      string s;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\ts += puz[ni][nj];\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < s.size() ) v.push_back( s );\n    }\n  }  \n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      string s;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\ts += puz[ni][nj];\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < s.size() ) v.push_back( s );\n    }\n  }\n\n  for(int i=0; i<v.size(); ++i){\n    if( !check_syntax(v[i]) ) return false;\n  }\n  \n  return true;\n}\n\nbool solve(char p[], int size, int h, int w)\n{\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  vector< pair<int, int> > emp;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp.push_back( make_pair(i, j) );\n    }\n  }\n\n  if( emp.size() != size )return false;\n\n  sort( p, p + size );\n  do{\n\n    for(int i=0; i<size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n\n    if( valid(h, w) )return true;\n    //cout << ++total << endl;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( cin >> h >> w && (h | w) ){\n\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tcin >> g[i][j];\n      }\n    }\n\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n\n    cout << ( solve(m, n, h, w) ? \"Yes\" : \"No\" ) << endl;\n    //clog << ( solve(m, n, h, w) ? \"Yes\" : \"No\" ) << endl;\n\n  }\n\n  //cout << calc(\"2\") << endl;\n  //cout << calc(\"8+23\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) {\n                end_parse = 1;\n                return 1e7;\n            }\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0){\n                end_parse = true;\n                return 1e7;\n            }\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    end_parse = 0;\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15]){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nbool check(char m[15][15]){\n    bool f;\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++){\n                    if(m[k][j] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++){\n                    str.push_back(m[i][k]);\n                    if(m[i][k] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        int k = 0;\n        rep(i,h){\n            rep(j,w){\n                scanf(\"%c\",&m[i + 1][j + 1]);\n                if(m[i + 1][j + 1] == '.'){\n                    y[k] = i + 1;\n                    x[k++] = j + 1;\n                }\n            }\n            scanf(\"%*c\");\n        }\n\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n        if(not check(m)){\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"Yes\" : \"No\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 15)) return false;\n    if(k == L) return true;\n    vector<int> perm;\n    for(int i = 0; i < vc.size(); i++) if(!used[i]) perm.push_back(i);\n    random_shuffle(perm.begin(), perm.end());\n    for(auto i : perm) {\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    srand(time(NULL));\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          NotMultExc = 5;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  int value = 0;\n  bool flag = false;\n  while (isdigit(s[p])) {\n    if (flag and value == 0) {\n      throw NotNumExc;\n    }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 14, WMAX = 14, NMAX = 15;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_contiguous_operands() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch(int ex) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (is_contiguous_operands()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!(isdigit(str[i]) && str[i]!='0')) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id) {\n  if (s.size() < 2) return 1;\n  if ((id == 0 || isoperator(s[id-1])) && !isdigit(s[id])) return 0;\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nchar TEMP[100];\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false; \n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\nint calc(string s)\n{\n  istringstream iss( s );\n  vector<int> num;\n  vector<char> op;\n  int n;\n  char c;\n  while( iss >> n ){    \n    num.push_back( n );\n    if( iss >> c )op.push_back( c );\n    else break;\n  }\n  \n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    else assert( false && \"invalid op\" );\n    num.erase( num.begin() + i + 1);\n    op.erase( op.begin() + i );\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\nbool check_syntax(string s)\n{\n  //cout << \"F : \" << s << endl;\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\nbool valid(int h, int w)\n{\n\n  if( 0 ){\n    cout << endl;\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tcout << g[i][j] ;\n      }\n      cout << endl;\n    }\n  }\n\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tflg = g[i][j] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  char puz[H][W];\n  vector<string> v;\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      string s;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\ts += puz[ni][nj];\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < s.size() ) v.push_back( s );\n    }\n  }  \n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      string s;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\ts += puz[ni][nj];\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < s.size() ) v.push_back( s );\n    }\n  }\n\n  for(int i=0; i<v.size(); ++i){\n    if( !check_syntax(v[i]) ) return false;\n  }\n  \n  return true;\n}\n\nbool solve(char p[], int size, int h, int w)\n{\n  vector< pair<int, int> > emp;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp.push_back( make_pair(i, j) );\n    }\n  }\n\n  if( emp.size() != size )return false;\n\n  sort( p, p + size );\n  do{\n\n    for(int i=0; i<size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n\n    if( valid(h, w) )return true;\n    //cout << ++total << endl;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( cin >> h >> w && (h | w) ){\n\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tcin >> g[i][j];\n      }\n    }\n\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n\n    cout << ( solve(m, n, h, w) ? \"Yes\" : \"No\" ) << endl;\n    //clog << ( solve(m, n, h, w) ? \"Yes\" : \"No\" ) << endl;\n\n  }\n\n  //cout << calc(\"2\") << endl;\n  //cout << calc(\"8+23\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (r == 0) throw 0;\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id, bool f=1) {\n  if (s.size() < 2) return 1;\n  // if (f) {\n  //   if ((id == 0 || isoperator(s[id-1])) && (!isdigit(s[id]) || s[id] == '0')) return 0;\n  //   if ((id == s.size()-1 || isoperator(s[id+1])) && !isdigit(s[id])) return 0;\n  // }\n  REP(i,s.size()-1) {\n    if ((i==0 || !isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return 0;\n    if (isoperator(s[i]) && isoperator(s[i+1])) return 0;\n  }\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == pos.size()) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // assert(pos.size() == n);\n    bool ok = 1;\n    FOR(it, v) ok &= check(*it,0,0);\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (ok&&dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\nconst int maxn = 10 + 2;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nint n, m, k, cnt;\nchar s[maxn][maxn], d[maxn];\npair<int, int> rec[maxn];\nbool used[maxn];\n\nbool out(int x, int y) {\n    return x < 0 || y < 0 || x >= n || y >= m;\n}\nbool isop(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\nbool calc(int &x1, int x2, char op) {\n    if (op == '+') x1 += x2;\n    else if (op == '-') x1 -= x2;\n    else if (op == '*') x1 *= x2;\n    else if (op == '/') {\n        if (x2 == 0 || x1 % x2) return false;\n        x1 /= x2;\n    }\n    return true;\n}\nbool calc_exp(char *s, int n, int &val) {\n    if (n == 0) return false;\n    int now = 0;\n    vector<int> num;\n    vector<char> op;\n    for (int i = 0; i <= n; ++i) {\n        if (i == n || s[i] == '+' || s[i] == '-') {\n            num.push_back(now);\n            now = 0;\n            while (num.size() > 1) {\n                int x2 = num.back();\n                num.pop_back();\n                int x1 = num.back();\n                num.pop_back();\n                if (!calc(x1, x2, op.back())) return false;\n                op.pop_back();\n                num.push_back(x1);\n            }\n            if (i != n) op.push_back(s[i]);\n        } else if (isdigit(s[i])) {\n            now = now * 10 + s[i] - '0';\n        } else if (s[i] == '*' || s[i] == '/') {\n            num.push_back(now);\n            now = 0;\n            while (op.size() > 0 && (op.back() == '*' || op.back() == '/')) {\n                int x2 = num.back();\n                num.pop_back();\n                int x1 = num.back();\n                num.pop_back();\n                if (!calc(x1, x2, op.back())) return false;\n                op.pop_back();\n                num.push_back(x1);\n            }\n            op.push_back(s[i]);\n        }\n    }\n    val = num[0];\n    return true;\n}\nbool legal_exp(char *s, int n, int &val) {\n    for (int i = 0; i < n; ++i) {\n        if (i + 1 < n && s[i] == '0' && isdigit(s[i + 1])) return false;\n        //if ((i == 0 || i == n - 1) && isop(s[i])) return false;\n        //if (i + 1 < n && isop(s[i]) && isop(s[i + 1])) return false;\n    }\n    if (!calc_exp(s, n, val)) return false;\n    return true;\n}\nbool legal_equility(char *s, int n) {\n    if (n <= 2) return true;\n    int x = -1;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '=') {\n            if (x >= 0) return false;\n            x = i;\n        }\n    }\n    if (x == -1) return false;\n    for (int i = 0; i < n; ++i) {\n        if ((i == 0 || i == n - 1) && isop(s[i])) return false;\n        if (i + 1 < n && isop(s[i]) && isop(s[i + 1])) return false;\n        if (i + 1 < n && isop(s[i]) && s[i + 1] == '=') return false;\n        if (i - 1 >= 0 && isop(s[i]) && s[i - 1] == '=') return false;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '.') return true;\n    }\n    int x1, x2;\n    if (!legal_exp(s, x, x1) || !legal_exp(s + x + 1, n - x - 1, x2)) return false;\n    return x1 == x2;\n}\nbool check_ori() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == '#') continue;\n            int k = j + 1;\n            while (k < m && s[i][k] != '#') ++k;\n            if (!legal_equility(s[i] + j, k - j)) return false;\n            j = k;\n        }\n    }\n    char str[maxn];\n    int len;\n    for (int j = 0; j < m; ++j) {\n        for (int i = 0; i < n; ++i) {\n            if (s[i][j] == '#') continue;\n            len = 0;\n            while (i + len < n && s[i + len][j] != '#') {\n                str[len] = s[i + len][j];\n                ++len;\n            }\n            if (!legal_equility(str, len)) return false;\n            i += len;\n        }\n    }\n    return true;\n}\n\nbool ok(int x1, int x2) {\n    int lf = x2, rt = x2;\n    while (lf >= 0 && s[x1][lf] != '#') --lf;\n    while (rt < m && s[x1][rt] != '#') ++rt;\n    ++lf;\n    --rt;\n    if (!legal_equility(s[x1] + lf, rt - lf + 1)) return false;\n    char str[maxn];\n    int len = 0;\n    while (x1 >= 0 && s[x1][x2] != '#') --x1;\n    ++x1;\n    while (x1 < n && s[x1][x2] != '#') {\n        str[len++] = s[x1++][x2];\n    }\n    if (!legal_equility(str, len)) return false;\n    return true;\n}\n\nbool dfs(int dep) {\n    if (dep == cnt) {\n        return true;\n    }\n    for (int i = 0; i < k; ++i) {\n        if (used[i]) continue;\n        if (i > 0 && d[i] == d[i - 1] && !used[i - 1]) continue;\n        s[rec[dep].first][rec[dep].second] = d[i];\n        used[i] = true;\n        if (ok(rec[dep].first, rec[dep].second) && dfs(dep + 1)) return true;\n        used[i] = false;\n        s[rec[dep].first][rec[dep].second] = '.';\n    }\n    return false;\n}\n\nbool check() {\n    if (cnt > k) return false;\n    if (!check_ori()) return false;\n    memset(used, 0, sizeof(used));\n    if (!dfs(0)) return false;\n    return true;\n}\nbool cmp(char x1, char x2) {\n    return x1 < x2;\n}\nint main() {\n    //char st[100];\n    //while (scanf(\"%s\", st) && strcmp(st, \"0\")) {\n        //int val;\n        //bool flag = legal_exp(st, strlen(st), val);\n        //printf(\"%d %d\\n\", val, flag);\n    //}\n    //printf(\"0\\n\");\n    //freopen(\"0.out\", \"w\", stdout);\n    while (scanf(\"%d%d\", &n, &m) == 2 && (n + m)) {\n        cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%s\", s[i]);\n            for (int j = 0; j < m; ++j) {\n                if (s[i][j] == '.') rec[cnt++] = make_pair(i, j);\n            }\n        }\n        scanf(\"%d\", &k);\n        if (k > 10) while (1);\n        //char str[10];\n        for (int i = 0; i < k; ++i) {\n            do {\n                d[i] = getchar();\n            } while (!isdigit(d[i]) && !isop(d[i]));\n            if(d[i] == '=') while(1);\n        }\n        sort(d, d + k, cmp);\n        //d[k] = 0; printf(\"%s\\n\", d);\n        bool flag = check();\n        if (flag) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\n\nll term(int &i);\nll fact(int &i);\n\nll exp(int &i) {\n  ll p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      ll a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nll term(int &i) {\n  ll p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nll fact(int &i) {\n  ll p = 0;\n  if (!(isdigit(str[i]) && str[i]!='0')) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nll parse(const string &s) {\n  REP(i,s.size()) str[i] = s[i];\n  str[s.size()] = '\\0';\n  int id = 0;\n  ll res = exp(id);\n  if (id != s.size()) throw 0;\n  return res;\n}\n\nbool check(const string &s) {\n  if (s.size() < 2) return 1;\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1) return 0;\n    ll a = parse(s.substr(0,pos));\n    ll b = parse(s.substr(pos+1));\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first])) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first])) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nconstexpr int tsurai=123456789;\n\nint parse_int(const std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i]-'0';\n  while (++i < s.length() && isdigit(s[i])) {\n    res = res*10 + s[i]-'0';\n  }\n  return res;\n}\n\nint fourt(const std::string &s, size_t &i) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length() && isdigit(s[i])) {\n    int cur=parse_int(s, i);\n    while (i < s.length() && s[i] != '=') {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (tmp == 0 || cur % tmp) return tsurai;\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n    if (sgn == '+') {\n      res += cur;\n    } else {\n      res -= cur;\n    }\n    if (i < s.length() && s[i] != '=') {\n      sgn = s[i++];\n    }\n  }\n  return res;\n}\n\nbool valid(const std::vector<std::string> &eqs, const std::vector<char> &cs) {\n  for (/* not const */ std::string eq: eqs) {\n    for (char &ch: eq)\n      if (ch >= 'A' && ch <= 'Z')\n        ch = cs[ch-'A'];\n\n    if (eq[0] == '=' || eq.back() == '=')\n      return false;\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] != '0') {\n        do {\n          ++i;\n        } while (i < eq.length() && isdigit(eq[i]));\n      } else {\n        if (i+1 < eq.length() && isdigit(eq[i+1]))\n          return false;\n      }\n    }\n\n    size_t i=0;\n    if (!isdigit(eq[i])) return false;\n    int lhs=fourt(eq, i);\n    assert(eq[i] == '=');\n    ++i;\n    if (!isdigit(eq[i])) return false;\n    int rhs=fourt(eq, i);\n    assert(i == eq.length());\n    \n    if (lhs == tsurai || rhs == tsurai || lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0)\n    return 1;\n\n  size_t ph='A';  // placeholder\n  std::vector<std::string> s(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] == '.')\n        s[i][j] = ph++;\n    }\n  }\n\n  std::vector<std::string> eqs;\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (s[i][j] != '#') {\n        eq += s[i][j];\n      } else {\n        if (eq.size() >= 3)\n          eqs.emplace_back(eq);\n        eq = \"\";\n      }\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> cs(n);\n  for (size_t i=0; i<n; ++i)\n    scanf(\" %c\", &cs[i]);\n\n  std::sort(cs.begin(), cs.end());\n  do {\n    if (valid(eqs, cs))\n      return !printf(\"Yes\\n\");\n  } while (std::next_permutation(cs.begin(), cs.end()));\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "5 5\n4=..2\n+#=#+\n.-2=.\n=#*#=\n.-.=3\n6\n7 3 1 4 / 8\n1 6\n8..3=2\n2\n2 +\n0 0"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\nconst int maxn = 10 + 2;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nint n, m, k, cnt;\nchar s[maxn][maxn], d[maxn];\npair<int, int> rec[maxn];\nbool used[maxn];\n\nbool out(int x, int y) {\n    return x < 0 || y < 0 || x >= n || y >= m;\n}\nbool isop(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\nbool calc(int &x1, int x2, char op) {\n    if (op == '+') x1 += x2;\n    else if (op == '-') x1 -= x2;\n    else if (op == '*') x1 *= x2;\n    else if (op == '/') {\n        if (x2 == 0 || x1 % x2) return false;\n        x1 /= x2;\n    }\n    return true;\n}\nbool calc_exp(char *s, int n, int &val) {\n    if (n == 0) return false;\n    int now = 0;\n    vector<int> num;\n    vector<char> op;\n    for (int i = 0; i <= n; ++i) {\n        if (i == n || s[i] == '+' || s[i] == '-') {\n            num.push_back(now);\n            now = 0;\n            while (num.size() > 1) {\n                int x2 = num.back();\n                num.pop_back();\n                int x1 = num.back();\n                num.pop_back();\n                if (!calc(x1, x2, op.back())) return false;\n                op.pop_back();\n                num.push_back(x1);\n            }\n            if (i != n) op.push_back(s[i]);\n        } else if (isdigit(s[i])) {\n            now = now * 10 + s[i] - '0';\n        } else if (s[i] == '*' || s[i] == '/') {\n            num.push_back(now);\n            now = 0;\n            while (op.size() > 0 && (op.back() == '*' || op.back() == '/')) {\n                int x2 = num.back();\n                num.pop_back();\n                int x1 = num.back();\n                num.pop_back();\n                if (!calc(x1, x2, op.back())) return false;\n                op.pop_back();\n                num.push_back(x1);\n            }\n            op.push_back(s[i]);\n        }\n    }\n    val = num[0];\n    return true;\n}\nbool legal_exp(char *s, int n, int &val) {\n    for (int i = 0; i < n; ++i) {\n        if (i + 1 < n && s[i] == '0' && isdigit(s[i + 1])) return false;\n        //if ((i == 0 || i == n - 1) && isop(s[i])) return false;\n        //if (i + 1 < n && isop(s[i]) && isop(s[i + 1])) return false;\n    }\n    if (!calc_exp(s, n, val)) return false;\n    return true;\n}\nbool legal_equility(char *s, int n) {\n    if (n <= 2) return true;\n    int x = -1;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '=') {\n            if (x >= 0) return false;\n            x = i;\n        }\n    }\n    if (x == -1) return true;\n    for (int i = 0; i < n; ++i) {\n        if ((i == 0 || i == n - 1) && isop(s[i])) return false;\n        if (i + 1 < n && isop(s[i]) && isop(s[i + 1])) return false;\n        if (i + 1 < n && isop(s[i]) && s[i + 1] == '=') return false;\n        if (i - 1 >= 0 && isop(s[i]) && s[i - 1] == '=') return false;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '.') return true;\n    }\n    int x1, x2;\n    if (!legal_exp(s, x, x1) || !legal_exp(s + x + 1, n - x - 1, x2)) return false;\n    return x1 == x2;\n}\nbool check_ori() {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (s[i][j] == '#') continue;\n            int k = j + 1;\n            while (k < m && s[i][k] != '#') ++k;\n            if (!legal_equility(s[i] + j, k - j)) return false;\n            j = k;\n        }\n    }\n    char str[maxn];\n    int len;\n    for (int j = 0; j < m; ++j) {\n        for (int i = 0; i < n; ++i) {\n            if (s[i][j] == '#') continue;\n            len = 0;\n            while (i + len < n && s[i + len][j] != '#') {\n                str[len] = s[i + len][j];\n                ++len;\n            }\n            if (!legal_equility(str, len)) return false;\n            i += len;\n        }\n    }\n    return true;\n}\n\nbool ok(int x1, int x2) {\n    int lf = x2, rt = x2;\n    while (lf >= 0 && s[x1][lf] != '#') --lf;\n    while (rt < m && s[x1][rt] != '#') ++rt;\n    ++lf;\n    --rt;\n    if (!legal_equility(s[x1] + lf, rt - lf + 1)) return false;\n    char str[maxn];\n    int len = 0;\n    while (x1 >= 0 && s[x1][x2] != '#') --x1;\n    ++x1;\n    while (x1 < n && s[x1][x2] != '#') {\n        str[len++] = s[x1++][x2];\n    }\n    if (!legal_equility(str, len)) return false;\n    return true;\n}\n\nbool dfs(int dep) {\n    if (dep == cnt) {\n        return true;\n    }\n    for (int i = 0; i < k; ++i) {\n        if (used[i]) continue;\n        if (i > 0 && d[i] == d[i - 1] && !used[i - 1]) continue;\n        s[rec[dep].first][rec[dep].second] = d[i];\n        used[i] = true;\n        if (ok(rec[dep].first, rec[dep].second) && dfs(dep + 1)) return true;\n        used[i] = false;\n        s[rec[dep].first][rec[dep].second] = '.';\n    }\n    return false;\n}\n\nbool check() {\n    if (cnt > k) return false;\n    if (!check_ori()) return false;\n    memset(used, 0, sizeof(used));\n    if (!dfs(0)) return false;\n    return true;\n}\nbool cmp(char x1, char x2) {\n    bool s1 = isop(x1), s2 = isop(x2);\n    if (s1 != s2) return s1 > s2;\n    return x1 < x2;\n}\nint main() {\n    //char st[100];\n    //while (scanf(\"%s\", st) && strcmp(st, \"0\")) {\n        //int val;\n        //bool flag = legal_exp(st, strlen(st), val);\n        //printf(\"%d %d\\n\", val, flag);\n    //}\n    //printf(\"0\\n\");\n    //freopen(\"0.out\", \"w\", stdout);\n    while (scanf(\"%d%d\", &n, &m) == 2 && (n + m)) {\n        cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%s\", s[i]);\n            for (int j = 0; j < m; ++j) {\n                if (s[i][j] == '.') rec[cnt++] = make_pair(i, j);\n            }\n        }\n        scanf(\"%d\", &k);\n        char str[10];\n        for (int i = 0; i < k; ++i) {\n            do {\n                d[i] = getchar();\n            } while (!isdigit(d[i]) && !isop(d[i]));\n        }\n        sort(d, d + k, cmp);\n        //d[k] = 0; printf(\"%s\\n\", d);\n        bool flag = check();\n        if (flag) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint h, w, n;\nchar t[12][12];\nchar p[12];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool check(int x, int y, int d){\n  while(0 <= x && x < w && 0 <= y && y < h && t[y][x] != '#'){\n    x += dx[d];\n    y += dy[d];\n  }\n\n  d += 2;\n  x += dx[d];\n  y += dy[d];\n\n  int cnt = 0;\n\n  while(0 <= x && x < w && 0 <= y && y < h && t[y][x] != '#'){\n    x += dx[d];\n    y += dy[d];\n    cnt++;\n  }\n\n  return cnt == 2;\n}\n\nbool check2(int x, int y){\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(nx < 0 || w <= nx || ny < 0 || h <= ny || t[ny][nx] == '#') continue;\n    return false;\n  }\n\n  return true;\n}\n\nint main(){\n  while(cin >> h >> w, h || w){\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n    }\n\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      cin >> p[i];\n    }\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(t[i][j] != '#' && (check(j, i, 0) || check(j, i, 1) || check2(j, i))){\n          while(true){}\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  string num = \"\";\n  while(pos < s.size() && isdigit(s[pos])) {\n    num += s[pos++];\n  }\n  if(num[0] == '0') flag = true;\n  return atoi(num.c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int x = getNum(s, pos);\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      x *= getNum(s, pos);\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn -1;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int x = term(s, pos);\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      x += term(s, pos);\n    } else if(s[pos] == '-') {\n      ++pos;\n      x -= term(s, pos);\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nbool check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i) \n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#') {\n\tif(isdigit(M[ny][nx])) type = 0;\n\telse type = 1; \n\tbreak;\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*'){\n\tres*=num;\n      }\n      if(ch=='/'){\n\tif(num!=0&&res%num>=0)res/=num;\n\telse flag=true;\n\t\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w;\n\nbool solve();\nbool check();\nbool compute();\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++){\n    v=w[i];\n    if(compute())return true;\n  }\n  return false;\n}\n\nbool compute(){\n  for(int i=0;i<(int)v.size();i++)\n      if('A'<=v[i]&&v[i]<='Z')v[i]=u[v[i]-'A'];\n  string a=\"\",b=\"\";\n  bool flg=false;\n  b.push_back(v[0]);\n  for(int i=1;i<(int)v.size();i++){\n      if(!isNum(v[i-1])&&!isNum(v[i]))return false;\n      if(!isNum(v[i-1])&&v[i]=='0')return false;\n      if(v[i-1]=='0'&&v[i]=='0')return false;\n      if(v[i]=='=')flg=true;\n      else if(flg)a.push_back(v[i]);\n      else b.push_back(v[i]);\n  }\n  if(!isNum(v[0])||!isNum(v[v.size()-1]))return false;\n  \n  calcStr x,y;\n  x.s=a;\n  x.init();\n  y.s=b;\n  y.init();\n\n  int A = x.getAns();\n  int B = y.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint expr(const string& s)\n{\n\tint x; char op1;\n\tfor(int i=0,j=0,k=0;i<s.size();i++){\n\t\tint y=0; char op2;\n\t\tfor(j=i;j<s.size();j++){\n\t\t\tif(s[j]<'1' || '9'<s[j]) return INF;\n\t\t\tint z=0;\n\t\t\tfor(k=j;k<s.size() && isdigit(s[k]);k++)\n\t\t\t\tz=z*10+s[k]-'0';\n\t\t\tif(j==i) y=z;\n\t\t\telse if(op2=='*') y*=z;\n\t\t\telse if(z && y%z==0) y/=z;\n\t\t\telse return INF;\n\t\t\tj=k;\n\t\t\tif(i==s.size()) break;\n\t\t\tif(s[j]!='*' && s[j]!='/') break;\n\t\t\top2=s[j];\n\t\t}\n\t\tif(i==0) x=y;\n\t\telse op1=='+'?x+=y:x-=y;\n\t\ti=j;\n\t\tif(i==s.size()) break;\n\t\tif(s[i]!='+' && s[i]!='-') return INF;\n\t\top1=s[i];\n\t}\n\treturn x;\n}\n\nbool check(const vs& grid,const vector<vector<pii>>& fs)\n{\n\tfor(auto f:fs){\n\t\tstring s;\n\t\tfor(auto p:f) s+=grid[p.first][p.second];\n\t\tif(count(all(s),'=')!=1) return false;\n\t\tint eq=s.find('=');\n\t\tif(eq==0 || eq==s.size()-1) return false;\n\t\tstring a=s.substr(0,eq),b=s.substr(eq+1);\n\t\t\n\t\tint x=expr(a),y=expr(b);\n\t\tif(x==INF || y==INF || x!=y)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint n; cin>>n;\n\t\tstring cs(n,'~');\n\t\trep(i,n) cin>>cs[i];\n\t\t\n\t\tvector<pii> ps;\n\t\tvector<vector<pii>> fs;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='.') ps.emplace_back(i,j);\n\t\t\tif(grid[i][j]!='#'){\n\t\t\t\tif((i==0 || grid[i-1][j]=='#') && i<h-1 && grid[i+1][j]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=i;k<h && grid[k][j]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(k,j);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t\tif((j==0 || grid[i][j-1]=='#') && j<w-1 && grid[i][j+1]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=j;k<w && grid[i][k]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(i,k);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring res=\"No\";\n\t\tvi is(n); iota(all(is),0);\n\t\tdo{\n\t\t\trep(i,n){\n\t\t\t\tint j=is[i];\n\t\t\t\tgrid[ps[i].first][ps[i].second]=cs[j];\n\t\t\t}\n\t\t\tif(check(grid,fs)){\n\t\t\t\t//rep(i,h) cout<<grid[i]<<endl;\n\t\t\t\tres=\"Yes\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}while(next_permutation(all(is)));\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, MAX_N> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint factor(string::const_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\tthrow \"parse error\";\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tint tmp;\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t++it;\n\t\t\ttmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_minus[expression[i - 1]] = true;\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_minus[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w));\n\tint next = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '.') idx[i][j] = next++;\n\t\t}\n\t}\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tif(is_operator[i] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\t\tif(in[i] == '-' && not_minus[idx]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[i]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tis_operator.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t\tif(in[i] == '+' || in[i] == '-' || in[i] == '*' || in[i] == '/') {\n\t\t\t\tis_operator[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tif (S == \"\") return pair< int, bool >(0, false);\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (a % b != 0 || b == 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (stack_op.top() == '*' || stack_op.top() == '/') {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) {\n\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t}\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tif (a != n) return false;\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) flag &= eq.evaluate(s_map);\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int UND = 1<<30;\nint h, w;\nchar pz[12][12];\nchar cur[12][12];\nbool used[12][12];\n\nbool ans;\n\nclass Parser\n{\npublic:\n\tstring exp;\n\tint p;\n\tvoid Eq (void );\n\tint Ex (void );\n\tint N (void );\n};\n\nvoid Parser::Eq (void )\n{\n\tint value1 = 0, value2 = 0;\n#if DEBUG\n\tcout << \"exp: \" << exp << endl;\n#endif\n\tvalue1 = Ex();\n\n\tif (value1 == UND ) ans = false;\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tint val = 0;\n\t\tif (exp[p] == '+' ){\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue1 += val;\n\t\t}else{\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue1 -= val;\t\t\n\t\t} // end if\n\t} // end while\n\n\tif (exp[p] == '=' ){\n\t\t++p;\n\t} // end if\n\n\tvalue2 = Ex();\t\t\t\n\n\tif (value2 == UND ) ans = false;\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tint val = 0;\n\t\tif (exp[p] == '+' ){\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue2 += val;\n\t\t}else{\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue2 -= val;\t\t\n\t\t} // end if\n\t} // end while\n\n\tif (value1 != value2 )\n\t\tans = false;\n#if DEBUG\n\tcout << \"ans: \" << (ans ? \"YES\" : \"NO\" ) << endl;\n#endif\n}\n\nint Parser::Ex (void )\n{\n\tint value = N();\n\n\tif (value == UND ) ans = false;\n\n\twhile (exp[p] == '*' || exp[p] == '/' ){\n\t\tif (exp[p] == '*' ){\n\t\t\t++p;\n\t\t\tint val = N();\n\t\t\tif (val == UND ){\n\t\t\t\tvalue = UND;\n\t\t\t\tans = false;\n\t\t\t}else{\n\t\t\t\tvalue *= val;\n\t\t\t} // end if\n\t\t}else{\n\t\t\t++p;\n\t\t\tint val = N();\n\t\t\tif (value != UND && val != UND && val != 0 && value % val == 0 ){\n\t\t\t\tvalue /= val;\n\t\t\t}else{\n\t\t\t\tvalue = UND;\n\t\t\t\tans = false;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end while\n\t\n\treturn value;\n}\n\nint Parser::N (void )\n{\n\tint value = 0;\n\tint cnt = 0;\n\tchar first = 0;\n\tif (!isdigit(exp[p] ) )\n\t\treturn UND;\n\n\twhile (isdigit(exp[p] ) ){\n\t\tif (cnt == 0 ){\n\t\t\tfirst = exp[p];\n\t\t} // end if\n\t\tvalue *= 10;\n\t\tvalue += (exp[p] - '0');\n\t\tcnt++;\n\t\tp++;\n\t} // end while\n\n\tif ( (first == '0' && cnt > 1 ) || (cnt > 2 ) )\n\t\tans = false;\n\n\treturn value;\n}\n\nvoid disp_pz (void )\n{\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tcout << cur[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep \n}\n\n\nbool make_pz (vector<char> ope )\n{\n\tmemset (cur, 0, sizeof (cur ) );\n\tint k = 0;\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tif (pz[i][j] == '.' ){\n\t\t\t\tif (!isdigit(ope[k] ) ){\n\t\t\t\t\tif (i == 0 && j == 0 ) return false;\n \t\t\t\t\tif (i != 0 && pz[i-1][j] != '#' && !isdigit (pz[i-1][j] ) ) return false;\n\t\t\t\t\tif (j != 0 && pz[i][j-1] != '#' && !isdigit (pz[i][j-1] ) ) return false;\n\t\t\t\t} // end if\n\t\t\t\tcur[i][j] = ope[k];\n\t\t\t\tk++;\n\t\t\t}else{\n\t\t\t\tcur[i][j] = pz[i][j];\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n#if DEBUG\n\tdisp_pz ();\n\tcout << endl;\n#endif\n\n\treturn true;\n}\n\nbool evaluate_exp (string exp )\n{\n//\tcout << exp << endl;\n\tParser parser;\n\tparser.exp = exp;\n\tparser.p = 0;\n\tans = true;\n\tparser.Eq();\n\n\treturn ans;\t\n}\n\nbool is_correct (void )\n{\n\tconst int dir[][2] = { { 0, 0 }, { 1, 0 }, { 0, 1 } };\n\n\tmemset (used, false, sizeof (used ) );\n\tstack<P> u;\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tif (cur[i][j] != '#' ){\n\t\t\t\tint k1 = 0, k2 = 0;\n\t\t\t\tif (!used[i][j] ){\n\t\t\t\t\tk1 = 0, k2 = 2;\n\t\t\t\t}else{ // if (used[i][j] )\n\t\t\t\t\tint dsum = 0;\n\t\t\t\t\trep (d, 3 ){\n\t\t\t\t\t\tint ni = i + dir[d][0];\n\t\t\t\t\t\tint nj = j + dir[d][1];\n\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= h || nj >= w || cur[ni][nj] == '#' ) continue;\n\t\t\t\t\t\tif (!used[ni][nj] ){\n\t\t\t\t\t\t\tdsum += d;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end rep\n\t\t\t\t\tswitch (dsum ){\n\t\t\t\t\t\tcase 1: k1 = 0, k2 = 1; break;\n\t\t\t\t\t\tcase 2: k1 = 1, k2 = 2; break;\n\t\t\t\t\t\tcase 3: k1 = 0, k2 = 2; break;\n\t\t\t\t\t\tdefault: k1 = 0, k2 = 0; break;\n\t\t\t\t\t} // end switch\n\t\t\t\t} // end if\n\t\t\t\tfor (int k = k1; k < k2; k++ ){\n\t\t\t\t\tbool equ = false;\n\t\t\t\t\tstring exp = \"\";\n\t\t\t\t\tfor (int e = (k == 0 ? i : j ); e < (k == 0 ? h : w ); e++ ){\n\t\t\t\t\t\tint row = (k == 0 ? e : i );\n\t\t\t\t\t\tint col = (k == 0 ? j : e );\n\t\t\t\t\t\tif (cur[row][col] != '#' ){\n\t\t\t\t\t\t\tif (cur[row][col] != '=' ){\n\t\t\t\t\t\t\t\texp += cur[row][col];\n\t\t\t\t\t\t\t\tused[row][col] = true;\n\t\t\t\t\t\t\t\tu.push (P (row, col ) );\n\t\t\t\t\t\t\t}else\n\t\t\t\t\t\t\tif (!equ ){\n\t\t\t\t\t\t\t\texp += cur[row][col];\n\t\t\t\t\t\t\t\tused[row][col] = true;\n\t\t\t\t\t\t\t\tu.push (P (row, col ) );\n\t\t\t\t\t\t\t\tequ = true;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t}else{ // if (cur[row][col] == '#' )\n\t\t\t\t\t\t\tif (equ ){\n\t\t\t\t\t\t\t\twhile (!u.empty() ) u.pop();\n\t\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\tequ = false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twhile (!u.empty() ){\n\t\t\t\t\t\t\t\t\tP c = u.top(); u.pop();\n\t\t\t\t\t\t\t\t\tused[c.first][c.second] = false;\n\t\t\t\t\t\t\t\t} // end while\n\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t\texp = \"\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end for\n\t\t\t\t\tif (!exp.empty() ){\n\t\t\t\t\t\tif (equ ){\n\t\t\t\t\t\t\twhile (!u.empty() ) u.pop();\n\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twhile (!u.empty() ){\n\t\t\t\t\t\t\t\tP c = u.top(); u.pop();\n\t\t\t\t\t\t\t\tused[c.first][c.second] = false;\n\t\t\t\t\t\t\t} // end while\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\texp = \"\";\n\t\t\t\t\t} // end if\n\t\t\t\t} // end for\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\treturn true;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.indian_puzzle3\", \"r\", stdin );\n\twhile (cin >> h >> w && h && w ){\n\t\tmemset (pz, 0, sizeof (pz ) );\n\t\trep (i, h ){\n\t\t\tstring in = \"\";\n\t\t\tcin >> in;\n\t\t\trep (j, w ){\n\t\t\t\tpz[i][j] = in[j];\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<char> ope (n, 0 );\n\t\trep (i, n ){\n\t\t\tcin >> ope[i];\n\t\t} // end rep\n\t\tsort (ALL (ope ) );\n\t\tbool found = false;\n\t\tdo{\n\t\t\tif (!make_pz (ope ) ) continue;\n\n\t\t\tif (is_correct () ){\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t}while (next_permutation (ALL (ope ) ) );\n\t\t\n\t\tif (found ){\n\t\t\tprintf (\"Yes\\n\" );\n\t\t}else{\n\t\t\tprintf (\"No\\n\" );\n\t\t} // end if\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        random_shuffle(bp.begin(), bp.end());\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int INF = 1<<24;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  string num = \"\";\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  while(pos < s.size() && isdigit(s[pos])) {\n    num += s[pos++];\n  }\n  if(num[0] == '0') {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  return atoi(num.c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int value = getNum(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      value = getNum(s, pos);\n      if(value == INF) return INF;\n      x *= value;\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == INF) return INF;\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn INF;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int value = term(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x += value;\n    } else if(s[pos] == '-') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x -= value;\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n\n      }\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if (incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if (incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) goto INCORRECT;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) goto INCORRECT;\n      }\n      return true;\n\nINCORRECT:\n      ;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  int value = 0;\n  bool flag = false;\n  if (not isdigit(s[p])) { throw LackNumExc; }\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) {\n      throw NotNumExc;\n    }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 14, WMAX = 14, NMAX = 15;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if (legal(q) and incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if (legal(q) and incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) continue;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) continue;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define UNKNOWN 20\n#define UI unsigned int\nusing namespace std;\nint h,w,n;\nchar m[10][10], r[10];\n//vector<string> form;\nstring form[1000];\nUI formLen;\nint map[10]; // u·¶ÖÌÊ\n\nconst int UNCAL = -1111111;\nconst int PLUS  = UNCAL -1;\nconst int MINUS = PLUS  -1;\nint cal( string s ){\n  string a;\n  int v[10];\n  UI vLen=0;//vector<int> v;\n  bool isNum=true;\n  int kind=0; // 0:+,- 1:* 2:/\n  for( UI i=0;i<s.length();i++ ){\n    if( isNum ){\n      a=\"\";\n      while( i<s.length() && '0'<=s[i] && s[i]<='9' ) a+=s[i++];\n      --i;\n\n      if( a.length()==0 ) return UNCAL;\n      if( a[0]=='0' && a.length()!=1 ) return UNCAL;\n      int number = atoi( a.c_str() );\n\n      if( kind==0 ) v[vLen++]=number;\n      else if( kind==1 ){ // *\n\tv[ vLen-1 ] *= number;\n      }else{ // /\n\tif( number==0 ) return UNCAL;\n\tif( v[vLen-1]%number !=0 ) return UNCAL;\n\tv[ vLen-1 ] /= number;\n      }\n    }else{\n      kind = 0;\n      if( s[i]=='+' )      v[ vLen++ ] = PLUS;\n      else if( s[i]=='-' ) v[ vLen++ ] = MINUS;\n      else if( s[i]=='*' ) kind=1;\n      else if( s[i]=='/' ) kind=2;\n      else return UNCAL;\n    }\n    isNum = !isNum;\n  }\n  if( vLen==0 ) return UNCAL;\n\n  int ret = v[0];\n  for( UI i=1;i<vLen;i+=2 ){\n    if( v[i]==PLUS && i+1<vLen ) ret += v[i+1];\n    else if( v[i]==MINUS && i+1<vLen ) ret-=v[i+1];\n    else return UNCAL;\n  }\n\n  return ret;\n}\n\nbool checkForm( string s ){\n  int a,b;\n  UI i=s.find(\"=\");\n\n  if( i==string::npos || i+1==s.length() )\n    return false;\n  if( (a=cal(s.substr(0,i)))==UNCAL )\n    return false;\n  b = cal( s.substr( i+1 ) );\n\n  return a==b;\n}\n\n\n/* i¶ÚÌóðu··é\n   j-1 ÔÚÜÅÌ form ÍNAµÄ¢éÆ·éB\n */\nbool solve(int i,UI j){\n  string s;\n  // ®`FbN\n  for( ; j<formLen;j++ ){\n    s=\"\";\n    UI k;\n    for( k=0;k<form[j].length();k++ ){\n      if( form[j][k]<10 ){   // ¢mÌ¶iójª¶Ý\n\tif( form[j][k]<i )\n\t  s = s + r[ map[(int)form[j][k]] ];\n\telse                 // ¢è¶ª¶Ý·é®\n\t  k = form[j].length()+100;\n      }else\n\ts = s + form[j][k];\n    }\n    if( k>form[j].length() ) break;\n    if( !checkForm( s ) ) // ®ÆÈçÈ©Á½\n      return false;\n  }\n\n  if( j==formLen ) return true;\n  if( i==n ) return false;\n\n  // i+1 ÔÚÌ`FbN\n  // map[i+1] É map[j]!=map[i][j] ( j<i )ÆÈélðãü\n  for( int k=0,l;k<n;k++ ){\n    map[i] = k;\n    for( l=0;l<i;l++ )\n      if( map[i] == map[l] ) break;\n    if( l!=i ) continue;\n    if( solve( i+1,j ) )\n      return true;    \n  }\n  return false;\n}\n\nint main(){\n  while( cin>>h>>w && (h||w) ){\n    int in=0; // ó}XCfbNX\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> m[i][j];\n\tif( m[i][j]=='.' ) m[i][j]=in++;\n      }\n    cin >> n;\n    for( int i=0;i<n;i++ )\n      cin >> r[i];\n\n    formLen=0;\n    string s;\n    // ¡ûüÌ®\n    for( int i=0;i<h;i++ ){\n      for( int j=0;j<w;j++ ){\n\ts=\"\";\n\twhile( m[i][j]=='#' ) j++;\n\twhile( j<w && m[i][j]!='#' ) s+=m[i][j++];\n\tif( s.length()>2 && !checkForm(s) ) form[formLen++] = s;\n      }\n    }\n    // cûüÌ®\n    for( int j=0;j<w;j++ ){\n      for( int i=0;i<h;i++ ){\n\ts=\"\";\n\twhile( m[i][j]=='#' ) i++;\n\twhile( i<h && m[i][j]!='#' ) s+=m[i++][j];\n\tif( s.length()>2 && !checkForm(s) ) form[formLen++] = s;\n      }\n    }\n\n    if( solve( 0,0 ) ) cout << \"Yes\" << endl;\n    else               cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n \nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n \nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n   \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n   \n  return t;\n}\n \n \nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n \nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n \nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n \n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\npair<int,int> BLANKS[NMAX];\n \nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  for (int i = 0; i < n; i++) {\n    TABLE[BLANKS[i].first][BLANKS[i].second] = BLOCK[i];\n  }\n}\n \nchar TEMP[100];\n \nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    y++;\n  }\n  return str;\n}\n \nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    x++;\n  }\n  return str;\n}\n \nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n \nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n \n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n \nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false;\n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n \n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false;\n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (solved()) {\n      return true;\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n  return false;\n}\n \nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n \nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n \n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n \n    int idx = 0;\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n      if (not PRINTED[x][y]) {\n        BLANKS[idx] = make_pair(x, y);\n        idx++;\n      }\n    }\n\n \n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = false;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return /*!operand_connected(str) and*/ equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define UNKNOWN 20\n#define UI unsigned int\nusing namespace std;\nint h,w,n;\nchar m[10][10], r[10];\n//vector<string> form;\nstring form[1000];\nUI formLen;\nint map[10]; // 置換文字への写像\n\nconst int UNCAL = -1111111;\nconst int PLUS  = UNCAL -1;\nconst int MINUS = PLUS  -1;\nint cal( string s ){\n  string a;\n  int v[10];\n  UI vLen=0;//vector<int> v;\n  bool isNum=true;\n  int kind=0; // 0:+,- 1:* 2:/\n  for( UI i=0;i<s.length();i++ ){\n    if( isNum ){\n      a=\"\";\n      while( i<s.length() && '0'<=s[i] && s[i]<='9' ) a+=s[i++];\n      --i;\n\n      if( a.length()==0 ) return UNCAL;\n      if( a[0]=='0' && a.length()!=1 ) return UNCAL;\n      int number = atoi( a.c_str() );\n\n      if( kind==0 ) v[vLen++]=number;\n      else if( kind==1 ){ // *\n\tv[ vLen-1 ] *= number;\n      }else{ // /\n\tif( number==0 ) return UNCAL;\n\tif( v[vLen-1]%number !=0 ) return UNCAL;\n\tv[ vLen-1 ] /= number;\n      }\n    }else{\n      kind = 0;\n      if( s[i]=='+' )      v[ vLen++ ] = PLUS;\n      else if( s[i]=='-' ) v[ vLen++ ] = MINUS;\n      else if( s[i]=='*' ) kind=1;\n      else if( s[i]=='/' ) kind=2;\n      else return UNCAL;\n    }\n    isNum = !isNum;\n  }\n  if( vLen==0 ) return UNCAL;\n\n  int ret = v[0];\n  for( UI i=1;i<vLen;i+=2 ){\n    if( v[i]==PLUS && i+1<vLen ) ret += v[i+1];\n    else if( v[i]==MINUS && i+1<vLen ) ret-=v[i+1];\n    else return UNCAL;\n  }\n\n  return ret;\n}\n\nbool checkForm( string s ){\n  int a,b;\n  UI i=s.find(\"=\");\n\n  if( i==string::npos || i+1==s.length() )\n    return false;\n  if( (a=cal(s.substr(0,i)))==UNCAL )\n    return false;\n  b = cal( s.substr( i+1 ) );\n\n  return a==b;\n}\n\n\n/* i文字目の空白を置換する\n   j-1 番目までの form はクリアしているとする。\n */\nbool solve(int i,UI j){\n  string s;\n  // 数式チェック\n  for( ; j<formLen;j++ ){\n    s=\"\";\n    UI k;\n    for( k=0;k<form[j].length();k++ ){\n      if( form[j][k]<10 ){   // 未知の文字（空白）が存在\n\tif( form[j][k]<i )\n\t  s = s + r[ map[(int)form[j][k]] ];\n\telse                 // 未定文字が存在する数式\n\t  k = form[j].length()+100;\n      }else\n\ts = s + form[j][k];\n    }\n    if( k>form[j].length() ) break;\n    if( !checkForm( s ) ) // 等式とならなかった\n      return false;\n  }\n\n  if( j==formLen ) return true;\n  if( i==n ) return false;\n\n  // i+1 番目のチェック\n  // map[i+1] に map[j]!=map[i][j] ( j<i )となる値を代入\n  for( int k=0,l;k<n;k++ ){\n    map[i] = k;\n    for( l=0;l<i;l++ )\n      if( map[i] == map[l] ) break;\n    if( l!=i ) continue;\n    if( solve( i+1,j ) )\n      return true;    \n  }\n  return false;\n}\n\nint main(){\n  while( cin>>h>>w && (h||w) ){\n    int in=0; // 空白マスインデックス\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> m[i][j];\n\tif( m[i][j]=='.' ) m[i][j]=in++;\n      }\n    cin >> n;\n    for( int i=0;i<n;i++ )\n      cin >> r[i];\n\n    formLen=0;\n    string s;\n    int unknown[1000];\n    // 横方向の数式\n    for( int i=0;i<h;i++ ){\n      for( int j=0;j<w;j++ ){\n\ts=\"\"; int uN=0;\n\twhile( m[i][j]=='#' ) j++;\n\twhile( j<w && m[i][j]!='#' ){\n\t  if( m[i][j]<10 ) uN++;\n\t  s+=m[i][j++];\n\t}\n\tif( s.length()>2 && uN>0 && !checkForm(s) ){\n\t  form[formLen] = s;\n\t  unknown[formLen] = uN;\n\t  formLen++;\n\t}\n      }\n    }\n    // 縦方向の数式\n    for( int j=0;j<w;j++ ){\n      for( int i=0;i<h;i++ ){\n\ts=\"\"; int uN=0;\n\twhile( m[i][j]=='#' ) i++;\n\twhile( i<h && m[i][j]!='#' ){\n\t  if( m[i][j]<10 ) uN++;\n\t  s+=m[i++][j];\n\t}\n\t//\tif( s.length()>2 && !checkForm(s) ){\n\tif( s.length()>2 && uN>0 && !checkForm(s) ){\n\t  form[formLen] = s;\n\t  unknown[formLen] = uN;\n\t  formLen++;\n\t}\n      }\n    }\n    // 未知数の少ないものが先にくるように並び替え\n    bool flag;\n    do{\n      flag=false;\n      for( UI i=1;i<formLen;i++ ){\n\tif( unknown[i-1] < unknown[i] ){\n\t  UI b = unknown[i-1]; unknown[i-1]=unknown[i]; unknown[i]=b;\n\t  s=form[i-1]; form[i-1]=form[i]; form[i]=s;\n\t  flag=true;\n\t}\n      }\n    }while( flag );\n\n\n    if( solve( 0,0 ) ) cout << \"Yes\" << endl;\n    else               cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  \n  void init(){ pos=0;len=s.size();  }\n\n  int head2Num(){\n    int res=0;\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      if(ch=='/')res/=num;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    return res;\n  }\n};\n\nint H,W,N,M;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\n\nbool solve();\nbool check();\nbool compute();\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];   \n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  string str;\n  for(int i=0;i<H;i++){\n    v=\"\";\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#'){\n\tif(v.size()>=3)if(!compute())return false;\n\tv=\"\";\n      }else v.push_back(t[i][j]);\n    }\n    if(v.size()>=3)if(!compute())return false;\n  }\n\n  for(int i=0;i<W;i++){\n    v=\"\";\n    for(int j=0;j<H;j++){\n      if(t[j][i]=='#'){\n\tif(v.size()>=3)if(!compute())return false;\n\tv=\"\";\n      }else v.push_back(t[j][i]);\n    }\n    if(v.size()>=3)if(!compute())return false;\n  }\n  return true;\n}\n\nbool compute(){\n  for(int i=0;i<(int)v.size();i++)\n      if('A'<=v[i]&&v[i]<='Z')v[i]=u[v[i]-'A'];\n  string a=\"\",b=\"\";\n  bool flg=false;\n  b.push_back(v[0]);\n  for(int i=1;i<(int)v.size();i++){\n      if(!isNum(v[i-1])&&!isNum(v[i]))return false;\n      if(v[i]=='=')flg=true;\n      else if(flg)a.push_back(v[i]);\n      else b.push_back(v[i]);\n  }\n  if(!isNum(v[0])||!isNum(v[v.size()-1]))return false;\n  \n  calcStr x,y;\n  x.s=a;\n  x.init();\n  y.s=b;\n  y.init();\n  \n  return (x.getAns()==y.getAns());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ninline pii number(const string& s,int i)\n{\n\tint x=0;\n\tif(i>=s.size() || !isdigit(s[i])) return mp(INF,-1);\n\tfor(int len=0;i<s.size() && isdigit(s[i]);i++,len++){\n\t\tif(len==1 && x==0) return mp(INF,-1);\n\t\tx=x*10+s[i]-'0';\n\t}\n\treturn mp(x,i);\n}\ninline pii term(const string& s,int i)\n{\n\tint x; tie(x,i)=number(s,i);\n\tif(i==-1) return mp(INF,-1);\n\twhile(i<s.size() && (s[i]=='*' || s[i]=='/')){\n\t\tchar op=s[i];\n\t\tint y; tie(y,i)=number(s,i+1);\n\t\tif(i==-1) return mp(INF,-1);\n\t\tif(op=='*') x*=y;\n\t\tif(op=='/'){\n\t\t\tif(y==0 || x%y>0) return mp(INF,-1);\n\t\t\tx/=y;\n\t\t}\n\t}\n\treturn mp(x,i);\n}\ninline pii expr(const string& s,int i)\n{\n\tint x; tie(x,i)=term(s,i);\n\tif(i==-1) return mp(INF,-1);\n\twhile(i<s.size()){\n\t\tchar op=s[i];\n\t\tif(op!='+' && op!='-') return mp(INF,-1);\n\t\tint y; tie(y,i)=term(s,i+1);\n\t\tif(i==-1) return mp(INF,-1);\n\t\tif(op=='+') x+=y;\n\t\tif(op=='-') x-=y;\n\t}\n\treturn mp(x,i);\n}\nint expr(const string& s)\n{\n\treturn expr(s,0).first;\n}\n\nbool check(const vs& grid,const vector<pii>& f)\n{\n\tstring s;\n\tfor(auto p:f) s+=grid[p.first][p.second];\n\tif(count(all(s),'=')!=1) return false;\n\tint eq=s.find('=');\n\tif(eq==0 || eq==s.size()-1) return false;\n\tstring a=s.substr(0,eq),b=s.substr(eq+1);\n\t\n\tint x=expr(a),y=expr(b);\n\t//dump(mt(s,x,y));\n\tif(x==INF || y==INF || x!=y)\n\t\treturn false;\n\treturn true;\n}\n\nbool solve(int i,vs& grid,string& cs,vector<pii>& ps,vector<vector<pii>>& fs,vvi& ds)\n{\n\tint n=ps.size();\n\tif(i==n) return true;\n\t\n\tfor(char& c:cs) if(c!='X'){\n\t\tgrid[ps[i].first][ps[i].second]=c; c='X';\n\t\tif(all_of(all(ds[i]),[&](int j){return check(grid,fs[j]);}))\n\t\t\tif(solve(i+1,grid,cs,ps,fs,ds))\n\t\t\t\treturn true;\n\t\tc=grid[ps[i].first][ps[i].second];\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint n; cin>>n;\n\t\tstring cs(n,'~');\n\t\trep(i,n) cin>>cs[i];\n\t\t\n\t\tvector<pii> ps;\n\t\tvector<vector<pii>> fs;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='.') ps.emplace_back(i,j);\n\t\t\tif(grid[i][j]!='#'){\n\t\t\t\tif((i==0 || grid[i-1][j]=='#') && i<h-1 && grid[i+1][j]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=i;k<h && grid[k][j]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(k,j);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t\tif((j==0 || grid[i][j-1]=='#') && j<w-1 && grid[i][j+1]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=j;k<w && grid[i][k]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(i,k);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvvi ds(n+1);\n\t\t{\n\t\t\tvi vis(fs.size());\n\t\t\trep(i,n+1){\n\t\t\t\trep(j,fs.size()) if(!vis[j]){\n\t\t\t\t\tstring s;\n\t\t\t\t\tfor(auto p:fs[j]) s+=grid[p.first][p.second];\n\t\t\t\t\tif(count(all(s),'.')==0){\n\t\t\t\t\t\tds[i].push_back(j);\n\t\t\t\t\t\tvis[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<n) grid[ps[i].first][ps[i].second]='?';\n\t\t\t}\n\t\t\trep(i,n)\n\t\t\t\tgrid[ps[i].first][ps[i].second]='.';\n\t\t\trotate(begin(ds),1+all(ds));\n\t\t}\n\t\t\n\t\tif(!all_of(all(ds[n]),[&](int j){return check(grid,fs[j]);})){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<(solve(0,grid,cs,ps,fs,ds)?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (r == 0) throw 0;\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(const string &s, int id, bool f=1) {\n  if (s.size() < 2) return 1;\n  // if (f) {\n  //   if ((id == 0 || isoperator(s[id-1])) && (!isdigit(s[id]) || s[id] == '0')) return 0;\n  //   if ((id == s.size()-1 || isoperator(s[id+1])) && !isdigit(s[id])) return 0;\n  // }\n  REP(i,s.size()-1) {\n    if ((i==0 || !isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return 0;\n    if (isoperator(s[i]) && isoperator(s[i+1])) return 0;\n  }\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1 || pos == 0 || pos == s.size()-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<s.size(); ++i) str[i-pos-1] = s[i]; str[s.size()-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == pos.size()) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    // if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first], p.second)) f = 0;\n      }\n    }\n    if (f) {\n      {\n        pii p = yoko[y][x];\n        if (p.first != -1) {\n          v[p.first][p.second] = b[i];\n          if (!check(v[p.first], p.second)) f = 0;\n        }\n      }\n      if (f) {\n        if (dfs(S|1<<i,now+1)) return 1;\n      }\n      {\n        pii p = tate[y][x];\n        if (p.first != -1) {\n          v[p.first][p.second] = '.';\n        }\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    // assert(pos.size() == n);\n    bool ok = 1;\n    FOR(it, v) ok &= check(*it,0,0);\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (ok&&dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nint BADHX, BADHY, BADVX, BADVY;\nstring BADHEQ, BADVEQ;\n\nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  if (x == -1 and y == -1) return \"\";\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADHX = x, BADHY = y;\n        BADHEQ = eq;\n        return false; \n      }\n    } catch (int ex) {\n      BADHX = x, BADHY = y;\n      BADHEQ = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        BADVX = x, BADVY = y;\n        BADVEQ = eq;\n        return false; \n      }\n    } catch(int ex) {\n      BADVX = x, BADVY = y;\n      BADVEQ = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nint factorial(int x) {\n  int sum = 1;\n  for (int i = 1; i <= x; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\nbool nextperm() {\n  while (next_permutation(BLOCK,BLOCK + n)) {\n    fill_blank();\n    if (BADHEQ != geth(BADHX, BADHY) and BADVEQ != getv(BADVX, BADVY)) {\n //     cout << \"o\" << BADHEQ << \" \" << geth(BADHX,BADHY) << \" \" << BADVEQ << \" \" << getv(BADVX, BADVY) << endl;\n      return true;\n    }/* else {\n      cout << \"x\" << BADHEQ << \" \" << geth(BADHX,BADHY) << \" \" << BADVEQ << \" \" << getv(BADVX, BADVY) << endl;\n    }*/\n  }\n  return false;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n//  int consid = 0;\n  do {\n//    if (BADHEQ == geth(BADHX, BADHY)) continue;\n//    if (BADVEQ == getv(BADVX, BADVY)) continue;\n    if (is_illegal_operand()) continue;\n    if (solved()) {\n//      cout << consid << \" / \" << factorial(n) << endl;\n      return true; \n    }/* else {\n      REP(y, H) {\n        REP(x, W) {\n          cout << TABLE[x][y]; \n        }\n        cout << endl;\n      }\n      cout << endl;\n      consid++;\n    }*/\n  } while (nextperm());\n//  cout << consid << \" / \" << factorial(n) << endl;\n  return false;\n}\n\nvoid init() {\n  BADHX = BADHY = BADVX = BADVY = -1;\n  BADHEQ = BADVEQ = \"No\";\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint idx;\nchar s[11];\nbool res;\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-' || s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex();\n\tASRT;\n\tif(a!=b || s[idx]) res=false;\n}\n\nbool parse(){\n\tif(strlen(s)<=2) return true;\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nvector<int> head[2][10],tail[2][10];\nvoid preprocess(){\n\trep(i,h){\n\t\thead[0][i].clear();\n\t\ttail[0][i].clear();\n\n\t\tint p=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\thead[0][i].push_back(p);\n\t\t\t\t\ttail[0][i].push_back(j);\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\thead[1][j].clear();\n\t\ttail[1][j].clear();\n\n\t\tint p=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\thead[1][j].push_back(p);\n\t\t\t\t\ttail[1][j].push_back(i);\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool calc_no_space(){\n\trep(i,h){\n\t\trep(k,head[0][i].size()){\n\t\t\trep(l,tail[0][i][k]-head[0][i][k]) s[l]=B[i][head[0][i][k]+l];\n\t\t\ts[tail[0][i][k]-head[0][i][k]]='\\0';\n\t\t\tif(strchr(s,'.')==0){\n\t\t\t\tif(!parse()) return false;\n\t\t\t\thead[0][i].erase(head[0][i].begin()+k);\n\t\t\t\ttail[0][i].erase(tail[0][i].begin()+k);\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\trep(k,head[1][j].size()){\n\t\t\trep(l,tail[1][j][k]-head[1][j][k]) s[l]=B[head[1][j][k]+l][j];\n\t\t\ts[tail[1][j][k]-head[1][j][k]]='\\0';\n\t\t\tif(strchr(s,'.')==0){\n\t\t\t\tif(!parse()) return false;\n\t\t\t\thead[1][j].erase(head[1][j].begin()+k);\n\t\t\t\ttail[1][j].erase(tail[1][j].begin()+k);\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool isvalid(){\n\trep(i,h){\n\t\trep(k,head[0][i].size()){\n\t\t\trep(l,tail[0][i][k]-head[0][i][k]) s[l]=B[i][head[0][i][k]+l];\n\t\t\ts[tail[0][i][k]-head[0][i][k]]='\\0';\n\t\t\tif(!parse()) return false;\n\t\t}\n\t}\n\n\trep(j,w){\n\t\trep(k,head[1][j].size()){\n\t\t\trep(l,tail[1][j][k]-head[1][j][k]) s[l]=B[head[1][j][k]+l][j];\n\t\t\ts[tail[1][j][k]-head[1][j][k]]='\\0';\n\t\t\tif(!parse()) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tint n; scanf(\"%d\",&n);\n\t\tchar key[10];\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\tint qx[10],qy[10];\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tpreprocess();\n\n\t\tbool ok=false;\n\t\tif(calc_no_space()){\n\t\t\tint p[]={0,1,2,3,4,5,6,7,8,9};\n\t\t\tdo{\n\t\t\t\trep(k,n) B[qy[k]][qx[k]]=key[p[k]];\n\t\t\t\tif(isvalid()){ ok=true; break; }\n\t\t\t}while(next_permutation(p,p+n));\n\t\t}\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,w,n;\nchar bd[10][11];\nchar lst[10];\nint dx[10],dy[10];\n\nint eval(char *expr,int s,int t)\n{\n\tif(s>=t)return inf;\n\t\n\tint p=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='+'||expr[p]=='-')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\treturn expr[p]=='+'?a+b:a-b;\n\t}\n\t\n\tfor(p=t-1;p>=s;p--)if(expr[p]=='*'||expr[p]=='/')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\tif(expr[p]=='/'&&(b==0||a%b!=0))return inf;\n\t\treturn expr[p]=='*'?a*b:a/b;\n\t}\n\t\n\tif(t>s+1&&expr[s]=='0')return inf;\n\t\n\tint ret=0;\n\tfor(p=s;p<t;p++)ret*=10,ret+=expr[p]-'0';\n\treturn ret;\n}\nbool ok(char *expr,int l)\n{\n\tint eq=-1;\n\trep(i,l)if(expr[i]=='=')eq=eq==-1?i:-2;\n\t\n\tassert(eq>=0); assert(l>0);\n\trep(i,l)assert(expr[i]!='.');\n\t\n\tint a=eval(expr,0,eq),b=eval(expr,eq+1,l);\n\treturn a!=inf&&b!=inf&&a==b;\n}\nbool valid(int y,int x)\n{\n\tif(y<0||y>=h||x<0||x>=w)return 0;\n\treturn bd[y][x]!='#';\n}\nint ck(int y,int x)//-1:µ 0:¢mè 1:³µ\n{\n\tint sy,ty,sx,tx;\n\tfor(sy=y-1;valid(sy,x);sy--); for(ty=y+1;valid(ty,x);ty++);\n\tfor(sx=x-1;valid(y,sx);sx--); for(tx=x+1;valid(y,tx);tx++);\n\tsy++; sx++;\n\t\n\tchar tate[11]={0},yoko[11]={0}; int t=0,yo=0;\n\tbool teq=0,yeq=0,tdot=0,ydot=0;\n\tfor(int i=sy;i<ty;i++)\n\t{\n\t\ttate[t++]=bd[i][x];\n\t\tif(bd[i][x]=='=')teq=1;\n\t\telse if(bd[i][x]=='.')tdot=1;\n\t}\n\tfor(int i=sx;i<tx;i++)\n\t{\n\t\tyoko[yo++]=bd[y][i];\n\t\tif(bd[y][i]=='=')yeq=1;\n\t\telse if(bd[y][i]=='.')ydot=1;\n\t}\n\t\n\tint tok,yok;\n\tif(t>1&&!teq||yo>1&&!yeq)return -1;\n\tif(tdot)tok=0; else tok=t<3||ok(tate,t)?1:-1;\n\tif(ydot)yok=0; else yok=yo<3||ok(yoko,yo)?1:-1;\n\t\n\treturn tok<0||yok<0?-1:tok>0&&yok>0?1:0;\n}\nbool rec(int c)\n{\n\tif(c==n)\n\t{\n\t\trep(i,h)rep(j,w)if(bd[i][j]=='='&&ck(i,j)<=0)return 0;\n\t\treturn 1;\n\t}\n\t\n\trep(i,n)if(lst[i])\n\t{\n\t\tbd[dy[c]][dx[c]]=lst[i]; lst[i]=0;\n\t\tif(ck(dy[c],dx[c])>=0&&rec(c+1))return 1;\n\t\tlst[i]=bd[dy[c]][dx[c]]; bd[dy[c]][dx[c]]='.';\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\trep(i,h)scanf(\"%s\",bd[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n)scanf(\" %c\",lst+i);\n\t\t\n\t\tint c=0;\n\t\tbool use[10][10]={0};\n\t\t\n\t\trep(i,h)rep(j,w)if(bd[i][j]=='=')\n\t\t{\n\t\t\tfor(int k=j+1;valid(i,k);k++)if(bd[i][k]=='.'&&!use[i][k])\n\t\t\tuse[i][k]=1,dy[c]=i,dx[c]=k,c++;\n\t\t\t\n\t\t\tfor(int k=j-1;valid(i,k);k--)if(bd[i][k]=='.'&&!use[i][k])\n\t\t\tuse[i][k]=1,dy[c]=i,dx[c]=k,c++;\n\t\t\t\n\t\t\tfor(int k=i+1;valid(k,j);k++)if(bd[k][j]=='.'&&!use[k][j])\n\t\t\tuse[k][j]=1,dy[c]=k,dx[c]=j,c++;\n\t\t\t\n\t\t\tfor(int k=i-1;valid(k,j);k--)if(bd[k][j]=='.'&&!use[k][j])\n\t\t\tuse[k][j]=1,dy[c]=k,dx[c]=j,c++;\n\t\t}\n\t\t\n\t\tputs(rec(0)?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) ((l)<=(x) && (x)<(r))\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1])) ){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nint parse(int l, int r, const string &s){\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=r-1;i>=l;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(l,i,s), b = parse(i+1,r,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=l;i<r;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  int a = parse(0,p,s);\n  int b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (r == 0) throw 0;\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(char *s) {\n  try {\n    int n = strlen(s);\n    int pos = -1;\n    REP(i,strlen(s)) if (s[i]=='=') pos = i;\n    if (pos == -1 || pos == 0 || pos == n-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<n; ++i) str[i-pos-1] = s[i]; str[n-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\n\nchar a[10][10];\nchar b[10];\n\nchar eq[100][11];\n\nint h,w;\n\nbool inserted[10][10];\n\npii pos[100];\nint posNum;\nint eqNum;\nbool visited[10][10][2];\n\nvector<pii> ididx[10][10];\nint dotNum[100];\n\nbool bfs(int y, int x, int dy, int dx) {\n  char s[11];\n  int idx = 0;\n  vector<pii> v;\n  vector<int> id;\n  while(valid(y,x,h,w)) {\n    visited[y][x][dy] = 1;\n    if (a[y][x] == '#') break;\n    if (a[y][x] == '.') {\n      v.push_back(pii(y,x));\n      id.push_back(idx);\n    }\n    s[idx++] = a[y][x];\n    y += dy;\n    x += dx;\n  }\n  if (idx >= 3) {\n    s[idx] = 0;\n    if (v.size() == 0 && !check(s)) return 0;\n    dotNum[eqNum] = v.size();\n    strcpy(eq[eqNum], s);\n    REP(i,v.size()) {\n      int y = v[i].first, x = v[i].second;\n      ididx[y][x].push_back(pii(eqNum,id[i]));\n      if (!inserted[y][x]) {\n        pos[posNum++] = pii(y,x);\n        inserted[y][x] = 1;\n      }\n    }\n    eqNum++;\n  }\n  return 1;\n}\n\nbool checkOp(int id, int idx) {\n  int n = strlen(eq[id]);\n  if (idx==0 || idx==n-1) return 1;\n  if (isoperator(eq[id][idx-1])) return 1;\n  if (isoperator(eq[id][idx+1])) return 1;\n  return 0;\n}\n\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,1,0,-1};\n\nbool isNumOnly(int now, int y, int x) {\n  FOR(it, ididx[y][x]) {\n    int id=it->first;\n    int idx=it->second;\n    if (checkOp(id,idx)) return 1;\n  }\n  return 0;\n}\n\nbool isHead(int now, int y, int x) {\n  FOR(it, ididx[y][x]) {\n    int id=it->first;\n    int idx=it->second;\n    if (idx==0 || isoperator(eq[id][idx-1]))return 1;\n  }\n  return 0;\n}\n\nbool numOnly[100];\n\nint n;\n\nbool dfs(int S, int now) {\n  if (now == posNum) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  FOR(it, ididx[y][x]) {\n    dotNum[it->first]--;\n  }\n  \n  REP(i,n) {\n    if (S>>i&1) continue;\n    if (!isdigit(b[i]) && isNumOnly(now,y,x)) continue;\n    // cout << y << \" \" << x << \" \" << now << \" \" << b[i] << endl;\n    // if (b[i] == '0' && isHead(now,y,x)) continue;\n    bool f = 1;\n    FOR(it, ididx[y][x]) {\n      int id = it->first;\n      int idx = it->second;\n      eq[id][idx] = b[i];\n      if (dotNum[id] == 0) {\n        f &= check(eq[id]);\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n  }\n  FOR(it, ididx[y][x]) {\n    eq[it->first][it->second] = '.';\n    dotNum[it->first]++;\n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    memset(inserted,0,sizeof(inserted));\n    memset(visited,0,sizeof(visited));\n    posNum = 0, eqNum = 0;\n    REP(i,h)REP(j,w)ididx[i][j].clear();\n    memset(dotNum,0,sizeof(dotNum));\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (!visited[i][j][1]) bfs(i,j,1,0);\n        if (!visited[i][j][0]) bfs(i,j,0,1);\n      }\n    }\n    memset(numOnly,0,sizeof(numOnly));\n    REP(i,posNum) {\n      FOR(it, ididx[pos[i].first][pos[i].second]) {\n        numOnly[i] = checkOp(it->first,it->second);\n      }\n    }\n    // REP(i,eqNum) cout << eq[i] << endl;\n    // REP(i,posNum) {\n    //   cout << numOnly[i] << endl;\n    //   cout << pos[i].first << \" \" << pos[i].second << endl;\n    //   FOR(it, ididx[pos[i].first][pos[i].second]) {\n    //     cout << it->first << \":\" << it->second << endl;\n    //   }cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15], string s[15]){\n    string str;\n    int k = 0;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n                s[k++] = str;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n                s[k++] = str;\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h){\n                rep(j,w){\n                    scanf(\"%c\",&m[i + 1][j + 1]);\n                    if(m[i + 1][j + 1] == '.'){\n                        y[k] = i + 1;\n                        x[k] = j + 1;\n                        k++;\n                    }\n                }\n               scanf(\"%*c\");\n            }\n        }\n\n        //if(not check(m)){\n        //    cout << \"NO\" << endl;\n        //    continue;\n        //}\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n\n        string s[15];\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m,s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e15;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  if(!isdigit(s[0]) || !isdigit(s.back()))return false;\n  return true;\n}\n\nll parse(int L, int R, const string &s){\n  assert(R!=L);\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=L;i<R;i++)res = res*10LL + (ll)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  assert(p!=(int)s.size());\n  ll a = parse(0,p,s);\n  ll b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15], vector<string> &s){\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                string str;\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                string str;\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nvector<pair<int, int>> spacePoints(vector<string> s){\n    vector<pair<int, int>> ret;\n    rep(i,s.size()){\n        rep(j,s[i].size()){\n            if(s[i][j] == '.') ret.emplace_back(make_pair(i,j));\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(scanf(\"%d%d\",&h,&w),h){\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h) rep(j,w){\n                cin >> m[i + 1][j + 1];\n                if(m[i + 1][j + 1] == '.'){\n                    y[k] = i + 1;\n                    x[k] = j + 1;\n                    k++;\n                }\n            }\n        }\n\n        int n;\n        cin >> n;\n        vector<char> v;\n        rep(i,n){\n            char x;\n            cin >> x;\n            v.emplace_back(x);\n        }\n\n        vector<string> s;\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m,s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (p < s.size() and isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <exception>\n#include <fstream>\nusing namespace std;\n\nconst int LIM = 10;\n\nint H, W, n;\nchar pz[12][12];\n\nvector<int> bx, by;\nbool used[LIM];\nvector<char> ch;\n\nclass Evaluator {\npublic:\n    static int num(string &s, int &k) {\n        int a = 0;\n        while (isdigit(s[k])) {\n            a = a * 10 + (s[k] - '0'); ++k;\n        }\n        return a;\n    }\n    static int mul(string &s, int &k) {\n        int a = num(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '*') a *= mul(s, ++k);\n            else if (s[k] == '/') {\n                int b = mul(s, ++k);\n                if (b == 0) throw 0; // DivisionByZero\n                else if (a % b != 0) throw 1; // LeavingRemaindar\n                a /= b;\n            }\n            else break;\n        }\n        return a;\n    }\n    static int add(string &s, int &k) {\n        int a = mul(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '+') a += mul(s, ++k);\n            else if (s[k] == '-') a -= mul(s, ++k);\n            else break;\n        }\n        return a;\n    }\n    static bool eq(string &s, int &k) {\n        int a = add(s, k);\n        if (k < (int)s.size() && s[k] == '=') {\n            int b = add(s, ++k);\n            if (k < (int)s.size()) return false;\n            return a == b;\n        }\n        return false;\n    }\n    static bool run(string s) {\n        int k; bool ret;\n        try {\n            ret = eq(s, k=0);\n        } catch (int) {\n            ret = false;\n        }\n        return ret;\n    }\n};\n\nbool issymbol(char c) {\n    return c=='+' || c=='-' || c=='*' || c=='/' || c=='=';\n}\n\nbool ok(int x, int y, char c) {\n    bool ver = true, hor = true;\n    if (pz[y-1][x] == '#' && pz[y+1][x] == '#') ver = false;\n    if (pz[y][x-1] == '#' && pz[y][x+1] == '#') hor = false;\n    if (issymbol(c)) {\n        if (pz[y-1][x] == '#' || pz[y+1][x] == '#' || issymbol(pz[y-1][x]) || issymbol(pz[y+1][x])) ver = false;\n        if (pz[y][x-1] == '#' || pz[y][x+1] == '#' || issymbol(pz[y][x-1]) || issymbol(pz[y][x+1])) hor = false;\n        if ( ! ver && ! hor) return false;\n    } else if (c == '0') {\n        if (pz[y-1][x] == '/' || pz[y][x-1] == '/' || isdigit(pz[y+1][x]) || isdigit(pz[y][x+1])) return false;\n    }\n    int tx, ty; string s; bool blank;\n    if (ver) {\n        blank=false; s=c; ty=y-1;\n        while (pz[ty][x] != '#') {\n            s=pz[ty][x]+s;\n            blank|=(pz[ty][x]=='.');\n            --ty;\n        }\n        ty=y+1;\n        while (pz[ty][x] != '#') {\n            s+=pz[ty][x];\n            blank|=(pz[ty][x]=='.');\n            ++ty;\n        }\n        for (int i=1; i<(int)s.size()-1; ++i) {\n            if ((i == 0 || ! isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return false;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    if (hor) {\n        blank=false; s=c; tx=x-1;\n        while (pz[y][tx] != '#') {\n            s=pz[y][tx]+s;\n            blank|=(pz[y][tx]=='.');\n            --tx;\n        }\n        tx=x+1;\n        while (pz[y][tx] != '#') {\n            s+=pz[y][tx];\n            blank|=(pz[y][tx]=='.');\n            ++tx;\n        }\n        for (int i=0; i<(int)s.size()-1; ++i) {\n            if ((i == 0 || ! isdigit(s[i-1])) && s[i] == '0' && isdigit(s[i+1])) return false;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    return true;\n}\n\nstring solve(int k, int si) {\n    if (n <= k) return \"Yes\";\n    for (int i=si; i<n; ++i) {\n        if ( ! used[i] && ok(bx[i], by[i], ch[k])) {\n            used[i] = true;\n            pz[by[i]][bx[i]] = ch[k];\n            string res = solve(k+1, (n<=k+1 || ch[k+1]==ch[k]) ? i+1 : 0);\n            used[i] = false;\n            pz[by[i]][bx[i]] = '.';\n            if (res == \"Yes\") return res;\n        }\n    }\n    return \"No\";\n}\n\nbool cmb(const char& l, const char& r) {\n    if (l == '=') return true;\n    if (r == '=') return false;\n    return l < r;\n}\n\nint main() {\n    while (cin >> H >> W, H) {\n        for (int i=0; i<12; ++i) {\n            for (int j=0; j<12; ++j) {\n                pz[i][j] = '#';\n            }\n        }\n        bx.clear(); by.clear();\n        for (int i=1; i<=H; ++i) {\n            for (int j=1; j<=W; ++j) {\n                cin >> pz[i][j];\n                if (pz[i][j] == '.') {\n                    bx.push_back(j);\n                    by.push_back(i);\n                }\n            }\n        }\n        cin >> n;\n        ch.clear();\n        char c;\n        for (int i=0; i<n; ++i) {\n            cin >> c;\n            ch.push_back(c);\n        }\n        sort(ch.begin(), ch.end(), cmb);\n        memset(used, false, sizeof used);\n        cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, MAX_N> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint factor(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tint tmp;\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t++it;\n\t\t\ttmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_minus[expression[i - 1]] = true;\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w));\n\tint next = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '.') idx[i][j] = next++;\n\t\t}\n\t}\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tif(is_operator[i] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\t\tif(in[i] == '-' && not_minus[idx]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[i]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) {\n\t\t\t\tnot_zero[e] = true;\n\t\t\t\tnot_minus[e] = true;\n\t\t\t}\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tis_operator.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t\tif(in[i] == '+' || in[i] == '-' || in[i] == '*' || in[i] == '/') {\n\t\t\t\tis_operator[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n\n    //if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    //if(!isNum(s[pos])){flag=true;}\n\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),z;\n    if(pos==len)return res;\n    else if(s[pos]=='*'){\n      pos++;\n      return res*getNum();\n    }else if(s[pos]=='/'){\n      pos++;\n      z=getNum();\n      if(z==0){flag=true;z=1;}\n      else if(res%z!=0)flag=true;\n      return res/z;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len)break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n\n  for(int i=0;i<(int)w.size();i++){\n    if(compute(i)==false)return false;\n  }\n  return true;\n}\n\nbool compute(int x){\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF){\n    return false;\n  }\n\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int UND = 1<<30;\nint h, w;\nchar pz[12][12];\nchar cur[12][12];\nbool used[12][12];\n\nbool ans;\n\nclass Parser\n{\npublic:\n\tstring exp;\n\tint p;\n\tvoid Eq (void );\n\tint Ex (void );\n\tint N (void );\n};\n\nvoid Parser::Eq (void )\n{\n\tint value1 = 0, value2 = 0;\n#if DEBUG\n\tcout << \"exp: \" << exp << endl;\n#endif\n\tvalue1 = Ex();\n\n\tif (value1 == UND ) ans = false;\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tint val = 0;\n\t\tif (exp[p] == '+' ){\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue1 += val;\n\t\t}else{\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue1 -= val;\t\t\n\t\t} // end if\n\t} // end while\n\n\tif (exp[p] == '=' ){\n\t\t++p;\n\t} // end if\n\n\tvalue2 = Ex();\t\t\t\n\n\tif (value2 == UND ) ans = false;\n\n\twhile (exp[p] == '+' || exp[p] == '-' ){\n\t\tint val = 0;\n\t\tif (exp[p] == '+' ){\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue2 += val;\n\t\t}else{\n\t\t\t++p;\n\t\t\tval = Ex();\n\t\t\tif (val == UND ) ans = false;\n\t\t\tvalue2 -= val;\t\t\n\t\t} // end if\n\t} // end while\n\n\tif (value1 != value2 )\n\t\tans = false;\n#if DEBUG\n\tcout << \"ans: \" << (ans ? \"YES\" : \"NO\" ) << endl;\n#endif\n}\n\nint Parser::Ex (void )\n{\n\tint value = N();\n\n\tif (value == UND ) ans = false;\n\n\twhile (exp[p] == '*' || exp[p] == '/' ){\n\t\tif (exp[p] == '*' ){\n\t\t\t++p;\n\t\t\tint val = N();\n\t\t\tif (val == UND ){\n\t\t\t\tvalue = UND;\n\t\t\t\tans = false;\n\t\t\t}else{\n\t\t\t\tvalue *= val;\n\t\t\t} // end if\n\t\t}else{\n\t\t\t++p;\n\t\t\tint val = N();\n//\t\t\tif (value != 0 && val != 0 && value % val == 0 ){\n\t\t\tif (value != UND && val != UND && val != 0 && value % val == 0 ){\n\t\t\t\tvalue /= val;\n\t\t\t}else{\n\t\t\t\tvalue = UND;\n\t\t\t\tans = false;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end while\n\t\n\treturn value;\n}\n\nint Parser::N (void )\n{\n\tint value = 0;\n\tint cnt = 0;\n\tchar first = 0;\n\tif (!isdigit(exp[p] ) )\n\t\treturn UND;\n\n\twhile (isdigit(exp[p] ) ){\n\t\tif (cnt == 0 ){\n\t\t\tfirst = exp[p];\n\t\t} // end if\n\t\tvalue *= 10;\n\t\tvalue += (exp[p] - '0');\n\t\tcnt++;\n\t\tp++;\n\t} // end while\n\n\tif ( (first == '0' && cnt > 1 ) || (cnt > 2 ) )\n\t\tans = false;\n\n\treturn value;\n}\n\nvoid disp_pz (void )\n{\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tcout << cur[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep \n}\n\n\nvoid make_pz (vector<char> ope )\n{\n\tmemset (cur, 0, sizeof (cur ) );\n\tint k = 0;\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tif (pz[i][j] == '.' ){\n\t\t\t\tcur[i][j] = ope[k++];\n\t\t\t}else{\n\t\t\t\tcur[i][j] = pz[i][j];\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n#if DEBUG\n\tdisp_pz ();\n\tcout << endl;\n#endif\n}\n\nbool evaluate_exp (string exp )\n{\n//\tcout << exp << endl;\n\tParser parser;\n\tparser.exp = exp;\n\tparser.p = 0;\n\tans = true;\n\tparser.Eq();\n\n\treturn ans;\t\n}\n\nbool is_correct (void )\n{\n\tconst int dir[][2] = { { 0, 0 }, { 1, 0 }, { 0, 1 } };\n\n\tmemset (used, false, sizeof (used ) );\n\tstack<P> u;\n\trep (i, h ){\n\t\trep (j, w ){\n\t\t\tif (cur[i][j] != '#' ){\n\t\t\t\tint k1 = 0, k2 = 0;\n\t\t\t\tif (!used[i][j] ){\n\t\t\t\t\tk1 = 0, k2 = 2;\n\t\t\t\t}else{ // if (used[i][j] )\n\t\t\t\t\tint dsum = 0;\n\t\t\t\t\trep (d, 3 ){\n\t\t\t\t\t\tint ni = i + dir[d][0];\n\t\t\t\t\t\tint nj = j + dir[d][1];\n\t\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= h || nj >= w || cur[ni][nj] == '#' ) continue;\n\t\t\t\t\t\tif (!used[ni][nj] ){\n\t\t\t\t\t\t\tdsum += d;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end rep\n\t\t\t\t\tswitch (dsum ){\n\t\t\t\t\t\tcase 1: k1 = 0, k2 = 1; break;\n\t\t\t\t\t\tcase 2: k1 = 1, k2 = 2; break;\n\t\t\t\t\t\tcase 3: k1 = 0, k2 = 2; break;\n\t\t\t\t\t\tdefault: k1 = 0, k2 = 0; break;\n\t\t\t\t\t} // end switch\n\t\t\t\t} // end if\n\t\t\t\tfor (int k = k1; k < k2; k++ ){\n\t\t\t\t\tbool equ = false;\n\t\t\t\t\tstring exp = \"\";\n\t\t\t\t\tfor (int e = (k == 0 ? i : j ); e < (k == 0 ? h : w ); e++ ){\n\t\t\t\t\t\tint row = (k == 0 ? e : i );\n\t\t\t\t\t\tint col = (k == 0 ? j : e );\n\t\t\t\t\t\tif (cur[row][col] != '#' ){\n\t\t\t\t\t\t\tif (cur[row][col] != '=' ){\n\t\t\t\t\t\t\t\texp += cur[row][col];\n\t\t\t\t\t\t\t\tused[row][col] = true;\n\t\t\t\t\t\t\t\tu.push (P (row, col ) );\n\t\t\t\t\t\t\t}else\n\t\t\t\t\t\t\tif (!equ ){\n\t\t\t\t\t\t\t\texp += cur[row][col];\n\t\t\t\t\t\t\t\tused[row][col] = true;\n\t\t\t\t\t\t\t\tu.push (P (row, col ) );\n\t\t\t\t\t\t\t\tequ = true;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t}else{ // if (cur[row][col] == '#' )\n\t\t\t\t\t\t\tif (equ ){\n\t\t\t\t\t\t\t\twhile (!u.empty() ) u.pop();\n\t\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\tequ = false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\twhile (!u.empty() ){\n\t\t\t\t\t\t\t\t\tP c = u.top(); u.pop();\n\t\t\t\t\t\t\t\t\tused[c.first][c.second] = false;\n\t\t\t\t\t\t\t\t} // end while\n\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t\texp = \"\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end for\n\t\t\t\t\tif (!exp.empty() ){\n\t\t\t\t\t\tif (equ ){\n\t\t\t\t\t\t\twhile (!u.empty() ) u.pop();\n\t\t\t\t\t\t\tif (!evaluate_exp (exp ) )\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\twhile (!u.empty() ){\n\t\t\t\t\t\t\t\tP c = u.top(); u.pop();\n\t\t\t\t\t\t\t\tused[c.first][c.second] = false;\n\t\t\t\t\t\t\t} // end while\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\texp = \"\";\n\t\t\t\t\t} // end if\n\t\t\t\t} // end for\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\treturn true;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.indian_puzzle2\", \"r\", stdin );\n\twhile (cin >> h >> w && h && w ){\n\t\tmemset (pz, 0, sizeof (pz ) );\n\t\trep (i, h ){\n\t\t\tstring in = \"\";\n\t\t\tcin >> in;\n\t\t\trep (j, w ){\n\t\t\t\tpz[i][j] = in[j];\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<char> ope (n, 0 );\n\t\trep (i, n ){\n\t\t\tcin >> ope[i];\n\t\t} // end rep\n\t\tsort (ALL (ope ) );\n\t\tbool found = false;\n\t\tdo{\n/*\n\t\t\trep (i, ope.size() )\n\t\t\t\tcout << ope[i];\n\t\t\tcout << endl;\n*/\n\t\t\tmake_pz (ope );\n\t\t\tif (is_correct () ){\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t}while (next_permutation (ALL (ope ) ) );\n\t\t\n\t\tif (found ){\n\t\t\tprintf (\"Yes\\n\" );\n\t\t}else{\n\t\t\tprintf (\"No\\n\" );\n\t\t} // end if\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n \nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n \nresult equation(const string &s, int p) {\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n   \n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n   \n  return t;\n}\n \n \nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n \nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n \nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n \n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\npair<int,int> BLANKS[NMAX];\n \nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  for (int i = 0; i < n; i++) {\n    TABLE[BLANKS[i].first][BLANKS[i].second] = BLOCK[i];\n  }\n}\n \nchar TEMP[100];\n \nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    y++;\n  }\n  return str;\n}\n \nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') {\n    str.push_back(TABLE[x][y]);\n    x++;\n  }\n  return str;\n}\n \nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n \nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n \n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n \nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n \nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false;\n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n \n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false;\n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (solved()) {\n      return true;\n    }\n  } while (next_permutation(BLOCK, BLOCK + n));\n  return false;\n}\n \nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n \nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n \n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n \n    int idx = 0;\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n      if (not PRINTED[x][y]) {\n        BLANKS[idx] = make_pair(x, y);\n        idx++;\n      }\n    }\n\n \n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (cur % tmp > 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq[0] == '-') return false;\n    if (!isdigit(eq[0]) || !isdigit(eq.back())) return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') return false;\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n    if (!succ) return false;\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n\n  void init(){ pos=0;len=s.size();flag=false;}\n\n  int head2Num(){\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    char ch;\n    while(s[pos]=='*'||s[pos]=='/'){\n      ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      else if(ch=='/'){\n\tif(num==0){flag=true;num=1;}\n\tif(res%num>0)flag=true;\n\tres/=num;\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    if(!isNum(s[0]))return INF;\n    for(int i=1;i+1<len;i++)if(!isNum(s[i-1])&&!isNum(s[i]))return INF;\n\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3&&e>0&&e+1<tmp.size()){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3&&e>0&&e+1<tmp.size()){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3&&e>0&&e+1<tmp.size()){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3&&e>0&&e+1<tmp.size()){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++)if(!compute(i))return false;\n  return true;\n}\n\nbool compute(int x){\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.s.push_back('=');\n  b.s.push_back('=');\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, MAX_N> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<bool, MAX_N> not_minus;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint number(string::const_iterator &it) {\n\tint res = 0;\n\twhile(isdigit(*it)) {\n\t\tres = res * 10 + (*it - '0');\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint factor(string::const_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\tthrow \"parse error\";\n}\n\nint term(string::const_iterator &it) {\n\tint res = factor(it);\n\twhile(true) {\n\t\tint tmp;\n\t\tswitch(*it) {\n\t\tcase '*':\n\t\t\t++it;\n\t\t\tres *= factor(it);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\t++it;\n\t\t\ttmp = factor(it);\n\t\t\tif(tmp == 0) throw \"division by zero\";\n\t\t\tif(res % tmp) throw \"division leaving a remainder\";\n\t\t\tres /= tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t\t++it;\n\t}\n\treturn res;\n}\n\nint expr(string::const_iterator &it) {\n\tint res = term(it);\n\twhile(true) {\n\t\tswitch(*it) {\n\t\tcase '+':\n\t\t\t++it;\n\t\t\tres += term(it);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t++it;\n\t\t\tres -= term(it);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tstring::const_iterator l_it = left.cbegin(), r_it = right.cbegin();\n\t\tif(expr(l_it) != expr(r_it)) return false;\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_minus[expression[i - 1]] = true;\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i) {\n\t\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_minus[expression[i]] = true;\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w, -1));\n\tint next = 0;\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\tif(idx[k][j] == -1) idx[k][j] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\tif(idx[i][k] == -1) idx[i][k] = next++;\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(max_index == -1) continue;\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tif(is_operator[i] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\t\tif(in[i] == '-' && not_minus[idx]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[i]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e];\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tis_operator.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tnot_minus.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t\tif(in[i] == '+' || in[i] == '-' || in[i] == '*' || in[i] == '/') {\n\t\t\t\tis_operator[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  \n  void init(){ pos=0;len=s.size();  }\n\n  int head2Num(){\n    int res=0;\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      if(ch=='/')res/=num;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    return res;\n  }\n};\n\nint H,W,N,M;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\n\nbool solve();\nbool check();\nbool compute();\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];   \n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  string str;\n  for(int i=0;i<H;i++){\n    v=\"\";\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#'){\n\tif(v.size()>=3)if(!compute())return false;\n\tv=\"\";\n      }else v.push_back(t[i][j]);\n    }\n    if(v.size()>=3)if(!compute())return false;\n  }\n\n  for(int i=0;i<W;i++){\n    v=\"\";\n    for(int j=0;j<H;j++){\n      if(t[j][i]=='#'){\n\tif(v.size()>=3)if(!compute())return false;\n\tv=\"\";\n      }else v.push_back(t[j][i]);\n    }\n    if(v.size()>=3)if(!compute())return false;\n  }\n  return true;\n}\n\nbool compute(){\n  for(int i=0;i<(int)v.size();i++)\n      if('A'<=v[i]&&v[i]<='Z')v[i]=u[v[i]-'A'];\n  string a=\"\",b=\"\";\n  bool flg=false;\n  b.push_back(v[0]);\n  for(int i=1;i<(int)v.size();i++){\n      if(!isNum(v[i-1])&&!isNum(v[i]))return false;\n      if(v[i]=='=')flg=true;\n      else if(flg)a.push_back(v[i]);\n      else b.push_back(v[i]);\n  }\n  if(!isNum(v[0])||!isNum(v[v.size()-1]))return false;\n  \n  calcStr x,y;\n  x.s=a;\n  x.init();\n  y.s=b;\n  y.init();\n  \n  return (x.getAns()==y.getAns());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// 4:37\n// 4:40 coding\n\nvector< pair<int,int> > pos;\nvector<string> expr;\n\nchar nowtable[128];\nstring s;\nint p;\nint A();\nint B();\nint C();\nint D();\nint calc(string _str){\n\ttry{\n\t\tp = 0;\n\t\ts = _str;\n\t\ts += \"~\";\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( s[i] >= 'A' && s[i] <= 'Z' ){\n\t\t\t\tif( nowtable[s[i]] == 0 ) return 2;\n\t\t\t\ts[i] = nowtable[s[i]];\n\t\t\t}\n\t\t}\n\t\tint res = A();\n\t\t\n\t\tif( s[p] != '~' ) throw \"not end\";\n\t\treturn res;\n\t}catch(const char *msg){\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\nint A(){\n\t\n\tint x = B();\n\tif( s[p] == '=' ){\n\t\tp++;\n\t\tint y = B();\n\t\treturn x == y;\n\t}else{\n\t\tthrow \"A\";\n\t}\n}\nint B(){\n\tint x = C();\n\twhile( s[p] == '+' || s[p] == '-' ){\n\t\tif( s[p] == '+'){\n\t\t\tp++;\n\t\t\tx += C();\n\t\t}else{\n\t\t\tp++;\n\t\t\tx -= C();\n\t\t}\n\t}\n\treturn x;\n}\nint C(){\n\tint x = D();\n\twhile( s[p] == '*' || s[p] == '/' ){\n\t\tif( s[p] == '*'){\n\t\t\tp++;\n\t\t\tx *= D();\n\t\t}else{\n\t\t\tp++;\n\t\t\tint r = D();\n\t\t\tif(r==0) throw \"zero\";\n\t\t\tif(x%r) throw \"modulo\";\n\t\t\tx /= r;\n\t\t}\n\t}\n\treturn x;\n}\nint D(){\n\t\n\tint x = 0;\n\n\tif( !(s[p]>='1'&&s[p]<='9') ) throw \"wrong number\";\n\twhile( s[p]>='1'&&s[p]<='9'){\n\t\tx = x*10+s[p++]-'0';\n\t}\n\t\n\treturn x;\n}\n\nchar t[12][12];\nvector<char> use;\n\nint used[10];\nvector<string> hoge;\nint check(){\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint r = calc(hoge[i]);\n\t\tif( r == 2 ) continue;\n\t\tif( !r ) return 0;\n\t}\n\treturn 1;\n}\nint N;\nint dfs(){\n\tif( !check() ) return 0;\n\tvector< pair<int,int> > v;\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint c = 0;\n\t\tfor(int j = 0 ; j < hoge[i].size() ; j++){\n\t\t\tif( nowtable[hoge[i][j]] == 0 ){\n\t\t\t\t\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif(c){\n\t\t\tv.push_back(make_pair(c,i));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tif( v.size() == 0 ) return 1;\n\t\n\tint idx = v[0].second;\n\tfor(int j = 0 ; j < hoge[idx].size() ; j++){\n\t\tif( nowtable[hoge[idx][j]] == 0 ){\n\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\tif( !used[k] ){\n\t\t\t\t\tnowtable[hoge[idx][j]] = use[k];\n\t\t\t\t\tused[k] = true;\n\t\t\t\t\tif( dfs() ) return true;\n\t\t\t\t\tused[k] = false;\n\t\t\t\t\tnowtable[hoge[idx][j]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\t\n\tint H,W;\n\twhile( cin >> H >> W && H){\n\t\tfor(int i = 0 ; i < 128 ; i++) nowtable[i] = -1;\n\t\tfor(int i = 0 ; i < 10 ; i++) used[i] = 0;\n\t\tfor(int i = 'A' ; i <= 'Z' ; i++) nowtable[i] = 0;\n\t\t\n\t\tfor(int i = 0 ; i < 12 ; i++)\n\t\t\tfor(int j = 0 ; j < 12 ; j++)\n\t\t\t\tt[i][j] = '#';\n\t\n\t\tchar tmpAlpha = 'A';\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> t[i+1][j+1];\n\t\t\t\tif( t[i+1][j+1] == '.' ){\n\t\t\t\t\tt[i+1][j+1] = tmpAlpha++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tchar c; cin >> c;\n\t\t\tuse.push_back(c);\n\t\t}\n\t\tint ans = 0;\n\t\tvector<string> id;\n\t\t\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( t[i][j-1] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = j;\n\t\t\t\t\twhile( t[i][k] != '#' ){\n\t\t\t\t\t\tstr += t[i][k++];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( t[i-1][j] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = i;\n\t\t\t\t\twhile( t[k][j] != '#' ){\n\t\t\t\t\t\tstr += t[k++][j];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (dfs()?\"yes\":\"no\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 10;\nconstexpr int MAX_N = 10;\n\nint h, w;\narray<string, MAX_SIZE> puzzle;\n\nint n;\narray<char, MAX_N> in;\n\narray<char, 128> letters;\narray<bool, MAX_N> is_operator;\narray<bool, MAX_N> not_operator;\narray<bool, MAX_N> not_zero;\narray<unordered_set<int>, MAX_N> left_idx, right_idx;\n\nint parse(const string &s, int l, int r) {\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '+') return parse(s, l, i) + parse(s, i + 1, r);\n\t\tif(s[i] == '-') return parse(s, l, i) - parse(s, i + 1, r);\n\t}\n\n\tfor(int i = r - 1; i >= l; --i) {\n\t\tif(s[i] == '*') return parse(s, l, i) * parse(s, i + 1, r);\n\t\tif(s[i] == '/') {\n\t\t\tconst int left = parse(s, l, i);\n\t\t\tconst int right = parse(s, i + 1, r);\n\n\t\t\tif(right == 0) throw \"division by zero\";\n\t\t\tif(left % right) throw \"division leaving a remainder\";\n\n\t\t\treturn left / right;\n\t\t}\n\t}\n\n\tif(r <= l || !isdigit(s[l]) || (s[l] == '0' && r - l > 1)) throw \"parse error\";\n\treturn stoi(s.substr(l, r - l));\n}\n\nbool valid(const vector<int> &expression) {\n\tconst int n = expression.size();\n\tstring left = \"\", right = \"\";\n\tint i;\n\n\tfor(i = 0; i < n; ++i) {\n\t\tif(expression[i] == '=') break;\n\t\tleft += letters[expression[i]];\n\t}\n\n\tfor(++i; i < n; ++i) {\n\t\tright += letters[expression[i]];\n\t}\n\n\ttry {\n\t\tif(parse(left, 0, left.size()) != parse(right, 0, right.size())) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcatch(const char *c) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool calc(int &x, int &y, int dx, int dy) {\n\twhile(0 <= x && x < w && 0 <= y && y < h) {\n\t\tif(puzzle[y][x] == '=') return false;\n\t\tif(puzzle[y][x] == '#') {\n\t\t\tx -= dx;\n\t\t\ty -= dy;\n\t\t\treturn true;\n\t\t}\n\t\tx += dx;\n\t\ty += dy;\n\t}\n\tx -= dx;\n\ty -= dy;\n\treturn true;\n}\n\nvoid update(const vector<int> &expression) {\n\tfor(unsigned i = 0; i < expression.size(); ++i) {\n\t\tif(isdigit(expression[i])) {\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_zero[expression[i - 1]] = true;\n\t\t\t}\n\t\t}\n\t\telse if(expression[i] < MAX_SIZE) { // space\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tleft_idx[expression[i]].insert(expression[i - 1]);\n\t\t\t\tright_idx[expression[i - 1]].insert(expression[i]);\n\t\t\t}\n\t\t}\n\t\telse { // operator\n\t\t\tif(i && expression[i - 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i - 1]] = true;\n\t\t\t}\n\t\t\tif(i + 1 < expression.size() && expression[i + 1] < MAX_SIZE) {\n\t\t\t\tnot_operator[expression[i + 1]] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<pair<int, vector<int>>> construct() {\n\tvector<vector<int>> idx(h, vector<int>(w));\n\tint next = 0;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '.') idx[i][j] = next++;\n\t\t}\n\t}\n\n\tvector<pair<int, vector<int>>> expressions;\n\texpressions.reserve(40);\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(puzzle[i][j] == '=') {\n\t\t\t\t// vertical\n\t\t\t\tint s = i - 1, g = i + 1;\n\t\t\t\tif(calc(j, s, 0, -1) && calc(j, g, 0, 1) && s != i && g != i) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[k][j] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[k][j]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\n\t\t\t\t// horizontal\n\t\t\t\ts = j - 1; g = j + 1;\n\t\t\t\tif(calc(s, i, -1, 0) && calc(g, i, 1, 0) && s != j && g != j) {\n\t\t\t\t\tvector<int> expression;\n\t\t\t\t\texpression.reserve(g - s + 1);\n\t\t\t\t\tint max_index = -1;\n\t\t\t\t\tfor(int k = s; k <= g; ++k) {\n\t\t\t\t\t\tif(puzzle[i][k] == '.') {\n\t\t\t\t\t\t\texpression.emplace_back(idx[i][k]);\n\t\t\t\t\t\t\tmax_index = max(max_index, idx[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texpression.emplace_back(puzzle[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tupdate(expression);\n\t\t\t\t\texpressions.emplace_back(max_index, expression);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(expressions.begin(), expressions.end());\n\treturn expressions;\n}\n\nbool dfs(const vector<pair<int, vector<int>>> &expressions, int next, int idx, int used) {\n\twhile(next < expressions.size() && expressions[next].first < idx) {\n\t\tif(!valid(expressions[next].second)) return false;\n\t\t++next;\n\t}\n\tif(next == expressions.size()) return true;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(used & (1 << i)) continue;\n\t\tif(is_operator[i] && not_operator[idx]) continue;\n\t\tif(in[i] == '0' && not_zero[idx]) continue;\n\n\t\tletters[idx] = in[i];\n\t\tconst auto t_no = not_operator;\n\t\tconst auto t_nz = not_zero;\n\n\t\tif(is_operator[i]) {\n\t\t\tfor(const auto &e : left_idx[idx]) not_operator[e] = true;\n\t\t\tfor(const auto &e : right_idx[idx]) not_operator[e] = true;\n\t\t}\n\t\telse {\n\t\t\tfor(const auto &e : left_idx[idx]) not_zero[e] = true;\n\t\t}\n\n\t\tif(dfs(expressions, next, idx + 1, used | (1 << i))) return true;\n\t\tnot_operator = t_no;\n\t\tnot_zero = t_nz;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tiota(begin(letters), end(letters), 0);\n\n\twhile(cin >> h >> w && h) {\n\t\tis_operator.fill(false);\n\t\tnot_operator.fill(false);\n\t\tnot_zero.fill(false);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tleft_idx[i].clear();\n\t\t\tright_idx[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> puzzle[i];\n\t\t}\n\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> in[i];\n\t\t}\n\t\trandom_shuffle(in.begin(), in.begin() + n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(in[i] == '+' || in[i] == '-' || in[i] == '*' || in[i] == '/') {\n\t\t\t\tis_operator[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tconst auto expressions = construct();\n\t\tcout << (dfs(expressions, 0, 0, 0) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n\n  void init(){ pos=0;len=s.size();flag=false;}\n\n  int head2Num(){\n    if(!isNum(s[pos]))flag=true;\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n\tres*=10;\n\tres+=(s[pos]-'0');\n\tpos++;\n      }else break;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    char ch;\n    while(s[pos]=='*'||s[pos]=='/'){\n      ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      else if(ch=='/'){\n\tif(num==0){flag=true;num=1;}\n\tif(res%num>0)flag=true;\n\tres/=num;\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n      else return INF;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3&&e>0&&e<tmp.size()){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3&&e>0&&e<tmp.size()){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3&&e>0&&e<tmp.size()){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3&&e>0){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++){\n    if(!compute(i))return false;\n  }\n  return true;\n}\n\nbool compute(int x){\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.s.push_back('=');\n  b.s.push_back('=');\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto s : check[k]){\n            string s1, s2;\n            for(auto& c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<int> bx, by;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bx.push_back(x); by.push_back(y); grid[y][x] = bx.size() - 1 + 'a';}\n\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 1 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 1 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nbool ck(); bool ck2(bool,int,int,int);\nbool rec(); bool rec2(bool,int,int,int);\n\nint h,w,n;\nchar bd[10][11];\nchar lst[10];\n\nint eval(char *expr,int s,int t)\n{\n\t//dbg(expr); for(int i=s;i<t;i++)assert(expr[i]!='.');\n\tint p=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='+'||expr[p]=='-')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\treturn expr[p]=='+'?a+b:a-b;\n\t}\n\tp=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='*'||expr[p]=='/')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\tif(expr[p]=='/'&&(b==0||a%b!=0))return inf;\n\t\treturn expr[p]=='*'?a*b:a/b;\n\t}\n\t\n\tif(t>s+1&&expr[s]=='0')return inf;\n\tint ret=0;\n\tfor(p=t-1;p>=s;p--)ret*=10,ret+=expr[p]-'0';\n\treturn ret;\n}\nbool ck2(bool tate,int y,int b,int x)\n{\n\tchar lhs[11]={0},rhs[11]={0}; int l=0,r=0;\n\tif(tate)\n\t{\n\t\tfor(;b<y;b++)\n\t\t{\n\t\t\tif(bd[b][x]=='=')break;\n\t\t\tlhs[l++]=bd[b][x];\n\t\t}\n\t\tb++;\n\t\tfor(;b<y;b++)rhs[r++]=bd[b][x];\n\t}\n\telse\n\t{\n\t\tfor(;b<x;b++)\n\t\t{\n\t\t\tif(bd[y][b]=='=')break;\n\t\t\tlhs[l++]=bd[y][b];\n\t\t}\n\t\tb++;\n\t\tfor(;b<x;b++)rhs[r++]=bd[y][b];\n\t}\n\t\n\tint a=eval(lhs,0,l); b=eval(rhs,0,r);\n\treturn a!=inf&&b!=inf&&a==b;\n}\nbool ck()\n{\n\trep(i,h)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(j,w+1)\n\t\t{\n\t\t\tif(j==w||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&!dot)\n\t\t\t\t{\n\t\t\t\t\tif(!ck2(0,i,beg,j))return 0;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=j+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\trep(j,w)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(i,h+1)\n\t\t{\n\t\t\tif(i==h||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&!dot)\n\t\t\t\t{\n\t\t\t\t\tif(!ck2(1,i,beg,j))return 0;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=i+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\t\n\treturn 1;\n}\nbool rec2(bool tate,int y,int b,int x)\n{\n\t//cerr<<tate<<\" \"<<y<<\" \"<<b<<\" \"<<x<<endl;\n\tif(tate)\n\t{\n\t\tassert(b<=y);\n\t\tif(y==b)return ck()&&rec();\n\t\tif(bd[b][x]!='.')return rec2(1,y,b+1,x);\n\t\trep(i,n)if(lst[i])\n\t\t{\n\t\t\tbd[b][x]=lst[i]; lst[i]=0;\n\t\t\tif(rec2(1,y,b+1,x))return 1;\n\t\t\tlst[i]=bd[b][x]; bd[b][x]='.';\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(x==b)return ck()&&rec();\n\t\tif(bd[y][b]!='.')return rec2(0,y,b+1,x);\n\t\trep(i,n)if(lst[i])\n\t\t{\n\t\t\tbd[y][b]=lst[i]; lst[i]=0;\n\t\t\tif(rec2(0,y,b+1,x))return 1;\n\t\t\tlst[i]=bd[y][b]; bd[y][b]='.';\n\t\t}\n\t}\n\treturn 0;\n}\nbool rec()\n{\n\trep(i,h)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(j,w+1)\n\t\t{\n\t\t\tif(j==w||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&dot)\n\t\t\t\t{\n\t\t\t\t\tif(rec2(0,i,beg,j))return 1;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=j+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\trep(j,w)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(i,h+1)\n\t\t{\n\t\t\tif(i==h||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&dot)\n\t\t\t\t{\n\t\t\t\t\tif(rec2(1,i,beg,j))return 1;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=i+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\t\n\trep(i,h)rep(j,w)if(bd[i][j]=='.')return 0;\n\treturn ck();\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\trep(i,h)scanf(\"%s\",bd[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n)scanf(\" %c\",lst+i);\n\t\t\n\t\tputs(rec()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <exception>\nusing namespace std;\n\nconst int LIM = 10;\n\nint H, W, n;\nchar pz[12][12];\n\nvector<int> bx, by;\nbool used[LIM];\nvector<char> ch;\n\nclass Evaluator {\npublic:\n    static int num(string &s, int &k) {\n        int a = 0;\n        while (isdigit(s[k])) {\n            a = a * 10 + (s[k] - '0'); ++k;\n        }\n        return a;\n    }\n    static int mul(string &s, int &k) {\n        int a = num(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '*') a *= mul(s, ++k);\n            else if (s[k] == '/') {\n                int b = mul(s, ++k);\n                if (b == 0) throw 0; // DivisionByZero\n                else if (a % b != 0) throw 1; // LeavingRemaindar\n                a /= b;\n            }\n            else break;\n        }\n        return a;\n    }\n    static int add(string &s, int &k) {\n        int a = mul(s, k);\n        while (k < (int)s.size()) {\n            if (s[k] == '+') a += mul(s, ++k);\n            else if (s[k] == '-') a -= mul(s, ++k);\n            else break;\n        }\n        return a;\n    }\n    static bool eq(string &s, int &k) {\n        int a = add(s, k);\n        if (k < (int)s.size() && s[k] == '=') {\n            int b = add(s, ++k);\n            if (k < (int)s.size()) return false;\n            return a == b;\n        }\n        return false;\n    }\n    static bool run(string s) {\n        int k; bool ret;\n        try {\n            ret = eq(s, k=0);\n        } catch (int) {\n            ret = false;\n        }\n        return ret;\n    }\n};\n\nbool issymbol(char c) {\n    return c=='+' || c=='-' || c=='*' || c=='/' || c=='=';\n}\n\nbool ok(int x, int y, char c) {\n    bool ver = true, hor = true;\n    if (pz[y-1][x] == '#' && pz[y+1][x] == '#') ver = false;\n    if (pz[y][x-1] == '#' && pz[y][x+1] == '#') hor = false;\n    if (issymbol(c)) {\n        if (pz[y-1][x] == '#' || pz[y+1][x] == '#' || issymbol(pz[y-1][x]) || issymbol(pz[y+1][x])) ver = false;\n        if (pz[y][x-1] == '#' || pz[y][x+1] == '#' || issymbol(pz[y][x-1]) || issymbol(pz[y][x+1])) hor = false;\n        if ( ! ver && ! hor) return false;\n    } else if (c == '0') {\n        if (pz[y-1][x] == '/' || pz[y][x-1] == '/' || isdigit(pz[y+1][x]) || isdigit(pz[y][x+1])) return false;\n    }\n    int tx, ty; string s; bool blank;\n    if (ver) {\n        blank=false; s=c; ty=y-1;\n        while (pz[ty][x] != '#') {\n            s=pz[ty][x]+s;\n            blank|=(pz[ty][x]=='.');\n            --ty;\n        }\n        ty=y+1;\n        while (pz[ty][x] != '#') {\n            s+=pz[ty][x];\n            blank|=(pz[ty][x]=='.');\n            ++ty;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    if (hor) {\n        blank=false; s=c; tx=x-1;\n        while (pz[y][tx] != '#') {\n            s=pz[y][tx]+s;\n            blank|=(pz[y][tx]=='.');\n            --tx;\n        }\n        tx=x+1;\n        while (pz[y][tx] != '#') {\n            s+=pz[y][tx];\n            blank|=(pz[y][tx]=='.');\n            ++tx;\n        }\n        if (1<(int)s.size() && ! blank && ! Evaluator::run(s)) return false;\n    }\n    return true;\n}\n\nstring solve(int k, int si) {\n    if (n <= k) return \"Yes\";\n    for (int i=si; i<n; ++i) {\n        if ( ! used[i] && ok(bx[i], by[i], ch[k])) {\n            used[i] = true;\n            pz[by[i]][bx[i]] = ch[k];\n            string res = solve(k+1, (n<=k+1 || ch[k+1]==ch[k]) ? i+1 : 0);\n            used[i] = false;\n            pz[by[i]][bx[i]] = '.';\n            if (res == \"Yes\") return res;\n        }\n    }\n    return \"No\";\n}\n\nbool cmb(const char& l, const char& r) {\n    if (l == '=') return true;\n    if (r == '=') return false;\n    return l < r;\n}\n\nint main() {\n    while (cin >> H >> W, H) {\n        for (int i=0; i<12; ++i) {\n            for (int j=0; j<12; ++j) {\n                pz[i][j] = '#';\n            }\n        }\n        bx.clear(); by.clear();\n        for (int i=1; i<=H; ++i) {\n            for (int j=1; j<=W; ++j) {\n                cin >> pz[i][j];\n                if (pz[i][j] == '.') {\n                    bx.push_back(j);\n                    by.push_back(i);\n                }\n            }\n        }\n        cin >> n;\n        ch.clear();\n        char c;\n        for (int i=0; i<n; ++i) {\n            cin >> c;\n            ch.push_back(c);\n        }\n        sort(ch.begin(), ch.end(), cmb);\n        memset(used, false, sizeof used);\n        cout << solve(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,w,n;\nchar bd[10][11];\nchar lst[10];\nint dx[10],dy[10];\n\nint eval(char *expr,int s,int t)\n{\n\tif(s>=t)return inf;\n\t\n\tint p=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='+'||expr[p]=='-')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\treturn expr[p]=='+'?a+b:a-b;\n\t}\n\t\n\tfor(p=t-1;p>=s;p--)if(expr[p]=='*'||expr[p]=='/')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\tif(expr[p]=='/'&&(b==0||a%b!=0))return inf;\n\t\treturn expr[p]=='*'?a*b:a/b;\n\t}\n\t\n\tif(t>s+1&&expr[s]=='0')return inf;\n\t\n\tint ret=0;\n\tfor(p=t-1;p>=s;p--)ret*=10,ret+=expr[p]-'0';\n\treturn ret;\n}\nbool ok(char *expr,int l)\n{\n\tint eq=-1;\n\trep(i,l)if(expr[i]=='=')eq=eq==-1?i:-2;\n\t\n\tassert(eq>=0); assert(l>0);\n\trep(i,l)assert(expr[i]!='.');\n\t\n\tint a=eval(expr,0,eq),b=eval(expr,eq+1,l);\n\treturn a!=inf&&b!=inf&&a==b;\n}\nbool valid(int y,int x)\n{\n\tif(y<0||y>=h||x<0||x>=w)return 0;\n\treturn bd[y][x]!='#';\n}\nint ck(int y,int x)//-1:µ 0:¢mè 1:³µ\n{\n\tint sy,ty,sx,tx;\n\tfor(sy=y-1;valid(sy,x);sy--); for(ty=y+1;valid(ty,x);ty++);\n\tfor(sx=x-1;valid(y,sx);sx--); for(tx=x+1;valid(y,tx);tx++);\n\tsy++; sx++;\n\t\n\tchar tate[11]={0},yoko[11]={0}; int t=0,yo=0;\n\tbool tateeq=0,yokoeq=0,tatedot=0,yokodot=0;\n\tfor(int i=sy;i<ty;i++)\n\t{\n\t\ttate[t++]=bd[i][x];\n\t\tif(bd[i][x]=='=')tateeq=1;\n\t\telse if(bd[i][x]=='.')tatedot=1;\n\t}\n\tfor(int i=sx;i<tx;i++)\n\t{\n\t\tyoko[yo++]=bd[y][i];\n\t\tif(bd[y][i]=='=')yokoeq=1;\n\t\telse if(bd[y][i]=='.')yokodot=1;\n\t}\n\t\n\tint tateok,yokook;\n\tif(t>1&&!tateeq||yo>1&&!yokoeq)return -1;\n\tif(tatedot)tateok=0; else tateok=!tateeq||ok(tate,t)?1:-1;\n\tif(yokodot)yokook=0; else yokook=!yokoeq||ok(yoko,yo)?1:-1;\n\t\n\treturn tateok<0||yokook<0?-1:tateok>0&&yokook>0?1:0;\n}\nbool rec(int c)\n{\n\tif(c==n)return 1;\n\t\n\trep(i,n)if(lst[i])\n\t{\n\t\tbd[dy[c]][dx[c]]=lst[i]; lst[i]=0;\n\t\tif(ck(dy[c],dx[c])>=0&&rec(c+1))return 1;\n\t\tlst[i]=bd[dy[c]][dx[c]]; bd[dy[c]][dx[c]]='.';\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\trep(i,h)scanf(\"%s\",bd[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n)scanf(\" %c\",lst+i);\n\t\t\n\t\tint c=0;\n\t\tbool use[10][10]={0};\n\t\t\n\t\trep(i,h)rep(j,w)if(bd[i][j]=='=')\n\t\t{\n\t\t\tfor(int k=j+1;valid(i,k);k++)if(bd[i][k]=='.'&&!use[i][k])\n\t\t\tuse[i][k]=1,dy[c]=i,dx[c]=k,c++;\n\t\t\t\n\t\t\tfor(int k=j-1;valid(i,k);k--)if(bd[i][k]=='.'&&!use[i][k])\n\t\t\tuse[i][k]=1,dy[c]=i,dx[c]=k,c++;\n\t\t\t\n\t\t\tfor(int k=i+1;valid(k,j);k++)if(bd[k][j]=='.'&&!use[k][j])\n\t\t\tuse[k][j]=1,dy[c]=k,dx[c]=j,c++;\n\t\t\t\n\t\t\tfor(int k=i-1;valid(k,j);k--)if(bd[k][j]=='.'&&!use[k][j])\n\t\t\tuse[k][j]=1,dy[c]=k,dx[c]=j,c++;\n\t\t}\n\t\t\n\t\tputs(rec(0)?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar a[10][10];\nchar b[10];\n\nvector<string> v;\n\npii tate[10][10];\npii yoko[10][10];\n\nint h,w;\n\nvoid bfs(int y, int x, int dy, int dx, pii table[10][10], int id) {\n  string s;\n  int idx = 0;\n  while(valid(y,x,h,w)) {\n    if (a[y][x] == '#') break;\n    table[y][x] = pii(id,idx++);\n    s += string(1,a[y][x]);\n    y += dy;\n    x += dx;\n  }\n  v.push_back(s);\n}\n\nchar str[1010];\n\nll term(int &i);\nll fact(int &i);\n\nll exp(int &i) {\n  ll p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      ll a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nll term(int &i) {\n  ll p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nll fact(int &i) {\n  ll p = 0;\n  if (!(isdigit(str[i]) && str[i]!='0')) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nll parse(const string &s) {\n  REP(i,s.size()) str[i] = s[i];\n  str[s.size()] = '\\0';\n  int id = 0;\n  ll res = exp(id);\n  if (id != s.size()) throw 0;\n  return res;\n}\n\nbool check(const string &s) {\n  if (s.size() < 2) return 1;\n  if ((int)s.find('.') != string::npos) {\n    return 1;\n  }\n  try {\n    int pos = s.find('=');\n    if (pos == -1) return 0;\n    ll a = parse(s.substr(0,pos));\n    ll b = parse(s.substr(pos+1));\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\nint n;\nvector<pii> pos;\nbool ng[10][10];\n\nbool dfs(int S, int now) {\n  if (now == n) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  REP(i,n) {\n    if (S>>i&1) continue;\n    if (!isdigit(b[i]) && ng[y][x]) continue;\n    bool f = 1;\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first])) f = 0;\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = b[i];\n        if (!check(v[p.first])) f = 0;\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n    {\n      pii p = tate[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    {\n      pii p = yoko[y][x];\n      if (p.first != -1) {\n        v[p.first][p.second] = '.';\n      }\n    }\n    \n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    v.clear();\n    REP(i,h)REP(j,w)tate[i][j]=yoko[i][j]=pii(-1,0);\n    int id = 0;\n    pos.clear();\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (a[i][j] == '.') pos.push_back(pii(i,j));\n        if (tate[i][j].first == -1) {\n          bfs(i,j,1,0,tate,id++);\n        }\n        if (yoko[i][j].first == -1) {\n          bfs(i,j,0,1,yoko,id++);\n        }\n      }\n    }\n    const int dy[4] = {-1,0,1,0};\n    const int dx[4] = {0,1,0,-1};\n    REP(i,h)REP(j,w) {\n      ng[i][j] = 0;\n      REP(k,4) {\n        int y=i+dy[k];\n        int x=j+dx[k];\n        if(!valid(y,x,h,w)) continue;\n        if (!isdigit(a[y][x]) && a[y][x] != '#' && a[y][x] != '.') ng[i][j] = 1;\n      }\n    }\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     printf(\"(%d,%d) \", yoko[i][j].first, yoko[i][j].second);\n    //   }\n    //   cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n    // FOR(it, v) if (it->size() >= 2) cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e15;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nll parse(int L, int R, const string &s){\n  assert(R-L<=0);\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=L;i<R;i++)res = res*10LL + (ll)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  ll a = parse(0,p,s);\n  ll b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cctype>\n#include<cstring>\n#include<iomanip>\n\n\n#define MAX 256\nusing namespace std;\n\n\ntypedef pair<const char *, int > parsed;\ntypedef pair<bool,int> bnfm;\n\nparsed expr(const char *);\nparsed term(const char *);\nparsed fact(const char *);\n\nbnfm Ex(int pos, const string &s);\nbnfm N0(int pos, const string &s);\n\nparsed expr(const char *p){\n  parsed r = term(p);\n  if( r.first == NULL ) return r; // parse error\n  while( *(r.first)=='+' || *(r.first)=='-' ){\n    const char *op = r.first;\n    parsed l = term(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='+' ){\n      r.first = l.first;\n      r.second = r.second + l.second;\n    }else{\n      r.first = l.first;\n      r.second = r.second - l.second;\n    }\n  }\n  return r;\n}\n\nparsed term(const char *p){\n  parsed r = fact(p);\n  if( r.first == NULL ) return r;\n  while( *(r.first)=='*' || *(r.first)=='/' ){\n    const char *op = r.first;\n    parsed l = fact(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='*' ){\n      r.first = l.first;\n      r.second = r.second * l.second;\n    }else{\n      r.first = l.first;\n      if( l.second == 0 || r.second % l.second != 0 ) return parsed(NULL,-1);\n      r.second = int(r.second / l.second);\n    }\n  }\n  return r;\n}\n\nparsed fact(const char *p){\n  if( *p=='(' ){\n    // new expression\n    parsed tp = expr(p+1);\n    if( tp.first == NULL ) return tp;\n    return parsed(tp.first+1, tp.second);\n  }\n  if( *p=='-' ){\n    // negative fact\n    parsed tp = fact(p+1);\n    if( tp.first == NULL ) return tp;\n    tp.second *= -1;\n    return tp;\n  }\n  if( isdigit(*p) ){\n    // number\n    int num = *p - '0';\n    while( isdigit(*(++p)) ){\n      num *= 10;\n      num += *p - '0';\n    }\n    return parsed(p,num);\n  }else assert(0); return parsed(NULL,0);\n}\n\nbool Eq(const string &s){\n  int pos = 0;\n  bnfm r = Ex(pos,s);\n  if( !r.first ) return false;\n  pos = r.second;\n  if( pos >= s.length() ) return false;\n  if( s[pos] != '=' ) return false;\n  ++pos;\n  r = Ex(pos,s);\n  if( !r.first ) return false;\n  if( r.second < s.length() ) return false;\n  return true;\n}\n\nbnfm Ex(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm(false,pos);\n  bnfm r = N0(pos,s);\n  if( !r.first ) return bnfm(false,r.second);\n  pos = r.second;\n  if( pos >= s.length() ) return bnfm(true,pos);\n  while( s[ pos ] == '+' || s[ pos ] == '-' || s[ pos ] == '*' || s[ pos ] == '/' ){\n    bnfm r = N0( pos+1, s );\n    if( !r.first ) return bnfm(false,r.second);\n    pos = r.second;\n    if( pos >= s.length() ) break;\n  }\n  return bnfm(true,pos);\n}\n\nbnfm N0(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm( false,pos );\n  if( !isdigit( s[pos] ) ) return bnfm(false,pos+1);\n  if( s[pos] == '0' ){\n    if( pos + 1 < s.length() ){\n      if( isdigit( s[pos+1] ) ) return bnfm(false,pos+2);\n    }\n    return bnfm(true,pos+1);\n  }else{\n    while( isdigit(s[pos]) ){\n      ++pos;\n      if( pos >= s.length() ) break;\n    }\n    return bnfm(true,pos);\n  }\n}\n\nbool Evaluate(const string &s){\n  string s1,s2;\n  int i,j;\n  for(i = 0; i < s.length(); ++i){\n    if( s[i] == '=' ) break;\n    else s1 += s[i];\n  }\n  for(j=i+1; j < s.length(); ++j){\n    s2 += s[j];\n  }\n  parsed p1 = expr(s1.c_str());\n  parsed p2 = expr(s2.c_str());\n  if( p1.first == NULL || p2.first == NULL ) return false;\n  if( p1.second == p2.second ) return true;\n  else return false;\n}\n\nint main(void){\n  while(true){\n    bool NG;\n    int H,W;\n    char pzl[MAX][MAX],org_pzl[MAX][MAX];\n    for(int i = 0; i < MAX; ++i)for(int j = 0; j < MAX; ++j)pzl[i][j]=org_pzl[i][j]='#';\n\n    cin >> H >> W;\n    if( H == 0 && W == 0) break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> pzl[i+1][j+1];\n\torg_pzl[i+1][j+1] = pzl[i+1][j+1];\n      }\n    }\n    \n    int n,num=0;\n    cin >> n;\n    int p[n];\n    char holes[n];\n    for(int i = 0; i < n; ++i){\n      char d; cin >> d; holes[num++] = d; p[i] = i;\n    }\n    \n    int *c,*pc,*q,k,t;\n    \n    int cnt = 0;\n    c = new int[n];\n    for(k=1,q=p,pc=c;k<=n;)*q++=*pc++=k++;k=1;pc=c;\n    do{t=*(p+k);*(p+k)=*(q=p+((k&1)?*pc:0));*q=t;\n    \n      NG=false;\n      num = 0;\n      vector<string> eqs;\n      const int di [] = {-1,0,1,0};\n      const int dj [] = {0,1,0,-1};\n \n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  if( pzl[i+1][j+1] == '.' ){\n\t    pzl[i+1][j+1] = holes[ p[num]-1 ];\n\t    ++num;\n\t  }\n\t}\n      }\n      \n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  if( pzl[i+1][j+1] != '#' ){ \n\t    for(int l = 0; l < sizeof(di)/sizeof(*di); ++l){\n\t      if( l == 1 || l == 2 ) continue;\n\t      int ti = i + 1 + di[l]; int tj = j + 1 + dj[l];\n\t      if( pzl[ti][tj] == '#' ){\n\t\tint dir = (l+2)%(sizeof(di)/sizeof(*di));\n\t\tti = i+1+di[dir]; tj = j+1+dj[dir];\n\t\tstring eq;\n\t\teq += pzl[i+1][j+1];\n\t\twhile(pzl[ti][tj]!='#'){\n\t\t  eq += pzl[ti][tj]; ti += di[dir]; tj += dj[dir];\n\t\t}\n\t\tif( eq.length() >= 3 ){\n\t\t  if( !Eq(eq) ) goto NEXT;\n\t\t  if( !Evaluate( eq ) ) goto NEXT;\n\t\t  eqs.push_back( eq );\n\t\t}\n\t\teq.clear();\n\t      }\n\t    }\n\t  }\n\t}\n      }\n\n      NG=false;break;\n      /*\n      for(int i = 0; i < eqs.size(); ++i){\n\t//cout << \"EQUATION : \" << eqs[i] << \" VALID? : \" << Eq(eqs[i]) << endl; \n\tif( !Eq(eqs[i]) ){ NG=true; break; }\n\tif( !Evaluate(eqs[i]) ){ NG=true; break; }\n      }\n      \n      if( !NG ){\n\tbreak;\n      }\n      */\n\n    NEXT:;\n      NG=true;\n      for(int i = 0; i < MAX; ++i){\n\tfor(int j = 0; j < MAX; ++j){\n\t  pzl[i][j] = org_pzl[i][j];\n\t}\n      }\n    k=1;pc = c;while(*pc==0)*pc++=k++;(*pc)--;}while(k<n);\n    delete [] c;\n    \n    if( NG ){\n      cout << \"No\" << endl;\n    }else{\n      cout << \"Yes\" <<endl;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nbool ck(); bool ck2(bool,int,int,int);\nbool rec(); bool rec2(bool,int,int,int);\n\nint h,w,n;\nchar bd[10][11];\nchar lst[10];\n\nint eval(char *expr,int s,int t)\n{\n\tint p=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='+'||expr[p]=='-')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\treturn expr[p]=='+'?a+b:a-b;\n\t}\n\tp=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='*'||expr[p]=='/')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\tif(expr[p]=='/'&&(b==0||a%b!=0))return inf;\n\t\treturn expr[p]=='*'?a*b:a/b;\n\t}\n\t\n\tif(t>s+1&&expr[s]=='0')return inf;\n\tint ret=0;\n\tfor(p=t-1;p>=s;p--)ret*=10,ret+=expr[p]-'0';\n\treturn ret;\n}\nbool ck2(bool tate,int y,int b,int x)\n{\n\tchar lhs[11]={0},rhs[11]={0}; int l=0,r=0;\n\tif(tate)\n\t{\n\t\tfor(;b<y;b++)\n\t\t{\n\t\t\tif(bd[b][x]=='=')break;\n\t\t\tlhs[l++]=bd[b][x];\n\t\t}\n\t\tb++;\n\t\tfor(;b<y;b++)rhs[r++]=bd[b][x];\n\t}\n\telse\n\t{\n\t\tfor(;b<x;b++)\n\t\t{\n\t\t\tif(bd[y][b]=='=')break;\n\t\t\tlhs[l++]=bd[y][b];\n\t\t}\n\t\tb++;\n\t\tfor(;b<x;b++)rhs[r++]=bd[y][b];\n\t}\n\t\n\tint a=eval(lhs,0,l); b=eval(rhs,0,r);\n\treturn a!=inf&&b!=inf&&a==b;\n}\nbool ck()\n{\n\trep(i,h)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(j,w+1)\n\t\t{\n\t\t\tif(j==w||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&!dot)\n\t\t\t\t{\n\t\t\t\t\tif(!ck2(0,i,beg,j))return 0;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=j+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\trep(j,w)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(i,h+1)\n\t\t{\n\t\t\tif(i==h||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&!dot)\n\t\t\t\t{\n\t\t\t\t\tif(!ck2(1,i,beg,j))return 0;\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=i+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\t\n\treturn 1;\n}\nbool rec2(bool tate,int y,int b,int x)\n{\n\t//cerr<<tate<<\" \"<<y<<\" \"<<b<<\" \"<<x<<endl;\n\tif(tate)\n\t{\n\t\tassert(b<=y);\n\t\tif(y==b)return ck()&&rec();\n\t\tif(bd[b][x]!='.')return rec2(1,y,b+1,x);\n\t\trep(i,n)if(lst[i])\n\t\t{\n\t\t\tbd[b][x]=lst[i]; lst[i]=0;\n\t\t\tif(rec2(1,y,b+1,x))return 1;\n\t\t\tlst[i]=bd[b][x]; bd[b][x]='.';\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(x==b)return ck()&&rec();\n\t\tif(bd[y][b]!='.')return rec2(0,y,b+1,x);\n\t\trep(i,n)if(lst[i])\n\t\t{\n\t\t\tbd[y][b]=lst[i]; lst[i]=0;\n\t\t\tif(rec2(0,y,b+1,x))return 1;\n\t\t\tlst[i]=bd[y][b]; bd[y][b]='.';\n\t\t}\n\t}\n\treturn 0;\n}\nbool rec()\n{\n\trep(i,h)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(j,w+1)\n\t\t{\n\t\t\tif(j==w||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&dot)\n\t\t\t\t{\n\t\t\t\t\treturn rec2(0,i,beg,j);\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=j+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\trep(j,w)\n\t{\n\t\tint beg=0;\n\t\tbool eq=0,dot=0;\n\t\trep(i,h+1)\n\t\t{\n\t\t\tif(i==h||bd[i][j]=='#')\n\t\t\t{\n\t\t\t\tif(eq&&dot)\n\t\t\t\t{\n\t\t\t\t\treturn rec2(1,i,beg,j);\n\t\t\t\t}\n\t\t\t\teq=dot=0; beg=i+1;\n\t\t\t}\n\t\t\telse if(bd[i][j]=='=')eq=1;\n\t\t\telse if(bd[i][j]=='.')dot=1;\n\t\t}\n\t}\n\t\n\trep(i,h)rep(j,w)if(bd[i][j]=='.')return 0;\n\treturn ck();\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\trep(i,h)scanf(\"%s\",bd[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n)scanf(\" %c\",lst+i);\n\t\t\n\t\tputs(rec()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = false;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end());\n    return ans;\n}\n\nbool requireString(char m[15][15], vector<string> &s){\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                string str;\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                string str;\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nvector<pair<int, int>> spacePoints(vector<string> s){\n    vector<pair<int, int>> ret;\n    rep(i,s.size()){\n        rep(j,s[i].size()){\n            if(s[i][j] == '.') ret.emplace_back(make_pair(i,j));\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> h >> w,h){\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        vector<pair<int, int>> space;\n        rep(i,h) rep(j,w){\n            cin >> m[i + 1][j + 1];\n            if(m[i + 1][j + 1] == '.') space.emplace_back(make_pair(i + 1,j + 1));\n        }\n\n        int n;\n        cin >> n;\n        vector<char> v;\n        rep(i,n){\n            char x;\n            cin >> x;\n            v.emplace_back(x);\n        }\n\n        vector<string> s;\n\n        bool f = false;\n        do{\n            rep(i,n) m[ space[i].first ][ space[i].second ] = v[i];\n            f |= requireString(m,s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (cur % tmp > 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq[0] == '-') return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') return false;\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    return res;\n}\nint main(){\n    int H, W;\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<int> bx, by;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bx.push_back(x); by.push_back(y); }\n\n\n        int L; cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        bool ans = false;\n        do{\n            REP(i, L) grid[ by[i] ][ bx[i] ] = vc[i];\n            REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n                if(y < H - 1 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#'){\n                    string s1, s2;\n                    for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                        if(grid[y + dy][x] == '='){\n                            if(s2.size() > 0) goto BAD;\n                            swap(s1, s2);\n                        }else{\n                            s1 += grid[y + dy][x];\n                        }\n                    }\n                    try{\n                        if(parse(s1) != parse(s2)) goto BAD;\n                    }catch(ParseError e){\n                        goto BAD;\n                    }\n                }\n                if(x < W - 1 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#'){\n                    string s1, s2;\n                    for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                        if(grid[y][x + dx] == '='){\n                            if(s2.size() > 0) goto BAD;\n                            swap(s1, s2);\n                        }else{\n                            s1 += grid[y][x + dx];\n                        }\n                    }\n                    try{\n                        if(parse(s1) != parse(s2)) goto BAD;\n                    }catch(ParseError e){\n                        goto BAD;\n                    }\n                }\n            }\n\n            //REP(y, H) cout << grid[y] << endl;\n            ans = true;\n            break;\n\n            BAD:;\n        }while(next_permutation(vc.begin(), vc.end()));\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) {\n                end_parse = 1;\n                return 1e7;\n            }\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0){\n                end_parse = true;\n                return 1e7;\n            }\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    end_parse = 0;\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15]){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nbool check(char m[15][15]){\n    bool f;\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++){\n                    if(m[k][j] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++){\n                    str.push_back(m[i][k]);\n                    if(m[i][k] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        int k = 0;\n        rep(i,h){\n            rep(j,w){\n                scanf(\"%c\",&m[i + 1][j + 1]);\n                if(m[i + 1][j + 1] == '.'){\n                    y[k] = i + 1;\n                    x[k++] = j + 1;\n                }\n            }\n            scanf(\"%*c\");\n        }\n\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n        if(not check(m)){\n            cout << \"NO\" << endl;\n            continue;\n        }\n\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  \n  void init(){ pos=0;len=s.size();  }\n\n  int head2Num(){\n    int res=0;\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      if(ch=='/')res/=num;\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    return res;\n  }\n};\n\nint H,W,N,M;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w;\n\nbool solve();\nbool check();\nbool compute();\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3)if(!compute())w.push_back(tmp);\n    }\n\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3)if(!compute())w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3)if(!compute())w.push_back(tmp);\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  /*\n\n  */\n  for(int i=0;i<(int)w.size();i++){\n    v=w[i];\n    if(compute())return true;\n  }\n  return false;\n}\n\nbool compute(){\n  for(int i=0;i<(int)v.size();i++)\n      if('A'<=v[i]&&v[i]<='Z')v[i]=u[v[i]-'A'];\n  string a=\"\",b=\"\";\n  bool flg=false;\n  b.push_back(v[0]);\n  for(int i=1;i<(int)v.size();i++){\n      if(!isNum(v[i-1])&&!isNum(v[i]))return false;\n      if(v[i]=='=')flg=true;\n      else if(flg)a.push_back(v[i]);\n      else b.push_back(v[i]);\n  }\n  if(!isNum(v[0])||!isNum(v[v.size()-1]))return false;\n  \n  calcStr x,y;\n  x.s=a;\n  x.init();\n  y.s=b;\n  y.init();\n  \n  return (x.getAns()==y.getAns());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n// 4:37\n// 4:40 coding\n\nvector< pair<int,int> > pos;\nvector<string> expr;\n\nchar nowtable[128];\nstring s;\nint p;\nint A();\nint B();\nint C();\nint D();\nint calc(string _str){\n\ttry{\n\t\tp = 0;\n\t\ts = _str;\n\t\ts += \"~\";\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( s[i] >= 'A' && s[i] <= 'Z' ){\n\t\t\t\tif( nowtable[s[i]] == 0 ) return 2;\n\t\t\t\ts[i] = nowtable[s[i]];\n\t\t\t}\n\t\t}\n\t\tint res = A();\n\t\t\n\t\tif( s[p] != '~' ) throw \"not end\";\n\t\treturn res;\n\t}catch(const char *msg){\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\nint A(){\n\t\n\tint x = B();\n\tif( s[p] == '=' ){\n\t\tp++;\n\t\tint y = B();\n\t\treturn x == y;\n\t}else{\n\t\tthrow \"A\";\n\t}\n}\nint B(){\n\tint x = C();\n\twhile( s[p] == '+' || s[p] == '-' ){\n\t\tif( s[p] == '+'){\n\t\t\tp++;\n\t\t\tx += C();\n\t\t}else{\n\t\t\tp++;\n\t\t\tx -= C();\n\t\t}\n\t}\n\treturn x;\n}\nint C(){\n\tint x = D();\n\twhile( s[p] == '*' || s[p] == '/' ){\n\t\tif( s[p] == '*'){\n\t\t\tp++;\n\t\t\tx *= D();\n\t\t}else{\n\t\t\tp++;\n\t\t\tint r = D();\n\t\t\tif(r==0) throw \"zero\";\n\t\t\tif(x%r) throw \"modulo\";\n\t\t\tx /= r;\n\t\t}\n\t}\n\treturn x;\n}\nint D(){\n\t\n\tint x = 0;\n\n\tif( !(s[p]>='1'&&s[p]<='9') ) throw \"wrong number\";\n\twhile( s[p]>='1'&&s[p]<='9'){\n\t\tx = x*10+s[p++]-'0';\n\t}\n\t\n\treturn x;\n}\n\nchar t[12][12];\nvector<char> use;\n\nint used[10];\nvector<string> hoge;\nint check(){\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint r = calc(hoge[i]);\n\t\tif( r == 2 ) continue;\n\t\tif( !r ) return 0;\n\t}\n\treturn 1;\n}\nint N;\nint dfs(){\n\tif( !check() ) return 0;\n\tvector< pair<int,int> > v;\n\tfor(int i = 0 ; i < hoge.size() ; i++){\n\t\tint c = 0;\n\t\tfor(int j = 0 ; j < hoge[i].size() ; j++){\n\t\t\tif( nowtable[hoge[i][j]] == 0 ){\n\t\t\t\t\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tif(c){\n\t\t\tv.push_back(make_pair(c,i));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tif( v.size() == 0 ) return 1;\n\t\n\tint idx = v[0].second;\n\tfor(int j = 0 ; j < hoge[idx].size() ; j++){\n\t\tif( nowtable[hoge[idx][j]] == 0 ){\n\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\tif( !used[k] ){\n\t\t\t\t\tnowtable[hoge[idx][j]] = use[k];\n\t\t\t\t\tused[k] = true;\n\t\t\t\t\tif( dfs() ) return true;\n\t\t\t\t\tused[k] = false;\n\t\t\t\t\tnowtable[hoge[idx][j]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\t\n\tint H,W;\n\twhile( cin >> H >> W && H){\n\t\tfor(int i = 0 ; i < 128 ; i++) nowtable[i] = -1;\n\t\tfor(int i = 0 ; i < 10 ; i++) used[i] = 0;\n\t\tfor(int i = 'A' ; i <= 'Z' ; i++) nowtable[i] = 0;\n\t\t\n\t\tfor(int i = 0 ; i < 12 ; i++)\n\t\t\tfor(int j = 0 ; j < 12 ; j++)\n\t\t\t\tt[i][j] = '#';\n\t\n\t\tchar tmpAlpha = 'A';\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> t[i+1][j+1];\n\t\t\t\tif( t[i+1][j+1] == '.' ){\n\t\t\t\t\tt[i+1][j+1] = tmpAlpha++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tchar c; cin >> c;\n\t\t\tuse.push_back(c);\n\t\t}\n\t\tint ans = 0;\n\t\tvector<string> id;\n\t\t\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( t[i][j-1] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = j;\n\t\t\t\t\twhile( t[i][k] != '#' ){\n\t\t\t\t\t\tstr += t[i][k++];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( t[i-1][j] == '#' && t[i][j] != '#' ){\n\t\t\t\t\tstring str;\n\t\t\t\t\tint k = i;\n\t\t\t\t\twhile( t[k][j] != '#' ){\n\t\t\t\t\t\tstr += t[k++][j];\n\t\t\t\t\t}\n\t\t\t\t\tif( str.size() >= 2 ){\n\t\t\t\t\t\thoge.push_back(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (dfs()?\"Yes\":\"No\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) end_parse = 1;\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0) end_parse = true;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15], vector<string> &s){\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++) str.push_back(m[k][j]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++) str.push_back(m[i][k]);\n                if(not sintaxCheck(str)) return false;\n                s.emplace_back(str);\n            }\n        }\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nvector<pair<int, int>> spacePoints(vector<string> s){\n    vector<pair<int, int>> ret;\n    rep(i,s.size()){\n        rep(j,s[i].size()){\n            if(s[i][j] == '.') ret.emplace_back(make_pair(i,j));\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n\n        end_parse = false;\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        {\n            int k = 0;\n            rep(i,h){\n                rep(j,w){\n                    scanf(\"%c\",&m[i + 1][j + 1]);\n                    if(m[i + 1][j + 1] == '.'){\n                        y[k] = i + 1;\n                        x[k] = j + 1;\n                        k++;\n                    }\n                }\n               scanf(\"%*c\");\n            }\n        }\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n\n        vector<string> s;\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m,s);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nbool end_parse;\n\ntypedef string::const_iterator State;\nint number(State&);\nint factor(State&);\nint term(State&);\nint expression(State&);\nbool eq(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// ??¬??§?????°???????????????????????????????????????????????????\nint factor(State &begin) {\n    if(end_parse) return -1;\n    if (*begin == '(') {\n        begin++; // '('????£???°??????\n        int ret = eq(begin);\n        begin++; // ')'????£???°??????\n        return ret;\n    } else {\n        return number(begin);\n    }\n    return 0;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if(end_parse) return -1;\n    int ret = factor(begin);\n\n    for (;;) {\n        if (*begin == '*') {\n            begin++;\n            ret *= factor(begin);\n        } else if (*begin == '/') {\n            begin++;\n            int tmp = factor(begin);\n            if(tmp == 0 || ret % tmp != 0) {\n                end_parse = 1;\n                return 1e7;\n            }\n            else ret /= tmp;\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    if(end_parse) return -1;\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '+') {\n            begin++;\n            ret += term(begin);\n        } else if (*begin == '-') {\n            begin++;\n            ret -= term(begin);\n            if(ret < 0){\n                end_parse = true;\n                return 1e7;\n            }\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nbool eq(State &begin){\n    int ret = expression(begin);\n    if(end_parse) return 0;\n\n    if(*begin == '='){\n        begin++;\n        return (ret == expression(begin));\n    }\n    return 0;\n}\n\n//begin???expected?????????????????????begin?????????????????????\nvoid consume(State &begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        //throw ParseError();\n    }\n}\n\nint h, w;\nbool sintaxCheck(string s){\n    rep(i,s.size() - 1){\n        if(not isdigit(s[i]) && not isdigit(s[i + 1])) return false;\n        if(s[i] == '0' && isdigit(s[i + 1])) return false;\n    }\n    if(not isdigit(s.front()) || not isdigit(s.back())) return false;\n\n    end_parse = 0;\n    State tmp = s.begin();\n    bool ans = eq(tmp);\n    assert(tmp == s.end() || end_parse);\n    return ans;\n}\n\nbool requireString(char m[15][15]){\n    string str;\n    int hx[12], hy[12], vx[12], vy[12];\n    int k = 0, l = 0;\n    range(i,1,h + 1){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#'){\n                vy[k] = i;\n                vx[k++] = j;\n            }\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#'){\n                hy[l] = i;\n                hx[l++] = j;\n            }\n        }\n    }\n\n    rep(i,k){\n        str = \"\";\n        for(int k = vy[i]; m[k][vx[i]] != '#'; k++) str.push_back(m[k][vx[i]]);\n        if(not sintaxCheck(str)) return false;\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n\n    rep(i,l){\n        str = \"\";\n        for(int k = hx[i]; m[hy[i]][k] != '#'; k++) str.push_back(m[hy[i]][k]);\n        if(not sintaxCheck(str)) return false;\n    }\n    return true;\n    //show(\"hor\")\n    //rep(i,s.size()){ show(s[i]); }\n}\n\nbool check(char m[15][15]){\n    bool f;\n    string str;\n    range(i,1,h){ //ver\n        range(j,1,w + 1){\n            if(m[i - 1][j] == '#' && m[i][j] != '#' && m[i + 1][j] != '#' && m[i + 2][j] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = i; m[k][j] != '#'; k++){\n                    if(m[k][j] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    //show(\"ver\")\n    //rep(i,s.size()){ show(s[i]); }\n    range(i,1,h + 1){ //hor\n        range(j,1,w){\n            if(m[i][j - 1] == '#' && m[i][j] != '#' && m[i][j + 1] != '#' && m[i][j + 2] != '#'){\n                f = true;\n                str = \"\";\n                for(int k = j; m[i][k] != '#'; k++){\n                    str.push_back(m[i][k]);\n                    if(m[i][k] == '.'){\n                        f = false;\n                        break;\n                    }\n                    str+=m[k][j];\n                }\n                if(not f) continue;\n                if(not sintaxCheck(str)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(scanf(\"%d%d%*c\",&h,&w),h){\n        char m[15][15];\n        rep(i,h + 2) rep(j, w + 2) m[i][j] = '#';\n\n        int y[15], x[15];\n        int k = 0;\n        rep(i,h){\n            rep(j,w){\n                scanf(\"%c\",&m[i + 1][j + 1]);\n                if(m[i + 1][j + 1] == '.'){\n                    y[k] = i + 1;\n                    x[k++] = j + 1;\n                }\n            }\n            scanf(\"%*c\");\n        }\n\n\n        int n;\n        scanf(\"%d%*c\",&n);\n        vector<char> v;\n        rep(i,n){\n            char x;\n            scanf(\"%c%*c\",&x);\n            v.emplace_back(x);\n        }\n        if(not check(m)){\n            cout << \"NO\" << endl;\n            continue;\n        }\n\n        bool f = false;\n        do{\n            rep(i,n) m[y[i]][x[i]] = v[i];\n            f |= requireString(m);\n        }while(next_permutation(all(v)));\n        cout << (f ? \"YES\" : \"NO\" ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint idx;\nchar s[11];\nbool res;\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-' || s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex();\n\tASRT;\n\tif(a!=b || s[idx]) res=false;\n}\n\nbool parse(){\n\tif(strlen(s)<=2) return true;\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nbool calc_no_space(){\n\trep(i,h){\n\t\tint p=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\trep(k,j-p) s[k]=B[i][p+k];\n\t\t\t\t\ts[j-p]='\\0';\n\t\t\t\t\tif(strchr(s,'.')==0 && !parse()) return false;\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\tint p=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\trep(k,i-p) s[k]=B[p+k][j];\n\t\t\t\t\ts[i-p]='\\0';\n\t\t\t\t\tif(strchr(s,'.')==0 && !parse()) return false;\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nchar key[10];\nint n,qx[10],qy[10];\nbool dfs(int k,bool *used){\n\tif(k==n) return true;\n\n\trep(l,n) if(!used[l]) {\n\t\tused[l]=true;\n\t\tB[qy[k]][qx[k]]=key[l];\n\n\t\tbool ok=true;\n\t\tint x1=qx[k],x2=qx[k];\n\t\twhile(x1>=0 && B[qy[k]][x1]!='#') x1--; x1++;\n\t\twhile(x2< w && B[qy[k]][x2]!='#') x2++;\n\t\trep(j,x2-x1) s[j]=B[qy[k]][x1+j];\n\t\ts[x2-x1]='\\0';\n\t\tif(count(s,s+x2-x1,'.')==0 && !parse()) ok=false;\n\n\t\tint y1=qy[k],y2=qy[k];\n\t\twhile(y1>=0 && B[y1][qx[k]]!='#') y1--; y1++;\n\t\twhile(y2< w && B[y2][qx[k]]!='#') y2++;\n\t\trep(i,y2-y1) s[i]=B[y1+i][qx[k]];\n\t\ts[y2-y1]='\\0';\n\t\tif(count(s,s+y2-y1,'.')==0 && !parse()) ok=false;\n\n\t\tif(ok && dfs(k+1,used)) return true;\n\n\t\tused[l]=false;\n\t\tB[qy[k]][qx[k]]='.';\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tbool used[10]={};\n\t\tputs(calc_no_space()&&dfs(0,used)?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n#define fprintf(...) (void)0\n\nint parse_int(std::string &s, size_t &i) {\n  assert(isdigit(s[i]));\n  int res=s[i++]-'0';\n  while (isdigit(s[i])) {\n    res = res*10 + s[i++]-'0';\n  }\n  return res;\n}\n\nint parse(std::string &s, size_t &i, bool &succ) {\n  int res=0;\n  char sgn='+';\n  while (i < s.length()) {\n    assert(isdigit(s[i]));\n\n    int cur=parse_int(s, i);\n    while (true) {\n      if (s[i] == '*') {\n        cur *= parse_int(s, ++i);\n      } else if (s[i] == '/') {\n        int tmp=parse_int(s, ++i);\n        if (cur % tmp > 0) {\n          succ = false;\n          return -1;\n        }\n        cur /= tmp;\n      } else {\n        break;\n      }\n    }\n\n    if (sgn == '+') {\n      res += cur;\n    } else if (sgn == '-') {\n      res -= cur;\n    }\n\n    if (i == s.length() || s[i] == '=')\n      return res;\n\n    sgn = s[i++];\n  }\n  return res;\n}\n\nbool solved(const std::vector<std::string> &eqs, const std::vector<char> &ch) {\n  fprintf(stderr, \": \");\n  for (size_t i=0; i<ch.size(); ++i)\n    fprintf(stderr, \"%c%c\", ch[i], i+1<ch.size()? ' ':'\\n');\n\n  for (auto eq: eqs) {\n    size_t i=0;\n\n    for (char &c: eq)\n      if (c >= 'A' && c <= 'Z')\n        c = ch[c-'A'];\n\n    fprintf(stderr, \"# %s\\n\", eq.c_str());\n\n    if (eq[0] == '=' || eq[0] == '-') return false;\n    for (size_t i=0; i+1<eq.length(); ++i) {\n      if (isdigit(eq[i])) continue;\n      if (!isdigit(eq[i+1])) return false;\n    }\n\n    for (size_t i=0; i<eq.length(); ++i) {\n      if (!isdigit(eq[i])) continue;\n      if (eq[i] == '0') return false;\n      while (i+1 < eq.length() && isdigit(eq[i+1])) {\n        ++i;\n      }\n    }\n\n    if (std::count(eq.begin(), eq.end(), '=') != 1)\n      return false;\n\n    bool succ=true;\n    int lhs=parse(eq, i, succ);\n    if (!succ) return false;\n    assert(eq[i] == '=');\n    ++i;\n    succ = true;\n    int rhs=parse(eq, i, succ);\n\n    fprintf(stderr, \"%s: %d %d\\n\", eq.c_str(), lhs, rhs);\n\n    if (lhs != rhs)\n      return false;\n  }\n  return true;\n}\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0) return 1;\n\n  std::vector<std::string> g(H);\n  for (size_t i=0; i<H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    g[i] = buf;\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::vector<char> ch(n);\n  for (size_t i=0; i<n; ++i) {\n    scanf(\" %c\", &ch[i]);\n  }\n\n  char ph='A';\n  for (size_t i=0; i<H; ++i)\n    for (size_t j=0; j<W; ++j)\n      if (g[i][j] == '.')\n        g[i][j] = ph++;\n\n  std::vector<std::string> eqs;\n\n  for (size_t i=0; i<H; ++i) {\n    std::string eq=\"\";\n    for (size_t j=0; j<W; ++j) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  for (size_t j=0; j<W; ++j) {\n    std::string eq=\"\";\n    for (size_t i=0; i<H; ++i) {\n      if (g[i][j] == '#') {\n        if (eq.size() >= 3) {\n          eqs.emplace_back(eq);\n        }\n        eq = \"\";\n        continue;\n      }\n\n      eq += g[i][j];\n    }\n    if (eq.size() >= 3)\n      eqs.emplace_back(eq);\n  }\n\n  std::sort(ch.begin(), ch.end());\n  do {\n    if (solved(eqs, ch)) {\n      printf(\"Yes\\n\");\n      return 0;\n    }\n  } while (std::next_permutation(ch.begin(), ch.end()));\n\n  printf(\"No\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (!stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) {\n\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t}\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tif (a != n) return false;\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) flag &= eq.evaluate(s_map);\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > 100000) return false;\n    if(k == L) return true;\n    REP(i, vc.size()) if(!used[i]){\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\ntypedef long long int lli;\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\ninline\nint calc(const string &s)\n{\n  istringstream iss( s );\n  vector<int> num;\n  vector<char> op;\n  int n;\n  char c;\n  while( iss >> n ){    \n    num.push_back( n );\n    if( iss >> c )op.push_back( c );\n    else break;\n  }\n  \n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    else assert( false && \"invalid op\" );\n    num.erase( num.begin() + i + 1);\n    op.erase( op.begin() + i );\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\ninline\nbool check_syntax(const string &s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\n\nstruct F{\n  vector< pair<int, int> > v;\n  F(){ v.clear(); }\n};\n\ninline\nstring build(F f)\n{\n  string s;\n  for(int i=0; i<f.v.size(); ++i){\n    s += g[ f.v[i].first ][ f.v[i].second ];\n  }\n  return s;\n}\n\ninline\nlli cpy(char c)\n{\n  if( isdigit(c) ) return c - '0';\n  if( c == '+' ) return 10;\n  if( c == '*' ) return 11;\n  if( c == '/' ) return 12;\n  if( c == '-' ) return 13;\n  return -(1LL << 60);\n}\n\nbool solve(char p[], int size, int h, int w)\n{\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  static pair<int, int> emp[10 * 10 + 1];\n  int emp_size = 0;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp[emp_size++] = make_pair(i, j);\n    }\n  }\n\n  if( emp_size != size )return false;\n\n  static char puz[H][W];\n  static F v[1000];  \n\n  fill( v, v + 1000, F() );\n\n  int v_size = 0;\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }  \n\n  if( v_size == 0 )return true;\n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }\n\n  sort( p, p + size );\n  set<lli> T, F;\n  do{\n\n    for(int i=0; i<emp_size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    bool flg = true;\n    for(int i=0; i<v_size && flg; ++i){\n      string s;\n      lli h = 0;\n      for(int j=0; j<v[i].v.size(); ++j){\n\tint a = v[i].v[j].first;\n\tint b = v[i].v[j].second;\n\ts += g[a][b];\n\th = (h + cpy( g[a][b] )) * 19LL;\n\th %= 1LL << 60;\n      }\n      if( F.count( h ) ) flg = false;\n      else if( T.count( h ) ) flg = true;\n      else if( !check_syntax(s) ){\n\tF.insert( h );\n\tflg = false;\n      }\n      else T.insert( h );\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( scanf(\"%d%d\\n\", &h, &w) != EOF && (h | w) ){\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tscanf(\"%c\", &g[i][j]);\n      }\n      scanf(\"\\n\");\n    }\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n    puts( solve(m, n, h, w) ? \"Yes\" : \"No\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return /*!operand_connected(str) and*/ equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll inf = 1e15;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if( s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if( i>0 && !isdigit(s[i]) && !isdigit(s[i-1])){\n      return false;\n    }\n  }\n  return true;\n}\n\nll parse(int L, int R, const string &s){\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      ll a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  ll res = 0;\n  for(int i=L;i<R;i++)res = res*10LL + (ll)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  ll a = parse(0,p,s);\n  ll b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    bool f = true;\n    rep(i,h)rep(j,w){\n      if(j==0 || g[i][j-1]=='#'){\n\tstring tmp;\n\trep(k,w){\n\t  if(g[i][k] == '#')break;\n\t  tmp += g[i][k];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n\n      if(i==0 || g[i-1][j]=='#'){\n\tstring tmp;\n\trep(k,h){\n\t  if(g[k][j] == '#')break;\n\t  tmp += g[k][j];\n\t}\n\tif(tmp.size()>=3 && tmp.find('.')==string::npos && !check(tmp))f = false;\n      }\n    }\n\n    if(!f){\n      cout << \"No\" << endl;\n      continue;\n    }\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,w,n;\nchar bd[10][11];\nchar lst[10];\nint dx[10],dy[10];\n\nint eval(char *expr,int s,int t)\n{\n\tif(s>=t)return inf;\n\t\n\tint p=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='+'||expr[p]=='-')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\treturn expr[p]=='+'?a+b:a-b;\n\t}\n\t\n\tfor(p=t-1;p>=s;p--)if(expr[p]=='*'||expr[p]=='/')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\tif(expr[p]=='/'&&(b==0||a%b!=0))return inf;\n\t\treturn expr[p]=='*'?a*b:a/b;\n\t}\n\t\n\tif(t>s+1&&expr[s]=='0')return inf;\n\t\n\tint ret=0;\n\tfor(p=t-1;p>=s;p--)ret*=10,ret+=expr[p]-'0';\n\treturn ret;\n}\nbool ok(char *expr,int l)\n{\n\tint eq=-1;\n\trep(i,l)if(expr[i]=='=')eq=eq==-1?i:-2;\n\t\n\tassert(eq>=0); assert(l>0);\n\trep(i,l)assert(expr[i]!='.');\n\t\n\tint a=eval(expr,0,eq),b=eval(expr,eq+1,l);\n\treturn a!=inf&&b!=inf&&a==b;\n}\nbool valid(int y,int x)\n{\n\tif(y<0||y>=h||x<0||x>=w)return 0;\n\treturn bd[y][x]!='#';\n}\nint ck(int y,int x)//-1:µ 0:¢mè 1:³µ\n{\n\tint sy,ty,sx,tx;\n\tfor(sy=y-1;valid(sy,x);sy--); for(ty=y+1;valid(ty,x);ty++);\n\tfor(sx=x-1;valid(y,sx);sx--); for(tx=x+1;valid(y,tx);tx++);\n\tsy++; sx++;\n\t\n\tchar tate[11]={0},yoko[11]={0}; int t=0,yo=0;\n\tbool teq=0,yeq=0,tatedot=0,yokodot=0;\n\tfor(int i=sy;i<ty;i++)\n\t{\n\t\ttate[t++]=bd[i][x];\n\t\tif(bd[i][x]=='=')teq=1;\n\t\telse if(bd[i][x]=='.')tatedot=1;\n\t}\n\tfor(int i=sx;i<tx;i++)\n\t{\n\t\tyoko[yo++]=bd[y][i];\n\t\tif(bd[y][i]=='=')yeq=1;\n\t\telse if(bd[y][i]=='.')yokodot=1;\n\t}\n\t\n\tint tok,yok;\n\tif(t>1&&!teq||yo>1&&!yeq)return -1;\n\tif(tatedot)tok=0; else tok=t<3||ok(tate,t)?1:-1;\n\tif(yokodot)yok=0; else yok=yo<3||ok(yoko,yo)?1:-1;\n\t\n\treturn tok<0||yok<0?-1:tok>0&&yok>0?1:0;\n}\nbool rec(int c)\n{\n\tif(c==n)\n\t{\n\t\trep(i,h)rep(j,w)if(bd[i][j]=='='&&ck(i,j)<=0)return 0;\n\t\treturn 1;\n\t}\n\t\n\trep(i,n)if(lst[i])\n\t{\n\t\tbd[dy[c]][dx[c]]=lst[i]; lst[i]=0;\n\t\tif(ck(dy[c],dx[c])>=0&&rec(c+1))return 1;\n\t\tlst[i]=bd[dy[c]][dx[c]]; bd[dy[c]][dx[c]]='.';\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\trep(i,h)scanf(\"%s\",bd[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n)scanf(\" %c\",lst+i);\n\t\t\n\t\tint c=0;\n\t\tbool use[10][10]={0};\n\t\t\n\t\trep(i,h)rep(j,w)if(bd[i][j]=='=')\n\t\t{\n\t\t\tfor(int k=j+1;valid(i,k);k++)if(bd[i][k]=='.'&&!use[i][k])\n\t\t\tuse[i][k]=1,dy[c]=i,dx[c]=k,c++;\n\t\t\t\n\t\t\tfor(int k=j-1;valid(i,k);k--)if(bd[i][k]=='.'&&!use[i][k])\n\t\t\tuse[i][k]=1,dy[c]=i,dx[c]=k,c++;\n\t\t\t\n\t\t\tfor(int k=i+1;valid(k,j);k++)if(bd[k][j]=='.'&&!use[k][j])\n\t\t\tuse[k][j]=1,dy[c]=k,dx[c]=j,c++;\n\t\t\t\n\t\t\tfor(int k=i-1;valid(k,j);k--)if(bd[k][j]=='.'&&!use[k][j])\n\t\t\tuse[k][j]=1,dy[c]=k,dx[c]=j,c++;\n\t\t}\n\t\t\n\t\tputs(rec(0)?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint idx;\nchar s[11];\nbool res;\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-' || s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex();\n\tASRT;\n\tif(a!=b || s[idx]) res=false;\n}\n\nbool parse(){\n\tif(strlen(s)<=2) return true;\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nvector<int> head[2][10],tail[2][10];\nvoid preprocess(){\n\trep(i,h){\n\t\thead[0][i].clear();\n\t\ttail[0][i].clear();\n\n\t\tint p=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\thead[0][i].push_back(p);\n\t\t\t\t\ttail[0][i].push_back(j);\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\thead[1][j].clear();\n\t\ttail[1][j].clear();\n\n\t\tint p=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\thead[1][j].push_back(p);\n\t\t\t\t\ttail[1][j].push_back(i);\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool calc_no_space(){\n\trep(i,h){\n\t\trep(k,head[0][i].size()){\n\t\t\trep(l,tail[0][i][k]-head[0][i][k]) s[l]=B[i][head[0][i][k]+l];\n\t\t\ts[tail[0][i][k]-head[0][i][k]]='\\0';\n\t\t\tif(strchr(s,'.')==0){\n\t\t\t\tif(!parse()) return false;\n\t\t\t\thead[0][i].erase(head[0][i].begin()+k);\n\t\t\t\ttail[0][i].erase(tail[0][i].begin()+k);\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\trep(k,head[1][j].size()){\n\t\t\trep(l,tail[1][j][k]-head[1][j][k]) s[l]=B[head[1][j][k]+l][j];\n\t\t\ts[tail[1][j][k]-head[1][j][k]]='\\0';\n\t\t\tif(strchr(s,'.')==0){\n\t\t\t\tif(!parse()) return false;\n\t\t\t\thead[1][j].erase(head[1][j].begin()+k);\n\t\t\t\ttail[1][j].erase(tail[1][j].begin()+k);\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool isvalid(){\n\trep(i,h){\n\t\trep(k,head[0][i].size()){\n\t\t\trep(l,tail[0][i][k]-head[0][i][k]) s[l]=B[i][head[0][i][k]+l];\n\t\t\ts[tail[0][i][k]-head[0][i][k]]='\\0';\n\t\t\tif(!parse()) return false;\n\t\t}\n\t}\n\n\trep(j,w){\n\t\trep(k,head[1][j].size()){\n\t\t\trep(l,tail[1][j][k]-head[1][j][k]) s[l]=B[head[1][j][k]+l][j];\n\t\t\ts[tail[1][j][k]-head[1][j][k]]='\\0';\n\t\t\tif(!parse()) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tint n; scanf(\"%d\",&n);\n\t\tchar key[10];\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\tint qx[10],qy[10];\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tpreprocess();\n\n\t\tbool ok=false;\n\t\tif(calc_no_space()){\n\t\t\tint p[]={0,1,2,3,4,5,6,7,8,9};\n\t\t\tdo{\n\t\t\t\trep(k,n) B[qy[k]][qx[k]]=key[p[k]];\n\t\t\t\tif(isvalid()){ ok=true; break; }\n\t\t\t}while(next_permutation(p,p+n));\n\t\t}\n\t\telse for(;;);\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int INF = 1<<24;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  string num = \"\";\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  while(pos < s.size() && isdigit(s[pos])) {\n    num += s[pos++];\n  }\n  if(num[0] == '0') {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  return atoi(num.c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int value = getNum(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      value = getNum(s, pos);\n      if(value == INF) return INF;\n      x *= value;\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == INF) return INF;\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn INF;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int value = term(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x += value;\n    } else if(s[pos] == '-') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x -= value;\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n\n      }\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n    sort(T, T+N);\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\ntypedef pair<int,int> Error;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw Error(p, NotEquationExc); }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw Error(p, NotEquationExc); }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw Error(p, NegIntExc); }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw Error(p, OutOfIntExc); \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw Error(p, LackNumExc); }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw Error(p, NotNumExc); }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (Error ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false; \n      }\n    } catch(Error ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define UNKNOWN 20\n#define UI unsigned int\nusing namespace std;\nint h,w,n;\nchar m[10][10], r[10];\n//vector<string> form;\nstring form[1000];\nUI formLen;\nint map[10]; // 置換文字への写像\n\nconst int UNCAL = -1111111;\nconst int PLUS  = UNCAL -1;\nconst int MINUS = PLUS  -1;\nint cal( string s ){\n  string a;\n  int v[10];\n  UI vLen=0;//vector<int> v;\n  bool isNum=true;\n  int kind=0; // 0:+,- 1:* 2:/\n  for( UI i=0;i<s.length();i++ ){\n    if( isNum ){\n      a=\"\";\n      while( i<s.length() && '0'<=s[i] && s[i]<='9' ) a+=s[i++];\n      --i;\n\n      if( a.length()==0 ) return UNCAL;\n      if( a[0]=='0' && a.length()!=1 ) return UNCAL;\n      int number = atoi( a.c_str() );\n\n      if( kind==0 ) v[vLen++]=number;\n      else if( kind==1 ){ // *\n\tv[ vLen-1 ] *= number;\n      }else{ // /\n\tif( number==0 ) return UNCAL;\n\tif( v[vLen-1]%number !=0 ) return UNCAL;\n\tv[ vLen-1 ] /= number;\n      }\n    }else{\n      kind = 0;\n      if( s[i]=='+' )      v[ vLen++ ] = PLUS;\n      else if( s[i]=='-' ) v[ vLen++ ] = MINUS;\n      else if( s[i]=='*' ) kind=1;\n      else if( s[i]=='/' ) kind=2;\n      else return UNCAL;\n    }\n    isNum = !isNum;\n  }\n  if( vLen==0 ) return UNCAL;\n\n  int ret = v[0];\n  for( UI i=1;i<vLen;i+=2 ){\n    if( v[i]==PLUS && i+1<vLen ) ret += v[i+1];\n    else if( v[i]==MINUS && i+1<vLen ) ret-=v[i+1];\n    else return UNCAL;\n  }\n\n  return ret;\n}\n\nbool checkForm( string s ){\n  int a,b;\n  UI i=s.find(\"=\");\n\n  if( i==string::npos || i+1==s.length() )\n    return false;\n  if( (a=cal(s.substr(0,i)))==UNCAL )\n    return false;\n  b = cal( s.substr( i+1 ) );\n\n  return a==b;\n}\n\n\n/* i文字目の空白を置換する\n   j-1 番目までの form はクリアしているとする。\n */\nbool solve(int i,UI j){\n  string s;\n  // 数式チェック\n  for( ; j<formLen;j++ ){\n    s=\"\";\n    UI k;\n    for( k=0;k<form[j].length();k++ ){\n      if( form[j][k]<10 ){   // 未知の文字（空白）が存在\n\tif( form[j][k]<i )\n\t  s = s + r[ map[(int)form[j][k]] ];\n\telse                 // 未定文字が存在する数式\n\t  k = form[j].length()+100;\n      }else\n\ts = s + form[j][k];\n    }\n    if( k>form[j].length() ) break;\n    if( !checkForm( s ) ) // 等式とならなかった\n      return false;\n  }\n\n  if( j==formLen ) return true;\n  if( i==n ) return false;\n\n  // i+1 番目のチェック\n  // map[i+1] に map[j]!=map[i][j] ( j<i )となる値を代入\n  for( int k=0,l;k<n;k++ ){\n    map[i] = k;\n    for( l=0;l<i;l++ )\n      if( map[i] == map[l] ) break;\n    if( l!=i ) continue;\n    if( solve( i+1,j ) )\n      return true;    \n  }\n  return false;\n}\n\nint main(){\n  while( cin>>h>>w && (h||w) ){\n    int in=0; // 空白マスインデックス\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> m[i][j];\n\tif( m[i][j]=='.' ) m[i][j]=in++;\n      }\n    cin >> n;\n    for( int i=0;i<n;i++ )\n      cin >> r[i];\n\n    formLen=0;\n    string s;\n    int unknown[1000];\n    // 横方向の数式\n    for( int i=0;i<h;i++ ){\n      for( int j=0;j<w;j++ ){\n\ts=\"\"; int uN=0;\n\twhile( m[i][j]=='#' ) j++;\n\twhile( j<w && m[i][j]!='#' ){\n\t  if( m[i][j]<10 ) uN++;\n\t  s+=m[i][j++];\n\t}\n\tif( s.length()>2 && uN>0 && !checkForm(s) ){\n\t  form[formLen] = s;\n\t  unknown[formLen] = uN;\n\t  formLen++;\n\t}\n      }\n    }\n    // 縦方向の数式\n    for( int j=0;j<w;j++ ){\n      for( int i=0;i<h;i++ ){\n\ts=\"\"; int uN=0;\n\twhile( m[i][j]=='#' ) i++;\n\twhile( i<h && m[i][j]!='#' ){\n\t  if( m[i][j]<10 ) uN++;\n\t  s+=m[i++][j];\n\t}\n\t//\tif( s.length()>2 && !checkForm(s) ){\n\tif( s.length()>2 && uN>0 && !checkForm(s) ){\n\t  form[formLen] = s;\n\t  unknown[formLen] = uN;\n\t  formLen++;\n\t}\n      }\n    }\n    // 未知数の少ないものが先にくるように並び替え\n    bool flag;\n    do{\n      flag=false;\n      for( UI i=1;i<formLen;i++ ){\n\tif( unknown[i-1] > unknown[i] ){\n\t  UI b = unknown[i-1]; unknown[i-1]=unknown[i]; unknown[i]=b;\n\t  s=form[i-1]; form[i-1]=form[i]; form[i]=s;\n\t  flag=true;\n\t}\n      }\n    }while( flag );\n\n\n    if( solve( 0,0 ) ) cout << \"Yes\" << endl;\n    else               cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvector<pair<int,int>> blanks;\n\nvoid fill_blank() {\n  int i = 0;\n  REP(i, n) {\n    int x = blanks[i].first, y = blanks[i].second;\n    TABLE[x][y] = BLOCK[i];\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool is_operand(char c) {\n  return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool is_illegal_operand() {\n  REP(y, H) REP(x, W) {\n    if (PRINTED[x][y]) continue;\n    if (not is_operand(TABLE[x][y])) continue;\n    const int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n    REP(i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (legal(nx, ny) and is_operand(TABLE[nx][ny])) {\n        return true;\n      }\n    }\n  }\n\n  REP(y, H) REP(x,W) {\n    if ((VBEGIN[x][y] or HBEGIN[x][y]) and is_operand(TABLE[x][y])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint hbadx, hbady, vbadx, vbady;\nbool hbadflag, vbadflag;\nstring hbadeq, vbadeq;\n\nbool solved() {\n  if (hbadflag and geth(hbadx, hbady) == hbadeq) return false;\n  if (vbadflag and geth(vbadx, vbady) == vbadeq) return false;\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        hbadflag = true;\n        hbadx = x, hbady = y;\n        hbadeq = eq;\n        return false; \n      }\n    } catch (int ex) {\n      hbadflag = true;\n      hbadx = x, hbady = y;\n      hbadeq = eq;\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) {\n        vbadflag = true;\n        vbadx = x, vbady = y;\n        vbadeq = eq;\n        return false; \n      }\n    } catch(int ex) {\n      vbadflag = true;\n      vbadx = x, vbady = y;\n      vbadeq = eq;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n    if (is_illegal_operand()) continue;\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nvoid init() {\n  blanks.clear();\n  REP(y, H) REP(x, W) {\n    hbadflag = vbadflag = false;\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n        if (row[x] == '.') {\n          blanks.push_back(make_pair(x, y));\n        }\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint expr(const string& s)\n{\n\tint x; char op1;\n\tfor(int i=0,j=0,k=0;i<s.size();i++){\n\t\tint y=0; char op2;\n\t\tfor(j=i;j<s.size();j++){\n\t\t\tif(s[j]<'1' || '9'<s[j]) return INF;\n\t\t\tint z=0;\n\t\t\tfor(k=j;k<s.size() && isdigit(s[k]);k++)\n\t\t\t\tz=z*10+s[k]-'0';\n\t\t\tif(j==i) y=z;\n\t\t\telse if(op2=='*') y*=z;\n\t\t\telse if(z && y%z==0) y/=z;\n\t\t\telse return INF;\n\t\t\tj=k;\n\t\t\tif(i==s.size()) break;\n\t\t\tif(s[j]!='*' && s[j]!='/') break;\n\t\t\top2=s[j];\n\t\t}\n\t\tif(i==0) x=y;\n\t\telse op1=='+'?x+=y:x-=y;\n\t\ti=j;\n\t\tif(i==s.size()) break;\n\t\tif(s[i]!='+' && s[i]!='-') return INF;\n\t\top1=s[i];\n\t}\n\treturn x;\n}\n\nbool check(const vs& grid,const vector<pii>& f)\n{\n\tstring s;\n\tfor(auto p:f) s+=grid[p.first][p.second];\n\tif(count(all(s),'=')!=1) return false;\n\tint eq=s.find('=');\n\tif(eq==0 || eq==s.size()-1) return false;\n\tstring a=s.substr(0,eq),b=s.substr(eq+1);\n\t\n\tint x=expr(a),y=expr(b);\n\tif(x==INF || y==INF || x!=y)\n\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint n; cin>>n;\n\t\tstring cs(n,'~');\n\t\trep(i,n) cin>>cs[i];\n\t\t\n\t\tvector<pii> ps;\n\t\tvector<vector<pii>> fs;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='.') ps.emplace_back(i,j);\n\t\t\tif(grid[i][j]!='#'){\n\t\t\t\tif((i==0 || grid[i-1][j]=='#') && i<h-1 && grid[i+1][j]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=i;k<h && grid[k][j]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(k,j);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t\tif((j==0 || grid[i][j-1]=='#') && j<w-1 && grid[i][j+1]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=j;k<w && grid[i][k]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(i,k);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvvi ds(n+1);\n\t\t{\n\t\t\tvi vis(fs.size());\n\t\t\trep(i,n+1){\n\t\t\t\trep(j,fs.size()) if(!vis[j]){\n\t\t\t\t\tstring s;\n\t\t\t\t\tfor(auto p:fs[j]) s+=grid[p.first][p.second];\n\t\t\t\t\tif(count(all(s),'.')==0){\n\t\t\t\t\t\tds[i].push_back(j);\n\t\t\t\t\t\tvis[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<n) grid[ps[i].first][ps[i].second]='?';\n\t\t\t}\n\t\t\trep(i,n)\n\t\t\t\tgrid[ps[i].first][ps[i].second]='.';\n\t\t\trotate(begin(ds),1+all(ds));\n\t\t}\n\t\t\n\t\tstring res=\"No\";\n\t\t{\n\t\t\tbool ok=true;\n\t\t\tfor(auto i:ds[n])\n\t\t\t\tok&=check(grid,fs[i]);\n\t\t\tif(!ok){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tdo{\n\t\t\tint i=0;\n\t\t\tfor(;i<n;i++){\n\t\t\t\tgrid[ps[i].first][ps[i].second]=cs[is[i]];\n\t\t\t\tbool ok=all_of(all(ds[i]),[&](int j){return check(grid,fs[j]);});\n\t\t\t\tif(!ok) break;\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\tres=\"Yes\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treverse(i+1+all(is));\n\t\t}while(next_permutation(all(is)));\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if (incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if (incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) goto INCORRECT;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) goto INCORRECT;\n      }\n      return true;\n\nINCORRECT:\n      ;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tbool evaluated;\n\tbool evaluated_ans;\n\t\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t\t\n\t\tevaluated = true;\n\t\tfor (char c : A) evaluated &= (isdigit(c) || c == '+' || c == '-' || c == '*' || c == '/');\n\t\tfor (char c : B) evaluated &= (isdigit(c) || c == '+' || c == '-' || c == '*' || c == '/');\n\t\t\n\t\tevaluated_ans = false;\n\t\tif (evaluated) evaluated_ans = evaluate(\"\");\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (!stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) calc();\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tfor (Equation& eq : eqs) if (eq.evaluated && !eq.evaluated_ans) return false;\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation& eq : eqs) {\n\t\t\tflag &= eq.evaluate(s_map);\n\t\t\tif (!flag) break;\n\t\t}\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  if (r.p >= s.size()) throw IterExceedExc;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = factor(s, p);\n  while (r.p+1 < s.size() and (s[r.p] == '+' or s[r.p] == '-')) {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = term(s, p);\n  while (r.p+1 < s.size() and (s[r.p] == '*' or s[r.p] == '/')) {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (p < s.size() and isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#define UNKNOWN 20\n#define UI unsigned int\nusing namespace std;\nint h,w,n;\nchar m[10][10], r[10];\nvector<string> form;\nint map[10]; // u·¶ÖÌÊ\n\nconst int UNCAL = -1111111;\nconst int PLUS  = UNCAL -1;\nconst int MINUS = PLUS  -1;\nint cal( string s ){\n  string a;\n  vector<int> v;\n  bool isNum=true;\n  int kind=0; // 0:+,- 1:* 2:/\n  for( UI i=0;i<s.length();i++ ){\n    if( isNum ){\n      a=\"\";\n      while( i<s.length() && '0'<=s[i] && s[i]<='9' ) a+=s[i++];\n      --i;\n\n      if( a.length()==0 ) return UNCAL;\n      if( a[0]=='0' && a.length()!=1 ) return UNCAL;\n      int number = atoi( a.c_str() );\n\n      if( kind==0 ) v.push_back( number );\n      else if( kind==1 ){ // *\n\tv[ v.size()-1 ] *= number;\n      }else{ // /\n\tif( number==0 ) return UNCAL;\n\tif( v[v.size()-1]%number !=0 ) return UNCAL;\n\tv[ v.size()-1 ] /= number;\n      }\n    }else{\n      kind = 0;\n      if( s[i]=='+' )      v.push_back( PLUS );\n      else if( s[i]=='-' ) v.push_back( MINUS );\n      else if( s[i]=='*' ) kind=1;\n      else if( s[i]=='/' ) kind=2;\n      else return UNCAL;\n    }\n    isNum = !isNum;\n  }\n  if( v.size()==0 ) return UNCAL;\n\n  int ret = v[0];\n  for( UI i=1;i<v.size();i+=2 ){\n    if( v[i]==PLUS && i+1<v.size() ) ret += v[i+1];\n    else if( v[i]==MINUS && i+1<v.size() ) ret-=v[i+1];\n    else return UNCAL;\n  }\n\n  return ret;\n}\n\nbool checkForm( string s ){\n  int a,b;\n  UI i=s.find(\"=\");\n\n  if( i==string::npos || i+1==s.length() )\n    return false;\n  if( (a=cal(s.substr(0,i)))==UNCAL )\n    return false;\n  b = cal( s.substr( i+1 ) );\n\n  return a==b;\n}\n\n\n/* i¶ÚÌóðu··é\n   j-1 ÔÚÜÅÌ form ÍNAµÄ¢éÆ·éB\n */\nbool solve(int i,UI j){\n  string s;\n  // ®`FbN\n  for( ; j<form.size();j++ ){\n    s=\"\";\n    UI k;\n    for( k=0;k<form[j].length();k++ ){\n      if( form[j][k]<10 ){   // ¢mÌ¶iójª¶Ý\n\tif( form[j][k]<i )\n\t  s = s + r[ map[(int)form[j][k]] ];\n\telse                 // ¢è¶ª¶Ý·é®\n\t  k = form[j].length()+100;\n      }else\n\ts = s + form[j][k];\n    }\n    if( k>form[j].length() ) break;\n    if( !checkForm( s ) ) // ®ÆÈçÈ©Á½\n      return false;\n  }\n\n  if( j==form.size() ) return true;\n  if( i==n ) return false;\n\n  // i+1 ÔÚÌ`FbN\n  // map[i+1] É map[j]!=map[i][j] ( j<i )ÆÈélðãü\n  for( int k=0,l;k<n;k++ ){\n    map[i] = k;\n    for( l=0;l<i;l++ )\n      if( map[i] == map[l] ) break;\n    if( l!=i ) continue;\n    if( solve( i+1,j ) )\n      return true;    \n  }\n  return false;\n}\n\nint main(){\n  while( cin>>h>>w && (h||w) ){\n    int in=0; // ó}XCfbNX\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> m[i][j];\n\tif( m[i][j]=='.' ) m[i][j]=in++;\n      }\n    cin >> n;\n    for( int i=0;i<n;i++ )\n      cin >> r[i];\n\n    form.clear();\n    string s;\n    // ¡ûüÌ®\n    for( int i=0;i<h;i++ ){\n      for( int j=0;j<w;j++ ){\n\ts=\"\";\n\twhile( m[i][j]=='#' ) j++;\n\twhile( j<w && m[i][j]!='#' ) s+=m[i][j++];\n\tif( s.length()>2 ) form.push_back( s );\n      }\n    }\n    // cûüÌ®\n    for( int j=0;j<w;j++ ){\n      for( int i=0;i<h;i++ ){\n\ts=\"\";\n\twhile( m[i][j]=='#' ) i++;\n\twhile( i<h && m[i][j]!='#' ) s+=m[i++][j];\n\tif( s.length()>2 ) form.push_back( s );\n      }\n    }\n\n    if( solve( 0,0 ) ) cout << \"Yes\" << endl;\n    else               cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) throw IncorrectExc;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) throw IncorrectExc;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar str[1010];\ntypedef int Int;\n\nInt term(int &i);\nInt fact(int &i);\n\nInt exp(int &i) {\n  Int p = term(i);\n  while(str[i]=='+' || str[i]=='-') {\n    char c = str[i++];\n    if (c == '+') {\n      Int a = term(i);\n      p += a;\n    }\n    else p -= term(i);\n  }\n  return p;\n}\n\nInt term(int &i) {\n  Int p = fact(i);\n  while(str[i]=='*' || str[i]=='/') {\n    if (str[i++] == '*') {\n      p *= fact(i);\n    } else {\n      int r = fact(i);\n      if (r == 0) throw 0;\n      if (p % r == 0) p /= r;\n      else throw 0;\n    }\n  }\n  return p;\n}\n\nInt fact(int &i) {\n  Int p = 0;\n  if (!isdigit(str[i])) throw 0;\n  while(isdigit(str[i])) {\n    p *= 10;\n    p += str[i]-'0';\n    i++;\n  }\n  return p;\n}\n\nInt parse() {\n  int id = 0;\n  Int res = exp(id);\n  if (str[id]) throw 0;\n  return res;\n}\n\ninline bool isoperator(char c) {\n  return c=='+'||c=='-'||c=='*'||c=='/'||c=='=';\n}\n\nbool check(char *s) {\n  try {\n    int n = strlen(s);\n    int pos = -1;\n    REP(i,strlen(s)) if (s[i]=='=') pos = i;\n    if (pos == -1 || pos == 0 || pos == n-1) return 0;\n    for (int i=0; i<pos; ++i) str[i] = s[i]; str[pos] = 0;\n    Int a = parse();\n    for (int i=pos+1; i<n; ++i) str[i-pos-1] = s[i]; str[n-pos-1] = 0;\n    Int b = parse();\n    if (a == b) return 1;\n    else return 0;\n  } catch(int a) {\n    return 0;\n  }\n}\n\n\nchar a[10][10];\nchar b[10];\n\nchar eq[100][11];\n\nint h,w;\n\nbool inserted[10][10];\n\npii pos[100];\nint posNum;\nint eqNum;\nbool visited[10][10][2];\n\nvector<pii> ididx[10][10];\nint dotNum[100];\n\nbool bfs(int y, int x, int dy, int dx) {\n  char s[11];\n  int idx = 0;\n  vector<pii> v;\n  vector<int> id;\n  while(valid(y,x,h,w)) {\n    visited[y][x][dy] = 1;\n    if (a[y][x] == '#') break;\n    if (a[y][x] == '.') {\n      v.push_back(pii(y,x));\n      id.push_back(idx);\n    }\n    s[idx++] = a[y][x];\n    y += dy;\n    x += dx;\n  }\n  if (idx >= 2) {\n    s[idx] = 0;\n    if (v.size() == 0 && !check(s)) return 0;\n    dotNum[eqNum] = v.size();\n    strcpy(eq[eqNum], s);\n    REP(i,v.size()) {\n      int y = v[i].first, x = v[i].second;\n      ididx[y][x].push_back(pii(eqNum,id[i]));\n      if (!inserted[y][x]) {\n        pos[posNum++] = pii(y,x);\n        inserted[y][x] = 1;\n      }\n    }\n    eqNum++;\n  }\n  return 1;\n}\n\nbool checkOp(int id, int idx) {\n  int n = strlen(eq[id]);\n  if (idx && isoperator(eq[id][idx-1])) return 1;\n  if (idx+1<n && isoperator(eq[id][idx+1])) return 1;\n  return 0;\n}\n\nbool numOnly[100];\nint n;\n\nbool dfs(int S, int now) {\n  if (now == posNum) return 1;\n  int y = pos[now].first;\n  int x = pos[now].second;\n  FOR(it, ididx[y][x]) {\n    dotNum[it->first]--;\n  }\n  REP(i,n) {\n    if (S>>i&1) continue;\n    if (!isdigit(b[i]) && numOnly[now]) continue;\n    bool f = 1;\n    FOR(it, ididx[y][x]) {\n      int id = it->first;\n      int idx = it->second;\n      eq[id][idx] = b[i];\n      if (dotNum[id] == 0) {\n        f &= check(eq[id]);\n      }\n    }\n    if (f) {\n      if (dfs(S|1<<i,now+1)) return 1;\n    }\n  }\n  FOR(it, ididx[y][x]) {\n    eq[it->first][it->second] = '.';\n    dotNum[it->first]++;\n  }\n  return 0;\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n    }\n    cin >> n;\n    REP(i,n)cin>>b[i];\n    memset(inserted,0,sizeof(inserted));\n    memset(visited,0,sizeof(visited));\n    posNum = 0, eqNum = 0;\n    REP(i,h)REP(j,w)ididx[i][j].clear();\n    memset(dotNum,0,sizeof(dotNum));\n    REP(i,h) {\n      REP(j,w) {\n        if (a[i][j] == '#') continue;\n        if (!visited[i][j][1]) bfs(i,j,1,0);\n        if (!visited[i][j][0]) bfs(i,j,0,1);\n      }\n    }\n    memset(numOnly,0,sizeof(numOnly));\n    REP(i,posNum) {\n      FOR(it, ididx[pos[i].first][pos[i].second]) {\n        numOnly[i] = checkOp(it->first,it->second);\n      }\n    }\n    // REP(i,eqNum) cout << eq[i] << endl;\n    // REP(i,posNum) {\n    //   cout << numOnly[i] << endl;\n    //   cout << pos[i].first << \" \" << pos[i].second << endl;\n    //   FOR(it, ididx[pos[i].first][pos[i].second]) {\n    //     cout << it->first << \":\" << it->second << endl;\n    //   }cout << endl;\n    // }\n    cout << (dfs(0,0)?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint eval_fact(const string &exp, int &pos) {\n    int val = 0;\n    if(!isdigit(exp.at(pos))) throw \"invalid factor\";\n    while(pos < exp.size() && isdigit(exp.at(pos))) {\n        val *= 10;\n        val += exp.at(pos++)-'0';\n    }\n    return val;\n}\n\nint eval_term(const string &exp, int &pos) {\n    int lhs = eval_fact(exp, pos);\n    while(pos < exp.size()) {\n        char op = exp.at(pos++);\n        if(op == '*') {\n            int rhs = eval_fact(exp, pos);\n            lhs *= rhs;\n        }\n        else if(op == '/') {\n            int rhs = eval_fact(exp, pos);\n            if(rhs == 0 || lhs % rhs != 0) throw \"invalid division\";\n            lhs /= rhs;\n        }\n        else {\n            pos--;\n            break;\n        }\n    }\n    return lhs;\n}\n\nint eval_expression(const string &exp,int &pos) {\n    int lhs = eval_term(exp, pos);\n    while(pos < exp.size()) {\n        char op = exp.at(pos++);\n        if(op == '+') {\n            int rhs = eval_term(exp, pos);\n            lhs += rhs;\n        }\n        else if(op == '-') {\n            int rhs = eval_term(exp, pos);\n            lhs -= rhs;\n        }\n        else {\n            pos--;\n            break;\n        }\n    }\n    return lhs;\n}\n\nint eval(const string &exp) {\n    int pos = 0;\n    if(exp.size() == 0) return 0;\n    int val = eval_expression(exp, pos);\n    if(pos != exp.size()) throw \"invalid expression\";\n    return val;\n}\n\nbool check(const vector<string> &v) {\n    bool ok = true;\n    int H = v.size();\n    for(int r = 0; r < H; ++r) {\n        int start = 0;\n        while(start < v[r].size()) {\n            int bl = v[r].find('#', start);\n            if(bl == string::npos) bl = v[r].size();\n            string eq = v[r].substr(start, bl-start);\n            int epos = eq.find('=');\n            if(eq.size() > 1 && epos != string::npos) {\n                string lhs = eq.substr(0, epos), rhs = eq.substr(epos+1);\n                //cout << eq << '$' << lhs << ' ' << rhs << endl;\n                try {\n                    if(eval(lhs) != eval(rhs)) {\n                        return false;\n                        break;\n                    }\n                } catch (const char *str) {\n                    return false;\n                    break;\n                }\n            }\n            start = bl+1;\n        }\n    }\n    return true;\n}\n\nint main() {\n    while(true) {\n        int H, W;\n        cin >> H >> W;\n        if(!H && !W) break;\n\n        vector<string> field(H);\n        vector<pair<int,int> > space;\n        for(int i = 0; i < H; ++i) {\n            cin >> field[i];\n            field[i] += '#';\n            for(int j = 0; j < W; ++j)\n                if(field[i][j] == '.') space.push_back(make_pair(i, j));\n        }\n\n        int N;\n        cin >> N;\n        vector<char> piece(N);\n        for(int i = 0; i < N; ++i) cin >> piece[i];\n\n        sort(piece.begin(), piece.end());\n        bool hasans = false;\n        do {\n            vector<string> tmp = field;\n            for(int i = 0; i < N; ++i) {\n                pair<int,int> s = space[i];\n                tmp[s.first][s.second] = piece[i];\n            }\n            if(!check(tmp)) continue;\n\n            vector<string> tmpt(W);\n            for(int r = 0; r < H; ++r) {\n                for(int c = 0; c < W; ++c) {\n                    tmpt[c] += tmp[r][c];\n                }\n            }\n            for(int i = 0; i < tmpt.size(); ++i) tmpt[i] += '#';\n\n            if(!check(tmpt)) continue;\n\n            hasans = true;\n            break;\n        } while(next_permutation(piece.begin(), piece.end()));\n        cout << (hasans?\"Yes\":\"No\") << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n\n    if(s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    \n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*'){\n\tres*=num;\n      }\n      if(ch=='/'){\n\tif(num!=0&&res%num>=0)res/=num;\n\telse flag=true;\n\t\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w;\n\nbool solve();\nbool check();\nbool compute();\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3)w.push_back(tmp);\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3)w.push_back(tmp);\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++){\n    v=w[i];\n    if(compute())return true;\n  }\n  return false;\n}\n\nbool compute(){\n  for(int i=0;i<(int)v.size();i++)\n      if('A'<=v[i]&&v[i]<='Z')v[i]=u[v[i]-'A'];\n  string a=\"\",b=\"\";\n  bool flg=false;\n  b.push_back(v[0]);\n  for(int i=1;i<(int)v.size();i++){\n      if(!isNum(v[i-1])&&!isNum(v[i]))return false;\n      if(v[i]=='=')flg=true;\n      else if(flg)a.push_back(v[i]);\n      else b.push_back(v[i]);\n  }\n  if(!isNum(v[0])||!isNum(v[v.size()-1]))return false;\n\n\n  if(v[0]=='0'&&isNum(v[1]))return false;\n\n  if(flg==false)return false;\n\n  calcStr x,y;\n  x.s=a;\n  x.init();\n  y.s=b;\n  y.init();\n\n  int A = x.getAns();\n  int B = y.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n\nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n  void init(){ pos=0;len=s.size(); flag=false; }\n\n  int head2Num(){\n    int res=0;\n\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    if(pos<len&&!isNum(s[pos])){flag=false;return 0;}\n\n    while(1){\n      if(pos==len)break;\n      if('0'<=s[pos]&&s[pos]<='9'){\n\tres*=10;\n\tres+=(s[pos]-'0');\n      }else break;\n      pos++;\n    }\n    \n    return res;\n  }\n  \n  int getNum(){\n    int res=head2Num(),num;\n    while(1){\n      if(pos==len||s[pos]=='+'||s[pos]=='-')break;\n      char ch=s[pos++];\n      num=head2Num();\n      if(ch=='*'){\n\tres*=num;\n      }\n      if(ch=='/'){\n\tif(num!=0&&res%num>=0)res/=num;\n\telse flag=true;\n\t\n      }\n    }\n    return res;\n  }\n  \n  int getAns(){\n    int res=getNum(),num;\n    while(1){\n      if(pos==len||s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n\nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n\nbool solve();\nbool check();\nbool compute(int);\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0||W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n\tt[i][j]=str[j];\n\tif(t[i][j]=='.'){\n\t  t[i][j]='A'+M;\n\t  M++;\n\t}\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n    \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n\tif(t[i][j]=='=')e=j;\n\tif(t[i][j]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n    \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n\tif(t[j][i]=='=')e=j;\n\tif(t[j][i]=='#'){\n\t  if(tmp.size()>=3){\n\t    w.push_back(tmp.substr(0,e));\n\t    w2.push_back(tmp.substr(e+1));\n\t  }\n\t  tmp=\"\";\n\t}else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3){\n\tw.push_back(tmp.substr(0,e));\n\tw2.push_back(tmp.substr(e+1));\n      }\n    }\n\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\nbool solve(){\n  //for(int i=0;i<w.size();i++)cout<<w[i]<<' '<<w2[i]<<endl;\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n\nbool check(){\n  for(int i=0;i<(int)w.size();i++){\n    if(compute(i))return true;\n  }\n  return false;\n}\n\nbool compute(int x){\n  calcStr a,b;\n  a.s=w[x];\n  b.s=w2[x];\n  for(int i=0;i<(int)a.s.size();i++){\n    if('A'<=a.s[i]&&a.s[i]<='Z')a.s[i]=u[a.s[i]-'A'];\n  }\n  for(int i=0;i<(int)b.s.size();i++){\n    if('A'<=b.s[i]&&b.s[i]<='Z')b.s[i]=u[b.s[i]-'A'];\n  }\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\n \nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\n \nstruct calcStr{\n  string s;\n  int pos,len;\n  bool flag;\n \n  void init(){ pos=0;len=s.size();flag=false;}\n \n  int head2Num(){\n    if(pos+1<len&&s[pos]=='0'&&isNum(s[pos+1]))flag=true;\n    int res=0;\n    while(pos<len){\n      if(isNum(s[pos])){\n    res*=10;\n    res+=(s[pos]-'0');\n    pos++;\n      }else break;\n    }\n    return res;\n  }\n   \n  int getNum(){\n    int res=head2Num(),num;\n    char ch;\n    while(s[pos]=='*'||s[pos]=='/'){\n      ch=s[pos++];\n      num=head2Num();\n      if(ch=='*')res*=num;\n      else if(ch=='/'){\n    if(num==0){flag=true;num=1;}\n    if(res%num>0)flag=true;\n    res/=num;\n      }\n    }\n    return res;\n  }\n   \n  int getAns(){\n    if(!isNum(s[0]))return INF;\n    for(int i=1;i+1<len;i++)if(!isNum(s[i-1])&&!isNum(s[i]))return INF;\n \n    int res=getNum(),num;\n    while(1){\n      if(s[pos]=='=')break;\n      char ch=s[pos++];\n      num=getNum();\n      if(ch=='+')res+=num;\n      else if(ch=='-')res-=num;\n    }\n    if(flag)return INF;\n    else return res;\n  }\n};\n \nint H,W,N,M,e;\nstring str;\nstring v;\nchar t[100][100];\nchar u[100];\nvector<string> w,w2;\n \nbool solve();\nbool check();\nbool compute(int);\n \nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    M=0;\n    w.clear();\n    for(int i=0;i<H;i++){\n      cin>>str;\n      for(int j=0;j<W;j++){\n    t[i][j]=str[j];\n    if(t[i][j]=='.'){\n      t[i][j]='A'+M;\n      M++;\n    }\n      }\n    }\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>u[i];\n     \n    string tmp;\n    for(int i=0;i<H;i++){\n      tmp=\"\";\n      for(int j=0;j<W;j++){\n    if(t[i][j]=='=')e=j;\n    if(t[i][j]=='#'){\n      if(tmp.size()>=3&&e>0&&e+1<tmp.size()){\n        w.push_back(tmp.substr(0,e));\n        w2.push_back(tmp.substr(e+1));\n      }\n      tmp=\"\";\n    }else tmp.push_back(t[i][j]);\n      }\n      if(tmp.size()>=3&&e>0&&e+1<tmp.size()){\n    w.push_back(tmp.substr(0,e));\n    w2.push_back(tmp.substr(e+1));\n      }\n    }\n     \n    for(int i=0;i<W;i++){\n      tmp=\"\";\n      for(int j=0;j<H;j++){\n    if(t[j][i]=='=')e=j;\n    if(t[j][i]=='#'){\n      if(tmp.size()>=3&&e>0&&e+1<tmp.size()){\n        w.push_back(tmp.substr(0,e));\n        w2.push_back(tmp.substr(e+1));\n      }\n      tmp=\"\";\n    }else tmp.push_back(t[j][i]);\n      }\n      if(tmp.size()>=3&&e>0&&e+1<tmp.size()){\n    w.push_back(tmp.substr(0,e));\n    w2.push_back(tmp.substr(e+1));\n      }\n    }\n \n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n \nbool solve(){\n  sort(u,u+N);\n  do{\n    if(check())return true;\n  }while(next_permutation(u,u+N));\n  return false;\n}\n \nbool check(){\n  for(int i=0;i<(int)w.size();i++)if(!compute(i))return false;\n  return true;\n}\n \nbool compute(int x){\n  calcStr a,b;\n  a.s=\"\";\n  b.s=\"\";\n  for(int i=0;i<(int)w[x].size();i++){\n    if('A'<=w[x][i]&&w[x][i]<='Z')a.s.push_back(u[w[x][i]-'A']);\n    else a.s.push_back(w[x][i]);\n  }\n  for(int i=0;i<(int)w2[x].size();i++){\n    if('A'<=w2[x][i]&&w2[x][i]<='Z')b.s.push_back(u[w2[x][i]-'A']);\n    else b.s.push_back(w2[x][i]);\n  }\n\n  a.s.push_back('=');\n  b.s.push_back('=');\n  a.init();\n  b.init();\n  int A=a.getAns();\n  int B=b.getAns();\n  if(A==INF||B==INF)return false;\n  return (A==B);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\nint calc(string s)\n{\n  istringstream iss( s );\n  vector<int> num;\n  vector<char> op;\n  int n;\n  char c;\n  while( iss >> n ){    \n    num.push_back( n );\n    if( iss >> c )op.push_back( c );\n    else break;\n  }\n  \n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    else assert( false && \"invalid op\" );\n    num.erase( num.begin() + i + 1);\n    op.erase( op.begin() + i );\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\nbool check_syntax(string s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\n\nstruct F{\n  vector< pair<int, int> > v;\n};\n\nbool solve(char p[], int size, int h, int w)\n{\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  static pair<int, int> emp[10 * 10 + 1];\n  int emp_size = 0;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp[emp_size++] = make_pair(i, j);\n    }\n  }\n\n  if( emp_size != size )return false;\n\n  static char puz[H][W];\n  static F v[1000];\n  int v_size = 0;\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ) v[v_size++] = f;\n    }\n  }  \n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ) v[v_size++] = f;\n    }\n  }\n\n  //clog << v.size() << endl;\n\n  sort( p, p + size );\n  do{\n\n    for(int i=0; i<emp_size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    bool flg = true;\n    for(int i=0; i<v_size && flg; ++i){\n      string s;\n      for(int j=0; j<v[i].v.size(); ++j){\n\tint a = v[i].v[j].first;\n\tint b = v[i].v[j].second;\n\ts += g[a][b];\n      }\n      if( !check_syntax(s) ) flg = false;\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( scanf(\"%d%d\\n\", &h, &w) != EOF && (h | w) ){\n\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tscanf(\"%c\", &g[i][j]);\n      }\n      scanf(\"\\n\");\n    }\n\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n\n    puts( solve(m, n, h, w) ? \"Yes\" : \"No\" );\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint idx;\nchar s[11];\nbool res;\n\n#define ASRT if(!res) return 0\n\nint N(){\n\tif(!('1'<=s[idx] && s[idx]<='9')){ res=false; ASRT; }\n\tint a=0;\n\twhile(isdigit(s[idx])) a=10*a+s[idx++]-'0';\n\treturn a;\n}\n\nint N0(){\n\tint a;\n\tif(s[idx]=='0'){\n\t\tidx++;\n\t\ta=0;\n\t}\n\telse a=N();\n\tASRT;\n\treturn a;\n}\n\nint Ex(){\n\tint a=N0();\n\tASRT;\n\twhile(s[idx]=='+' || s[idx]=='-' || s[idx]=='*' || s[idx]=='/'){\n\t\tchar op=s[idx++];\n\t\tint b=N0();\n\t\tASRT;\n\t\tif(op=='/' && (b==0 || a%b!=0)){ res=false; ASRT; }\n\n\t\tif(op=='+') a+=b;\n\t\tif(op=='-') a-=b;\n\t\tif(op=='*') a*=b;\n\t\tif(op=='/') a/=b;\n\t}\n\treturn a;\n}\n\nint Eq(){\n\tint a=Ex();\n\tASRT;\n\tif(s[idx++]!='='){ res=false; ASRT; }\n\tint b=Ex();\n\tASRT;\n\tif(a!=b || s[idx]) res=false;\n\treturn 0;\n}\n\nbool parse(){\n\tif(strlen(s)<=2) return true;\n\tidx=0;\n\tres=true;\n\tEq();\n\treturn res;\n}\n\nint h,w;\nchar B[10][11];\n\nbool calc_no_space(){\n\trep(i,h){\n\t\tint p=-1;\n\t\trep(j,w+1){\n\t\t\tif(j<w && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\trep(k,j-p) s[k]=B[i][p+k];\n\t\t\t\t\ts[j-p]='\\0';\n\t\t\t\t\tif(strchr(s,'.')==0 && !parse()) return false;\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(j,w){\n\t\tint p=-1;\n\t\trep(i,h+1){\n\t\t\tif(i<h && B[i][j]!='#'){\n\t\t\t\tif(p==-1) p=i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(p!=-1){\n\t\t\t\t\trep(k,i-p) s[k]=B[p+k][j];\n\t\t\t\t\ts[i-p]='\\0';\n\t\t\t\t\tif(strchr(s,'.')==0 && !parse()) return false;\n\t\t\t\t\tp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nchar key[10];\nint n,qx[10],qy[10];\nbool dfs(int k,bool *used){\n\tif(k==n) return true;\n\n\trep(l,n) if(!used[l]) {\n\t\tused[l]=true;\n\t\tB[qy[k]][qx[k]]=key[l];\n\n\t\tbool ok=true;\n\t\tint x1=qx[k],x2=qx[k];\n\t\twhile(x1>=0 && B[qy[k]][x1]!='#') x1--; x1++;\n\t\twhile(x2< w && B[qy[k]][x2]!='#') x2++;\n\t\trep(j,x2-x1) s[j]=B[qy[k]][x1+j];\n\t\ts[x2-x1]='\\0';\n\t\tif(count(s,s+x2-x1,'.')==0 && !parse()) ok=false;\n\n\t\tint y1=qy[k],y2=qy[k];\n\t\twhile(y1>=0 && B[y1][qx[k]]!='#') y1--; y1++;\n\t\twhile(y2< h && B[y2][qx[k]]!='#') y2++;\n\t\trep(i,y2-y1) s[i]=B[y1+i][qx[k]];\n\t\ts[y2-y1]='\\0';\n\t\tif(count(s,s+y2-y1,'.')==0 && !parse()) ok=false;\n\n\t\tif(ok && dfs(k+1,used)) return true;\n\n\t\tused[l]=false;\n\t\tB[qy[k]][qx[k]]='.';\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n) scanf(\" %c\",key+i);\n\n\t\tn=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='.') qx[n]=j, qy[n]=i, n++;\n\n\t\tbool used[10]={};\n\t\tputs(calc_no_space()&&dfs(0,used)?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5,\n          IterExceedExc = 6;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  if (s.size() <= p) throw IterExceedExc;\n  int value = 0;\n  bool flag = false;\n  if (not isdigit(s[p])) { throw LackNumExc; }\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) {\n      throw NotNumExc;\n    }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,w,n;\nchar bd[10][11];\nchar lst[10];\nint dx[10],dy[10];\n\nint eval(char *expr,int s,int t)\n{\n\tif(s>=t)return inf;\n\t\n\tint p=t-1;\n\tfor(;p>=s;p--)if(expr[p]=='+'||expr[p]=='-')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\treturn expr[p]=='+'?a+b:a-b;\n\t}\n\t\n\tfor(p=t-1;p>=s;p--)if(expr[p]=='*'||expr[p]=='/')break;\n\tif(p>=s)\n\t{\n\t\tint a=eval(expr,s,p),b=eval(expr,p+1,t);\n\t\tif(a==inf||b==inf)return inf;\n\t\tif(expr[p]=='/'&&(b==0||a%b!=0))return inf;\n\t\treturn expr[p]=='*'?a*b:a/b;\n\t}\n\t\n\tif(t>s+1&&expr[s]=='0')return inf;\n\t\n\tint ret=0;\n\tfor(p=t-1;p>=s;p--)ret*=10,ret+=expr[p]-'0';\n\treturn ret;\n}\nbool ok(char *expr,int l)\n{\n\tint eq=-1;\n\trep(i,l)if(expr[i]=='=')eq=eq==-1?i:-2;\n\t\n\tassert(eq>=0); assert(l>0);\n\trep(i,l)assert(expr[i]!='.');\n\t\n\tint a=eval(expr,0,eq),b=eval(expr,eq+1,l);\n\treturn a!=inf&&b!=inf&&a==b;\n}\nbool valid(int y,int x)\n{\n\tif(y<0||y>=h||x<0||x>=w)return 0;\n\treturn bd[y][x]!='#';\n}\nint ck(int y,int x)//-1:µ 0:¢mè 1:³µ\n{\n\tint sy,ty,sx,tx;\n\tfor(sy=y-1;valid(sy,x);sy--); for(ty=y+1;valid(ty,x);ty++);\n\tfor(sx=x-1;valid(y,sx);sx--); for(tx=x+1;valid(y,tx);tx++);\n\tsy++; sx++;\n\t\n\tchar tate[11]={0},yoko[11]={0}; int t=0,yo=0;\n\tbool teq=0,yeq=0,tatedot=0,yokodot=0;\n\tfor(int i=sy;i<ty;i++)\n\t{\n\t\ttate[t++]=bd[i][x];\n\t\tif(bd[i][x]=='=')teq=1;\n\t\telse if(bd[i][x]=='.')tatedot=1;\n\t}\n\tfor(int i=sx;i<tx;i++)\n\t{\n\t\tyoko[yo++]=bd[y][i];\n\t\tif(bd[y][i]=='=')yeq=1;\n\t\telse if(bd[y][i]=='.')yokodot=1;\n\t}\n\t\n\tint tok,yok;\n\tif(t>1&&!teq||yo>1&&!yeq)return -1;\n\tif(tatedot)tok=0; else tok=t<=1||ok(tate,t)?1:-1;\n\tif(yokodot)yok=0; else yok=yo<=1||ok(yoko,yo)?1:-1;\n\t\n\treturn tok<0||yok<0?-1:tok>0&&yok>0?1:0;\n}\nbool rec(int c)\n{\n\tif(c==n)\n\t{\n\t\trep(i,h)rep(j,w)if(bd[i][j]=='='&&ck(i,j)<=0)return 0;\n\t\treturn 1;\n\t}\n\t\n\trep(i,n)if(lst[i])\n\t{\n\t\tbd[dy[c]][dx[c]]=lst[i]; lst[i]=0;\n\t\tif(ck(dy[c],dx[c])>=0&&rec(c+1))return 1;\n\t\tlst[i]=bd[dy[c]][dx[c]]; bd[dy[c]][dx[c]]='.';\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\trep(i,h)scanf(\"%s\",bd[i]);\n\t\tscanf(\"%d\",&n);\n\t\trep(i,n)scanf(\" %c\",lst+i);\n\t\t\n\t\tint c=0;\n\t\tbool use[10][10]={0};\n\t\t\n\t\trep(i,h)rep(j,w)if(bd[i][j]=='=')\n\t\t{\n\t\t\tfor(int k=j+1;valid(i,k);k++)if(bd[i][k]=='.'&&!use[i][k])\n\t\t\tuse[i][k]=1,dy[c]=i,dx[c]=k,c++;\n\t\t\t\n\t\t\tfor(int k=j-1;valid(i,k);k--)if(bd[i][k]=='.'&&!use[i][k])\n\t\t\tuse[i][k]=1,dy[c]=i,dx[c]=k,c++;\n\t\t\t\n\t\t\tfor(int k=i+1;valid(k,j);k++)if(bd[k][j]=='.'&&!use[k][j])\n\t\t\tuse[k][j]=1,dy[c]=k,dx[c]=j,c++;\n\t\t\t\n\t\t\tfor(int k=i-1;valid(k,j);k--)if(bd[k][j]=='.'&&!use[k][j])\n\t\t\tuse[k][j]=1,dy[c]=k,dx[c]=j,c++;\n\t\t}\n\t\t\n\t\tputs(rec(0)?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, LL> Result;\nclass ParseError{};\nstruct Parser{\n    Result expr(string s, int p){\n        Result r = term(s, p);\n        while(s[r.first] == '+' || s[r.first] == '-'){\n            Result t = term(s, r.first + 1);\n            if(s[r.first] == '+'){\n                r.second += t.second;\n            }else{\n                r.second -= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result term(string s, int p){\n        Result r = factor(s, p);\n        while(s[r.first] == '*' || s[r.first] == '/'){\n            Result t = factor(s, r.first + 1);\n            if(s[r.first] == '*'){\n                r.second *= t.second;\n            }else{\n                if(t.second == 0) throw ParseError();\n                r.second /= t.second;\n            }\n            r.first = t.first;\n        }\n        return r;\n    }\n    Result factor(string s, int p){\n        if(s[p] == '0'){\n            if(isdigit(s[p + 1])) throw ParseError();\n            return Result(p + 1, 0);\n        }else if(isdigit(s[p])){\n            LL num = 0;\n            while(isdigit(s[p])){\n                num = num * 10 + s[p++] - '0';\n            }\n            return Result(p, num);\n        }else{\n            throw ParseError();\n        }\n    }\n};\nLL parse(string s){\n    LL res = Parser().expr(s, 0).second;\n    //cout << s << \" \" << res << endl;\n    return res;\n}\nchar select_ch[10];\nbool used[10];\nint H, W, L;\nint iter;\nbool dfs(int k, vector<char>& vc, vector<string> check[10]){\n    if(++iter > (1 << 14)) return false;\n    if(k == L) return true;\n    vector<int> perm;\n    for(int i = 0; i < vc.size(); i++) if(!used[i]) perm.push_back(i);\n    random_shuffle(perm.begin(), perm.end());\n    for(auto i : perm) {\n        select_ch[k] = vc[i];\n        used[i] = true;\n        for(auto& s : check[k]){\n            string s1, s2;\n            for(auto c : s) {\n                if(islower(c)){\n                    c = select_ch[ c - 'a' ];\n                }\n                if(c == '='){\n                    if(s2.size() > 0) goto NEXT;\n                    swap(s1, s2);\n                }else{\n                    s1 += c;\n                }\n            }\n            try{\n                if(parse(s1) != parse(s2)) goto NEXT;\n            }catch(ParseError e){\n                goto NEXT;\n            }\n        }\n        if(dfs(k + 1, vc, check)) return true;\n        NEXT:\n        used[i] = false;\n    }\n    return false;\n}\nint main(){\n    while(cin >> H >> W && H){\n        vector<string> grid(H);\n        REP(i, H) cin >> grid[i];\n\n        vector<pair<int, int>> bp;\n        REP(y, H) REP(x, W) if(grid[y][x] == '.') { bp.push_back(make_pair(x, y)); }\n        REP(i, bp.size()) grid[ bp[i].second ][ bp[i].first ] = 'a' + i;\n\n        cin >> L;\n        vector<char> vc(L);\n        for(auto& c : vc) cin >> c;\n        sort(vc.begin(), vc.end());\n\n        vector<string> check[10];\n\n        REP(y, H) REP(x, W) if(grid[y][x] != '#'){\n            if(y < H - 2 && (y == 0 || grid[y - 1][x] == '#') && grid[y + 1][x] != '#' && grid[y + 2][x] != '#'){\n                string s;\n                for(int dy = 0; y + dy < H && grid[y + dy][x] != '#'; dy++){\n                    s += grid[y + dy][x];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n            if(x < W - 2 && (x == 0 || grid[y][x - 1] == '#') && grid[y][x + 1] != '#' && grid[y][x + 2] != '#'){\n                string s;\n                for(int dx = 0; x + dx < W && grid[y][x + dx] != '#'; dx++){\n                    s += grid[y][x + dx];\n                }\n                int maxk = 0;\n                for(auto c : s) if(islower(c)) maxk = max(maxk, c - 'a');\n                check[maxk].push_back(s);\n            }\n        }\n\n        memset(used, 0, sizeof used);\n        iter = 0;\n        bool ans = dfs(0, vc, check);\n\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\npii number(const string& s,int i)\n{\n\t//dump(mt(__PRETTY_FUNCTION__,s,i));\n\tif(s[i]<'1' || '9'<s[i]) throw \"number\";\n\tint x=0;\n\tfor(;i<s.size() && isdigit(s[i]);i++)\n\t\tx=x*10+s[i]-'0';\n\treturn mp(x,i);\n}\npii term(const string& s,int i)\n{\n\tint x; tie(x,i)=number(s,i);\n\twhile(i<s.size()){\n\t\tif(s[i]=='+' || s[i]=='-') break;\n\t\tif(s[i]!='*' && s[i]!='/') throw \"*/\";\n\t\tchar op=s[i];\n\t\tint y; tie(y,i)=number(s,i+1);\n\t\tif(op=='*') x*=y;\n\t\telse{\n\t\t\tif(y==0 || x%y) throw \"/\";\n\t\t\tx/=y;\n\t\t}\n\t}\n\treturn mp(x,i);\n}\nint expr(const string& s)\n{\n\tint x,i; tie(x,i)=term(s,0);\n\twhile(i<s.size()){\n\t\tif(s[i]!='+' && s[i]!='-') throw \"+-\";\n\t\tchar op=s[i];\n\t\tint y; tie(y,i)=term(s,i+1);\n\t\top=='+'?x+=y:x-=y;\n\t}\n\treturn x;\n}\n\nbool check(const vs& grid,const vector<vector<pii>>& fs)\n{\n\tfor(auto f:fs){\n\t\tstring s;\n\t\tfor(auto p:f) s+=grid[p.first][p.second];\n\t\tif(count(all(s),'=')!=1) return false;\n\t\tint eq=s.find('=');\n\t\tif(eq==0 || eq==s.size()-1) return false;\n\t\tstring a=s.substr(0,eq),b=s.substr(eq+1);\n\t\ttry{\n\t\t\tif(expr(a)!=expr(b))\n\t\t\t\treturn false;\n\t\t}\n\t\tcatch(const char* msg){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tint n; cin>>n;\n\t\tstring cs(n,'~');\n\t\trep(i,n) cin>>cs[i];\n\t\t\n\t\tvector<pii> ps;\n\t\tvector<vector<pii>> fs;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='.') ps.emplace_back(i,j);\n\t\t\tif(grid[i][j]!='#'){\n\t\t\t\tif((i==0 || grid[i-1][j]=='#') && i<h-1 && grid[i+1][j]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=i;k<h && grid[k][j]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(k,j);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t\tif((j==0 || grid[i][j-1]=='#') && j<w-1 && grid[i][j+1]!='#'){\n\t\t\t\t\tvector<pii> f;\n\t\t\t\t\tfor(int k=j;k<w && grid[i][k]!='#';k++)\n\t\t\t\t\t\tf.emplace_back(i,k);\n\t\t\t\t\tfs.emplace_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring res=\"No\";\n\t\tvi is(n); iota(all(is),0);\n\t\tdo{\n\t\t\trep(i,n){\n\t\t\t\tint j=is[i];\n\t\t\t\tgrid[ps[i].first][ps[i].second]=cs[j];\n\t\t\t}\n\t\t\tif(check(grid,fs)){\n\t\t\t\tres=\"Yes\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}while(next_permutation(all(is)));\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;                           // 空白の数\nstring p;                        // リストの文字\nvector<vector<string> > formula; // パズル中の数式\nstring change;                   // 各空白に入れる文字\nbool error;                      // 式計算のエラー有無\n\nint calculate(const string& s, int a, int b)\n{\n    if(a > b){\n        error = true;\n        return 0;\n    }\n\n    int k = b;\n    while(k >= a && s[k] != '*' && s[k] != '/')\n        -- k;\n    if(k >= a){\n        int x = calculate(s, a, k-1);\n        int y = calculate(s, k+1, b);\n        if(s[k] == '*'){\n            return x * y;\n        }else{\n            if(y == 0 || x % y != 0){\n                error = true;\n                return 0;\n            }\n            return x / y;\n        }\n    }\n\n    k = b;\n    while(k >= a && s[k] != '+' && s[k] != '-')\n        -- k;\n    if(k >= a){\n        int x = calculate(s, a, k-1);\n        int y = calculate(s, k+1, b);\n        if(s[k] == '+')\n            return x + y;\n        else\n            return x - y;\n    }\n\n    if(b > a && s[a] == '0'){\n        error = true;\n        return 0;\n    }\n\n    int ret = 0;\n    for(int i=a; i<=b; ++i){\n        ret *= 10;\n        ret += s[i] - '0';\n    }\n\n    return ret;\n}\n\nbool check(const string& s)\n{\n    int k = s.find('=');\n    if(k == string::npos || s.find('=', k+1) != string::npos)\n        return false;\n\n    error = false;\n    bool ret = calculate(s, 0, k-1) == calculate(s, k+1, s.size()-1);\n    return !error && ret;\n}\n\nbool solve(int x, bitset<10> bs)\n{\n    if(x == n)\n        return true;\n\n    for(int i=0; i<n; ++i){\n        if(bs[i])\n            continue;\n        bs[i] = true;\n\n        change[x] = p[i];\n        bool ok = true;\n        for(unsigned j=0; j<formula[x].size(); ++j){\n            string t = formula[x][j];\n            for(unsigned k=0; k<t.size(); ++k){\n                if(isalpha(t[k]))\n                    t[k] = change[t[k]-'a'];\n            }\n            if(!check(t))\n                ok = false;\n        }\n\n        if(ok && solve(x+1, bs))\n            return true;\n\n        bs[i] = false;\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> h >> w;\n        if(h == 0)\n            return 0;\n\n        vector<string> s(h+2, string(w+2, '#'));\n        int tmp = 0;\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> s[i][j];\n                if(s[i][j] == '.'){\n                    s[i][j] = 'a' + tmp;\n                    ++ tmp;\n                }\n            }\n        }\n\n        cin >> n;\n        p.assign(n, ' ');\n        for(int i=0; i<n; ++i)\n            cin >> p[i];\n\n        bool ng = false;\n        formula.assign(n, vector<string>());\n        for(int i=0; i<h+2; ++i){\n            char c = 0;\n            string t;\n            for(int j=0; j<w+2; ++j){\n                if(s[i][j] != '#'){\n                    t += s[i][j];\n                    if(isalpha(s[i][j]))\n                        c = s[i][j];\n                }else{\n                    if(t.size() >= 3){\n                        if(c == 0){\n                            if(!check(t))\n                                ng = true;\n                        }else{\n                            formula[c-'a'].push_back(t);\n                        }\n                    }\n                    c = 0;\n                    t = \"\";\n                }\n            }\n        }\n        for(int j=0; j<w+2; ++j){\n            char c = 0;\n            string t;\n            for(int i=0; i<h+2; ++i){\n                if(s[i][j] != '#'){\n                    t += s[i][j];\n                    if(isalpha(s[i][j]))\n                        c = s[i][j];\n                }else{\n                    if(t.size() > 2){\n                        if(c == 0){\n                            if(!check(t))\n                                ng = true;\n                        }else{\n                            formula[c-'a'].push_back(t);\n                        }\n                    }\n                    c = 0;\n                    t = \"\";\n                }\n            }\n        }\n        if(ng){\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        change.assign(n, ' ');\n        if(solve(0, 0))\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nconst int inf = 1e9;\n\nint h,w,n;\nstring g[10];\nchar c[10];\nbool use[10];\nint l[10][10], r[10][10], u[10][10], d[10][10];\n\ninline bool valid(const string &s){\n  rep(i,s.size()){\n    if(s[i]=='0' && (i==0 || !isdigit(s[i-1])) && (i+1<(int)s.size() && isdigit(s[i+1]))){\n      return false;\n    }\n    if(!isdigit(s[i]) && (i==0 || !isdigit(s[i-1]))){\n      return false;\n    }\n  }\n  return isdigit(s.back());\n}\n\nint parse(int L, int R, const string &s){\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '+' || s[i] == '-'){\n      int a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '+')return a+b;\n      if(s[i] == '-')return a-b;\n    }\n  }\n\n  for(int i=R-1;i>=L;i--){\n    if(s[i] == '*' || s[i] == '/'){\n      int a = parse(L,i,s), b = parse(i+1,R,s);\n      if(a==inf || b==inf)return inf;\n      if(s[i] == '*')return a*b;\n      if(s[i] == '/'){\n\tif(b==0 || a%b)return inf;\n\treturn a/b;\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=L;i<R;i++)res = res*10 + (int)(s[i]-'0');\n  return res;\n}\n\ninline bool check(const string &s){\n  if(!valid(s))return false;\n\n  int p = 0;\n  while(s[p]!='=')p++;\n  assert(p!=(int)s.size());\n  int a = parse(0,p,s);\n  int b = parse(p+1,s.size(),s);\n  if(a==inf || b==inf)return false;\n  return a==b;\n}\n\nbool solve(int y, int x){\n  if(y==h)return true;\n\n  int ny = y, nx = x+1;\n  if(nx==w)ny++, nx=0;\n\n  if(g[y][x] != '.')return solve(ny,nx);\n\n  rep(i,n){\n    if(!use[i]){\n      use[i] = 1;\n      g[y][x] = c[i];\n\n      bool f = true;\n      if(l[y][x]>=0){\n\tstring s;\n\tfor(int j=l[y][x];j<r[y][x];j++)s += g[y][j];\n\tif(!check(s))f = false;\n      }\n\n      if(f && u[y][x]>=0){\n\tstring s;\n\tfor(int j=u[y][x];j<d[y][x];j++)s += g[j][x];\n\tif(!check(s))f = false;\n      }\n\n      if(f && solve(ny,nx))return true;\n\n      g[y][x] = '.';\n      use[i] = 0;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> h >> w, h){\n    rep(i,h)cin >> g[i];\n    cin >> n;\n    rep(i,n)cin >> c[i];\n\n    memset(l,-1,sizeof(l)); memset(r,-1,sizeof(r));\n    memset(u,-1,sizeof(u)); memset(d,-1,sizeof(d));\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '.'){\n\tint cnt = 0;\n\tfor(int k=j+1;k<w;k++){\n\t  if(g[i][k] == '.')cnt++;\n\t  if(g[i][k] == '#')break;\n\t}\n\tif(cnt==0){\n\t  l[i][j] = 0; r[i][j] = w;\n\t  for(int k=j-1;k>=0;k--){\n\t    if(g[i][k] == '#'){\n\t      l[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=j+1;k<w;k++){\n\t    if(g[i][k] == '#'){\n\t      r[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(r[i][j]-l[i][j]<3)r[i][j] = l[i][j] = -1;\n\t}\n\n\tcnt = 0;\n\tfor(int k=i+1;k<h;k++){\n\t  if(g[k][j] == '.')cnt++;\n\t  if(g[k][j] == '#')break;\n\t}\n\tif(cnt==0){\n\t  u[i][j] = 0; d[i][j] = h;\n\t  for(int k=i-1;k>=0;k--){\n\t    if(g[k][j] == '#'){\n\t      u[i][j] = k+1;\n\t      break;\n\t    }\n\t  }\n\t  for(int k=i+1;k<h;k++){\n\t    if(g[k][j] == '#'){\n\t      d[i][j] = k;\n\t      break;\n\t    }\n\t  }\n\t  if(d[i][j]-u[i][j]<3)d[i][j] = u[i][j] = -1;\n\t}\n      }\n    }\n    \n    memset(use,0,sizeof(use));\n    if(solve(0,0))cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n\ntypedef long long int lli;\n\nusing namespace std;\n\nconst int H = 10 + 1;\nconst int W = 10 + 1;\n\nint total = 0;\n\nchar g[H][W];\n\nint calc(string s)\n{\n  istringstream iss( s );\n  vector<int> num;\n  vector<char> op;\n  int n;\n  char c;\n  while( iss >> n ){    \n    num.push_back( n );\n    if( iss >> c )op.push_back( c );\n    else break;\n  }\n  \n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' || op[i] == '-' ) continue;\n    else if( op[i] == '*' ) num[i] *= num[i+1];\n    else if( op[i] == '/' ) num[i] /= num[i+1];\n    else assert( false && \"invalid op\" );\n    num.erase( num.begin() + i + 1);\n    op.erase( op.begin() + i );\n    --i;\n  }\n\n  int ret = num[0];\n  for(int i=0; i<op.size(); ++i){\n    if( op[i] == '+' )ret += num[i+1];\n    if( op[i] == '-' )ret -= num[i+1];     \n  }\n\n  return ret;\n}\n\ninline bool is_op(char c){ return !isdigit(c); }\n\nbool check_syntax(string s)\n{\n  if( count( s.begin(), s.end(), '=' ) != 1 )return false;\n  string t[2];\n  for(int i = 0, j=0; i<s.size(); ++i){\n    if( s[i] == '=' ){ ++j; continue; }\n    t[j] += s[i];\n  }\n \n  if( t[0].size() == 0 )return false;\n  if( t[1].size() == 0 )return false;\n\n  for(int i=0; i<2; ++i){\n    for(int j=0; j<t[i].size(); ++j){\n      if( !is_op(t[i][j]) ) continue;\n      if( j == 0 || j+1 == t[i].size() )return false;\n      if( is_op( t[i][j-1] ) || is_op( t[i][j+1] ) )return false;\n    }\n  }\n  \n  return calc(t[0]) == calc(t[1]);\n}\n\n\nstruct F{\n  vector< pair<int, int> > v;\n  F(){ v.clear(); }\n};\n\nstring build(F f)\n{\n  string s;\n  for(int i=0; i<f.v.size(); ++i){\n    s += g[ f.v[i].first ][ f.v[i].second ];\n  }\n  return s;\n}\n\nlli cpy(char c)\n{\n  if( isdigit(c) ) return c - '0';\n  if( c == '+' ) return 10;\n  if( c == '*' ) return 11;\n  if( c == '/' ) return 12;\n  if( c == '-' ) return 13;\n  return -(1LL << 60);\n}\n\nbool solve(char p[], int size, int h, int w)\n{\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '#' ) continue;\n      const int di[] = {0, 0, -1, 1};\n      const int dj[] = {-1, 1, 0, 0};\n      bool flg = false;\n      for(int d=0; d<4 && !flg; ++d){\n\tint ni = i + di[d];\n\tint nj = j + dj[d];\n\tif( ni < 0 || nj < 0 )continue;\n\tif( h <= ni || w <= nj )continue;\n\tflg = g[ni][nj] != '#';\n      }\n      if( !flg )return false;\n    }\n  }\n\n  static pair<int, int> emp[10 * 10 + 1];\n  int emp_size = 0;\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( g[i][j] == '.' ) emp[emp_size++] = make_pair(i, j);\n    }\n  }\n\n  if( emp_size != size )return false;\n\n  static char puz[H][W];\n  static F v[1000];  \n\n  fill( v, v + 1000, F() );\n\n  int v_size = 0;\n\n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i;\n\tint nj = j + l;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }  \n\n  if( v_size == 0 )return true;\n  \n  copy( g[0], g[H], puz[0] );\n  for(int i=0; i<h; ++i){\n    for(int j=0; j<w; ++j){\n      if( puz[i][j] == '#' )continue;\n\n      bool filled = true;\n      F f;\n      for(int l=0; ; ++l){\n\tint ni = i + l;\n\tint nj = j;\n\tif( h <= ni || w <= nj )break;\n\tif( puz[ni][nj] == '#' )break;\n\tf.v.push_back( make_pair(ni, nj) );\n\tif( puz[ni][nj] == '.' ) filled = false;\n\tpuz[ni][nj] = '#';\n      }\n      if( 1 < f.v.size() ){\n\tif( !filled ) v[v_size++] = f;\n\telse{\n\t  if( !check_syntax( build( f ) ) )return false;\n\t}\n      }\n    }\n  }\n\n  sort( p, p + size );\n  set<lli> T, F;\n  do{\n\n    for(int i=0; i<emp_size; ++i){\n      g[ emp[i].first ][ emp[i].second ] = p[i];\n    }\n    bool flg = true;\n    for(int i=0; i<v_size && flg; ++i){\n      string s;\n      lli h = 0;\n      for(int j=0; j<v[i].v.size(); ++j){\n\tint a = v[i].v[j].first;\n\tint b = v[i].v[j].second;\n\ts += g[a][b];\n\th = (h + cpy( g[a][b] )) * 19LL;\n\th %= 1LL << 60;\n      }\n      if( F.count( h ) ) flg = false;\n      else if( T.count( h ) ) flg = true;\n      else if( !check_syntax(s) ){\n\tF.insert( h );\n\tflg = false;\n      }\n      else T.insert( h );\n    }    \n    if( flg ) return true;\n\n  }while( next_permutation( p, p + size ) );\n\n  return false;\n}\n\nint main(void)\n{\n  int h, w;\n  while( scanf(\"%d%d\\n\", &h, &w) != EOF && (h | w) ){\n    for(int i=0; i<h; ++i){\n      for(int j=0; j<w; ++j){\n\tscanf(\"%c\", &g[i][j]);\n      }\n      scanf(\"\\n\");\n    }\n    int n;\n    char m[10];\n    cin >> n;\n    for(int i=0; i<n; ++i){\n      cin >> m[i];\n    }\n    puts( solve(m, n, h, w) ? \"Yes\" : \"No\" );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cctype>\n#include<cstring>\n#include<iomanip>\n\n\n#define MAX 256\nusing namespace std;\n\n\ntypedef pair<const char *, int > parsed;\ntypedef pair<bool,int> bnfm;\n\nparsed expr(const char *);\nparsed term(const char *);\nparsed fact(const char *);\n\nbnfm Ex(int pos, const string &s);\nbnfm N0(int pos, const string &s);\n\nparsed expr(const char *p){\n  parsed r = term(p);\n  if( r.first == NULL ) return r; // parse error\n  while( *(r.first)=='+' || *(r.first)=='-' ){\n    const char *op = r.first;\n    parsed l = term(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='+' ){\n      r.first = l.first;\n      r.second = r.second + l.second;\n    }else{\n      r.first = l.first;\n      r.second = r.second - l.second;\n    }\n  }\n  return r;\n}\n\nparsed term(const char *p){\n  parsed r = fact(p);\n  if( r.first == NULL ) return r;\n  while( *(r.first)=='*' || *(r.first)=='/' ){\n    const char *op = r.first;\n    parsed l = fact(op+1);\n    if( l.first == NULL ) return l;\n\n    if( *op=='*' ){\n      r.first = l.first;\n      r.second = r.second * l.second;\n    }else{\n      r.first = l.first;\n      if( l.second == 0 || r.second % l.second != 0 ) return parsed(NULL,-1);\n      r.second = int(r.second / l.second);\n    }\n  }\n  return r;\n}\n\nparsed fact(const char *p){\n  if( *p=='(' ){\n    // new expression\n    parsed tp = expr(p+1);\n    if( tp.first == NULL ) return tp;\n    return parsed(tp.first+1, tp.second);\n  }\n  if( *p=='-' ){\n    // negative fact\n    parsed tp = fact(p+1);\n    if( tp.first == NULL ) return tp;\n    tp.second *= -1;\n    return tp;\n  }\n  if( isdigit(*p) ){\n    // number\n    int num = *p - '0';\n    while( isdigit(*(++p)) ){\n      num *= 10;\n      num += *p - '0';\n    }\n    return parsed(p,num);\n  }else assert(0); return parsed(NULL,0);\n}\n\nbool Eq(const string &s){\n  int pos = 0;\n  bnfm r = Ex(pos,s);\n  if( !r.first ) return false;\n  pos = r.second;\n  if( pos >= s.length() ) return false;\n  if( s[pos] != '=' ) return false;\n  ++pos;\n  r = Ex(pos,s);\n  if( !r.first ) return false;\n  if( r.second < s.length() ) return false;\n  return true;\n}\n\nbnfm Ex(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm(false,pos);\n  bnfm r = N0(pos,s);\n  if( !r.first ) return bnfm(false,r.second);\n  pos = r.second;\n  if( pos >= s.length() ) return bnfm(true,pos);\n  while( s[ pos ] == '+' || s[ pos ] == '-' || s[ pos ] == '*' || s[ pos ] == '/' ){\n    bnfm r = N0( pos+1, s );\n    if( !r.first ) return bnfm(false,r.second);\n    pos = r.second;\n    if( pos >= s.length() ) break;\n  }\n  return bnfm(true,pos);\n}\n\nbnfm N0(int pos, const string &s){\n  if( pos >= s.length() ) return bnfm( false,pos );\n  if( !isdigit( s[pos] ) ) return bnfm(false,pos+1);\n  if( s[pos] == '0' ){\n    if( pos + 1 < s.length() ){\n      if( isdigit( s[pos+1] ) ) return bnfm(false,pos+2);\n    }\n    return bnfm(true,pos+1);\n  }else{\n    while( isdigit(s[pos]) ){\n      ++pos;\n      if( pos >= s.length() ) break;\n    }\n    return bnfm(true,pos);\n  }\n}\n\nbool Evaluate(const string &s){\n  string s1,s2;\n  int i,j;\n  for(i = 0; i < s.length(); ++i){\n    if( s[i] == '=' ) break;\n    else s1 += s[i];\n  }\n  for(j=i+1; j < s.length(); ++j){\n    s2 += s[j];\n  }\n  parsed p1 = expr(s1.c_str());\n  parsed p2 = expr(s2.c_str());\n  if( p1.first == NULL || p2.first == NULL ) return false;\n  if( p1.second == p2.second ) return true;\n  else return false;\n}\n\n#define NMAX 11\n\nbool Judge(int H, int W, char pzl[][MAX]){\n  vector<string> eqs;\n  const int di [] = {-1,0,1,0};\n  const int dj [] = {0,1,0,-1};\n\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if( pzl[i+1][j+1] != '#' ){ \n\tfor(int l = 0; l < sizeof(di)/sizeof(*di); ++l){\n\t  if( l == 1 || l == 2 ) continue;\n\t  int ti = i + 1 + di[l]; int tj = j + 1 + dj[l];\n\t  if( pzl[ti][tj] == '#' ){\n\t    int dir = (l+2)%(sizeof(di)/sizeof(*di));\n\t    ti = i+1+di[dir]; tj = j+1+dj[dir];\n\t    string eq;\n\t    eq += pzl[i+1][j+1];\n\t    while(pzl[ti][tj]!='#'){\n\t      eq += pzl[ti][tj]; ti += di[dir]; tj += dj[dir];\n\t    }\n\t    if( eq.length() >= 3 && eq.find('.') == string::npos ){\n\t      if( !Eq(eq) ) return false;\n\t      if( !Evaluate( eq ) ) return false;\n\t      eqs.push_back( eq );\n\t    }\n\t    eq.clear();\n\t  }\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nbool dfs(int n, int now, const vector<pair<int,int> > &hole_pos,\n\t bool vis[NMAX], char holes[NMAX], int H, int W, char pzl[][MAX] ){\n\n  if( !Judge(H,W,pzl) ){\n    return false;\n  }else if( now == hole_pos.size() ){\n    return true;\n  }\n\n  for(int i = 0; i < n; ++i){\n    if( !vis[i] ){\n      vis[i]=true;\n      pair<int,int> pi = hole_pos[ now ];\n      char tmp = pzl[pi.first][pi.second];\n      pzl[pi.first][pi.second] = holes[ i ];\n      \n      if( dfs( n, now+1, hole_pos, vis, holes, H,W, pzl ) ) return true;\n      \n      pzl[pi.first][pi.second] = tmp;\n      vis[i]=false;\n    }\n  }\n  return false;\n}\n\nint main(void){\n  while(true){\n    int H,W;\n    char pzl[MAX][MAX];\n    bool vis[NMAX]={false,};\n    vector< pair<int,int> > hole_pos;\n    for(int i = 0; i < MAX; ++i)for(int j = 0; j < MAX; ++j)pzl[i][j]='#';\n    \n    cin >> H >> W;\n    if( H == 0 && W == 0) break;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> pzl[i+1][j+1];\n\tif(pzl[i+1][j+1] == '.' ){\n\t  hole_pos.push_back( make_pair(i+1,j+1) );\n\t}\n      }\n    }\n    \n    int n,num=0;\n    cin >> n;\n    int p[n];\n    char holes[n];\n    for(int i = 0; i < n; ++i){\n      char d; cin >> d; holes[num++] = d; p[i] = i;\n    }\n    \n    if( dfs(n,0,hole_pos,vis,holes,H,W,pzl) ){\n      cout << \"Yes\" << endl;\n    }else{\n      cout << \"No\" <<endl;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i, b) for( int i = 0; i < b; i++ )\ntypedef vector<char> vec;\n\n// char op[5] = { '=', '-', '+' , '*', '/' };\n// char num[10] = {'0','1','2','3','4','5','6','7','8','9'};\n\nint main(){\n    int h, w;\n    while( cin >> h >> w, h ){\n        vector< vector<int> > exist( h, vector<int>(w) );\n        fill( exist.begin(), exist.end(), 0 );\n        vector< vec > grid( h, vec(w) );\n        rep(i, h){\n            rep(j, w){\n                char cell;\n                cin >> cell;\n                grid[i][j] = cell;\n                if( cell != '#' ) exist[i][j]++;\n            }\n        }\n        vector< vec > formula;\n        rep(i, h){\n            rep(j, w){\n                if( exist[i][j] && exist[i][j+1] ){\n                    int k = 0;\n                    vec fml;\n                    while( exist[i][j+k] ){\n                        fml.push_back( grid[i][j+k] );\n                        exist[i][j+k]--;\n                        k++;\n                    }\n                    formula.push_back(vec(fml));\n                }\n                if( exist[i][j] && exist[i+1][j] ){\n                    int k = 0;\n                    vec fml;\n                    while( exist[i+k][j] ){\n                        fml.push_back( grid[i+k][j] );\n                        exist[i+k][j]--;\n                        k++;\n                    }\n                    formula.push_back(vec(fml));\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cctype>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> V;\nint H, W, N;\nchar M[10][10], T[10];\nbool flag;\n\nconst int INF = 1<<24;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint getNum(string &s, int &pos) {\n  int st = pos;\n  int l = 0;\n  if(!isdigit(s[pos])) {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  while(pos < s.size() && isdigit(s[pos])) {\n    //    num += s[pos++];\n    ++pos;\n    ++l;\n  }\n  //if(num[0] == '0') {\n  if(s[st] == '0') {\n    pos = s.size();\n    flag = true;\n    return INF;\n  }\n  return atoi(s.substr(st, l).c_str());\n}\n\n\nint term(string &s, int &pos) {\n  int value = getNum(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '*') {\n      ++pos;\n      value = getNum(s, pos);\n      if(value == INF) return INF;\n      x *= value;\n    } else if(s[pos] == '/') {\n      ++pos;\n      int tmp = getNum(s, pos);\n      if(tmp == INF) return INF;\n      if(tmp == 0 || x % tmp != 0) {\n\tflag = true;\n\treturn INF;\n      }\n      x /= tmp;\n    } else {\n      break;\n    }\n  }\n  return x;\n}\n\nint exp(string &s, int &pos) {\n  int value = term(s, pos);\n  if(value == INF) return INF;\n  int x = value;\n  while(pos < s.size()) {\n    if(s[pos] == '+') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x += value;\n    } else if(s[pos] == '-') {\n      ++pos;\n      value = term(s, pos);\n      if(value == INF) return INF;\n      x -= value;\n    }else {\n      break;\n    }\n  }\n  return x;\n}\n\nint check(int x, int y, int dir) {\n  string s[2];\n  s[0] = s[1] = \"\";\n  int p = 0;\n  int a, b;\n\n  do {\n    if(M[y][x] == '=') {\n      ++p;\n    } else {\n      s[p] += M[y][x];\n    }\n    x += dx[dir];\n    y += dy[dir];\n  } while(x < W && y < H);\n  for(int i = 0; i < 2; ++i)\n    if(!isdigit(s[i][0]) || !isdigit(s[i][(int)s[i].size()-1])) return false;\n\n  int pos;\n  flag = false;\n\n  pos = 0;\n  a = exp(s[0], pos);\n  pos = 0;\n  b = exp(s[1], pos);\n\n  return !flag && a == b;\n}\n\nbool judge() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if((j == 0 || M[i][j-1] == '#') &&\n\t M[i][j] != '#' && j+2 < W && M[i][j+1] != '#' && M[i][j+2] != '#') {\n\tif(!check(j, i, 0)) return false;\n\n      }\n      if((i == 0 || M[i-1][j] == '#') &&\n\t M[i][j] != '#' && i+2 < H && M[i+1][j] != '#' && M[i+2][j] != '#') {\n\tif(!check(j, i, 1)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nbool rec(int t) {\n  if(t == N) {\n    return judge();\n  }\n\n  for(int i = 0; i < N; ++i) {\n    int x = V[i].first;\n    int y = V[i].second;\n    if(M[y][x] != '.') continue;\n    int type = -1; // 0:Num, 1:Operator\n    for(int i = 0; i < 4; ++i) {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < 0 || nx >= W) continue;\n      if(ny < 0 || ny >= H) continue;\n      if(M[ny][nx] != '#' && M[ny][nx] != '.') {\n\tif(!isdigit(M[ny][nx])) {\n\t  type = 1;\n\t  break;\n\t}\n      }\n    }\n    if(!isdigit(T[t]) && type == 1) continue;\n\n    M[y][x] = T[t];\n    if(rec(t+1)) return true;\n    M[y][x] = '.';\n  }\n  return false;\n}\n\nint main() {\n  while((cin >> H >> W) && (H || W)) {\n    V.clear();\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '.') V.push_back(P(j, i));\n      }\n    }\n\n    cin >> N;\n    for(int i = 0; i < N; ++i) cin >> T[i];\n    sort(T, T+N);\n    if(rec(0)) cout << \"Yes\" << endl;\n    else        cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct invalid {};\ntypedef const char *Iterator;\n\nint eval_factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw invalid();\n  }\n  if (*it < '0' || '9' < *it) {\n    throw invalid();\n  }\n  int val = *it - '0';\n  ++it;\n  if (val == 0) {\n    return val;\n  }\n  while (it != last && '0' <= *it && *it <= '9') {\n    val = 10*val + (*it - '0');\n    ++it;\n  }\n  return val;\n}\n\nint eval_term(Iterator& it, const Iterator& last)\n{\n  int val = eval_factor(it, last);\n  while (it != last && (*it == '*' || *it == '/')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_factor(it, last);\n    if (op == '*') {\n      val *= x;\n    } else {\n      val /= x;\n    }\n  }\n  return val;\n}\n\nint eval_expr(Iterator& it, const Iterator& last)\n{\n  int val = eval_term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_term(it, last);\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return val;\n}\n\nbool check(Iterator it, const Iterator& last) try\n{\n  const int l = eval_expr(it, last);\n  if (it == last || *it != '=') {\n    return false;\n  }\n  ++it;\n  const int r = eval_expr(it, last);\n  return it == last && l == r;\n} catch (const invalid&) {\n  return false;\n}\n\nstatic const int M = 15;\n\nbool extract_expr(char (*dst)[M], pair<int,int> (*tbl)[2], const char rows[M][M], int H, int W, int& s)\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (j == 0 || rows[i][j-1] == '#') {\n        const int k = j;\n        ++j;\n        while (j < W && rows[i][j] != '#') {\n          ++j;\n        }\n        if (j-k > 2) {\n          bool b = false;\n          for (int l = k; l < j; l++) {\n            dst[s][l] = rows[i][l];\n            if (rows[i][l] >= 'a') {\n              b = true;\n              pair<int,int> *t = tbl[rows[i][l]-'a'];\n              if (t[0].first != -1) {\n                t[1].first = s;\n                t[1].second = l;\n              } else {\n                t[0].first = s;\n                t[0].second = l;\n              }\n            }\n          }\n          if (b) {\n            dst[s][j-k] = '\\0';\n            ++s;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(char (*exprs)[M], int s, char *cards, int N, const pair<int,int> (*tbl)[2])\n{\n  do {\n    for (int i = 0; i < N; i++) {\n      if (tbl[i][0].first >= 0) {\n        exprs[tbl[i][0].first][tbl[i][0].second] = cards[i];\n      }\n      if (tbl[i][1].first >= 0) {\n        exprs[tbl[i][1].first][tbl[i][1].second] = cards[i];\n      }\n    }\n    for (int i = 0; i < s; i++) {\n      if (!check(exprs[i], exprs[i]+strlen(exprs[i]))) {\n        goto FAIL;\n      }\n    }\n    return true;\nFAIL:\n    ;\n  } while (next_permutation(cards, cards+N));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (scanf(\"%d %d\", &H, &W) != EOF && H != 0) {\n    char rows[M][M], cols[M][M];\n    int n = 0;\n    for (int i = 0; i < H; i++) {\n      scanf(\"%s\", rows[i]);\n      for (int j = 0; j < W; j++) {\n        if (rows[i][j] == '.') {\n          rows[i][j] = 'a' + n;\n          ++n;\n        }\n        cols[j][i] = rows[i][j];\n        cols[j][H] = '\\0';\n      }\n    }\n    int N;\n    scanf(\"%d\", &N);\n    char cards[M];\n    for (int i = 0; i < N; i++) {\n      char buf[4];\n      scanf(\"%s\", buf);\n      cards[i] = buf[0];\n    }\n    sort(cards, cards+N);\n    cards[N] = '\\0';\n\n    static char exprs[100][M];\n    static pair<int,int> tbl[10][2];\n    for (int i = 0; i < 10; i++) {\n      tbl[i][0].first = tbl[i][1].second = -1;\n    }\n    int s = 0;\n    if (!extract_expr(exprs, tbl, rows, H, W, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (!extract_expr(exprs, tbl, cols, W, H, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (s == 0) {\n      puts(\"Yes\");\n      continue;\n    }\n    if (solve(exprs, s, cards, N, tbl)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct invalid {};\ntypedef const char *Iterator;\n\nint eval_factor(Iterator& it, const Iterator& last)\n{\n  if (it == last) {\n    throw invalid();\n  }\n  if (*it < '0' || '9' < *it) {\n    throw invalid();\n  }\n  int val = *it - '0';\n  ++it;\n  if (val == 0) {\n    return val;\n  }\n  while (it != last && '0' <= *it && *it <= '9') {\n    val = 10*val + (*it - '0');\n    ++it;\n  }\n  return val;\n}\n\nint eval_term(Iterator& it, const Iterator& last)\n{\n  int val = eval_factor(it, last);\n  while (it != last && (*it == '*' || *it == '/')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_factor(it, last);\n    if (op == '*') {\n      val *= x;\n    } else {\n      val /= x;\n    }\n  }\n  return val;\n}\n\nint eval_expr(Iterator& it, const Iterator& last)\n{\n  int val = eval_term(it, last);\n  while (it != last && (*it == '+' || *it == '-')) {\n    const char op = *it;\n    ++it;\n    const int x = eval_term(it, last);\n    if (op == '+') {\n      val += x;\n    } else {\n      val -= x;\n    }\n  }\n  return val;\n}\n\nbool check(Iterator it, const Iterator& last) try\n{\n  const int l = eval_expr(it, last);\n  if (it == last || *it != '=') {\n    return false;\n  }\n  ++it;\n  const int r = eval_expr(it, last);\n  return it == last && l == r;\n} catch (const invalid&) {\n  return false;\n}\n\nstatic const int M = 15;\n\nbool extract_expr(char (*dst)[M], pair<int,int> (*tbl)[2], const char rows[M][M], int H, int W, int& s)\n{\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (j == 0 || rows[i][j-1] == '#') {\n        const int k = j;\n        ++j;\n        while (j < W && rows[i][j] != '#') {\n          ++j;\n        }\n        if (j-k > 2) {\n          bool b = false;\n          for (int l = k; l < j; l++) {\n            dst[s][l] = rows[i][l];\n            if (rows[i][l] >= 'a') {\n              b = true;\n              pair<int,int> *t = tbl[rows[i][l]-'a'];\n              if (t[0].first != -1) {\n                t[1].first = s;\n                t[1].second = l;\n              } else {\n                t[0].first = s;\n                t[0].second = l;\n              }\n            }\n          }\n          if (b) {\n            dst[s][j-k] = '\\0';\n            ++s;\n          } else {\n            if (!check(rows[i]+k, rows[i]+j)) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nbool solve(char (*exprs)[M], int s, char *cards, int N, const pair<int,int> (*tbl)[2])\n{\n  do {\n    for (int i = 0; i < N; i++) {\n      if (tbl[i][0].first >= 0) {\n        exprs[tbl[i][0].first][tbl[i][0].second] = cards[i];\n      }\n      if (tbl[i][1].first >= 0) {\n        exprs[tbl[i][1].first][tbl[i][1].second] = cards[i];\n      }\n    }\n    for (int i = 0; i < s; i++) {\n      if (!check(exprs[i], exprs[i]+strlen(exprs[i]))) {\n        goto FAIL;\n      }\n    }\n    return true;\nFAIL:\n    ;\n  } while (next_permutation(cards, cards+N));\n  return false;\n}\n\nint main()\n{\n  int H, W;\n  while (scanf(\"%d %d\", &H, &W) != EOF && H != 0) {\n    char rows[M][M], cols[M][M];\n    int n = 0;\n    for (int i = 0; i < H; i++) {\n      scanf(\"%s\", rows[i]);\n      for (int j = 0; j < W; j++) {\n        if (rows[i][j] == '.') {\n          rows[i][j] = 'a' + n;\n          ++n;\n        }\n        cols[j][i] = rows[i][j];\n        cols[j][H] = '\\0';\n      }\n    }\n    int N;\n    scanf(\"%d\", &N);\n    char cards[M];\n    for (int i = 0; i < N; i++) {\n      char buf[4];\n      scanf(\"%s\", buf);\n      cards[i] = buf[0];\n    }\n    sort(cards, cards+N);\n    cards[N] = '\\0';\n\n    static char exprs[100][M];\n    static pair<int,int> tbl[10][2];\n    for (int i = 0; i < 10; i++) {\n      tbl[i][0].first = tbl[i][1].second = -1;\n    }\n    int s = 0;\n    if (!extract_expr(exprs, tbl, rows, H, W, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (!extract_expr(exprs, tbl, cols, W, H, s)) {\n      puts(\"No\");\n      continue;\n    }\n    if (s == 0) {\n      puts(\"Yes\");\n      continue;\n    }\n    if (solve(exprs, s, cards, N, tbl)) {\n      puts(\"Yes\");\n    } else {\n      puts(\"No\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nclass Equation {\npublic:\n\tstring A, B;\n\tEquation(string S) {\n\t\tint p = S.find(\"=\");\n\t\tA = S.substr(0, p);\n\t\tB = S.substr(p+1);\n\t\t// cerr << A << \" \" << B << endl;\n\t}\n\t\n\tstring convert(string S, string symbol_map) {\n\t\tfor (char& c : S) if ('a' <= c && c <= 'z') c = symbol_map[c - 'a'];\n\t\treturn S;\n\t}\n\t\n\tpair< int, bool > calculate(string S) {\n\t\tstack< char > stack_op;\n\t\tstack< int > stack_num;\n\t\t\n\t\tauto calc = [&]() {\n\t\t\tchar op = stack_op.top(); stack_op.pop();\n\t\t\tint b = stack_num.top(); stack_num.pop();\n\t\t\tint a = stack_num.top(); stack_num.pop();\n\t\t\t//cerr << a << op << b << endl;\n\t\t\tif (op == '+') stack_num.push(a + b);\n\t\t\tif (op == '-') stack_num.push(a - b);\n\t\t\tif (op == '*') stack_num.push(a * b);\n\t\t\tif (op == '/') {\n\t\t\t\tif (b == 0) return false;\n\t\t\t\tif (a % b != 0) return false;\n\t\t\t\tstack_num.push(a / b);\n\t\t\t}\n\t\t\treturn true;\t\n\t\t};\n\t\t\n\t\tS += '#';\n\t\tint num = -1;\n\t\tfor (char c : S) {\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (num == -1) num = 0;\n\t\t\t\tnum = 10 * num + (c - '0');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstack_num.push(num);\n\t\t\t\tnum = -1;\n\t\t\t\twhile (stack_op.empty() && (stack_op.top() == '*' || stack_op.top() == '/')) {\n\t\t\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t\t\t}\n\t\t\t\tif (c != '#') stack_op.push(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!stack_op.empty()) {\n\t\t\tif (!calc()) return pair< int, bool >(0, false);\n\t\t}\n\t\treturn pair< int, bool >(stack_num.top(), true);\n\t}\n\t\n\tbool valid(string S) {\n\t\tint len = S.size();\n\t\tbool num_flag = false, op_flag = false;\n\t\tfor_(i,0,len) {\n\t\t\tchar c = S[i];\n\t\t\tif (isdigit(c)) {\n\t\t\t\tif (!num_flag && c == '0' && i<len-1 && isdigit(S[i+1])) return false; // reading zero\n\t\t\t\tnum_flag = true;\n\t\t\t\top_flag = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!num_flag || op_flag) return false; // unary operation\n\t\t\t\tnum_flag = false;\n\t\t\t\top_flag = true;\n\t\t\t}\n\t\t}\n\t\treturn num_flag;\n\t}\n\t\n\tbool evaluate(string symbol_map) {\n\t\tstring X = convert(A, symbol_map);\n\t\tstring Y = convert(B, symbol_map);\n\t\tif (!valid(X) || !valid(Y)) return false;\n\t\tpair< int, bool > pX = calculate(X), pY = calculate(Y);\n\t\t//cerr << X << \" ? \" << Y << \" -> \" << pX.first << \" ? \" << pY.first << endl;\n\t\treturn  pX.second && pY.second && pX.first == pY.first;\n\t}\n};\n\nint H, W, n, buf[11][11];\nstring board[11];\nchar symbol[11];\n\nvector< Equation > findEquations() {\n\tvector< Equation > ret;\n\t\n\tfor_(d,0,2) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tif (board[y][x] != '#' && buf[y][x] == 0) {\n\t\t\t\tstring S = \"\";\n\t\t\t\tint cx = x, cy = y;\n\t\t\t\twhile (cy < H && cx < W && board[cy][cx] != '#') {\n\t\t\t\t\tS += board[cy][cx];\n\t\t\t\t\tbuf[cy][cx] = 1;\n\t\t\t\t\tif (d == 0) ++cy;\n\t\t\t\t\telse ++cx;\n\t\t\t\t}\n\t\t\t\tif (S.size() >= 3) {\n\t\t\t\t\tret.push_back(Equation(S));\n\t\t\t\t\t//cerr << S << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nbool solve() {\n\tint a = 0;\n\tfor_(y,0,H) {\n\t\tcin >> board[y];\n\t\tfor_(x,0,W) {\n\t\t\tif (board[y][x] == '.') {\n\t\t\t\tboard[y][x] = char('a' + a);\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcin >> n;\n\tfor_(i,0,n) cin >> symbol[i];\n\tsort(symbol, symbol + n);\n\t\n\tif (a != n) return false;\n\t\n\tvector< Equation > eqs = findEquations();\n\t\n\tdo {\n\t\tstring s_map = \"\";\n\t\tfor_(i,0,n) s_map += symbol[i];\n\t\t//cerr << s_map << endl;\n\t\tbool flag = true;\n\t\tfor (Equation eq : eqs) flag &= eq.evaluate(s_map);\n\t\tif (flag) return true;\n\t} while (next_permutation(symbol, symbol + n));\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n  return operand_connected(str) or equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n        if ((not legal(q)) or incorrect(getv(q))) {\n          continue;\n        }\n\n        q = hsolvables[i];\n        if ((not legal(q)) or incorrect(geth(q))) {\n          continue;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) continue;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) continue;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;                           // 空白の数\nstring p;                        // リストの文字\nvector<vector<string> > formula; // パズル中の数式\nstring change;                   // 各空白に入れる文字\nbool error;                      // 式計算のエラー有無\n\nint calculate(const string& s, int a, int b)\n{\n    if(a > b){\n        error = true;\n        return 0;\n    }\n\n    int k = b;\n    while(k >= a && s[k] != '+' && s[k] != '-')\n        -- k;\n    if(k >= a){\n        int x = calculate(s, a, k-1);\n        int y = calculate(s, k+1, b);\n        if(s[k] == '+')\n            return x + y;\n        else\n            return x - y;\n    }\n\n    if(b > a && s[a] == '0'){\n        error = true;\n        return 0;\n    }\n\n    k = b;\n    while(k >= a && s[k] != '*' && s[k] != '/')\n        -- k;\n    if(k >= a){\n        int x = calculate(s, a, k-1);\n        int y = calculate(s, k+1, b);\n        if(s[k] == '*'){\n            return x * y;\n        }else{\n            if(y == 0 || x % y != 0){\n                error = true;\n                return 0;\n            }\n            return x / y;\n        }\n    }\n\n    int ret = 0;\n    for(int i=a; i<=b; ++i){\n        ret *= 10;\n        ret += s[i] - '0';\n    }\n\n    return ret;\n}\n\nbool check(const string& s)\n{\n    int k = s.find('=');\n    if(k == string::npos || s.find('=', k+1) != string::npos)\n        return false;\n\n    error = false;\n    bool ret = calculate(s, 0, k-1) == calculate(s, k+1, s.size()-1);\n    return !error && ret;\n}\n\nbool solve(int x, bitset<10> bs)\n{\n    if(x == n)\n        return true;\n\n    for(int i=0; i<n; ++i){\n        if(bs[i])\n            continue;\n        bs[i] = true;\n\n        change[x] = p[i];\n        bool ok = true;\n        for(unsigned j=0; j<formula[x].size(); ++j){\n            string t = formula[x][j];\n            for(unsigned k=0; k<t.size(); ++k){\n                if(isalpha(t[k]))\n                    t[k] = change[t[k]-'a'];\n            }\n            if(!check(t))\n                ok = false;\n        }\n\n        if(ok && solve(x+1, bs))\n            return true;\n\n        bs[i] = false;\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> h >> w;\n        if(h == 0)\n            return 0;\n\n        vector<string> s(h+2, string(w+2, '#'));\n        int tmp = 0;\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> s[i][j];\n                if(s[i][j] == '.'){\n                    s[i][j] = 'a' + tmp;\n                    ++ tmp;\n                }\n            }\n        }\n\n        cin >> n;\n        p.assign(n, ' ');\n        for(int i=0; i<n; ++i)\n            cin >> p[i];\n\n        bool ng = false;\n        formula.assign(n, vector<string>());\n        for(int i=0; i<h+2; ++i){\n            char c = 0;\n            string t;\n            for(int j=0; j<w+2; ++j){\n                if(s[i][j] != '#'){\n                    t += s[i][j];\n                    if(isalpha(s[i][j]))\n                        c = s[i][j];\n                }else{\n                    if(t.size() >= 3){\n                        if(c == 0){\n                            if(!check(t))\n                                ng = true;\n                        }else{\n                            formula[c-'a'].push_back(t);\n                        }\n                    }\n                    c = 0;\n                    t = \"\";\n                }\n            }\n        }\n        for(int j=0; j<w+2; ++j){\n            char c = 0;\n            string t;\n            for(int i=0; i<h+2; ++i){\n                if(s[i][j] != '#'){\n                    t += s[i][j];\n                    if(isalpha(s[i][j]))\n                        c = s[i][j];\n                }else{\n                    if(t.size() > 2){\n                        if(c == 0){\n                            if(!check(t))\n                                ng = true;\n                        }else{\n                            formula[c-'a'].push_back(t);\n                        }\n                    }\n                    c = 0;\n                    t = \"\";\n                }\n            }\n        }\n        if(ng){\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        change.assign(n, ' ');\n        if(solve(0, 0))\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nP vsolvables[NMAX], hsolvables[NMAX];\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = false;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n      }\n\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nvoid init() { // {{{\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "C++",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\nconst int OutOfIntExc = 1,\n          NegIntExc = 2,\n          NotEquationExc = 3,\n          NotNumExc = 4,\n          LackNumExc = 5;\n\nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n\nresult equation(const string &s, int p) {\n//  cout << \"? \" << s << \" \";\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n  \n  r.p++; // skip '=';\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n//  cout << (t.value ? \"T\" : \"F\") << endl;\n  \n  return t;\n}\n\n\nresult expression(const string &s, int p) {\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult factor(const string &s, int p) {\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) { \n        throw OutOfIntExc; \n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\n\nresult term(const string &s, int p) {\n  int value = 0;\n  bool flag = false;\n  if (not isdigit(s[p])) { throw LackNumExc; }\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) {\n      throw NotNumExc;\n    }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nint H, W, n;\nconst int HMAX = 14, WMAX = 14, NMAX = 15;\nchar TABLE[HMAX][WMAX];\nbool PRINTED[HMAX][WMAX], HBEGIN[HMAX][WMAX], VBEGIN[HMAX][WMAX];\nchar BLOCK[NMAX];\n\nvoid init() {\n  REP(y, H) REP(x, W) {\n    PRINTED[x][y] = false;\n    HBEGIN[x][y] = false;\n    VBEGIN[x][y] = false;\n  }\n}\n\nbool legal(int x, int y) {\n  return 0 <= x and x < W and 0 <= y and y < H;\n}\n\nvoid fill_blank() {\n  int i = 0;\n  REP(y, H) REP(x, W) {\n    if (i == n) return;\n    if (not PRINTED[x][y]) {\n      TABLE[x][y] = BLOCK[i++];\n    }\n  }\n}\n\nstring getv(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    y++; \n  }\n  return str;\n}\n\nstring geth(int x, int y) {\n  string str;\n  while (legal(x, y) and TABLE[x][y] != '#') { \n    str.push_back(TABLE[x][y]);\n    x++; \n  }\n  return str;\n}\n\nbool solved() {\n  REP(y, H) REP(x, W) {\n    if (not HBEGIN[x][y]) continue;\n    string eq = geth(x, y);\n    try {\n      result e = equation(eq);\n      if (e.value == 0) { return false; }\n    } catch (int ex) {\n      return false;\n    }\n  }\n\n  REP(y, H) REP(x, W) {\n    if (not VBEGIN[x][y]) continue;\n    string eq = getv(x, y);\n    result e = equation(eq);\n    if (e.value == 0) { return false; }\n  }\n  return true;\n}\n\nbool solve() {\n  sort(BLOCK, BLOCK + n);\n  do {\n    fill_blank();\n/*    REP(y, H) {\n      REP(x, W) {\n        cout << TABLE[x][y];\n      }\n      cout << endl;\n    }*/\n    if (solved()) { return true; }\n  } while (next_permutation(BLOCK, BLOCK + n));\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    init();\n\n    REP(y, H) {\n      string row;\n      cin >> row;\n      REP(x, W) {\n        TABLE[x][y] = row[x];\n        PRINTED[x][y] = row[x] != '.';\n      }\n    }\n\n    REP(y, H) REP(x, W) {\n      if (TABLE[x][y]!='#' and legal(x+1,y) and TABLE[x+1][y]!='#'\n          and (!legal(x-1,y) or TABLE[x-1][y] == '#')) {\n        HBEGIN[x][y] = true;\n      }\n      if (TABLE[x][y]!='#' and legal(x,y+1) and TABLE[x][y+1]!='#'\n          and (!legal(x,y-1) or TABLE[x][y-1] == '#')) {\n        VBEGIN[x][y] = true;\n      }\n    }\n    cin >> n;\n    REP(i, n) { cin >> BLOCK[i]; }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1022\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <setjmp.h>\n\njmp_buf jb;\nchar ban[10][11];\nchar formula[20][11];\nint  form_cnt;\nchar list[10];\nint var_cnt;\nint n,W,H;\n\nint myatoi(char s[])\n{\n  if(s[0]=='0' && isdigit(s[1]))\n    longjmp(jb,1);\n  return(atoi(s));\n}\n\n\nint comp_char(const void *a, const void *b)\n{\n    return *(char *)a - *(char *)b;\n}\nint r_compare(const void *a, const void *b)\n{\n    return *(char *)b - *(char *)a;\n}\n\nint next_perm(char a[],int n,int r)\n{\n  int i,j,min_p;\n  char p,wk,min_;\n\n  if(a[n-2]<a[n-1])\n    {\n\twk=a[n-1];\n\ta[n-1]=a[n-2];\n\ta[n-2]=wk;\n\treturn(-1);\n    }\n\n  for(i=n-1;i>=1;i--)\n    if(a[i]>a[i-1])\n      {\n\tp=a[i-1];\n\tmin_=CHAR_MAX;\n\tfor(j=i;j<n;j++)\n\t  if(a[j] > p && min_ > a[j])\n\t    {\n\t      min_=a[j];\n\t      min_p=j;\n\t    }\n\twk=a[min_p];\n\ta[min_p]=a[i-1];\n\ta[i-1]=wk;\n\tqsort(&a[i],n-i,sizeof(char),comp_char);\n\tqsort(a+r,n-r,sizeof(char),r_compare);\n        return(-1);\n      }\n \n  return(0);\n}\n\n\nextern int eval_1(char form[],int len)\n{\n  int i,op1,op2;\n#ifdef DEBUG1\n  printf(\"%d|\",len);\n  for(i=0;i<len;i++)\n    printf(\"%c\",form[i]);\n  printf(\"\\n\");\n#endif\n  if(!isdigit(form[0]))\n    longjmp(jb,1);\n  if(!isdigit(form[len-1]))\n    longjmp(jb,1);\n\n  for(i=0;i<len;i++)\n    if(form[i]=='*'||form[i]=='/')\n      goto NEXT;\n  return(myatoi(form));\n NEXT:\n  for(i=len-1;i>=0;i--)\n    if(form[i]=='*')\n      {\n\treturn(eval_1(form,i)*myatoi(form+i+1));\n      }\n    else if(form[i]=='/')\n      {\n\top1=eval_1(form,i);\n\top2=myatoi(form+i+1);\n\tif(op2==0 || (op1 % op2)>0)\n\t  longjmp(jb,1);\n\telse\n\t  return(op1/op2);\n      }\n\n}\n\nextern int eval_m(char form[],int len)\n{\n  int i,op1,op2;\n#ifdef DEBUGM\n  printf(\"%d|\",len);\n  for(i=0;i<len;i++)\n    printf(\"%c\",form[i]);\n  printf(\"\\n\");\n#endif\n  for(i=0;i<len;i++)\n    if(form[i]=='+'||form[i]=='-')\n      goto NEXT;\n  return(eval_1(form,len));\n NEXT:\n  for(i=len-1;i>=0;i--)\n    if(form[i]=='+')\n      {\n\treturn(eval_m(form,i)+eval_1(form+i+1,len-i-1));\n      }\n    else if(form[i]=='-')\n      {\n\top1=eval_m(form,i);\n\top2=eval_1(form+i+1,len-i-1);\n\treturn(op1-op2);\n      }\n}\n\neval_eq(char form[],int len)\n{\n  int i,op1,op2;\n#ifdef DEBUGF\n  printf(\"%d|\",len);\n  for(i=0;i<len;i++)\n    printf(\"%c\",form[i]);\n  printf(\"\\n\");\n#endif\n  for(i=0;i<len;i++)\n    if(form[i]=='=')\n      goto NEXT;\n  longjmp(jb,1);;\n\n NEXT:\n  for(i=len-1;i>=0;i--)\n    if(form[i]=='=')\n      {\n\treturn (eval_m(form,i)==eval_m(form+i+1,len-i-1))?1:0;\n      }\n}\n\nvoid prepare1()\n{\n  int i,j;\n  var_cnt=0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]=='.')\n\tban[i][j]='a'+var_cnt++;\n  qsort(list,n,sizeof(char),comp_char);\n}\n\nvoid replace(char from[],char to[],char list[])\n{\n  char c;\n\n  while((c=*from))\n    {\n      if(islower(c))\n\tc=list[c-'a'];\n      *to=c;\n      from++;\n      to++;\n    }\n\n}\n\nint solve()\n{\n  int i,ret;\n  char expr[11];\n\n  do\n    {\n      /*      \n      for(i=0;i<var_cnt;i++)\n\tprintf(\"%c|\",list[i]);\n      printf(\"\\n\");\n      */\n       \n      for(i=0;i<form_cnt;i++)\n      {\n\tmemset(expr,0,sizeof(expr));\n\treplace(&formula[i][0],expr,list);\n\t\n\tif(setjmp(jb)==0)\n\t  ret=eval_eq(expr,strlen(expr));\n\telse\n\t  {\n\t    ret=-1;\n\t  }\n\t//printf(\"%s %d\\n\",expr,ret);\n\tif(ret!=1)\n\t  goto NEXT;\n       }\n      return(1); \n    NEXT: ;\n      \n    }\n  while(next_perm(list,n,var_cnt));\n  return(0);\n}\n\nvoid prepare2()\n{\n  int i,j,k;\n\n  form_cnt=0;\n  for(i=0;i<H;i++)\n    {\n      for(j=0;j<W-4;j++)\n\tif(ban[i][j]!='#' && ban[i][j+1]!='#') \n\t  {\n\t    k=0;\n\t    while(ban[i][j+k]!='#' && j+k<W)\n\t      {\n\t\tformula[form_cnt][k]=ban[i][j+k];\n\t\tk++;\n\t      }\n\t    form_cnt++;\n\t    break;\n\t  }\n    }\n  for(i=0;i<W;i++)\n    {\n      for(j=0;j<H-4;j++)\n\tif(ban[j][i]!='#' && ban[j+1][i]!='#') \n\t  {\n\t    k=0;\n\t    while(ban[j+k][i]!='#' && j+k<H)\n\t      {\n\t\tformula[form_cnt][k]=ban[j+k][i];\n\t\tk++;\n\t      }\n\t    form_cnt++;\n\t    break;\n\t  }\n    }\n}\nshow()\n{\n  int i,j;\n  var_cnt=0;\n  for(i=0;i<H;i++)\n    {\n      for(j=0;j<W;j++)\n\tprintf(\"%c|\",ban[i][j]);\n      printf(\"\\n\");\n    }\n}\n\nvoid show_formula()\n{\n  int i;\n  for(i=0;i<form_cnt;i++)\n    printf(\"%s\\n\",&formula[i][0]);\n}\n\n\nmain()\n{\n  int i,ret;\n  char buf[22];\n\n  (scanf(\"%d %d\",&H,&W)  && (H||W));\n    {\n      memset(formula,0,sizeof(formula));\n      //printf(\"HW=%d %d\\n\",H,W);\n      for(i=0;i<H;i++)\n\tscanf(\"%s\",&ban[i][0]);\n      scanf(\"%d \",&n);\n      fgets(buf,22,stdin);\n      for(i=0;i<n;i++)\n\tlist[i]=buf[i*2];\n      prepare1();\n      //show();\n      prepare2();\n      //show_formula();\n      qsort(list+var_cnt,n-var_cnt,sizeof(char),r_compare);\n      ret=solve();\n      printf(\"%s\\n\",ret?\"Yes\":\"No\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1022\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <setjmp.h>\n\njmp_buf jb;\nchar ban[10][11];\nchar formula[20][11];\nint  form_cnt;\nchar list[10];\nint var_cnt;\nint n,W,H;\n\nint myatoi(char s[])\n{\n  if(s[0]=='0' && isdigit(s[1]))\n    longjmp(jb,1);\n  return(atoi(s));\n}\n\n\nint comp_char(const void *a, const void *b)\n{\n    return *(char *)a - *(char *)b;\n}\nint r_compare(const void *a, const void *b)\n{\n    return *(char *)b - *(char *)a;\n}\n\nint next_perm(char a[],int n,int r)\n{\n  int i,j,min_p;\n  char p,wk,min_;\n\n  if(a[n-2]<a[n-1])\n    {\n\twk=a[n-1];\n\ta[n-1]=a[n-2];\n\ta[n-2]=wk;\n\treturn(-1);\n    }\n\n  for(i=n-1;i>=1;i--)\n    if(a[i]>a[i-1])\n      {\n\tp=a[i-1];\n\tmin_=CHAR_MAX;\n\tfor(j=i;j<n;j++)\n\t  if(a[j] > p && min_ > a[j])\n\t    {\n\t      min_=a[j];\n\t      min_p=j;\n\t    }\n\twk=a[min_p];\n\ta[min_p]=a[i-1];\n\ta[i-1]=wk;\n\tqsort(&a[i],n-i,sizeof(char),comp_char);\n\tqsort(a+r,n-r,sizeof(char),r_compare);\n        return(-1);\n      }\n \n  return(0);\n}\n\n\nextern int eval_1(char form[],int len)\n{\n  int i,op1,op2;\n\n  if(!isdigit(form[0]))\n    longjmp(jb,1);\n  if(!isdigit(form[len-1]))\n    longjmp(jb,1);\n\n  for(i=0;i<len;i++)\n    if(form[i]=='*'||form[i]=='/')\n      goto NEXT;\n  return(myatoi(form));\n NEXT:\n  for(i=len-1;i>=0;i--)\n    if(form[i]=='*')\n      {\n\treturn(eval_1(form,i)*myatoi(form+i+1));\n      }\n    else if(form[i]=='/')\n      {\n\top1=eval_1(form,i);\n\top2=myatoi(form+i+1);\n\tif(op2==0 || (op1 % op2)>0)\n\t  longjmp(jb,1);\n\telse\n\t  return(op1/op2);\n      }\n\n}\n\nextern int eval_m(char form[],int len)\n{\n  int i,op1,op2;\n\n  for(i=0;i<len;i++)\n    if(form[i]=='+'||form[i]=='-')\n      goto NEXT;\n  return(eval_1(form,len));\n NEXT:\n  for(i=len-1;i>=0;i--)\n    if(form[i]=='+')\n      {\n\treturn(eval_m(form,i)+eval_1(form+i+1,len-i-1));\n      }\n    else if(form[i]=='-')\n      {\n\top1=eval_m(form,i);\n\top2=eval_1(form+i+1,len-i-1);\n\treturn(op1-op2);\n      }\n}\n\neval_eq(char form[],int len)\n{\n  int i,eqc,op1,op2;\n\n  for(i=eqc=0;i<len;i++)\n    if(form[i]=='=')\n      eqc++;\n      \n  if(eqc!=1)\n    longjmp(jb,1);;\n\n NEXT:\n  for(i=len-1;i>=0;i--)\n    if(form[i]=='=')\n      {\n\treturn (eval_m(form,i)==eval_m(form+i+1,len-i-1))?1:0;\n      }\n}\n\nvoid prepare1()\n{\n  int i,j;\n  var_cnt=0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]=='.')\n\tban[i][j]='a'+var_cnt++;\n  qsort(list,n,sizeof(char),comp_char);\n}\n\nvoid replace(char from[],char to[],char list[])\n{\n  char c;\n\n  while((c=*from))\n    {\n      if(islower(c))\n\tc=list[c-'a'];\n      *to=c;\n      from++;\n      to++;\n    }\n\n}\n\nint solve()\n{\n  int i,ret;\n  char expr[40][11];\n\n  do\n    {\n      /*\n      for(i=0;i<var_cnt;i++)\n\tprintf(\"%c|\",list[i]);\n      printf(\"\\n\");\n      */\n      for(i=0;i<form_cnt;i++)\n      {\n\tmemset(&expr[i][0],0,11);\n\treplace(&formula[i][0],&expr[i][0],list);\n\t\n\tif(setjmp(jb)==0)\n\t  ret=eval_eq(&expr[i][0],strlen(&expr[i][0]));\n\telse\n\t  {\n\t    ret=-1;\n\t  }\n\t//printf(\"%s %d\\n\",&expr[i][0],ret);\n\tif(ret!=1)\n\t  goto NEXT;\n       }\n#ifdef DEBUG\n      for(i=0;i<form_cnt;i++)\n\tprintf(\"%s\\n\",&expr[i][0]);\n#endif\n      return(1); \n    NEXT: ;\n      \n    }\n  while(next_perm(list,n,var_cnt));\n  return(0);\n}\n\nvoid prepare2()\n{\n  int i,j,k;\n\n  form_cnt=0;\n  for(i=0;i<H;i++)\n    {\n      for(j=0;j<W-2;j++)\n\tif(ban[i][j]!='#' && ban[i][j+1]!='#') \n\t  {\n\t    k=0;\n\t    while(ban[i][j+k]!='#' && j+k<W)\n\t      {\n\t\tformula[form_cnt][k]=ban[i][j+k];\n\t\tk++;\n\t      }\n\t    form_cnt++;\n\t    break;\n\t  }\n      for(j=j+k;j<W-2;j++)\n\t{\n\t  if(ban[i][j]!='#' && ban[i][j+1]!='#') \n\t    {\n\t      k=0;\n\t      while(ban[i][j+k]!='#' && j+k<W)\n\t      {\n\t\tformula[form_cnt][k]=ban[i][j+k];\n\t\tk++;\n\t      }\n\t      form_cnt++;\n\t      break;\n\t    }\n\t}\n    }\n  for(i=0;i<W;i++)\n    {\n      for(j=0;j<H-2;j++)\n\tif(ban[j][i]!='#' && ban[j+1][i]!='#') \n\t  {\n\t    k=0;\n\t    while(ban[j+k][i]!='#' && j+k<H)\n\t      {\n\t\tformula[form_cnt][k]=ban[j+k][i];\n\t\tk++;\n\t      }\n\t    form_cnt++;\n\t    break;\n\t  }\n      for(j=j+k;j<H-2;j++)\n\tif(ban[j][i]!='#' && ban[j+1][i]!='#') \n\t  {\n\t    k=0;\n\t    while(ban[j+k][i]!='#' && j+k<H)\n\t      {\n\t\tformula[form_cnt][k]=ban[j+k][i];\n\t\tk++;\n\t      }\n\t    form_cnt++;\n\t    break;\n\t  }\n    }\n}\nshow()\n{\n  int i,j;\n  var_cnt=0;\n  for(i=0;i<H;i++)\n    {\n      for(j=0;j<W;j++)\n\tprintf(\"%c|\",ban[i][j]);\n      printf(\"\\n\");\n    }\n}\n\nvoid show_formula()\n{\n  int i;\n  for(i=0;i<form_cnt;i++)\n    printf(\"%s\\n\",&formula[i][0]);\n}\n\n\nmain()\n{\n  int i,ret;\n  char buf[22];\n\n  (scanf(\"%d %d\",&H,&W)  && (H||W));\n    {\n      memset(formula,0,sizeof(formula));\n      //printf(\"HW=%d %d\\n\",H,W);\n      for(i=0;i<H;i++)\n\tscanf(\"%s\",&ban[i][0]);\n      scanf(\"%d \",&n);\n      fgets(buf,22,stdin);\n      for(i=0;i<n;i++)\n\tlist[i]=buf[i*2];\n      prepare1();\n      //show();\n      prepare2();\n      //show_formula();\n      qsort(list+var_cnt,n-var_cnt,sizeof(char),r_compare);\n      ret=solve();\n      printf(\"%s\\n\",ret?\"Yes\":\"No\");\n    }\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class Main{\n        public static void main(String[] arg) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String[] ia;\n\n                while(true){\n                        ia = in.readLine().split(\" \");\n                        H = Integer.parseInt(ia[0]);\n                        W = Integer.parseInt(ia[1]);\n                        if(H == 0 && W == 0){\n                                break;\n                        }\n                        prob1 = new char[H][W];\n                        prob2 = new char[W][H];\n                        for(int i = 0;i < H; ++i){\n                                prob1[i] = in.readLine().toCharArray();\n                        }\n                        n = Integer.parseInt(in.readLine());\n                        cont = new char[n];\n                        ia = in.readLine().split(\" \");\n                        on = 0;\n                        for(int i = 0;i < n; ++i){\n                                cont[i] = ia[i].charAt(0);\n                                if(cont[i] == '-' || cont[i] == '+' || cont[i] == '*' || cont[i] == '/'){\n                                        ++on;\n                                }\n                        }\n                        Arrays.sort(cont);\n                        con = new int[n][2];\n                        co = new boolean[n];\n                        os = new boolean[n];\n\n                        boolean cs = true;\n\n                        int c = 0;\n                        for(int i = 0;i < H; ++i){\n                                for(int j = 0;j < W; ++j){\n                                        if((prob2[j][i] = prob1[i][j]) == '.'){\n                                                con[c][0] = i;\n                                                con[c][1] = j;\n                                                ++c;\n                                        }\n                                }\n                        }\n\n                        if(c != n){\n                                cs = false;\n                        }\n                        osc = 0;\n                        for(int i = 0;i < n; ++i){\n                                os[i] = sfos(con[i][0],con[i][1]);\n                        }\n                        if(cs && solv(0)){\n                                System.out.println(\"Yes\");\n                        } else {\n                                System.out.println(\"No\");\n                        }\n                }\n        }\n        static int H;\n        static int W;\n        static char[][] prob1;\n        static char[][] prob2;\n        static int n;\n        static char[] cont;\n        static int[][] con;\n        static boolean[] co;\n        static boolean[] os;\n        static int osc;\n        static int ss;\n        static int on;\n        static boolean sfos(int a, int b){\n                if(0 < a && a < H){\n                        if(!(prob1[a-1][b] == '.' || prob1[a-1][b] == '#' ||\n                            (0 <= (prob1[a-1][b] - '0') && (prob1[a-1][b] - '0') < 10))){\n                                return false;\n                        }\n                }\n                if(0 <= a && a < H-1){\n                        if(!(prob1[a+1][b] == '.' || prob1[a+1][b] == '#' ||\n                            (0 <= (prob1[a+1][b] - '0') && (prob1[a+1][b] - '0') < 10))){\n                                return false;\n                        }\n                }\n                if(0 < b && b < W){\n                        if(!(prob1[a][b-1] == '.' || prob1[a][b-1] == '#' ||\n                            (0 <= (prob1[a][b-1] - '0') && (prob1[a][b-1] - '0') < 10))){\n                                return false;\n                        }\n                }\n                if(0 <= b && b < W-1){\n                        if(!(prob1[a][b+1] == '.' || prob1[a][b+1] == '#' ||\n                            (0 <= (prob1[a][b+1] - '0') && (prob1[a][b+1] - '0') < 10))){\n                                return false;\n                        }\n                }\n                ++osc;\n                return true;\n        }\n        static boolean solv(int c){\n                if(c == on){\n                        return solve(c);\n                }\n                for(int i = 0;i < n; ++i){\n                        if(os[i] && !co[i]){\n                                co[i] = true;\n                                prob1[con[i][0]][con[i][1]] = cont[c];\n                                prob2[con[i][1]][con[i][0]] = cont[c];\n                                if(solv(c+1)){\n                                        return true;\n                                }\n                                co[i] = false;\n                        }\n                }\n                return false;\n        }\n        static boolean solve(int c){\n                char b = 'n';\n                if(c == n){\n                        return ca();\n                }\n                for(int i = 0;i < n; ++i){\n                        if(!co[i] && cont[i] != b){\n                                b = cont[i];\n                                co[i] = true;\n                                prob1[con[i][0]][con[i][1]] = cont[c];\n                                prob2[con[i][1]][con[i][0]] = cont[c];\n                                if(solve(c+1)){\n                                        return true;\n                                }\n                                co[i] = false;\n                        }\n                }\n                return false;\n        }\n        static boolean ca(){\n                for(int i = 0;i < H; ++i){\n                        if(!cal(prob1[i])){\n                                return false;\n                        }\n                }\n                for(int i = 0;i < W; ++i){\n                        if(!cal(prob2[i])){\n                                return false;\n                        }\n                }\n                return true;\n        }\n        static boolean cal(char[] s){\n                int b=0,i,j;\n                boolean flag = true;\n                while(b < s.length){\n                        for(i = b;i < s.length; ++i){\n                                if(s[i] == '='){\n                                        break;\n                                }\n                        }\n                        for(j = b;j < s.length; ++j){\n                                if(s[j] == '#'){\n                                        break;\n                                }\n                        }\n                        if(j-b > 2){\n                                if(i != s.length){\n                                        flag = flag && (calc(s,b,i) == calc(s,i+1,j));\n                                } else {\n                                        return false;\n                                }\n                        }\n                        b = j+1;\n                }\n                return flag;\n        }\n        static int calc(char[] s, Integer t, Integer e){\n                int x = 0;\n                int t1 = 0;\n                if(e-t==0){\n                        return -100000;\n                }\n                for(int i = t;t < e; ++t){\n                        if(0 < s[t]-'0' && s[t]-'0'<10){\n                                t1 = t1*10+s[t]-'0';\n                        } else if(s[t] == '+'){\n                                return calc(s,i,new Integer(t)) + calc(s,++t,e);\n                        } else if(s[t] == '-'){\n                                return calc(s,i,new Integer(t)) - calc(s,++t,e);\n                        } else if(s[t] == '*'){\n                                t1 *= calc(s,++t,e);\n                        } else if(s[t] == '/'){\n                                try{\n                                        t1 /= calc(s,++t,e);\n                                } catch(ArithmeticException f){\n                                        return -100000;\n                                }\n                                break;\n                        }\n                }\n                return t1;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Indian Puzzle\npublic class Main{\n\n\tclass E implements Comparable<E>{\n\t\tString s;\n\t\tint count;\n\t\tpublic E(String s) {\n\t\t\tthis.s = s;\n\t\t\tcount = 0;\n\t\t\tfor(char c:s.toCharArray())if(Character.isUpperCase(c))count++;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn count-o.count;\n\t\t}\n\t}\n\t\n\tint n;\n\tchar[] cand;\n\tint[] ref;\n\tboolean[] u;\n\tList<E> exs;\n\t\n\tchar[] s;\n\tint id;\n\t\n\tboolean sub(char[] t, int k, int ind){\n\t\tif(ind==t.length){\n\t\t\tString[] r = (new String(t)).split(\"=\");\n//\t\t\tSystem.out.println(\"R[0]:\" + r[0] + \" R[1]:\" + r[1]);\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\tif(ref[i]!=-1)System.out.println((char)(i+'A')+\" -> \" + cand[ref[i]]);\n//\t\t\t}\n\t\t\tid = 0;\n\t\t\ts = (r[0]+\"$\").toCharArray();\n\t\t\tdouble ex1 = exp();\n\t\t\tif(ex1==1<<28)return false;\n\t\t\tid = 0;\n\t\t\ts = (r[1]+\"$\").toCharArray();\n\t\t\tdouble ex2 = exp();\n\t\t\tif(ex2==1<<28)return false;\n\t\t\tif(Math.abs(ex1-ex2)<1e-6)return assign(k+1);\n\t\t\treturn false;\n\t\t}\n\t\tif(!Character.isUpperCase(t[ind]))return sub(t,k,ind+1);\n\t\tint x = t[ind]-'A';\n\t\tif(ref[x]!=-1)return sub(t,k,ind+1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(u[i])continue;\n\t\t\tu[i] = true;\n\t\t\tref[x] = i;\n\t\t\tif(sub(t,k,ind+1))return true;\n\t\t\tu[i] = false;\n\t\t\tref[x] = -1;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean assign(int k){\n\t\tif(k==exs.size())return true;\n\t\treturn sub(exs.get(k).s.toCharArray(), k, 0);\n\t}\n\t\n\tchar get(){\n\t\tif(Character.isUpperCase(s[id]))return cand[ref[s[id++]-'A']];\n\t\telse return s[id++];\n\t}\n\t\n\tdouble exp(){\n\t\tdouble res = fact();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='+'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres+=a;\n\t\t\t}\n\t\t\telse if(c=='-'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres-=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tdouble fact(){\n\t\tdouble res = digit();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='*'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres*=a;\n\t\t\t}\n\t\t\telse if(c=='/'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28||a==0)return a;\n\t\t\t\tres/=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn res;\n\t}\n\t\n\tdouble digit(){\n\t\tdouble res = 0;\n\t\tchar c = get();\n\t\tif(!Character.isDigit(c))return 1<<28;\n\t\tchar next = get();\n\t\tif(c=='0'&&'1'<=next&&next<='9')return 1<<28;\n\t\tid--;\n\t\twhile(Character.isDigit(c)){\n\t\t\tres = res*10 + (c-'0');\n\t\t\tc = get();\n\t\t}\n\t\tid--;\n\t\treturn res;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint k = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(m[i][j]=='.')m[i][j]=(char)(k+++'A');\n\t\t\texs = new ArrayList<E>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i][j+1]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(j<w&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i][j++]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(new E(sb.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int i=0;i<h-1;i++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i+1][j]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(i<h&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i++][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(new E(sb.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(exs);\n\t\t\tn = sc.nextInt();\n\t\t\tcand = new char[n];\n\t\t\tfor(int i=0;i<n;i++)cand[i]=sc.next().charAt(0);\n\t\t\tref = new int[n];\n\t\t\tArrays.fill(ref, -1);\n\t\t\tu = new boolean[n];\n\t\t\tSystem.out.println(assign(0)?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/*\n * Main.java: 1022: Indian Puzzle\n */\n\nimport java.util.*;\n\npublic class Main {\n  // constant\n\n  static int Error = Integer.MIN_VALUE;\n\n  // inner classes\n\n  static class Box {\n    int id;\n    char val;\n\n    Box(int id, char val) { this.id = id; this.val = val; }\n    char get() { return val; }\n    void set(char v) { val = v; }\n  }\n\n  // global variables\n\n  static int n;\n  static int pos = 0;\n\n  static HashMap<ArrayList<Box>, Integer> expcache;\n  static HashMap<ArrayList<Box>, Boolean> eqncache;\n  static ArrayList<ArrayList<ArrayList<Box>>> eqnbls;\n\n  static Box[] mtx, blanks;\n  static char[] cands;\n\n  static boolean[] used;\n\n  // subroutines\n\n  static int parse_num(ArrayList<Box> exp) {\n    if (pos >= exp.size()) return Error;\n    if (exp.get(pos).get() == '0') {\n      pos++;\n      return 0;\n    }\n\n    int val = 0;\n    boolean exist = false;\n\n    while (pos < exp.size()) {\n      char ch = exp.get(pos).get();\n      if (ch < '0' ||  ch > '9') break;\n      val = 10 * val + (ch - '0');\n      pos++;\n      exist = true;\n    }\n\n    return (exist ? val : Error);\n  }\n\n  static int parse_md(ArrayList<Box> exp) {\n    int val = parse_num(exp);\n    if (val == Error) return Error;\n\n    while (pos < exp.size()) {\n      char ch = exp.get(pos).get();\n      if (ch != '*' && ch != '/') break;\n      pos++;\n\n      int val0 = parse_num(exp);\n      if (val0 == Error) return Error;\n\n      if (ch == '*')\n        val *= val0;\n      else {\n        if (val0 == 0 || val % val0 != 0) return Error;\n        val /= val0;\n      }\n    }\n\n    return val;\n  }\n\n  static int parse_exp(ArrayList<Box> exp) {\n    int val = parse_md(exp);\n    if (val == Error) return Error;\n\n    while (pos < exp.size()) {\n      char ch = exp.get(pos).get();\n      if (ch != '+' && ch != '-') break;\n      pos++;\n\n      int val0 = parse_md(exp);\n      if (val0 == Error) return Error;\n\n      if (ch == '+')\n        val += val0;\n      else\n        val -= val0;\n    }\n\n    return val;\n  }\n\n  static int eval_exp(ArrayList<Box> exp) {\n    //if (expcache.containsKey(exp)) return expcache.get(exp);\n\n    int val = parse_exp(exp);\n    if (pos < exp.size() && exp.get(pos).get() != '=') val = Error;\n\n    //expcache.put(exp, val);\n    return val;\n  }\n\n  static boolean is_valid_eqn(ArrayList<Box> eqn) {\n    //if (eqncache.containsKey(eqn)) return eqncache.get(eqn);\n\n    int eqnum = 0;\n    for (Box box: eqn)\n      if (box.get() == '=') eqnum++;\n    if (eqnum != 1) {\n      //eqncache.put(eqn, false);\n      return false;\n    }\n\n    boolean ok = false;\n    pos = 0;\n\n    int val0 = eval_exp(eqn);\n    if (val0 != Error) {\n      pos++;\n      int val1 = eval_exp(eqn);\n      if (val1 != Error && val0 == val1) ok = true;\n    }\n\n    //eqncache.put(eqn, ok);\n    return ok;\n  }\n\n  static boolean check_rec(int k) {\n    if (k >= n) return true;\n\n    for (int d = 0; d < n; d++) {\n      if (used[d]) continue;\n\n      used[d] = true;\n      blanks[k].set(cands[d]);\n      boolean ok = true;\n\n      for (ArrayList<Box> eqn: eqnbls.get(k)) {\n        ok = is_valid_eqn(eqn);\n        if (! ok) break;\n      }\n\n      if (ok)\n        ok = check_rec(k + 1);\n\n      used[d] = false;\n\n      if (ok) return true;\n    }\n\n    return false;\n  }\n\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int h = sc.nextInt();\n      int w = sc.nextInt();\n      if (h == 0 && w == 0) break;\n\n      mtx = new Box[h * w];\n\n      for (int y = 0; y < h; y++) {\n        String line = sc.next();\n        for (int x = 0; x < w; x++) {\n          int id = y * w + x;\n          mtx[id] = new Box(id, line.charAt(x));\n        }\n      }\n\n      ArrayList<ArrayList<Box>> eqns = new ArrayList<ArrayList<Box>>();\n\n      for (int y = 0; y < h; y++) {\n        int x = 0;\n        while (x < w) {\n          int x0 = x;\n          ArrayList<Box> eqn = new ArrayList<Box>();\n\n          while (x0 < w) {\n            Box b = mtx[y * w + x0];\n            if (b.get() == '#') break;\n            eqn.add(b);\n            x0++;\n          }\n\n          if (eqn.size() > 1) eqns.add(eqn);\n          x = x0 + 1;\n        }\n      }\n\n      for (int x = 0; x < w; x++) {\n        int y = 0;\n        while (y < h) {\n          int y0 = y;\n          ArrayList<Box> eqn = new ArrayList<Box>();\n\n          while (y0 < h) {\n            Box b = mtx[y0 * w + x];\n            if (b.get() == '#') break;\n            eqn.add(b);\n            y0++;\n          }\n\n          if (eqn.size() > 1) eqns.add(eqn);\n          y = y0 + 1;\n        }\n      }\n\n      n = sc.nextInt();\n\n      blanks = new Box[n];\n      int kb = 0;\n      for (Box box: mtx)\n        if (box.get() == '.') blanks[kb++] = box;\n\n      cands = new char[n];\n      for (int i = 0; i < n; i++) {\n        String str = sc.next();\n        cands[i] = str.charAt(0);\n      }\n\n      eqnbls = new ArrayList<ArrayList<ArrayList<Box>>>();\n      for (int i = 0; i < n; i++)\n        eqnbls.add(new ArrayList<ArrayList<Box>>());\n\n      for (int i = 0; i < eqns.size(); i++) {\n        ArrayList<Box> eqn = eqns.get(i);\n\n        Box blb = null;\n        for (int j = eqn.size() - 1; j >= 0; j--) {\n          blb = eqn.get(j);\n          if (blb.get() == '.') break;\n        }\n\n        if (blb != null)\n          for (int k = 0; k < n; k++)\n            if (blb == blanks[k]) {\n              eqnbls.get(k).add(eqn);\n              break;\n            }\n      }\n\n      used = new boolean[n];\n      Arrays.fill(used, false);\n\n      //expcache = new HashMap<ArrayList<Box>, Integer>();\n      //eqncache = new HashMap<ArrayList<Box>, Boolean>();\n\n      boolean ok = check_rec(0);\n\n      System.out.println(ok ? \"Yes\" : \"No\");\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Indian Puzzle\npublic class Main{\n\n\t//®ð\\·NX\n\tclass E implements Comparable<E>{\n\t\t//³Ì¶ ex: A+B=5-CÈÇ\n\t\tString s;\n\t\t//ÜÜêéóÌÂ = ß±ñ¾At@xbgÌÂ\n\t\tint count;\n\t\t//str[0]: ¶Ó  str[1]:@EÓ\n\t\tchar[][] str;\n\t\tpublic E(String s) {\n\t\t\tthis.s = s;\n\t\t\tcount = 0;\n\t\t\tfor(char c:s.toCharArray())if(Character.isUpperCase(c))count++;\n\t\t\tstr = new char[2][];\n\t\t\tString[] t = s.split(\"=\");\n\t\t\tstr[0] = (t[0]+\"$\").toCharArray();\n\t\t\tstr[1] = (t[1]+\"$\").toCharArray();\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn o.count-count;\n\t\t}\n\t}\n\t\n\tint n;\n\tchar[] cand;\n\tint[] ref;\n\tboolean[] u;\n\tList<E> exs;\n\t\n\tchar[] s;\n\tint id;\n\t\n\tboolean sub(char[] t, int k, int ind){\n\t\tif(ind==t.length){\n\t\t\tid = 0;\n\t\t\ts = exs.get(k).str[0];\n\t\t\tdouble ex1 = exp();\n\t\t\tif(ex1==1<<28)return false;\n\t\t\tid = 0;\n\t\t\ts = exs.get(k).str[1];\n\t\t\tdouble ex2 = exp();\n\t\t\tif(ex2==1<<28)return false;\n\t\t\tif(Math.abs(ex1-ex2)<1e-6)return assign(k+1);\n\t\t\treturn false;\n\t\t}\n\t\tif(!Character.isUpperCase(t[ind]))return sub(t,k,ind+1);\n\t\tint x = t[ind]-'A';\n\t\tif(ref[x]!=-1)return sub(t,k,ind+1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(u[i])continue;\n\t\t\tu[i] = true;\n\t\t\tref[x] = i;\n\t\t\tif(sub(t,k,ind+1))return true;\n\t\t\tu[i] = false;\n\t\t\tref[x] = -1;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean assign(int k){\n\t\tif(k==exs.size())return true;\n\t\treturn sub(exs.get(k).s.toCharArray(), k, 0);\n\t}\n\t\n\tchar get(){\n\t\tif(Character.isUpperCase(s[id]))return cand[ref[s[id++]-'A']];\n\t\telse return s[id++];\n\t}\n\t\n\tdouble exp(){\n\t\tdouble res = fact();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='+'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres+=a;\n\t\t\t}\n\t\t\telse if(c=='-'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres-=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tdouble fact(){\n\t\tdouble res = digit();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='*'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres*=a;\n\t\t\t}\n\t\t\telse if(c=='/'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28||a==0)return a;\n\t\t\t\tres/=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn res;\n\t}\n\t\n\tdouble digit(){\n\t\tdouble res = 0;\n\t\tchar c = get();\n\t\tif(!Character.isDigit(c))return 1<<28;\n\t\tchar next = get();\n\t\tif(c=='0'&&'1'<=next&&next<='9')return 1<<28;\n\t\tid--;\n\t\twhile(Character.isDigit(c)){\n\t\t\tres = res*10 + (c-'0');\n\t\t\tc = get();\n\t\t}\n\t\tid--;\n\t\treturn res;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint k = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(m[i][j]=='.')m[i][j]=(char)(k+++'A');\n\t\t\texs = new ArrayList<E>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i][j+1]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(j<w&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i][j++]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(new E(sb.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int i=0;i<h-1;i++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i+1][j]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(i<h&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i++][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(new E(sb.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(exs);\n\t\t\tn = sc.nextInt();\n\t\t\tcand = new char[n];\n\t\t\tfor(int i=0;i<n;i++)cand[i]=sc.next().charAt(0);\n\t\t\tref = new int[n];\n\t\t\tArrays.fill(ref, -1);\n\t\t\tu = new boolean[n];\n\t\t\tSystem.out.println(assign(0)?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// AOJ 1022\n#include<iostream>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#define value first\n#define p second\nusing namespace std;\ntypedef pair<int,int> result;\n\n// {{{\nconst int OutOfIntExc = 1, NegIntExc = 2, NotEquationExc = 3,\n      NotNumExc = 4, LackNumExc = 5, IterExceedExc = 6,\n      IncorrectExc = 7;// }}}\n\n//{{{ \nresult equation(const string &s, int p = 0);\nresult expression(const string &s, int p = 0);\nresult factor(const string &s, int p = 0);\nresult term(const string &s, int p = 0);\n// }}} \n\nresult equation(const string &s, int p) { // {{{\n  if (s[p] == '=') { throw NotEquationExc; }\n  result r = expression(s, p);\n  if (s[r.p] != '=') { throw NotEquationExc; }\n\n  r.p++;\n  result t = expression(s, r.p);\n  t.value = (int)(r.value == t.value);\n\n  return t;\n} // }}} \n\nresult expression(const string &s, int p) { // {{{\n  result r = factor(s, p);\n  while (s[r.p] == '+' or s[r.p] == '-') {\n    result r_ = factor(s, r.p+1);\n    r.value += (s[r.p] == '+' ? r_.value : - r_.value);\n    if (r.value < 0) { throw NegIntExc; }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult factor(const string &s, int p) { // {{{\n  result r = term(s, p);\n  while (s[r.p] == '*' or s[r.p] == '/') {\n    result r_ = term(s, r.p+1);\n    if (s[r.p] == '*') {\n      r.value *= r_.value;\n    } else {\n      if (r_.value == 0 or r.value % r_.value != 0) {\n        throw OutOfIntExc;\n      }\n      r.value /= r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n} // }}}\n\nresult term(const string &s, int p) { // {{{\n  if (not isdigit(s[p])) { throw LackNumExc; }\n  int value = 0;\n  bool flag = false;\n\n  while (isdigit(s[p])) {\n    if (flag and value == 0) { throw NotNumExc; }\n    flag = true;\n    value = value * 10 + (s[p++] - '0');\n  }\n  return result(value, p);\n} // }}}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define X first\n#define Y second\nint H, W, n;\nconst int HMAX = 200, WMAX = 200, NMAX = 200;\nchar table[HMAX][WMAX], block[NMAX];\n\ntypedef pair<int,int> P;\nbool printed[HMAX][WMAX];\nP blanks[NMAX];\nbool  operand_not_allowed[NMAX];\nvector<P> vbegins, hbegins;\nP vsolvables[NMAX], hsolvables[NMAX];\n\nvoid init() { // {{{\n  vbegins.clear();\n  hbegins.clear();\n\n  REP(y, H) REP(x, W) {\n    printed[x][y] = false;\n  }\n\n  REP(i, n) {\n    operand_not_allowed[i] = false;\n  }\n} // }}}\n\nstring tostr(P x) {\n  return \"(\" + to_string(x.first) + \",\" + to_string(x.second) + \")\";\n}\n\nbool is_operand(char c) {\n    return c == '=' or c == '+' or c == '-' or c == '*' or c == '/';\n}\n\nbool operand_connected(string str) {\n  bool flag = true;\n  for (int i = 0, len = str.size(); i < len; i++) {\n    if (is_operand(str[i])) {\n      if (flag) return true;\n      flag = true;\n    } else {\n      flag = false;\n    }\n  }\n  return false;\n}\n\nbool incorrect(string str) {\n//  cout << \"<\" << str << \">\" << endl;\n  return !operand_connected(str) and equation(str).value != 1; \n}\n\nbool legal(int x, int y) { // {{{\n  return 0 <= x and x < W and 0 <= y and y < H;\n} // }}}\n\nbool legal(P p) { return legal(p.X, p.Y); }\n\nbool is_white_block(int x, int y) {\n  return legal(x, y) and table[x][y] != '#';\n}\n\nbool is_white_block(P p) {\n  return is_white_block(p.X, p.Y);\n}\n\nstring getv(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    y++;\n  }\n  return str;\n} // }}}\n\nstring getv(P p) { return getv(p.X, p.Y) ; }\n\nstring geth(int x, int y) { // {{{\n  string str;\n  while (legal(x, y) and table[x][y] != '#') {\n    str.push_back(table[x][y]);\n    x++;\n  }\n  return str;\n} // }}}\n\nstring geth(P p) { return geth(p.X, p.Y) ; }\n\nbool taboo_operand() {\n  REP(i, n) {\n    if (operand_not_allowed[i] and is_operand(block[i]))\n      return true;\n  }\n  return false;\n}\n\nbool solve() { // {{{\n  sort(block, block + n);\n  do {\n    if (taboo_operand()) continue;\n    try {\n      REP(i, n) {\n        P p = blanks[i];\n        table[p.X][p.Y] = block[i];\n\n        P q = vsolvables[i];\n//        cout << '#' << i << tostr(q) << getv(q) << endl;\n        if (legal(q) and incorrect(getv(q))) {\n//          cout << \"!\" << getv(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n\n        q = hsolvables[i];\n//        cout << '#' << i << tostr(q) << geth(q) << endl;\n        if (legal(q) and incorrect(geth(q))) {\n//          cout << \"?\" << geth(q.first, q.second) << endl;\n          throw IncorrectExc;\n        }\n      }\n      for (P begin : vbegins) {\n        if (incorrect(getv(begin))) throw IncorrectExc;\n      }\n      for (P begin : hbegins) {\n        if (incorrect(geth(begin))) throw IncorrectExc;\n      }\n      return true;\n    } catch (int exc) {\n      continue;\n    }\n  } while (next_permutation(block, block + n));\n  return false;\n} // }}}\n\nP v_solvable(P p) { // {{{\n  string v = getv(p.X, p.Y + 1);\n//  cout << v << endl;\n  if (v.find(\".\", 0) == string::npos and\n      is_white_block(p.X, p.Y - 1)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) y--;\n    return P(x, ++y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nP h_solvable(P p) { // {{{\n  string h = geth(p.X + 1, p.Y);\n  if (h.find(\".\", 0) == string::npos and\n      is_white_block(p.X - 1, p.Y)) {\n    int x = p.X, y = p.Y;\n    while (is_white_block(x,y)) x--;\n    return P(++x, y);\n  } else {\n    return P(-1, -1);\n  }\n} // }}}\n\nbool nearby_operand(P p) {\n  const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n  REP(i, 4) {\n    int nx = p.X + dx[i], ny = p.Y + dy[i];\n    if (is_operand(table[nx][ny])) return true;\n  }\n  return false;\n}\n\nbool is_vbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X, p.Y + 1)\n    and !is_white_block(p.X, p.Y - 1);\n}\n\nbool is_hbeginner(P p) {\n  return is_white_block(p) and is_white_block(p.X + 1, p.Y)\n    and !is_white_block(p.X-1, p.Y);\n}\n\nint main() {\n  while (cin >> H >> W and H + W) {\n    REP(y, H) { // {{{\n      string row;\n      cin >> row;\n      REP(x, W) {\n        table[x][y] = row[x];\n        printed[x][y] = row[x] != '.';\n      }\n    } // }}}\n\n    for (int i = 0, x = 0; x < W; x++) for (int y = 0; y < H; y++) {\n      if (table[x][y] == '.') {\n        blanks[i] = P(x, y);\n        i++;\n      }\n    }\n\n    cin >> n;\n    REP(i, n) { cin >> block[i]; }\n    \n    init();\n\n    for (int i = 0; i < n; i++) {\n      vsolvables[i] = v_solvable(blanks[i]);\n      hsolvables[i] = h_solvable(blanks[i]);\n//      cout << tostr(vsolvables[i]) << getv(vsolvables[i]) << endl;\n//       cout << tostr(hsolvables[i]) << geth(hsolvables[i]) << endl;\n      operand_not_allowed[i] = nearby_operand(blanks[i]);\n    }\n\n    REP(y,H) REP(x,W) {\n      if (is_vbeginner(P(x,y))) { vbegins.push_back(P(x,y)); }\n      if (is_hbeginner(P(x,y))) { hbegins.push_back(P(x,y)); }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n// vim: set foldmethod=marker :"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Indian Puzzle\npublic class Main{\n\n\tclass E implements Comparable<E>{\n\t\tString s;\n\t\tint count;\n\t\tpublic E(String s) {\n\t\t\tthis.s = s;\n\t\t\tcount = 0;\n\t\t\tfor(char c:s.toCharArray())if(Character.isUpperCase(c))count++;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn o.count-count;\n\t\t}\n\t}\n\t\n\tint n;\n\tchar[] cand;\n\tint[] ref;\n\tboolean[] u;\n\tList<E> exs;\n\t\n\tchar[] s;\n\tint id;\n\t\n\tboolean sub(char[] t, int k, int ind){\n\t\tif(ind==t.length){\n\t\t\tString[] r = (new String(t)).split(\"=\");\n//\t\t\tSystem.out.println(\"R[0]:\" + r[0] + \" R[1]:\" + r[1]);\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\tif(ref[i]!=-1)System.out.println((char)(i+'A')+\" -> \" + cand[ref[i]]);\n//\t\t\t}\n\t\t\tid = 0;\n\t\t\ts = (r[0]+\"$\").toCharArray();\n\t\t\tdouble ex1 = exp();\n\t\t\tif(ex1==1<<28)return false;\n\t\t\tid = 0;\n\t\t\ts = (r[1]+\"$\").toCharArray();\n\t\t\tdouble ex2 = exp();\n\t\t\tif(ex2==1<<28)return false;\n\t\t\tif(Math.abs(ex1-ex2)<1e-6)return assign(k+1);\n\t\t\treturn false;\n\t\t}\n\t\tif(!Character.isUpperCase(t[ind]))return sub(t,k,ind+1);\n\t\tint x = t[ind]-'A';\n\t\tif(ref[x]!=-1)return sub(t,k,ind+1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(u[i])continue;\n\t\t\tu[i] = true;\n\t\t\tref[x] = i;\n\t\t\tif(sub(t,k,ind+1))return true;\n\t\t\tu[i] = false;\n\t\t\tref[x] = -1;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean assign(int k){\n\t\tif(k==exs.size())return true;\n\t\treturn sub(exs.get(k).s.toCharArray(), k, 0);\n\t}\n\t\n\tchar get(){\n\t\tif(Character.isUpperCase(s[id]))return cand[ref[s[id++]-'A']];\n\t\telse return s[id++];\n\t}\n\t\n\tdouble exp(){\n\t\tdouble res = fact();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='+'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres+=a;\n\t\t\t}\n\t\t\telse if(c=='-'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres-=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tdouble fact(){\n\t\tdouble res = digit();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='*'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres*=a;\n\t\t\t}\n\t\t\telse if(c=='/'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28||a==0)return a;\n\t\t\t\tres/=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn res;\n\t}\n\t\n\tdouble digit(){\n\t\tdouble res = 0;\n\t\tchar c = get();\n\t\tif(!Character.isDigit(c))return 1<<28;\n\t\tchar next = get();\n\t\tif(c=='0'&&'1'<=next&&next<='9')return 1<<28;\n\t\tid--;\n\t\twhile(Character.isDigit(c)){\n\t\t\tres = res*10 + (c-'0');\n\t\t\tc = get();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"DIGIT RES:\" + res);\n\t\treturn res;\n\t}\n\t\n//\tboolean assign(){\n//\t\tboolean f = true;\n//\t\tfor(E e:exs){\n//\t\t\tString t = e.s;\n//\t\t\tString[] r = t.split(\"=\");\n//\t\t\tid = 0;\n//\t\t\ts = (r[0]+\"$\").toCharArray();\n//\t\t\tdouble ex1 = exp();\n////\t\t\tSystem.out.println(\"EX1: \" + s + \" RES:\" + ex1);\n//\t\t\tif(ex1==1<<28)f = false;\n//\t\t\tid = 0;\n//\t\t\ts = (r[1]+\"$\").toCharArray();\n//\t\t\tdouble ex2 = exp();\n////\t\t\tSystem.out.println(\"EX2: \" + s + \" RES:\" + ex2);\n//\t\t\tif(ex2==1<<28)f = false;\n//\t\t\tif(Math.abs(ex1-ex2)<1e-6);\n//\t\t\telse f = false;\n//\t\t\tif(!f)return false;\n//\t\t}\n//\t\treturn true;\n//\t}\n\t\n//\tboolean dfs(int k){\n//\t\tif(k==n){\n////\t\t\tSystem.out.println(\"II\");\n//\t\t\treturn assign();\n//\t\t}\n//\t\tfor(int i=0;i<n;i++){\n//\t\t\tif(u[i])continue;\n//\t\t\tu[i] = true;\n//\t\t\tref[i] = k;\n//\t\t\tif(dfs(k+1))return true;\n//\t\t\tu[i] = false;\n//\t\t}\n//\t\treturn false;\n//\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint k = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(m[i][j]=='.')m[i][j]=(char)(k+++'A');\n\t\t\texs = new ArrayList<E>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i][j+1]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(j<w&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i][j++]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(new E(sb.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int i=0;i<h-1;i++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i+1][j]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(i<h&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i++][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(new E(sb.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(exs);\n//\t\t\tfor(E e:exs)System.out.println(e.s);\n\t\t\tn = sc.nextInt();\n\t\t\tcand = new char[n];\n\t\t\tfor(int i=0;i<n;i++)cand[i]=sc.next().charAt(0);\n\t\t\tref = new int[n];\n\t\t\tArrays.fill(ref, -1);\n\t\t\tu = new boolean[n];\n\t\t\tSystem.out.println(assign(0)?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Indian Puzzle\npublic class Main{\n\n\tint n;\n\tchar[] cand;\n\tint[] ref;\n\tboolean[] u;\n\tList<String> exs;\n\t\n\tchar[] s;\n\tint id;\n\t\n\tchar get(){\n//\t\tSystem.out.println(\"ID:\" + id);\n\t\tif(Character.isUpperCase(s[id]))return cand[ref[s[id++]-'A']];\n\t\telse return s[id++];\n\t}\n\t\n\tdouble exp(){\n\t\tdouble res = fact();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='+'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres+=a;\n\t\t\t}\n\t\t\telse if(c=='-'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres-=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tdouble fact(){\n\t\tdouble res = digit();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='*'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres*=a;\n\t\t\t}\n\t\t\telse if(c=='/'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28||a==0)return a;\n\t\t\t\tres/=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn res;\n\t}\n\t\n\tdouble digit(){\n\t\tdouble res = 0;\n\t\tchar c = get();\n\t\tif(!Character.isDigit(c))return 1<<28;\n\t\tchar next = get();\n\t\tif(c=='0'&&'1'<=next&&next<='9')return 1<<28;\n\t\tid--;\n\t\twhile(Character.isDigit(c)){\n\t\t\tres = res*10 + (c-'0');\n\t\t\tc = get();\n\t\t}\n\t\tid--;\n//\t\tSystem.out.println(\"DIGIT RES:\" + res);\n\t\treturn res;\n\t}\n\t\n\tboolean assign(){\n\t\tboolean f = true;\n\t\tfor(String t:exs){\n\t\t\tString[] r = t.split(\"=\");\n\t\t\tid = 0;\n\t\t\ts = (r[0]+\"$\").toCharArray();\n\t\t\tdouble ex1 = exp();\n//\t\t\tSystem.out.println(\"EX1: \" + s + \" RES:\" + ex1);\n\t\t\tif(ex1==1<<28)f = false;\n\t\t\tid = 0;\n\t\t\ts = (r[1]+\"$\").toCharArray();\n\t\t\tdouble ex2 = exp();\n//\t\t\tSystem.out.println(\"EX2: \" + s + \" RES:\" + ex2);\n\t\t\tif(ex2==1<<28)f = false;\n\t\t\tif(Math.abs(ex1-ex2)<1e-6);\n\t\t\telse f = false;\n\t\t\tif(!f)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tboolean dfs(int k){\n\t\tif(k==n){\n//\t\t\tSystem.out.println(\"II\");\n\t\t\treturn assign();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(u[i])continue;\n\t\t\tu[i] = true;\n\t\t\tref[i] = k;\n\t\t\tif(dfs(k+1))return true;\n\t\t\tu[i] = false;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint k = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(m[i][j]=='.')m[i][j]=(char)(k+++'A');\n\t\t\texs = new ArrayList<String>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i][j+1]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(j<w&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i][j++]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int i=0;i<h-1;i++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i+1][j]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(i<h&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i++][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(sb.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tn = sc.nextInt();\n\t\t\tcand = new char[n];\n\t\t\tfor(int i=0;i<n;i++)cand[i]=sc.next().charAt(0);\n\t\t\tref = new int[n];\n\t\t\tu = new boolean[n];\n\t\t\tSystem.out.println(dfs(0)?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class Main{\n        public static void main(String[] arg) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String[] ia;\n\n                while(true){\n                        ia = in.readLine().split(\" \");\n                        H = Integer.parseInt(ia[0]);\n                        W = Integer.parseInt(ia[1]);\n                        if(H == 0 && W == 0){\n                                break;\n                        }\n                        prob1 = new char[H][W];\n                        prob2 = new char[W][H];\n                        for(int i = 0;i < H; ++i){\n                                prob1[i] = in.readLine().toCharArray();\n                        }\n                        n = Integer.parseInt(in.readLine());\n                        cont = new char[n];\n                        ia = in.readLine().split(\" \");\n                        on = 0;\n                        for(int i = 0;i < n; ++i){\n                                cont[i] = ia[i].charAt(0);\n                                if(cont[i] == '-' || cont[i] == '+' || cont[i] == '*' || cont[i] == '/'){\n                                        ++on;\n                                }\n                        }\n                        Arrays.sort(cont);\n                        con = new int[n][2];\n                        co = new boolean[n];\n                        os = new boolean[n];\n\n                        boolean cs = true;\n\n                        int c = 0;\n                        for(int i = 0;i < H; ++i){\n                                for(int j = 0;j < W; ++j){\n                                        if((prob2[j][i] = prob1[i][j]) == '.'){\n                                                con[c][0] = i;\n                                                con[c][1] = j;\n                                                ++c;\n                                        }\n                                }\n                        }\n\n                        if(c != n){\n                                cs = false;\n                        }\n                        osc = 0;\n                        for(int i = 0;i < n; ++i){\n                                os[i] = sfos(con[i][0],con[i][1]);\n                        }\n                        if(cs && solv(0)){\n                                System.out.println(\"Yes\");\n                        } else {\n                                System.out.println(\"No\");\n                        }\n                }\n        }\n        static int H;\n        static int W;\n        static char[][] prob1;\n        static char[][] prob2;\n        static int n;\n        static char[] cont;\n        static int[][] con;\n        static boolean[] co;\n        static boolean[] os;\n        static int osc;\n        static int ss;\n        static int on;\n        static boolean sfos(int a, int b){\n                if(0 < a && a < H){\n                        if(!(prob1[a-1][b] == '.' || prob1[a-1][b] == '#' ||\n                            (0 <= (prob1[a-1][b] - '0') && (prob1[a-1][b] - '0') < 10))){\n                                return false;\n                        }\n                }\n\n                if(0 <= a && a < H-1){\n                        if(!(prob1[a+1][b] == '.' || prob1[a+1][b] == '#' ||\n                            (0 <= (prob1[a+1][b] - '0') && (prob1[a+1][b] - '0') < 10))){\n                                return false;\n                        }\n                }\n                if(0 < b && b < W){\n                        if(!(prob1[a][b-1] == '.' || prob1[a][b-1] == '#' ||\n                            (0 <= (prob1[a][b-1] - '0') && (prob1[a][b-1] - '0') < 10))){\n                                return false;\n                        }\n                }\n                if(0 <= b && b < W-1){\n                        if(!(prob1[a][b+1] == '.' || prob1[a][b+1] == '#' ||\n                            (0 <= (prob1[a][b+1] - '0') && (prob1[a][b+1] - '0') < 10))){\n                                return false;\n                        }\n                }\n                ++osc;\n                return true;\n        }\n        static boolean solv(int c){\n                if(c == on){\n                        return solve(c);\n                }\n                for(int i = 0;i < n; ++i){\n                        if(os[i] && !co[i]){\n                                co[i] = true;\n                                prob1[con[i][0]][con[i][1]] = cont[c];\n                                prob2[con[i][1]][con[i][0]] = cont[c];\n                                if(solv(c+1)){\n                                        return true;\n                                }\n                                co[i] = false;\n                        }\n                }\n                return false;\n        }\n        static boolean solve(int c){\n                char b = 'n';\n                if(c == n){\n                        return ca();\n                }\n                for(int i = 0;i < n; ++i){\n                        if(!co[i] && cont[i] != b){\n                                b = cont[i];\n                                co[i] = true;\n                                prob1[con[i][0]][con[i][1]] = cont[c];\n                                prob2[con[i][1]][con[i][0]] = cont[c];\n                                if(solve(c+1)){\n                                        return true;\n                                }\n                                co[i] = false;\n                        }\n                }\n                return false;\n        }\n        static boolean ca(){\n                for(int i = 0;i < H; ++i){\n                        if(!cal(prob1[i])){\n                                return false;\n                        }\n                }\n                for(int i = 0;i < W; ++i){\n                        if(!cal(prob2[i])){\n                                return false;\n                        }\n                }\n                return true;\n        }\n        static boolean cal(char[] s){\n                int b=0,i,j;\n                boolean flag = true;\n                while(b < s.length){\n                        for(i = b;i < s.length; ++i){\n                                if(s[i] == '='){\n                                        break;\n                                }\n                        }\n                        for(j = b;j < s.length; ++j){\n                                if(s[j] == '#'){\n                                        break;\n                                }\n                        }\n                        if(j-b > 2){\n                                if(i != s.length){\n                                        flag = flag && (calc(s,b,i) == calc(s,i+1,j));\n                                } else {\n                                        return false;\n                                }\n                        }\n                        b = j+1;\n                }\n                return flag;\n        }\n        static int calc(char[] s, Integer t, Integer e){\n                int x = 0;\n                int t1 = 0;\n                if(e-t==0){\n                        return Integer.MIN_VALUE;\n                }\n                for(int i = t;t < e; ++t){\n                        if(0 < s[t]-'0' && s[t]-'0'<10){\n                                t1 = t1*10+s[t]-'0';\n                        } else if(s[t] == '+'){\n                                return calc(s,i,new Integer(t)) + calc(s,++t,e);\n                        } else if(s[t] == '-'){\n                                return calc(s,i,new Integer(t)) - calc(s,++t,e);\n                        } else if(s[t] == '*'){\n                                t1 *= calc(s,++t,e);\n                        } else if(s[t] == '/'){\n                                try{\n                                        t1 /= calc(s,++t,e);\n                                } catch(ArithmeticException f){\n                                        return Integer.MIN_VALUE;\n                                }\n                                break;\n                        }\n                }\n                return t1;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Indian Puzzle\npublic class Main{\n\n\tclass E implements Comparable<E>{\n\t\tString s;\n\t\tint count;\n\t\tchar[][] str;\n\t\tpublic E(String s) {\n\t\t\tthis.s = s;\n\t\t\tcount = 0;\n\t\t\tfor(char c:s.toCharArray())if(Character.isUpperCase(c))count++;\n\t\t\tstr = new char[2][];\n\t\t\tString[] t = s.split(\"=\");\n\t\t\tstr[0] = (t[0]+\"$\").toCharArray();\n\t\t\tstr[1] = (t[1]+\"$\").toCharArray();\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn count-o.count;\n\t\t}\n\t}\n\t\n\tint n;\n\tchar[] cand;\n\tint[] ref;\n\tboolean[] u;\n\tList<E> exs;\n\t\n\tchar[] s;\n\tint id;\n\t\n\tboolean sub(char[] t, int k, int ind){\n\t\tif(ind==t.length){\n//\t\t\tSystem.out.println(\"R[0]:\" + r[0] + \" R[1]:\" + r[1]);\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\tif(ref[i]!=-1)System.out.println((char)(i+'A')+\" -> \" + cand[ref[i]]);\n//\t\t\t}\n\t\t\tid = 0;\n\t\t\ts = exs.get(k).str[0];\n\t\t\tdouble ex1 = exp();\n\t\t\tif(ex1==1<<28)return false;\n\t\t\tid = 0;\n\t\t\ts = exs.get(k).str[1];\n\t\t\tdouble ex2 = exp();\n\t\t\tif(ex2==1<<28)return false;\n\t\t\tif(Math.abs(ex1-ex2)<1e-6)return assign(k+1);\n\t\t\treturn false;\n\t\t}\n\t\tif(!Character.isUpperCase(t[ind]))return sub(t,k,ind+1);\n\t\tint x = t[ind]-'A';\n\t\tif(ref[x]!=-1)return sub(t,k,ind+1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(u[i])continue;\n\t\t\tu[i] = true;\n\t\t\tref[x] = i;\n\t\t\tif(sub(t,k,ind+1))return true;\n\t\t\tu[i] = false;\n\t\t\tref[x] = -1;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tboolean assign(int k){\n\t\tif(k==exs.size())return true;\n\t\treturn sub(exs.get(k).s.toCharArray(), k, 0);\n\t}\n\t\n\tchar get(){\n\t\tif(Character.isUpperCase(s[id]))return cand[ref[s[id++]-'A']];\n\t\telse return s[id++];\n\t}\n\t\n\tdouble exp(){\n\t\tdouble res = fact();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='+'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres+=a;\n\t\t\t}\n\t\t\telse if(c=='-'){\n\t\t\t\tdouble a = fact();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres-=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tdouble fact(){\n\t\tdouble res = digit();\n\t\tif(res==1<<28)return res;\n\t\twhile(true){\n\t\t\tchar c = get();\n\t\t\tif(c=='*'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28)return a;\n\t\t\t\tres*=a;\n\t\t\t}\n\t\t\telse if(c=='/'){\n\t\t\t\tdouble a = digit();\n\t\t\t\tif(a==1<<28||a==0)return a;\n\t\t\t\tres/=a;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tid--;\n\t\treturn res;\n\t}\n\t\n\tdouble digit(){\n\t\tdouble res = 0;\n\t\tchar c = get();\n\t\tif(!Character.isDigit(c))return 1<<28;\n\t\tchar next = get();\n\t\tif(c=='0'&&'1'<=next&&next<='9')return 1<<28;\n\t\tid--;\n\t\twhile(Character.isDigit(c)){\n\t\t\tres = res*10 + (c-'0');\n\t\t\tc = get();\n\t\t}\n\t\tid--;\n\t\treturn res;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tchar[][] m = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\tint k = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(m[i][j]=='.')m[i][j]=(char)(k+++'A');\n\t\t\texs = new ArrayList<E>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w-1;j++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i][j+1]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(j<w&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i][j++]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(new E(sb.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tfor(int i=0;i<h-1;i++){\n\t\t\t\t\tif(m[i][j]!='#'&&m[i+1][j]!='#'){\n\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\twhile(i<h&&m[i][j]!='#'){\n\t\t\t\t\t\t\tsb.append(m[i++][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\texs.add(new E(sb.toString()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(exs);\n\t\t\tn = sc.nextInt();\n\t\t\tcand = new char[n];\n\t\t\tfor(int i=0;i<n;i++)cand[i]=sc.next().charAt(0);\n\t\t\tref = new int[n];\n\t\t\tArrays.fill(ref, -1);\n\t\t\tu = new boolean[n];\n\t\t\tSystem.out.println(assign(0)?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\n\npublic class Main{\n\tstatic int h,w,n;\n\tstatic char[][] t;\n\tstatic String[] s;\n\tstatic ArrayList<Point> p;\n\tstatic boolean[] used;\n\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString[] tmp = br.readLine().split(\" \");\n\t\t\th = Integer.parseInt(tmp[0]);\n\t\t\tw = Integer.parseInt(tmp[1]);\n\t\t\tif(h == 0 && w == 0) break;\n\n\t\t\tp = new ArrayList<Point>();\n\t\t\tt = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tt[i] = br.readLine().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++) if(t[i][j]=='.') p.add(new Point(j,i));\n\t\t\t}\n\n\t\t\tn = Integer.parseInt(br.readLine());\n\t\t\ts = br.readLine().split(\" \");\n\n\t\t\tused = new boolean[n];\n\t\t\tSystem.out.println(solve(0)?\"Yes\":\"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve(int idx){\n\t\tif(idx == n) return check();\n\n\t\tfor(int i=0;i<n;i++) if(!used[i]) {\n\t\t\tused[i] = true;\n\t\t\tt[p.get(idx).y][p.get(idx).x] = s[i].charAt(0);\n\t\t\tif(solve(idx+1)) return true;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tstatic boolean check(){\n\t\t//ツ縦ツチツェツッツク\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint i = 0;\n\t\t\twhile(i<h){\n\t\t\t\tfor(;i<h && t[i][j]=='#';i++);\n\t\t\t\tif(i>=h) break;\n\t\t\t\tString str = \"\" + t[i++][j];\n\t\t\t\tfor(;i<h && t[i][j]!='#';i++) str += t[i][j];\n\t\t\t\tif(str.length()>=3 && !Eq(str)) return false;\n\t\t\t}\n\t\t}\n\n\t\t//ツ可。ツチツェツッツク\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint j = 0;\n\t\t\twhile(j<w){\n\t\t\t\tfor(;j<w && t[i][j]=='#';j++);\n\t\t\t\tif(j>=w) break;\n\t\t\t\tString str = \"\" + t[i][j++];\n\t\t\t\tfor(;j<w && t[i][j]!='#';j++) str += t[i][j];\n\t\t\t\tif(str.length()>=3 && !Eq(str)) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic boolean Eq(String str){\n\t\tString[] tmp = str.split(\"=\");\n\t\tif(tmp.length<2 || tmp[0].equals(\"\") || tmp[1].equals(\"\")) return false;\n\n\t\tlong left = Ex(tmp[0]);\n\t\tif(left==Long.MAX_VALUE) return false;\n\t\tlong right = Ex(tmp[1]);\n\t\tif(right==Long.MAX_VALUE) return false;\n\n\t\treturn left == right;\n\t}\n\n\tstatic long Ex(String str){\n\t\tString[] tmp = str.split(\"\\\\+|\\\\-|\\\\*|/\");\n\t\tif(tmp.length == 0) return Long.MAX_VALUE;\n\t\tfor(String ss : tmp){\n\t\t\tif(ss.equals(\"\") || ss.length()>=2 && ss.charAt(0)=='0') return Long.MAX_VALUE;\n\t\t}\n\n\t\tArrayList<Character> opCh = new ArrayList<Character>();\n\t\tint len = str.length();\n\t\tboolean before = false;\n\t\tif(str.charAt(0)<'0' || '9'<str.charAt(0)) return Long.MAX_VALUE;\n\t\tfor(int i=1;i<len-1;i++){\n\t\t\tif(str.charAt(i)<'0' || '9'<str.charAt(i)){\n\t\t\t\tif(before) return Long.MAX_VALUE;\n\t\t\t\tbefore = true;\n\t\t\t\topCh.add(str.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbefore = false;\n\t\t\t}\n\t\t}\n\t\tif(str.charAt(len-1)<'0' || '9'<str.charAt(len-1)) return Long.MAX_VALUE;\n\n\t\tStack<Long> val = new Stack<Long>();\n\t\tStack<Character> op = new Stack<Character>();\n\t\tval.push(Long.parseLong(tmp[0]));\n\t\tint tmpIdx=1, opChIdx=0;\n\n\t\twhile(tmpIdx<tmp.length){\n\t\t\tchar ch = opCh.get(opChIdx++);\n\n\t\t\tif(!op.empty()){\n\t\t\t\tchar ops = op.peek();\n\t\t\t\tif(ops=='*' || ops=='/' || (ops=='+' || ops=='-') && (ch=='+' || ch=='-')){\n\t\t\t\t\tlong b = val.pop();\n\t\t\t\t\tlong a = val.pop();\n\t\t\t\t\top.pop();\n\t\t\t\t\tif(ops == '+') val.push(a+b);\n\t\t\t\t\telse if(ops == '-') val.push(a-b);\n\t\t\t\t\telse if(ops == '*') val.push(a*b);\n\t\t\t\t\telse if(ops == '/'){\n\t\t\t\t\t\tif(b==0 || a%b!=0) return Long.MAX_VALUE;\n\t\t\t\t\t\tval.push(a/b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\top.push(ch);\n\t\t\tval.push(Long.parseLong(tmp[tmpIdx++]));\n\t\t}\n\n\t\twhile(!op.empty()){\n\t\t\tchar ops = op.pop();\n\t\t\tlong b = val.pop();\n\t\t\tlong a = val.pop();\n\t\t\tif(ops == '+') val.push(a+b);\n\t\t\telse if(ops == '-') val.push(a-b);\n\t\t\telse if(ops == '*') val.push(a*b);\n\t\t\telse if(ops == '/'){\n\t\t\t\tif(b==0 || a%b!=0) return Long.MAX_VALUE;\n\t\t\t\tval.push(a/b);\n\t\t\t}\n\t\t}\n\n\t\treturn val.peek();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "aimport java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class Main{\n        public static void main(String[] arg) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String[] ia;\n\n                while(true){\n                        ia = in.readLine().split(\" \");\n                        H = Integer.parseInt(ia[0]);\n                        W = Integer.parseInt(ia[1]);\n                        if(H == 0 && W == 0){\n                                break;\n                        }\n                        prob1 = new char[H][W];\n                        prob2 = new char[W][H];\n                        for(int i = 0;i < H; ++i){\n                                prob1[i] = in.readLine().toCharArray();\n                        }\n                        n = Integer.parseInt(in.readLine());\n                        cont = new char[n];\n                        ia = in.readLine().split(\" \");\n                        on = 0;\n                        for(int i = 0;i < n; ++i){\n                                cont[i] = ia[i].charAt(0);\n                                if(cont[i] == '-' || cont[i] == '+' || cont[i] == '*' || cont[i] == '/'){\n                                        ++on;\n                                }\n                        }\n                        Arrays.sort(cont);\n                        con = new int[n][2];\n                        co = new boolean[n];\n                        os = new boolean[n];\n\n                        boolean cs = true;\n\n                        int c = 0;\n                        for(int i = 0;i < H; ++i){\n                                for(int j = 0;j < W; ++j){\n                                        if((prob2[j][i] = prob1[i][j]) == '.'){\n                                                con[c][0] = i;\n                                                con[c][1] = j;\n                                                ++c;\n                                        }\n                                }\n                        }\n\n                        if(c != n){\n                                cs = false;\n                        }\n                        osc = 0;\n                        for(int i = 0;i < n; ++i){\n                                os[i] = sfos(con[i][0],con[i][1]);\n                        }\n                        if(cs && solv(0)){\n                                System.out.println(\"Yes\");\n                        } else {\n                                System.out.println(\"No\");\n                        }\n                }\n        }\n        static int H;\n        static int W;\n        static char[][] prob1;\n        static char[][] prob2;\n        static int n;\n        static char[] cont;\n        static int[][] con;\n        static boolean[] co;\n        static boolean[] os;\n        static int osc;\n        static int ss;\n        static int on;\n        static boolean sfos(int a, int b){\n                if(0 < a && a < H){\n                        if(!(prob1[a-1][b] == '.' || prob1[a-1][b] == '#' ||\n                            (0 <= (prob1[a-1][b] - '0') && (prob1[a-1][b] - '0') < 10))){\n                                return false;\n                        }\n                }\n                if(0 <= a && a < H-1){\n                        if(!(prob1[a+1][b] == '.' || prob1[a+1][b] == '#' ||\n                            (0 <= (prob1[a+1][b] - '0') && (prob1[a+1][b] - '0') < 10))){\n                                return false;\n                        }\n                }\n                if(0 < b && b < W){\n                        if(!(prob1[a][b-1] == '.' || prob1[a][b-1] == '#' ||\n                            (0 <= (prob1[a][b-1] - '0') && (prob1[a][b-1] - '0') < 10))){\n                                return false;\n                        }\n                }\n                if(0 <= b && b < W-1){\n                        if(!(prob1[a][b+1] == '.' || prob1[a][b+1] == '#' ||\n                            (0 <= (prob1[a][b+1] - '0') && (prob1[a][b+1] - '0') < 10))){\n                                return false;\n                        }\n                }\n                ++osc;\n                return true;\n        }\n        static boolean solv(int c){\n                if(c == on){\n                        return solve(c);\n                }\n                for(int i = 0;i < n; ++i){\n                        if(os[i] && !co[i]){\n                                co[i] = true;\n                                prob1[con[i][0]][con[i][1]] = cont[c];\n                                prob2[con[i][1]][con[i][0]] = cont[c];\n                                if(solv(c+1)){\n                                        return true;\n                                }\n                                co[i] = false;\n                        }\n                }\n                return false;\n        }\n        static boolean solve(int c){\n                char b = 'n';\n                if(c == n){\n                        return ca();\n                }\n                for(int i = 0;i < n; ++i){\n                        if(!co[i] && cont[i] != b){\n                                b = cont[i];\n                                co[i] = true;\n                                prob1[con[i][0]][con[i][1]] = cont[c];\n                                prob2[con[i][1]][con[i][0]] = cont[c];\n                                if(solve(c+1)){\n                                        return true;\n                                }\n                                co[i] = false;\n                        }\n                }\n                return false;\n        }\n        static boolean ca(){\n                for(int i = 0;i < H; ++i){\n                        if(!cal(prob1[i])){\n                                return false;\n                        }\n                }\n                for(int i = 0;i < W; ++i){\n                        if(!cal(prob2[i])){\n                                return false;\n                        }\n                }\n                return true;\n        }\n        static boolean cal(char[] s){\n                int b=0,i,j;\n                boolean flag = true;\n                while(b < s.length){\n                        for(i = b;i < s.length; ++i){\n                                if(s[i] == '='){\n                                        break;\n                                }\n                        }\n                        for(j = b;j < s.length; ++j){\n                                if(s[j] == '#'){\n                                        break;\n                                }\n                        }\n                        if(j-b > 2){\n                                if(i != s.length){\n                                        flag = flag && (calc(s,b,i) == calc(s,i+1,j));\n                                } else {\n                                        return false;\n                                }\n                        }\n                        b = j+1;\n                }\n                return flag;\n        }\n        static int calc(char[] s, Integer t, Integer e){\n                int x = 0;\n                int t1 = 0;\n                if(e-t==0){\n                        return -100000;\n                }\n                for(int i = t;t < e; ++t){\n                        if(0 < s[t]-'0' && s[t]-'0'<10){\n                                t1 = t1*10+s[t]-'0';\n                        } else if(s[t] == '+'){\n                                return calc(s,i,new Integer(t)) + calc(s,++t,e);\n                        } else if(s[t] == '-'){\n                                return calc(s,i,new Integer(t)) - calc(s,++t,e);\n                        } else if(s[t] == '*'){\n                                t1 *= calc(s,++t,e);\n                        } else if(s[t] == '/'){\n                                try{\n                                        t1 /= calc(s,++t,e);\n                                } catch(ArithmeticException f){\n                                        return -100000;\n                                }\n                                break;\n                        }\n                }\n                return t1;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\n\npublic class Main{\n\tstatic int h,w,n;\n\tstatic char[][] t;\n\tstatic String[] s;\n\tstatic ArrayList<Point> p;\n\tstatic boolean[] used;\n\n\t//ok\n\tpublic static void main(String[] args)throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString[] tmp = br.readLine().split(\" \");\n\t\t\th = Integer.parseInt(tmp[0]);\n\t\t\tw = Integer.parseInt(tmp[1]);\n\t\t\tif(h == 0 && w == 0) break;\n\n\t\t\tp = new ArrayList<Point>();\n\t\t\tt = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tt[i] = br.readLine().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++) if(t[i][j]=='.') p.add(new Point(j,i));\n\t\t\t}\n\n\t\t\tn = Integer.parseInt(br.readLine());\n\t\t\ts = br.readLine().split(\" \");\n\n\t\t\tused = new boolean[n];\n\t\t\tSystem.out.println(solve(0)?\"Yes\":\"No\");\n\t\t}\n\t}\n\n\t//ok\n\tstatic boolean solve(int idx){\n\t\tif(idx == p.size()) return check();\n\n\t\tfor(int i=0;i<n;i++) if(!used[i]) {\n\t\t\tused[i] = true;\n\t\t\tt[p.get(idx).y][p.get(idx).x] = s[i].charAt(0);\n\t\t\tif(solve(idx+1)) return true;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//ok\n\tstatic boolean check(){\n\t\t//ツ縦ツチツェツッツク\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint i = 0;\n\t\t\twhile(i<h){\n\t\t\t\tfor(;i<h && t[i][j]=='#';i++);\n\t\t\t\tif(i>=h) break;\n\t\t\t\tString str = \"\" + t[i++][j];\n\t\t\t\tfor(;i<h && t[i][j]!='#';i++) str += t[i][j];\n\t\t\t\tif(str.length()>=3 && !Eq(str)) return false;\n\t\t\t}\n\t\t}\n\n\t\t//ツ可。ツチツェツッツク\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint j = 0;\n\t\t\twhile(j<w){\n\t\t\t\tfor(;j<w && t[i][j]=='#';j++);\n\t\t\t\tif(j>=w) break;\n\t\t\t\tString str = \"\" + t[i][j++];\n\t\t\t\tfor(;j<w && t[i][j]!='#';j++) str += t[i][j];\n\t\t\t\tif(str.length()>=3 && !Eq(str)) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t//ok\n\tstatic boolean Eq(String str){\n\t\tString[] tmp = str.split(\"=\");\n\t\tif(tmp.length<2 || tmp[0].equals(\"\") || tmp[1].equals(\"\")) return false;\n\n\t\tlong left = Ex(tmp[0]);\n\t\tif(left==Long.MAX_VALUE) return false;\n\t\tlong right = Ex(tmp[1]);\n\t\tif(right==Long.MAX_VALUE) return false;\n\n\t\treturn left == right;\n\t}\n\n\tstatic long Ex(String str){\n\t\tString[] tmp = str.split(\"\\\\+|\\\\-|\\\\*|/\");\n\t\tif(tmp.length == 0) return Long.MAX_VALUE;\n\t\tfor(String ss : tmp){\n\t\t\tif(ss.equals(\"\") || ss.length()>=2 && ss.charAt(0)=='0') return Long.MAX_VALUE;\n\t\t}\n\n\t\tArrayList<Character> opCh = new ArrayList<Character>();\n\t\tint len = str.length();\n\t\tboolean before = false;\n\t\tif(str.charAt(0)<'0' || '9'<str.charAt(0)) return Long.MAX_VALUE;\n\t\tfor(int i=1;i<len-1;i++){\n\t\t\tif(str.charAt(i)<'0' || '9'<str.charAt(i)){\n\t\t\t\tif(before) return Long.MAX_VALUE;\n\t\t\t\tbefore = true;\n\t\t\t\topCh.add(str.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbefore = false;\n\t\t\t}\n\t\t}\n\t\tif(str.charAt(len-1)<'0' || '9'<str.charAt(len-1)) return Long.MAX_VALUE;\n\t\tif(opCh.size()+1 != tmp.length) return Long.MAX_VALUE;\n\n\t\tStack<Long> val = new Stack<Long>();\n\t\tStack<Character> op = new Stack<Character>();\n\t\tval.push(Long.parseLong(tmp[0]));\n\t\tint tmpIdx=1, opChIdx=0;\n\n\t\twhile(tmpIdx<tmp.length){\n\t\t\tchar ch = opCh.get(opChIdx++);\n\n\t\t\tif(!op.empty()){\n\t\t\t\tchar ops = op.peek();\n\t\t\t\tif(ops=='*' || ops=='/' || (ops=='+' || ops=='-') && (ch=='+' || ch=='-')){\n\t\t\t\t\top.pop();\n\t\t\t\t\tlong b = val.pop();\n\t\t\t\t\tlong a = val.pop();\n\t\t\t\t\tif(ops == '+') val.push(a+b);\n\t\t\t\t\telse if(ops == '-') val.push(a-b);\n\t\t\t\t\telse if(ops == '*') val.push(a*b);\n\t\t\t\t\telse if(ops == '/'){\n\t\t\t\t\t\tif(b==0 || a%b!=0) return Long.MAX_VALUE;\n\t\t\t\t\t\tval.push(a/b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\top.push(ch);\n\t\t\tval.push(Long.parseLong(tmp[tmpIdx++]));\n\t\t}\n\n\t\twhile(!op.empty()){\n\t\t\tchar ops = op.pop();\n\t\t\tlong b = val.pop();\n\t\t\tlong a = val.pop();\n\t\t\tif(ops == '+') val.push(a+b);\n\t\t\telse if(ops == '-') val.push(a-b);\n\t\t\telse if(ops == '*') val.push(a*b);\n\t\t\telse if(ops == '/'){\n\t\t\t\tif(b==0 || a%b!=0) return Long.MAX_VALUE;\n\t\t\t\tval.push(a/b);\n\t\t\t}\n\t\t}\n\n\t\treturn val.peek();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### global variables\n\n$pos = 0\n$expcache = {}\n\n### subroutines\n\n## <exp> := <md> (('+'|'-') <md>)*\n## <md> := <num> (('*'|'/') <num>)*\n## <num> := '0' | ('1'-'9')('0'-'9')*\n\ndef parse_num(exp)\n  #puts \"parse_num: #{exp}, #{$pos}\"\n\n  str = ''\n  ch = exp[$pos]\n  while ! ch.nil? && ch >= '0' && ch <= '9'\n    str += ch\n    $pos += 1\n    ch = exp[$pos]\n  end\n\n  return nil if str == '' || (str.length >= 2 && str[0] == '0')\n  str.to_i\nend\n\ndef parse_md(exp)\n  #puts \"parse_md: #{exp}, #{$pos}\"\n\n  val = parse_num(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '*' || ch == '/')\n    $pos += 1\n    val0 = parse_num(exp)\n    return nil if val0.nil?\n\n    if ch == '*'\n      val *= val0\n    else\n      return nil if val0 == 0 || val % val0 != 0\n      val /= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef parse_exp(exp)\n  #puts \"parse_exp: #{exp}, #{$pos}\"\n\n  val = parse_md(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '+' || ch == '-')\n    #puts \"parse_exp: #{exp}[#{$pos}] = #{ch}\"\n\n    $pos += 1\n    val0 = parse_md(exp)\n    return nil if val0.nil?\n\n    if ch == '+'\n      val += val0\n    else\n      val -= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef eval_exp(exp)\n  return $expcache[exp] if ! $expcache[exp].nil?\n\n  $pos = 0\n  val = parse_exp(exp)\n\n  $expcache[exp] = ($pos == exp.length) ? val : nil\nend\n\ndef is_valid_eqn?(eqn)\n  exps = eqn.split('=')\n  return false if exps.length != 2\n\n  val0 = eval_exp(exps[0])\n  val1 = eval_exp(exps[1])\n\n  ! val0.nil? && ! val1.nil? && val0 == val1\nend\n\ndef check_rec(k)\n  return true if k >= $n\n\n  for d in (0...$n)\n    next if $used[d]\n\n    $used[d] = true\n    $mtx[$blanks[k]] = $cands[d]\n    ok = true\n\n    for i in $eqnbls[k]\n      eqnstr = $eqns[i].map{|j| $mtx[j]}.join\n      ok = is_valid_eqn?(eqnstr)\n      break if ! ok\n    end\n\n    if ok\n      ok = check_rec(k + 1)\n    end\n\n    $mtx[$blanks[k]] = '.'\n    $used[d] = false\n\n    return true if ok\n  end\n\n  false\nend\n\n### main\n\nloop do\n  $h, $w = gets.split.map(&:to_i)\n  break if $h == 0 && $w == 0\n\n  hw = $h * $w\n\n  $mtx = []\n\n  $h.times do\n    $mtx += gets.strip.split('')\n  end\n  #p $mtx\n\n  $eqns = []\n\n  for y in (0...$h)\n    x = 0\n    while x < $w\n      x0 = x\n      eqn = []\n      while x0 < $w && $mtx[y * $w + x0] != '#'\n        eqn << y * $w + x0\n        x0 += 1\n      end\n      $eqns << eqn if eqn.length > 1\n      x = x0 + 1\n    end\n  end\n\n  for x in (0...$w)\n    y = 0\n    while y < $h\n      y0 = y\n      eqn = []\n      while y0 < $h && $mtx[y0 * $w + x] != '#'\n        eqn << y0 * $w + x\n        y0 += 1\n      end\n      $eqns << eqn if eqn.length > 1\n      y = y0 + 1\n    end\n  end\n  #$eqns.each{|e| p e.map{|i| $mtx[i]}.join}\n\n  $blanks = []\n  $mtx.each_with_index{|c, i|  $blanks << i if c == '.'}\n  #p $blanks\n\n  $n = gets.to_i\n  $cands = gets.split\n  #p cands\n\n  $eqnbls = $n.times.map{[]}\n  for i in (0...$eqns.length)\n    blpos = $eqns[i].select{|pos| $mtx[pos] == '.'}.max\n    $eqnbls[$blanks.index(blpos)] << i\n  end\n  #p $eqnbls\n\n  $used = $n.times.map{false}\n\n  ok = check_rec(0)\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Ruby",
    "code": "### global variables\n\n$pos = 0\n$expcache = {}\n\n### subroutines\n\n## <exp> := <md> (('+'|'-') <md>)*\n## <md> := <num> (('*'|'/') <num>)*\n## <num> := '0' | ('1'-'9')('0'-'9')*\n\ndef parse_num(exp)\n  #puts \"parse_num: #{exp}, #{$pos}\"\n\n  str = ''\n  ch = exp[$pos]\n  while ! ch.nil? && ch >= '0' && ch <= '9'\n    str += ch\n    $pos += 1\n    ch = exp[$pos]\n  end\n\n  return nil if str == '' || (str.length >= 2 && str[0] == '0')\n  str.to_i\nend\n\ndef parse_md(exp)\n  #puts \"parse_md: #{exp}, #{$pos}\"\n\n  val = parse_num(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '*' || ch == '/')\n    $pos += 1\n    val0 = parse_num(exp)\n    return nil if val0.nil?\n\n    if ch == '*'\n      val *= val0\n    else\n      return nil if val0 == 0 || val % val0 != 0\n      val /= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef parse_exp(exp)\n  #puts \"parse_exp: #{exp}, #{$pos}\"\n\n  val = parse_md(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '+' || ch == '-')\n    #puts \"parse_exp: #{exp}[#{$pos}] = #{ch}\"\n\n    $pos += 1\n    val0 = parse_md(exp)\n    return nil if val0.nil?\n\n    if ch == '+'\n      val += val0\n    else\n      val -= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef eval_exp(exp)\n  #return $expcache[exp] if ! $expcache[exp].nil?\n\n  $pos = 0\n  val = parse_exp(exp)\n\n  #$expcache[exp] = ($pos == exp.length) ? val : nil\n  ($pos == exp.length) ? val : nil\nend\n\ndef is_valid_eqn?(eqn)\n  exps = eqn.split('=')\n  return false if exps.length != 2\n\n  val0 = eval_exp(exps[0])\n  val1 = eval_exp(exps[1])\n\n  ! val0.nil? && ! val1.nil? && val0 == val1\nend\n\ndef check_rec(k)\n  return true if k >= $n\n\n  for d in (0...$n)\n    next if $used[d]\n\n    $used[d] = true\n    $mtx[$blanks[k]] = $cands[d]\n    ok = true\n\n    for i in $eqnbls[k]\n      eqnstr = $eqns[i].map{|j| $mtx[j]}.join\n      ok = is_valid_eqn?(eqnstr)\n      break if ! ok\n    end\n\n    if ok\n      ok = check_rec(k + 1)\n    end\n\n    $mtx[$blanks[k]] = '.'\n    $used[d] = false\n\n    return true if ok\n  end    \n\n  false\nend\n\n### main\n\nloop do\n  $h, $w = gets.split.map(&:to_i)\n  break if $h == 0 && $w == 0\n\n  hw = $h * $w\n\n  $mtx = []\n\n  $h.times do\n    $mtx += gets.strip.split('')\n  end\n  #p $mtx\n\n  $eqns = []\n\n  for y in (0...$h)\n    x = 0\n    while x < $w\n      x0 = x\n      eqn = []\n      while x0 < $w && $mtx[y * $w + x0] != '#'\n        eqn << y * $w + x0\n        x0 += 1\n      end\n      $eqns << eqn if eqn.length > 1\n      x = x0 + 1\n    end\n  end\n\n  for x in (0...$w)\n    y = 0\n    while y < $h\n      y0 = y\n      eqn = []\n      while y0 < $h && $mtx[y0 * $w + x] != '#'\n        eqn << y0 * $w + x\n        y0 += 1\n      end\n      $eqns << eqn if eqn.length > 1\n      y = y0 + 1\n    end\n  end\n  #$eqns.each{|e| p e.map{|i| $mtx[i]}.join}\n\n  $blanks = []\n  $mtx.each_with_index{|c, i|  $blanks << i if c == '.'}\n  #p $blanks\n\n  $n = gets.to_i\n  $cands = gets.split\n  #p cands\n\n  $eqnbls = $n.times.map{[]}\n  for i in (0...$eqns.length)\n    blpos = $eqns[i].select{|pos| $mtx[pos] == '.'}.max\n    $eqnbls[$blanks.index(blpos)] << i\n  end\n  #p $eqnbls\n\n  $used = $n.times.map{false}\n\n  ok = check_rec(0)\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Ruby",
    "code": "## global variables\n\n$pos = 0\n$expcache = {}\n\n### subroutines\n\n## <exp> := <md> (('+'|'-') <md>)*\n## <md> := <num> (('*'|'/') <num>)*\n## <num> := '0' | ('1'-'9')('0'-'9')*\n\ndef parse_num(exp)\n  #puts \"parse_num: #{exp}, #{$pos}\"\n\n  str = ''\n  ch = exp[$pos]\n  while ! ch.nil? && ch >= '0' && ch <= '9'\n    str += ch\n    $pos += 1\n    ch = exp[$pos]\n  end\n\n  return nil if str == '' || (str.length >= 2 && str[0] == '0')\n  str.to_i\nend\n\ndef parse_md(exp)\n  #puts \"parse_md: #{exp}, #{$pos}\"\n\n  val = parse_num(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '*' || ch == '/')\n    $pos += 1\n    val0 = parse_num(exp)\n    return nil if val0.nil?\n\n    if ch == '*'\n      val *= val0\n    else\n      return nil if val0 == 0 || val % val0 != 0\n      val /= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef parse_exp(exp)\n  #puts \"parse_exp: #{exp}, #{$pos}\"\n\n  val = parse_md(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '+' || ch == '-')\n    #puts \"parse_exp: #{exp}[#{$pos}] = #{ch}\"\n\n    $pos += 1\n    val0 = parse_md(exp)\n    return nil if val0.nil?\n\n    if ch == '+'\n      val += val0\n    else\n      val -= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef eval_exp(exp)\n  return $expcache[exp] if ! $expcache[exp].nil?\n\n  $pos = 0\n  val = parse_exp(exp)\n\n  $expcache[exp] = ($pos == exp.length) ? val : nil\nend\n\ndef is_valid_eqn?(eqn)\n  exps = eqn.split('=')\n  return false if exps.length != 2\n\n  val0 = eval_exp(exps[0])\n  val1 = eval_exp(exps[1])\n\n  ! val0.nil? && ! val1.nil? && val0 == val1\nend\n\n### main\n\nloop do\n  h, w = gets.split.map(&:to_i)\n  break if h == 0 && w == 0\n\n  mtx = []\n\n  h.times do\n    mtx += gets.strip.split('')\n  end\n  #p mtx\n\n  eqns = []\n\n  for y in (0...h)\n    x = 0\n    while x < w\n      x0 = x\n      eqn = []\n      while x0 < w && mtx[y * w + x0] != '#'\n        eqn << y * w + x0\n        x0 += 1\n      end\n      eqns << eqn if eqn.length > 1\n      x = x0 + 1\n    end\n  end\n\n  for x in (0...w)\n    y = 0\n    while y < h\n      y0 = y\n      eqn = []\n      while y0 < h && mtx[y0 * w + x] != '#'\n        eqn << y0 * w + x\n        y0 += 1\n      end\n      eqns << eqn if eqn.length > 1\n      y = y0 + 1\n    end\n  end\n  #eqns.each{|e| p e.map{|i| mtx[i]}.join}\n\n  blanks = []\n  mtx.each_with_index{|c, i|  blanks << i if c == '.'}\n  #p blanks\n\n  n = gets.to_i\n  cands = gets.split\n  #p cands\n\n  ok = true\n\n  cands.permutation(n) do |cps|\n    for i in (0...n)\n      mtx[blanks[i]] = cps[i]\n    end\n\n    for eqn in eqns\n      eqnstr = eqn.map{|i| mtx[i]}.join\n      ok = is_valid_eqn?(eqnstr)\n      break if ! ok\n    end\n\n    break if ok\n  end\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Ruby",
    "code": "## global variables\n\n$pos = 0\n$expcache = {}\n\n### subroutines\n\n## <exp> := <md> (('+'|'-') <md>)*\n## <md> := <num> (('*'|'/') <num>)*\n## <num> := '0' | ('1'-'9')('0'-'9')*\n\ndef parse_num(exp)\n  #puts \"parse_num: #{exp}, #{$pos}\"\n\n  str = ''\n  ch = exp[$pos]\n  while ! ch.nil? && ch >= '0' && ch <= '9'\n    str += ch\n    $pos += 1\n    ch = exp[$pos]\n  end\n\n  return nil if str == '' || (str.length >= 2 && str[0] == '0')\n  str.to_i\nend\n\ndef parse_md(exp)\n  #puts \"parse_md: #{exp}, #{$pos}\"\n\n  val = parse_num(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '*' || ch == '/')\n    $pos += 1\n    val0 = parse_num(exp)\n    return nil if val0.nil?\n\n    if ch == '*'\n      val *= val0\n    else\n      return nil if val0 == 0 || val % val0 != 0\n      val /= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef parse_exp(exp)\n  #puts \"parse_exp: #{exp}, #{$pos}\"\n\n  val = parse_md(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '+' || ch == '-')\n    #puts \"parse_exp: #{exp}[#{$pos}] = #{ch}\"\n\n    $pos += 1\n    val0 = parse_md(exp)\n    return nil if val0.nil?\n\n    if ch == '+'\n      val += val0\n    else\n      val -= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef eval_exp(exp)\n  return $expcache[exp] if ! $expcache[exp].nil?\n\n  $pos = 0\n  val = parse_exp(exp)\n\n  $expcache[exp] = ($pos == exp.length) ? val : nil\n  #($pos == exp.length) ? val : nil\nend\n\ndef is_valid_eqn?(eqn)\n  return $expcache[eqn] if ! $expcache[eqn].nil?\n\n  exps = eqn.split('=')\n  return ($expcache[eqn] = false) if exps.length != 2\n\n  val0 = eval_exp(exps[0])\n  return ($expcache[eqn] = false) if val0.nil?\n  val1 = eval_exp(exps[1])\n  return ($expcache[eqn] = false) if val1.nil?\n\n  $expcache[eqn] = (val0 == val1)\nend\n\ndef check_rec(k)\n  return true if k >= $n\n\n  for d in (0...$n)\n    next if $used[d]\n\n    $used[d] = true\n    $mtx[$blanks[k]] = $cands[d]\n    ok = true\n\n    for i in $eqnbls[k]\n      eqnstr = $eqns[i].map{|j| $mtx[j]}.join\n      ok = is_valid_eqn?(eqnstr)\n      break if ! ok\n    end\n\n    if ok\n      ok = check_rec(k + 1)\n    end\n\n    $mtx[$blanks[k]] = '.'\n    $used[d] = false\n\n    return true if ok\n  end\n\n  false\nend\n\n### main\n\nloop do\n  $h, $w = gets.split.map(&:to_i)\n  break if $h == 0 && $w == 0\n\n  hw = $h * $w\n\n  $mtx = []\n\n  $h.times do\n    $mtx += gets.strip.split('')\n  end\n  #p $mtx\n\n  $eqns = []\n\n  for y in (0...$h)\n    x = 0\n    while x < $w\n      x0 = x\n      eqn = []\n      while x0 < $w && $mtx[y * $w + x0] != '#'\n        eqn << y * $w + x0\n        x0 += 1\n      end\n      $eqns << eqn if eqn.length > 1\n      x = x0 + 1\n    end\n  end\n\n  for x in (0...$w)\n    y = 0\n    while y < $h\n      y0 = y\n      eqn = []\n      while y0 < $h && $mtx[y0 * $w + x] != '#'\n        eqn << y0 * $w + x\n        y0 += 1\n      end\n      $eqns << eqn if eqn.length > 1\n      y = y0 + 1\n    end\n  end\n  #$eqns.each{|e| p e.map{|i| $mtx[i]}.join}\n\n  $blanks = []\n  $mtx.each_with_index{|c, i|  $blanks << i if c == '.'}\n  #p $blanks\n\n  $n = gets.to_i\n  $cands = gets.split\n  #p cands\n\n  $eqnbls = $n.times.map{[]}\n  for i in (0...$eqns.length)\n    blpos = $eqns[i].select{|pos| $mtx[pos] == '.'}.max\n    if ! blpos.nil?\n      $eqnbls[$blanks.index(blpos)] << i\n    end\n  end\n  #p $eqnbls\n\n  $used = $n.times.map{false}\n  $expcache = {}\n\n  ok = check_rec(0)\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Ruby",
    "code": "### global variables\n\n$pos = 0\n\n### subroutines\n\n## <exp> := <md> (('+'|'-') <md>)*\n## <md> := <num> (('*'|'/') <num>)*\n## <num> := '0' | ('1'-'9')('0'-'9')*\n\ndef parse_num(exp)\n  #puts \"parse_num: #{exp}, #{$pos}\"\n\n  str = ''\n  ch = exp[$pos]\n  while ! ch.nil? && ch >= '0' && ch <= '9'\n    str += ch\n    $pos += 1\n    ch = exp[$pos]\n  end\n\n  return nil if str == '' || (str.length >= 2 && str[0] == '0')\n  str.to_i\nend\n\ndef parse_md(exp)\n  #puts \"parse_md: #{exp}, #{$pos}\"\n\n  val = parse_num(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '*' || ch == '/')\n    $pos += 1\n    val0 = parse_num(exp)\n    return nil if val0.nil?\n\n    if ch == '*'\n      val *= val0\n    else\n      return nil if val0 == 0 || val % val0 != 0\n      val /= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef parse_exp(exp)\n  #puts \"parse_exp: #{exp}, #{$pos}\"\n\n  val = parse_md(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '+' || ch == '-')\n    #puts \"parse_exp: #{exp}[#{$pos}] = #{ch}\"\n\n    $pos += 1\n    val0 = parse_md(exp)\n    return nil if val0.nil?\n\n    if ch == '+'\n      val += val0\n    else\n      val -= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef eval_exp(exp)\n  $pos = 0\n  val = parse_exp(exp)\n\n  ($pos == exp.length) ? val : nil\nend\n\ndef is_valid_eqn?(eqn)\n  exps = eqn.split('=')\n  return false if exps.length != 2\n\n  val0 = eval_exp(exps[0])\n  val1 = eval_exp(exps[1])\n\n  ! val0.nil? && ! val1.nil? && val0 == val1\nend\n\n### main\n\nloop do\n  h, w = gets.split.map(&:to_i)\n  break if h == 0 && w == 0\n\n  mtx = []\n\n  h.times do\n    mtx += gets.strip.split('')\n  end\n  #p mtx\n\n  eqns = []\n\n  for y in (0...h)\n    x = 0\n    while x < w\n      x0 = x\n      eqn = []\n      while x0 < w && mtx[y * w + x0] != '#'\n        eqn << y * w + x0\n        x0 += 1\n      end\n      eqns << eqn if eqn.length > 1\n      x = x0 + 1\n    end\n  end\n\n  for x in (0...w)\n    y = 0\n    while y < h\n      y0 = y\n      eqn = []\n      while y0 < h && mtx[y0 * w + x] != '#'\n        eqn << y0 * w + x\n        y0 += 1\n      end\n      eqns << eqn if eqn.length > 1\n      y = y0 + 1\n    end\n  end\n  #eqns.each{|e| p e.map{|i| mtx[i]}.join}\n\n  blanks = []\n  mtx.each_with_index{|c, i|  blanks << i if c == '.'}\n  #p blanks\n\n  n = gets.to_i\n  cands = gets.split\n  #p cands\n\n  ok = true\n\n  cands.permutation(n) do |cps|\n    for i in (0...n)\n      mtx[blanks[i]] = cps[i]\n    end\n\n    for eqn in eqns\n      eqnstr = eqn.map{|i| mtx[i]}.join\n      ok = is_valid_eqn?(eqnstr)\n      break if ! ok\n    end\n\n    break if ok\n  end\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Ruby",
    "code": "### global variables\n\n$pos = 0\n$expcache = {}\n\n### subroutines\n\n## <exp> := <md> (('+'|'-') <md>)*\n## <md> := <num> (('*'|'/') <num>)*\n## <num> := '0' | ('1'-'9')('0'-'9')*\n\ndef parse_num(exp)\n  #puts \"parse_num: #{exp}, #{$pos}\"\n\n  str = ''\n  ch = exp[$pos]\n  while ! ch.nil? && ch >= '0' && ch <= '9'\n    str += ch\n    $pos += 1\n    ch = exp[$pos]\n  end\n\n  return nil if str == '' || (str.length >= 2 && str[0] == '0')\n  str.to_i\nend\n\ndef parse_md(exp)\n  #puts \"parse_md: #{exp}, #{$pos}\"\n\n  val = parse_num(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '*' || ch == '/')\n    $pos += 1\n    val0 = parse_num(exp)\n    return nil if val0.nil?\n\n    if ch == '*'\n      val *= val0\n    else\n      return nil if val0 == 0 || val % val0 != 0\n      val /= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef parse_exp(exp)\n  #puts \"parse_exp: #{exp}, #{$pos}\"\n\n  val = parse_md(exp)\n  return nil if val.nil?\n\n  ch = exp[$pos]\n  while ! ch.nil? && (ch == '+' || ch == '-')\n    #puts \"parse_exp: #{exp}[#{$pos}] = #{ch}\"\n\n    $pos += 1\n    val0 = parse_md(exp)\n    return nil if val0.nil?\n\n    if ch == '+'\n      val += val0\n    else\n      val -= val0\n    end\n\n    ch = exp[$pos]\n  end\n\n  val\nend\n\ndef eval_exp(exp)\n  #return $expcache[exp] if ! $expcache[exp].nil?\n\n  $pos = 0\n  val = parse_exp(exp)\n\n  #$expcache[exp] = ($pos == exp.length) ? val : nil\n  ($pos == exp.length) ? val : nil\nend\n\ndef is_valid_eqn?(eqn)\n  exps = eqn.split('=')\n  return false if exps.length != 2\n\n  val0 = eval_exp(exps[0])\n  val1 = eval_exp(exps[1])\n\n  ! val0.nil? && ! val1.nil? && val0 == val1\nend\n\ndef check_rec(k)\n  return true if k >= $n\n\n  for d in (0...$n)\n    next if $used[d]\n\n    $used[d] = true\n    $mtx[$blanks[k]] = $cands[d]\n    ok = true\n\n    for i in $eqnbls[k]\n      eqnstr = $eqns[i].map{|j| $mtx[j]}.join\n      ok = is_valid_eqn?(eqnstr)\n      break if ! ok\n    end\n\n    if ok\n      ok = check_rec(k + 1)\n    end\n\n    $mtx[$blanks[k]] = '.'\n    $used[d] = false\n\n    return true if ok\n  end    \n\n  false\nend\n\n### main\n\nloop do\n  $h, $w = gets.split.map(&:to_i)\n  break if $h == 0 && $w == 0\n\n  hw = $h * $w\n\n  $mtx = []\n\n  $h.times do\n    $mtx += gets.strip.split('')\n  end\n  #p $mtx\n\n  $eqns = []\n\n  for y in (0...$h)\n    x = 0\n    while x < $w\n      x0 = x\n      eqn = []\n      while x0 < $w && $mtx[y * $w + x0] != '#'\n        eqn << y * $w + x0\n        x0 += 1\n      end\n      $eqns << eqn if eqn.length > 1\n      x = x0 + 1\n    end\n  end\n\n  for x in (0...$w)\n    y = 0\n    while y < $h\n      y0 = y\n      eqn = []\n      while y0 < $h && $mtx[y0 * $w + x] != '#'\n        eqn << y0 * $w + x\n        y0 += 1\n      end\n      $eqns << eqn if eqn.length > 1\n      y = y0 + 1\n    end\n  end\n  #$eqns.each{|e| p e.map{|i| $mtx[i]}.join}\n\n  $blanks = []\n  $mtx.each_with_index{|c, i|  $blanks << i if c == '.'}\n  #p $blanks\n\n  $n = gets.to_i\n  $cands = gets.split\n  #p cands\n\n  $eqnbls = $n.times.map{[]}\n  for i in (0...$eqns.length)\n    blpos = $eqns[i].select{|pos| $mtx[pos] == '.'}.max\n    if ! blpos.nil?\n      $eqnbls[$blanks.index(blpos)] << i\n    end\n  end\n  #p $eqnbls\n\n  $used = $n.times.map{false}\n\n  ok = check_rec(0)\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Python",
    "code": "import itertools\ndef myeval(st):\n    if(not (str(st[0]).isdigit())):\n        throw()\n    ok=True\n    for i in range(len(st)-1):\n        if((not(str(st[0]).isdigit()))and (not (str(st[i+1]).isdigit()))):\n            ok=False\n    if ok:\n        return eval(st)\n    else:\n        throw()\n\n\n    \ndef formula(st):\n    if(st==\"\"):return True\n    if(len(st)==1):return True\n    sts=st.split(\"=\")\n    if len(sts)==2:\n        try:\n            a=myeval(sts[0])\n            b=myeval(sts[1])\n            return a==b\n        except:\n            return False\n    else :\n        return False\n\ndef check(field,H,W):\n    for y in range(H):\n        row=\"\"\n        for x in range(W):\n            row+=str(field[y][x])\n        sts=row.split(\"#\")\n        for st in sts:\n            if (not formula(st)):\n                return False\n            else:\n                a=2\n\n    for i in range(W):\n        col=\"\"\n        for y in range(H):\n            col+=str(field[y][x])\n        sts=col.split(\"#\")\n        for st in sts:\n            if (not formula(st)):return False\n    return True\n\n\nwhile True:\n\n    H,W=map(int,input().split())\n    if ( H==0):\n        break\n    field=[]\n    for i in range(H):\n        st=input()\n        aa=[]\n        for x in range(W):\n            aa.append(st[x])\n\n        field.append(aa)\n    N=int(input())\n    nums=list(input().split())\n    unknowns=[]\n    for y in range(H):\n        for x in range(W):\n            if(field[y][x]=='.'):\n                aa=[x,y]\n                unknowns.append([x,y])\n    ok=False\n    for x in itertools.permutations(nums):\n        nowfield=field[:]\n        for i in range(N):\n            nowfield[unknowns[i][1]][unknowns[i][0]]=x[i]\n        if check(nowfield,H,W):\n            ok=True\n    if ok:\n        print(\"Yes\")\n    else:\n        print(\"No\")"
  }
]