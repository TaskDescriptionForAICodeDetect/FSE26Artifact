[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-6;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\n\nstruct circle{\n    point o;\n    long double r;\n    circle(){}\n    circle(const point o,const long double r):o(o),r(r){}\n};\n\n//2??????????????????\nint icc(const circle &c, const circle &d) {\n    /*\n      1 : intersect\n      0 : distinct\n      -1: c < d\n      -2: c > d\n\n      intersect or contain : true\n      distinct             : false\n    */\n    long double od = abs((c.o-d.o));\n    return c.r+d.r<od+eps ? 0 : od+c.r<d.r+eps ? -1 : od+d.r<c.r+eps ? -2 : 1;\n}\n\n\n//?????¨??´??????????????????\nint icl(const circle &c, const line &l) {\n    /*\n      number of crosspoint\n    */\n    long double d = norm(projection(l,c.o)-c.o)-c.r*c.r;\n    return d>eps ? 0 : std::abs(d)<eps ? 1 : 2;\n}\n\n\n//?????¨?????????????????????\nint ics(const circle &c, const line &s) {\n    /*\n      0 : distinct\n      1 : intersect 1 point\n      2 : s is in c\n    */\n    if (!icl(c, s)) return 0;\n    long double da = abs(s.first - c.o);\n    long double db = abs(s.second - c.o);\n    if ((da < c.r-eps) and (db < c.r-eps)) return 0;\n    if ((da < c.r-eps) xor (db < c.r-eps)) return 1;\n    return ccw(s.first, s.second, projection(s,c.o)) ? 0 : 2;\n}\n\n//?????¨????????????????±???????\npair<point,point> ccc(const circle &c1, const circle &c2) {\n    if(!icc(c1,c2)) return pair<point,point>(c1.o,c2.o);\n    long double w = abs(c2.o-c1.o), th = arg(c2.o-c1.o);\n    long double dth = acosl((c1.r*c1.r+w*w-c2.r*c2.r)/(2.*c1.r*w));\n    return pair<point,point>(c1.o+polar(c1.r,th-dth),c1.o+polar(c1.r,th+dth));\n}\n\n//????????´????????????\npair<point,point> ccl(const circle &c, const line &l) {\n    point h = projection(l,c.o), p = sqrtl(c.r*c.r-norm(h-c.o))*(l.second-l.first)/abs(l.second-l.first);\n    return pair<point,point>(h-p,h+p);\n}\n\n\nvoid solve(int n){\n    vector<circle> cs;\n    rep(i,0,n){\n        long double x,y,r;\n        cin >> x >> y >> r;\n        cs.push_back(circle(point(x,y),r));\n    }\n    vector<point> ps;\n    vector<int> idx;\n    vector<line> ls;\n    ps.push_back(cs[0].o);\n    idx.push_back(0);\n    rep(i,1,n){\n        auto tmp=ccc(cs[i],cs[i-1]);\n        ps.push_back(tmp.first);\n        ps.push_back(tmp.second);\n        idx.push_back(i-1);\n        idx.push_back(i-1);\n        ls.push_back(line(ps[i*2-1],ps[i*2]));\n    }\n    ps.push_back(cs.back().o);\n    idx.push_back(n-1);\n\n    long double dist[200][200];\n    fill_n((long double*)dist,200*200,infll);\n    rep(i,0,2*n) dist[i][i]=0;\n    rep(i,0,2*n) rep(j,i+1,2*n) dist[i][j]=dist[j][i]=abs(ps[i]-ps[j]);\n    rep(i,0,2*n) rep(j,i+1,2*n){\n        if(idx[j]-idx[i]<=1) continue;\n        line s=line(ps[i],ps[j]);\n        bool f=true;\n        rep(k,idx[i]+(i==0?0:1),idx[j]){\n            if(intersectSS(s,ls[k])) continue;\n            f=false;\n            break;\n        }\n        if(!f) dist[i][j]=dist[j][i]=infll;\n    }\n\n    rep(k,0,2*n) rep(i,0,2*n) rep(j,0,2*n) dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    cout << dist[0][2*n-1] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n// #define EPS 1e-8\n// static const int INF=1<<24;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define M_PI  asin(0.5)*6\n\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P,i) P[(i)%P.size()]\n#define Next(P,i) P[(i+1)%P.size()]\n#define Prev(P,i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n  bool operator<(const P a,const P b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\ndouble cross(const P a,const P b){\n  return (conj(a)*b).imag();\n}\ndouble dot(const P a,const P b){\n  return (conj(a)*b).real();\n}\n// TODO make graph (20)\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)>0)    return +1;//counter clockwise\n  if(cross(b,c)<0)    return -1;//clockwise\n  if(dot(b,c)<0)      return +2;// c--a--b\n  if(norm(b)<norm(c)) return -2;// a--b--c\n                      return  0;// a--c--b(or b==c)\n}\n\nstruct L : public vector<P>{\n  L(){}\n  L(const P a,const P b){\n    push_back(a),push_back(b);\n  }\n};\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C{\n  P p;double r;\n  C(){}\n  C(const P p,double r): p(p),r(r){}\n};\n\n\n\n//直線と点の関係\n//点から線分に垂線を下ろした点\nP projection(L a,P p){\n  double t = dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0] + t*(a[0]-a[1]);\n}\n//線対称の点\nP reflection(L a,P p){\n  return p + 2.0 * (projection(a,p)-p);\n}\n\n\n\n\n//交差判定\n//TODO CP(内包) CL CS (0)\nbool isCrossLL(L a,L b){\n  return \n    abs(cross(a[1]-a[0],b[1]-b[0])) > EPS\n    || abs(cross(a[1]-a[0],b[0]-a[0])) < EPS ;\n}\nbool isCrossLS(L a,S b){\n  return \n    cross(a[1]-a[0],b[0]-a[0]) \n    * cross(a[1]-a[0],b[1]-a[0]) < EPS;\n}\nbool isCrossLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool isCrossSS(S a,S b){\n  return\n    ccw(a[0],a[1],b[0])\n    * ccw(a[0],a[1],b[1]) <= 0\n    &&\n    ccw(b[0],b[1],a[0])\n    * ccw(b[0],b[1],a[1]) <= 0;\n}\nbool isCrossSP(S a,P p){\n  return abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\n\n// 距離 CP CL CS は(distXP(x,c.p)-c.r)\ndouble distPP(P a,P b){\n  return abs(a-b);\n}\ndouble distLP(L a,P p){\n  return abs(p-projection(a,p));\n}\ndouble distLL(L a,L b){\n  return isCrossLL(a,b) ? 0 : distLP(a,b[0]);\n}\ndouble distLS(L a,S b){\n  return isCrossLS(a,b) ? 0 : min(distLP(a,b[0]),distLP(a,b[1]));\n}\ndouble distSP(S a,P p){\n  const P r = projection(a,p);\n  return isCrossSP(a,r) ? abs(p-r) : min(abs(a[0]-p),abs(a[1]-p));\n}\ndouble distSS(S a,S b){\n  return isCrossSS(a,b)?0:\n    min(\n      min(distSP(a,b[0]),distSP(a,b[1])),\n      min(distSP(b,a[0]),distSP(b,a[1]))\n    );\n}\n\n//円の交差判定\nbool isCrossCP(C a,P p){\n  return abs(a.p-p)-a.r<=EPS;\n}\nbool isCrossCL(C a,L l){\n  return distLP(l,a.p)-a.r<EPS;\n}\ndouble distSP_MAX(S a,P p){\n  return max(abs(a[0]-p),abs(a[1]-p));\n}\nbool isCrossCS(C a,S s){\n  return distSP(s,a.p)-a.r<-EPS&&distSP_MAX(s,a.p)-a.r>+EPS;\n}\nbool isCrossCC(C a,C b){//接してる時は交差\n  return abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\n\n//交差点\n//先に交差判定をすること\nP crossP_LL(L a,L b){\n  double A = cross(a[1]-a[0],b[1]-b[0]);\n  double B = cross(a[1]-a[0],a[1]-b[0]);\n  if(abs(A)<EPS && abs(B)<EPS)return b[0];\n  if(abs(A)<EPS)assert(false);\n  return b[0]+B/A*(b[1]-b[0]);\n}\nvector<P> crossP_CL(C c,L l){\n  P tmp = projection(l,c.p);\n  P e = (l[0]-l[1])/abs(l[0]-l[1]);\n  double h = abs(c.p-tmp)*abs(c.p-tmp);\n  double t = sqrt(c.r*c.r - h*h);\n  if(t<EPS)return {tmp};\n  return {tmp + e*t,tmp - e*t};\n}\nvector<P> crossP_CC(C a,C b){\n  P A = conj(b.p-a.p);\n  P B = (b.r*b.r - a.r*a.r - (b.p-a.p)*conj(b.p-a.p));\n  P C = a.r*a.r*(b.p-a.p);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+a.p;\n  P z2 = (-B-sqrt(D))/(2.0*A)+a.p;\n  return {z1,z2};\n}\n\n\n\n//三点->円\nP PPPtoC(P a,P b,P c){\n  P x = 1.0/(conj(b-a));\n  P y = 1.0/(conj(c-a));\n  return (y-x)/( conj(x)*y - x*conj(y) ) + a;\n}\n\n//凸包\nG convex_hull(G ps){\n  int n = ps.size();\n  int k = 0;\n  G ch(2*n);\n  for(int i = 0;i<n;(ch[k++]=ps[i++])){\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  for(int i = n-2,t=k+1 ; i>=0 ; ch[k++]=ps[i--]){\n    while(k>=t && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch;\n} \n\n\n//凸性判定\nbool isConvex(G g){\n  for(int i=0; i<g.size();i++){\n    if(ccw(Prev(g,i),Curr(g,i),Next(g,i))>0)return false;\n  }\n}\n\n\n\n//接線\n//TODO check\nvector<L> TLine_CP(C c,P p){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P n2 = reflection(L(p,c.p),n1);\n  return {L(p,n1),L(p,n2)};\n}\n\n// TLine CC\nvector<L> TLine_CPr(C c,P p,double r){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P e1 = (n1-c.p)/abs(n1-c.p) * r;\n  P n2 = reflection(L(p,c.p),n1);\n  P e2 = (n2-c.p)/abs(n2-c.p) * r;\n  return {L(p+e1,n1+e1),L(p+e2,n2+e2)};\n}\nvector<L> TLine_CC(C a,C b){\n  //接してる時がヤバイ\n  vector<L> res;\n  if(!isCrossCC(a,b)&&(abs(a.r)>EPS)&&(abs(b.r>EPS))){\n    P tmp = (a.p-b.p)*(b.r)/(a.r+b.r) + b.p;\n    auto t1 = TLine_CP(a,tmp);\n    auto t2 = TLine_CP(b,tmp);\n    res.push_back(L(t1[0][1],t2[0][1]));\n    res.push_back(L(t1[1][1],t2[1][1]));\n  }\n  if(abs(a.r-b.r)<EPS){\n    const auto r = a.r;\n    P e = (a.p-b.p)/abs(a.p-b.p) * exp(P(.0,90.0/180.0*M_PI));\n    res.push_back(L(a.p+(e*r),b.p+(e*r)));\n    if(abs(r)>=EPS)res.push_back(L(a.p-(e*r),b.p-(e*r)));\n  }else{\n    if(a.r<b.r)swap(a,b);\n    auto t3 = TLine_CPr(C(a.p,a.r-b.r),b.p,b.r);\n    for(auto i:t3){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\n//原点を起点とした回転\nP rotate(P a,double r){\n  return a*exp(P(0.0,r*M_PI/180.0));\n}\n\ndouble dp[110][2];\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C> cir(n);\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b>>cir[i].r;\n      cir[i].p=P(a,b);\n      // cout<<cir[i].p.X<<\" \"<<cir[i].p.Y<<\" \"<<cir[i].r<<endl;\n\t\t}\n    VV(P) po;\n    po.PB(vector<P>(1,cir[0].p));\n    rep(i,n-1){\n      po.PB(crossP_CC(cir[i],cir[i+1]));\n    }\n    po.PB(vector<P>(1,cir[n-1].p));\n    rep(i,110){\n      rep(j,2){\n        dp[i][j]=INF;\n      }\n    }\n    // printf(\"%.6lf %.6lf\\n\",po[1][0].X,po[1][0].Y);\n    // printf(\"%.6lf %.6lf\\n\",po[1][1].X,po[1][1].Y);\n    dp[0][0]=dp[0][1]=0;\n    reep(i,1,n){\n      if(i==1){\n        dp[1][0]=distPP(cir[0].p,po[1][0]);\n        dp[1][1]=distPP(cir[0].p,po[1][1]);\n      }\n      // dp[i][0]=mkp(distPP(cir[0].p,po[0][0]),0);\n      else{\n        rep(j,2){\n          for(int k=i-1;k>=0;k--){\n            rep(g,po[k].size()){\n              S t1=S(po[i][j],po[k][g]);\n              bool f=true;\n              reep(h,k+1,i){\n                f&=isCrossSS(t1,S(po[h][0],po[h][1]));\n              }\n              if(f){\n                if(dp[i][j]>distPP(po[i][j],po[k][g])+dp[k][g]){\n                  dp[i][j]=distPP(po[i][j],po[k][g])+dp[k][g];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    double ans=INF;\n    rep(i,n){\n      rep(j,po[i].size()){\n        // cout<<i<<\" \"<<j<<\" \";\n        // printf(\"%.6lf\\n\",dp[i][j]);\n        S t1=S(po[i][j],po[n][0]);\n        bool f=true;\n        reep(k,i+1,n){\n          f&=isCrossSS(t1,S(po[k][0],po[k][1]));\n        }\n        if(f){\n          ans=min(ans,dp[i][j]+distPP(po[i][j],po[n][0]));\n        }\n      }\n    }\n    printf(\"%.6lf\\n\",ans);\n    // rep(i,n){\n      // cout<<dp[i][0].se<<\" \"<<dp[i][1].se<<endl;\n    // }\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n\nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n\n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n\n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n\n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.a - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Segment& a,const Segment& b){\n  return abs( cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Segment& a,const Segment& b){\n    return dot( a.a - a.b, b.a - b.b) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n};\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\nstruct node{\n  double cost;\n  P pos;\n  int nowy, nowx;\n  bool operator < (const node &left) const {\n    return cost > left.cost;\n  }\n};\ntypedef pair< int, int > POS;\ntypedef pair< double, P > PS;\n\nint main(){\n  int n;\n  C prev, now;\n  S seg[101];\n  bool used[101][101];\n\n  while(scanf(\"%d\", &n), n){\n\n    cin >> prev.p >> prev.r;\n    seg[0] = S( prev.p, prev.p);\n    for(int i = 1; i < n; i++){\n      scanf(\"%lf %lf %lf\", &now.p.x, &now.p.y, &now.r);\n      Geometory::PointPoint pp = geo.Crosspoint( prev, now);\n      seg[i] = S(pp.first,pp.second);\n      prev = now;\n    }\n    seg[n] = S( prev.p, prev.p);\n\n    priority_queue< node > que;\n    que.push((node){ 0, seg[0].a, 0, 0});\n    memset( used, false, sizeof used);\n    double ret;\n    while(!que.empty()){\n      node p = que.top(); que.pop();\n      if(p.nowy == n){ ret = p.cost; break; }\n      if(used[p.nowy][p.nowx]++) continue;\n      for(int i = p.nowy + 1; i <= n; i++){\n        S s1 = S( p.pos, seg[i].a), s2 = S( p.pos, seg[i].b);\n        bool flag1 = true, flag2 = true;\n        for(int j = i - 1; j > p.nowy; j--){\n          if(!geo.Intersect( s1, seg[j])){\n            flag1 = false;\n            break;\n          }\n        }\n        for(int j = i - 1; j > p.nowy; j--){\n          if(!geo.Intersect( s2, seg[j])){\n            flag2 = false;\n            break;\n          }\n        }\n        if(flag1) que.push((node){ p.cost + (s1.a - s1.b).abs(), s1.b, i, 0});\n        if(flag2) que.push((node){ p.cost + (s2.a - s2.b).abs(), s2.b, i, 1});\n      }\n    }\n    printf(\"%.7lf\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n\ntypedef long double ld;\nconst ld PI = 3.141592653589793238462643383279;\n\nstruct po{\n\tld x;\n\tld y;\n\tpo(ld a){ x = a; y = 0; }\n\tpo(ld a,ld b){ x = a; y = b; }\n\tpo(){}\n\tinline ld operator()(const po& rhs) const {\n\t\treturn x*rhs.x+y*rhs.y;\n\t}\n\tinline ld norm() {\n\t\treturn sqrt((*this)(*this));\n\t}\n\tinline po& operator+=(const po& rhs){\n\t\tx += rhs.x;\n\t\ty += rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator-=(const po& rhs){\n\t\tx -= rhs.x;\n\t\ty -= rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator*=(const po& rhs){\n\t\tld x_ = x*rhs.x-y*rhs.y;\n\t\ty = x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\treturn *this;\n\t}\n\tinline po& operator/=(const po& rhs){\n\t\tld x_ = x*rhs.x+y*rhs.y;\n\t\ty = -x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\tld nor = rhs(rhs);\n\t\tx /= nor;\n\t\ty /= nor;\n\t\treturn *this;\n\t}\n\tinline void in(){\n\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t}\n};\ninline po operator+(const po& a, const po& b){ return po(a) += b; }\ninline po operator-(const po& a, const po& b){ return po(a) -= b; }\ninline po operator*(const po& a, const po& b){ return po(a) *= b; }\ninline po operator/(const po& a, const po& b){ return po(a) /= b; }\n\ninline po similar(const po& a,const po& b,const po& c,const po& p,const po& q){\n\treturn p+(q-p)*(c-a)/(b-a);\n}\n\ntypedef pair<po,po> se;\n#define fr first\n#define sc second\n\nstruct li{\n\tld a;\n\tld b;\n\tld c;\n\tli(po p,po q){\n\t\ta = q.y-p.y;\n\t\tb = p.x-q.x;\n\t\tc = p.y*q.x-p.x*q.y;\n\t}\n\t/*explicit li(se s){\n\t\ta = s.sc.y-s.fr.y;\n\t\tb = s.fr.x-s.sc.x;\n\t\tc = s.fr.y*s.sc.x-s.fr.x*s.sc.y;\n\t\tli(s.fr,s.sc);\n\t}*/\n\tli(){}\n\tinline ld operator()(const po& p) const {\n\t\treturn a*p.x+b*p.y+c;\n\t}\n};\n\nvoid intersect(const li &l,const li &m,po* &ret){\n\tif(abs(l.a*m.b-m.a*l.b) <= 1e-18){\n\t\tret = nullptr;\n\t\treturn;\n\t}\n\tret = new po;\n\tret->x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret->y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n}\ninline bool on(const po &p,const se &s){\n\treturn (s.fr-p)(s.sc-p) <= 1e-9;\n}\nvoid intersect(const se &s,const se &t,po* &ret){\n\tli l = li(s.fr,s.sc);\n\tli m = li(t.fr,t.sc);\n\tpo *p;\n\tintersect(l,m,p);\n\tif(p == nullptr || (on(*p,s)&&on(*p,t)))ret = p;\n\telse{\n\t\tdelete p;\n\t\tret = nullptr;\n\t}\n}\ninline ld dist(const po &p,const po &q){\n\treturn sqrt((p-q)(p-q));\n}\ninline li perpen(const po &p,const li &l){\n\tli ret;\n\tret.a = l.b;\n\tret.b = -l.a;\n\tret.c = l.a*p.y-l.b*p.x;\n\treturn ret;\n}\ninline po perpen_leg(const po &p,const li &l){\n\tpo ret;\n\tli m = perpen(p,l);\n\tret.x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret.y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n\treturn ret;\n}\ninline ld dist(const po &p,const se &s){\n\tpo h = perpen_leg(p,li(s.fr,s.sc));\n\tif(on(h,s))return dist(p,h);\n\telse return min( dist(p,s.fr) , dist(p,s.sc) );\n}\ninline ld dist(const se &s,const se &t){\n\tpo *p;\n\tintersect(s,t,p);\n\tif(p != nullptr){\n\t\tdelete p;\n\t\treturn 0.0;\n\t}\n\tld ret = min( dist(s.fr,t) , dist(s.sc,t) );\n\tret = min( ret , min( dist(t.fr,s) , dist(t.sc,s) ) );\n\treturn ret;\n}\ninline ld dist(const po &p, const li &l){\n\treturn abs(l(p))/sqrt(l.a*l.a+l.b*l.b);\n}\n\nstruct ci{\n\tpo c;\n\tld r;\n\tinline bool internal(const po &p){\n\t\treturn dist(p,c) <= r+1e-9;\n\t}\n};\n\nci circum(const po &p,const po &q,const po &r){\n\tci ret;\n\tli l = perpen((p+q)/2.0,li(p,q));\n\tli m = perpen((q+r)/2.0,li(q,r));\n\tpo* _c;\n\tintersect(l,m,_c);\n\tif(_c == nullptr){\n\t\tret.c = po(0.0,0.0);\n\t\tret.r = -1.0;\n\t\treturn ret;\n\t}\n\telse {\n\t\tret.c = *_c;\n\t\tret.r = dist(ret.c,p);\n\t\tdelete _c;\n\t\treturn ret;\n\t}\n}\n\n\nvoid intersect(const li &l, const ci &c, po* &ret1, po* &ret2){\n\tld d = dist(c.c,l);\n\tif(d > c.r+1e-9){\n\t\tret1 = nullptr;\n\t\tret2 = nullptr;\n\t\treturn;\n\t}\n\tpo h = perpen_leg(c.c,l);\n\tif(abs(d-c.r) <= 1e-9){\n\t\tret1 = new po;\n\t\t*ret1 = h;\n\t\tret2 = nullptr;\n\t\treturn;\n\t}\n\tpo v = po(l.b,-l.a);\n\tv /= sqrt(v(v));\n\tv *= sqrt(c.r*c.r-d*d);\n\tret1 = new po;\n\t*ret1 = h+v;\n\tret2 = new po;\n\t*ret2 = h-v;\n\treturn;\n}\nvoid intersect(const ci &c, const ci &d, po* &ret1, po* &ret2){\n\tli l;\n\tl.a = 2*(c.c.x-d.c.x);\n\tl.b = 2*(c.c.y-d.c.y);\n\tl.c = d.c(d.c)-d.r*d.r-(c.c(c.c)-c.r*c.r);\n\tintersect(l,c,ret1,ret2);\n}\nvoid tangent(const po &p, const ci &c,li* &ret1,li* &ret2){\n\tci d;\n\td.c = (p+c.c)/2.0;\n\td.r = dist(p,c.c)/2.0;\n\tpo *q,*r;\n\tintersect(c,d,q,r);\n\tret1 = ret2 = nullptr;\n\tif(q == nullptr)return;\n\tret1 = new li;\n\t*ret1 = li(p,*q);\n\tdelete q;\n\tif(r == nullptr)return;\n\tret2 = new li;\n\t*ret2 = li(p,*r);\n\tdelete r;\n}\nvoid cotan_in(const ci &c, const ci &d, li* &ret1, li* &ret2){\n\tpo p = similar(-c.r,d.r,0.0,c.c,d.c);\n\ttangent(p,c,ret1,ret2);\n}\nvoid cotan_out(const ci &c, const ci &d, li* &ret1, li* &ret2){\n\tif(abs(c.r-d.r) < 1e-9){\n\t\tret1 = new li;\n\t\tret2 = new li;\n\t\t*ret1 = *ret2 = li(c.c,d.c);\n\t\tret1->c += c.r*sqrt(ret1->a*ret1->a+ret1->b*ret1->b);\n\t\tret2->c -= c.r*sqrt(ret1->a*ret1->a+ret1->b*ret1->b);\n\t\treturn;\n\t}\n\tpo p = similar(c.r,d.r,0.0,c.c,d.c);\n\ttangent(p,c,ret1,ret2);\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\t\t//cerr << \"n=\" << n << endl;\n\t\tci c[102];\n\t\trep1(i,n){\n\t\t\tc[i].c.in();\n\t\t\tscanf(\"%Lf\",&c[i].r);\n\t\t}\n\t\tpo *p[204] = {nullptr};\n\t\tp[0] = &c[1].c;\n\t\tp[1] = &c[n].c;\n\t\tint k = 2;\n\t\trep1(i,n-1){\n\t\t\tintersect(c[i],c[i+1],p[k],p[k+1]);\n\t\t\twhile(p[k] != nullptr)k ++;\n\t\t}\n\t\t/*cerr << \"k=\" << k << endl;\n\t\trep(i,k){\n\t\t\tcerr << p[i]->x << \" \" << p[i]->y << endl;\n\t\t}*/\n\t\tld d[204][204];\n\t\trep(i,k)rep(j,k){\n\t\t\tif(i == j)d[i][j] = 0.0;\n\t\t\telse {\n\t\t\t\tvector<pair<ld,int>> vec;\n\t\t\t\trep1(t,n){\n\t\t\t\t\tpo *q[2];\n\t\t\t\t\t//if(i == 0 && j == 2)cerr << \"=====================\\n\" << c[t].c.x << \" \" << c[t].c.y << \" \" << c[t].r << endl;\n\t\t\t\t\tintersect(li(*p[i],*p[j]),c[t],q[0],q[1]);\n\t\t\t\t\tif(q[1] != nullptr){\n\t\t\t\t\t\tld s[2];\n\t\t\t\t\t\t/*if(i == 0 && j == 2){\n\t\t\t\t\t\t\tcerr << q[0]->x << \" \" << q[0]->y << endl;\n\t\t\t\t\t\t\tcerr << q[1]->x << \" \" << q[1]->y << endl;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\trep(a,2)s[a] = similar(*p[i],*p[j],*q[a],0.0,1.0).x;\n\t\t\t\t\t\tif(s[0] > s[1])swap(s[0],s[1]);\n\t\t\t\t\t\tvec.push_back(pair<ld,int>(s[0]-1e-9,1));\n\t\t\t\t\t\tvec.push_back(pair<ld,int>(s[1]+1e-9,-1));\n\t\t\t\t\t}\n\t\t\t\t\trep(a,2)if(q[a] != nullptr)delete q[a];\n\t\t\t\t}\n\t\t\t\tsort(vec.begin(),vec.end());\n\t\t\t\tint cnt = 0;\n\t\t\t\tbool ret = true;\n\t\t\t\trep(t,vec.size()){\n\t\t\t\t\t/*if(i == 0 && j == 2){\n\t\t\t\t\t\tcout << vec[t].fr << \" \" << vec[t].sc << endl;\n\t\t\t\t\t}*/\n\t\t\t\t\tcnt += vec[t].sc;\n\t\t\t\t\tif(cnt == 0 && (1e-9 <= vec[t].fr && vec[t].fr <= 1.0-1e-9)\n\t\t\t\t\t\t|| (cnt == 0 && t+1 < vec.size() && 1e-9 <= vec[t+1].fr && vec[t+1].fr <= 1.0-1e-9)){\n\t\t\t\t\t\t//\tcout << t << endl;\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ret)d[i][j] = dist(*p[i],*p[j]);\n\t\t\t\telse d[i][j] = 10000000000.0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2 ; i < k ; i ++){\n\t\t\t//cerr << \"DEBUG\" << endl;\n\t\t\t//cerr << p[i]->x << \" \" << p[i]->y << endl;\n\t\t\tdelete p[i];\n\t\t}\n\t\t/*rep(i,k)rep(j,k){\n\t\t\tcout << i << \" \" << j << \" \" << d[i][j] << endl;\n\t\t}*/\n\t\trep(t,k)rep(i,k)rep(j,k){\n\t\t\tif(d[i][j] > d[i][t]+d[t][j]){\n\t\t\t\td[i][j] = d[i][t]+d[t][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.12f\\n\",(double)d[0][1]);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<double,int>P;\ntypedef complex<double> C;\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nconst int MAX_N = 105;\n\nC v[MAX_N];\nint r[MAX_N];\nvector<edge> G[2*MAX_N];\nint n;\ndouble d[2*MAX_N];\n\nnamespace std {\n  bool operator < (const C& a, const C& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const C& a, const C& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const C& a, const C& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<C> {\n  L(const C &a, const C &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(C a, C b, C c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const C &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nL cross_line(C p1,int r1,C p2,int r2)\n{\n    double d = norm(p2-p1);\n    double t = r2*r2 - r1*r1 - d;\n    double aa = d,bb = t*(real(p2)-real(p1)),cc = t*t / 4.0 - (imag(p2) - imag(p1))*(imag(p2) - imag(p1))*r1*r1;\n    double x1 = (-bb + sqrt(bb*bb - 4*aa*cc))/(2*aa);\n    double x2 = (-bb - sqrt(bb*bb - 4*aa*cc))/(2*aa);\n    double y1,y2;\n    if(imag(p1) == imag(p2)){\n        y1 = sqrt(r1*r1 - x1*x1);\n        y2 = -y1;\n    }else{\n        y1 = (t+2*(real(p2)-real(p1))*x1)/(-2*(imag(p2)-imag(p1)));\n        y2 = (t+2*(real(p2)-real(p1))*x2)/(-2*(imag(p2)-imag(p1)));\n    }\n    L ln = L(C(x1+real(p1),y1+imag(p1)),C(x2+real(p1),y2+imag(p1)));\n    return ln;\n}\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0.0;\n\tque.push(P(0.0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tque.push(P(d[G[v][i].to],G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        rep(i,2*n){\n            G[i].clear();\n        }\n    \trep(i,n){\n            int bf1,bf2;\n    \t\tscanf(\"%d%d%d\",&bf1,&bf2,&r[i]);\n            v[i] = C(bf1,bf2);\n    \t}\n        vector<L> vec;\n        vector<L> sect;\n        rep(i,n-1){\n            vec.push_back(cross_line(v[i],r[i],v[i+1],r[i+1]));\n            cout << vec[i][0] << vec[i][1] << \"\\n\";\n        }\n        bool fl = false;\n        rep(k,n-1){\n            if(!intersectSS(L(v[0],v[n-1]),vec[k])){\n                fl =true;\n                break;\n            }\n        }\n        if(!fl){\n            G[0].push_back((edge){2*n-1,abs(v[n-1] - v[0])});\n        }\n        rep(j,n-1){\n            rep(id,2){\n                bool flag = false;\n                rep(k,j){\n                    if(!intersectSS(L(v[0],vec[j][id]),vec[k])){\n                        flag =true;\n                        break;\n                    }\n                }\n                if(!flag){\n                    G[0].push_back((edge){2*j+1+id,abs(vec[j][id] - v[0])});\n                }\n            }\n        }\n        rep(i,n-2){\n            for(int j=i+1;j<=n-2;j++){\n                rep(id,2){\n                    rep(id2,2){\n                        bool flag = false;\n                        for(int k = i+1;k < j;k++){\n                            if(!intersectSS(L(vec[i][id],vec[j][id2]),vec[k])){\n                                flag = true;\n                                break;\n                            }\n                        }\n                        if(!flag){\n                            G[2*i+1+id].push_back((edge){2*j+1+id2,abs(vec[j][id2] - vec[i][id])});\n                        }\n                    }\n                }\n            }\n        }\n        rep(j,n-1){\n            rep(id,2){\n                bool flag = false;\n                for(int k = j+1;k <= n-2;k++){\n                    if(!intersectSS(L(v[n-1],vec[j][id]),vec[k])){\n                        flag =true;\n                        break;\n                    }\n                }\n                if(!flag){\n                    G[2*j+1+id].push_back((edge){2*n-1,abs(vec[j][id] - v[n-1])});\n                }\n            }\n        }\n        rep(i,2*n-1){\n            cout << i << \" \";\n            rep(j,G[i].size()){\n                cout << G[i][j].cost << \" \";\n            }\n            cout << \"\\n\";\n        }\n        fill(d,d+n*2,INF);\n        dijkstra(0);\n        printf(\"%.6f\\n\",d[2*n-1]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "10\n802 0 10\n814 0 4\n820 1 4\n826 1 4\n832 3 5\n838 5 5\n845 7 3\n849 10 3\n853 14 4\n857 18 3\n3\n0 0 5\n8 0 5\n8 8 5\n3\n0 0 5\n7 3 6\n16 0 5\n9\n0 3 5\n8 0 8\n19 2 8\n23 14 6\n23 21 6\n23 28 6\n19 40 8\n8 42 8\n0 39 5\n11\n0 0 5\n8 0 5\n18 8 10\n8 16 5\n0 16 5\n0 24 5\n3 32 5\n10 32 5\n17 28 8\n27 25 3\n30 18 5\n0"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n\nusing ll = long long;\nusing P = complex<double>;\n\n#define eps 1e-6\n\nnamespace std{\n    template<class T> bool operator<(const complex<T> &a, const complex<T> &b) {\n        return abs(a.real() - b.real()) < eps ? a.imag() + eps < b.imag() : a.real() + eps < b.real();\n    }\n}\n\ndouble dot(P a, P b) {\n    return (a * conj(b)).real();\n}\n\ndouble cross(P a, P b) {\n    return (conj(a) * b).imag();\n}\n\nbool isContainedCP(P c, double r, P a) {\n    return abs(c - a) < r - eps;\n}\n\ndouble distanceLP(P a, P b, P c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\ndouble distanceSP(P a, P b, P c) {\n    if (dot(b-a, c-a) < eps) return abs(c- a);\n    if(dot(a-b, c-b) < eps) return abs(c - b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nbool isCrossCC(P c1, double r1, P c2, double r2) {\n    double dist = abs(c1 - c2);\n    return abs(r1 - r2) < dist - eps && dist + eps < r1 + r2;\n}\n\nbool isIntersectedCS(P c, double r, P a1, P a2) {\n    return (!isContainedCP(c, r, a1) || !isContainedCP(c, r, a2)) &&\n        distanceSP(a1, a2, c) < r - eps;\n}\n\nvector<P> getCrosspointCC(P c1, double r1, P c2, double r2) {\n    double dist = abs(c1 - c2);\n    double a = acos((r1 * r1 + dist * dist - r2*r2) / (2 * r1 * dist));\n    return {c1 + polar(r1, arg(c2 - c1) + a), c1 + polar(r1, arg(c2 - c1) - a)};\n}\n\nvector<P> getCrosspointCS(P c, double r, P a1, P a2) {\n    if(!isIntersectedCS(c, r, a1, a2)) return {};\n\n    P base1 = a2 - a1;\n    P proj = a1 + base1 * dot(c - a1, base1) / norm(base1);\n    P e = (a2 - a1) / abs(a2 - a1);\n    P base2 = sqrt(r * r - norm(proj - c));\n    return {proj - e*base2, proj + e*base2};\n}\n\nint n;\nint x[101], y[100], r[100];\nP p[101];\n\nbool isOK(int s, int t, P a, P b) {\n    vector<P> vec;\n\n    //cerr << a << \" <-> \" << b << endl;\n\n    P epsV = (b - a) / abs(b - a) * 10.0 * eps;\n    P a2 = a + epsV;\n    P b2 = b + epsV;\n\n\n    for(int i=0; i<n; i++) {\n        auto res = getCrosspointCS(p[i], r[i], a2, b2);\n        \n        for(auto q : res)\n            if(abs(abs(q-a) + abs(q - b) - abs(a-b)) < eps)\n                vec.push_back(q);\n    }\n\n   // cerr << \"***\" << endl;\n    \n    bool used[101] = {};\n  \n    for (auto item : vec) {\n        bool ok = false;\n        if (abs(a - item) < eps || abs(b - item) < eps) continue;\n        for (int i=0; i<n; i++) {\n          bool f = isContainedCP(p[i], r[i], item);\n          ok |= f;\n          used[i] |= f;\n        }\n        if (!ok) return false;\n    }\n\n    for(int i=s+1; i<t; i++){\n      if(!used[i]) return false;\n    }\n  \n    //cerr << \"OK\" << endl;\n\n    return true;\n}\n\nbool solve() {\n    vector<P> points;\n    vector<int> S;\n\n    cin >> n;\n\n    if (n == 0) return false;\n\n    for (int i=0; i<n; i++) {\n        cin >> x[i] >> y[i] >> r[i];\n        p[i] = P(x[i], y[i]);\n    }\n\n    points.push_back(p[0]);\n    S.push_back(0);\n\n    for (int i=0; i<n-1; i++) {\n        if (!isCrossCC(p[i], r[i], p[i+1], r[i+1])) continue;\n\n        auto res = getCrosspointCC(p[i], r[i], p[i+1], r[i+1]);\n\n        for (auto p : res) {\n            points.push_back(p);\n            S.push_back(i+1);\n            //cerr << p << endl;\n        }\n    }\n\n    points.push_back(p[n-1]);\n    S.push_back(n-1);\n\n\n    double dist[205][205];\n\n    for(int i=0; i<points.size(); i++)\n        for(int j=0; j<points.size(); j++)\n            dist[i][j] = 1e32 * (i != j);\n\n    for (int i=0; i<points.size(); i++) {\n        for(int j=i+1; j<points.size(); j++) {\n            if(isOK(S[i], S[j], points[i], points[j])) {\n                double tmp = abs(points[i] - points[j]);\n                dist[i][j] = dist[j][i] = tmp;\n                //cerr << points[i] << \" \" << points[j] << endl;\n                //cerr << i << \" \" << j << \" : \" << tmp << endl; \n            }\n        }\n    }\n\n    int m = points.size();\n\n    for(int k=0; k<m; k++) {\n        for(int i=0; i<m; i++) {\n            for(int j=0; j<m; j++) {\n                dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);\n            }\n        }\n    }\n\n    printf(\"%.10lf\\n\", dist[0][m-1]);\n\n    return true;\n}\n\nint main(){\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b,QF &&qf) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1,qf);\n\t}*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l,int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//end of lib\nP f(L a, int k) { return k ? a.b : a.a; }\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<C> c(n);\n\t\trep(i, n) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tc[i] = C{ P{ (double)x,(double)y },(double)r };\n\t\t}\n\t\tva<double, 2> dp(n + 1,{1e9,1e9});\n\t\tvector<L> s(n + 1);\n\t\trep1(i, n - 1) {\n\t\t\tauto x = is_cc(c[i - 1], c[i]);;\n\t\t\ts[i] = { x[0],x[1] };\n\t\t}\n\t\ts[0] = L{ c[0].p,c[0].p };\n\t\ts.back() = L{ c.back().p,c.back().p };\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\trep(i, n + 1)rep(j, i)rep(k,4) {\n\t\t\tbool fl = 1;\n\t\t\tL line{ f(s[j],k >> 1),f(s[i],k & 1) };\n\t\t\tfor (int l = j+1; l < i; l++) {\n\t\t\t\tif (!isis_ss(line, s[l])) {\n\t\t\t\t\tfl = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fl) {\n\t\t\t\tcmin(dp[i][k & 1],dp[j][k >> 1] + abs(line.a-line.b));\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << min(dp.back()[0], dp.back()[1]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "10\n802 0 10\n814 0 4\n820 1 4\n826 1 4\n832 3 5\n838 5 5\n845 7 3\n849 10 3\n853 14 4\n857 18 3\n3\n0 0 5\n8 0 5\n8 8 5\n3\n0 0 5\n7 3 6\n16 0 5\n9\n0 3 5\n8 0 8\n19 2 8\n23 14 6\n23 21 6\n23 28 6\n19 40 8\n8 42 8\n0 39 5\n11\n0 0 5\n8 0 5\n18 8 10\n8 16 5\n0 16 5\n0 24 5\n3 32 5\n10 32 5\n17 28 8\n27 25 3\n30 18 5\n0"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\nconst double EPS = 1e-7;\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\nostream& operator << (ostream &os , const vector<double> &v) { for(const double t : v) os << \"\\t\" << (t >= INF ? -1 : t); return os << endl; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\n\n\nusing Point = complex<double>;\n#define X(a) real(a)\n#define Y(a) imag(a)\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\nbool operator < (Point a, Point b) { return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag(); }\nbool operator > (Point a, Point b) { return !eq(a.real(), b.real()) ? a.real() > b.real() : a.imag() > b.imag(); }\nistream &operator >> (istream& is, Point& p) { double a, b; is >> a >> b; p.X(a); p.Y(b); return is; }\nostream &operator << (ostream& os, const Point& p) { return os << \"(\" << X(p) << \",\" << Y(p) << \")\"; }\ndouble dot(Point a, Point b) { return a.X() * b.X() + a.Y() * b.Y(); }\ndouble cross(Point a, Point b) { return a.X() * b.Y() - a.Y() * b.X(); }\ndouble length2(Point p) { return p.X() * p.X() + p.Y() * p.Y(); }\ndouble length(Point p) { return sqrt(length2(p)); }\ndouble distance(Point a, Point b) { return length(a - b); }\nPoint unit(Point p) { return p / length(p); }\n\nenum ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\nccw_t ccw(Point a, Point b, Point c){\n    Point ab = b - a, ac = c - a;\n    if( cross(ab,ac) > EPS ) return COUNTER_CLOCK_WISE; // +1 a-b-c ???????¨???????\n    if( cross(ab,ac) < -EPS ) return CLOCK_WISE;        // -1 a-b-c ????¨???????\n    if( dot(ab,ac) < -EPS ) return STRAIGHT_C_A_B;      // +2 c-a-b\n    if( length2(ab) < length2(ac) )return STRAIGHT_A_B_C;     // -2 a-b-c or a==b\n    return STRAIGHT_A_C_B;                              //  0 a-c-b or b==c or a==c\n}\n\nstruct Circle{\n    Point c;\n    double r;\n};\nistream &operator >> (istream& is, Circle& c){ return is >> c.c >> c.r;}\nostream &operator << (ostream& os, Circle& c){ return os << c.c << \" r = \" << c.r;}\n\narray<Point, 2> cross_points(Circle c1, Circle c2) {\n    double d = distance(c1.c, c2.c);\n    assert(d > 0);\n    // c1.c ?????????c1,c2????????????????????´?????¨c1.c->c2.c ??????????????§????????¢\n    double x = (pow(c1.r, 2) - pow(c2.r, 2) + pow(d, 2)) / (2 * d);\n    assert(c1.r > x);\n    double h = sqrt(pow(c1.r, 2) - pow(x, 2));    \n    Point mid = unit(c2.c - c1.c) * x;\n    Point vertical = unit(Point(-Y(mid), X(mid))) * h; // ???????????????????????????\n    return { c1.c + mid + vertical, c1.c + mid - vertical };\n}\n\nstruct Segment{\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n};\n\nbool does_intersect(const Segment &a, const Segment &b){\n    return (int)ccw(a.a, a.b, b.a) * (int)ccw(a.a, a.b, b.b) <= 0 &&\n            (int)ccw(b.a, b.b, a.a) * (int)ccw(b.a, b.b, a.b) <= 0;\n}\n\nstruct State {\n    int index;\n    double cost;\n    State(int i, double c):index(i), cost(c) {}\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\n// O(ElogV)\nvector<double> dijkstra(const vector<vector<double>> &G, int start) {\n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<double> dist(G.size(), INF);\n    que.emplace(start, 0);\n    dist[start] = 0;\n    while(not que.empty()){\n        State now = que.top(); que.pop();\n        rep(i, G.size()) {\n            if(G[now.index][i] >= INF) continue;                                               \n            if(dist[i] > now.cost + G[now.index][i]) {\n                State nxt = State(i, now.cost + G[now.index][i]);\n                dist[i] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return dist;\n}\n\nclass Solver {\n  public:\n    bool solve() {\n        int N; cin >> N;\n        if(N == 0) return false;\n        vector<Circle> C(N); cin >> C;        \n        vector<array<Point, 2>> P;\n        Point s = C.front().c, e = C.back().c;\n        P.push_back({s, s});\n        rep(i, N - 1) {\n            P.push_back(cross_points(C[i], C[i + 1]));\n        }\n        P.push_back({e, e});\n                \n        vector<vector<double>> dist(P.size() * 2, vector<double>(P.size() * 2, INF));\n        rep(i, dist.size()) dist[i][i] = 0;\n        rep(i, P.size()) rep(ii, 2) {\n            Point a = P[i][ii];\n            repeat(j, i + 1, P.size()) rep(jj, 2) {\n                Point b = P[j][jj];\n                Segment s1(a, b);\n                bool ok = true;\n                repeat(k, i + 1, j) {                    \n                    if(!does_intersect(s1, Segment(P[k][0], P[k][1]))) ok = false;\n                }\n                if(ok) {\n                    dist[i*2 + ii][j*2 + jj] = distance(a, b);\n                }\n            }\n        }\n\n        auto ans = dijkstra(dist, 0);\n        cout << ans.back() << endl;\n\n        return true;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\n\ntypedef long double R;\ntypedef complex<R> P;\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos(-1);\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (a > b) swap(a, b);\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\nstruct C {\n    P p;\n    R r;\n    C () {};\n    C (P p, R r) : p(p), r(r) {};\n};\n\nint crossSC(const L&l, const C &c) {\n    R mi = distSP(l, c.p);\n    if (sgn(c.r, mi) == 1) return 0;\n    if (sgn(c.r, mi) == 0) return 1;\n    int u = 0;\n    if (sgn(c.r, abs(l.x-c.p)) != -1) u++;\n    if (sgn(c.r, abs(l.y-c.p)) != -1) u++;\n    return u;\n}\n\n\n//return number of cross point\nint crossP(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) return -1;\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\nbool insLS(const L &l, const L &s) {\n    int a = ccw(l.x, l.y, s.x);\n    int b = ccw(l.x, l.y, s.y);\n    if (a == 1 && b == 1) return false;\n    if (a == -1 && b == -1) return false;\n    return true;\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\n/*\nexec??§res??????????????¢?????\\???\n*/\nconst R INF = 1e9;\ntemplate<int V>\nstruct Dijkstra {\n    typedef R T;\n    typedef pair<T, int> P;\n    vector<P> g[V];\n    void add(int from, int to, T dist) {\n        g[from].push_back(P(dist, to));\n    }\n    T res[V];\n    void exec(int s) {\n        fill_n(res, V, INF);\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push(P(0, s));\n        res[s] = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            if (res[p.second] < p.first) continue;\n            for (P e: g[p.second]) {\n                if (p.first+e.first < res[e.second]) {\n                    res[e.second] = p.first+e.first;\n                    q.push(P(e.first+p.first, e.second));\n                }\n            }\n        }\n        return;\n    }\n};\n\n\n\nconst int MN = 110;\nint n;\nC c[MN];\nL l[MN];\n\nbool calc(L ll, int i, int j) {\n    for (int k = i+1; k < j; k++) {\n        if (!insSS(ll, l[k])) return false;\n    }\n    return true;\n}\nR solve() {\n    l[0] = L(c[0].p, c[0].p);\n    for (int i = 1; i < n; i++) {\n        crossP(c[i-1], c[i], l[i]);\n    }\n    l[n] = L(c[n-1].p, c[n-1].p);\n    n++;\n    Dijkstra<MN*2> djk;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (calc(L(l[i].x, l[j].x), i, j)) {\n                djk.add(i*2, j*2, abs(l[i].x-l[j].x));\n            }\n            if (calc(L(l[i].x, l[j].y), i, j)) {\n                djk.add(i*2, j*2+1, abs(l[i].x-l[j].y));\n            }\n            if (calc(L(l[i].y, l[j].x), i, j)) {\n                djk.add(i*2+1, j*2, abs(l[i].y-l[j].x));\n            }\n            if (calc(L(l[i].y, l[j].y), i, j)) {\n                djk.add(i*2+1, j*2+1, abs(l[i].y-l[j].y));\n            }\n        }\n    }\n    djk.exec(0);\n    return djk.res[2*n-1];\n}\n\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, r;\n            cin >> x >> y >> r;\n            c[i] = C(P(x, y), r);\n        }\n        printf(\"%.20Lf\\n\", (long double)solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <list>\n#include <map>\n#include <cmath>\n#include <utility>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <set>\n#include <climits>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI = acos(-1.0);\n\ntemplate<class T>\nstruct Point{\n\tT x,y;\n\tPo() : x(0.0),y(0.0) {}\n\tPo(const T &x,const T &y) : x(x),y(y) {}\n\tPo operator+(const Po& a) const { return Po(x + a.x,y + a.y); }\n\tPo operator-(const Po& a) const { return Po(x - a.x,y - a.y); }\n\tPo operator*(const double& a) const { return Po(x * a, y * a); }\n\tPo operator/(const double& a) const { return Po(x / a, y / a); }\n};\n\nenum{ CCW = 1,CW = -1,ON = 0};\n\ntypedef Po<double> P;\n\ndouble SQ(double x) {return x* x; }\ndouble abs(const P& a) { return sqrt(SQ(a.x) + SQ(a.y)); }\ndouble dot( const P& a,const P &b){ return a.x * b.x + a.y * b.y ; }\ndouble cross( const P& a,const P &b){ return a.x * b.y - a.y * b.x ; }\n\nP rot(const P& a, double theta){\n\treturn P( a.x * cos(theta) - a.y * sin(theta) ,\n\t\ta.x * sin(theta) + a.y * cos(theta) );\n}\n\nint ccw(P a,P b,P c){\n\tb = b - a; c = c - a;\n\tdouble rdir = cross(b,c);\n\tdouble len = abs(b) * abs(c);\n\tif( rdir > EPS *len) return CCW;\n\telse if( rdir < -EPS * len) return CW;\n\treturn ON;\n}\n\nbool intersect(P& a1,P& b1,P& a2, P& b2){\n\tif(max(a1.x,b1.x) + EPS < min(a2.x,b2.x)\n\t||max(a1.y,b1.y) + EPS < min(a2.y,b2.y)\n\t||max(a2.x,b2.x) + EPS < min(a1.x,b1.x)\n\t||max(a2.y,b2.y) + EPS < min(a1.y,b1.y) ) return false;\n\treturn ccw(a1,b1,a2) * ccw(a1,b1,b2) <= 0\n\t\t&& ccw(a2,b2,a1) * ccw(a2,b2,b1) <= 0;\n}\n\ntypedef pair<P,P> PD;\n\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\nint n;\nP p[100];\ndouble r[100];\ndouble dp[202][202];\n\n#define FOR(i,n) for(int i = 0; i < (n) ; i++)\n\n\nint main(){\n\n\twhile(cin>>n,n){\n\t\tvector<P> us;\n\t\tvector<PD> vpd;\n\t\tFOR(i,n) cin>>p[i].x >> p[i].y >> r[i];\n\t\tFOR(i,202) FOR(j,202) dp[i][j] = 1e50;\n\t\tus.push_back(p[0]);\n\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tPD pd = GetContact(p[i],p[i+1],r[i],r[i+1]);\n\t\t\tus.push_back(pd.first);\n\t\t\tus.push_back(pd.second);\n\t\t\tvpd.push_back(pd);\n\t\t}\n\t\tus.push_back(p[n-1]);\n\n\t\tfor(int i = 0; i < (int)us.size(); i++){\n\t\t\tfor(int j = i + 1; j < (int)us.size(); j++){\n\t\t\t\tbool ok = true;\n\t\t\t\tint l  = (1 + i) / 2;\n\t\t\t\tint r = (1 + j) / 2 - 1;\n\t\t\t\tfor (int k = l; k < r; k++){\n\t\t\t\t\tif(!intersect(us[i],us[j],vpd[k].first,vpd[k].second))\n\t\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok) continue;\n\t\t\t\tdouble dist = abs(us[i] - us[j]);\n\t\t\t\tdp[j][i] = dp[i][j] = dist;\n\t\t\t}\n\t\t}\n\n\t\tint a = (int)us.size();\n\t\tFOR(k,a) FOR(i,a) FOR(j,a) dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\n\t\tprintf(\"%.10lf\\n\",dp[0][a - 1]);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n// #define EPS 1e-8\n// static const int INF=1<<24;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double M_PI = acos(-1);\n\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P,i) P[(i)%P.size()]\n#define Next(P,i) P[(i+1)%P.size()]\n#define Prev(P,i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n  bool operator<(const P a,const P b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\ndouble cross(const P a,const P b){\n  return (conj(a)*b).imag();\n}\ndouble dot(const P a,const P b){\n  return (conj(a)*b).real();\n}\n// TODO make graph (20)\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)>0)    return +1;//counter clockwise\n  if(cross(b,c)<0)    return -1;//clockwise\n  if(dot(b,c)<0)      return +2;// c--a--b\n  if(norm(b)<norm(c)) return -2;// a--b--c\n                      return  0;// a--c--b(or b==c)\n}\n\nstruct L : public vector<P>{\n  L(){}\n  L(const P a,const P b){\n    push_back(a),push_back(b);\n  }\n};\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C{\n  P p;double r;\n  C(){}\n  C(const P p,double r): p(p),r(r){}\n};\n\n\n\n//直線と点の関係\n//点から線分に垂線を下ろした点\nP projection(L a,P p){\n  double t = dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0] + t*(a[0]-a[1]);\n}\n//線対称の点\nP reflection(L a,P p){\n  return p + 2.0 * (projection(a,p)-p);\n}\n\n\n\n\n//交差判定\n//TODO CP(内包) CL CS (0)\nbool isCrossLL(L a,L b){\n  return \n    abs(cross(a[1]-a[0],b[1]-b[0])) > EPS\n    || abs(cross(a[1]-a[0],b[0]-a[0])) < EPS ;\n}\nbool isCrossLS(L a,S b){\n  return \n    cross(a[1]-a[0],b[0]-a[0]) \n    * cross(a[1]-a[0],b[1]-a[0]) < EPS;\n}\nbool isCrossLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool isCrossSS(S a,S b){\n  return\n    ccw(a[0],a[1],b[0])\n    * ccw(a[0],a[1],b[1]) <= 0\n    &&\n    ccw(b[0],b[1],a[0])\n    * ccw(b[0],b[1],a[1]) <= 0;\n}\nbool isCrossSP(S a,P p){\n  return abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\n\n// 距離 CP CL CS は(distXP(x,c.p)-c.r)\ndouble distPP(P a,P b){\n  return abs(a-b);\n}\ndouble distLP(L a,P p){\n  return abs(p-projection(a,p));\n}\ndouble distLL(L a,L b){\n  return isCrossLL(a,b) ? 0 : distLP(a,b[0]);\n}\ndouble distLS(L a,S b){\n  return isCrossLS(a,b) ? 0 : min(distLP(a,b[0]),distLP(a,b[1]));\n}\ndouble distSP(S a,P p){\n  const P r = projection(a,p);\n  return isCrossSP(a,r) ? abs(p-r) : min(abs(a[0]-p),abs(a[1]-p));\n}\ndouble distSS(S a,S b){\n  return isCrossSS(a,b)?0:\n    min(\n      min(distSP(a,b[0]),distSP(a,b[1])),\n      min(distSP(b,a[0]),distSP(b,a[1]))\n    );\n}\n\n//円の交差判定\nbool isCrossCP(C a,P p){\n  return abs(a.p-p)-a.r<=EPS;\n}\nbool isCrossCL(C a,L l){\n  return distLP(l,a.p)-a.r<EPS;\n}\ndouble distSP_MAX(S a,P p){\n  return max(abs(a[0]-p),abs(a[1]-p));\n}\nbool isCrossCS(C a,S s){\n  return distSP(s,a.p)-a.r<-EPS&&distSP_MAX(s,a.p)-a.r>+EPS;\n}\nbool isCrossCC(C a,C b){//接してる時は交差\n  return abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\n\n//交差点\n//先に交差判定をすること\nP crossP_LL(L a,L b){\n  double A = cross(a[1]-a[0],b[1]-b[0]);\n  double B = cross(a[1]-a[0],a[1]-b[0]);\n  if(abs(A)<EPS && abs(B)<EPS)return b[0];\n  if(abs(A)<EPS)assert(false);\n  return b[0]+B/A*(b[1]-b[0]);\n}\nvector<P> crossP_CL(C c,L l){\n  P tmp = projection(l,c.p);\n  P e = (l[0]-l[1])/abs(l[0]-l[1]);\n  double h = abs(c.p-tmp)*abs(c.p-tmp);\n  double t = sqrt(c.r*c.r - h*h);\n  if(t<EPS)return {tmp};\n  return {tmp + e*t,tmp - e*t};\n}\nvector<P> crossP_CC(C a,C b){\n  P A = conj(b.p-a.p);\n  P B = (b.r*b.r - a.r*a.r - (b.p-a.p)*conj(b.p-a.p));\n  P C = a.r*a.r*(b.p-a.p);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+a.p;\n  P z2 = (-B-sqrt(D))/(2.0*A)+a.p;\n  return {z1,z2};\n}\n\n\n\n//三点->円\nP PPPtoC(P a,P b,P c){\n  P x = 1.0/(conj(b-a));\n  P y = 1.0/(conj(c-a));\n  return (y-x)/( conj(x)*y - x*conj(y) ) + a;\n}\n\n//凸包\nG convex_hull(G ps){\n  int n = ps.size();\n  int k = 0;\n  G ch(2*n);\n  for(int i = 0;i<n;(ch[k++]=ps[i++])){\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  for(int i = n-2,t=k+1 ; i>=0 ; ch[k++]=ps[i--]){\n    while(k>=t && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch;\n} \n\n\n//凸性判定\nbool isConvex(G g){\n  for(int i=0; i<g.size();i++){\n    if(ccw(Prev(g,i),Curr(g,i),Next(g,i))>0)return false;\n  }\n}\n\n\n\n//接線\n//TODO check\nvector<L> TLine_CP(C c,P p){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P n2 = reflection(L(p,c.p),n1);\n  return {L(p,n1),L(p,n2)};\n}\n\n// TLine CC\nvector<L> TLine_CPr(C c,P p,double r){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P e1 = (n1-c.p)/abs(n1-c.p) * r;\n  P n2 = reflection(L(p,c.p),n1);\n  P e2 = (n2-c.p)/abs(n2-c.p) * r;\n  return {L(p+e1,n1+e1),L(p+e2,n2+e2)};\n}\nvector<L> TLine_CC(C a,C b){\n  //接してる時がヤバイ\n  vector<L> res;\n  if(!isCrossCC(a,b)&&(abs(a.r)>EPS)&&(abs(b.r>EPS))){\n    P tmp = (a.p-b.p)*(b.r)/(a.r+b.r) + b.p;\n    auto t1 = TLine_CP(a,tmp);\n    auto t2 = TLine_CP(b,tmp);\n    res.push_back(L(t1[0][1],t2[0][1]));\n    res.push_back(L(t1[1][1],t2[1][1]));\n  }\n  if(abs(a.r-b.r)<EPS){\n    const auto r = a.r;\n    P e = (a.p-b.p)/abs(a.p-b.p) * exp(P(.0,90.0/180.0*M_PI));\n    res.push_back(L(a.p+(e*r),b.p+(e*r)));\n    if(abs(r)>=EPS)res.push_back(L(a.p-(e*r),b.p-(e*r)));\n  }else{\n    if(a.r<b.r)swap(a,b);\n    auto t3 = TLine_CPr(C(a.p,a.r-b.r),b.p,b.r);\n    for(auto i:t3){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\n//原点を起点とした回転\nP rotate(P a,double r){\n  return a*exp(P(0.0,r*M_PI/180.0));\n}\n\ndouble dp[110][2];\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C> cir(n);\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b>>cir[i].r;\n      cir[i].p=P(a,b);\n      // cout<<cir[i].p.X<<\" \"<<cir[i].p.Y<<\" \"<<cir[i].r<<endl;\n\t\t}\n    VV(P) po;\n    po.PB(vector<P>(1,cir[0].p));\n    rep(i,n-1){\n      po.PB(crossP_CC(cir[i],cir[i+1]));\n    }\n    po.PB(vector<P>(1,cir[n-1].p));\n    rep(i,110){\n      rep(j,2){\n        dp[i][j]=INF;\n      }\n    }\n    // printf(\"%.6lf %.6lf\\n\",po[1][0].X,po[1][0].Y);\n    // printf(\"%.6lf %.6lf\\n\",po[1][1].X,po[1][1].Y);\n    dp[0][0]=dp[0][1]=0;\n    reep(i,1,n){\n      if(i==1){\n        dp[1][0]=distPP(cir[0].p,po[1][0]);\n        dp[1][1]=distPP(cir[0].p,po[1][1]);\n      }\n      // dp[i][0]=mkp(distPP(cir[0].p,po[0][0]),0);\n      else{\n        rep(j,2){\n          for(int k=i-1;k>=0;k--){\n            rep(g,po[k].size()){\n              S t1=S(po[i][j],po[k][g]);\n              bool f=true;\n              reep(h,k+1,i){\n                f&=isCrossSS(t1,S(po[h][0],po[h][1]));\n              }\n              if(f){\n                if(dp[i][j]>distPP(po[i][j],po[k][g])+dp[k][g]){\n                  dp[i][j]=distPP(po[i][j],po[k][g])+dp[k][g];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    double ans=INF;\n    rep(i,n){\n      rep(j,po[i].size()){\n        // cout<<i<<\" \"<<j<<\" \";\n        // printf(\"%.6lf\\n\",dp[i][j]);\n        S t1=S(po[i][j],po[n][0]);\n        bool f=true;\n        reep(k,i+1,n){\n          f&=isCrossSS(t1,S(po[k][0],po[k][1]));\n        }\n        if(f){\n          ans=min(ans,dp[i][j]+distPP(po[i][j],po[n][0]));\n        }\n      }\n    }\n    printf(\"%.6lf\\n\",ans);\n    // rep(i,n){\n      // cout<<dp[i][0].se<<\" \"<<dp[i][1].se<<endl;\n    // }\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.push_back(S(c, c));\n\t\t\telse{\n\t\t\t\ts.push_back(cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.push_back(S(prev, prev));\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.4f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n\ntypedef double D;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\nconst D EPS = 1e-8;\n\ntypedef complex<D> P;\nnamespace std {\n    bool operator<(const P &a,const P &b){\n        return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n    }\n}\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nP unit(P p){return p / abs(p);}\nP rotate(P v,double s){\n    return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\nD arg(D a,D b,D c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\ntypedef pair<P, P> L;\nint ccw(P a,P b,P c){\n    b -= a;c -= a;\n    if (cross(b,c)>EPS) return 1; //counter clockwise\n    if (cross(b,c)<-EPS) return -1; //clockwise\n    if (dot(b, c)<-EPS) return 2; //c−−a−−b on line\n    if (abs(b)<abs(c)) return -2; //a−−b−−c on line\n    return 0; //on segment\n}\nD line_dis(L a,P x){return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);}\nbool is_cp(L a, L b) {\n    if (ccw(a.fs, a.sc, b.fs) * ccw(a.fs, a.sc, b.sc) <= 0)\n        if (ccw(b.fs, b.sc, a.fs) * ccw(b.fs, b.sc, a.sc) <= 0) return true;\n    return false;\n}\n\ntypedef pair<P, D> C;\nvector<P> cp_cir_to_cir(C a, C b){\n    vector<P> v;\n    D s = arg(b.sc,abs(b.fs-a.fs),a.sc);\n    P x = a.sc * unit(b.fs - a.fs);\n    v.push_back(a.fs + rotate(x,s));\n    v.push_back(a.fs + rotate(x,-s));\n    return v;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<C> c(n);\n        vector<tuple<P, int>> v;\n        vector<L> check(n);\n        for (int i = 0; i < n; i++) {\n            double x, y, r; cin >> x >> y >> r;\n            c[i] = {{x, y}, r};\n\n            if (i == 0) {\n                v.push_back(make_tuple(P{x, y}, 1));\n                continue;\n            }\n            auto pts = cp_cir_to_cir(c[i-1], c[i]);\n            for (auto x : pts) v.push_back(make_tuple(x, i));\n            check[i] = {pts[0], pts[1]};\n            if (i == n - 1) v.push_back(make_tuple(P{x, y}, i));\n        }\n\n        vector<double> done(v.size(), 1e9);\n        typedef tuple<double, int> State;\n        priority_queue<State, vector<State>, greater<State>> Q;\n        done[0] = 0;\n        Q.push(make_tuple(0, 0));\n        while(Q.size()) {\n            double cost; int vi;\n            tie(cost, vi) = Q.top(); Q.pop();\n            if (done[vi] < cost) continue;\n\n            P from, to; int ci, ni;\n            tie(from, ci) = v[vi];\n            for (int i = 0; i < v.size(); i++) {\n                if (vi == i) continue;\n\n                tie(to, ni) = v[i];\n                if (ni < ci) continue;\n\n                bool flag = true;\n                for (int j = ci; flag && j <= ni; j++)\n                    if (!is_cp(check[j], {from, to})) flag = false;\n                if (!flag) continue;\n\n                if (done[i] > cost + abs(to - from)) {\n                    done[i] = cost + abs(to - from);\n                    Q.push(make_tuple(done[i], i));\n                }\n            }\n        }\n        printf(\"%.10lf\\n\", done[v.size() - 1]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (sqrt(cross(b-a, c-a)) > EPS) return 1;\n    if (sqrt(cross(b-a, c-a)) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (sqrt(cross(b-a, c-a)) > EPS) return 1;\n    if (sqrt(cross(b-a, c-a)) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n// http://is2011.2-d.jp/moin/moin.cgi/amylase/icpc#A.2BdvR92jBuTqRwuQ-\n\n#define rep(i,n) for(int i=0;i<n;++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define F first\n#define S second\n#define SZ(a) (int)((a).size())\n// primitives\ntypedef double Real;\ntypedef complex<Real> Point;\ntypedef pair<Point, Point> Line;\ntypedef pair<Point, Real> Circle;\ntypedef vector<Point> Poly;\n\nReal eps = 1e-9;\n\nvector<Point> CCintersect (Circle c, Circle d) {\n    vector<Point> ret;\n    const Real dist = abs(c.first - d.first);\n    const Real cr = c.second;\n    const Real dr = d.second;\n\n    if (dist > cr + dr) return ret;\n    if (dist < abs(cr - dr)) return ret;\n\n    const Real s = (cr + dr + dist) / 2.;\n    const Real area = sqrt(s * (s - cr) * (s - dr) * (s - dist));\n    const Real h = 2 * area / dist;\n\n    Point v = d.first - c.first; v /= abs(v);\n    const Point m = c.first + sqrt(cr * cr - h * h) * v;\n    const Point n = v * Point(0, 1);\n\n    ret.push_back(m + n * h);\n    ret.push_back(m - n * h);\n    return ret;\n}\n\ninline Real dot(const Point& p, const Point& q){return p.real() * q.real() + p.imag() * q.imag();}\ninline Real cross(const Point& p, const Point& q){return p.real() * q.imag() - p.imag() * q.real();}\n\n// ccw_b : old version of ccw.\ninline Real ccw_b(const Point& p, const Point& q, const Point& r) {return cross(q - p, r - p);}\n\n/* ccw :\nCD  : counter direction\nCW  : clock wise\nOS  : on segment\nCCW : counter clock wise\nD   : direction\n */\nenum LPposit { P_CD = -2, P_CW = -1, P_OS = 0, P_CCW = 1, P_D = 2};\nLPposit ccw(const Point& p, const Point& q, const Point& r) {\n  Real c = ccw_b(p, q, r);\n  if (c < -eps) return P_CW;\n  if (c >  eps) return P_CCW;\n  if (dot(q - p, r - p) < -eps) return P_CD;\n  if (dot(p - q, r - q) < -eps) return P_D;\n  return P_OS;\n}\n\nbool crossS(const Line& p, const Line& q){\n  return\n    ccw(p.first, p.second, q.first) * ccw(p.first, p.second, q.second) <= 0 &&\n    ccw(q.first, q.second, p.first) * ccw(q.first, q.second, p.second) <= 0;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int n;\n    while(cin>>n){\n        if(n==0) break;\n        double x[n],y[n],r[n];\n        Circle c[n];\n        for(int i=0;i<n;i++){\n            cin>>x[i]>>y[i]>>r[i];\n            c[i] = {{x[i],y[i]},r[i]};\n        }\n        Point p[2*n]={};\n        p[0]={x[0],y[0]};\n        p[2*n-1] = {x[n-1],y[n-1]};\n        for(int i=0;i<n-1;i++){\n            vector<Point> ret = CCintersect(c[i],c[i+1]);\n            if(imag(ret[0]) < imag(ret[1])) swap(ret[0],ret[1]);\n            p[2*i+1] = {ret[0]};\n            p[2*i+2] = {ret[1]};\n        }\n        int m = 2*n;\n        double dp[m][m]={};\n        for(int i=0;i<m;i++){\n            for(int j=0;j<m;j++){\n                if(i!=j) dp[i][j] = 1e9;\n            }\n        }\n        for(int i=0;i<m;i++){\n            for(int j=i+1;j<m;j++){\n                bool pos = true;\n                int next, last;\n                if(i%2) next = i+2;\n                else next = i+1;\n                if(j%2) last = j-2;\n                else last = j-3;\n                for(int k=next;k<=last;k+=2){\n                    //k,k+1と交差しているか\n                    Line y1 = {p[i],p[j]}, y2 = {p[k],p[k+1]};\n                    bool ok = crossS(y1,y2);\n                    if(!ok){\n                        pos = false;\n                        break;\n                    }\n                }\n                if(pos){\n                    dp[i][j] = abs(p[i] - p[j]);\n                    dp[j][i] = dp[i][j];\n                }\n            }\n        }\n\n        for(int k=0;k<m;k++)for(int i=0;i<m;i++)for(int j=0;j<m;j++){\n            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n        }\n        cout << dp[0][m-1] << \"\\n\";\n\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing T = long double;\nconst T EPS = 1e-10;\nconst T PI = acos(-1.0);\nconst T INF = 1e10;\nT torad(int deg) {return (T)(deg) * PI / 180;}\nT todeg(T ang) {return ang * 180 / PI;}\n\n/* Point */\nusing P = complex<T>;\n#define x real()\n#define y imag()\ntemplate <typename T> inline bool eq(T p, T q) { return abs(p - q) < EPS; }\ninline int sgn(T x) { return (0.0 < x) - (x < 0.0); }\ninline T dot(P v, P w) { return (conj(v) * w).x; }\ninline T cross(P v, P w) { return (conj(v) * w).y; }\ninline bool isOrth(P v, P w) { return dot(v, w) == 0; }\ninline bool isPara(P v, P w) { return cross(v, w) == 0; }\ninline P unit(P v) { return v / abs(v); }\ninline P translate(P p, P v) { return p + v; }\ninline P scale(P p, P c, T k) { return c + (p - c) * k; }\ninline P rot(P p, T a) { return p * polar(T(1), a); }\ninline P rot90(P p) { return {-p.y, p.x}; }\ninline T orient(P a, P b, P c) { return cross(b - a, c - a); }\nistream& operator>>(istream& is, P& p) { T xx, yy; is >> xx >> yy; p = P(xx, yy); return is; }\nbool cmpX(const P& a, const P& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool cmpY(const P& a, const P& b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nnamespace std {\n    bool operator < (const P& a, const P& b) { return cmpX(a, b); }\n}\n\nP linearTransform(P p, P q, P fp, P fq, P r) {\n    return fp + (r - p) * (fq - fp) / (q - p);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > EPS) return +1;      // counter clockwise\n    if (cross(b, c) < -EPS) return -1;      // clockwise\n    if (dot(b, c) < -EPS) return +2;        // c--a--b on line\n    if (norm(b) < norm(c) - EPS) return -2;    // a--b--c on line or a==b\n    return 0;                            // a--c--b on line or a==c or b==c\n}\n\nT angle(P v, P w) {\n    T cosTheta = dot(v, w) / abs(v) / abs(w);\n    return acos(max(T(-1.0), min(T(1.0), cosTheta)));\n}\nT orientedAngle(P a, P b, P c) {\n    if (orient(a, b, c) >= 0) return angle(b - a, c - a);\n    return 2 * PI - angle(b - a, c - a);\n}\nbool inAngle(P a, P b, P c, P p) {\n    assert(abs(orient(a, b, c)) != 0);\n    if (orient(a, b, c) < 0) swap(b, c);\n    return orient(a, b, p) >= 0 && orient(a, c, p) <= 0;\n}\n\n// polar sort\nbool half(P p) {\n    assert(p.x != 0 || p.y != 0);\n    return p.y > 0 || (p.y == 0 && p.x < 0);\n}\nvoid polarSort(vector<P>& v, P o = P(0.0, 0.0)) {\n    sort(v.begin(), v.end(), [&](P v, P w) {\n        return make_tuple(half(v - o), 0, norm(v - o)) <\n            make_tuple(half(w - o), cross(v - o, w - o), norm(w - o));\n    });\n}\n\n/* Line */\nstruct L : array<P, 2> {\n    P v; T c;\n    L(P a = P(0.0, 0.0), P b = P(0.0, 0.0)) : array<P, 2>({a, b}), v(b - a), c(cross(v, a)) {}\n    T side(P p) { return cross(v, p) - c; }\n    P proj(P p) { return p - rot90(v) * side(p) / norm(v); }\n    P refl(P p) { return p - rot90(v) * T(2) * side(p) / norm(v); }\n    friend istream& operator>>(istream& is, L& l) { P p, q; is >> p >> q; l = L(p, q); return is; }\n    friend ostream& operator<<(ostream& os, const L& l) { return os << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct C : P {\n    T r;\n    C(P p = P(0.0, 0.0), T r = 0.0) : P(p), r(r) {}\n    friend istream& operator>>(istream& is, C& c) { P p; T r; is >> p >> r; c = C(p, r); return is; }\n    friend ostream& operator<<(ostream& os, const C& c) { return os << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\nP circumCenter(P a, P b, P c) {\n    b -= a, c -= a;\n    assert(cross(b, c) != 0);\n    return a + rot90(b * norm(c) - c * norm(b)) / cross(b, c) / T(2);\n}\n\nvector<P> tangentPoints(C c, P p) {\n    if (eq(abs(p - c), c.r)) return vector<P>{p};\n    vector<P> res;\n    T t = acos(c.r / abs(p - c));\n    P q = (p - c) / abs(p - c) * c.r;\n    res.push_back(c + q * polar(T(1), t));\n    res.push_back(c + q * polar(T(1), -t));\n    sort(res.begin(), res.end(), cmpX);\n    return res;\n}\n\nvector<L> tangentLines(C c1, C c2, bool inner) {\n    if (inner) c2.r = -c2.r;\n    vector<L> res;\n    P d = c2 - c1;\n    T dr = c1.r - c2.r, d2 = norm(d), h2 = d2 - dr * dr;\n    if (d2 == 0 || h2 < 0) { assert(h2 != 0); return res; }\n    for (T sign : {-1, 1}) {\n        P v = (d * dr + rot90(d) * sqrt(h2) * sign) / d2;\n        res.emplace_back(c1 + v * c1.r, c2 + v * c2.r);\n    }\n    return res;\n}\n\n// intersect\nbool isInterPL(P p, L l) { return (ccw(l[0], l[1], p) != 1); }\nbool isInterPS(P p, L s) { return (ccw(s[0], s[1], p) == 0); }\nbool isInterLL(L l, L m) { return (!isPara(l.v, m.v)); }\nbool isInterLS(L l, L s) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], l);\n    return (ccw(l[0], l[1], s[0]) * ccw(l[0], l[1], s[1]) <= 0);\n}\nbool isInterSS(L s, L t) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], t);\n    if (eq(t[0], t[1])) return isInterPL(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nint isInterCC(C a, C b) {\n    T d = abs(b - a);\n    if (a == b && a.r == b.r) return 0;         // ∞ cp (A = B)\n    if (a.r + d - b.r < -EPS) return +1;        // 0 cp (A in B)\n    if (b.r + d - a.r < -EPS) return -1;        // 0 cp (B in A)\n    if (abs(a.r + d - b.r) < EPS) return +2;    // 1 cp (A in B)\n    if (abs(b.r + d - a.r) < EPS) return -2;    // 1 cp (B in A)\n    if (abs(a.r + b.r - d) < EPS) return 3;     // 1 cp (outside)\n    if (a.r + b.r - d < -EPS) return 4;         // 0 cp (outside)\n    return 5;                                   // 2 cp\n}\n \n// distance\nT distancePL(P p, L l) { return (abs(p - l.proj(p))); }\nT distancePS(P p, L s) {\n    P h = s.proj(p);\n    if (isInterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nT distanceLL(L l, L m) {\n    if (isInterLL(l, m)) return 0.0;\n    return distancePL(m[0], l);\n}\nT distanceLS(L l, L s) {\n    if (isInterLS(l, s)) return 0;\n    return min(distancePL(s[0], l), distancePL(s[1], l));\n}\nT distanceSS(L s, L t) {\n    if (isInterSS(s, t)) return 0;\n    return min({distancePS(s[0], t), distancePS(s[1], t), distancePS(t[0], s), distancePS(t[1], s)});\n}\n\n// crosspoint\nvector<P> crosspointLL(L l, L m) {\n    if (!isInterLL(l, m)) return vector<P>();\n    vector<P> res;\n    T d = cross(m[1] - m[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLS(L l, L s) {\n    if (!isInterLS(l, s)) return vector<P>();\n    vector<P> res;\n    T d = cross(s[1] - s[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(s[1] - s[0], s[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLC(L l, C c, bool dupl = false) {\n    if (abs(c - l.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, l), h2 = c.r * c.r - d * d;\n    assert(h2 >= 0);\n    P p = l.proj(c), h = l.v * sqrt(h2) / abs(l.v);\n    res.push_back(p - h);\n    if (dupl || abs(h) > 0) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointSS(L s, L t) {\n    if (!isInterSS(s, t)) return vector<P>();\n    vector<P> res;\n    T d = cross(t[1] - t[0], s[1] - s[0]);\n    if (d) {\n        res.push_back(s[0] + (s[1] - s[0]) * cross(t[1] - t[0], t[1] - s[0]) / d);\n    } else {\n        if (ccw(s[0], s[1], t[0]) == 0) res.push_back(t[0]);\n        if (ccw(s[0], s[1], t[1]) == 0) res.push_back(t[1]);\n        if (ccw(t[0], t[1], s[0]) == 0) res.push_back(s[0]);\n        if (ccw(t[0], t[1], s[1]) == 0) res.push_back(s[1]);\n    }\n    return res;\n}\nvector<P> crosspointSC(L s, C c, bool dupl = false) {\n    if (abs(c - s.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, s), h2 = c.r * c.r - d * d;\n    assert(h2 >= 0);\n    P p = s.proj(c), h = s.v * sqrt(h2) / abs(s.v);\n    if (isInterPS(p - h, s)) res.push_back(p - h);\n    if (dupl || (abs(h) > 0 && isInterPS(p + h, s))) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointCC(C c1, C c2, bool dupl = false) {\n    P d = c2 - c1; T d2 = norm(d);\n    if (d2 == 0) { assert(c1.r != c2.r); return vector<P>(); }\n    vector<P> res;\n    T pd = (d2 + c1.r * c1.r - c2.r * c2.r) / 2;\n    T h2 = c1.r * c1.r - pd * pd / d2;\n    if (h2 >= 0) {\n        P p = c1 + d * pd / d2, h = rot90(d) * sqrt(h2 / d2);\n        res.push_back(p - h);\n        if (dupl || abs(h) > 0) res.push_back(p + h);\n    }\n    return res;\n}\n\n/* Polygon */\n// p[0] has minimum y and p is counterclockwise\nvector<P> makeStandard(vector<P> p) {\n    int n = p.size(), j = -1;\n    for (int i = 0; i < n; ++i) {\n        if (j == -1 || p[i].y < p[j].y) j = i;\n    }\n    vector<P> res;\n    if (p[(j - 1 + n) % n].x <= p[j].x && p[j].x <= p[(j + 1) % n].x) {\n        for (int i = 0; i < n; ++i) {\n            res.push_back(p[(i + j) % n]);\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            res.push_back(p[(i - j + n) % n]);\n        }\n    }\n    return res;\n}\nbool isConvex(vector<P> p) {\n    p = makeStandard(p);\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        P a = p[i], b = p[(i + 1) % n], c = p[(i + 2) % n];\n        if (orient(a, b, c) < 0) return false;\n        if (b.y != p[0].y && b.y < min(a.y, c.y)) return false;\n        if (b.y != p[0].y && a.y == b.y && b.y == c.y && a.x <= b.x && b.x <= c.x) return false;\n    }\n    return true;\n}\nT areaTriangle(P a, P b, P c) {\n    return abs(cross(b - a, c - a)) / 2.0;\n}\nT areaPolygon(vector<P> p) {\n    T res = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return abs(res) / 2.0;\n}\nT areaTwoCircle(C p, C q) {\n    int in = isInterCC(p, q);\n    if (abs(in) <= 2) return pow(min(p.r, q.r), 2) * PI;\n    if (in <= 4) return 0.0;\n    T d = abs(p - q), res = 0;\n    T pt = acos((p.r * p.r + d * d - q.r * q.r) / (2 * p.r * d));\n    res += p.r * p.r * pt - p.r * p.r * sin(pt) * cos(pt);\n    T qt = acos((q.r * q.r + d * d - p.r * p.r) / (2 * q.r * d));\n    res += q.r * q.r * qt - q.r * q.r * sin(qt) * cos(qt);\n    return res;\n}\nT calcElem(P a, P b, T r, bool triangle) {\n    if (triangle) return cross(a, b) / 2;\n    P tmp = b * P(a.x, -a.y);\n    return r * r * atan2(tmp.y, tmp.x) / 2;\n}\nT areaCircleTriange(C c, P a, P b) {\n    a -= c, b -= c;\n    if (eq(a, b)) return 0;\n    bool inA = (abs(a) < c.r + EPS);\n    bool inB = (abs(b) < c.r + EPS);\n    if (inA && inB) return calcElem(a, b, c.r, true);\n    L s(a, b);\n    auto cr = crosspointSC(s, C(P(0, 0), c.r));\n    if (cr.empty()) return calcElem(a, b, c.r, false);\n    auto p = cr[0], q = cr.back();\n    return calcElem(p, q, c.r, true) + calcElem(a, p, c.r, inA) + calcElem(q, b, c.r, inB);\n}\nT areaCirclePolygon(C c, vector<P> p) {\n    T res = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        res += areaCircleTriange(c, p[i], p[(i + 1) % n]);\n    }\n    return res;\n}\nP centroid(vector<P> p) {\n    P c; T sumA = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        T a = cross(p[i], p[(i + 1) % n]);\n        sumA += abs(a);\n        c += (p[i] + p[(i + 1) % n]) * a;\n    }\n    return 1.0 / 3.0 / sumA * c;\n}\n// If A is strictly inside P, return 1.\n// If A is on the boundary, return 2.\n// Else return 0.\nint inConvexCcw(vector<P> p, P a) {\n    int n = p.size();\n    P g = (p[0] + p[n / 2]) / T(2);\n    if (g == a) return 1;\n    P ga = a - g;\n    int l = 0, r = n;\n    while (r - l > 1) {\n        int m = (l + r) / 2;\n        P gl = p[l] - g, gm = p[m] - g;\n        if (cross(gl, gm) > EPS) {\n            if (cross(gl, ga) > -EPS && cross(gm, ga) < EPS) r = m;\n            else l = m;\n        } else {\n            if (cross(gl, ga) < EPS && cross(gm, ga) > -EPS) l = m;\n            else r = m;\n        }\n    }\n    r %= n;\n    int c = ccw(a, p[l], p[r]);\n    return (c == 2 || c == -2 || c == 0) ? 2 : c == -1 ? 0 : 1;\n}\nbool above(P a, P p) { return p.y >= a.y; }\nbool crossesRay(P a, P p, P q) {\n    return (above(a, q) - above(a, p)) * orient(a, p, q) > 0;\n}\n// If A is strictly inside P, return 1.\n// If A is on the boundary, return 2.\n// Else return 0.\nint inPolygon(vector<P> p, P a) {\n    int numCrossing = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        if (ccw(p[i], p[(i + 1) % n], a) == 0) return 2;\n        numCrossing += crossesRay(a, p[i], p[(i + 1) % n]);\n    }\n    return numCrossing & 1;\n}\nvector<P> convexHull(vector<P> p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(), p.end(), cmpX);\n    vector<P> res(2 * n);\n    for (int i = 0; i < n; res[k++] = p[i++])\n        while (k >= 2 && ccw(res[k - 2], res[k - 1], p[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; res[k++] = p[i--])\n        while (k >= t && ccw(res[k - 2], res[k - 1], p[i]) <= 0) --k;\n    res.resize(k - 1);\n    return res;\n}\nvector<P> convexHullCollinearOK(vector<P> p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(), p.end(), cmpX);\n    vector<P> res(2 * n);\n    for (int i = 0; i < n; res[k++] = p[i++])\n        while (k >= 2 && ccw(res[k - 2], res[k - 1], p[i]) == -1) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; res[k++] = p[i--])\n        while (k >= t && ccw(res[k - 2], res[k - 1], p[i]) == -1) --k;\n    res.resize(k - 1);\n    return res;\n}\nvector<P> convexCut(vector<P> p, L l) {\n    vector<P> res;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        int ccwc = ccw(l[0], l[1], p[i]);\n        if (ccwc != -1) res.push_back(p[i]);\n        int ccwn = ccw(l[0], l[1], p[(i + 1) % n]);\n        if (ccwc * ccwn == -1) res.push_back(crosspointLL(l, L(p[i], p[(i + 1) % n]))[0]);\n    }\n    return res;\n}\npair<int, int> convexDiameter(const vector<P>& p) {\n    int i = min_element(p.begin(), p.end()) - p.begin();\n    int j = max_element(p.begin(), p.end()) - p.begin();\n    int maxI, maxJ;\n    T maxD = 0;\n    for (int k = 0, n = p.size(); k < 2 * n; ++k) {\n        if (maxD < norm(p[i] - p[j]) - EPS) {\n            maxD = norm(p[i] - p[j]);\n            maxI = i;\n            maxJ = j;\n        }\n        if (cross(p[i] - p[(i + 1) % n], p[(j + 1) % n] - p[j]) < EPS) j = (j + 1) % n;\n        else i = (i + 1) % n;\n    }\n    return make_pair(maxI, maxJ);\n}\nT closest_pair(vector<P>& a, int l = 0, int r = -1) {\n    if (r < 0) {\n        r = a.size();\n        sort(a.begin(), a.end());\n    }\n    if (r - l <= 1) return abs(a[0] - a[1]);\n    int m = (l + r) >> 1;\n    T amx = a[m].x, d = min(closest_pair(a, l, m), closest_pair(a, m, r));\n    inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r, cmpY);\n    vector<P> b;\n    for (int i = l; i < r; ++i) {\n        if (abs(a[i].x - amx) > d - EPS) continue;\n        for (int j = 0, n = b.size(); j < n; ++j) {\n            if (a[i].y - b[n - j - 1].y > d - EPS) break;\n            d = min(d, abs(a[i] - b[n - j - 1]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\n/* EndPoint */\nstruct EndPoint {\n    P p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(P p, int seg, int st) : p(p), seg(seg), st(st) {}\n\n    bool operator<(const EndPoint& ep) const {\n        return (p.y == ep.p.y ? st < ep.st : p.y < ep.p.y);\n    }\n};\nint manhattanIntersection(vector<L> s, const T INF = numeric_limits<T>::max()) {\n    const int BTM = 0;\n    const int LFT = 1;\n    const int RGH = 2;\n    const int TOP = 3;\n\n    int n = s.size();\n    vector<EndPoint> ep;\n    for (int i = 0; i < n; ++i) {\n        if (s[i][0].y == s[i][1].y) {\n            if (s[i][0].x > s[i][1].x) {\n                swap(s[i][0], s[i][1]);\n            }\n        } else if (s[i][0].y > s[i][1].y) {\n            swap(s[i][0], s[i][1]);\n        }\n\n        if (s[i][0].y == s[i][1].y) {\n            ep.emplace_back(s[i][0], i, LFT);\n            ep.emplace_back(s[i][1], i, RGH);\n        } else {\n            ep.emplace_back(s[i][0], i, BTM);\n            ep.emplace_back(s[i][1], i, TOP);\n        }\n    }\n    sort(ep.begin(), ep.end());\n    set<T> bt;\n    bt.insert(INF);\n    int res = 0;\n    for (int i = 0; i < 2 * n; ++i) {\n        if (ep[i].st == TOP) {\n            bt.erase(ep[i].p.x);\n        } else if (ep[i].st == BTM) {\n            bt.insert(ep[i].p.x);\n        } else if (ep[i].st == LFT) {\n            auto b = bt.lower_bound(s[ep[i].seg][0].x);\n            auto e = bt.upper_bound(s[ep[i].seg][1].x);\n            res += distance(b, e);\n        }\n    }\n    return res;\n}\nC minimumCoveringCircle(vector<P> p) {\n    int n = p.size();\n    assert(n >= 1);\n    if (n == 1) return C(p[0], T(0));\n    mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n    shuffle(p.begin(), p.end(), mt);\n\n    auto makeCircle3 = [](const P& a, const P& b, const P& c) -> C {\n        T A = norm(b - c), B = norm(c - a), C = norm(a - b), S = cross(b - a, c - a);\n        P p = (A * (B + C - A) * a + B * (C + A - B) * b + C * (A + B - C) * c) / (4 * S * S);\n        return {p, abs(a - p)};\n    };\n\n    auto makeCircle2 = [](const P& a, const P& b) -> C {\n        P c = (a + b) / T(2);\n        return {c, abs(a - c)};\n    };\n\n    auto inCircle = [](const P& p, const C& c) -> bool {\n        return abs(p - c) <= c.r + EPS;\n    };\n\n    C res = makeCircle2(p[0], p[1]);\n    for (int i = 2; i < n; ++i) if (!inCircle(p[i], res)) {\n        res = makeCircle2(p[0], p[i]);\n        for (int j = 1; j < i; ++j) if (!inCircle(p[j], res)) {\n            res = makeCircle2(p[i], p[j]);\n            for (int k = 0; k < j; ++k) if (!inCircle(p[k], res)) {\n                res = makeCircle3(p[i], p[j], p[k]);\n            }\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    int n;\n    while (cin >> n, n) {\n        vector<C> cs(n);\n        REP (i, n) cin >> cs[i];\n        vector<vector<T>> dp(n + 1, vector<T>(2, INF));\n        vector<vector<P>> cps(n - 1);\n        REP (i, n - 1) cps[i] = crosspointCC(cs[i], cs[i + 1]);\n        cps.insert(cps.begin(), vector<P>{cs[0], cs[0]});\n        cps.emplace_back(vector<P>{cs[n - 1], cs[n - 1]});\n\n        dp[0][0] = dp[0][1] = 0;\n        REP (i, n) REP (j, 2) {\n            REP (k, i + 1) REP (l, 2) {\n                bool ok = true;\n                FOR (m, k, i + 1) {\n                    auto p = crosspointSS(L(cps[i + 1][j], cps[k][l]), L(cps[m][0], cps[m][1]));\n                    ok &= (!p.empty());\n                }\n                if (ok) {\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[k][l] + abs(cps[i + 1][j] - cps[k][l]));\n                }\n            }\n        }\n        cout << dp[n][0] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n     \n    Point operator * (Point p){\n        return Point(p.x*x-p.y*y,p.x*y+p.y*x);\n    }\n\n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n    \n    Point operator = (Point p){\n        x = p.x;\n        y = p.y;\n        return *this;\n    }\n\n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n    //?????????????????§?????????2???\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n    //?????????????????§??????\n    return sqrt(norm(p));\n}\nPoint UnitVector(Point a){\n    //??????????????????\n    return a/pabs(a);\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //?????????\n    double r; //??????\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a???b ??§???????¨?????????????c ccw\n    if(cross(b,c) < 0)return -1; //a???b ??§????¨?????????????c ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\n\nPoint projection(Line l, Point p){\n    double t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + (l[0]-l[1])*t;\n}\n\nPoint reflection(Line l, Point p){\n    return p + (projection(l,p)-p)*2.0; \n}\n\nbool intersectSS(Line l,Line m){\n    //l??¨m??????????????????????????????\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<EPS)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<EPS);\n}\n\nbool intersectSP(Line l, Point p){\n    //??????l??¨???p?????????????????????\n    return !ccw(l[0],l[1],p);\n}\n\ndouble distanceLP(Line l,Point p){\n    //??????l??¨???p????????¢\n    p = p - l[0];\n    l[1] = l[1] - l[0];\n    if(intersectSP(l,p))return 0.0;\n    return fabs(cross(p,l[1])/pabs(l[1]));\n}\n\nbool intersectLL(Line l,Line m){\n    return fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //????????§??????\n            fabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //????????????\n}\n\nbool intersectCP(Circle c,Point p){\n    //???c??¨???p???????????????\n    //true->???c????????¨??????p????????¨????????????.\n    return fabs(pabs(p-c.p)-c.r)<EPS;\n}\n\nint intersectCL(Circle c,Line l,Point *p,Point *q){\n    if(norm(projection(l,c.p) - c.p) - c.r*c.r > EPS)return 0;\n    double d1 = pabs(c.p-l[0]);\n    double d2 = pabs(c.p-l[1]);\n    if(d1 < c.r + EPS && d2 < c.r + EPS)return 0;\n    if(d1 < c.r - EPS && d2 > c.r+EPS\n        || d1 > c.r + EPS && d2 < c.r -EPS)return 1;\n    Point h = projection(l,c.p);\n    if(dot(l[0] - h,l[1] - h) < 0)return 2;\n    return 0;\n}\n\nint intersectCC(Circle a,Circle b,Point *p,Point *q){\n    double dist = pabs(a.p-b.p);\n    if(dist < fabs(a.r-b.r) || dist > a.r+b.r){\n        //????????????????????´??????????????¨???\n        //????????????????????¨???????????¨???\n        *p = Point(1e15,1e15);\n        *q = Point(1e15,1e15);\n        return 0;\n    }\n    else if(fabs(dist-a.r-b.r) < EPS){\n        //??????1?????§????????£???????????¨???\n        Point way;\n        way = b.p-a.p;\n        *p = a.p+UnitVector(way)*a.r;\n        *q = *p;\n        return 1;\n    }\n    else{\n        //??????2?????§????????£???????????¨???\n        if(a.r < b.r){\n            swap(a.r,b.r);\n            swap(a.p,b.p);\n        }\n        double s = (a.r + b.r + dist) / 2.0 ;\n        double area = sqrt(s * (s - a.r) * (s - b.r) * (s - dist));\n        double h = 2.0 * area / dist;\n\n        Point  v = b.p-a.p;\n        v = UnitVector(v);\n        Point  m = a.p + (v*sqrt(a.r*a.r-h*h));\n        Point  n = v * Point(0.0,1.0);\n        \n        *p = m + (n * h);\n        *q = m - (n * h);\n        return 2;\n    }\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5; //?????????????????¨??????????????§??¨???\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea; //?????????????????¨??????????????§??¨???\n}\n\nPoint crosspoint(Line l,Line m){\n    //??????l??¨??????m?????????\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nPolygon ConvexHull(Polygon v){\n    //??????????????????\n    int n = v.size();\n    int k = 0;\n    sort(v.begin(),v.end());\n    Polygon e(2*n);\n    for(int i=0;i<n;e[k++]=v[i++])\n        while(k>=2&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n    for(int i=n-2,t=k+1;i>=0;e[k++]=v[i--])\n        while(k>=t&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n    e.resize(k-1);\n    return e;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to,double _cost){\n        to = _to;\n        cost = _cost;\n    }\n    bool operator < (const edge &a)const{\n        return a.cost<cost;\n    }\n};\ntypedef pair<Point,int> P;\n\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        Circle C[128];\n        vector < pair < Point , int >  > points;\n        Point start,goal;\n        rep(i,N){\n            double x,y,r;\n            scanf(\"%lf%lf%lf\",&x,&y,&r);\n            if(i == 0){\n                start = Point(x,y);\n            }\n            if(i == N-1){\n                goal = Point(x,y);\n            }\n            C[i] = Circle(Point(x,y),r);\n        }\n        vector < Line > arc;\n        points.PB(P(start,0));\n        rep(i,N){\n            reps(j,i+1,N){\n                Point p,q;\n                int tmp = intersectCC(C[i],C[j],&p,&q);\n                if(tmp > 0){\n                    points.PB(P(p,j));\n                    points.PB(P(q,j));\n                    Line l;\n                    l.PB(p);l.PB(q);\n                    arc.PB(l);\n         //         cout << p.x << \" \" << p.y << \"\\n\";\n         //         cout << q.x << \" \" << q.y << \"\\n\";\n                }\n            }\n        }\n       // puts(\"$$$$$$$$$$$$$$$$$$$$$$\");\n        points.PB(P(goal,N-1));\n        int goal_ID = points.size()-1;\n\n        vector< edge > G[250];\n        rep(i,points.size()){\n            reps(j,i+1,points.size()){\n                double dist = pabs(points[i].fi-points[j].fi);\n                Line l;\n                l.PB(points[i].fi);\n                l.PB(points[j].fi);\n                int cnt = 0;\n                Point p,q;\n                bool flg = true;\n        //        cout << \"&\" <<points[i].se+1 << \" \" << points[j].se << \"\\n\";\n                for(int k = points[i].se+1; k < points[j].se+1; k++){\n                    bool a = true;\n                    a = intersectSS(l,arc[k-1]);\n                    //cout << a << \"\\n\";\n                    if(!a){\n                        flg = false;\n                    }\n                }\n                if(!flg)continue;\n                G[i].PB(edge(j,dist));\n                G[j].PB(edge(i,dist));\n            //    cout << i << \" \" << j << \" \" << dist << \" \"<< flg <<\"\\n\";\n            }\n        }\n\n        double d[250];\n        fill(d,d+250,INF);\n        priority_queue < edge > Q;\n        Q.push(edge(0,0.0));\n\n        while(!Q.empty()){\n            edge e = Q.top();Q.pop();\n            if(d[e.to] != INF)continue;\n            d[e.to] = e.cost;\n            rep(i,G[e.to].size()){\n                Q.push(edge(G[e.to][i].to,G[e.to][i].cost+d[e.to]));\n            }\n        }\n\n        printf(\"%.4lf\\n\",d[goal_ID]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst double eps = 1e-8, inf = 1e+8;\n\ntemplate<typename T> void chmin(T &t, T f){if(t > f)t = f;}\ntemplate<typename T> T sqr(T x){return x*x;}\n\ndouble cross(const Point &a, const Point &b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : vector<Point> {\n    Line(const Point &a, const Point &b){\n        push_back(a); push_back(b);\n    }\n};\n\nbool interLS(const Line &l, const Line &s){\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < eps;\n}\n\nstruct Circle : Point {\n    double r;\n    Circle(const Point &a, double r):Point(a), r(r){}\n};\n\nvector<Point> xptCC(const Circle &c1, const Circle &c2){\n    vector<Point> res;\n    double d = abs(c1-c2);\n    if(d < eps)return res;\n    double rc = (sqr(d) + sqr(c1.r) - sqr(c2.r)) / (2.*d);\n    double rs = sqrt(sqr(c1.r) - sqr(rc));\n    Point diff = (c2-c1) / d;\n    res.push_back(c1 + diff * Point(rc, rs));\n    res.push_back(c1 + diff * Point(rc, -rs));\n    return res;\n}\n\nostream& operator<<(ostream &os, const Point &a){\n    return os << \"(\" << a.real() << \", \" << a.imag() << \")\";\n}\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n\nint n;\nvector<Circle> cir;\nvector<vector<double> > dist;\n\ndouble solve(){\n    dist.assign(2*n+2, vector<double>(2*n+2, inf));\n    vector<Point> ps;\n    vector<Line> seg;\n    rep(i, n-1){\n        vector<Point> xpt(xptCC(cir[i], cir[i+1]));\n        ps.insert(ps.end(), all(xpt));\n        seg.emplace_back(xpt[0], xpt[1]);\n        rep(j, i){\n            for(auto u: {2*i, 2*i+1})for(auto v: {2*j, 2*j+1}){\n                bool ok = true;\n                for(int k=j; k<i; ++k){\n                    if(!interLS(Line(ps[u], ps[v]), seg[k])){\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok)dist[u][v] = dist[v][u] = abs(ps[u]-ps[v]);\n            }\n        }\n    }\n    //---------- v FIX ----------\n    rep(i, n-1){\n        for(auto u: {2*i, 2*i+1}){\n            bool ok = true;\n            rep(k, i){\n                if(!interLS(Line(cir[0], ps[u]), seg[k])){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok)dist[2*n][u] = dist[u][2*n] = abs(cir[0]-ps[u]);\n        }\n    }\n    rep(i, n-1){\n        for(auto u: {2*i, 2*i+1}){\n            bool ok = true;\n            for(int k=n-2; k>i; --k){\n                if(!interLS(Line(cir.back(), ps[u]), seg[k])){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok)dist[2*n+1][u] = dist[u][2*n+1] = abs(cir.back()-ps[u]);\n        }\n    }\n    bool ok = true;\n    rep(i, n-1)if(!interLS(Line(cir[0], cir.back()), seg[i])){\n        ok = false;\n        break;\n    }\n    if(ok)return abs(cir[0]-cir.back());\n    // ---------- ^ FIX ----------\n    rep(k, 2*n+2)rep(i, 2*n+2)rep(j, 2*n+2){\n        chmin(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n    return dist[2*n][2*n+1];\n}\n\nint main(){\n    while(cin >> n, n){\n        cir.clear();\n        rep(i, n){\n            int x, y, r;\n            cin >> x >> y >> r;\n            cir.emplace_back(Point(x, y), r);\n        }\n        cout << fixed << setprecision(6) << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<int, double> pid;\ntypedef pair<double, int> pdi;\ntypedef pair<ll, ll> pl;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n\n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nint n;\nP p[100];\nD r[100];\nstruct CP {\n    P p;\n    int i;\n    double dis;\n};\nvector<CP> cps;\nvector<pid> e[200];\n\nvoid solve() {\n    cps.clear();\n    rep(i,200) e[i].clear();\n    rep(i,n) {\n        D x, y;\n        cin >> x >> y >> r[i];\n        p[i] = P(x, y);\n    }\n    {\n        CP cp;\n        cp.p = p[0];\n        cp.i = 0;\n        cp.dis = 0.0;\n        cps.push_back(cp);\n    }\n    rep(i,n-1) {\n        VP hoge = crosspointCC(p[i], r[i], p[i+1], r[i+1]);\n        rep(j,hoge.size()) {\n            CP cp;\n            cp.p = hoge[j];\n            cp.i = i+1;\n            cp.dis = inf;\n            cps.push_back(cp);\n        }\n    }\n    {\n        CP cp;\n        cp.p = p[n-1];\n        cp.i = n;\n        cp.dis = inf;\n        cps.push_back(cp);\n    }\n    rep(i,cps.size()) {\n        for (int j = i+1; j < cps.size(); j++) {\n            CP cp1 = cps[i];\n            CP cp2 = cps[j];\n            if (cp1.i == cp2.i) continue;\n            bool ok = true;\n            double pred = inf;\n            for (int k = cp1.i; k < cp2.i; k++) {\n                if (!isecSS(cp1.p, cp2.p, cps[2*k+1].p, cps[2*k+2].p)) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (!ok) continue;\n            double dis = abs(cp1.p-cp2.p);\n            //cerr << i << \" \" << j << \" \" << dis << endl;\n            //cerr << i << \" \" << j << endl;\n            e[i].push_back(pid(j, dis));\n            e[j].push_back(pid(i, dis));\n        }\n    }\n    priority_queue<pdi, vector<pdi>, greater<pdi>> pque;\n    pque.push(pdi(0.0, 0));\n    while (!pque.empty()) {\n        pdi p = pque.top(); pque.pop();\n        if (cps[p.second].dis+EPS < p.first) continue;\n        rep(j,e[p.second].size()) {\n            int to = e[p.second][j].first;\n            double cost = e[p.second][j].second;\n            if (cps[to].dis > cps[p.second].dis + cost) {\n                cps[to].dis = cps[p.second].dis + cost;\n                pque.push(pdi(cps[to].dis, to));\n            }\n        }\n    }\n    cout << cps[cps.size()-1].dis << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    //freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    while (cin >> n) {\n        if (n == 0) break;\n        solve();\n    }\n    //cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle():c(point(0, 0)), r(0.0){}\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn s.a + (s.b - s.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nvector<circle> circles;\nvector<vector<point> > c_p;\n\nstruct edge {\n\tint to;\n\tdouble cost;\n\tedge(int t, double c):to(t), cost(c){}\n};\ntypedef pair<int, int> P;\n\nvector<vector<edge> > es;\n\ndouble dijkstra(int s, int t) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<double> d(es.size(), INT_MAX);\n\tque.push(P(0, s));\n\td[s] = 0;\n\t\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\n\t\tif(v == t)\n\t\t\treturn d[t];\n\n\t\tfor(int i = 0; i < es[v].size(); ++i) {\n\t\t\tedge& e = es[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\ninline bool in_range(const segment& s, const point& p, const point& q) {\n\tint tmp = ccw(s.a, s.b, p) * ccw(s.a, s.b, q);\n\treturn tmp == -1 || tmp == 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; scanf(\"%d\", &n), n;) {\n\t\tcircles.clear();\n\t\tcircles.resize(n);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x, y, r;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &r);\n\t\t\tcircles[i] = circle(point(x, y), r);\n\t\t}\n\n\t\tc_p.clear();\n\t\tc_p.resize(n - 1, vector<point>(2));\n\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\tvector<point> tmp = crosspoint(circles[i], circles[i + 1]);\n\t\t\tc_p[i][0] = tmp[0];\n\t\t\tc_p[i][1] = tmp[1];\n\t\t}\n\n\t\tes.clear();\n\t\tes.resize(2 * n + 2);\n\n\t\tfor(int i = 0; i < n - 1; ++i)\n\t\t\tfor(int j = 0; j <= 1; ++j)\n\t\t\t\tfor(int k = i + 1; k < n - 1; ++k)\n\t\t\t\t\tfor(int l = 0; l <= 1; ++l) {\n\t\t\t\t\t\tconst segment s(c_p[i][j], c_p[k][l]);\n\t\t\t\t\t\tfor(int m = i + 1; m < k; ++m)\n\t\t\t\t\t\t\tif(!in_range(s, c_p[m][0], c_p[m][1]))\n\t\t\t\t\t\t\t\tgoto ng;\n\n\t\t\t\t\t\tes[i + j * n].push_back(edge(k + l * n, dist(s.a, s.b)));\n\t\t\t\t\tng:;\n\t\t\t\t\t}\n\n\n\t\tfor(int i = 0; i < n - 1; ++i)\n\t\t\tfor(int j = 0; j <= 1; ++j) {\n\t\t\t\tconst segment s(circles[0].c, c_p[i][j]);\n\t\t\t\tfor(int m = 0; m < i; ++m)\n\t\t\t\t\tif(!in_range(s, c_p[m][0], c_p[m][1]))\n\t\t\t\t\t\tgoto ng2;\n\n\t\t\t\tes[2 * n].push_back(edge(i + j * n, dist(s.a, s.b)));\n\t\t\tng2:;\n\t\t\t}\n\n\n\t\tfor(int i = 0; i < n - 1; ++i)\n\t\t\tfor(int j = 0; j <= 1; ++j) {\n\t\t\t\tconst segment s(c_p[i][j], circles[n - 1].c);\n\t\t\t\tfor(int m = i + 1; m < n - 1; ++m) {\n\t\t\t\t\tif(!in_range(s, c_p[m][0], c_p[m][1]))\n\t\t\t\t\t\tgoto ng3;\n\t\t\t\t}\n\t\t\t\tes[i + j * n].push_back(edge(2 * n + 1, dist(s.a, s.b)));\n\t\t\tng3:;\n\t\t\t}\n\n\t\t{\n\t\t\tconst segment s(circles[0].c, circles[n - 1].c);\n\t\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\t\tif(!in_range(s, c_p[i][0], c_p[i][1]))\n\t\t\t\t\tgoto ng4;\n\t\t\t}\n\t\t\tes[2 * n].push_back(edge(2 * n + 1, dist(s.a, s.b)));\n\t\tng4:;\n\t\t}\n\n\t\tprintf(\"%.10lf\\n\", dijkstra(2 * n, 2 * n + 1));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-6;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\n\nstruct circle{\n    point o;\n    long double r;\n    circle(){}\n    circle(const point o,const long double r):o(o),r(r){}\n};\n\n//2??????????????????\nint icc(const circle &c, const circle &d) {\n    /*\n      1 : intersect\n      0 : distinct\n      -1: c < d\n      -2: c > d\n\n      intersect or contain : true\n      distinct             : false\n    */\n    long double od = abs((c.o-d.o));\n    return c.r+d.r<od+eps ? 0 : od+c.r<d.r+eps ? -1 : od+d.r<c.r+eps ? -2 : 1;\n}\n\n\n//?????¨??´??????????????????\nint icl(const circle &c, const line &l) {\n    /*\n      number of crosspoint\n    */\n    long double d = norm(projection(l,c.o)-c.o)-c.r*c.r;\n    return d>eps ? 0 : std::abs(d)<eps ? 1 : 2;\n}\n\n\n//?????¨?????????????????????\nint ics(const circle &c, const line &s) {\n    /*\n      0 : distinct\n      1 : intersect 1 point\n      2 : s is in c\n    */\n    if (!icl(c, s)) return 0;\n    long double da = abs(s.first - c.o);\n    long double db = abs(s.second - c.o);\n    if ((da < c.r-eps) and (db < c.r-eps)) return 0;\n    if ((da < c.r-eps) xor (db < c.r-eps)) return 1;\n    return ccw(s.first, s.second, projection(s,c.o)) ? 0 : 2;\n}\n\n//?????¨????????????????±???????\npair<point,point> ccc(const circle &c1, const circle &c2) {\n    if(!icc(c1,c2)) return pair<point,point>(c1.o,c2.o);\n    long double w = abs(c2.o-c1.o), th = arg(c2.o-c1.o);\n    long double dth = acosl((c1.r*c1.r+w*w-c2.r*c2.r)/(2.*c1.r*w));\n    return pair<point,point>(c1.o+polar(c1.r,th-dth),c1.o+polar(c1.r,th+dth));\n}\n\n//????????´????????????\npair<point,point> ccl(const circle &c, const line &l) {\n    point h = projection(l,c.o), p = sqrtl(c.r*c.r-norm(h-c.o))*(l.second-l.first)/abs(l.second-l.first);\n    return pair<point,point>(h-p,h+p);\n}\n\n\nvoid solve(int n){\n    vector<circle> cs;\n    rep(i,0,n){\n        long double x,y,r;\n        cin >> x >> y >> r;\n        cs.push_back(circle(point(x,y),r));\n    }\n    vector<point> ps;\n    vector<int> idx;\n    vector<line> ls;\n    ps.push_back(cs[0].o);\n    idx.push_back(0);\n    rep(i,1,n){\n        auto tmp=ccc(cs[i],cs[i-1]);\n        ps.push_back(tmp.first);\n        ps.push_back(tmp.second);\n        idx.push_back(i-1);\n        idx.push_back(i-1);\n        ls.push_back(line(ps[i*2-1],ps[i*2]));\n    }\n    ps.push_back(cs.back().o);\n    idx.push_back(n-1);\n\n    long double dist[200][200];\n    fill_n((long double*)dist,200*200,infll);\n    rep(i,0,2*n) dist[i][i]=0;\n    rep(i,0,2*n) rep(j,i+1,2*n) dist[i][j]=dist[j][i]=abs(ps[i]-ps[j]);\n    rep(i,0,2*n) rep(j,i+1,2*n){\n        line s=line(ps[i],ps[j]);\n        bool f=true;\n        rep(k,idx[i]+(i==0?0:1),idx[j]){\n            if(intersectSS(s,ls[k])) continue;\n            f=false;\n            break;\n        }\n        if(!f) dist[i][j]=dist[j][i]=infll;\n    }\n\n    rep(k,0,2*n) rep(i,0,2*n) rep(j,0,2*n) dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    cout << dist[0][2*n-1] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF 100000000\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#  define __builtin_popcount __popcnt\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n//// i/o ////\ntemplate <class T> class vevector : public vector<vector<T>> {\npublic: vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { }\n};\ntemplate <class T> class vevevector : public vector<vevector<T>> {\npublic: vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { }\n};\ntemplate <class T> class vevevevector : public vector<vevevector<T>> {\npublic: vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { }\n};\n\ntemplate <class T1, class T2>\ninline istream & operator>>(istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tauto circles = read<Circle>(N);\n\t\tif (!N) { break; }\n\n\t\tP2 firstPoint = circles[0].c;\n\t\tP2 lastPoint = circles[N - 1].c;\n\n\t\tvector<pair<P2, P2>> gates;\n\t\tgates.emplace_back(firstPoint, firstPoint);\n\t\tREP(i, N-1) gates.push_back(crossPoint(circles[i], circles[i + 1]));\n\t\tgates.emplace_back(lastPoint, lastPoint);\n\n\t\t// { for (auto g : gates) write(g.first, g.second); }\n\n\t\tvevector<double> distanc(N + 1, 2, INF);\n\t\tdistanc[0][0] = distanc[0][1] = 0;\n\n\t\tREP(i, N) // 現在地\n\t\t{\n\t\t\tconst P2 srcs[] = { gates[i].first, gates[i].second };\n\t\t\tFOR(j, i + 1, N + 1) // 行き先\n\t\t\t{\n\t\t\t\tconst P2 dsts[] = { gates[j].first, gates[j].second };\n\t\t\t\t\n\t\t\t\tREP(_, 4)\n\t\t\t\t{\n\t\t\t\t\tconst P2 &src = srcs[_ % 2];\n\t\t\t\t\tconst double pred = distanc[i][_ % 2];\n\t\t\t\t\tconst P2 &dst = dsts[_ / 2];\n\t\t\t\t\tdouble &totald = distanc[j][_ / 2];\n\n\t\t\t\t\t// iからjの間にあるゲートを全て通過できるなら直通で来てよい\n\t\t\t\t\t{\n\t\t\t\t\t\tbool condition_all_green = true;\n\t\t\t\t\t\tFOR(k, i + 1, j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcondition_all_green &= clockwise(src, dst, gates[k].first) <= 0;\n\t\t\t\t\t\t\tcondition_all_green &= clockwise(src, dst, gates[k].second) >= 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (condition_all_green)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotald = min(totald, pred + (dst - src).length());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// { for (auto d : distanc) write(d); }\n\t\t}\n\n\t\tprintf(\"%.8f\\n\", distanc.back().back());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple){\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>{\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b,QF &&qf) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1,qf);\n\t}*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l,int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<C> c(n);\n\t\trep(i, n) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tc[i] = C{ P{ (double)x,(double)y },(double)r };\n\t\t}\n\t\tvector<double[2]> dp(n - 1);\n\t\tvector<L> s(n - 1);\n\t\trep(i, n - 1) {\n\t\t\tauto x = is_cc(c[i], c[i + 1]);\n\t\t\ts[i] = { x[0],x[1] };\n\t\t}\n\t\tVP p = { c[n - 1].p };\n\t\trep1(i, n - 2) {\n\t\t\tdp[i][0] = min(dp[i - 1][0] + abs(s[i].a - s[i - 1].a), dp[i - 1][1] + abs(s[i].a - s[i - 1].b));\n\t\t\tdp[i][1] = min(dp[i - 1][0] + abs(s[i].b - s[i - 1].a), dp[i - 1][1] + abs(s[i].b - s[i - 1].b));\n\t\t}\n\t\tint prev = (dp[n - 2][0] < dp[n - 2][1] ? 0 : 1);\n\t\tp.push_back(prev ? s[n - 2].b : s[n - 2].a);\n\t\trrep(i, n - 2) {\n\t\t\tprev = (dp[i][0] + abs(s[i].a - (prev ? s[i + 1].b : s[i + 1].a)) == dp[i + 1][prev] ? 0 : 1);\n\t\t\tp.push_back(prev ? s[i].b : s[i].a);\n\t\t}\n\t\tp.push_back(c[0].p);\n\t\treverse(ALL(p));\n\t\tVP ans = { p[0] };\n\t\tvi pos;\n\t\trep1(i, n - 1) {\n\t\t\tif (!isis_ls({ ans.back(),p[i + 1] }, s[i - 1])) {\n\t\t\t\twhile (!pos.empty() && isis_ls({ ans[ans.size() - 2],p[i] }, s[pos.back()]))ans.pop_back(), pos.pop_back();\n\t\t\t\tans.push_back(p[i]);\n\t\t\t\tpos.push_back(i - 1);\n\t\t\t}\n\t\t}\n\t\tans.push_back(p.back());\n\t\tpos.push_back(n - 1);\n\t\tlong double a = 0;\n\t\trep(i, ans.size() - 1)a += abs(ans[i] - ans[i + 1]);\n\t\tint p_pos = 0;\n\t\tpos.insert(pos.begin(), -1);\n\t\trep(i, pos.size() - 1) {\n\t\t\trep(j, pos[i + 1] - pos[i] - 1) {\n\t\t\t\tif (!isis_ls({ ans[i],ans[i + 1] }, s[pos[i] + j + 1])) {\n\t\t\t\t\tint b = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << a << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define REP(i,a) for(int i=0;i<a;i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\nconst double PI = acos(-1);\n\nP unit(P p){return p / abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\ndouble dot(P x,P y){return real(conj(x)*y);}\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\ndouble arg(double a,double b,double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;\n  if (cross(b,c)<-EPS) return -1;\n  if (dot(b, c)<-EPS) return 2;\n  if (abs(b)<abs(c)) return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nint cpr(C a,C b){\n  double d = abs(a.fs-b.fs);\n  if(a.sc+b.sc + EPS < d)return -1;\n  if(b.sc+d + EPS < a.sc)return 1;\n  if(a.sc+d + EPS < b.sc)return 2;\n  if(abs(a.sc+b.sc - d) < EPS)return -3;\n  if(abs(b.sc+d - a.sc) < EPS)return 3;\n  if(abs(a.sc+d - b.sc) < EPS)return 4;\n  return 0;\n}\n\nvector<P> cp_cir_to_cir(C a, C b){\n  vector<P> v;\n  int pos = cpr(a,b);\n  if(pos==0){\n    double s = arg(b.sc,abs(b.fs-a.fs),a.sc);\n    P x = a.sc * unit(b.fs - a.fs);\n    v.pb(a.fs + rotate(x,s));\n    v.pb(a.fs + rotate(x,-s));\n  }else if(abs(pos) == 3){\n    v.pb(a.fs + a.sc * unit(b.fs-a.fs));\n  }else if(pos == 4){\n    v.pb(a.fs + a.sc * unit(b.fs-a.fs));\n  }\n  return v;\n}\n\nint main(){\n  int n,pn;\n  double d[200][200];\n  C c[100];\n  L l[100],tmp;\n  P p[200];\n  vector<P> v;\n\n  while(scanf(\"%d\",&n),n){\n      REP(i,n)scanf(\"%lf%lf%lf\",&c[i].fs.real(),&c[i].fs.imag(),&c[i].sc);\n\n    p[0] = c[0].fs;\n    pn = 1;\n    for(int i=1;i<n;i++){\n      v = cp_cir_to_cir(c[i-1],c[i]);\n      p[pn] = v[0]; p[pn+1] = v[1];\n      l[i-1] = L(v[0],v[1]);\n      pn += 2;\n    }\n    p[pn] = c[n-1].fs;\n    pn++;\n    \n    for(int i=0;i<pn;i++)\n      for(int j=0;j<pn;j++)d[i][j] = 1e6;\n\n    for(int i=1;i<pn;i++){\n      tmp = L(p[0],p[i]);\n      bool f = true;\n      for(int k=0;k<(i-1)/2;k++){\n\tf &= is_cp(tmp,l[k]);\n\tif(!f)break;\n      }\n      if(f)d[0][i] = abs(p[0]-p[i]);\n      else d[0][i] = 1e6;\n    }\n    \n    for(int i=1;i<pn-1;i++){\n      for(int j=i+1;j<pn-1;j++){\n\tif(i&1 && j==i+1)continue;\n\ttmp = L(p[i],p[j]);\n\tbool f = true;\n\tfor(int k=(i+1)/2;k<(j-1)/2;k++){\n\t  f &= is_cp(tmp,l[k]);\n\t  if(!f)break;\n\t}\n\tif(f)d[i][j] = abs(p[i]-p[j]);\n\telse d[i][j] = 1e6;\n      }\n    }\n\n    for(int i=1;i<pn-1;i++){\n      tmp = L(p[i],p[pn-1]);\n      bool f = true;\n      for(int k=(i+1)/2;k<n-1;k++){\n\tf &= is_cp(tmp,l[k]);\n\tif(!f)break;\n      }\n      if(f)d[i][pn-1] = abs(p[i]-p[pn-1]);\n      else d[i][pn-1] = 1e6;\n    }\n\n    REP(k,pn)REP(i,pn)REP(j,pn)d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    printf(\"%lf\\n\",d[0][pn-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define INF 2147483647\nusing namespace std;\ntypedef complex<double> xy_t;\n\nclass vertex\n{\npublic:\n  int n;\n  double d;\n  vertex()\n  {\n    n=-1;\n    d=0;\n  }\n  vertex(int v,double dis)\n  {\n    n=v;\n    d=dis;\n  }\n  bool operator<(const vertex b) const\n  {\n    return (fabs(d-b.d)>0.00001 && d<b.d);\n  }\n};\nclass edge\n{\npublic:\n  int vt;\n  double d;\n  edge()\n  {\n    vt=-1;\n    d=0;\n  }\n  edge(int v,double dis)\n  {\n    vt=v;\n    d=dis;\n  }\n  /*bool operator<(const vertex b) const\n  {\n    return (fabs(d-b.d)>0.00001 && d<b.d)\n  }*/\n};\n\n\n\nclass circle\n{\npublic:\n  xy_t center;\n  int r;\n  circle()\n  {\n    center=xy_t(0,0);\n    r=0;\n  }\n  circle(int x, int y, int rad)\n  {\n    center=xy_t(x,y);\n    r=rad;\n  }\n};\npriority_queue<vertex> Q;\nvector<edge> E[202];\nint n;\ncircle circles[101];\nxy_t intercept[202];\ndouble dist[202];\n\nxy_t cross(circle C_1,circle C_2,bool p)\n{\n  int a=C_1.center.real();\n  int b=C_1.center.imag();\n  int r=C_1.r;\n  int c=C_2.center.real();\n  int d=C_2.center.imag();\n  int R=C_2.r;\n  int A=2*(a-c);\n  int B=2*(b-d);\n  int C=R*R-r*r+a*a+b*b-c*c-d*d;\n  double x,y;\n  if (B==0)\n  {\n    x=1.0l*C/(1.0l*A);\n    double BB=-2*b;\n    double CC=b*b-r*r+x*x-2*a*x+a*a;\n    double delta=BB*BB-4*CC;\n    if (p==true)\n      y=(-BB+sqrt(delta))/(2.0l);\n    else\n      y=(-BB-sqrt(delta))/(2.0l);\n  }\n  else\n  {\n    double AA=A*A+B*B;\n    double BB=-2*A*C-2*a*B*B+2*b*A*B;\n    double CC=-B*B*(r*r-a*a-b*b)-2*b*B*C+C*C;\n    double delta=BB*BB-4*AA*CC;\n    //cout<<AA<<' '<<BB<<' '<<CC<<endl;\n    if (p==true)\n      x=(-BB+sqrt(delta))/(2.0l*AA);\n    else\n      x=(-BB-sqrt(delta))/(2.0l*AA);\n    y=(C-A*x)/(B);\n  }\n  return xy_t(x,y);\n}\nint calc()\n{\n  int count=0;\n  intercept[count++]=circles[0].center;\n  cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  for(int i=1;i<n;i++)\n  {\n    intercept[count++]=cross(circles[i-1],circles[i],false);\n    cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n    intercept[count++]=cross(circles[i-1],circles[i],true);\n    cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  }\n  intercept[count++]=circles[n-1].center;\n  cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  return count;\n}\n\ndouble dis(int i,int j)\n{\n  return abs(intercept[i]-intercept[j]);\n}\n\ndouble cross_product(xy_t a,xy_t b)\n{\n  return (conj(a)*b).imag();\n}\n\nbool isleft(int a, int b, int c)\n{\n  xy_t a1=intercept[b]-intercept[a];\n  xy_t a2=intercept[c]-intercept[b];\n  return cross_product(a1,a2)>0;\n}\n\nbool iszero(int a, int b, int c)\n{\n  xy_t a1=intercept[b]-intercept[a];\n  xy_t a2=intercept[c]-intercept[b];\n  return abs(cross_product(a1,a2))<0.00001;\n}\n\nbool legal(int i,int j)\n{\n  for(int k=(i+3)/2;k<=(j-1)/2;k++)\n  {\n    //if(!iszero(i,2*k,j)&&!iszero(i,2*k-1,j)&&isleft(i,2*k,j)==isleft(i,2*k-1,j))\n    if(isleft(i,2*k,j)==isleft(i,2*k-1,j))\n      return false;\n  }\n  return true;\n}\nvoid make_edge(int n)\n{\n  for(int i=0;i<n;i++)\n  {\n    E[i].clear();\n    for(int j=i+1;j<n;j++)\n    {\n      if(legal(i,j))\n      {\n        E[i].push_back(edge(j,dis(i,j)));\n        cout<<i<<\",\"<<j<<\",\"<<dis(i,j)<<endl;\n      }\n    }\n  }\n}\nvoid dijkstra(int nofv)\n{\n  for(int i=0;i<nofv;i++)\n    dist[i]=INF;\n  dist[0]=0;\n  Q.push(vertex(0,dist[0]));\n  while(!Q.empty())\n  {\n    vertex now=Q.top();\n    Q.pop();\n    int nowv=now.n;\n    for(vector<edge>::iterator it=E[nowv].begin();it!=E[nowv].end();++it)\n    {\n      int vt=(*it).vt;double d=(*it).d;\n      if (dist[vt]>dist[nowv]+d)\n      {\n        dist[vt]=dist[nowv]+d;\n        Q.push(vertex(vt,dist[vt]));\n      }\n    }\n  }\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if(n==0) break;\n    for(int i=0;i<n;i++)\n    {\n      int x,y,r;\n      cin>>x>>y>>r;\n      circles[i]=circle(x,y,r);\n    }\n    int nofv=calc();\n    make_edge(nofv);\n    dijkstra(nofv);\n    cout<<dist[nofv-1]<<endl;\n  }\n\n  //cout<<cross(circle(851,443,17),circle(856,419,17),0)<<endl;\n  //cout<<cross(circle(851,443,17),circle(856,419,17),1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<queue>\n#include<set>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#define Loop(i, n) for (int i = 0; i < int(n); i++)\n#define INF INFINITY\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\nconst double eps = 1e-7;\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool fge(double x, double y) { return x >= y - eps; }\ndouble fsqrt(double x) { return feq(x, 0) ? 0 : sqrt(x); }\n\nstruct pt_t {\n\tdouble x, y;\n\tpt_t operator+(const pt_t &p) const { return { x + p.x, y + p.y }; }\n\tpt_t operator-(const pt_t &p) const { return { x - p.x, y - p.y }; }\n\tpt_t operator*(const double &c) const { return { x * c, y * c }; }\n\tbool operator<(const pt_t &another) const {\n\t\treturn (x != another.x ? x < another.x : y < another.y);\n\t}\n};\n\nstruct line_t {\n\tdouble a, b, c;\n};\n\nstruct circle_t {\n\tdouble x, y, r;\n};\n\nline_t solve_line(double a, double b, pt_t p) {\n\treturn { a, b, -a * p.x - b * p.y };\n}\n\nline_t solve_line(pt_t p, pt_t q) {\n\treturn solve_line(q.y - p.y, -q.x + p.x, p);\n}\n\ndouble norm2(pt_t p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble norm(pt_t p) {\n\treturn sqrt(norm2(p));\n}\n\ndouble angle(pt_t p, pt_t q) {\n\tp = p * (1.0 / norm(p));\n\tq = q * (1.0 / norm(q));\n\tdouble r0 = acos(max(min(p.x * q.x + p.y * q.y, 1.0), -1.0));\n\tdouble r1 = asin(max(min(p.x * q.y - p.y * q.x, 1.0), -1.0));\n\tif (r1 >= 0) return r0;\n\telse return 2 * PI - r0;\n}\n\ndouble dist(line_t l, pt_t p) {\n\treturn abs(l.a * p.x + l.b * p.y + l.c) / sqrt(l.a * l.a + l.b * l.b);\n}\n\nbool on_same_line(pt_t t, pt_t p) {\n\tline_t l = solve_line({ 0, 0 }, t);\n\tif (feq(dist(l, p), 0)) return true;\n\telse return false;\n}\n\nbool on_same_halfline(pt_t t, pt_t p) {\n\tline_t l = solve_line({ 0, 0 }, t);\n\tif (feq(dist(l, p), 0) && feq(angle(t, p), 0)) return true;\n\telse return false;\n}\n\nbool in_segment(pt_t s, pt_t t, pt_t p) {\n\tline_t l = solve_line(s, t);\n\tif (dist(l, p) < eps\n\t\t&& fge(p.x, min(s.x, t.x))\n\t\t&& fge(max(s.x, t.x), p.x)\n\t\t&& fge(p.y, min(s.y, t.y))\n\t\t&& fge(max(s.y, t.y), p.y)) return true;\n\telse return false;\n}\n\npt_t cross_point(line_t l, line_t m) {\n\tdouble d = l.a * m.b - l.b * m.a;\n\tif (feq(d, 0)) {\n\t\tif (feq(l.a * m.c - l.c * m.a, 0)) return { INF, INF };\n\t\telse return { NAN, NAN };\n\t}\n\telse {\n\t\tdouble x = l.b * m.c - m.b * l.c;\n\t\tdouble y = l.a * m.c - m.a * l.c;\n\t\treturn { x / d, y / -d };\n\t}\n}\n\nvector<pt_t> cross_point(circle_t f, line_t l) {\n\tdouble d = dist(l, { f.x, f.y });\n\tif (!fge(f.r, d)) return {};\n\tline_t m = solve_line(l.b, -l.a, { f.x, f.y });\n\tpt_t p = cross_point(l, m);\n\tif (feq(d, f.r)) return { p };\n\telse {\n\t\tpt_t u = { l.b, -l.a };\n\t\tpt_t v = u * (sqrt(pow(f.r, 2) - pow(d, 2)) / norm(u));\n\t\treturn { p + v, p - v };\n\t}\n}\n\nvector<pt_t> cross_point(circle_t f, circle_t g) {\n\tline_t l = {\n\t\t-2 * f.x + 2 * g.x,\n\t\t-2 * f.y + 2 * g.y,\n\t\t(f.x * f.x + f.y * f.y - f.r * f.r) - (g.x * g.x + g.y * g.y - g.r * g.r)\n\t};\n\treturn cross_point(f, l);\n}\n\n\nint main(void)\n{\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n) break;\n\t\tvector<circle_t> p(n);\n\t\tLoop(i, n) {\n\t\t\tcin >> p[i].x >> p[i].y >> p[i].r;\n\t\t}\n\t\tvector<pt_t> d(2 * n);\n\t\tpt_t s, e;\n\t\td[0].x = p[0].x; d[0].y = p[0].y;\n\t\td[2 * n - 1].x = p[n - 1].x; d[2 * n - 1].y = p[n - 1].y;\n\n\t\tLoop(i, n - 1) {\n\t\t\tvector<pt_t> get = cross_point(p[i], p[i + 1]);\n\t\t\td[2 * i + 1] = get[0];\n\t\t\td[2 * i + 2] = get[1];\n\t\t}\n\t\tvector<vector<double>> dis(2 * n, vector<double>(2 * n));\n\t\tLoop(i, 2 * n) {\n\t\t\tfor (int j = i + 1; j < 2 * n; j++) {\n\t\t\t\tbool flag = 1;\n\t\t\t\tint l = (i - 1) / 2;\n\t\t\t\tif (i == 0) l = -1;\n\t\t\t\tint r = (j - 1) / 2;\n\t\t\t\tfor (int k = l + 1; k < r; k++) {\n\t\t\t\t\tline_t get1 = solve_line(d[2 * k + 1], d[2 * k + 2]);\n\t\t\t\t\tline_t get2 = solve_line(d[i], d[j]);\n\t\t\t\t\tflag = in_segment(d[2 * k + 1], d[2 * k + 2], cross_point(get1, get2));\n\t\t\t\t\tif (!flag) break;\n\t\t\t\t}\n\t\t\t\tif (!flag) dis[i][j] = INF;\n\t\t\t\telse dis[i][j] = norm(d[i] - d[j]);\n\t\t\t}\n\t\t}\n\t\tvector<double> dp(2 * n, INF);\n\t\tvector<int> from(2 * n, -1);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\tfor (int j = i + 1; j < 2 * n; j++) {\n\t\t\t\tdouble x = dp[i] + dis[i][j];\n\t\t\t\tif (x < dp[j]) {\n\t\t\t\t\tdp[j] = x;\n\t\t\t\t\tfrom[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << setprecision(12) << dp[2 * n - 1] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vl=vector<ll>;\nusing vs=vector<string>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(ll i=(a);i<n;i++)\n\nusing D=double;\nusing P=complex<D>;\nusing L=pair<P,P>;\nusing VP=vector<P>;\nconst D EPS=1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n)<(m)+EPS)\n#define GE(n,m) ((n)+EPS>(m))\n#define EQ(n,m) (abs((n)-(m))<EPS)\n#define LINF 1e20\n\nVP crosspointCC(P a, D ar, P b, D br){\n    VP ps;\n    P ab =b-a;\n    D d=abs(ab);\n    D crL=(norm(ab)+ar*ar-br*br)/(2*d);\n    if(EQ(d,0) || ar<abs(crL)) return ps;\n    P abN = ab*P(0,sqrt(ar*ar-crL*crL)/d);\n    P cp=a+crL/d*ab;\n    ps.push_back(cp+abN);\n    if(!EQ(norm(abN),0))ps.push_back(cp-abN);\n    return ps;\n}\nD dot(P a,  P b){\n    return (conj(a)*b).X;\n}\n\nD cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\nint ccw(P a,P b, P c){\n    b-=a; c-=a;\n    if(cross(b,c) >EPS)return 1;\n    if(cross(b,c) <-EPS)return -1;\n    if(dot(b,c) <-EPS)return 2;\n    if(norm(b)<norm(c))return -2;\n    return 0;\n    \n}\nbool isecSS(P a1,P a2, P b1, P b2){\n    return ccw(a1,a2,b1) * ccw(a1,a2,b2)<=0 &&\n    ccw(b1,b2,a1)*ccw(b1,b2,a2)<=0;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vd x(n),y(n),r(n);\n        rep(i,n)cin>>x[i]>>y[i]>>r[i];\n        vd px(2*n), py(2*n);\n        px[0]=x[0];\n        py[0]=y[0];\n        px[2*n-1]=x[n-1];\n        py[2*n-1]=y[n-1];\n        rep(i,n-1){\n            auto vp=crosspointCC(P(x[i],y[i]), r[i], P(x[i+1],y[i+1]), r[i+1]);\n            px[i*2+1]=vp[0].X;\n            py[i*2+1]=vp[0].Y;\n            px[i*2+2]=vp[1].X;\n            py[i*2+2]=vp[1].Y;\n        }\n        vvd dist(2*n, vd(2*n,LINF));\n        rep(i,2*n)range(j,i+1,2*n){\n            bool ok=true;\n            range(k,(i==0?0:(i-1)/2+1),(j-1)/2){\n                // cout<<i<<\",\"<<j<<\",\"<<k*2+1<<endl;\n                // cout<<P(px[i],py[i])<<P(px[j],py[j])<<P(px[k*2+1],py[k*2+1])<<P(px[k*2+2],py[k*2+2])<<endl;\n                if(!isecSS(P(px[i],py[i]), P(px[j],py[j]), P(px[k*2+1],py[k*2+1]), P(px[k*2+2],py[k*2+2]))){\n                    ok=false;\n                }\n                // cout<<ok<<\",\"<<endl;\n            }\n            // cout<<px[i]<<\",\"<<py[i]<<\",\"<<px[j]<<\",\"<<py[j]<<endl;\n            // cout<<i<<\",\"<<j<<\"=\"<<(ok?\"ok\":\"ng\")<<endl;\n            if(ok){\n                dist[i][j]=hypot(abs(px[i]-px[j]), abs(py[i]-py[j]));\n            }\n        }\n        vd dp(n*2, LINF);\n        dp[0]=0;\n        rep(i,2*n){\n            range(j,i+1,2*n){\n                dp[j]=min(dp[j], dp[i]+dist[i][j]);\n            }\n        }\n        // rep(i,n*2)cout<<dp[i]<<endl;\n        cout<<setprecision(10)<<fixed<<dp[2*n-1]<<endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \n//constexpr double inf = numeric_limits<double>::max() / 10; \nconstexpr double inf = 30000;\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nnamespace Geometry{\n    struct Point{\n        double x,y;\n        Point(){}\n        Point(double a,double b) : x(a),y(b){}\n        Point(const Point& p) : x(p.x),y(p.y){}\n        Point operator + (Point p){\n            return Point(x+p.x,y+p.y);\n        }\n        Point operator - (Point p){\n            return Point(x-p.x,y-p.y);\n        }\n        Point operator * (double k){\n            return Point(x*k,y*k);\n        }\n    };\n    using Vector = Point;\n    struct Circle{\n        Point c;\n        double r;\n        Circle(){}\n        Circle(Point p,double c) : c(p),r(c){}\n        Circle(double a,double b,double c) : c(Point(a,b)) , r(c){}\n    };\n\n    // for debug\n    ostream& operator<<(ostream& os,const Point& p){\n        os << \"{\" << p.x <<\",\" << p.y <<\"}\";\n        return os;\n    }\n    ostream& operator<<(ostream& os,const Circle& c){\n        os << \"{(\" << c.c.x << \",\" << c.c.y <<\"),\" << c.r << \"}\";\n        return os;\n    }\n\n    // ?????????????????£??????\n    Vector normalize(Vector v){\n        double t = sqrt(v.x*v.x+v.y*v.y);\n        return Vector(v.x/t,v.y/t);\n    }\n\n    // ?????¨???????????¢\n    inline double distance(Point a,Point b){\n        double x=a.x-b.x;\n        double y=a.y-b.y;\n        return sqrt(x*x+y*y);\n    }\n\n    // ????????????\n    pair<Point,Point> getCrossPoint(Circle c1,Circle c2){\n        double d = distance(c1.c,c2.c);\n        Vector v = normalize(c2.c - c1.c);  // ??£????????????????????????????????????\n        Vector dualv = Vector(-v.y,v.x);    // v??¨?????´???????????????\n        double Cos = (c1.r*c1.r+d*d-c2.r*c2.r) / (2*c1.r*d);\n        double Sin = sqrt(1-Cos*Cos);\n        Point a = c1.c + v*Cos*c1.r + dualv*Sin*c1.r;\n        Point b = c1.c + v*Cos*c1.r - dualv*Sin*c1.r;\n        return make_pair(a,b);\n    }\n};\n\nusing namespace Geometry;\n\nint N;\nCircle cir[128];\ndouble x[128],y[128],r[128];\nvector<pair<Point,Point>> cross;\nvector<Point> poi;\nint NN;\n\nvoid solve(){\n    cross.assign(0,pair<Point,Point>());\n    poi.assign(0,Point());\n    rep(i,N){\n        cin >> x[i] >> y[i] >> r[i];\n        cir[i] = Circle(x[i],y[i],r[i]);\n    }\n    for(int i=0;i<N-1;i++){\n        cross.pb(getCrossPoint(cir[i],cir[i+1]));\n    }\n\n    NN = cross.size() * 2 + 2;\n    poi.push_back(Point(x[0],y[0]));\n    for(int i=0;i<cross.size();i++){\n        poi.push_back(cross[i].fi);\n        poi.push_back(cross[i].se);\n    }\n    poi.push_back(Point(x[N-1],y[N-1]));\n\n    vector<vector<double>> d(NN,vector<double>(NN,inf));\n    for(int i=0;i<NN;i++) d[i][i] = 0;\n    for(int i=0;i<NN;i++){\n        for(int j=i+1;j<NN;j++){\n            d[i][j] = d[j][i] = distance(poi[i],poi[j]);\n        }\n    }\n\n    //cerr << \"distance \" << endl;\n    //for(int i=0;i<NN;i++){\n    //    for(int j=0;j<NN;j++){\n    //        if(d[i][j]==inf) cerr << \"inf  \" << \" \";\n    //        else printf(\"%-5.3f \",d[i][j]);\n    //    }\n    //    cerr << endl;\n    //}\n\n    for(int i=0;i<NN;i++){\n        for(int j=i+1;j<NN;j++){\n            bool ok = true;\n            int idx1,idx2;\n            idx1 = (i%2==0) ? i+1 : i+2;\n            idx2 = (j%2==1) ? j-1 : j-2;\n            Vector a(poi[i]-poi[j]);\n            //cout << i << \" \" << j << \" \" << idx1 <<\" \" << idx2 << endl;\n            for(int k=idx1;k<=idx2;k+=2){\n                if(k+1>idx2) break;\n                Vector b(poi[k]-poi[i]);\n                Vector c(poi[k+1]-poi[i]);\n                double t1 = a.x*b.y - a.y*b.x;\n                double t2 = a.x*c.y - a.y*c.x;\n                //if(i==0 and j==7){\n                //    //cout << k << \" \" << k+1 << \" \" << t1 << \" \" << t2 << endl;\n                //}\n                if(t1*t2 >= 0){\n                    //cout << \"NG  between \" << k << \" \" << k+1 << endl;\n                    ok=false;\n                    break;\n                }\n            }\n            if(!ok){\n                d[i][j] = d[j][i] = inf;\n            }\n            //cerr << i << \" \" << j << \" \" << (ok? \"true\" : \"false\") << endl;\n        }\n    }\n\n    /*\n    cerr << \"Point : \" << endl;\n    for(int i=0;i<NN;i++){\n        cerr << i << \" \" << poi[i] << endl;\n    }\n\n    cerr << \"distance \" << endl;\n    for(int i=0;i<NN;i++){\n        for(int j=0;j<NN;j++){\n            if(d[i][j]==inf) cerr << \"inf  \" << \" \";\n            else printf(\"%-5.3f \",d[i][j]);\n        }\n        cerr << endl;\n    }\n    */\n\n\n    //cout << Double(d[0][5]) << \" \" << Double(d[5][11]) << \" \" << Double(d[11][13]) << \" \" << Double(d[13][19]) << endl; \n    //cout << d[0][11] << endl;\n    /*\n    cout << \"0,3 : \" << Double(d[0][3]) << endl;\n    cout << \"0,5 : \" << Double(d[0][5]) << endl;\n    cout << \"3,5 : \" << Double(d[3][5]) << endl;\n    cout << \"3,7 : \" << Double(d[3][7]) << endl;\n    cout << \"5,7 : \" << Double(d[5][7]) << endl;\n    */\n\n\n\n    for(int k=0;k<NN;k++){\n        for(int i=0;i<NN;i++){\n            for(int j=0;j<NN;j++){\n                //if(abs(inf-d[i][k])<eps or abs(inf-d[k][j])<eps) continue;\n                double tmp = d[i][j];\n                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n                //if(i==0 and j==11 and abs(tmp-d[i][j]) > eps){\n                //    cout << \"check :: \" << k << \"   \"  << Double(tmp)<< \" -> \" << Double(d[i][j]) << endl;\n                //    cout << Double(d[i][k]) << \" \" << Double(d[k][j]) << endl;\n                //}\n                //if(i==0 and j==7){\n                //    cout << \"0 and 7\" << endl;\n                //    cout <<  k << \"   \"  << Double(tmp)<< \" -> \" << Double(d[i][j]) << endl;\n                //    cout << Double(d[i][k]) << \" \" << Double(d[k][j]) << endl;\n                //}\n            }\n        }\n    }\n\n    //cerr << \"distance \" << endl;\n    //for(int i=0;i<NN;i++){\n    //    for(int j=0;j<NN;j++){\n    //        if(abs(d[i][j]-inf) < eps) cerr << \"inf  \" << \" \";\n    //        else printf(\"%-5.3f \",d[i][j]);\n    //    }\n    //    cerr << endl;\n    //}\n\n\n    //cout << \"0 .. 7 : \" << d[0][7] << endl;\n    //cout << \"0..5 + 5..7 : \" << d[0][5] + d[5][7] << endl;\n\n\n    //cout << Double(d[0][5]) << \" \" << Double(d[5][11]) << \" \" << Double(d[11][13]) << \" \" << Double(d[13][19]) << endl; \n\n    //cout << Double(d[0][5]) << \" \" << Double(d[5][11]) << \" \" << Double(d[0][11]) << endl;\n    //cout << Double(d[0][5] + d[5][11]) << endl;\n\n    //cout << Double(d[0][5] + d[5][11] + d[11][13] + d[13][19] ) << endl;\n\n    cout << Double(d[0][NN-1]) << endl;\n}\n\nint main(){\n    while(1){\n        cin >> N;\n        if(N==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n// using Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void print() {\n\n    }\n};\n\nstruct C {\n    P p;\n    double r;\n    C(){}\n    C(P _p, double _r) : p(_p), r(_r) {}\n    C(double _x, double _y, double _r) : p(_x, _y), r(_r) {}\n    void print() {\n        cerr << p.real() << \" \" << p.imag() << \" \" << r << endl;\n    }\n};\n\nC readC() {\n    double x, y, r;\n    cin >> x >> y >> r;\n    return C(x, y, r);\n}\n\nL intersectSegmentCC(C c1, C c2) {\n    P v = c2.p - c1.p;\n    double ac = (norm(v) + c1.r * c1.r - c2.r * c2.r) / (2 * abs(v));\n    double as = sqrt(c1.r * c1.r - ac * ac);\n    P u = v / abs(v);\n    P h = u * P(0, as);\n    u *= ac;\n    return L(c1.p + u + h, c1.p + u - h);\n}\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\n// !! ???????????????????????¨?????? \"<\" !!\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\nstruct edge {\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to, double _cost) : to(_to), cost(_cost) {}\n    void print() {\n        printf(\"{%d, %.2f}, \", to, cost);\n    }\n};\nusing Graph = vector<vector<edge>>;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, double c) {\n    G[x].emplace_back(y, c);\n    G[y].emplace_back(x, c);\n}\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    using State = pair<double, int>;\n    priority_queue<State, vector<State>, greater<State>> pq;   // cost, vertex\n    vector<double> d(n, 1e18);\n    d[s] = 0.;\n    pq.push(make_pair(0., s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nmain() {\n    // std::ios::sync_with_stdio(false);\n    // std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<C> circles(n);\n        rep(i, n) circles[i] = readC();\n\n        vector<L> segments(n - 1);\n        const int N = 2 * n, s = N - 2, t = N - 1;\n        // output(N, s, t);\n        vector<P> points(N);\n        rep(i, n - 1) {\n            segments[i] = intersectSegmentCC(circles[i], circles[i + 1]);\n            points[2 * i] = segments[i].a;\n            points[2 * i + 1] = segments[i].b;\n        }\n        points[s] = circles[0].p;\n        points[t] = circles.back().p;\n\n        auto canConnect = [&](int a, int b) {\n            L seg(points[a], points[b]);\n\n            int l, r; // [l, r)\n            if (a == s && b == t) {\n                l = 0, r = n - 1;\n            }\n            else if (b == s) {\n                l = 0, r = a / 2;\n            }\n            else if (b == t) {\n                l = a / 2, r = n - 1;\n            }\n            else {\n                l = a / 2, r = b / 2;\n            }\n\n            // output(a, b, l, r);\n\n            for (int i = l; i < r; i++) {\n                if (!intersectSS(seg, segments[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        Graph G(N);\n        rep(i, N) {\n            rep2(j, i + 1, N) {\n                if (canConnect(i, j)) {\n                    addEdge(G, i, j, abs(points[i] - points[j]));\n                }\n            }\n        }\n\n        // rep(i, G.size()) {\n        //     printf(\"%d (%.2f, %.2f): \", i, points[i].real(), points[i].imag());\n        //     for (auto e : G[i]) {\n        //         e.print();\n        //     }\n        //     cout << endl;\n        // }\n\n        cout << fixed << setprecision(10) << dijkstra(G, s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\n\nconst double EPS=1e-8,INF=1e12;\ntypedef complex<double> P;\ntypedef P point;\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);}\n}\ndouble cross(const P &a,const P &b){\n  return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n  return real(conj(a)*b);\n}\n\nstruct L :public vector<P>{\n  L(const P &a,const P &b){\n    pb(a); pb(b);\n  }\n};\n\ntypedef pair<point,point> ppp;\n\nint ccw(P a,P b,P c){\n  b-=a; c-=a;\n  if(cross(b,c)>EPS) return 1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c)<-EPS) return +2;\n  if(norm(b)+EPS<norm(c)) return -2;\n  return 0;\n}\n\nppp c_c_inter(const point &c1,const double &r1,\n\t      const point &c2,const double &r2){\n  point A=conj(c2-c1), B=(r2*r2-r1*r1-(c2-c1)*conj(c2-c1)),C=r1*r1*(c2-c1);\n  point D=B*B-4.*A*C;\n  point z1=(-B+sqrt(D))/(2.0*A)+c1, z2=(-B-sqrt(D))/(2.0*A)+c1;\n  return ppp(z1,z2);\n}\n\nbool interLS(const L &l,const L s){\n  return cross(l[1]-l[0], s[0]-l[0])*\n    cross(l[1]-l[0],s[1]-l[0])<EPS;\n}\n\ndouble len(const L &l){\n  return abs(l[0]-l[1]);\n}\ndouble d[112][112];\n\nint main(){\n  cout<<fixed<<setprecision(10);\n  int n;\n  while(cin>>n,n){\n    vector<P> c(n);\n    vector<double> r(n);\n    double x,y;\n    rep(i,n){\n      cin>>x>>y>>r[i];\n      c[i]=P(x,y);\n    }\n    vector<ppp> ps(n-1);\n    rep(i,n-1)\n      ps[i]=c_c_inter(c[i],r[i],c[i+1],r[i+1]);\n\n    fill(d[0],d[0]+112*112,INF);\n    rep(i,n-1){\n      L lx(c[0],ps[i].X),ly(c[0],ps[i].Y);\n      int fx=1,fy=1;\n      rep(j,i){\n\tfx&=interLS(lx,L(ps[j].X,ps[j].Y));\n\tfy&=interLS(ly,L(ps[j].X,ps[j].Y));\n      }\n      if(fx)d[2*n-2][2*i]=d[2*i][2*n-2]=len(lx);\n      if(fy)d[2*n-2][2*i+1]=d[2*i+1][2*n-2]=len(ly);\n    }\n    rep(i,n-1){\n      L lx(c[n-1],ps[i].X),ly(c[n-1],ps[i].Y);\n      int fx=1,fy=1;\n      for(int j=i;j<n-1;++j){\n\tfx&=interLS(lx,L(ps[j].X,ps[j].Y));\n\tfy&=interLS(ly,L(ps[j].X,ps[j].Y));\n      }\n      if(fx)d[2*n-1][2*i]=d[2*i][2*n-1]=len(lx);\n      if(fy)d[2*n-1][2*i+1]=d[2*i+1][2*n-1]=len(ly);\n    }\n    L l(c[0],c[n-1]);\n    int f=1;\n    rep(i,n-1)\n      f&=interLS(l,L(ps[i].X,ps[i].Y));\n    if(f) d[2*n-1][2*n-2]=d[2*n-2][2*n-1]=len(l);\n    rep(i,n-1)rep(j,i)rep(a,2)rep(b,2){\n      L l(a?ps[i].Y:ps[i].X,b?ps[j].Y:ps[j].X);\n      int f=1;\n      for(int k=j+1;k<i;++k)\n\tf&=interLS(l,L(ps[k].X,ps[k].Y));\n      if(f)\n\td[2*i+a][2*j+b]=d[2*j+b][2*i+a]=len(l);\n    }\n    rep(k,2*n)rep(i,2*n)rep(j,2*n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<d[2*n-1][2*n-2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Chain-Confined Path\n\n// 円同士の交点を頂点, 円内部を通る線分を辺としたダイクストラ\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<cfloat>\nusing namespace std;\n\ntypedef double Weight;\nconst double INF = DBL_MAX;\nclass Edge {\npublic:\n    int source, target;\n    Weight weight;\n    Edge(int s, int t, Weight w) :source(s), target(t), weight(w) {}\n    bool operator<(const Edge& e) const {\n        if(weight != e.weight) return weight > e.weight;    // !!INVERSE!!\n        return source != e.source ? source < e.source : target < e.target;\n    }\n};\nclass Graph {\npublic:\n    vector< vector<Edge> > list;\n    int size;\n    Graph(int n) :size(n), list(vector< vector<Edge> >(n, vector<Edge>())) {};\n    Weight Dijkstra(int, int) const;\n};\nWeight Graph::Dijkstra(int from, int to) const {\n    vector<Weight> distance(size, INF);\n    distance[from] = 0;\n    priority_queue<Edge> q;\n    q.push(Edge(from, from, 0));\n    while(!q.empty()) {\n        Edge now = q.top(); q.pop();\n        int u = now.target;\n        if(distance[u] == INF) break;\n        for(vector<Edge>::const_iterator next = list[u].begin(); next != list[u].end(); next++) {\n            int v = next->target;\n            if(distance[v] <= distance[u] + next->weight) continue;\n            distance[v] = distance[u] + next->weight;\n            q.push(Edge(u, v, distance[v]));\n        }\n    }\n    return distance[to];\n}\n\nconst double EPS = 0.0;\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\npublic:\n    double x, y;\n    Point(double a = 0.0, double b = 0.0) :x(a), y(b) {};\n    bool operator== (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    Point operator+(const Point&) const;\n    Point operator-(const Point&) const;\n    Point operator-() const;\n    Point times(double) const;\n    Point& operator=(const Point&);\n    Point& operator+=(const Point&);\n    Point& operator-=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Line&) const;\n    Point reflection(const Line&) const;\n    int ccw(const Point&, const Point&) const;              // a.ccw(b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n};\nclass Segment {\npublic:\n    Point source, target;\n    Segment(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\npublic:\n    Point source, target;\n    Line(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Point&) const;\n    Point reflection(const Point&) const;\n    Point crosspoint(const Line&) const;\n};\nclass Circle {\npublic:\n    double x, y, r;\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :x(a), y(b), r(c) {};\n    Point point() const;\n    double distance(const Point&) const;                    // 円の中心と点の距離\n    double distance(const Circle&) const;                   // 円の中心同士の距離\n    bool include(const Point&) const;                       // 点を含むか\n    bool include(const Circle&) const;                      // 円を含むか\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x == p.x && y == p.y;}\nbool Point::operator<(const Point &p) const {return x != p.x ? x < p.x : y < p.y;}\nbool Point::operator>(const Point &p) const {return x != p.x ? x > p.x : y > p.y;}\nbool Point::operator<=(const Point &p) const {return x != p.x ? x < p.x : y <= p.y;}\nbool Point::operator>=(const Point &p) const {return x != p.x ? x > p.x : y >= p.y;}\nPoint Point::operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\nPoint Point::operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\nPoint Point::operator-() const {return Point(-x, -y);}\nPoint Point::times(double d) const {return Point(x * d, y * d);}\nPoint& Point::operator=(const Point& p) {x = p.x; y = p.y; return *this;}\nPoint& Point::operator+=(const Point& p) {x += p.x; y += p.y; return *this;}\nPoint& Point::operator-=(const Point& p) {x -= p.x; y -= p.y; return *this;}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\ndouble Point::abs() const {return hypot(x, y);}\ndouble Point::norm() const {return x * x + y * y;}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nPoint Point::projection(const Line& l) const {return l.projection(*this);}\nPoint Point::reflection(const Line& l) const {return l.reflection(*this);}\nint Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > 0.0) return 1;\n    if(v1.cross(v2) < 0.0) return -1;\n    if(v1.dot(v2) < 0.0) return 2;\n    if(v1.norm() < v2.norm()) return -2;\n    return 0;\n}\n// Segment\nLine Segment::line() const {return Line(source, target);}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source.distance(p);\n    double b = target.distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    double c = s.distance(source);\n    double d = s.distance(target);\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source.distance(p) + target.distance(p) - target.distance(source) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source.ccw(s.target, source) * s.source.ccw(s.target, target) <= EPS;\n    bool b = source.ccw(target, s.source) * source.ccw(target, s.target) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nSegment Line::segment() const {return Segment(source, target);}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source);}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source - p;\n    Point v2 = target - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target - source;\n    Point v2 = s.source - source;\n    Point v3 = s.target - source;\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = l.source - source;\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nPoint Line::projection(const Point& p) const {\n    Point v1 = p - source;\n    Point v2 = source - target;\n    return Point(source + v2.times(v1.dot(v2) / v2.norm()));\n}\nPoint Line::reflection(const Point& p) const {\n    return p + (projection(p) - p).times(2.0);\n}\nPoint Line::crosspoint(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = target - l.source;\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source;\n    return l.source + v2.times(b / a);\n}\n// Circle\nPoint Circle::point() const {return Point(x, y);}\ndouble Circle::distance(const Point& p) const {return point().distance(p);}\ndouble Circle::distance(const Circle& c) const {return point().distance(c.point());}\nbool Circle::include(const Point& p) const {return distance(p) - r <= EPS;}\nbool Circle::include(const Circle& c) const {return distance(c) - (r - c.r) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return distance(c) - r - c.r <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y - y, c.x - x);\n    double d = distance(c);\n    double add = acos((d * d + r * r - c.r * c.r) / (2.0 * d * r));\n    vector<Point> result;\n    result.push_back(Point(x + r * cos(angle + add), y + r * sin(angle + add)));\n    result.push_back(Point(x + r * cos(angle - add), y + r * sin(angle - add)));\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<Circle> circle(n);\n        for(int i = 0; i < n; i++) {\n            double x, y, r;\n            cin>>x>>y>>r;\n            circle[i] = Circle(x, y, r);\n        }\n        vector<Segment> gate;\n        vector<Point> vertex;\n        vertex.push_back((*circle.begin()).point());\n        for(int i = 0; i < n - 1; i++) {\n            vector<Point> p = circle[i].crosspoint(circle[i + 1]);\n            gate.push_back(Segment(p[0], p[1]));\n            vertex.insert(vertex.end(), p.begin(), p.end());\n        }\n        vertex.push_back((*circle.rbegin()).point());\n        Graph g(vertex.size());\n        for(int i = 0; i < vertex.size() - 1; i++) {\n            for(int j = i + 1; j < vertex.size(); j++) {\n                Line edge(vertex[i], vertex[j]);\n                int firstGate = (i + 1) / 2;\n                int lastGate = (j + 1) / 2 - 1;\n                if(j == vertex.size() - 1) lastGate--;\n                bool ok = true;\n                for(int k = firstGate; k <= lastGate; k++) {\n                    if(!edge.intersect(gate[k])) ok = false;\n                }\n                if(ok) (g.list[i]).push_back(Edge(i, j, vertex[i].distance(vertex[j])));\n            }\n        }\n        printf(\"%.6f\\n\", g.Dijkstra(0, vertex.size() - 1));\n//         for(int i=0; i<(g.list).size(); i++) {cout<<vertex[i].x<<\", \"<<vertex[i].y<<endl;}\n//         for(int i=0; i<(g.list).size(); i++) {\n//             for(int j=0; j<(g.list[i]).size(); j++) {\n//                 cout<<\" \"<<((g.list[i])[j]).target<<\":\"<<((g.list[i])[j]).weight;\n//             }\n//             cout<<endl;\n//         }\n//         return(1);\n//         cout<<g.Dijkstra(0, vertex.size() - 1)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\nconst double INF=1e+10;\nint N;\ndouble xs[101];\ndouble ys[101];\ndouble rs[101];\nP cps[101];\nP ps[1001];\ndouble d[301][301];\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n\treturn P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 2円の交点を求める\npair<P,P> crossPointsTwoCircle(P c1,double r1,P c2,double r2){\n  double a=abs(c1-c2);\n  //double b=sqrt(r1*r1-(a/2)*(a/2));\n  double tmp=((r1*r1-r2*r2+a*a)/(2*a));\n  double b=sqrt(r1*r1-tmp*tmp);\n  P p=c1-c2;p/=abs(p);\n  p=roundPoint(p,PI/2);\n  P p1=p;\n  P p2=p;p2*=-1;\n  p1*=b;p2*=b;\n  P cp=(c2*tmp+c1*(a-tmp));\n  cp*=(1.0/a);\n  P res1=cp+p1;\n  P res2=cp+p2;\n  return make_pair(res1,res2);\n}\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 円の中にaがあるか\nbool isDotInCiecle(P cp,double r,P a){\n  double dist=abs(cp-a);\n  if(EQ(dist,r)||dist<r)return true;\n  return false;\n}\nbool isCircleCrossLine(P a,P b,P c,double r){\n  double d1 = abs(a-c);\n  double d2 = abs(b-c);\n  // 線分が中に含まれるとき、ここのコメントアウトをはずせばtrue(交差)となる\n  if(d1<r&&d2<r)return true;\n  double d = distance_ls_p(a,b,c);\n  return (EQ(d,r)||d<r);\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 円と直線の交点計算\n// 接する場合は同じ点を２つ返す\nvector<P> calcCrossPointLineAndCircle(P a,P b,P c,double r){\n  vector<P> res;\n  // もし直線と円がcrossしないなら、空リスト\n  if(!isCircleCrossLine(a,b,c,r))return res;\n  for(int i=0;i<2;i++){\n    double x=distance_l_p(a,b,c);\n    double y=sqrt(r*r-x*x);\n    P e=(b-a);e/=abs(e);e=roundPoint(e,(2*i+1)*PI/2);\n    P e2=e;e2*=x;\n    P cp2=c+e2;\n    P addV=(b-a);addV/=abs(addV);addV*=y;\n    P res1=cp2+addV;\n    addV*=-1;\n    P res2=cp2+addV;\n    // 今回求めた点が線分に乗ってない場合、向きを変えて再計算\n    if(!EQ(0,distance_l_p(a,b,res1)))continue;\n    res.push_back(res1);\n    res.push_back(res2);\n    return res;\n  }\n}\n// 円と線分の交点計算\nvector<P> calcCrossPointSegmentAndCircle(P a,P b,P c,double r){\n  // 直線との交点計算\n  vector<P> v=calcCrossPointLineAndCircle(a,b,c,r);\n  vector<P> res;\n  for(int i=0;i<(int)v.size();i++){\n    // 線分と今回の点の距離が0ならリストへ\n    double dis=distance_ls_p(a,b,v[i]);\n    if(EQ(dis,0))res.push_back(v[i]);\n  }\n  return res;\n}\n\n// 線分a,bが円の内側にあるか\n// fromからtoの円について調査する\nbool check(P a,P b,int from,int to){\n  vector<P> points;\n  // 線分a-bと各円との交点を全列挙する\n  for(int i=from;i<=to;i++){\n    // 線分との交点を取得\n    vector<P> res=calcCrossPointSegmentAndCircle(a,b,cps[i],rs[i]);\n    for(int j=0;j<(int)res.size();j++)\n      points.push_back(res[j]);\n    // もし線分がない円が存在すれば、false\n    if(res.size()==0)return false;\n  }\n  // pointsの点がそれぞれ2つ以上の点の内部にあるか\n  for(int i=0;i<(int)points.size();i++){\n    int cnt=0;\n    for(int j=0;j<N;j++)\n      if(isDotInCiecle(cps[j],rs[j],points[i]))cnt++;\n    if(cnt<2)return false;\n  }\n  return true;\n}\n\nint main(){\n\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++){\n      cin>>xs[i]>>ys[i]>>rs[i];\n      cps[i]=P(xs[i],ys[i]);\n    }\n    for(int i=1;i<N;i++){\n      pair<P,P> p2=crossPointsTwoCircle(cps[i-1],rs[i-1],cps[i],rs[i]);\n      ps[2*(i-1)]=p2.first;\n      ps[2*(i-1)+1]=p2.second;\n    }\n    for(int i=0;i<=2*N-1;i++)\n      for(int j=0;j<=2*N-1;j++)\n    \tif(i==j)d[i][j]=0;\n    \telse d[i][j]=INF;\n    const int s=(N-1)*2;\n    const int g=(N-1)*2+1;\n    ps[(N-1)*2]=cps[0];\n    ps[(N-1)*2+1]=cps[N-1];\n    for(int i=0;i<=2*(N-1)+1;i++){\n      for(int j=i+1;j<=2*(N-1)+1;j++){\n\tint from=i/2;\n\tint to=j/2;\n\tif(i==2*N-2)from=0;\n\telse if(i==2*N-1)from=N-1;\n\tif(j==2*N-2)to=0;\n\telse if(j==2*N-1)to=N-1;\n\tint a=min(from,to);\n\tint b=min(N-1,max(from,to)+1);\n    \t// 条件を満たす線分を使う\n    \tif(check(ps[i],ps[j],a,b)){\n\t  //cout<<i<<\" \"<<j<<endl;\n\t  d[i][j]=d[j][i]=abs(ps[i]-ps[j]);\n\t}\n      }\n    }\n    // floyd\n    for(int i=0;i<=2*N-1;i++)\n      for(int j=0;j<=2*N-1;j++)\n    \tfor(int k=0;k<=2*N-1;k++)\n    \t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n    printf(\"%.10f\\n\",d[s][g]);\n    //break;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 2円の交点\nVP crosspointCC(Point a, double ar, Point b, double br) {\n  VP ps;\n  Point ab = b-a;\n  double d = abs(ab);\n  double crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  Point abN = ab * Point(0, sqrt(ar*ar - crL*crL) / d);\n  Point cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nstruct edge{\n    int to;\n    double cost;\n};\n\nconst int N = 200;\nvector<edge> G[N];\n\nint main(){\n    int n;\n    while(scanf(\" %d\", &n),n){\n        rep(i,N) G[i].clear();\n\n        vector<Point> p(n);\n        vector<int> r(n);\n        rep(i,n){\n            int x,y;\n            scanf(\" %d %d %d\", &x, &y, &r[i]);\n            p[i] = Point(x,y);\n        }\n\n        vector<VP> c(n-1);\n        rep(i,n-1) c[i] = crosspointCC(p[i],r[i],p[i+1],r[i+1]);\n\n        int S = 2*n-2, T = S+1;\n\n        bool direct = true;\n        rep(i,n-1){\n            direct &= isecSS(p[0],p[n-1],c[i][0],c[i][1]);\n        }\n        if(direct){\n            G[S].pb({T,abs(p[0]-p[n-1])});\n            G[T].pb({S,abs(p[0]-p[n-1])});\n        }\n\n        rep(i,n-1)rep(j,2){\n            bool ok = true;\n            rep(k,i) ok &= isecSS(p[0],c[i][j],c[k][0],c[k][1]);\n            if(ok){\n                G[S].pb({2*i+j, abs(p[0]-c[i][j])});\n                G[2*i+j].pb({S, abs(p[0]-c[i][j])});\n            }\n        }\n\n        rep(i,n-1)rep(j,2){\n            bool ok = true;\n            for(int k=n-2; k>i; --k) ok &= isecSS(p[n-1],c[i][j],c[k][0],c[k][1]);\n            if(ok){\n                G[T].pb({2*i+j, abs(p[n-1]-c[i][j])});\n                G[2*i+j].pb({T, abs(p[n-1]-c[i][j])});\n            }\n        }\n\n        rep(i,n-1)rep(j,2)for(int k=i+1; k<n-1; ++k)rep(l,2){\n            bool ok = true;\n            for(int a=i+1; a<k; ++a) ok &= isecSS(c[i][j],c[k][l],c[a][0],c[a][1]);\n            if(ok){\n                G[2*i+j].pb({2*k+l, abs(c[i][j]-c[k][l])});\n                G[2*k+l].pb({2*i+j, abs(c[i][j]-c[k][l])});\n            }\n        }\n\n        vector<double> d(2*n,INF);\n        d[S] = 0;\n\n        using P = pair<double,int>;\n        priority_queue<P, vector<P>, greater<P>> pq;\n        pq.push({0,S});\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n            int v = now.se;\n            if(now.fi > d[v]) continue;\n            for(const auto &e:G[v]){\n                if(d[e.to] > d[v]+e.cost){\n                    d[e.to] = d[v]+e.cost;\n                    pq.push({d[e.to],e.to});\n                }\n            }\n        }\n        printf(\"%.10f\\n\", d[T]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint n;\nCircle c[200];\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint ccw(Point a,Point b,Point c){\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a???b??§???????¨???¨???????????????b???c\n    if(cross(b,c) < -EPS) return -1;//a???b??§????¨???¨???????????????b???c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(abs??????????????????????????????????????????????????????????)\n    return 0;//a--c--b?????????b==c\n}\nbool is_intersection_two_line_segment(Line a,Line b){\n    return ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 && ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0;\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.first - c1.first);\n    R b = c1.second;\n    R c = c2.second;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.first - c1.first) / a;\n\n    Line p ;\n    p.first = c1.first + diff * rc + diff * Point(0,1) * rs;\n    p.second = c1.first + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\nbool input(){\n    scanf(\"%d\",&n);\n\n    if(n == 0)\n        return false;\n    REP(i,n){\n        double re,im;\n        cin >> re >> im  >> c[i].second;\n        c[i].first = Point(re,im);\n    }\n    return true;\n}\n\ndouble G[1000][1000];\nPoint ver[200][2];\n\nbool judgecross(Point a,Point b,int a1,int b1){\n    Line c(a,b);\n     FOR(i,a1+1,b1){\n         Line d(ver[i][0],ver[i][1]);\n         if(!is_intersection_two_line_segment(c,d))\n             return false;\n    }\n    return true;\n}\n\n\nvoid solve(){\n    REP(i,1000)\n        REP(j,1000)\n            G[i][j] = 1000000000.0;\n    REP(i,1000)\n        G[i][i] = 0.0;\n\n    REP(i,n-1){\n        Line inter = intersection_of_two_circles(c[i],c[i+1]);\n        ver[i][0] = inter.first;\n        ver[i][1] = inter.second;\n    }\n    //REP(i,n-1)\n        //printf(\"%lf %lf    %lf %lf\\n\",ver[i][0].real(),ver[i][0].imag(),ver[i][1].real(),ver[i][1].imag());\n    REP(i,(n - 1) * 2){\n        FOR(j,i + 1,(n - 1) * 2){\n            int i1 = i / 2;int i2 = i % 2;\n            int j1 = j / 2;int j2 = j % 2;\n            if(!judgecross(ver[i1][i2],ver[j1][j2],i1,j1))\n                continue;\n            G[i][j] = G[j][i] = abs(ver[i1][i2] - ver[j1][j2]);\n        }\n    }\n    Point start(c[0].first.real(),c[0].first.imag());\n    REP(i,(n - 1) * 2){\n        int i1 = i / 2;int i2 = i % 2;\n        if(!judgecross(start,ver[i1][i2],-1,i1))\n            continue;\n        G[i][n * 2 - 2]  = G[n * 2 - 2][i] = abs(start - ver[i1][i2]);\n    }\n    Point end(c[n-1].first.real(),c[n-1].first.imag());\n    REP(i,(n - 1) * 2){\n        int i1 = i / 2;int i2 = i % 2;\n        if(!judgecross(ver[i1][i2],end,i1,n-1))\n            continue;\n        G[i][n * 2 - 1] = G[n * 2 - 1][i] = abs(end - ver[i1][i2]);\n    }\n    if(judgecross(start,end,-1,n-1))\n        G[n * 2 - 1][n * 2 - 2] = G[n * 2 - 2][n * 2 - 1] = abs(start - end);\n    REP(k,n*2){\n        REP(i,n*2){\n            REP(j,n*2){\n                G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n            }\n        }\n    }\n    printf(\"%lf\\n\",G[n*2-2][n*2-1]);\n}\n\nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\ntemplate<class T> T at(vector<T> v, int i) {return v[i % v.size()];}\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\n// 比較関数\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator==(P a, P b) {return norm(a - b) < EPS;}\n  bool operator<(L a, L b) {return a.a != b.a ? a.a < b.a : a.b < b.b;}\n}\n\nD sr(D a) {return sqrt(max(a, (D)0));}\n\n// 内積\nD dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.b - a.a;}\n\n// 線分abに対する点cの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  if (a == c || b == c) return ON;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\n// 射影\nP proj(P a, P b) {return a * dot(a, b) / norm(a);}\nP perp(L l, P p) {return l.a + proj(vec(l), p - l.a);}\n\n// 距離\nD dLP(L l, P p) {return abs(det(vec(l), p - l.a)) / abs(vec(l));}\nD dSP(L s, P p) {\n  if (dot(vec(s), p - s.a) < 0) return abs(p - s.a);\n  if (dot(vec(s), p - s.b) > 0) return abs(p - s.b);\n  return dLP(s, p);\n}\n\n// 円\nstruct C{P c; D r;};\n\n// 交差判定\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCS(C c, L s) {return sig(c.r, dSP(s, c.c)) >= 0;}\nbool iCSc(C c, L s) {return iCS(c, s) && sig(c.r, max(abs(s.a - c.c), abs(s.b - c.c))) <= 0;}\n\n// 交点\npair<P, P> pCC(C a, C b) {\n  D x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  P e = (b.c - a.c) / abs(b.c - a.c);\n  P y = e * P(0, sr(a.r * a.r - x * x));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\npair<P, P> pCL(C c, L l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\n// 線分アレンジメント 隣の点への辺のみを持つ\nvector<vector<int> > sArr(vector<L> s, vector<P> &vp) {\n  //s = merge(s);\n  rep (i, s.size()) {\n    vp.push_back(s[i].a);\n    vp.push_back(s[i].b);\n  }\n  //rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) vp.push_back(pLL(s[i], s[j]));\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end()), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i].a, s[i].b, vp[j]) == ON) {\n      v.push_back(make_pair(norm(vp[j] - s[i].a), j));\n    }\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return g;\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    C c[n];\n    rep (i, n) cin >> c[i].c.X >> c[i].c.Y >> c[i].r;\n    vector<P> vp;\n    vp.push_back(c[0].c);\n    vp.push_back(c[n - 1].c);\n    rep (i, n - 1) {\n      pair<P, P> pp = pCC(c[i], c[i + 1]);\n      vp.push_back(pp.first);\n      vp.push_back(pp.second);\n    }\n    vector<L> vs;\n    rep (i, vp.size()) rep (j, i) {\n      L s = {vp[i], vp[j]};\n      vector<P> v;\n      rep (k, n) if (iCSc(c[k], s)) {\n\tpair<P, P> pp = pCL(c[k], s);\n\tif (ccw(s.a, s.b, pp.first) == ON) v.push_back(pp.first);\n\tif (ccw(s.a, s.b, pp.second) == ON) v.push_back(pp.second);\n      }\n      sort(v.begin(), v.end());\n      rep (t, v.size() - 1) {\n\tbool ok = false;\n\tP m = (v[t] + v[t + 1]) / (D)2;\n\trep (k, n) if (iCP(c[k], m)) {\n\t  ok = true;\n\t  break;\n\t}\n\tif (!ok) goto next;\n      }\n      vs.push_back(s);\n    next:;\n    }\n    vector<P> p;\n    vector<vector<int> > g = sArr(vs, p);\n    int start = -1, goal = -1;\n    rep (i, p.size()) if (p[i] == c[0].c) start = i;\n    rep (i, p.size()) if (p[i] == c[n - 1].c) goal = i;\n    D dis[p.size()];\n    rep (i, p.size()) dis[i] = 1e100;\n    priority_queue<pair<D, int>, vector<pair<D, int> >, greater<pair<D, int> > > que;\n    que.push(make_pair(0, start));\n    while (!que.empty()) {\n      pair<D, int> now = que.top();\n      que.pop();\n      if (sig(dis[now.second], now.first) <= 0) continue;\n      dis[now.second] = now.first;\n      rep (i, g[now.second].size()) {\n\tque.push(make_pair(now.first + abs(p[now.second] - p[g[now.second][i]]), g[now.second][i]));\n      }\n    }\n    printf(\"%.12Lf\\n\", dis[goal]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define IL inline \nnamespace geo {\n\ttypedef double D;\n\ttypedef bool B;\n\tstruct P {\n\t\tD X, Y;\n\t\tB operator<(const P &o)const { return (X == o.X) ? Y < o.Y : X < o.X; }\n\t\tP operator+ (P o) { return P{ X + o.X,Y + o.Y }; }\n\t\tP operator- (P o) { return P{ X - o.X,Y - o.Y }; }\n\t\tP operator* (D o) { return P{ X*o,Y*o }; }\n\t\tP operator/ (D o) { return P{ X/o,Y/o }; }\n\t\tP operator-() { return P{ -X,-Y }; }\n\t};\n\ttypedef tuple<P, P> L;  //line\n\ttypedef tuple<P, P> LS; //line segment\n\ttypedef tuple<P, D> C;  //circle\n\ttypedef vector<P> Poly;\n\tconst D EPS = 1e-8;\n\tIL P iMUL(P p, P q) {return P{ p.X*q.X - p.Y*q.Y,p.X*q.Y + p.Y*q.X };}\n\n\tIL D ABS(P p) { return sqrt(p.X*p.X + p.Y*p.Y); }\n\t//A dot B\n\tIL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n\t//A cross B\n\tIL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n\n\tIL D signed_distance_P_L(P p, L l) {\n\t\tP a, b, c = p;\n\t\ttie(a, b) = l;\n\t\treturn cross(b - a, c - a) / ABS(b - a);\n\t}\n\n\tIL D distance_P_L(P p, L l) {\n\t\treturn abs(signed_distance_P_L(p,l));\n\t}\n\n\tIL D distance_P_LS(P p, LS ls) {\n\t\tP a, b, c = p;\n\t\ttie(a, b) = ls;\n\t\tif (dot(b - a, c - a) < EPS) return ABS(c - a);\n\t\tif (dot(a - b, c - b) < EPS) return ABS(c - b);\n\t\treturn abs(cross(b - a, c - a)) / ABS(b - a);\n\t}\n\n\tIL B isintersected_L_L(L p, L q) {\n\t\tP a, b, c, d;\n\t\ttie(a, b) = p;\n\t\ttie(c, d) = q;\n\t\treturn (abs(cross(a - b, c - d)) > EPS);\n\t}\n\tIL B isintersected_L_LS(L l, LS ls) {\n\t\tP a, b, c, d;\n\t\ttie(a, b) = l;\n\t\ttie(c, d) = ls;\n\t\treturn !((cross(a - b, b - a) > -EPS) ^ (cross(a - b, d - a) < EPS));\n\t}\n\tIL B isintersected_LS_LS(LS p, LS q) {\n\t\tP a, b, c, d;\n\t\ttie(a, b) = p;\n\t\ttie(c, d) = q;\n\t\treturn cross(b - a, c - a)*cross(b - a, d - a) < EPS && cross(d - c, a - c)*cross(d - c, b - c) < EPS;\n\t}\n\t//caution: have to use isintersected_L_L before this function\n\tIL P cross_point_L_L(L p, L q) {\n\t\tP a, b;\n\t\ttie(a, b) = p;\n\t\tD d1 = signed_distance_P_L(a, q);\n\t\tD d2 = signed_distance_P_L(b, q);\n\t\treturn (a * d2 - b * d1) / (d2 - d1);\n\t}\n\n\tIL B isintersected_C_C(C p, C q) {\n\t\tP cp, cq;\n\t\tD rp, rq;\n\t\ttie(cp, rp) = p;\n\t\ttie(cq, rq) = q;\n\t\tD d = ABS(cp - cq);\n\t\treturn abs(rp - rq) < d + EPS&&d < rp + rq + EPS;\n\t}\n\tIL LS cross_C_C(C p, C q) {\n\t\tP cp, cq;\n\t\tD rp, rq;\n\t\ttie(cp, rp) = p;\n\t\ttie(cq, rq) = q;\n\t\tD d = ABS(cp - cq);\n\t\tD rc = (d*d + rp*rp - rq*rq) / (2 * d);\n\t\tD rs = sqrt(rp*rp - rc*rc);\n\t\tP diff = (cq - cp) / d;\n\t\treturn LS(cp + iMUL(P{ rc, rs },diff), cp + iMUL(P{ rc, -rs },diff));\n\t}\n\n}\n\n\n\n#define rep(i,N) for(auto i=(N)*0;i<N;i++)\n#define range(it,v) for(auto &it:v)\nstruct INIT { INIT() { cin.tie(0); ios_base::sync_with_stdio(false); } }init;\nusing namespace geo;\nconst double INF = 1e9;\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcout << setprecision(10);\n\tcout << fixed;\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<C> c(n);\n\t\trange(it, c) {\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tit = C(P{ x, y }, r);\n\t\t}\n\n\t\tvector<LS> ls;\n\t\t{\n\t\t\tP s, g;\n\t\t\t{\n\t\t\t\tdouble t;\n\t\t\t\ttie(s, t) = c[0];\n\t\t\t\ttie(g, t) = c[n - 1];\n\t\t\t}\n\t\t\tls.push_back(LS(s, s));\n\t\t\trep(i, n - 1)ls.push_back(cross_C_C(c[i], c[i + 1]));\n\t\t\tls.push_back(LS(g, g));\n\t\t}\n\t\t\n\t\tvector<vector<double>> DP(n + 1, vector<double>(2, INF));\n\t\tDP[0][0] = DP[0][1] = 0;\n\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tvector<P> v = { get<0>(ls[i]),get<1>(ls[i]) };\n\t\t\t\tvector<P> u = { get<0>(ls[j]),get<1>(ls[j]) };\n\t\t\t\trep(a,2)rep(b,2){\n\t\t\t\t\tauto s = LS(v[a], u[b]);\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int k = j + 1; k < i; k++)flag &= (isintersected_LS_LS(s, ls[k]));\n\t\t\t\t\tif (flag)DP[i][a] = min(DP[i][a], DP[j][b] + ABS(v[a]-u[b]));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcout << min(DP[n][0], DP[n][1]) << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n\n#define INF 1000000.0\n\nusing namespace std;\n\nstruct P{\n\tdouble x, y;\n\tP(double X=0.0, double Y=0.0){\n\t\tx = X;\n\t\ty = Y;\n\t} \n\tP operator+( const P &in ){\n\t\tP tmp( x + in.x , y + in.y );\n\t\treturn tmp;\n\t}\n\tP operator-( const P &in ){\n\t\tP tmp( x - in.x , y - in.y );\n\t\treturn tmp;\n\t}\n\tP operator*( const double &in ){\n\t\tP tmp( x * in , y * in );\n\t\treturn tmp;\n\t}\n\tdouble dot( const P &in ){\n\t\treturn x * in.x + y * in.y;\n\t}\n\tdouble cross( const P &in ){\n\t\treturn x * in.y - y * in.x;\n\t}\n};\n\n\n//交差しているか求める(どの3点も同直線上にない)\nbool check(P a1, P a2, P b1, P b2){\n\tP va = a2 - a1, vb = b2 - b1;\n\tP v1 = b1 - a1, v2 = b2 - a2;\n\n//\tcout << \"va \" << va.first << \" \" << va.second << endl;\n//\tcout << \"vb \" << vb.first << \" \" << vb.second << endl;\n//\tcout << \"v1 \" << v1.first << \" \" << v1.second << endl;\n//\tcout << \"v2 \" << v2.first << \" \" << v2.second << endl;\n//\tcout << \"va.cross(v1) \" << va.cross( v1 ) << endl;\n//\tcout << \"va.cross(v2) \" << va.cross( v2 ) << endl;\n\t\n\tif( ( va.cross( v1 ) * va.cross( v2 ) ) >= 0 )\n\t\treturn false;\n\n\tif( ( vb.cross( v1 ) * vb.cross( v2 ) ) >= 0 )\n\t\treturn false;\n\t\n\treturn true;\n}\n\n//2円の交点を求める(2円の中心の中点cからのベクトルvを返す(交点はc±v) )\nP circlecross(P a, double ra, P b, double rb, P *cen){\n\t//P cen = ( a + b ) * 0.5;\n//\tdouble r = ra / (ra + rb);\n\n\tdouble c = sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );\n\tdouble r = (ra*ra - rb*rb + c*c ) / ( 2.0 * c*c );\n//\tcout << \"r  \" << r << endl;\n\tdouble e = c * r;\n//\tcout << \"e  \" << e << endl;\n\tdouble d = sqrt( ra*ra - e*e );\n//\tcout << \"d  \" << d << endl;\n\t\n\tP tmp;\n//\tcout << \"d \" << d << \"  c \" << c << endl;\n\ttmp.x = d * (a.y - b.y) / c;\n\ttmp.y = d * (b.x - a.x) / c;\n\n\t*cen = a * (1.0-r) + b * r;\n\t\n\treturn tmp;\n}\n\nint n;\n\nint solve(){\n\tP c[100], p[101][2];\n\tdouble r[100];\n\tdouble dist[205][205];\n\t\n\tcin >> c[0].x >> c[0].y >> r[0];\n\tp[0][0] = c[0];\n\tp[0][1] = c[0];\n\tfor(int i=1; i<n; i++){\n\t\tcin >> c[i].x >> c[i].y >> r[i];\n\t\tP cen;\n\t\tP d = circlecross( c[i-1], r[i-1], c[i], r[i], &cen );\n//\t\tcout << \"circlecross \" << d.x << d.y << endl;\n\t//\tdouble rate = sqrt( (r[i-1]*r[i-1] - r[i]*r[i] + c*c ) / ( 2.0 * c*c ) );\n//\t\tP cen = ( c[i] * (1-rate) + ( c[i-1] * rate );\n\t\tp[i][0] = cen + d;\n\t\tp[i][1] = cen - d;\n\t}\n\tp[n][0] = c[n-1];\n\tp[n][1] = c[n-1];\n\n\t//求める\n\tfill( dist[0], dist[0]+205*205, INF );\n\tfor(int i=0; i<n*2; i++){\n\t\tfor(int j=i+1; j<=n*2; j++){\n\t\t\tbool f=true;\n\t\t\tfor(int k=i/2+1; k<j/2; k++){\n\t//\t\t\tcout << \"ijk \" << i << \" \" << j << \" \" << k << endl;\n\t\t\t\tif( !check( p[i/2][i%2], p[j/2][j%2], p[k][0], p[k][1] ) )\n\t\t\t\t\tf = false;\n\t\t\t}\n\t\t\tif( f ){\n\t\t\t\tdouble x = p[i/2][i%2].x - p[j/2][j%2].x;\n\t\t\t\tdouble y = p[i/2][i%2].y - p[j/2][j%2].y;\n\t\t\t\tdist[i][j] = sqrt( x*x + y*y );\n\t\t\t}\n\t\t}\n\t}\n\t//最短経路\n\tfor(int k=1; k<n*2; k++){\n\t\tfor(int i=0; i<=n*2; i++){\n\t\t\tfor(int j=0; j<=n*2; j++){\n\t\t\t\tdist[i][j] = min( dist[i][j], dist[i][k] + dist[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\n//\tcout << dist[0][n*2] << endl;\n\tprintf(\"%0.6f\\n\", dist[0][n*2] );\n\t\n\treturn 0;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#define LT(x,y) ((x)-(y)<=-EPS)\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\n\ndouble dot(P a, P b) {\n\treturn (a.real()*b.real() + a.imag()*b.imag());\n}\n\ndouble cross(P a, P b) {\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\nvp cross_circles(P c1, double r1, P c2, double r2) {\n\tdouble d = abs(c2-c1);\n\tif(LT(r1+r2, d) || LT(d, fabs(r1-r2))) {\n\t\treturn vp();\n\t}\n\tdouble l = 0.5*((r1*r1-r2*r2)/d+d);\n\tdouble h = sqrt(r1*r1-l*l);\n\tvp ret(2);\n\tret[0] = P(l,+h)*(c2-c1)/d+c1;\n\tret[1] = P(l,-h)*(c2-c1)/d+c1;\n\treturn ret;\n}\n\nint is_point_on_ls(P a, P b, P c) {\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) { \n\tif((cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS) &&\n\t   (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS))\n\t   return true;\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2)\n\t\t|| is_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\ntypedef vector<double> vd;\n\nstruct state {\n\tint p;\n\tdouble c;\n\tstate(int p, double c) : p(p), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.c<c;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<vd> data(n, vd(3));\n\t\tREP(i, n) {\n\t\t\tREP(j, 3) {\n\t\t\t\tcin >> data[i][j];\n\t\t\t}\n\t\t}\n\n\t\tvp points(2*n);\n\t\tpoints[0] = P(data[0][0], data[0][1]);\n\t\tpoints[2*n-1] = P(data[n-1][0], data[n-1][1]);\n\t\tREP(i, n-1) {\n\t\t\tvp ccp = cross_circles(P(data[i][0], data[i][1]), data[i][2], P(data[i+1][0], data[i+1][1]), data[i+1][2]);\n\t\t\tpoints[2*i+1] = ccp[0];\n\t\t\tpoints[2*i+2] = ccp[1];\n\t\t}\n\n\t\tvector<vd> dist(2*n, vd(2*n, INF));\n\t\tREP(i, 2*n) {\n\t\t\tFOR(j, i+1, 2*n-1) {\n\t\t\t\tP s = points[i], g = points[j];\n\t\t\t\tint sl = (i+1)/2, gl = j/2;\n\t\t\t\tif(sl == 0) {\n\t\t\t\t\tsl++;\n\t\t\t\t}\n\t\t\t\tbool ok = true;\n\t\t\t\tFOR(k, sl, gl) {\n\t\t\t\t\tif(is_intersected_ls(s, g, points[2*k-1], points[2*k])) {\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok) {\n\t\t\t\t\tdist[i][j] = dist[j][i] = abs(g-s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvd cost(2*n, INF);\n\t\tcost[0] = 0;\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0, 0));\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\n\t\t\tif(st.p == 2*n-1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(d, 2*n) {\n\t\t\t\tdouble nc = st.c + dist[st.p][d];\n\t\t\t\tif(nc < cost[d]) {\n\t\t\t\t\tcost[d] = nc;\n\t\t\t\t\tQ.push(state(d, nc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.6f\\n\", cost[2*n-1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef struct Point {\n\tdouble x, y;\n\tPoint operator - (const Point& o) const { return Point{x - o.x, y - o.y}; }\n\tPoint operator + (const Point& o) const { return Point{x + o.x, y + o.y}; }\n\tPoint operator * (double d) const { return Point{x * d, y * d}; }\n\tPoint operator / (double d) const { return Point{x / d, y / d}; }\n} Vector;\n\ndouble angle(double a, double b, double c) { return acos((b * b + c * c - a * a) / (2.0 * b * c)); }\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\nVector unitVector(Vector a) { return a / abs(a); }\nVector rotate(Vector a, double s) { return Vector{a.x * cos(s) - a.y * sin(s), a.x * sin(s) + a.y * cos(s)}; }\n\nint n;\ndouble x[100], y[100], r[100];\n\npair< Point, Point > crossPoint(int i, int j) {\n\tPoint a{x[i], y[i]}, b{x[j], y[j]};\n\tPoint x = unitVector(b - a) * r[i];\n\tdouble s = angle(r[j], abs(b - a), r[i]);\n\treturn pair< Point, Point >(a + rotate(x, s), a + rotate(x, -s));\n}\n\nint ccw(Point a, Point b, Point c) {\n\tVector ba = b - a, ca = c - a;\n\tif (cross(ba, ca) > 0) return 1;\n\tif (cross(ba, ca) < 0) return -1;\n\tif (dot(ba, ca) < 0) return 2;\n\tif (abs(ba) < abs(ca)) return -2;\n\treturn 0;\n}\n\nvoid solve() {\n\tvector< vector< Point > > vp(2, {Point{x[0], y[0]}});\n\t\n\tfor_(i,0,n-1) {\n\t\tpair< Point, Point > cp = crossPoint(i, i + 1);\n\t\tvp[0].push_back(cp.first);\n\t\tvp[1].push_back(cp.second);\n\t}\n\t\n\tvp[0].push_back(Point{x[n-1], y[n-1]});\n\tvp[1].push_back(Point{x[n-1], y[n-1]});\n\t\n\tassert((int)vp[0].size() == n+1);\n\tvector< vector< double > > dst(2, vector< double >(n+1, 1e9));\n\tdst[0][0] = dst[1][0] = 0;\n\t\n\tfor_(i,0,n) for_(bi,0,2) for_(j,i+1,n+1) for_(bj,0,2) {\n\t\tbool flag = true;\n\t\tfor_(k,i+1,j) flag &= (ccw(vp[bi][i], vp[bj][j], vp[0][k]) * ccw(vp[bi][i], vp[bj][j], vp[1][k]) == -1);\n\t\tif (flag) dst[bj][j] = min(dst[bj][j], dst[bi][i] + abs(vp[bi][i] - vp[bj][j]));\n\t}\n\t\n\tprintf(\"%.9f\\n\", dst[0][n]);\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor_(i,0,n) cin >> x[i] >> y[i] >> r[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n  }\n  bool operator == (const P& a, const P& b) {\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\nP pin(){\n  double x,y;\n  char d;\n  cin>>x>>y;\n  P p(x,y);\n  return p;\n}\nvoid PIN(P* a,int n){\n  rep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n  double t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n  return p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n  return (distanceLP(l,c.c) < c.r+EPS &&\n  (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n  }*/\nint intersectCS(C c,L &l){\n  if(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n  const double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n  if(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n  if(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n  const P h=projection(l,c.c);\n  if(dot(l[0]-h,l[1]-h)<0)return 2;\n  return 0;\n}\nP crosspointSS(L a,L b){\n  double t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n  double t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n  return b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n  P pr=projection(l,c.c);\n  P e=(l[1]-l[0])/abs(l[1]-l[0]);\n  double t=sqrt(c.r*c.r-norm(pr-c.c));\n  P a=pr+t*e;\n  P b=pr-t*e;\n  if(b<a)swap(a,b);\n  return L(a,b);\n}\nL crosspointCS(C c,L l){\n  if(intersectCS(c,l)==2)return crosspointCL(c,l);\n  L ret=crosspointCL(c,l);\n  if(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n  else ret[0]=ret[1];\n  return ret;\n}\nL crosspointCC(C a,C b){\n  P tmp=b.c-a.c;\n  double d=abs(tmp);\n  double q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n  double t=arg(tmp);//atan(tmp.imag()/tmp.real());\n  P p1=a.c+polar(a.r,t+q);\n  P p2=a.c+polar(a.r,t-q);\n  if(p2<p1)swap(p1,p2);\n  return L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n  double S =0;\n  for(int i =0;i <g.size();i++){\n    S +=(cross(g[i],g[(i+1)%g.size()]));\n  }\n  return abs(S/2.0);\n}\nbool isconvex(const G &g){\n  int n=g.size();\n  rep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n  return true;\n}\nint inconvex(const G& g, const P& p) {\n  bool in = false;\n  int n=g.size();\n  rep(i,n){\n    P a=g[i%n]-p;\n    P b=g[(i+1)%n]-p;\n    if(imag(a)>imag(b))swap(a, b);\n    if(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n    if(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n  }\n  return in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n  int n=ps.size(),k=0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n  for(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n    while(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n  ch.resize(k-1);\n  return ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n  return p*exp(P(.0,t*PI/180.0));\n}\nvector<L> tangentCC(C a,C b){\n  if(a.r<b.r)swap(a,b);\n  double d=abs(a.c-b.c);\n  vector<L>l;\n  if(d<EPS)return l;\n  if(a.r+b.r<d-EPS){//hanareteiru\n    double t=acos((a.r+b.r)/d);\n    t=t*180/PI;\n    l.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n    l.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n  }else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n    P p=a.c+a.r/d*(b.c-a.c);\n    l.pb(L(p,p+turn(b.c-a.c,90)));\n  }\n  if(abs(a.r-b.r)<d-EPS){//majiwatteiru\n    double t1=acos((a.r-b.r)/d);\n    t1=t1*180/PI;\n    double t2=180-t1;\n    l.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n    l.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n  }else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n    P p=a.c+a.r/d*(b.c-a.c);\n    l.pb(L(p,p+turn(b.c-a.c,90)));\n  }\n  return l;\n}\nvoid printL(const L &out){\n  printf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n  P p=pin();\n  double r;\n  cin>>r;\n  return C(p,r);\n}\nbool para(L a,L b){\n  return (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\n\n\ndouble Min(double a,double b){return (a<b?a:b);}\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<C>c;\n    rep(i,n){\n      double a,b;\n      cin>>a>>b;\n      P p(a,b);\n      double r;\n      cin>>r;\n      c.pb(C(p,r));\n    }\n    vector<L>g;\n    g.pb(L(c[0].c,P(inf,inf)));\n    rep(i,n-1){\n      L l=crosspointCC(c[i],c[i+1]);\n      g.pb(l);\n    }\n    g.pb(L(c[n-1].c,P(inf,inf)));\n    vector<vector<double> >dp(n+1,vector<double>(2,inf));\n    dp[0][0]=0;\n    rep(i,n)rep(j,2){\n      if(i==0&&j==1)continue;\n      P p=g[i][j];\n      loop(k,i+1,n+1)rep(l,2){\n\tif(k==n&&l==1)continue;\n\tbool h=true;\n\tloop(q,i+1,k){\n\t  if(q==n)continue;\n\t  if(intersectSS(L(p,g[k][l]),L(g[q][0],g[q][1]))==0)h=false;\n\t}\n\tif(h){\n\t  dp[k][l]=Min(dp[k][l],dp[i][j]+abs(g[k][l]-g[i][j]));\n\t}\n      }\n    }\n    printf(\"%.9f\\n\",Min(dp[n][0],dp[n][1]));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\nR dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    // ax+by+c=0\n    L(R a, R b, R c){\n        if(fabs(a) < eps) *this = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) *this = L(P(-c/a,0),P(-c/a,1));\n        else *this = L(P(-c/a,0), P(0,-c/b));\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p, R r) : p(p), r(r) { }\n    C(){}\n};\nbool debug = false;\nstruct VS {\n    vector<string> ls;\n    int cnt;\n    double POINT_SIZE;\n    double max_x, min_x, max_y, min_y;\n    static char buf[2048];\n\n    void chboundary(const C& c){\n        max_x = max<double>(max_x, c.p.real() + c.r);\n        max_y = max<double>(max_y, c.p.imag() + c.r);\n        min_x = min<double>(min_x, c.p.real() - c.r);\n        min_y = min<double>(min_y, c.p.imag() - c.r);\n    }\n\n    VS() : cnt(1), POINT_SIZE(1) { min_x = min_y = +inf; max_x = max_y = -inf; }\n    VS& clear(){ return *this = VS(); }\n\n    // 円\n    VS& append(C const& c, const char* color = \"black\"){\n        chboundary(c);\n        sprintf(buf, \"set object %d circle at %lf,%lf size %lf fc rgb \\\"%s\\\"\",\n                cnt++, (double)c.p.real(), (double)c.p.imag(), (double)c.r, color);\n        ls.push_back(buf);\n        return *this;\n    }\n\n    // 点\n    VS& append(P const& p, const char* color = \"black\"){\n        return append(C(p,POINT_SIZE), color);\n    }\n\n    // 多角形\n    VS& append(G const& g, const char* color = \"black\"){\n        string s;\n        sprintf(buf, \"set object %d polygon\", cnt++);\n        s += buf;\n        rep(i,g.size()){\n            chboundary(C(g[i],1));\n            sprintf(buf, \" %s %lf,%lf\", i==0 ? \"from\" : \"to\",\n                    (double)g[i].real(), (double)g[i].imag());\n            s += buf;\n        }\n        sprintf(buf,\n                \" to %lf,%lf fc rgb \\\"%s\\\"\",\n                (double)g.front().real(), (double)g.front().imag(), color);\n        s += buf; ls.push_back(s);\n        return *this;\n    }\n\n    // 線分\n    VS& append(L const& l, const char* color = \"black\"){\n        return append(G{l[0],l[1]}, color);\n    }\n\n    // 直接入力\n    VS& append(string const& s){\n        ls.push_back(s); return *this;\n    }\n\n    // 出力\n    VS& plot(string png_name = \"plt.png\"){\n        if(!debug) return *this;\n        FILE* fp = popen(\"gnuplot -persist\", \"w\");\n        // FILE* fp = stdout;\n        // FILE* fp = fopen((png_name + \".plt\").c_str(), \"w\");\n        {\n            double wy = max_y-min_y, wx = max_x-min_x;\n            double d = abs(wy-wx);\n            if(wy > wx){\n                max_x += d/2; min_x -= d/2;\n            } else {\n                max_y += d/2; min_y -= d/2;\n            }\n            POINT_SIZE = 0.1;\n        }\n        fprintf(fp, \"set size square\\n\");\n        fprintf(fp, \"set xrange [%lf:%lf]\\n\", min_x, max_x);\n        fprintf(fp, \"set yrange [%lf:%lf]\\n\", min_y, max_y);\n        fprintf(fp, \"set terminal pngcairo size 600,600\\n\");\n        fprintf(fp, \"set output \\\"%s\\\"\\n\", png_name.c_str());\n        for(auto const& line : ls) fprintf(fp, \"%s\\n\", line.c_str());\n        fprintf(fp, \"plot NaN notitle\\n\");\n        fprintf(fp, \"quit\\n\");\n        pclose(fp);\n        return *this;\n    }\n};\nchar VS::buf[2048];\n\nVS vsualizer;\n\n// CCW\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return -1; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b 直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c 直線上\n    return 0; // 2点以上が重なっている\n}\n\n// 交差判定\nbool isiLL(const L &l, const L &m) {\n    return\n        abs(cross(l[1]-l[0], m[1]-m[0])) > eps || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < eps;   // same line\n}\n\nbool isiLS(const L &l, const L &s) {\n    return\n        cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < eps; // s[1] is right of l\n}\n\nbool isiLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool isiSS(const L &s, const L &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool isiSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool isiCP(const C &c, const P &p) {\n    // 境界または内部\n    return abs(c.p - p) <= c.r + eps;\n}\n\nint isiCC(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(abs(d - r1 - r2) < eps) return  1; // 接する\n    if(d > r1 + r2)       return  0; // 共通部分を持たない\n    if(d < r1 - r2)       return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)       return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\n\n// 距離\nR dLP(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dLL(const L &l, const L &m) {\n    return isiLL(l, m) ? 0 : dLP(l, m[0]);\n}\n\nR dLS(const L &l, const L &s) {\n    if (isiLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\nR dSP(const L &s, const P &p) {\n    const P r = proj(s, p);\n    if (isiSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dSS(const L &s, const L &t) {\n    if (isiSS(s, t)) return 0;\n    return min(min(dSP(s, t[0]), dSP(s, t[1])),\n               min(dSP(t, s[0]), dSP(t, s[1])));\n}\n\nR dCP(const C &c, const P &p) {\n    return max(0. , abs(c.p - p));\n}\n\n// 交点\nvector<P> iLL(const L &l, const L &m) {\n    R A = cross(l[1] - l[0], m[1] - m[0]);\n    R B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) throw \"PRECONDITION NOT SATISFIED!!!\";\n    return {m[0] + B / A * (m[1] - m[0])};\n}\n\nvector<P> iSS(const L& s, const L& t) {\n    if(isiSS(s,t)) return iLL(s,t);\n    else return {};\n}\n\nvector<P> iLS(const L& l, const L& s){\n    if(isiLS(l,s)) return iLL(l,s);\n    else return {};\n}\n\n// !!! not verified !!!\nvector<P> iCL(const C& c, const L& l){\n    R d = dLP(l,c.p);\n    // 接する\n    if(abs(d-c.r) < eps) return { proj(l, c.p) };\n    // 共有点を持たない\n    if(d > c.r) return {};\n    P h = proj(l, c.p);\n    P v = h - c.p;\n    P u = v * P(0,1) * sqrt(c.r*c.r - d*d) / abs(v);\n    return {h+u, h-u};\n}\n\n// !!! not verified !!!\nvector<P> iCC(const C& c1, const C& c2){\n    int i = isiCC(c1,c2);\n    // 共通部分なし || 内部\n    if(i==0 || abs(i)==3) return {};\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    // 接する\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d };\n    // 2つの交点\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = -2. * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return iCL(c1, L(A,B,C));\n}\n\nint main(){\n    int n;\n    int cnt = 1;\n    while(cin>>n && n){\n        vsualizer.clear();\n        vector<C> cs(n);\n        rep(i,n){\n            int x,y,r;\n            cin>>x>>y>>r;\n            cs[i] = C(P(x,y),r);\n            vsualizer.append(cs[i], \"red\");\n        }\n        vector<L> ls(n-1);\n        for(int i=0;i<n-1;i++){\n            auto l = iCC(cs[i],cs[i+1]);\n            ls[i] = L(l[0],l[1]);\n        }\n\n        int N=n*2;\n        double d[N][N];\n        rep(i,N)rep(j,N){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=inf;\n        }\n\n        L st(cs[0].p,cs[n-1].p);\n        bool okst = true;\n        for(int i=0;i<n-1;i++){\n            auto &ps = ls[i];\n            P &p1=ps[0], &p2=ps[1];\n            d[i*2][i*2+1] = abs(p1-p2);\n            vsualizer.append(L(p1,p2));\n            if(!isiSS(st,{p1,p2})) okst=false;\n            for(int j=i+1;j<n-1;j++){\n                auto &qs = ls[j];\n                P &q1=qs[0], &q2=qs[1];\n                L s11(p1,q1), s12(p1,q2), s21(p2,q1), s22(p2,q2);\n                bool ok11 = true, ok12 = true, ok21 = true, ok22 = true;\n                for(int k=i+1;k<=j-1;k++){\n                    auto &rs = ls[k];\n                    L s(rs[0],rs[1]);\n                    if(!isiSS(s,s11))ok11=false;\n                    if(!isiSS(s,s12))ok12=false;\n                    if(!isiSS(s,s21))ok21=false;\n                    if(!isiSS(s,s22))ok22=false;\n                }\n                if(ok11){\n                    d[i*2][j*2] = d[j*2][i*2] = abs(p1-q1);\n                    vsualizer.append(L(p1,q1));\n                }\n                if(ok12){\n                    d[i*2][j*2+1] = d[j*2+1][i*2] = abs(p1-q2);\n                    vsualizer.append(L(p1,q2));\n                }\n                if(ok21){\n                    d[i*2+1][j*2] = d[j*2][i*2+1] = abs(p2-q1);\n                    vsualizer.append(L(p2,q1));\n                }\n                if(ok22){\n                    d[i*2+1][j*2+1] = d[j*2+1][i*2+1] = abs(p2-q2);\n                    vsualizer.append(L(p2,q2));\n                }\n            }\n\n            L s1(ps[0],cs[0].p);\n            L s2(ps[1],cs[0].p);\n            bool oks1 = true, oks2 = true;\n            for(int j=0;j<i;j++){\n                auto &t = ls[j];\n                L s(t[0],t[1]);\n                if(!isiSS(s,s1)) oks1 = false;\n                if(!isiSS(s,s2)) oks2 = false;\n            }\n            if(oks1){\n                d[N-1][i*2] = d[i*2][N-1] = abs(s1[0]-s1[1]);\n                vsualizer.append(s1);\n            }\n            if(oks2){\n                d[N-1][i*2+1] = d[i*2+1][N-1] = abs(s2[0]-s2[1]);\n                vsualizer.append(s2);\n            }\n            L t1(ps[0],cs[n-1].p);\n            L t2(ps[1],cs[n-1].p);\n            bool okt1 = true, okt2 = true;\n            for(int j=i+1;j<n-1;j++){\n                auto t = ls[j];\n                L s(t[0],t[1]);\n                if(!isiSS(s,t1)) okt1 = false;\n                if(!isiSS(s,t2)) okt2 = false;\n            }\n            if(okt1){\n                d[N-2][i*2] = d[i*2][N-2] = abs(t1[0]-t1[1]);\n                vsualizer.append(t1);\n            }\n            if(okt2){\n                d[N-2][i*2+1] = d[i*2+1][N-2] = abs(t2[0]-t2[1]);\n                vsualizer.append(t2);\n            }\n        }\n        if(okst){\n            d[N-1][N-2] = d[N-2][N-1] = abs(st[0]-st[1]);\n            vsualizer.append(st);\n        }\n        rep(k,N)rep(i,N)rep(j,N)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        printf(\"%.4lf\\n\",d[N-1][N-2]);\n\n        string name = \"pCase\" + to_string(cnt++) + \".png\";\n        vsualizer.plot(name);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double INF = 1e100;\nconst double EPS = 1e-9;\nconst double PI = 6.0 * asin(0.5);\n\ndouble dot(P a, P b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(P a, P b){ return   a.real() * b.imag() - a.imag() * b.real(); }\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\nP proj(P p, L l){\n    return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //???????¨???????\n  if(cross(b,c) < -EPS) return -1; // ????¨???????\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b ????????´???\n  if(norm(b) < norm(c)) return -2; // a -- b -- c ????????´???\n  return 0; // a -- c -- b ????????´????\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\n//???\nstruct Circle{\n  P c; //?????????\n  double r; //??????\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\n//?????¨???????????????\nvector<P> getIntersectCS(Circle c, L s){\n  vector<P> res;\n  P h = proj(c.c, s);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS){\n    if(isIntersectSP(s,h)) res.push_back(h);\n  }\n  else {\n    P v = s.second - s.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    if(isIntersectSP(s, h+v)) res.push_back(h+v);\n    if(isIntersectSP(s, h-v)) res.push_back(h-v);\n  }\n  return res;\n}\n\n\n//?????¨????????????\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res; //????????¨?????????????????´???????????????????????????????????????\n  if(r1 + r2< d - EPS || d + EPS < abs(r1-r2)) return res; //???????????????\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\nbool isInnerCP( Circle c, P p ){\n  return abs( c.c - p ) < c.r+EPS;\n}\n\n//?????????????????????????????¨???????????????????????????\nbool isInnerCS( vector<Circle>& c, L s ){\n  vector<P> pos; pos.push_back( s.first ); pos.push_back( s.second );\n  for(int i=0;i<(int)c.size();i++){\n    vector<P> ret = getIntersectCS( c[i], s );\n    for(int j=0;j<(int)ret.size();j++) pos.push_back( ret[j] );\n  }\n  sort( pos.begin(), pos.end() );\n  for(int i=0;i<(int)pos.size()-1;i++){\n    P cp = (pos[i]+pos[i+1])/2.0;\n    bool f = false;\n    for(int j=0;j<(int)c.size();j++){\n      f = isInnerCP( c[j], cp ); if( f ) break;\n    }\n    if(!f) return false;\n  }\n  return true;\n}\n\n\n\nint N;\n\nvector<int> G[333];\nP V[333];\ndouble H[333];\nstruct state {\n  int id;\n  double c;\n  state(int id,double c):id(id),c(c) {}\n  bool operator<(const state& st) const {\n    return c > st.c;\n  }\n};\nvoid dijk(int s,int g){\n  fill( H, H+320, INF );\n  priority_queue<state> q;\n  q.push( state( s, 0.0 ) );\n  H[s] = 0.0;\n  while( !q.empty() ) {\n    state p = q.top(); q.pop();\n    if( p.c > H[p.id] ) continue;\n    if( p.id == g ) {\n      printf(\"%.9lf\\n\",p.c);\n      return;\n    }\n    for(int i=0;i<(int)G[p.id].size();i++){\n      int to = G[p.id][i];\n      double sc = p.c + abs( V[p.id] - V[to] );\n      if( H[to] > sc ){\n        H[to] = sc;\n        q.push( state( to, sc )  );\n      }\n    }\n  }\n  assert( false );\n}\n\nint main(){\n  while( cin >> N && N ){\n    vector<Circle> cs;\n    for(int i=0;i<N;i++){\n      int x,y,r; cin >> x >> y >> r;\n      cs.push_back( Circle( P(x,y), r ) );\n    }\n    V[0] = cs[0].c;\n    V[1] = cs[N-1].c;\n    int cnt = 2;\n    for(int i=0;i<N-1;i++){\n      vector<P> ps = getIntersectCC( cs[i],cs[i+1] );\n      for(int j=0;j<(int)ps.size();j++)\n        V[cnt++] = ps[j];\n    }\n\n    for(int i=0;i<cnt;i++){\n      for(int j=i+1;j<cnt;j++){\n        if( isInnerCS( cs, L(V[i], V[j]) ) ){\n          G[i].push_back( j );\n          G[j].push_back( i );\n        }\n      }\n    }\n\n    dijk(0,1);\n\n    for(int i=0;i<cnt;i++) G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-5;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (sqrt(cross(b-a, c-a)) > EPS) return 1;\n    if (sqrt(cross(b-a, c-a)) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (sqrt(cross(b-a, c-a)) > EPS) return 1;\n    if (sqrt(cross(b-a, c-a)) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\nconst double EPS = 1e-7;\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\nostream& operator << (ostream &os , const vector<double> &v) { for(const double t : v) os << \"\\t\" << (t >= INF ? -1 : t); return os << endl; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\n\n\nusing Point = complex<double>;\n#define X(a) real(a)\n#define Y(a) imag(a)\ntemplate<class T> bool eq(T a, T b) { return abs(a - b) < EPS; }\nbool operator < (Point a, Point b) { return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag(); }\nbool operator > (Point a, Point b) { return !eq(a.real(), b.real()) ? a.real() > b.real() : a.imag() > b.imag(); }\nistream &operator >> (istream& is, Point& p) { double a, b; is >> a >> b; p.X(a); p.Y(b); return is; }\nostream &operator << (ostream& os, const Point& p) { return os << \"(\" << X(p) << \",\" << Y(p) << \")\"; }\ndouble dot(Point a, Point b) { return a.X() * b.X() + a.Y() * b.Y(); }\ndouble cross(Point a, Point b) { return a.X() * b.Y() - a.Y() * b.X(); }\ndouble length2(Point p) { return p.X() * p.X() + p.Y() * p.Y(); }\ndouble length(Point p) { return sqrt(length2(p)); }\ndouble distance(Point a, Point b) { return length(a - b); }\nPoint unit(Point p) { return p / length(p); }\n\nenum ccw_t {\n    COUNTER_CLOCK_WISE = 1,\n    CLOCK_WISE = -1,\n    STRAIGHT_C_A_B = 2,\n    STRAIGHT_A_B_C = -2,\n    STRAIGHT_A_C_B = 0\n};\n\nccw_t ccw(Point a, Point b, Point c){\n    Point ab = b - a, ac = c - a;\n    if( cross(ab,ac) > EPS ) return COUNTER_CLOCK_WISE; // +1 a-b-c ???????¨???????\n    if( cross(ab,ac) < -EPS ) return CLOCK_WISE;        // -1 a-b-c ????¨???????\n    if( dot(ab,ac) < -EPS ) return STRAIGHT_C_A_B;      // +2 c-a-b\n    if( length2(ab) < length2(ac) )return STRAIGHT_A_B_C;     // -2 a-b-c or a==b\n    return STRAIGHT_A_C_B;                              //  0 a-c-b or b==c or a==c\n}\n\nstruct Circle{\n    Point c;\n    double r;\n};\nistream &operator >> (istream& is, Circle& c){ return is >> c.c >> c.r;}\nostream &operator << (ostream& os, Circle& c){ return os << c.c << \" r = \" << c.r;}\n\narray<Point, 2> cross_points(Circle c1, Circle c2) {\n    double d = distance(c1.c, c2.c);\n    assert(d > 0);\n    // c1.c ?????????c1,c2????????????????????´?????¨c1.c->c2.c ??????????????§????????¢\n    double x = (pow(c1.r, 2) - pow(c2.r, 2) + pow(d, 2)) / (2 * d);\n    assert(c1.r > x);\n    double h = sqrt(pow(c1.r, 2) - pow(x, 2));    \n    Point mid = unit(c2.c - c1.c) * x;\n    Point vertical = unit(Point(-Y(mid), X(mid))) * h; // ???????????????????????????\n    return { c1.c + mid + vertical, c1.c + mid - vertical };\n}\n\nstruct Segment{\n    Point a, b;\n    Segment(){}\n    Segment(const Point& a, const Point& b):a(a), b(b){}\n};\n\nbool does_intersect(const Segment &a, const Segment &b){\n    return (int)ccw(a.a, a.b, b.a) * (int)ccw(a.a, a.b, b.b) <= 0 &&\n            (int)ccw(b.a, b.b, a.a) * (int)ccw(b.a, b.b, a.b) <= 0;\n}\n\nstruct State {\n    int index;\n    double cost;\n    State(int i, double c):index(i), cost(c) {}\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\n// O(ElogV)\nvector<double> dijkstra(const vector<vector<double>> &G, int start) {\n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<double> dist(G.size(), INF);\n    que.emplace(start, 0);\n    dist[start] = 0;\n    while(not que.empty()){\n        State now = que.top(); que.pop();\n        rep(i, G.size()) {\n            if(G[now.index][i] >= INF) continue;                                               \n            if(dist[i] > now.cost + G[now.index][i]) {\n                State nxt = State(i, now.cost + G[now.index][i]);\n                dist[i] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return dist;\n}\n\nclass Solver {\n  public:\n    bool solve() {\n        int N; cin >> N;\n        if(N == 0) return false;\n        vector<Circle> C(N); cin >> C;        \n        vector<array<Point, 2>> P;\n        Point s = C.front().c, e = C.back().c;\n        P.push_back({s, s});\n        rep(i, N - 1) {\n            P.push_back(cross_points(C[i], C[i + 1]));\n        }\n        P.push_back({e, e});\n                \n        vector<vector<double>> dist(P.size() * 2, vector<double>(P.size() * 2, INF));\n        rep(i, dist.size()) dist[i][i] = 0;\n        rep(i, P.size()) rep(ii, 2) {\n            Point a = P[i][ii];\n            repeat(j, i + 1, P.size()) rep(jj, 2) {\n                Point b = P[j][jj];\n                Segment s1(a, b);\n                bool ok = true;\n                repeat(k, i + 1, j) {                    \n                    if(!does_intersect(s1, Segment(P[k][0], P[k][1]))) ok = false;\n                }\n                if(ok) {\n                    dist[i*2 + ii][j*2 + jj] = distance(a, b);\n                }\n            }\n        }\n\n        auto ans = dijkstra(dist, 0);\n\n        printf(\"%.6lf\\n\", ans.back());\n\n        return true;\n    }\n};\n\nint main() {\n    while(Solver().solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ \n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; \n    if(cross(v1,v2)<-EPS) return -1; \n\tif(dot(v1,v2)<-EPS) return +2; \n\tif(v1.norm()<v2.norm()) return -2; \n    return 0; \n}\n \nbool intersect_ss(Line l,Line m){\n\treturn ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; \n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; \n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; \n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; \n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; \n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; \n    return 2; \n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; \n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; \n\treturn 0; \n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N;\n\tCircle C[100];\n\twhile(cin>>N,N){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>C[i].c.x>>C[i].c.y>>C[i].r;\n\t\t}\n\t\tPolygon way[2];\n\t\tway[0].push_back(C[0].c); way[1].push_back(C[1].c);\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tPoint p1,p2;\n\t\t\tcrosspoint_cc(C[i],C[i+1],p1,p2);\n\t\t\tway[0].push_back(p1); way[1].push_back(p2);\n\t\t}\n\t\tway[0].push_back(C[N-1].c); way[1].push_back(C[N-1].c);\n\t\tdouble dp[101][2];\n\t\tfill_n((double*)dp,101*2,INF); dp[0][0] = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tfor(int k=i+1;k<=N;k++){\n\t\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\t\tLine l1(way[j][i],way[l][k]);\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int m=i+1;m<k;m++){\n\t\t\t\t\t\t\tif(intersect_ss(l1,Line(way[0][m],way[1][m]))==false)\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag==true){\n\t\t\t\t\t\t\tdouble d = sqrt((way[l][k]-way[j][i]).norm());\n\t\t\t\t\t\t\tdp[k][l] = min(dp[k][l],dp[i][j]+d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[N][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment,[-PI,PI]\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\n// cos a\nlong double costh(long double a, long double b,\n                  long double c) {\n  return (b * b + c * c - a * a) / (2.0L * b * c);\n}\n\n// dot(a,b) = |a||b|cos x\nlong double dot(CP a, CP b) { return (conj(a) * b).X; }\n// cross(a,b) : area of parallelogram\n// sign : a-> b ,counter clockwise? + : -\nlong double cross(CP a, CP b) { return (conj(a) * b).Y; }\nlong double corner(CP a, CP b) {\n  //[0,PI]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP projection(CP s, CP t, CP p) {\n  CP base = t - s;\n  long double r = dot(p - s, base) / norm(base);\n  return s + base * r;\n}\n\nCP reflection(CP s, CP t, CP p) {\n  CP tmp = (projection(s, t, p) - p);\n  tmp *= 2;\n  return p + tmp;\n}\n\nCP intersectionLL(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP s, CP t, CP p) {\n  // if not use end point, dot(s - p, t - p) < 0\n  return abs(cross(s - p, t - p)) <= 1e-10 &&\n         dot(s - p, t - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersectionLL(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong double distLP(CP s, CP t, CP p) {\n  return abs(cross(t - s, p - s) / abs(t - s));\n}\n\n// segmentver.\nlong double distSP(CP s, CP t, CP p) {\n  if(dot(t - s, p - s) < 0) return abs(p - s);\n  if(dot(s - t, p - t) < 0) return abs(p - t);\n  return distLP(s, t, p);\n}\n\n// segment and segment\nlong double distSS(CP a, CP b, CP c, CP d) {\n  long double res = 1e18;\n  if(iscross(a, b, c, d)) return 0.0L;\n  res = min(res, distSP(a, b, c));\n  res = min(res, distSP(a, b, d));\n  res = min(res, distSP(c, d, a));\n  res = min(res, distSP(c, d, b));\n  return res;\n}\n\n// counter clockwise\nbool is_convex(const vector<CP> &v) {\n  int n = v.size();\n  for(int i = 0; i < n; ++i)\n    if(cross(v[(i + 1) % n] - v[i],\n             v[(i + 2) % n] - v[(i + 1) % n]) < -EPS)\n      return 0;\n  return 1;\n}\n\nvector<CP> convex_hull(vector<CP> &ps) {\n  auto lmd = [&](const CP &l, const CP &r) {\n    if(l.X != r.X) return l.X < r.X;\n    return l.Y < r.Y;\n  };\n  vector<CP> qs;\n  int psize = ps.size();\n  sort(ps.begin(), ps.end(), lmd);\n  int k = 0;\n  qs.resize(psize * 2);\n  for(int i = 0; i < psize; ++i) {\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],\n                         ps[i] - qs[k - 1]) <= 0)\n      --k;\n    qs[k++] = ps[i];\n  }\n  for(int i = psize - 2, t = k; i >= 0; --i) {\n    while(k > t && cross(qs[k - 1] - qs[k - 2],\n                         ps[i] - qs[k - 1]) <= 0)\n      --k;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\nlong double convex_diameter(vector<CP> &newv) {\n  vector<CP> v = convex_hull(newv);\n  int n = v.size(), i = 0, j = 0;\n  if(n == 2) return abs(v[0] - v[1]);\n  for(int k = 0; k < n; ++k) {\n    if(v[k].X < v[i].X) i = k;\n    if(v[k].X > v[j].X) j = k;\n  }\n  long double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(v[i] - v[j]));\n    if(cross(v[(i + 1) % n] - v[i], v[(j + 1) % n] - v[j]) <\n       0)\n      (++i) %= n;\n    else\n      (++j) %= n;\n  }\n  return res;\n}\n\nvector<CP> convex_cut(const vector<CP> &v, const CP &s,\n                      const CP &t) {\n  vector<CP> res;\n  int n = v.size();\n  for(int i = 0; i < n; ++i) {\n    CP nows = v[i], nowt = v[(i + 1) % n];\n    if(cross(t - s, nows - s) >= -EPS) res.push_back(nows);\n    if(cross(t - s, nows - s) * cross(t - s, nowt - s) < 0)\n      res.push_back(intersectionLL(s, t, nows, nowt));\n  }\n  return res;\n}\n\nstruct Circle {\n  CP o;\n  long double r;\n  Circle(long double _x = 0.0L, long double _y = 0.0L,\n         long double _r = 0.0L)\n      : o(CP(_x, _y)), r(_r) {}\n  Circle(CP _o, long double _r = 0.0) : o(_o), r(_r) {}\n};\n\nvoid intersectionCC(Circle c1, Circle c2, CP &res1,\n                    CP &res2) {\n  long double d = abs(c1.o - c2.o);\n  long double arg = acos(costh(c2.r, c1.r, d));\n  res1 = (c2.o - c1.o) * CP(cos(arg), sin(arg));\n  res1 *= c1.r / abs(res1);\n  res1 += c1.o;\n  res2 = reflection(c1.o, c2.o, res1);\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nvoid intersectionCL(Circle ci, CP s, CP t, CP &res1,\n                    CP &res2) {\n  res1 = res2 = projection(s, t, ci.o);\n  long double r = sqrtl(ci.r * ci.r - norm(res1 - ci.o));\n  t -= s;\n  t *= r / abs(t);\n  res1 += t;\n  res2 -= t;\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nvoid contactCP(Circle ci, CP p, CP &res1, CP &res2) {\n  long double d = abs(ci.o - p);\n  if(abs(d - ci.r) <= EPS) {\n    res1 = res2 = p;\n    return;\n  }\n  else if(d < ci.r) {\n    res1 = res2 = CP(-1e18, -1e18);\n    return;\n  }\n  long double arg = asin(ci.r / d);\n  res1 = (ci.o - p) * CP(cos(arg), sin(arg));\n  res1 *= (d * cos(arg)) / abs(res1);\n  res1 += p;\n  res2 = reflection(p, ci.o, res1);\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nlong double polygonarea(const vector<CP> &v) {\n  int n = v.size();\n  long double res = 0;\n  for(int i = 0; i < n; ++i)\n    res +=\n        (v[(i - 1 + n) % n].X - v[(i + 1) % n].X) * v[i].Y;\n  return res / 2.0L;\n}\n\nlong long calc_clockwise(CP s, CP t, CP p) {\n  t -= s;\n  p -= s;\n  if(cross(t, p) > EPS) return 1;   // \"COUNTER_CLOCKWISE\"\n  if(cross(t, p) < -EPS) return -1; //\"CLOCK_WISE\"\n  if(dot(t, p) < 0) return 2;       // ONLINE_BACK\n  if(norm(t) < norm(p)) return -2;  // ONLINE_FRONT\n  return 0;                         // ON_SEGMENT\n}\n\nlong long n;\nvector<vector<long double>> dist;\nvector<CP> points;\nvector<int> id;\nvector<Circle> circles;\n\nlong double solve();\n\nint main() {\n  cout << fixed << setprecision(10);\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    circles.resize(n);\n    for(int i = 0; i < n; ++i) {\n      int x, y;\n      cin >> x >> y >> circles[i].r;\n      circles[i].o = CP(x, y);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong double solve() {\n  points.clear();\n  dist.clear();\n  id.clear();\n  points.push_back(circles[0].o);\n  id.push_back(0);\n  for(int i = 0; i < n - 1; ++i) {\n    points.push_back(CP(0, 0));\n    points.push_back(CP(0, 0));\n    id.push_back(i + 1);\n    id.push_back(i + 1);\n    intersectionCC(circles[i], circles[i + 1],\n                   points[1 + 2 * i], points[2 + 2 * i]);\n  }\n  points.push_back(circles[n - 1].o);\n  id.push_back(n);\n  int psize = points.size();\n  dist.assign(psize, vector<long double>(psize, 1e18));\n  for(int i = 0; i < psize; ++i)\n    for(int j = i; j < psize; ++j) {\n      bool ch = 1;\n      CP nowp = points[i], st = points[i], go = points[j];\n      if(i == 0) {\n        CP dummy1, dummy2;\n        intersectionCL(circles[0], st, go, dummy1, dummy2);\n        if(norm(dummy2 - go) < norm(dummy1 - go))\n          dummy1 = dummy2;\n        st = dummy1;\n      }\n      if(j == psize - 1) {\n        CP dummy1, dummy2;\n        intersectionCL(circles[n - 1], st, go, dummy1,\n                       dummy2);\n        if(norm(dummy2 - st) < norm(dummy1 - st))\n          dummy1 = dummy2;\n        go = dummy1;\n      }\n      nowp = st;\n      for(int k = max(id[i], 1); k < id[j]; ++k) {\n        if(distLP(st, go, circles[k].o) >\n               circles[k].r + EPS ||\n           abs(nowp - circles[k].o) > circles[k].r + EPS) {\n          ch = 0;\n          break;\n        }\n        CP p1(0, 0), p2(0, 0);\n        intersectionCL(circles[k], st, go, p1, p2);\n        if(norm(p2 - points[i]) < norm(p1 - points[i]))\n          swap(p1, p2);\n        nowp = p2;\n      }\n      if(ch) dist[i][j] = abs(points[i] - points[j]);\n    }\n  for(int k = 0; k < psize; ++k)\n    for(int i = 0; i < psize; ++i)\n      for(int j = 0; j < psize; ++j)\n        dist[i][j] =\n            min(dist[i][j], dist[i][k] + dist[k][j]);\n  return dist[0][psize - 1];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nclass coord {\npublic:\n\tdouble x, y;\n\tcoord() {}\n\tcoord(double a, double b) {\n\t\tx = a; y = b;\n\t}\n};\n\nclass circle {\npublic:\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coord a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coord,coord> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coord,coord> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coord(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coord(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\treturn ret;\n}\n\nbool cross_lseg(coord a_start, coord a_end, coord b_start, coord b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\ndouble distance(coord a, coord b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coord,coord> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coord(v[0].x, v[0].y), coord(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coord,coord> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(pair<coord,coord>(coord(v[v.size() - 1].x, v[v.size() - 1].y), coord(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoord start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoord end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <complex>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P, i) P[(i)%P.size()]\n#define Next(P, i) P[(i+1)%P.size()]\n#define Prev(P, i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n\tbool operator<(const P a, const P b) {\n\t\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n\t}\n}\n\ndouble cross(const P a, const P b) {\n\treturn (conj(a)*b).imag();\n}\ndouble dot(const P a, const P b) {\n\treturn (conj(a)*b).real();\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > 0) return +1;\n\tif (cross(b, c) < 0) return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nstruct L : public vector<P> {\n\tL(const P a, const P b) {\n\t\tpush_back(a), push_back(b);\n\t}\n};\n\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C {\n\tP p;\t\n\tdouble r;\n\tC(const P p, double r): p(p), r(r){}\n};\n\nP projection(L a, P p) {\n\tdouble t = dot(p-a[0], a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0] + t*(a[0]-a[1]);\n}\n\nP reflection(L a, P p) {\n\treturn p + 2.0 * (projection(a, p)-p);\n}\n\nbool isCrossLL(L a, L b) {\n\treturn abs(cross(a[1]-a[0], b[1]-b[0])) > EPS \n\t\t|| abs(cross(a[1]-a[0], b[0]-a[0])) < EPS;\n}\n\nbool isCrossLS(L a, S b) {\n\treturn cross(a[1]-a[0], b[0]-a[0])\n\t\t * cross(a[1]-a[0], b[1]-a[0]) < EPS;\n}\n\nbool isCrossLP(L l, P p) {\n\treturn abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool isCrossSS(S a, S b) {\n\treturn ccw(a[0], a[1], b[0])\n\t\t * ccw(a[0], a[1], b[1]) <= 0\n\t\t &&\n\t\t   ccw(b[0], b[1], a[0])\n\t\t * ccw(b[0], b[1], a[1]) <= 0;\n}\n\nbool isCrossSP(S a, P p) {\n\treturn abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\ndouble distPP(P a, P b) {\n\treturn abs(a-b);\n}\n\ndouble distLP(L a, P p) {\n\treturn abs(p-projection(a, p));\n}\n\ndouble distLL(L a, L b) {\n\treturn isCrossLL(a, b) ? 0 : distLP(a, b[0]);\n}\n\ndouble distLS(L a, S b) {\n\treturn isCrossLS(a, b) ? 0 : min(distLP(a, b[0]), distLP(a, b[1]));\n}\n\ndouble distSP(S a, P p) {\n\tconst P r = projection(a, p);\n\treturn isCrossSP(a, r) ? abs(p-r) : min(abs(a[0]-p), abs(a[1]-p));\n}\n\ndouble distSS(S a, S b) {\n\treturn isCrossSS(a, b) ? 0 :\n\t\tmin(\n\t\t     min(distSP(a, b[0]), distSP(a, b[1])),\n\t\t\t min(distSP(b, a[0]), distSP(b, a[1]))\n\t    );\n}\n\nbool isCrossCP(C a, P p) {\n\treturn abs(a.p-p)-a.r <= EPS;\n}\n\nbool isCrossCL(C a, L l) {\n\treturn distLP(l, a.p)-a.r < EPS;\n}\n\ndouble distSP_MAX(S a, P p) {\n\treturn max(abs(a[0]-p), abs(a[1]-p));\n}\n\nbool isCrossCS(C a, S s) {\n\treturn distSP(s, a.p)-a.r<-EPS&&distSP_MAX(s, a.p)-a.r>+EPS;\n}\n\nbool isCrossCC(C a, C b) {\n\treturn abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\nP crossP_LL(L a, L b) {\n\tdouble A = cross(a[1]-a[0], b[1]-b[0]);\n\tdouble B = cross(a[1]-a[0], a[1]-b[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return b[0];\n\tif (abs(A) < EPS) assert(false);\n\treturn b[0]+B/A*(b[1]-b[0]);\n}\n\nvector<P> crossP_CL(C c, L l) {\n\tP tmp = projection(l, c.p);\n\tP e = (l[0]-l[1])/abs(l[0]-l[1]);\n\tdouble h = abs(c.p-tmp)*abs(c.p-tmp);\n\tdouble t = sqrt(c.r*c.r-h*h);\n\tvector<P> p;\n\tif (t < EPS) {\n\t\tp.push_back(tmp);\n\t\treturn p;\n\t}\n\tp.push_back(tmp+e*t);\n\tp.push_back(tmp-e*t);\n\treturn p;\n}\n\nvector<P> crossP_CC(C a, C b) {\n\tdouble dx = (b.p).X-(a.p).X;\n\tdouble dy = (b.p).Y-(a.p).Y;\n\tdouble A = dx * dx + dy * dy;\n\tdouble B = ((a.r * a.r - b.r * b.r) / A + 1) / 2;\n\tdouble D = a.r * a.r / A - B * B;\n\tD = sqrt(D);\n\tdouble x3 = (a.p).X + dx * B;\n\tdouble y3 = (a.p).Y + dy * B;\n\tdouble x4 = -dy * D;\n\tdouble y4 = dx * D;\n\tvector<P> p;\n\tp.push_back(P(x3-x4, y3-y4));\n\tp.push_back(P(x3+x4, y3+y4));\n\treturn p;\n}\n\ntypedef pair<double, int> R;\n\nint V;\n\nstruct edge {\n\tint to;\n\tdouble cost;\n};\n\nvector<edge> GG[200];\ndouble d[200];\n\nvoid dijkstra(int s) {\n\tpriority_queue<R, vector<R>, greater<R> > que;\n\tfill(d, d+V, INF);\n\td[s] = 0;\n\tque.push(R(0.0, s));\n\n\twhile (!que.empty()) {\n\t\tR p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tfor (int i = 0; i < GG[v].size(); i++) {\n\t\t\tedge e = GG[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(R(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tGG[i].clear();\n\t\t}\n\t\tvector<C> en;\n\t\tvector<P> ten;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tC k = C(P(a, b), c);\n\t\t\ten.push_back(k);\n\t\t}\n\t\tten.push_back(en[0].p);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tvector<P> p = crossP_CC(en[i-1], en[i]);\n\t\t\tten.push_back(p[0]);\n\t\t\tten.push_back(p[1]);\n\t\t}\n\t\tten.push_back(en[n-1].p);\n\t\tfor (int i = 1; i < 2*n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint t;\n\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\tt = j+1;\n\t\t\t\t} else {\n\t\t\t\t\tt = j+2;\n\t\t\t\t}\n\t\t\t\tbool hantei = true;\n\t\t\t\tfor (int k = t; k < i; k += 2) {\n\t\t\t\t\tif (!isCrossSS(S(ten[k], ten[k+1]), S(ten[i], ten[j]))) {\n\t\t\t\t\t\thantei = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hantei) {\n\t\t\t\t\tedge e = {j, distPP(ten[i], ten[j])};\n\t\t\t\t\tGG[i].push_back(e);\n\t\t\t\t\te.to = i;\n\t\t\t\t\tGG[j].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV = 2*n;\n\t\tdijkstra(0);\n\t\tprintf(\"%f\\n\", d[2*n-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a != b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint baseP;\nbool sortT(Point a, Point b){return (gt(cross(a - baseP, b - baseP), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\n\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n) && n){\n\t\tvector<Point> p(n);\n\t\tdouble r[128];\n\t\tvector<pair<double, int> > G[256];\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf %lf %lf\", &p[i].x, &p[i].y, &r[i]);\n\t\t}\n\t\t\n\t\tvector<Point> q(2 * n + 2);\n\t\tint belong[256], ctr = 0;\n\t\t\n\t\tbelong[ctr] = 0; q[ctr++] = p[0];\n\t\t\n\t\tfor (int i = 1; i < n; i++){\n\t\t\tvector<Point> cand = interPointCC(p[i - 1], r[i - 1], p[i], r[i]);\n\t\t\tbelong[ctr] = i; q[ctr++] = cand[0];\n\t\t\tbelong[ctr] = i; q[ctr++] = cand[1];\n\t\t}\n\t\t\n\t\tbelong[ctr] = n - 1; q[ctr++] = p[n - 1];\n\t\t\n\t\tfor (int i = 0; i < ctr - 1; i++){\n\t\t\tfor (int j = i + 1; j < ctr; j++){\n\t\t\t\tbool ng = false;\n\t\t\t\tfor (int k = belong[i]; k <= belong[j]; k++){\n\t\t\t\t\tif (k == 0) continue;\n\t\t\t\t\t\n\t\t\t\t\tif (!(q[j] == q[k * 2 - 1]) && !(q[j] == q[k * 2]) && isIntersectSS(q[i], q[j], q[k * 2 - 1], q[k * 2]) == false){\n\t\t\t\t\t\tng = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!ng){\n\t\t\t\t\tG[i].push_back(make_pair(abs(q[i] - q[j]), j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool done[256] = {0};\n\t\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > pq;\n\t\t\n\t\tfor (pq.push(make_pair(0, 0)); pq.size(); pq.pop()){\n\t\t\tpair<double, int> x = pq.top();\n\t\t\t\n\t\t\tif (done[x.second]) continue;\n\t\t\tdone[x.second] = true;\n\t\t\t\n\t\t\tif (x.second == ctr - 1){\n\t\t\t\tprintf(\"%.10f\\n\", x.first);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < G[x.second].size(); i++){\n\t\t\t\tpq.push(make_pair(x.first + G[x.second][i].first, G[x.second][i].second));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nint x[100];\nint y[100];\nint r[100];\ndouble g[200][200];\nP wolf[200];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d\",x+i,y+i,r+i);\n\t\t}\n\t\twolf[0]=P(x[0],y[0]);\n\t\twolf[2*a-1]=P(x[a-1],y[a-1]);\n\t\tfor(int i=0;i<a-1;i++){\n\t\t\tdouble d=sqrt((x[i+1]-x[i])*(x[i+1]-x[i])+(y[i+1]-y[i])*(y[i+1]-y[i]));\n\t\t\tdouble theta=acos((d*d+r[i]*r[i]-r[i+1]*r[i+1])/(2.0*d*r[i]));\n\t\t\tdouble T=atan2(y[i+1]-y[i],x[i+1]-x[i]);\n\t\t\twolf[i*2+1]=P((double)x[i]+cos(theta+T)*r[i],(double)y[i]+sin(theta+T)*r[i]);\n\t\t\twolf[i*2+2]=P((double)x[i]+cos(-theta+T)*r[i],(double)y[i]+sin(-theta+T)*r[i]);\n\t\t}\n\t\tfor(int i=0;i<2*a;i++)\n\t\t\tfor(int j=0;j<2*a;j++)\n\t\t\t\tg[i][j]=999999999;\n\t\tfor(int i=0;i<2*a;i++)g[i][i]=0;\n\t\tfor(int i=0;i<2*a;i++)\n\t\t\tfor(int j=i+1;j<2*a;j++){\n\t\t\t\tint left=(i+1)/2;\n\t\t\t\tint right=(j-1)/2;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int k=left;k<right;k++){\n\t\t\t\t\tif(!intersectSS(L(wolf[i],wolf[j]),L(wolf[k*2+1],wolf[k*2+2])))ok=false;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tg[j][i]=g[i][j]=sqrt(norm(wolf[i]-wolf[j]));\n\t\t\t\t}\n\t\t\t}\n\t\tfor(int k=0;k<2*a;k++)\n\t\t\tfor(int i=0;i<2*a;i++)\n\t\t\t\tfor(int j=0;j<2*a;j++)\n\t\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\tprintf(\"%f\\n\",g[0][2*a-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <complex>\n#include <iomanip>\n#include <queue>\n\nusing namespace std;\n\ntypedef long double R;\ntypedef complex<R> P;\ntypedef pair<P,P> L;\ntypedef pair<P,R> C;\ntypedef vector<P> Poly;\n\n#define x real()\n#define y imag()\n\nconst R EPS = 1e-9;\nconst int INF = 1<<29;\n\ninline bool near(const P& p,const P& q){ return abs(p-q)<EPS;}\n\nR dot(const P& p,const P& q){ return p.x*q.x+p.y*q.y;}\nR det(const P& p,const P& q){ return p.x*q.y-p.y*q.x;}\n\nenum LPposit{\n  P_CD = -2, //counter direction\n  P_CW = -1, //clock wise\n  P_OS = 0, //on segment\n  P_CCW = 1, //counter clock wise\n  P_D = 2 //direction\n};\n\ninline R ccw_b(const P& p,const P& q,const P& r){  return det(q-p,r-p);}\n\nLPposit ccw(const P& p, const P& q, const P& r){\n  R c = ccw_b(p,q,r);\n  if(c<-EPS) return P_CW;\n  if(c>EPS) return P_CCW;\n  if(dot(q-p,r-p)<-EPS) return P_CD;\n  if(dot(p-q,r-q)<-EPS) return P_D;\n  return P_OS;\n}\n\ninline R Sabs(const L& l){ return abs(l.first-l.second);}\ninline R LPdist(const L& l,const P& p){ return abs(ccw_b(l.first,l.second,p))/Sabs(l);}\n\ninline R SPdist(L l,P p){\n  R a = abs(l.first-p);\n  R b = abs(l.second-p);\n  R c = Sabs(l);\n  if(b*b+c*c>a*a && a*a+c*c>b*b) return LPdist(l,p);\n  return min(a,b);\n}\n\nbool crossS(const L& p,const L& q){\n  return\n    ccw(p.first,p.second,q.first)*ccw(p.first,p.second,q.second)<=0 &&\n    ccw(q.first,q.second,p.first)*ccw(q.first,q.second,p.second)<=0;\n}\n\nP intersect(const L& p,const L& q){\n  P vp = p.second-p.first;\n  P vq = q.second-q.first;\n  P c(det(vp,p.first), det(vq,q.first));\n  return P(det(c, P(vp.x, vq.x)), det(c, P(vp.y, vq.y))) / det(vp, vq);\n}\n\nR area(const Poly& p){\n  R ret = 0;\n  int n = p.size();\n  for(int i=0;i<n;++i) ret+=det(p[i],p[(i+1)%n]);\n  return abs(ret)/2;\n}\n\n/* ?????¨??´???????????? */\nvector<P> CLintersect(const L& l,const C& c){\n  vector<P> ret;\n  R di = LPdist(l,c.first);\n  R r = c.second;\n  if(di+EPS > r) return ret;\n  P v = l.second-l.first;\n  v/=abs(v);\n  P rv = v*P(0,1);\n  rv*=di;\n  if(LPdist(l,c.first+rv) > di+EPS) rv=-rv;\n  v*=sqrt(r*r-di*di);\n  ret.push_back(c.first+rv-v);\n  ret.push_back(c.first+rv+v);\n  return ret;\n}\n\nvector<P> CSintersect(const L& l,const C& c){\n  vector<P> u = CLintersect(l,c);\n  vector<P> ret;\n  for(int i=0;i<u.size();++i){\n    if(l.first.x <= u[i].x && u[i].x<=l.second.x &&\n       l.first.y <= u[i].y && u[i].y<=l.second.y)\n      ret.push_back(u[i]);\n  }\n  return ret;\n}\n\nvector<P> CCintersect(C c,C d){\n  vector<P> ret;\n  const R dist = abs(c.first-d.first);\n  const R cr = c.second;\n  const R dr = d.second;\n\n  if(dist > cr+dr) return ret;\n  if(dist < abs(cr-dr)) return ret;\n\n  const R s = (cr+dr+dist)/2;\n  const R area = sqrt(s*(s-cr)*(s-dr)*(s-dist));\n  const R h = 2*area/dist;\n\n  P v = d.first - c.first; v/=abs(v);\n  const P m = c.first+sqrt(cr*cr-h*h)*v;\n  const P n = v*P(0,1);\n\n  ret.push_back(m+n*h);\n  ret.push_back(m-n*h);\n  return ret;\n}\n\n/* ?????? */\nnamespace std{\n  bool operator < (const P& a,const P& b){\n    return a.x!=b.x?a.x<b.x : a.y<b.y;\n  }\n}\nPoly convexHull(vector<P> ps){\n  int n = ps.size();\n  sort(ps.begin(),ps.end());\n  Poly ret(2*n);\n  int m=0;\n  for(int i=0;i<n;++i){\n    while(m>=2 && ccw(ret[m-2],ret[m-1],ps[i])<0) --m;\n    ret[m++] = ps[i];\n  }\n  int t = m;\n  for(int i=n-2;i>=0;--i){\n    while(m>=t && ccw(ret[m-2], ret[m-1], ps[i])<0) --m;\n    ret[m++] = ps[i];\n  }\n\n  ret.resize(m-1);\n  return ret;\n}\n\nint n;\nvector<C> circ;\nvector<P> ps;\ndouble G[250][250];\n\ndouble len(L l){\n  return abs(l.first-l.second);\n}\n\nbool pass(int i,int j,const L& l){\n  for(int k=i;k<=j;++k){\n    L tmp = L(ps[2*k],ps[2*k+1]);\n    if(!crossS(l,tmp)) return false;\n  }\n  return true;\n}\n\ninline double min(double a,double b){\n  if(a>b) return b;\n  return a;\n}\n\ndouble ans[250];\nbool used[250];\nvoid dijkstra(int s){\n  int m = n*2;\n  for(int i=0;i<250;++i) ans[i]=INF,used[i]=false;\n  ans[s] = 0;\n  while(true){\n    double minw = INF;\n    int id = -1;\n    for(int i=0;i<m;++i){\n      if(minw > ans[i] && !used[i]){\n\tminw = ans[i];\n\tid = i;\n      }\n    }\n    if(id==-1) break;\n    used[id] = true;\n    for(int i=0;i<m;++i)\n      ans[i] = min(ans[i],minw + G[id][i]);\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<250;++i)\n      for(int j=0;j<250;++j)\n\tG[i][j] = INF;\n    for(int i=0;i<250;++i) G[i][i] = 0;\n    circ.clear();\n    ps.clear();\n\n    for(int i=0;i<n;++i){\n      double p,q,r;\n      cin >> p >> q >> r;\n      circ.push_back(C(P(p,q),r));\n    }\n    for(int i=0;i+1<n;++i){\n      vector<P> u = CCintersect(circ[i],circ[i+1]);\n      ps.push_back(u[0]);\n      ps.push_back(u[1]);\n    }\n    //ps[i] : circ[i],circ[i+1]???2??????\n    for(int i=0;i<n-1;++i){\n      for(int j=i+1;j<n-1;++j){\n\tif(pass(i,j,L(ps[2*i],ps[2*j])))\n\t  G[2*i][2*j] = G[2*j][2*i] = len(L(ps[2*i],ps[2*j]));\n\tif(pass(i,j,L(ps[2*i],ps[2*j+1])))\n\t  G[2*i][2*j+1] = G[2*j+1][2*i] = len(L(ps[2*i],ps[2*j+1]));\n\tif(pass(i,j,L(ps[2*i+1],ps[2*j])))\n\t  G[2*i+1][2*j] = G[2*j][2*i+1] = len(L(ps[2*i+1],ps[2*j]));\n\tif(pass(i,j,L(ps[2*i+1],ps[2*j+1])))\n\t  G[2*i+1][2*j+1] = G[2*j+1][2*i+1] = len(L(ps[2*i+1],ps[2*j+1]));\n      }\n    }\n\n    /*\n    for(int i=0;i<.2*n-3;i+=2)\n      G[i][i+1] = G[i+1][i] = abs(ps[2*i+1]-ps[2*i]);\n    */      \n    //node 2*n-2 : start node\n    //node 2*n-1 : end node\n    for(int i=0;i<n-1;++i){\n      if(pass(0,i,L(circ[0].first,ps[2*i])))\n\tG[2*n-2][2*i] = G[2*i][2*n-2] = abs(ps[2*i]-circ[0].first);\n      if(pass(0,i,L(circ[0].first,ps[2*i+1])))\n\tG[2*n-2][2*i+1] = G[2*i+1][2*n-2] = abs(ps[2*i+1]-circ[0].first);\n      if(pass(i,n-2,L(ps[2*i],circ[n-1].first)))\n\tG[2*i][2*n-1] = G[2*n-1][2*i] = abs(circ[n-1].first-ps[2*i]);\n      if(pass(i,n-2,L(ps[2*i+1],circ[n-1].first)))\n\tG[2*i+1][2*n-1] = G[2*n-1][2*i+1] = abs(circ[n-1].first-ps[2*i+1]);\n    }\n    if(pass(0,n-2,L(circ[0].first,circ[n-1].first)))\n      G[2*n-2][2*n-1] = G[2*n-1][2*n-2] = abs(circ[n-1].first-circ[0].first);\n\n    /*\n    if(n==3){\n      for(int i=0;i<2*n;++i)\n\tfor(int j=i+1;j<2*n;++j)\n\t  if(G[i][j]!=INF) cout << i << \":\" << j << \" \" << G[i][j] << endl;\n    }\n    */\n    dijkstra(2*n-2);\n    cout << setprecision(10) << ans[2*n-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 解答時間→ 101:22(途中) */\n#include <cmath>\n#include <iomanip>\n#include <iostream>\t\t//基本入出力\nusing namespace std;\n\ndouble dist2d(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main(){\n\tcout << setprecision(16);\n\twhile(1){\n\t\t//入力\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tdouble x[25],y[25],r[25];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\t\tint V = n * 2;\n\t\tdouble pos_x[50], pos_y[50];\n\t\tpos_x[0] = x[0];\n\t\tpos_y[0] = y[0];\n\t\tpos_x[V - 1] = x[n - 1];\n\t\tpos_y[V - 1] = y[n - 1];\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tdouble d = sqrt(1.0 * (x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1]));\n\t\t\tdouble a = (d * d + r[i] * r[i] - r[i + 1] * r[i + 1]) / (d * 2);\n\t\t\tdouble b = sqrt(-a * a + r[i] * r[i]);\n\t\t\tdouble va_x = a * (x[i + 1] - x[i]) / d, va_y = a * (y[i + 1] - y[i]) / d;\n\t\t\tdouble vb_x = b * (y[i] - y[i + 1]) / d, vb_y = b * (x[i + 1] - x[i]) / d;\n\t\t\tpos_x[i * 2 + 1] = va_x + vb_x + x[i];\n\t\t\tpos_y[i * 2 + 1] = va_y + vb_y + y[i];\n\t\t\tpos_x[i * 2 + 2] = va_x - vb_x + x[i];\n\t\t\tpos_y[i * 2 + 2] = va_y - vb_y + y[i];\n\t\t}\n\t\t//総当りで距離を計算\n\t\tdouble dist[50][50];\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tdist[i][j] = 1.797693e+308;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < V - 1; i++){\n\t\t\tfor(int j = i + 1; j < V; j++){\n\t\t\t\t//交差判定(準備)\n\t\t\t\tint flg = 1;\n\t\t\t\tdouble x1, y1, x2, y2, x3, y3, x4, y4;\n\t\t\t\tx1 = pos_x[i];\n\t\t\t\ty1 = pos_y[i];\n\t\t\t\tx2 = pos_x[j];\n\t\t\t\ty2 = pos_y[j];\n\t\t\t\tint pos_ls, pos_lg;\n\t\t\t\tif(i == 0)\n\t\t\t\t\tpos_ls = 1;\n\t\t\t\telse\n\t\t\t\t\tpos_ls = (i + 1) / 2 + 1;\n\t\t\t\tif(j == V - 1)\n\t\t\t\t\tpos_lg = n - 1;\n\t\t\t\telse\n\t\t\t\t\tpos_lg = (j + 1) / 2 - 1;\n\t\t\t\t//交差判定(本番)\n\t\t\t\tdouble ta, tb, tc, td;\n\t\t\t\tfor(int k = pos_ls; k <= pos_lg; k++){\n\t\t\t\t\tx3 = pos_x[k * 2 - 1];\n\t\t\t\t\ty3 = pos_y[k * 2 - 1];\n\t\t\t\t\tx4 = pos_x[k * 2];\n\t\t\t\t\ty4 = pos_y[k * 2];\n\t\t\t\t\tta = (x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\t\t\t\ttb = (x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\t\t\t\ttc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\t\t\t\ttd = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\t\t\tif((tc*td>=0.0)||(ta*tb>=0.0)){\n\t\t\t\t\t\tflg=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg == 1){\n\t\t\t\t\tdist[i][j] = dist2d(pos_x[i], pos_y[i], pos_x[j], pos_y[j]);\n\t\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ワーシャル・フロイド法\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j])\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tcout << dist[0][V - 1] << \"\\n\";\n\t}\n\tcout << flush;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\nusing namespace std;\n\nusing ld = long double;\nusing P = complex<ld>;\nusing VP = vector<P>;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nstruct L{ P a, b; };\nstruct C { P p; ld r; };\n\n// counter clockwise\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ss(L s, L t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nVP is_cc(C c1, C c2){\n  VP res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  P diff = (c2.p-c1.p)/d;\n  res.push_back(c1.p + diff * P(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n  return res;\n}\ntypedef double Weight;\nWeight INF = 1000000000;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n  g[dest].push_back((Edge){dest, src, weight});\n}\n\n// Dijkstra (Verified: AOJ2005)\nvoid dijkstra(Graph &g, Array &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    vector<C> vc(n);\n    REP(i,n) {\n      ld x,y,r;\n      cin>>x>>y>>r;\n      vc[i] = {P(x,y), r};\n    }\n    vector<VP> vvp;\n    REP(i,n-1) {\n      vvp.emplace_back(is_cc(vc[i], vc[i+1]));\n    }\n    int m=2*n;\n    Graph g(m);\n    P s = vc.front().p;\n    P t = vc.back().p;\n    REP(i,2) {\n      add_edge(g, 0, i+1, abs(s - vvp.front()[i]));\n      add_edge(g, m-1, m-3+i, abs(t - vvp.back()[i]));\n    }\n    L st = {s, t};\n    bool ok = true;\n    REP(i,n-1) {\n      L crs = {vvp[i][0], vvp[i][1]};\n      if (!isis_ss(st, crs)) {\n        ok = false;\n      }\n    }\n    if (ok) {\n      add_edge(g, 0, m-1, abs(s-t));\n    }\n    FOR(i,1,n-1) {\n      REP(j,2) {\n        int revi = n-i-2;\n        L sl = {s, vvp[i][j]};\n        L tl = {t, vvp[revi][j]};\n        bool oks = true;\n        bool okt = true;\n        REP(k, i) {\n          L crss = {vvp[k][0], vvp[k][1]};\n          L crst = {vvp[n-k-2][0], vvp[n-k-2][1]};\n          if (!isis_ss(sl, crss)) {\n            oks = false;\n          }\n          if (!isis_ss(tl, crst)) {\n            okt = false;\n          }\n        }\n        if (oks) {\n          add_edge(g, 0, 2*i+j+1, abs(s - vvp[i][j]));\n        }\n        if (okt) {\n          add_edge(g, m-1, 2*revi+j+1, abs(t - vvp[revi][j]));\n        }\n      }\n    }\n    REP(i,n-1)REP(j,i) {\n      REP(k,2)REP(l,2) {\n        L nl = {vvp[i][k], vvp[j][l]};\n        bool ok = true;\n        FOR(p,j+1,i) {\n          L crs = {vvp[p][0], vvp[p][1]};\n          if (!isis_ss(nl, crs)) {\n            ok = false;\n          }\n        }\n        if (ok) {\n          add_edge(g, j*2+l+1, i*2+k+1, abs(nl.a - nl.b));\n        }\n      }\n    }\n    Array res(m);\n    dijkstra(g, res, 0);\n    cout << fixed << setprecision(6) << res[m-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 110\n#define INF 1e9\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\nPoint operator * (const Point &a,const Point &b){ return Point(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); }\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\ndouble getDistance(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nstruct Circle{\n  Point p;\n  double r;\n  Circle(){}\n  Circle(Point p,double r) : p(p),r(r) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n    && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nvector<Point> crosspointCC(const Circle &a,const Circle &b){\n  vector<Point> res;\n  double d = abs(a.p-b.p);\n  double rc = (a.r*a.r-b.r*b.r+d*d)/(2.0*d);\n  double rs = sqrt(a.r*a.r-rc*rc);\n  Point p = (b.p-a.p)/d;\n  res.push_back(Point(a.p+p*Point(rc,-rs)));\n  res.push_back(Point(a.p+p*Point(rc,rs)));\n  return res;\n}\n\nstruct P{\n  double d;\n  int n,p;\n  P(double d,int n,int p) : d(d),n(n),p(p) {}\n  bool operator < (const P &p)const{\n    if(d != p.d){\n      return d > p.d;\n    }\n  }\n};\n\ndouble dist[MAX_N][2][MAX_N][2];\n\ndouble solve(int N,const vector<Circle> &cirs){\n  double d[MAX_N][2];\n  fill(d[0],d[0]+MAX_N*2,INF);\n  d[0][0] = 0.0;\n\n  priority_queue<P> Q;\n  Q.push(P(0,0,0));\n\n  while(!Q.empty()){\n    P p = Q.top(); Q.pop();\n    int idx = p.n,pos = p.p;\n    if(lt(d[idx][pos],p.d)){ continue; }\n    if(idx == N){ return p.d; }\n    for(int i = idx+1 ; i <= N ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n        if(dist[idx][pos][i][j] == INF){ continue; }\n        if(p.d+dist[idx][pos][i][j] < d[i][j]){\n          d[i][j] = p.d+dist[idx][pos][i][j];\n          Q.push(P(d[i][j],i,j));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(int N){\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < 2 ; j++){\n      for(int k = 0 ; k <= N ; k++){\n        for(int l = 0 ; l < 2 ; l++){\n          dist[i][j][k][l] = INF;\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(cin >> N,N){\n    vector<Point> G[MAX_N];\n    vector<Circle> cirs(N);\n    init(N);\n    for(int i = 0 ; i < N ; i++){\n      cin >> cirs[i].p >> cirs[i].r;\n      if(i == 0){\n        G[i].push_back(cirs[0].p);\n        G[i].push_back(cirs[0].p);\n      }else{\n        vector<Point> cp = crosspointCC(cirs[i-1],cirs[i]);\n        G[i].push_back(cp[0]); G[i].push_back(cp[1]);\n      }\n    }\n    G[N].push_back(cirs[N-1].p);\n    G[N].push_back(cirs[N-1].p);\n\n    for(int i = 0 ; i < N ; i++){\n      for(int j = i+1 ; j <= N ; j++){\n        Point p1[2] = {G[i][0],G[i][1]};\n        Point p2[2] = {G[j][0],G[j][1]};\n        for(int k = 0 ; k < 2 ; k++){\n          for(int l = 0 ; l < 2 ; l++){\n            Segment a = Segment(p1[k],p2[l]);\n            bool ok = true;\n            for(int m = i ; m < j ; m++){\n              Segment b = Segment(G[m][0],G[m][1]);\n              if(!isIntersectSS(a,b)){\n                ok = false;\n                break;\n              }\n            }\n            if(ok){\n              dist[i][k][j][l] = getDistance(p1[k],p2[l]);\n            }\n          }\n        }\n      }\n    }\n    printf(\"%.8f\\n\",solve(N,cirs));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <limits.h>\n#include <float.h>\n#include <queue>\n\n#define eps 10e-5\n#define INF 1e8\n#define M INT_MAX\nusing namespace std;\n\nstruct P{\n\tdouble x;\n\tdouble y;\n\n\tP(){\n\t\tx=M; y=M;\n\t}\n\n\tP(const double &s , const double &e)\n\t\t{ x=s; y=e;}\n\n\tP operator - (const P &t) const\n\t{ return P(x-t.x , y-t.y); }\n\n\tP operator + (const P &t) const\n\t{ return P(x+t.x , y+t.y); }\n\n\tP operator * (const double &d) const\n\t{ return P(x*d , y*d); }\n\n};\n\ndouble dis(P t);\n\nstruct L{\n\tP p1,p2;\n\n\tL(){}\n\n\tL(const P &s , const P &e)\n\t\t{ p1=s; p2=e;}\n\tdouble ldis(){\n\t\treturn dis(p1-p2);\n\t}\n};\n\nstruct C{\n\tP a;\n\tdouble r;\n\tC(){}\n\tC(const P &s , const double &e)\n\t\t{ a=s; r=e;}\n};\n\n//距離を求める\ndouble dis(P t){\n\treturn sqrt(t.x*t.x+t.y*t.y);\n}\n\n//単位ベクトルを求める\nP unit_vector(P t){\n\tdouble u=fabs(dis(t));\n\treturn P(t.x/u , t.y/u);\n}\n\n//外積を求める a×b\ndouble cross(P a,P b){\n\treturn (a.x*b.y-a.y*b.x);\n}\n\n//線分交差判定\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n\treturn ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < eps) &&\n\t\t   ( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < eps);\n}\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nP rotate(P t , P p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn P(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nL interpoint_cc(C a , C b){\n\tdouble di=fabs(dis(a.a-b.a));\n\tif(di > a.r+b.r || di < fabs(a.r-b.r)) return L(P(0, 0), P(0, 0));\n\tdouble t=(a.r*a.r-b.r*b.r+di*di)/(di+di);\n\tdouble rd=acos(t/a.r);\n\n\tP dv=unit_vector(b.a-a.a);\n\tP g1=rotate(dv , P(0,0) , rd);\n\tP g2=rotate(dv , P(0,0) , -rd);\n\treturn L(a.a+g1*a.r, a.a+g2*a.r);\n}\n\nclass State{\npublic:\n\tdouble sum;\n\tint t,s;\n\tP cur;\n\tState(){}\n\tState(double c, int a, int b, P p):sum(c),t(a),s(b),cur(p){}\n\tbool operator < (const State &opp)const{\n\t\treturn sum > opp.sum;\n\t}\n};\n\n\ndouble dp[101][2];\nint v[101][2];\nvector <L> Lines;\n\nbool check(L l, int s, int t){\n\tfor(;s<t;s++) if(!intersect_s(l.p1, l.p2, Lines[s].p1, Lines[s].p2))return 0;\n\treturn 1;\n}\n\nmain(){\n\tint i,j,n;\n\n\twhile(cin>>n, n){\n\t\tpriority_queue<State> S;\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor(i=0;i<=100;i++) dp[i][0] = dp[i][1] = INF;\n\t\tLines.clear();\n\t\tC Prev, Now;\n\t\tcin >> Now.a.x >> Now.a.y >> Now.r;\n\t\tP Start = Now.a;\n\t\tLines.push_back(L(Start, Start));\n\t\tfor(i=1;i<n;i++){\n\t\t\tPrev = Now;\n\t\t\tcin >> Now.a.x >> Now.a.y >> Now.r;\n\t\t\tLines.push_back(interpoint_cc(Now, Prev));\n\t\t}\n\t\tLines.push_back(L(Now.a, Now.a));\n\t\tS.push(State(0, 0, 0, Start));\n\t\twhile(!S.empty()){\n\t\t\tState t = S.top();S.pop();\n\t\t\tif(v[t.t][t.s]) continue;\n\t\t\tv[t.t][t.s] = 1;\n\t\t\tif(t.t == n) break;\n\t\t\tfor(i=t.t+1;i<=n;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\tif(v[i][j]) continue;\n\t\t\t\t\tL l = L(t.cur, (j?Lines[i].p2:Lines[i].p1));\n\t\t\t\t\tif(!check(l, t.t+1, i)) continue;\n\t\t\t\t\tif(dp[i][j] < l.ldis() + t.sum) continue;\n\t\t\t\t\tdp[i][j] = l.ldis() + t.sum;\n\t\t\t\t\tS.push(State(dp[i][j], i, j, l.p2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\", dp[n][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef complex<double> xy;\ntypedef pair<double,int> P;\ndouble eps = 1e-9;\ndouble dot_product(xy a,xy b) {return (conj(a)*b).real();}\ndouble cross_product(xy a,xy b) {return (conj(a)*b).imag();}\nbool comp(xy a,xy b){\n    return (a.real()!=b.real()? a.real()<b.real() : a.imag()<b.imag());\n}\n\nstruct circle{\n    int id;\n    xy c;\n    double r;\n};\n\nvector<xy> cc_intertsection_points(circle o1,circle o2){\n    double d1 = abs(o2.c-o1.c);\n    double x = (d1*d1+o1.r*o1.r-o2.r*o2.r)/(2*d1);\n    xy v1 = (o2.c-o1.c)/d1,v2 = v1*(xy(0,1));\n    double d2 = max(sqrt(o1.r*o1.r-x*x),0.0);\n    return vector<xy> {o1.c+v1*x+v2*d2,o1.c+v1*x-v2*d2};\n}\n\nbool is_valid(xy p1,xy p2,xy q1,xy q2){\n    return cross_product(p2-p1,q1-p1)*cross_product(p2-p1,q2-p1)<=eps;\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<circle> C;\n        for(int i=0;i<N;i++){\n            double x,y,r;\n            cin >> x >> y >> r;\n            C.push_back({i,xy(x,y),r});\n        }\n        vector<vector<xy>> isp,isp2;\n        vector<xy> points(2*N);\n        vector<vector<int>> v(2*N);\n        points[0] = C[0].c;\n        int id = 1;\n        for(int i=0;i<N-1;i++){\n            isp.push_back({cc_intertsection_points(C[i],C[i+1])});\n            points[id++] = isp[i][0];\n            points[id++] = isp[i][1];\n        }\n        points[id] = C[N-1].c;\n        for(int i=0;i<N-1;i++){\n            for(auto x:isp[i]){\n                bool ok = true;\n                for(int j=0;j<i;j++){\n                    if(!is_valid(C[0].c,x,isp[j][0],isp[j][1])) ok = false;\n                }\n                if(ok) v[0].push_back(2*i+1+(x!=isp[i][0]));\n            }\n            for(auto x:isp[i]){\n                bool ok = true;\n                for(int j=i+1;j<N-1;j++){\n                    if(!is_valid(x,C[N-1].c,isp[j][0],isp[j][1])) ok = false;\n                }\n                if(ok) v[2*i+1+(x!=isp[i][0])].push_back(id);\n            }\n        }\n        bool ok = true;\n        for(int i=0;i<N-1;i++){\n            if(!is_valid(C[0].c,C[N-1].c,isp[i][0],isp[i][1])) ok = false;\n        }\n        if(ok) v[0].push_back(id);\n        for(int i=0;i<N-1;i++) for(int j=i;j<N-1;j++){\n            for(auto x:isp[i]){\n                for(auto y:isp[j]){\n                    bool ok = true;\n                    for(int k=i+1;k<j;k++){\n                        if(!is_valid(x,y,isp[k][0],isp[k][1])) ok = false;\n                    }\n                    if(ok) v[2*i+1+(x!=isp[i][0])].push_back(2*j+1+(y!=isp[j][0]));\n                }\n            }\n        }\n        vector<double> dp(2*N,1e9);\n        dp[0] = 0;\n        priority_queue<P,vector<P>,greater<P>> Q;\n        Q.push({0,0});\n        while(!Q.empty()){\n            P p = Q.top(); Q.pop();\n            if(dp[p.second]<p.first) continue;\n            for(auto x:v[p.second]){\n                double d = abs(points[p.second]-points[x]);\n                if(dp[x]>p.first+d){\n                    dp[x] = p.first+d;\n                    Q.push({dp[x],x});\n                }\n            }\n        }\n        cout << fixed << setprecision(10) << dp[id] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\nR dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    // ax+by+c=0\n    L(R a, R b, R c){\n        if(fabs(a) < eps) *this = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) *this = L(P(-c/a,0),P(-c/a,1));\n        else *this = L(P(-c/a,0), P(0,-c/b));\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p, R r) : p(p), r(r) { }\n    C(){}\n};\n\n// CCW\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return -1; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b 直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c 直線上\n    return 0; // 2点以上が重なっている\n}\n\n// 交差判定\nbool isiLL(const L &l, const L &m) {\n    return\n        abs(cross(l[1]-l[0], m[1]-m[0])) > eps || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < eps;   // same line\n}\n\nbool isiLS(const L &l, const L &s) {\n    return\n        cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < eps; // s[1] is right of l\n}\n\nbool isiLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool isiSS(const L &s, const L &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool isiSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool isiCP(const C &c, const P &p) {\n    // 境界または内部\n    return abs(c.p - p) <= c.r + eps;\n}\n\nint isiCC(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(abs(d - r1 - r2) < eps) return  1; // 接する\n    if(d > r1 + r2)       return  0; // 共通部分を持たない\n    if(d < r1 - r2)       return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)       return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\n\n// 距離\nR dLP(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dLL(const L &l, const L &m) {\n    return isiLL(l, m) ? 0 : dLP(l, m[0]);\n}\n\nR dLS(const L &l, const L &s) {\n    if (isiLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\nR dSP(const L &s, const P &p) {\n    const P r = proj(s, p);\n    if (isiSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dSS(const L &s, const L &t) {\n    if (isiSS(s, t)) return 0;\n    return min(min(dSP(s, t[0]), dSP(s, t[1])),\n               min(dSP(t, s[0]), dSP(t, s[1])));\n}\n\nR dCP(const C &c, const P &p) {\n    return max(0. , abs(c.p - p));\n}\n\n// 交点\nvector<P> iLL(const L &l, const L &m) {\n    R A = cross(l[1] - l[0], m[1] - m[0]);\n    R B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) throw \"PRECONDITION NOT SATISFIED!!!\";\n    return {m[0] + B / A * (m[1] - m[0])};\n}\n\nvector<P> iSS(const L& s, const L& t) {\n    if(isiSS(s,t)) return iLL(s,t);\n    else return {};\n}\n\nvector<P> iLS(const L& l, const L& s){\n    if(isiLS(l,s)) return iLL(l,s);\n    else return {};\n}\n\n// !!! not verified !!!\nvector<P> iCL(const C& c, const L& l){\n    R d = dLP(l,c.p);\n    // 接する\n    if(abs(d-c.r) < eps) return { proj(l, c.p) };\n    // 共有点を持たない\n    if(d > c.r) return {};\n    P h = proj(l, c.p);\n    P v = h - c.p;\n    P u = v * P(0,1) * sqrt(c.r*c.r - d*d) / abs(v);\n    return {h+u, h-u};\n}\n\n// !!! not verified !!!\nvector<P> iCC(const C& c1, const C& c2){\n    int i = isiCC(c1,c2);\n    // 共通部分なし || 内部\n    if(i==0 || abs(i)==3) return {};\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    // 接する\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d };\n    // 2つの交点\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = -2. * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return iCL(c1, L(A,B,C));\n}\n\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<C> cs(n);\n        rep(i,n){\n            int x,y,r;\n            cin>>x>>y>>r;\n            cs[i] = C(P(x,y),r);\n        }\n\n        int N=n*2;\n        double d[N][N];\n        rep(i,N)rep(j,N){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=inf;\n        }\n\n        for(int i=0;i<n-1;i++){\n            auto ps = iCC(cs[i],cs[i+1]);\n            P &p1=ps[0], &p2=ps[1];\n            d[i*2][i*2+1] = abs(p1-p2);\n            for(int j=i+1;j<n-1;j++){\n                auto qs = iCC(cs[j],cs[j+1]);\n                P &q1=qs[0], &q2=qs[1];\n                L s11(p1,q1), s12(p1,q2), s21(p2,q1), s22(p2,q2);\n                bool ok11 = true, ok12 = true, ok21 = true, ok22 = true;\n                for(int k=i+1;k<=j-1;k++){\n                    auto rs = iCC(cs[k],cs[k+1]);\n                    L s(rs[0],rs[1]);\n                    if(!isiSS(s,s11))ok11=false;\n                    if(!isiSS(s,s12))ok12=false;\n                    if(!isiSS(s,s21))ok21=false;\n                    if(!isiSS(s,s22))ok22=false;\n                }\n                if(ok11){\n                    d[i*2][j*2] = d[j*2][i*2] = abs(p1-q1);\n                }\n                if(ok12){\n                    d[i*2][j*2+1] = d[j*2+1][i*2] = abs(p1-q2);\n                }\n                if(ok21){\n                    d[i*2+1][j*2] = d[j*2][i*2+1] = abs(p2-q1);\n                }\n                if(ok22){\n                    d[i*2+1][j*2+1] = d[j*2+1][i*2+1] = abs(p2-q2);\n                }\n            }\n\n            L s1(ps[0],cs[0].p);\n            L s2(ps[1],cs[0].p);\n            bool oks1 = true, oks2 = true;\n            for(int j=0;j<i;j++){\n                auto t = iCC(cs[j],cs[j+1]);\n                L s(t[0],t[1]);\n                if(!isiSS(s,s1)) oks1 = false;\n                if(!isiSS(s,s2)) oks2 = false;\n            }\n            if(oks1){\n                d[N-1][i*2] = d[i*2][N-1] = abs(s1[0]-s1[1]);\n            }\n            if(oks2){\n                d[N-1][i*2+1] = d[i*2+1][N-1] = abs(s2[0]-s2[1]);\n            }\n            L t1(ps[0],cs[n-1].p);\n            L t2(ps[1],cs[n-1].p);\n            bool okt1 = true, okt2 = true;\n            for(int j=i+1;j<n-1;j++){\n                auto t = iCC(cs[j],cs[j+1]);\n                L s(t[0],t[1]);\n                if(!isiSS(s,t1)) okt1 = false;\n                if(!isiSS(s,t2)) okt2 = false;\n            }\n            if(okt1){\n                d[N-2][i*2] = d[i*2][N-2] = abs(t1[0]-t1[1]);\n            }\n            if(okt2){\n                d[N-2][i*2+1] = d[i*2+1][N-2] = abs(t2[0]-t2[1]);\n            }\n        }\n\n        rep(k,N)rep(i,N)rep(j,N)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        printf(\"%lf\\n\",d[N-1][N-2]);\n\n        string name = \"p\" + to_string(rand()) + \".png\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nstruct C{P p;D r;};\nPol ps;\nvector<int> qs;\nvector<L> ls;\nD eps=1e-9;\nD cro(P a,P b){return imag(conj(a)*b);}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(c-b)-abs(a-c))<eps) return -2;\n\treturn 2;\n}\nbool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nPol intCC(C a,C b){\n\tD d=abs(a.p-b.p);\n\tD theta=acos((a.r*a.r+d*d-b.r*b.r)/(2.0*a.r*d));\n\tPol ret;\n\tret.pb(a.p+(b.p-a.p)/d*polar(a.r,theta));\n\tret.pb(a.p+(b.p-a.p)/d*polar(a.r,-theta));\n\treturn ret;\n}\nD d[200][200],inf=1e9;\nC c[100];\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tps.clear();\n\t\tqs.clear();\n\t\tls.clear();\n\t\trep(i,N){\n\t\t\tint x,y,r;\n\t\t\tcin>>x>>y>>r;\n\t\t\tc[i]={P(x,y),r};\n\t\t}\n\t\tps.pb(c[0].p);\n\t\tqs.pb(0);\n\t\trep(i,N-1){\n\t\t\tPol h=intCC(c[i],c[i+1]);\n\t\t\trep(j,2) ps.pb(h[j]);\n\t\t\trep(j,2) qs.pb(i+1);\n\t\t\tls.pb(L(h[0],h[1]));\n\t\t}\n\t\tps.pb(c[N-1].p);\n\t\tqs.pb(N-1);\n\t\tint M=ps.size();\n\t\trep(i,M) for(int j=i+1;j<M;j++){\n\t\t\td[i][j]=d[j][i]=inf;\n\t\t\tL l=L(ps[i],ps[j]);\n\t\t\tbool can=true;\n\t\t\tfor(int k=qs[i];k<qs[j];k++){\n\t\t\t\tif(!iSS(l,ls[k])) can=0;\n\t\t\t}\n\t\t\tif(can){\n\t\t\t\td[i][j]=d[j][i]=abs(ps[i]-ps[j]);\n//\t\t\t\tprintf(\"d[%d][%d]=%.5f\\n\",i,j,d[i][j]);\n\t\t\t}\n\t\t}\n\t\trep(i,M) rep(j,M) rep(k,M) d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\tprintf(\"%.12f\\n\",d[0][M-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define x real()\n#define y imag()\n#define N 105\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair<int,int> P;\ntypedef pair<double,P> P1;\n\nvector<point> v[N];\nvector<P1> e[N][2];\npoint p[N];\nint n;\n\ndouble dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(point a,point b){\n  return a.x*b.y-a.y*b.x;\n}\n \nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 2;//\"ONLINE_BACK\"\n  if(abs(d) < abs(e)) return -2;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\nvector<point> CrossPoints_CC(point a,double ra,point b,double rb){\n  vector<point> res;\n  b-=a;\n  double d= ( norm(b) + ra*ra - rb*rb ) / ( 2.0 * abs(b)  );\n  double  c = sqrt( ra*ra - d*d );\n  point base = b/abs(b);\n  res.push_back(point(d,c) * base + a);\n  res.push_back(point(d,-c) * base + a);  \n  return res;\n}\n\nbool check(int a,int b,int c,int d){\n  point A=v[a][b],B=v[c][d];\n  for(int i=a+1;i<c;i++)\n    if(!intersection(A,B,v[i][0],v[i][1]))return false;\n  return true;\n}\n\ndouble dijkstra(){\n  priority_queue<P1,vector<P1>,greater<P1> > q;\n  double d[N][2];\n  for(int i=0;i<=n;i++)d[i][0]=d[i][1]=INF;\n  q.push(P1(0,P(0,0)));\n  d[0][0]=0;\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    double cost=t.first;\n    int node=t.second.first,idx=t.second.second;\n    if(d[node][idx]<cost)continue;\n    if(node==n)return cost;\n    for(int i=0;i<(int)e[node][idx].size();i++){\n      double ncost=cost+e[node][idx][i].first;\n      int nnode=e[node][idx][i].second.first;\n      int nidx=e[node][idx][i].second.second;\n      if(d[nnode][nidx]>ncost){\n\td[nnode][nidx]=ncost;\n\tq.push(P1(ncost,P(nnode,nidx)));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  double r[N],a,b;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=1;i<=n;i++)cin>>a>>b>>r[i],p[i]=point(a,b);\n    v[0].push_back(p[1]);\n    for(int i=1;i<n;i++)v[i]=CrossPoints_CC(p[i],r[i],p[i+1],r[i+1]);\n    v[n].push_back(p[n]);\n    for(int i=0;i<n;i++)\n      for(int j=0;j<(int)v[i].size();j++)\n\tfor(int k=i+1;k<=n;k++)\n\t  for(int l=0;l<(int)v[k].size();l++)\n\t    if(check(i,j,k,l))e[i][j].push_back(P1(abs(v[i][j]-v[k][l]),P(k,l)));\n    printf(\"%.8f\\n\",dijkstra());\n    for(int i=0;i<=n;i++){\n      v[i].clear();\n      for(int j=0;j<2;j++)e[i][j].clear();\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nnamespace Geometry{\n#define F first\n#define S second\n  typedef long double D;\n  typedef complex<long double> P;\n  typedef pair<P,D> C;\n    \n  const D EPS=1e-9;\n  const D PI=asin(1)*2;\n  const D INF=1e18;\n    \n  static bool comp(const P &p1,const P &p2){\n    if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n    return p1.real()<p2.real();\n  }\n    \n  static bool comp_y(const P &p1,const P &p2){\n    if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n    return p1.imag()<p2.imag();\n  }\n    \n  static bool eqls(const P &p1,const P &p2){return abs(p1-p2)<EPS;}\n    \n  D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n  D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n  P project(P vec,P x){return vec*(x/vec).real();}\n    \n  P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n  P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n  P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n  bool intersectSL(P p1,P p2,P vec){\n    vec/=abs(vec); p1/=vec; p2/=vec;\n    return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n  }\n    \n  bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n  bool intersectSS(P p1,P p2,P p3,P p4){\n    if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n    if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n    return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n  }\n    \n  D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n  D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n  D distSP(P p1,P p2,P x){\n    if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n    if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n    return distLP(p1,p2,x);\n  }\n    \n  D distSS(P p1,P p2,P p3,P p4){\n    if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n    return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n                distSP(p3,p4,p1),distSP(p3,p4,p2)});\n  }\n    \n  P crosspointLL(P p1,P p2,P vec){\n    if(abs(cross(p2-p1,vec))<EPS){return vec;}\n    return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n  }\n    \n  P crosspointLL(P p1,P p2,P p3,P p4){\n    return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n  }\n    \n  P crosspointSS(P p1,P p2,P p3,P p4){\n    if(distSP(p1,p2,p3)<EPS){return p3;}\n    if(distSP(p1,p2,p4)<EPS){return p4;}\n    return crosspointLL(p1,p2,p3,p4);\n  }\n    \n  bool intersectShL(P p1,P p2,P vec){\n    vec/=abs(vec);\n    return intersectSL(p1,p2,vec) &&\n      crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n  }\n    \n  bool intersectShL(P p1,P p2,P p3,P p4){\n    return intersectShL(p1-p3,p2-p3,p4-p3);\n  }\n    \n  //1::in,0::on edge,-1::out\n  int contain(const vector<P> &poly,const P &p){\n    vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n    int s=A.size();\n    vector<bool> cnt(s,false);\n    for(int i=0;i<(int)poly.size();i++){\n      int k=(i+1)%poly.size();\n      if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n      for(int j=0;j<s;j++){\n        if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n      }\n    }\n    int in=0;\n    for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n    return in>s/2?1:-1;\n  }\n    \n  vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n    vector<P> ret;\n    for(int i=0;i<(int)poly.size();i++){\n      int j=(i+1)%poly.size();\n      if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n      if(intersectSL(poly[i],poly[j],p1,p2) &&\n         distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n        ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly){\n    D ans=0;\n    for(int i=2;i<(int)poly.size();i++){\n      ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n    }\n    return abs(ans)/2;\n  }\n    \n  vector<P> convexhull(vector<P> pts){\n    vector<P> ret;\n    sort(pts.begin(),pts.end(),comp);\n    auto fnc=[&](){\n               for(auto &I:pts){\n                 if(!ret.empty() && abs(I-ret.back())<EPS){continue;}\n                 while(ret.size()>1){\n                   P A=ret.back()-ret[ret.size()-2];\n                   P B=I-ret.back();\n                   if(cross(A,B)<-EPS){ret.pop_back();}\n                   else if(abs(cross(A,B))<EPS && dot(A,B)>EPS){ret.pop_back();}\n                   else{break;}\n                 }\n                 ret.push_back(I);\n               }\n             };\n    fnc();\n    reverse(pts.begin(),pts.end());\n    fnc();\n    if(ret.size()>1 && ret[0]==ret.back()){ret.pop_back();}\n    return ret;\n  }\n    \n  //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n  int intersectCC(C c1,C c2){\n    D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n    if(d<EPS && dif<EPS){return -1;}\n    if(d-r>EPS){return 4;}\n    if(d-r>-EPS){return 3;}\n    if(d-dif>EPS){return 2;}\n    if(d-dif>-EPS){return 1;}\n    return 0;\n  }\n    \n  vector<P> crosspointLC(P p1,P p2,C c){\n    vector<P> ret;\n    P pr=project(p1,p2,c.F);\n    D d=distLP(p1,p2,c.F);\n    if(d-c.S>EPS){return ret;}\n    if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n    P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n    ret.push_back(pr-vec);\n    ret.push_back(pr+vec);\n    return ret;\n  }\n    \n  vector<P> crosspointSC(P p1,P p2,C c){\n    vector<P> ret;\n    for(auto &I:crosspointLC(p1,p2,c)){\n      if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n    }\n    return ret;\n  }\n    \n  vector<P> crosspointCC(C c1,C c2){\n    vector<P> ret;\n    P vec=c2.F-c1.F;\n    D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n    D h=sqrt(c1.S*c1.S-base*base);\n    vec/=abs(vec);\n    ret.push_back(c1.F+vec*P(base,-h));\n    ret.push_back(c1.F+vec*P(base,h));\n    return ret;\n  }\n    \n  vector<P> tangentCP(C c,P p){\n    return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n  }\n    \n  vector<pair<P,P>> tangentCC(C c1,C c2){\n    vector<pair<P,P>> ret;\n    P d=c2.F-c1.F;\n    for(D i:{-1,1}){\n      D r=c1.S+c2.S*i;\n      if(intersectCC(c1,c2)>i+1){\n        for(P s:{-1i,1i}){\n          P p=r+s*sqrt(norm(d)-norm(r));\n          ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n        }\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly,C c){\n    D ret=0;\n    for(int i=0;i<(int)poly.size();i++){\n      P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n      if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n      else{\n        vector<P> A=crosspointSC(a,b,{0,c.S});\n        if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n        else{\n          ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n          ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n          ret+=cross(A[0],A.back());\n        }\n      }\n    }\n    return abs(ret)/2;\n  }\n    \n  //反時計回り\n  D diameter(const vector<P> &poly){\n    D ret=0;\n    ll l=0,r=0,n=poly.size();\n    if(n==2){return abs(poly[0]-poly[1]);}\n    for(int i=0;i<n;i++){\n      if(comp(poly[l],poly[i])){l=i;}\n      if(comp(poly[i],poly[r])){r=i;}\n    }\n    ll sl=r,sr=l;\n    while(sl!=l || sr!=r){\n      ret=max(ret,abs(poly[r]-poly[l]));\n      if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n      else{(++r)%=n;}\n    }\n    return ret;\n  }\n    \n  D closestpair(vector<P> pt){\n    sort(pt.begin(),pt.end(),comp);\n    D ret=INF;\n    int N=pt.size();\n    for(int i=1;i<N;i<<=1){\n      for(int j=0;i+j<N;j+=i*2){\n        int m=i+j;\n        vector<P> R;\n        D l=-INF,r=INF;\n        for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n        for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n        for(int k=0;m+k<N && k<i;k++){\n          if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n        }\n        int idx=0;\n        for(int k=j;k<m;k++){\n          if(r-pt[k].real()>ret){continue;}\n          int M=R.size();\n          while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n          for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n            ret=min(ret,abs(R[s]-pt[k]));\n          }\n        }\n        auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n        inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n      }\n    }\n    return ret;\n  }\n    \n  P centerofgravity(const vector<P> &pt){\n    P ret(0,0);\n    D wt=0;\n    for(int i=2;i<(int)pt.size();i++){\n      D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n      P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n      wt+=w2;\n      ret+=p*w2;\n    }\n    return ret/wt;\n  }\n    \n  void segment_arrangement(const vector<pair<P,P>> &L,vector<pair<int,int>> &seg,vector<P> &pt){\n    int N=L.size();\n    for(int i=0;i<N;i++){\n      pt.push_back(L[i].F);\n      pt.push_back(L[i].S);\n      for(int j=i+1;j<N;j++){\n        if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n          pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n        }\n      }\n    }\n    auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n    sort(pt.begin(),pt.end(),le);\n    pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n    for(auto &I:L){\n      vector<pair<D,int>> on;\n      for(int j=0;j<(int)pt.size();j++){\n        if(distSP(I.F,I.S,pt[j])<EPS){\n          on.emplace_back(abs(pt[j]-I.F),j);\n        }\n      }\n      sort(on.begin(),on.end());\n      for(int j=1;j<(int)on.size();j++){\n        seg.emplace_back(on[j-1].S,on[j].S);\n      }\n    }\n    sort(seg.begin(),seg.end());\n    seg.erase(unique(seg.begin(),seg.end()),seg.end());\n  }\n    \n  vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n    vector<pair<int,int>> seg;\n    vector<P> pt;\n    segment_arrangement(L,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n      edge[I.F].push_back(I.S);\n      edge[I.S].push_back(I.F);\n    }\n    vector<P> ret;\n    function<void(int,int)> dfs=\n      [&](int v,int pre){\n        if(pre!=-1 && v==0){return;}\n        ret.push_back(pt[v]);\n        vector<pair<D,int>> nx;\n        for(auto &u:edge[v]){\n          D a=arg((pt[u]-pt[v])/(pre==-1 || eqls(pt[v],pt[pre])?P(1):pt[v]-pt[pre]));\n          if(abs(a+PI)<EPS){a=PI;}\n          nx.emplace_back(a,u);\n        }\n        sort(nx.begin(),nx.end());\n        dfs(nx[0].S,v);\n      };\n    dfs(0,-1);\n    return ret;\n  }\n    \n  istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n  istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n  void Input(P &p){D x,y;cin>>x>>y;p={x,y};}\n};\n\nusing namespace Geometry;\n\n\nbool solve(){\n  ll N;\n  cin>>N;\n  if(N==0){return false;}\n  vector<C> A(N);\n  cin>>A;\n  vector<P> pts(2*N);//crosspointCC(A[i-1],A[i])={pts[2*i-1],pts[2*i]}\n  for(int i=1;i<N;i++){\n    auto ret=crosspointCC(A[i-1],A[i]);\n    pts[2*i-1]=ret[0];\n    pts[2*i]=ret[1];\n  }\n  pts[0]=A[0].F;\n  pts.back()=A.back().F;\n  vector<vector<ll>> edge(2*N);\n  for(int i=1;i<N;i++){\n    edge[2*i-1].push_back(2*i);\n    edge[2*i].push_back(2*i-1);\n    for(int j=i+1;j<N;j++){\n      for(int k=0;k<2;k++){\n        for(int l=0;l<2;l++){\n          bool jd=true;\n          P s=pts[2*i-k],g=pts[2*j-l];    \n          for(int m=i+1;m<j;m++){\n            jd&=intersectSS(s,g,pts[2*m-1],pts[2*m]);\n          }\n          if(jd){\n            edge[2*i-k].push_back(2*j-l);\n            edge[2*j-l].push_back(2*i-k);\n          }\n        }\n      }\n    }\n  }\n  for(int i=1;i<N;i++){\n    for(int j=0;j<2;j++){\n      bool jd=true;\n      P s=pts[0],g=pts[2*i-j];\n      for(int k=1;k<i;k++){\n        jd&=intersectSS(s,g,pts[2*k-1],pts[2*k]);\n      }\n      if(jd){\n        edge[0].push_back(2*i-j);\n        edge[2*i-j].push_back(0);\n      }\n    }\n  }\n  for(int i=1;i<N;i++){\n    for(int j=0;j<2;j++){\n      bool jd=true;\n      P s=pts[2*i-j],g=pts.back();\n      for(int k=i+1;k<N;k++){\n        jd&=intersectSS(s,g,pts[2*k-1],pts[2*k]);\n      }\n      if(jd){\n        edge[2*N-1].push_back(2*i-j);\n        edge[2*i-j].push_back(2*N-1);\n      }\n    }\n  }\n  {\n    bool jd=true;\n    P s=pts[0],g=pts.back();\n    for(int k=1;k<N;k++){\n      jd&=intersectSS(s,g,pts[2*k-1],pts[2*k]);\n    }\n    if(jd){\n      edge[0].push_back(2*N-1);\n      edge[2*N-1].push_back(0);\n    }\n  }\n  vector<D> dp(2*N,INF);\n  dp[0]=0;\n  using state=pair<D,int>;\n  priority_queue<state,vector<state>,greater<state>> Q;\n  Q.push({0,0});\n  while(!Q.empty()){\n    state u=Q.top(); Q.pop();\n    if(abs(dp[u.S]-u.F)>EPS){continue;}\n    for(auto &v:edge[u.S]){\n      if(dp[v]>dp[u.S]+abs(pts[u.S]-pts[v])+EPS){\n        dp[v]=dp[u.S]+abs(pts[u.S]-pts[v]);\n        Q.push({dp[v],v});\n      }\n    }\n  }\n  cout<<dp.back()<<endl;\n  \n  return true;\n}\n\nint main(){\n  cout<<fixed<<setprecision(12);\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef double D;\n\nconst D EPS = 1e-8;\nconst D INF = 1e9;\n\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nstruct P {\n  D x,y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nstruct L {\n  P a,b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\n\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\n\nP operator +(P a, P b) {\n  return P(a.x + b.x, a.y + b.y);\n}\n\nP operator -(P a, P b) {\n  return P(a.x - b.x, a.y - b.y);\n}\n\nP operator *(P a, D b) {\n  return P(a.x * b, a.y * b);\n}\n\nP operator /(P a, D b) {\n  return P(a.x / b, a.y / b);\n}\n\nostream& operator <<(ostream &os, const P &p) {\n  os << \"{ x = \" << p.x << \", y = \" << p.y << \" }\";\n  return os;\n}\n\nostream& operator <<(ostream &os, const C &c) {\n  os << \"{ p = \" << c.p << \", r = \" << c.r << \" }\";\n  return os;\n}\n\n\nD inp(P a, P b) {\n  return a.x*b.x + a.y*b.y;\n}\n\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\n\nD norm(P a) {\n  return inp(a,a);\n}\n\nD abs(P a) {\n  return sqrt(norm(a));\n}\n\nP rot90(P a) {\n  return P(-a.y, a.x);\n}\n\nP vec(P from, P to) { return to - from; }\n\nint ccw(P a, P b, P c) {\n  b = vec(a, b); c = vec(a, c);\n\n  // a - b - c が折れ曲がるとき\n  if(sig(outp(b, c), 0.0) > 0) return +1; // 反時計回り\n  if(sig(outp(b, c), 0.0) < 0) return -1; // 時計回り\n\n  // a - b - c が直線上に並ぶとき\n  if(sig(inp(b, c), 0.0) < 0) return +2; // c - a - b\n  if(norm(b) < norm(c))   return -2; // a - b - c\n  return 0;                          // a - c - b\n}\n\nbool iSS(L s, L t) { // 端を含む\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 2点で接していることを確認すること\nvector<P> cCC(C a, C b) {\n  D d = abs(b.p - a.p);\n  D x = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n  D y = sqrt(a.r*a.r - x*x);\n  P v = (b.p - a.p) / d;\n  vector<P> res;\n  res.emplace_back(a.p + v*x + rot90(v)*y);\n  res.emplace_back(a.p + v*x - rot90(v)*y);\n  return res;\n}\n\nstruct Edge {\n  int to; double cost;\n  Edge() { }\n  Edge(int to_, double cost_) : to(to_), cost(cost_) { }\n};\n\nstruct State {\n  int pos; double cost;\n  State() { };\n  State(int pos_, double cost_) : pos(pos_), cost(cost_) { }\n  bool operator >(const State &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\ndouble shortest_path(const vector<vector<Edge>> &G, const int src, const int dst) {\n  double d[G.size()];\n  fill(d, d + G.size(), INF);\n  d[src] = 0.0;\n  priority_queue<State, vector<State>, greater<State>> Q;\n  Q.emplace(src, 0.0);\n  while(!Q.empty()) {\n    State s = Q.top(); Q.pop();\n    if(s.cost > d[s.pos]) continue;\n    for(const Edge &e : G[s.pos]) {\n      if(d[e.to] > d[s.pos] + e.cost) {\n        d[e.to] = d[s.pos] + e.cost;\n        Q.emplace(e.to, d[e.to]);\n      }\n    }\n  }\n  return d[dst];\n}\n\nint main() {\n  while(true) {\n    int n; cin >> n;\n    if(n == 0) break;\n    vector<C> circle(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r;\n    }\n    vector<vector<P>> cross(n-1);\n    for(int i = 0; i < n - 1; ++i) {\n      cross[i] = cCC(circle[i], circle[i+1]);\n    }\n    vector<vector<Edge>> G(2*(n-1)+2);\n    G[2*(n-1)].emplace_back(0, abs(circle[0].p - cross[0][0]));\n    G[2*(n-1)].emplace_back(1, abs(circle[0].p - cross[0][1]));\n    G[2*(n-1)-1].emplace_back(2*(n-1)+1, abs(cross[n-2][0] - circle[n-1].p));\n    G[2*(n-1)-2].emplace_back(2*(n-1)+1, abs(cross[n-2][1] - circle[n-1].p));\n    for(int i = 0; i < n - 2; ++i) {\n      G[2*i].emplace_back(2*i+2, abs(cross[i][0] - cross[i+1][0]));\n      G[2*i].emplace_back(2*i+3, abs(cross[i][0] - cross[i+1][1]));\n      G[2*i+1].emplace_back(2*i+2, abs(cross[i][1] - cross[i+1][0]));\n      G[2*i+1].emplace_back(2*i+3, abs(cross[i][1] - cross[i+1][1]));\n    }\n    {\n      bool ok = true;\n      for(int i = 0; i < n - 1; ++i) {\n        if(iSS(L(circle[0].p, circle[n-1].p), L(cross[i][0], cross[i][1])) == false) ok = false;\n      }\n      if(ok) G[2*(n-1)].emplace_back(2*(n-1)+1, abs(circle[0].p - circle[n-1].p));\n    }\n    {\n      for(int i = 0; i < n - 1; ++i) {\n        for(int j = 0; j < 2; ++j) {\n          bool ok = true;\n          for(int k = 0; k < i; ++k) {\n            if(iSS(L(circle[0].p, cross[i][j]), L(cross[k][0], cross[k][1])) == false) ok = false;\n          }\n          if(ok) {\n            G[2*(n-1)].emplace_back(2*i+j, abs(circle[0].p - cross[i][j]));\n          }\n        }\n      }\n    }\n    {\n      for(int i = 0; i < n - 1; ++i) {\n        for(int j = 0; j < 2; ++j) {\n          bool ok = true;\n          for(int k = i + 1; k < n - 1; ++k) {\n            if(iSS(L(circle[n-1].p, cross[i][j]), L(cross[k][0], cross[k][1])) == false) ok = false;\n          }\n          if(ok) {\n            G[2*i+j].emplace_back(2*(n-1)+1, abs(circle[n-1].p - cross[i][j]));\n          }\n        }\n      }\n    }\n    {\n      for(int i = 0; i < n - 1; ++i) {\n        for(int j = 0; j < 2; ++j) {\n          for(int i2 = i + 1; i2 < n - 1; ++i2) {\n            for(int j2 = 0; j2 < 2; ++j2) {\n              bool ok = true;\n              for(int k = i + 1; k < i2; ++k) {\n                if(iSS(L(cross[i][j], cross[i2][j2]), L(cross[k][0], cross[k][1])) == false) ok = false;\n              }\n              if(ok) {\n                G[2*i+j].emplace_back(2*i2+j2, abs(cross[i][j] - cross[i2][j2]));\n              }\n            }\n          }\n        }\n      }\n    }\n    cout.setf(ios::fixed);\n    cout.precision(4);\n    cout << shortest_path(G, 2*(n-1), 2*(n-1)+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e18 : 1e9+10;\n\n#include<complex>\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L :public vector<P>{\n\tL(){}\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c, double r):c(c),r(r){}\n};\n\nnamespace std{\n\tbool operator < (const P& a,const P& b){\n\t\treturn real(a)!=real(b) ? real(a) < real(b) : imag(a)<imag(b);\n\t}\n\tbool operator == (const P& a,const P& b){\n\t\treturn a.real()==b.real() && a.imag() == b.imag();\n\t}\n\t\n}\n\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a, P b){\n\treturn imag(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n\tb-=a; c-=a;\n\tif(cross(b,c) > 0)return 1;\n\tif(cross(b,c) < 0)return -1;\n\tif(dot(b,c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L &s,const L &t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nL crosspointCC(C a, C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nint n;\nvector<L>w;\nbool f(int a,P st,int b,P go){\n\tbool h=true;\n\tloop(i,a,b){\n\t\tif(!intersectSS(L(st,go),w[i]))h=false;\n\t}\n\treturn h;\n}\nsigned main(){\n\twhile(cin>>n,n){\n\t\tvector<C>in;\n\t\trep(i,n){\n\t\t\tdouble a,b,c;cin>>a>>b>>c;\n\t\t\tin.pb(C(P(a,b),c));\n\t\t}\n\t\tw=vector<L>(n-1);\n\t\trep(i,n-1)w[i]=crosspointCC(in[i],in[i+1]);\n\t\tdouble dp[110][2]={0};\n\t\trep(i,110)rep(j,2)dp[i][j]=inf;\n\t\tdp[0][0]=abs(in[0].c-w[0][0]);\n\t\tdp[0][1]=abs(in[0].c-w[0][1]);\n\t\trep(i,n-2)rep(j,2){\n\t\t\tdouble out=inf;\n\t\t\tif(f(0,in[0].c,i+1,w[i+1][j]))out=abs(in[0].c-w[i+1][j]);\n\t\t\trep(k,i+1)rep(l,2)\n\t\t\t\tif(f(k,w[k][l],i+1,w[i+1][j]))out=min(out,abs(w[k][l]-w[i+1][j])+dp[k][l]);\n\t\t\tdp[i+1][j]=out;\n\t\t}\n\t\tdouble out=inf;\n\t\tif(f(0,in[0].c,n-1,in[n-1].c))out=abs(in[0].c-in[n-1].c);\n\t\trep(i,n-1){\n\t\t\tif(f(i,w[i][0],n-1,in[n-1].c))out=min(out,abs(in[n-1].c-w[i][0])+dp[i][0]);\n\t\t\tif(f(i,w[i][1],n-1,in[n-1].c))out=min(out,abs(in[n-1].c-w[i][1])+dp[i][1]);\n\t\t}\n\t\tcout<<shosu(9)<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// AOJ0214\n// a contains b?\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-10;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.pb(q + v);\n    if (h > feps)\n        res.pb(q - v); // 2点\n    return res;\n}\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.pb(p + v);\n    if (t > feps)\n        res.pb(p - v); // 2点\n    return res;\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_LC(const Line& line, const Circle& c)\n{\n    return ip_CL(c, line);\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.pb(ip[i]);\n    return res;\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_SC(const Seg& seg, const Circle& c)\n{\n    return ip_CS(c, seg);\n}\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\n\n\nint n;\nCircle c[111];\nPoint ip[111][2];\nbool reachable(int i, int a, int j, int b)\n{\n    Seg path(ip[i][a], ip[j][b]);\n    for (int k = i + 1; k < j; ++k)\n        if (!intersect_SS(path, Seg(ip[k + 1][0], ip[k + 1][1])))\n            return false;\n    return true;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        rep(i, n)\n            cin >> c[i].p >> c[i].r;\n\n        rep(i, 2)\n        {\n            ip[0][i] = c[0].p;\n            ip[n][i] = c[n - 1].p;\n        }        \n        rep(i, n - 1)\n        {\n            vector<Point> t = ip_CC(c[i], c[i + 1]);\n            assert(t.size() == 2);\n            ip[i + 1][0] = t[0], ip[i + 1][1] = t[1];\n        }\n        \n        const double eps = 1e-9;\n        const double inf = 1e9;\n        typedef pair<double, pint> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        double dp[111][2];\n        erep(i, n) rep(j, 2)\n            dp[i][j] = inf;\n        dp[0][0] = dp[0][1] = 0;\n        q.push(P(0, pint(0, 0)));\n        double res = -1;\n        while (!q.empty())\n        {\n            P t = q.top();\n            q.pop();\n\n            int u = t.second.first, w = t.second.second;\n            double d = t.first;\n            if (d > dp[u][w] + eps)\n                continue;\n            else if (u == n)\n            {\n                res = d;\n                break;\n            }\n\n            for (int v = u + 1; v <= n; ++v) rep(s, 2)\n            {\n                double nd = d + abs(ip[v][s] - ip[u][w]);\n                if (nd + eps < dp[v][s] && reachable(u, w, v, s))\n                {\n                    dp[v][s] = nd;\n                    q.push(P(nd, pint(v, s)));\n                }\n            }\n        }\n        printf(\"%.6f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<complex>\n#include<queue>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<28) \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n \nclass Point\n{\n  public:\n  double x,y;\n \n  Point(double x = -inf,double y = -inf): x(x),y(y){}\n \n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n \n  bool operator < (const Point& p) const{ return x != p.x?x<p.x:y<p.y; }\n};\n \nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n};\n \ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n \ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n \ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n \ndouble norm(Point a) {  return a.x*a.x+a.y*a.y; }\n \nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n \ndouble toRad(double agl){ return agl*M_PI/180.0; }\n \nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n \nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n \nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n \ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n \ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n \nstruct P\n{\n  int to;\n  double cost;\n  P(int to=-inf,double cost=-inf):to(to),cost(cost){}\n};\n \nstruct Pox\n{\n  int cur;\n  double cost;\n  Pox(int cur=-inf,double cost=-inf):cur(cur),cost(cost){}\n  bool operator < (const Pox& a)const{ return cost > a.cost; }\n \n};\n \nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=-inf):p(p),r(r){}\n};\n \npair<Point, Point> circle_circle_intersect( Point C1, double r1, Point C2, double r2) {\n  complex<double> c1(C1.x,C1.y);\n  complex<double> c2(C2.x,C2.y);\n  complex<double> A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  complex<double> D = B*B-4.0*A*C;\n  complex<double> z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<Point, Point>(Point(z1.real(),z1.imag()),Point(z2.real(),z2.imag()));\n}\n \nint n;\n \nint main()\n{\n \n  while(cin >> n,n)\n    {\n      vector<Circle> cs(n);\n      vector<Segment> ss(n-1);\n      vector<Point> ps;\n      rep(i,n)cin >> cs[i].p.x >> cs[i].p.y >> cs[i].r;\n      \n      ps.push_back(cs[0].p);\n      rep(i,n-1)\n    {\n \n      pair<Point,Point> pp = circle_circle_intersect(cs[i].p,cs[i].r,cs[i+1].p,cs[i+1].r);\n      ss[i].p1 = pp.first,ss[i].p2 = pp.second; \n      ps.push_back(pp.first);\n      ps.push_back(pp.second);\n      ps.push_back(cs[i+1].p);\n    }\n \n      int N = n + (n-1)*2;\n      vector<vector<P> > G(N,vector<P>());\n \n      int pssize = ps.size();\n      rep(i,pssize)\n\t{\n\t  //cout << \"from \" << i << endl;\n\t  rep(j,pssize)\n\t    {\n\t      if(i == j)continue;\t      \n\t      bool pass = true;\n\t      for(int k=1;k<=j;k+=3)\n\t\t{\n\t\t  if(k < i)continue;\n\t\t  //cout << \"Segment( ( \"<< ps[i].x << \",\" << ps[i].y << \") , (\" << ps[j].x << \",\" << ps[j].y << \") ) and Segment( (\" << ps[k].x << \",\" << ps[k].y << \") , (\" << ps[k+1].x << \",\" << ps[k+1].y << \") )\" << endl;            \n\t\t  //cout << \"result : \" << intersectSS(Segment(ps[i],ps[j]),Segment(ps[k],ps[k+1])) << endl;\n\t\t  if(!intersectSS(Segment(ps[i],ps[j]),Segment(ps[k],ps[k+1])))\n\t\t    {\n\t\t      pass = false;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      //cout <<\"pass?\" << pass << endl;\n\t      if(!pass)continue;\n\t      //cout << \"IN!\" << endl;\n\t      G[i].push_back(P(j,abs(ps[j]-ps[i])));\n\t    }\n\t}\n      /*\n\trep(i,G.size())\n\t{\n\tcout << i << \"-th\" << endl;\n\trep(j,G[i].size())\n        {\n\tcout << \"(\" << G[i][j].to << \",\" << G[i][j].cost << \") \";\n        }\n\tcout << endl;\n\t}\n      */\n      double mincost[N];\n      rep(i,N)mincost[i] = inf;\n      mincost[0] = 0;\n      priority_queue<Pox> Q;\n      Q.push(Pox(0,0));\n      while(!Q.empty())\n\t{\n\t  Pox pox = Q.top(); Q.pop();\n\t  if(pox.cur == N-1)\n\t    {\n\t      cout << setiosflags(ios::fixed) << setprecision(10) << pox.cost << endl;\n\t      goto Fin;\n\t    }\n\t  \n\t  rep(i,G[pox.cur].size())\n\t    {\n\t      P p = G[pox.cur][i];\n\t      if(mincost[p.to] > mincost[pox.cur] + p.cost)\n\t\t{\n\t\t  mincost[p.to] = mincost[pox.cur] + p.cost;\n\t\t  Q.push(Pox(p.to,mincost[p.to]));\n\t\t}\n\t    }\n\t}\n      cout << \"EEE\" << endl; \n    Fin:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\n#define fcout(a) cout<<setprecision(a)<<fixed\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define PI 3.14159265358\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\t/*\n\t\t0,1:S\n\t\t2~3:L1\n\t\t4~5:L2\n\t\tN*2-2,N*2-1:L(N-1)\n\t\tN*2,N*2+1,G\n\t*/\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<pair<P,D>> cir(n);\n\t\tvector<P> line(n*2+2);\n\t\trep(i,n){\n\t\t\tdouble x,y,r;\n\t\t\tcin>>x>>y>>r;\n\t\t\tcir[i]=make_pair(P(x,y),r);\n\t\t}\n\t\tline[0]=line[1]=cir[0].first;\n\t\trange(i,1,n){\n\t\t\tauto p=crosspointCC(cir[i-1].first,cir[i-1].second,cir[i].first,cir[i].second);\n\t\t\tline[i*2]=p[0];\n\t\t\tline[i*2+1]=p[1];\n\t\t}\n\t\tline[n*2]=line[n*2+1]=cir[n-1].first;\n\n\t\tvector<vector<D>> dist(n*2+2,vector<double>(n*2+2,-1));\n\t\trep(i,n*2+2)range(j,i+1,n*2+2){\n\t\t    //cout<<i<<\",\"<<j<<\"=>\";\n\t\t\tbool ok=true;\n\t\t\tfor(int k=(i+2)/2;k<j/2;k++){\n\t\t\t    //cout<<\"(\"<<k*2<<\"-\"<<k*2+1<<\")\";\n\t\t\t\tok&=isecSS(line[i],line[j],line[k*2],line[k*2+1]);\n\t\t\t}\n\t\t\tif(ok)dist[i][j]=dist[j][i]=abs(line[i]-line[j]);\n\t\t\t//cout<<dist[i][j]<<endl;\n\t\t}\n\t\t//cout<<line<<endl;\n\t\t//cout<<setprecision(1)<<fixed<<dist<<endl;\n\t\tvector<D> dp(n*2+2,INF);\n\t\tdp[0]=dp[1]=0;\n\t\trange(i,2,n*2+2){\n\t\t    //int p=0;\n\t\t\trep(j,i/2*2)if(dist[i][j]!=-1){\n\t\t\t    //if(dp[i]>dp[j]+dist[i][j])p=j;\n\t\t\t\tdp[i]=min(dp[i],dp[j]+dist[i][j]);\n\t\t\t}\n\t\t\t//cout<<i<<\"=>\"<<p<<endl;\n\t\t}\n\t\tfcout(10)<<dp[n*2]<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\ntypedef Point Vector;\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n};\n\nstruct Info{\n\tInfo(int arg_node_id,double arg_sum_dist){\n\t\tnode_id = arg_node_id;\n\t\tsum_dist = arg_sum_dist;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t}\n\n\tint node_id;\n\tdouble sum_dist;\n};\n\nint N;\nCircle circle[100];\nPoint point[300];\nvector<int> G[300];\ndouble min_dist[300],dist[300][300];\n\ndouble arg(Vector p){\n\treturn atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n\treturn Point(cos(r)*a,sin(r)*a);\n}\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble calc_dist(Point a,Point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\nvector<Point> getCrossPoints(Circle c1,Circle c2){\n\n\tvector<Point> res;\n\n\tdouble d = abs(c1.center-c2.center);\n\tdouble a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n\tdouble t = arg(c2.center-c1.center);\n\n\tres.push_back(Point(c1.center+polar(c1.r,t+a)));\n\tres.push_back(Point(c1.center+polar(c1.r,t-a)));\n\n\treturn res;\n}\n\nvoid solve(){\n\n\tfor(int i = 0; i < 300; i++)G[i].clear();\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&circle[i].center.x,&circle[i].center.y,&circle[i].r);\n\t}\n\n\tint start = 0,goal,index = 1;\n\n\tpoint[0] = circle[0].center;\n\tvector<Point> res;\n\n\tfor(int i = 0; i <= N-2; i++){\n\t\tres = getCrossPoints(circle[i],circle[i+1]);\n\t\tpoint[index++] = res[0];\n\t\tpoint[index++] = res[1];\n\t\tpoint[index++] = circle[i+1].center;\n\t}\n\n\tgoal = index-1;\n\n\tfor(int i = 0; i < index; i++){\n\t\tfor(int k = 0; k < index; k++){\n\t\t\tdist[i][k] = calc_dist(point[i],point[k]);\n\t\t}\n\t}\n\n\tbool FLG;\n\tint first_up,last_up;\n\n\tfor(int i = 0; i < index-1; i++){\n\t\tswitch(i%3){\n\t\tcase 0:\n\t\t\tfirst_up = i+1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfirst_up = i+3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfirst_up = i+2;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int k = i+1; k < index; k++){\n\t\t\tFLG = true;\n\n\t\t\tswitch(k%3){\n\t\t\tcase 0:\n\t\t\t\tlast_up = k-2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlast_up = k-3;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlast_up = k-4;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int p = first_up; p <= last_up; p += 3){\n\t\t\t\tif(func(point[i].x,point[i].y,point[k].x,point[k].y,point[p].x,point[p].y)\n\t\t\t\t\t\t*func(point[i].x,point[i].y,point[k].x,point[k].y,point[p+1].x,point[p+1].y) > 0 ||\n\t\t\t\t\t\tfunc(point[p].x,point[p].y,point[p+1].x,point[p+1].y,point[i].x,point[i].y)\n\t\t\t\t\t\t* func(point[p].x,point[p].y,point[p+1].x,point[p+1].y,point[k].x,point[k].y) > 0){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG){\n\t\t\t\tG[i].push_back(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < index; i++)min_dist[i] = 999999999999.0;\n\n\tpriority_queue<Info> Q;\n\tmin_dist[start] = 0;\n\tQ.push(Info(start,0));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tprintf(\"%.10lf\\n\",Q.top().sum_dist);\n\t\t\treturn;\n\t\t}else if(Q.top().sum_dist > min_dist[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tif(min_dist[G[Q.top().node_id][i]] > Q.top().sum_dist+dist[Q.top().node_id][G[Q.top().node_id][i]]){\n\t\t\t\t\tmin_dist[G[Q.top().node_id][i]] = Q.top().sum_dist+dist[Q.top().node_id][G[Q.top().node_id][i]];\n\t\t\t\t\tQ.push(Info(G[Q.top().node_id][i],min_dist[G[Q.top().node_id][i]]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <complex>\n#include <cmath>\n#include <iomanip>\n\nusing Comp = std::complex<double>;\n\nconstexpr double Eps = 0.00000001;\nconstexpr double Inf = 1000000000;\n\ndouble cross(const Comp& a, const Comp& b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool intersects(const Comp& s1, const Comp& l1, const Comp& s2, const Comp& l2) {\n\tdouble c12 = cross(l1, l2);\n\tif (std::abs(c12) <= Eps)\n\t\treturn false;\n\n\tconst Comp l = s2 - s1;\n\tdouble t1 = cross(l, l1) / c12;\n\tdouble t2 = cross(l, l2) / c12;\n\treturn 0 <= t1 && t1 <= 1 && 0 <= t2 && t2 <= 1;\n}\n\nstruct Circle {\n\tComp center;\n\tdouble r;\n\n\tstd::array<Comp, 2> intersections(const Circle& c) const {\n\t\tdouble l = std::abs(c.center - center);\n\t\tComp n_l = (c.center - center) / l;\n\n\t\tdouble theta = std::acos((r*r + l * l - c.r * c.r)/(2*r*l));\n\n\t\treturn {\n\t\t\tcenter + std::polar(r, theta) * n_l,\n\t\t\tcenter + std::polar(r, -theta)* n_l\n\t\t};\n\t}\n};\n\nint main() {\n\tint n;\n\twhile (std::cin >> n, n != 0) {\n\t\tstd::vector<Circle> circles(n);\n\t\tfor (auto&& c : circles) {\n\t\t\tint x, y;\n\t\t\tstd::cin >> x >> y >> c.r;\n\t\t\tc.center = Comp(x, y);\n\t\t}\n\n\t\tstd::vector<std::array<Comp, 2>> iss(n - 1);\n\t\tfor (int i = 0; i < n - 1; ++i)\n\t\t\tiss[i] = circles[i].intersections(circles[i + 1]);\n\n\t\tauto isValid = [&](const Comp& a, const Comp b, int s, int t) {\n\t\t\tfor (int i = s; i < t; ++i)\n\t\t\t\tif (!intersects(a, b - a, iss[i][0], iss[i][1] - iss[i][0]))\n\t\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t};\n\n\t\tstd::vector<std::array<double, 2>> dp(n - 1, {Inf, Inf});\n\n\t\tdp[0][0] = std::abs(iss[0][0] - circles[0].center);\n\t\tdp[0][1] = std::abs(iss[0][1] - circles[0].center);\n\t\tfor (int i = 2; i / 2 < n - 1; ++i) {\n\t\t\tif (isValid(circles[0].center, iss[i / 2][i % 2], 0, i / 2))\n\t\t\t\tdp[i / 2][i % 2] = std::abs(iss[i / 2][i % 2] - circles[0].center);\n\n\t\t\tfor (int j = 0; j / 2 < i / 2; ++j) {\n\t\t\t\tif (isValid(iss[j / 2][j % 2], iss[i / 2][i % 2], j / 2 + 1, i / 2)) {\n\t\t\t\t\tdp[i / 2][i % 2] = std::min(\n\t\t\t\t\t\tdp[i / 2][i % 2],\n\t\t\t\t\t\tdp[j / 2][j % 2] + std::abs(iss[i / 2][i % 2] - iss[j / 2][j % 2])\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = Inf;\n\t\tif (isValid(circles[0].center, circles[n - 1].center, 0, n - 1))\n\t\t\tans = std::abs(circles[n - 1].center - circles[0].center);\n\n\t\tfor (int i = 0; i / 2 < n - 1; ++i) {\n\t\t\tif (isValid(iss[i / 2][i % 2], circles[n - 1].center, i / 2 + 1, n - 1)) {\n\t\t\t\tans = std::min(\n\t\t\t\t\tans,\n\t\t\t\t\tdp[i / 2][i % 2] + std::abs(circles[n - 1].center - iss[i / 2][i % 2])\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << std::fixed << std::setprecision(6) << ans << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <map>\n#include <queue>\n#include <assert.h>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n \nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(pair<P, P> pp) {\n    push_back(pp.first); push_back(pp.second);\n  }\n};\n \nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n \nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> circle_circle_intersect(C c1, C c2) {\n  if(c1.p.real() > c2.p.real()) swap(c1, c2);\n  const double d = abs(c2.p - c1.p);\n  const double alpha  = acos((c2.p.real() - c1.p.real()) / d) * ((c1.p.imag() > c2.p.imag()) ? -1.0 : 1.0);\n  const double beta   = acos((c1.r * c1.r - c2.r * c2.r + d * d) / 2.0 / d / c1.r);\n  return make_pair(c1.p + polar(c1.r, alpha - beta), c1.p + polar(c1.r, alpha + beta));\n}\n\nstruct Edge {\n  int to;\n  double cost;\n};\n \nvector<Edge> G[300];\n \nmap<P, int> mp;\nint nidx;\nvoid init_node_map(P ps, P pt, int N) {\n  mp.clear();\n  mp[ps] = 0;\n  mp[pt] = (N-1)*2+1;\n  nidx = 1;\n}\n \nint get_node(P p) {\n  if(mp.find(p) == mp.end()) {\n    mp[p] = nidx++;\n  }\n  return mp[p];\n}\n \n#define MAX (300)\ndouble dist[MAX];\n \ntypedef pair<double, int> Pdi;\n  \ndouble dijkstra(int S, int T) {\n   \n  priority_queue<Pdi, vector<Pdi>, greater<Pdi> > PQ;\n  fill(dist, dist+MAX, INF);\n  dist[S] = 0;\n  PQ.push(Pdi(0., S));\n    \n  while(!PQ.empty()) {\n    Pdi pdi = PQ.top(); PQ.pop();\n    const int u = pdi.second;\n    for(int i=0; i<(int)G[u].size(); i++) {\n      const Edge& e = G[u][i];\n      if(dist[e.to] > dist[u]+e.cost) {\n    dist[e.to] = dist[u]+e.cost;\n    PQ.push(Pdi(dist[e.to], e.to));\n      }\n    }\n  }\n    \n  return dist[T];\n}\n \n#define IINF2 (INT_MAX/2)\n \nint main() {\n   \n  int N;\n  while(cin >> N && N) {\n \n    for(int i=0; i<300; i++) G[i].clear();\n \n    vector<C> cs;\n    for(int i=0; i<N; i++) {\n      double x, y, r; cin >> x >> y >> r;\n      cs.push_back(C(P(x, y), r));\n    }\n     \n    vector<pair<P, P> > ips(N+1);\n    ips[0].first = cs[0].p; // ips[0].second = P(-IINF2, -IINF2);\n    for(int i=0; i<N-1; i++) {\n      ips[i+1] = circle_circle_intersect(cs[i], cs[i+1]);\n    }\n    ips[N].first = cs[N-1].p; // ips.back().second = P(+IINF2, +IINF2);\n     \n    init_node_map(ips[0].first, ips[N].first, N);\n     \n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N+1; j++) {\n     \n    const int dij = j-i;\n     \n    for(int k=0; k<2; k++) {\n       \n      if(i == 0 && k == 1) continue;\n       \n      const P pti = k == 0 ? ips[i].first : ips[i].second;\n      const int a = get_node(pti);\n       \n      for(int l=0; l<2; l++) {\n         \n        if(j == N && l == 1) continue;\n         \n        const P ptj = l == 0 ? ips[j].first : ips[j].second;\n        const int b = get_node(ptj);\n         \n        bool ok = true;\n        const L sa(pti, ptj);\n        // ?¶???????????????°?????????????£?\n        for(int didx=1; didx<dij; didx++) {\n          const L sb(ips[i+didx]);\n          ok = ok && intersectSS(sa, sb);\n        }\n \n         \n        if(ok) {\n          const double len = abs(pti-ptj);\n          G[a].push_back((Edge){b, len});\n          G[b].push_back((Edge){a, len});\n        }\n         \n         \n      }\n    }\n      }\n    }\n     \n    printf(\"%.6f\\n\", dijkstra(get_node(cs[0].p), get_node(cs[N-1].p)));\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// AOJ0214\n// a contains b?\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.pb(q + v);\n    if (h > feps)\n        res.pb(q - v); // 2点\n    return res;\n}\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.pb(p + v);\n    if (t > feps)\n        res.pb(p - v); // 2点\n    return res;\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_LC(const Line& line, const Circle& c)\n{\n    return ip_CL(c, line);\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.pb(ip[i]);\n    return res;\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_SC(const Seg& seg, const Circle& c)\n{\n    return ip_CS(c, seg);\n}\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\n\n\nint n;\nCircle c[111];\nPoint ip[111][2];\nbool reachable(int i, int a, int j, int b)\n{\n    Seg path(ip[i][a], ip[j][b]);\n    for (int k = i; k < j; ++k)\n        if (!intersect_SS(path, Seg(ip[k + 1][0], ip[k + 1][1])))\n            return false;\n    return true;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        rep(i, n)\n            cin >> c[i].p >> c[i].r;\n\n        rep(i, 2)\n        {\n            ip[0][i] = c[0].p;\n            ip[n][i] = c[n - 1].p;\n        }        \n        rep(i, n - 1)\n        {\n            vector<Point> t = ip_CC(c[i], c[i + 1]);\n            assert(t.size() == 2);\n            ip[i + 1][0] = t[0], ip[i + 1][1] = t[1];\n        }\n        \n        const double eps = 1e-9;\n        const double inf = 1e9;\n        typedef pair<double, pint> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        double dp[111][2];\n        erep(i, n) rep(j, 2)\n            dp[i][j] = inf;\n        dp[0][0] = dp[0][1] = 0;\n        q.push(P(0, pint(0, 0)));\n        double res = -1;\n        while (!q.empty())\n        {\n            P t = q.top();\n            q.pop();\n\n            int u = t.second.first, w = t.second.second;\n            double d = t.first;\n            if (d > dp[u][w] + eps)\n                continue;\n            else if (u == n)\n            {\n                res = d;\n                break;\n            }\n\n            for (int v = u + 1; v <= n; ++v) rep(s, 2)\n            {\n                double nd = d + abs(ip[v][s] - ip[u][w]);\n                if (nd + eps < dp[v][s] && reachable(u, w, v, s))\n                {\n                    dp[v][s] = nd;\n                    q.push(P(nd, pint(v, s)));\n                }\n            }\n        }\n        printf(\"%.6f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n\n#define sqr(x) ((x)*(x))\n\nusing namespace std;\nconst int MAXN = 233;\nconst double EPS = 1e-8;\nconst double INF = 1e16;\nstruct Point{\n\tdouble x, y;\n};\n\nPoint g[MAXN][2], c[MAXN];\ndouble d[MAXN][2], r[MAXN];\n\ndouble operator * (const Point &u, const Point &v){\n\treturn u.x * v.y - u.y * v.x;\n}\n\nPoint operator - (Point u, const Point &v){\n\tu.x -= v.x;\n\tu.y -= v.y;\n\treturn u;\n}\n\ndouble Dist(const Point &u, const Point &v){\n\treturn sqrt(sqr(u.x - v.x) + sqr(u.y - v.y));\n}\n\nbool Pass(int l, int r, const Point &u, const Point &v){\n\tfor (int i = l; i<=r; ++i)\n\t\tif (((v - u) * (g[i][0] - u)) * ((v - u) * (g[i][1] - u)) > -EPS) return 0;\n\treturn 1;\n}\n\nint main(){\n\twhile (1){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif (n==0) break;\n\t\tfor (int i = 1; i<=n; ++i){\n\t\t\tint a, b, l;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &l);\n\t\t\tc[i].x = a * 1.0;\n\t\t\tc[i].y = b * 1.0;\n\t\t\tr[i] = l * 1.0;\n\t\t}\n\t\tfor (int i = 1; i<n; ++i){\n\t\t\tdouble u, v, w;\n\t\t\tu = sqr(r[i]) - sqr(r[i + 1]) + sqr(c[i + 1].y) - sqr(c[i].y) + sqr(c[i + 1].x) - sqr(c[i].x);\n\t\t\tv = 2.0 * (c[i + 1].x - c[i].x);\n\t\t\tw = 2.0 * (c[i + 1].y - c[i].y);\n//printf(\"%d %.7f %.7f %.7f\\n\", i, u, v, w);\n\t\t\tif (w>-EPS && w<EPS){\n\t\t\t\tdouble x = u / v;\n\t\t\t\tdouble y = sqrt(sqr(r[i]) - sqr(x - c[i].x));\n\t\t\t\tg[i][0].x = x;\n\t\t\t\tg[i][0].y = y + c[i].y;\n\t\t\t\tg[i][1].x = x;\n\t\t\t\tg[i][1].y = - y + c[i].y;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble k = (-v) / w;\n\t\t\t\tdouble b = u / w;\n//printf(\"%.7f %.7f\\n\", k, b);\n\t\t\t\tdouble A, B, C;\n\t\t\t\tA = (k * k + 1.0);\n\t\t\t\tB = (2.0 * k * b - 2.0 * c[i].x - 2.0 * c[i].y * k);\n\t\t\t\tC = sqr(c[i].x) + b * b - 2.0 * c[i].y * b + sqr(c[i].y) - sqr(r[i]);\n//printf(\"%.7f %.7f %.7f\\n\", A, B, C);\n\t\t\t\tdouble Delta = sqrt(B * B - 4.0 * A * C);\n\t\t\t\tg[i][0].x = ((-B) + Delta) / (2.0 * A);\n\t\t\t\tg[i][0].y = k * g[i][0].x + b;\n\t\t\t\tg[i][1].x = ((-B) - Delta) / (2.0 * A);\n\t\t\t\tg[i][1].y = k * g[i][1].x + b;\n\t\t\t}\n//printf(\"%.7f %.7f %.7f %.7f\\n\", g[i][0].x, g[i][0].y, g[i][1].x, g[i][1].y);\n\t\t}\n\n\t\tfor (int i = 1; i<n; ++i)\n\t\t\tfor (int l = 0; l<2; ++l){\n\t\t\t\td[i][l] = INF;\n\t\t\t\tif (Pass(1, i - 1, c[1], g[i][l])){\n//printf(\"Pass C1 C%d %.7f %.7f\\n\", i, g[i][l].x, g[i][l].y);\n\t\t\t\t\td[i][l] = fmin(d[i][l], Dist(c[1], g[i][l]));\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j<i; ++j)\n\t\t\t\t\tfor (int k = 0; k<2; ++k)\n\t\t\t\t\t\tif (Pass(j + 1, i - 1, g[j][k], g[i][l])){\n//printf(\"Pass C%d C%d %.7f %.7f %.7f %.7f\\n\", j, i, g[j][k].x, g[j][k].y, g[i][l].x, g[i][l].y);\n\t\t\t\t\t\t\td[i][l] = fmin(d[i][l], d[j][k] + Dist(g[j][k], g[i][l]));\n\t\t\t\t\t\t}\n\t\t\t}\n\t\tdouble ans = INF;\n\t\tif (Pass(1, n - 1, c[1], c[n])) ans = Dist(c[1], c[n]);\n\t\tfor (int i = 1; i<n; ++i)\n\t\t\tfor (int l = 0; l<2; ++l)\n\t\t\t\tif (Pass(i + 1, n - 1, g[i][l], c[n]))\n\t\t\t\t\tans = fmin(ans, d[i][l] + Dist(g[i][l], c[n]));\n\t\tprintf(\"%.7f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-6;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-5;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tC c[100];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i].p.real() >> c[i].p.imag() >> c[i].r;\n\t\t}\n\t\tvector<P> cp[200];\n\t\tfor(int i = 0 ; i < n - 1 ; i++)\n\t\t\tcp[i] = C_cp(c[i],c[i+1]);\n\t\n\t\tvector<P> p;\n\t\tp.push_back(c[0].p);\n\t\tp.push_back(c[n-1].p);\n\t\tfor(int i = 0 ; i < n-1 ; i++){\n\t\t\tvector<P> a = C_cp(c[i],c[i+1]);\n\t\t\tfor(int k = 0 ; k < a.size() ; k++)\n\t\t\t\tp.push_back(a[k]);\n\t\t}\n\t\tpriority_queue< pair<double,int> , vector< pair<double,int> > , greater< pair<double,int> > > Q;\n\t\tvector<int> done(p.size(),0);\n\t\tQ.push(make_pair(0,0));\n\t\twhile(Q.size()){\n\t\t\tint qi = Q.top().second;\n\t\t\tdouble qcost = Q.top().first;\n\t\t\tQ.pop();\n\t\t\tif( done[qi]++) continue;\n\t\t\t//cout << qi << p[qi] << \" \" << -qcost << endl;\n\t\t\tif( qi == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",qcost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < p.size() ; i++){\n\t\t\t\tif( !done[i] ){\n\t\t\t\t\tint minIdx = 1e9;\n\t\t\t\t\tint maxIdx = -1e9;\n\t\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\t\tif( distanceSP(L(p[i],p[qi]),c[k].p) < c[k].r + EPS ){\n\t\t\t\t\t\t\tminIdx = min(minIdx,k);\n\t\t\t\t\t\t\tmaxIdx = max(maxIdx,k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint flag = true;\n\t\t\t\t\tfor(int k = minIdx ; k < maxIdx ; k++){\n\t\t\t\t\t\tvector<P> a = cp[k];\n\t\t\t\t\t\tif( !intersectSS(L(p[i],p[qi]),L(a[0],a[1])) || distanceSP(L(a[0],a[1]), crosspoint(L(p[i],p[qi]),L(a[0],a[1]) ) ) > EPS || distanceSP(L(p[i],p[qi]), crosspoint(L(p[i],p[qi]),L(a[0],a[1]) ) ) > EPS ){\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( flag ) {\n\t\t\t\t\t\tQ.push(make_pair(qcost+abs(p[i]-p[qi]),i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\n#include<queue>\n#include<complex>\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\n#define int long long\nD dot(P a, P b) {\n\treturn (conj(a) * b).X;\n}\nD cross(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > EPS)return 1;\n\tif (cross(b, c) < -EPS)return -1;\n\tif (dot(b, c) < -EPS)return 2;\n\tif (norm(b) < norm(c))return -2;\n\treturn 0;\n}\n\nbool issecSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n\t\tccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nVP crosspointCC(P a, D ar, P b, D br) {\n\tVP ps;\n\tP ab = b - a;\n\tD d = abs(ab);\n\tD crL = (norm(ab) + ar*ar - br*br) / (2 * d);\n\tif (EQ(d, 0) || ar < abs(crL)) return ps;\n\n\tP abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n\tP cp = a + crL / d * ab;\n\tps.push_back(cp + abN);\n\tif (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n\treturn ps;\n}\nint N;\nsigned main() {\n\twhile (true) {\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvector<int> x(N);\n\t\tvector<int> y(N);\n\t\tvector<int> r(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\t\tvector<VP> vp(N + 1);\n\t\tvp[0] = VP(1, P(x[0], y[0]));\n\t\tfor (int i = 1; i <= N - 1; i++) {\n\t\t\tvp[i] = crosspointCC(P(x[i - 1], y[i - 1]), r[i - 1], P(x[i], y[i]), r[i]);\n\t\t\tif ((int)vp[i].size() == 1)vp.push_back(vp[0]);\n\t\t\t//cerr << i << \" \" << vp[i].size() << endl;\n\t\t}\n\t\tvp[N] = VP(1, P(x[N - 1], y[N - 1]));\n\t\tvector<vector<double> > dst(N + 1, vector<double>(2, 1e9));\n\t\tdst[0][0] = 0;\n\t\tbool f = true;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tfor (int a = 0; a < vp[i].size(); a++) {\n\t\t\t\t\tfor (int b = 0; b < vp[j].size(); b++) {\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tfor (int k = j + 1; k < i; k++) {\n\t\t\t\t\t\t\tif (!issecSS(vp[j][b], vp[i][a], vp[k][0], vp[k][1])) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tdst[i][a] = min(dst[i][a], dst[j][b] + abs(vp[j][b] - vp[i][a]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(15) << dst[N][0] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// ??????????????????\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nD x[102], y[102], r[102];\nP xy[102];\n\nstruct edge{\n    int to;\n    double cost;\n    edge(int to, double cost) : to(to), cost(cost) {}\n};\n\nint main(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i=0;i<n;i++){\n            cin >> x[i] >> y[i] >> r[i];\n            xy[i] = P(x[i], y[i]);\n        }\n\n        vector<P> points;\n        points.emplace_back(x[0], y[0]);\n\n        vector<vector<edge>> G(2*n);\n\n        for(int i=1;i<=n;i++){\n            VP crosspoints;\n            if(i < n){\n                crosspoints = crosspointCC(xy[i-1], r[i-1], xy[i], r[i]);\n            }else{\n                crosspoints.push_back(xy[n-1]);\n            }\n            int n_prev = points.size();\n            for(P& p2 : crosspoints){\n                int idx = points.size();\n                points.push_back(p2);\n                for(int j=0;j<n_prev;j++){\n                    P& p1 = points[j];\n                    int k = j % 2 == 0 ? j + 1 : j + 2;\n                    bool ok = true;\n                    for(;k+1<n_prev;k++){\n                        if(!isecSS(p1, p2, points[k], points[k+1])){\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if(ok){\n                        G[j].emplace_back(idx, abs(p1 - p2));\n                    }\n                }\n            }\n        }\n        assert(points.size() == 2 * n);\n\n        int N = G.size();\n        vector<double> d(N, 10000000000000.0);\n        priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> que;\n        d[0] = 0;\n        que.push(make_pair(0.0, 0));\n        while(que.size()){\n            pair<double, int> p = que.top(); que.pop();\n            if(d[p.second] < p.first) continue;\n            if(p.second == N-1){\n                printf(\"%.4f\\n\", p.first);\n                break;\n            }\n            for(edge e: G[p.second]){\n                double nc = p.first + e.cost;\n                if(d[e.to] > nc){\n                    d[e.to] = nc;\n                    que.push(make_pair(nc, e.to));\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\n\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-9;\nconst double INF = 1e8;\n\nbool   eq(P,P); //点:点 一緒か\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nPs     crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //GがPが包容か\ndouble area2(G); //Gの面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){\n  return abs( a - b) < EPS;\n}\ndouble cross( P a, P b){\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){\n  return real( conj(a) * b);\n}\nP projection( L l, P p) {\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\n\nint ccw( P a, P b, P c){\n  b -= a, c -= a;\n  if(cross(b,c) > EPS)    return 1;  // a → b で 時計方向におれて c\n  if(cross(b,c) < -EPS)    return -1; // a → b で 反時計方向におれて c\n  if(dot(b,c) < -EPS)      return 2;  // c -- a -- b\n  if(norm(b) < norm(c) - EPS) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) {\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) {\n  return cross( l.sc - l.fr, s[0] - l.fr) *      // s[0] is left of l\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS; // s[1] is right of l\n}\nbool intersect(Ls l, P p) {\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nint intersect( C c, L l){\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection(l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\ndouble distance( L s, P p){\n  P r = projection(s, p);\n\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) {\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) {\n  return intersect(llcomb(l), llcomb(m)) ? 0 : distance(llcomb(l), m.fr);\n}\ndouble distance( Ls l, L s) {\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint conteins(G Q, P p){\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\ndouble area2(G p){\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) {\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) {\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) {\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nPs crosspoint(C c1, C c2){\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  Ps ret;\n  ret.push_back( c1.p + m * v + h * v * P(0,1));\n  ret.push_back( c1.p + m * v - h * v * P(0,1));\n  return ret;\n}\nstruct dC{\n  double cost;\n  P pos;\n  int nowi,nowj;\n  bool operator < (const dC &left) const {\n    return cost > left.cost;\n  }\n};\nL make_2_cross(C c1, C c2){\n  Ps a(crosspoint( c1, c2));\n  return L( a[0], a[1]);\n}\n\nint main(){\n  C prev, now;\n  int n;\n\n  while(cin >> n , n){\n    LLL ls;\n\n    cin >> prev.p.real() >> prev.p.imag() >> prev.r;\n    ls.push_back( L( prev.p, prev.p));\n\n    for(int i = 1 ; i < n ; i++ ){\n      cin >> now.p.real() >> now.p.imag() >> now.r;\n      ls.push_back( make_2_cross( prev, now));\n      prev = now;\n    }\n    ls.push_back( L( prev.p, prev.p)); // G\n\n    priority_queue< dC > que;\n    que.push((dC){ 0, ls[0][0], 0, 0});\n    bool used[101][2] = {{}};\n    double ret = INF;\n    while(!que.empty()){\n      dC p = que.top();\n      que.pop();\n      if(p.nowj == n){\n        ret = p.cost;\n        break;\n      }\n      if(used[p.nowj][p.nowi]++) continue;\n      for(int i = 0 ; i < 2 ; i++ ){\n        for(int j = p.nowj + 1 ; j <= n ; j++ ){\n          L l = L( p.pos, ls[j][i]);\n\n          bool flag = true;\n          for(int k = j - 1 ; k > p.nowj ; k-- ){\n            if(!intersect( l, ls[k])){\n              flag = false;\n              break;\n            }\n          }\n          if(flag) que.push( (dC){ abs( l[0] - l[1]) + p.cost, l[1], i, j});\n        }\n      }\n    }\n    cout << fixed << setprecision(7) << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\n#define EPS 1e-9\n#define INF 1e9\n\n// ?????¢, ??????, ??????\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(Point a, Point b){ return a.real() * b.imag() - a.imag() * b.real(); }\n\n\n// ccw\n//  1: c?????????ab??????????????´????????? (a?????????, b????\\\\??¨????????¨???)\n// -1: c?????????ab??????????????´?????????\n//  2: c?????????ab?????¶????????????a?????????????????????\n// -2: c?????????ab?????¶????????????b???????\\\\?????????\n//  0: c?????????ab????????????\nint ccw(Point a, Point b, Point c){\n  if(cross(b - a, c - a) > EPS) return 1;\n  if(cross(b - a, c - a) < -EPS) return -1;\n  if(dot(b - a, c - a) < -EPS) return 2;\n  if(dis(a, b) + EPS < dis(c, a)) return -2;\n  return 0;\n}\nint ccw(Line a, Point b){ return ccw(a.first, a.second, b); }\n\n// ??????????????????(??????2???????????¶??´????????????)\nLine CircleCross(Point a, double ra, Point b, double rb){\n  double d = dis(a, b);\n  double rc = (d * d + ra * ra - rb * rb) / (2 * d);\n  double rs = sqrt(ra * ra - rc * rc);\n  Point diff = (b - a) / d;\n  return make_pair(a + diff * Point(rc, rs), a + diff * Point(rc, -rs));\n}\n\n\nvector<double> dijk(int s, vector<vector<pair<double, int> > > adj){\n  int n = adj.size();\n  vector<double> result(n, INF);\n  priority_queue<pair<double, int> > wait;  \n  result[s] = 0;\n  wait.push(make_pair(0, s));\n\n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int nowpoint = wait.top().second;\n    wait.pop();\n    if(result[nowpoint] < nowcost){ continue; }\n    \n    for(int i = 0; i < (int)adj[nowpoint].size(); i++){\n      double nextcost = adj[nowpoint][i].first + nowcost;\n      int nextpoint = adj[nowpoint][i].second;\n      if(result[nextpoint] > nextcost){\n        wait.push(make_pair(-nextcost, nextpoint));\n        result[nextpoint] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\n\nint main(void){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    // ??????????????¨?????????????????????\n    double x, y, r;\n    vector<pair<Point, double> > circles;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y >> r;\n      circles.push_back(make_pair(Point(x, y), r));\n    }\n\n    // ????????????(+?§??????¨??????)?????????\n    // second??????????????????????????????????????????????¨????\n    vector<pair<Point, int> > vertices;\n    vertices.push_back(make_pair(circles[0].first, 0));\n    for(int i = 0; i < n - 1; i++){\n      Line tmp = CircleCross(circles[i].first, circles[i].second, circles[i + 1].first, circles[i + 1].second);\n      vertices.push_back(make_pair(tmp.first, 1));\n      vertices.push_back(make_pair(tmp.second, -1));\n    }\n    vertices.push_back(make_pair(circles[n - 1].first, 0));\n\n    // ??????i??¨j????????????????????????\n    // ??????k(i+1???j-1)????????????????????????????????????????????°OK\n    vector<vector<pair<double, int> > > adj(vertices.size());\n    for(int i = 0; i < (int)vertices.size(); i++){\n      for(int j = i + 1; j < (int)vertices.size(); j++){\n        bool flag = true;\n        for(int k = i + 1; k < j; k++){\n          int tmp = ccw(vertices[i].first, vertices[j].first, vertices[k].first);\n          if(tmp != vertices[k].second){ flag = false; }\n        }\n        if(flag){ adj[i].push_back(make_pair(dis(vertices[i].first, vertices[j].first), j)); }\n      }\n    }\n\n    // ??????????????????????????????????????????\n    vector<double> result = dijk(0, adj);\n    printf(\"%.4f\\n\", result[result.size() - 1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <complex>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst double eps = 1e-8, inf = 1e+8;\n\ntemplate<typename T> T sqr(T x){return x*x;}\n\ndouble cross(const Point &a, const Point &b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : vector<Point> {\n    Line(const Point &a, const Point &b){\n        push_back(a); push_back(b);\n    }\n};\n\nbool interLS(const Line &l, const Line &s){\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < eps;\n}\n\nstruct Circle : Point {\n    double r;\n    Circle(const Point &a, double r):Point(a), r(r){}\n};\n\nvector<Point> xptCC(const Circle &c1, const Circle &c2){\n    vector<Point> res;\n    double d = abs(c1-c2);\n    if(d < eps)return res;\n    double rc = (sqr(d) + sqr(c1.r) - sqr(c2.r)) / (2.*d);\n    double rs = sqrt(sqr(c1.r) - sqr(rc));\n    Point diff = (c2-c1) / d;\n    res.push_back(c1 + diff * Point(rc, rs));\n    res.push_back(c1 + diff * Point(rc, -rs));\n    return res;\n}\n\nint n;\nvector<Circle> cir;\n\ndouble solve(){\n    vector<Point> ps{cir[0]};\n    rep(i, n-1){\n        vector<Point> xpt(xptCC(cir[i], cir[i+1]));\n        ps.insert(ps.end(), all(xpt));\n    }\n    ps.push_back(cir[n-1]);\n    int m = (int)ps.size();\n    vector<vector<pair<int, double> > > G(m);\n    rep(i, m)rep(j, i){\n        bool ok = true;\n        int s = j|1, t = i - (~i&1);\n        for(int k=s; k<t; k+=2){\n            if(interLS(Line(ps[i], ps[j]), Line(ps[k], ps[k+1])))continue;\n            ok = false;\n            break;\n        }\n        if(ok)G[j].emplace_back(i, abs(ps[i] - ps[j]));\n    }\n    vector<double> mem(n, inf); mem[0] = 0;\n    priority_queue<pair<double, int> > q;\n    for(q.emplace(0, 0); !q.empty();){\n        double c; int v;\n        tie(c, v) = q.top(); q.pop();\n        if(mem[v] + c < -eps)continue;\n        for(auto e: G[v]){\n            double nc = e.second - c;\n            if(mem[e.first] + eps <= nc)continue;\n            mem[e.first] = nc;\n            q.emplace(-nc, e.first);\n        }\n    }\n    return mem[n-1];\n}\n\nint main(){\n    while(cin >> n, n){\n        cir.clear();\n        rep(i, n){\n            int x, y, r;\n            cin >> x >> y >> r;\n            cir.emplace_back(Point(x, y), r);\n        }\n        cout << fixed << setprecision(6) << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\nstruct Angle {\n\tlong double sin, cos;\n\tAngle operator+(const Angle& that) const { return Angle{ sin * that.cos + cos * that.sin, cos * that.cos - sin * that.sin }; }\n\tAngle operator-(const Angle& that) const { return Angle{ sin * that.cos - cos * that.sin, cos * that.cos + sin * that.sin }; }\n\tstatic Angle from_sin(const long double sin);\n};\nAngle Angle::from_sin(const long double sin) {\n\treturn Angle{ sin, std::sqrt(1 - sin * sin) };\n}\nstruct Vector {\n\tlong double x, y;\n\tlong double cross(const Vector& that) const { return x * that.y - y * that.x; }\n\tlong double dot(const Vector& that) const { return x * that.x + y * that.y; }\n\tlong double length() const { return std::sqrt(x * x + y * y); }\n\tAngle angle() const { return Angle{ y / length(), x / length() }; }\n};\nstruct Coordinate {\n\tlong double x, y;\n\tVector operator-(const Coordinate& that) const { return Vector{ x - that.x, y - that.y }; }\n\tCoordinate operator+(const Coordinate& that) const { return Coordinate{ x + that.x, y + that.y }; }\n\tlong double distance(const Coordinate& that) const { return (*this - that).length(); }\n};\nlong double inner_area(const long double a, const long double b, const long double c) {\n\tauto s = (a + b + c) / 2;\n\treturn std::sqrt(s * (s - a) * (s - b) * (s - c));\n}\nint sign(const long double val) { return (val == 0) ? 0 : (std::signbit(val)) ? -1 : 1; }\nstruct Edge {\n\tCoordinate from, to;\n\tbool is_cross(const Edge& that) const {\n\t\tconstexpr long double eps = 0.0000000001;\n\t\treturn sign((to - from).cross(that.to - from)) * sign((to - from).cross(that.from - from)) <= 0 && sign((that.to - that.from).cross(to - that.from)) * sign((that.to - that.from).cross(from - that.from)) <= 0;\n\t}\n\tlong double length() const {\n\t\treturn (from - to).length();\n\t}\n\tCoordinate operator[](const int index) const {\n\t\treturn (index == 0) ? from : to;\n\t}\n};\nstruct Circle {\n\tCoordinate center;\n\tlong double radius;\n\tEdge cut(const Circle& that) const {\n\t\tauto mid = that.center - center;\n\t\tauto catheti = inner_area(radius, that.radius, mid.length()) * 2 / mid.length();\n\t\tauto diff_angle = Angle::from_sin(catheti / radius);\n\t\tauto mid_angle = mid.angle();\n\t\tauto a = mid_angle + diff_angle;\n\t\tauto b = mid_angle - diff_angle;\n\t\treturn Edge{ Coordinate{a.cos * radius, a.sin * radius} + center, Coordinate{b.cos * radius, b.sin * radius} + center };\n\t}\n};\nlong double min_length(const std::vector<Edge>& edges, const std::pair<int, int> &start, const Coordinate& goal, std::vector<std::vector<long double>>& memo) {\n\tif (memo[start.first][start.second] >= 0) return memo[start.first][start.second];\n\telse {\n\t\tmemo[start.first][start.second] = LDBL_MAX;\n\t\tauto current = edges[start.first][start.second];\n\t\tauto to_goal = Edge{ current, goal };\n\t\tauto is_cross = true;\n\t\tfor (auto i = start.first + 1; i < edges.size() && is_cross; ++i) {\n\t\t\tif (!edges[i].is_cross(to_goal)) {\n\t\t\t\tis_cross = false;\n\t\t\t}\n\t\t}\n\t\tif (is_cross) return memo[start.first][start.second] = to_goal.length();\n\t\tfor (auto next = start.first + 1; next < edges.size(); ++next) {\n\t\t\tfor (auto i = 0; i < 2; ++i) {\n\t\t\t\tauto to_next = Edge{ current, edges[next][i] };\n\t\t\t\tis_cross = true;\n\t\t\t\tfor (auto mid = start.first + 1; mid < next; ++mid) {\n\t\t\t\t\tif (!edges[mid].is_cross(to_next)) {\n\t\t\t\t\t\tis_cross = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (is_cross) {\n\t\t\t\t\tmemo[start.first][start.second] = std::min(memo[start.first][start.second], min_length(edges, std::make_pair(next, i), goal, memo) + to_next.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn memo[start.first][start.second];\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) return 0;\n\t\tstd::vector<Circle> circles(n); for (auto& c : circles) std::cin >> c.center.x >> c.center.y >> c.radius;\n\t\tstd::vector<Edge> edges; edges.push_back(Edge{ circles.front().center, circles.front().center });\n\t\tfor (auto i = 1; i < n; ++i) {\n\t\t\tedges.push_back(circles[i].cut(circles[i - 1]));\n\t\t}\n\t\tstd::vector<std::vector<long double>> memo(n, std::vector<long double>(2, -1));\n\t\tstd::cout << std::setprecision(16) << std::fixed << min_length(edges, std::make_pair(0, 0), circles.back().center, memo) << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n    //return a.Y < b.Y;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) return CCW; // ccw\n  if (cross(b, c) < -EPS) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  if (s[0] > s[1]) swap(s[0], s[1]);\n  for (Point p : res) {\n    if (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nGeometory ContainsPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\nint n;\nCircle cs[114514];\ndouble mind[400][400];\nvector<Point> ps;\n\ntypedef pair<Point, int> Event;\nvector<Event> es;\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    ps.clear();\n    for (int i=0; i<n; i++) {\n      int x, y;\n      double r;\n      scanf(\"%d%d%lf\", &x, &y, &r);\n      cs[i] = Circle{Point(x, y), r};\n      ps.push_back(cs[i].c);\n    }\n  \n    for (int i=1; i<n; i++) {\n      vector<Point> cros = CrossPointCC(cs[i-1], cs[i]);\n      assert (cros.size() == 2);\n      ps.push_back(cros[0]);\n      ps.push_back(cros[1]);\n    }\n    //sort(ps.begin(), ps.end());\n  \n    int m = ps.size();\n    for (int i=0; i<m; i++) for (int j=0; j<m; j++) mind[i][j] = INF;\n    for (int i=0; i<m; i++) {\n      mind[i][i] = 0;\n      for (int j=i+1; j<m; j++) {\n        es.clear();\n\n        //printf(\"consider %d %d %f %f %f %f\\n\", i, j, ps[i].X, ps[i].Y, ps[j].X, ps[j].Y);\n        for (int k=0; k<n; k++) {\n          vector<Point> cros = CrossPointCS(cs[k], Line{ps[i], ps[j]});\n          if (cros.empty()) continue;\n  \n          if (cros.size() == 1) {\n            double id = abs(ps[i]-cs[k].c);\n            double jd = abs(ps[j]-cs[k].c);\n            if (id < min(jd, cs[k].r)) cros.push_back(ps[i]);\n            else if (jd < min(id, cs[k].r)) cros.push_back(ps[j]);\n            else { \n              Point p = cros[0];\n              cros.push_back(p);\n            }\n          }\n  \n          if (cros[1] < cros[0]) {\n            swap(cros[0], cros[1]);\n          }\n  \n          //printf(\"%f %f %f %f\\n\", cros[0].X, cros[0].Y, cros[1].X, cros[1].Y);\n          es.push_back(Event(cros[0], -1));\n          es.push_back(Event(cros[1], +1));\n  \n          Vec v1 = ps[i]-cs[k].c;\n          Vec v2 = ps[j]-cs[k].c;\n          if (EQ(abs(v1), cs[k].r) && EQ(abs(v2), cs[k].r)) {\n            double ar = abs(arg(v2/v1)) * cs[k].r;\n            double g = min(mind[i][j], ar);\n            mind[i][j] = mind[j][i] = g;\n          }\n        }\n  \n        sort(es.begin(), es.end());\n        int cnt = 0;\n        bool fail = false;\n        Point lim = Point(-INF, -INF);\n        for (int idx=0; idx<es.size(); idx++) {\n          Event &e = es[idx];\n          Point p = e.first;\n          //printf(\"%d: %f %f\\n\", idx, p.X, p.Y);\n          if (idx == 0 && !EQ(p, min(ps[i], ps[j]))) {\n            //printf(\"%f %f %f %f\\n\", min(ps[i], ps[j]).X, min(ps[i], ps[j]).Y, p.X, p.Y);\n            \n            fail = true;\n            break;\n          }\n\n          cnt += e.second;\n          lim = max(lim, p);\n          if (cnt > 0 || (cnt == 0 && idx < es.size()-1)) {\n            fail = true;\n            break;\n          }\n          //printf(\"%d %d cnt: %d st: %d\\n\", i, j, cnt, fail);\n        }\n        //printf(\"%f %f\\n\", lim.X, lim.Y);\n        if (!es.empty() && !EQ(lim, max(ps[i], ps[j]))) fail = true;\n  \n        if (!fail) {\n          mind[i][j] = mind[j][i] = abs(ps[i]-ps[j]);\n          //printf(\"connect %d %d %f\\n\", i, j, mind[i][j]);\n        }\n      }\n    }\n  \n    for (int k=0; k<m; k++) {\n      for (int i=0; i<m; i++) {\n        for (int j=0; j<m; j++) {\n          mind[i][j] = min(mind[i][j], mind[i][k]+mind[k][j]);\n          //printf(\"mind %d %d %f\\n\", i, j, mind[i][j]);\n        }\n      }\n    }\n  \n    //printf(\"ans: %.10f\\n\", mind[0][n-1]);\n    printf(\"%.10f\\n\", mind[0][n-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\nR dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    // ax+by+c=0\n    L(R a, R b, R c){\n        if(fabs(a) < eps) *this = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) *this = L(P(-c/a,0),P(-c/a,1));\n        else *this = L(P(-c/a,0), P(0,-c/b));\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p, R r) : p(p), r(r) { }\n    C(){}\n};\n\n// CCW\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return -1; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b 直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c 直線上\n    return 0; // 2点以上が重なっている\n}\n\n// 交差判定\nbool isiLL(const L &l, const L &m) {\n    return\n        abs(cross(l[1]-l[0], m[1]-m[0])) > eps || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < eps;   // same line\n}\n\nbool isiLS(const L &l, const L &s) {\n    return\n        cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < eps; // s[1] is right of l\n}\n\nbool isiLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool isiSS(const L &s, const L &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool isiSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool isiCP(const C &c, const P &p) {\n    // 境界または内部\n    return abs(c.p - p) <= c.r + eps;\n}\n\nint isiCC(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(abs(d - r1 - r2) < eps) return  1; // 接する\n    if(d > r1 + r2)       return  0; // 共通部分を持たない\n    if(d < r1 - r2)       return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)       return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\n\n// 距離\nR dLP(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dLL(const L &l, const L &m) {\n    return isiLL(l, m) ? 0 : dLP(l, m[0]);\n}\n\nR dLS(const L &l, const L &s) {\n    if (isiLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\nR dSP(const L &s, const P &p) {\n    const P r = proj(s, p);\n    if (isiSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dSS(const L &s, const L &t) {\n    if (isiSS(s, t)) return 0;\n    return min(min(dSP(s, t[0]), dSP(s, t[1])),\n               min(dSP(t, s[0]), dSP(t, s[1])));\n}\n\nR dCP(const C &c, const P &p) {\n    return max(0. , abs(c.p - p));\n}\n\n// 交点\nvector<P> iLL(const L &l, const L &m) {\n    R A = cross(l[1] - l[0], m[1] - m[0]);\n    R B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) throw \"PRECONDITION NOT SATISFIED!!!\";\n    return {m[0] + B / A * (m[1] - m[0])};\n}\n\nvector<P> iSS(const L& s, const L& t) {\n    if(isiSS(s,t)) return iLL(s,t);\n    else return {};\n}\n\nvector<P> iLS(const L& l, const L& s){\n    if(isiLS(l,s)) return iLL(l,s);\n    else return {};\n}\n\n// !!! not verified !!!\nvector<P> iCL(const C& c, const L& l){\n    R d = dLP(l,c.p);\n    // 接する\n    if(abs(d-c.r) < eps) return { proj(l, c.p) };\n    // 共有点を持たない\n    if(d > c.r) return {};\n    P h = proj(l, c.p);\n    P v = h - c.p;\n    P u = v * P(0,1) * sqrt(c.r*c.r - d*d) / abs(v);\n    return {h+u, h-u};\n}\n\n// !!! not verified !!!\nvector<P> iCC(const C& c1, const C& c2){\n    int i = isiCC(c1,c2);\n    // 共通部分なし || 内部\n    if(i==0 || abs(i)==3) return {};\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    // 接する\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d };\n    // 2つの交点\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = -2. * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return iCL(c1, L(A,B,C));\n}\n\nint main(){\n    int n;\n    int cnt = 1;\n    while(cin>>n && n){\n        vector<C> cs(n);\n        rep(i,n){\n            int x,y,r;\n            cin>>x>>y>>r;\n            cs[i] = C(P(x,y),r);\n        }\n        vector<L> ls(n-1);\n        rep(i,n-1){\n            auto l = iCC(cs[i],cs[i+1]);\n            ls[i] = L(l[0],l[1]);\n        }\n\n        int N=n*2;\n        double d[N][N];\n        rep(i,N)rep(j,N){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=inf;\n        }\n\n        L st(cs[0].p,cs[n-1].p);\n        bool okst = true;\n        for(int i=0;i<n-1;i++){\n            auto &ps = ls[i];\n            P &p1=ps[0], &p2=ps[1];\n            d[i*2][i*2+1] = abs(p1-p2);\n            if(!isiSS(st,{p1,p2})) okst=false;\n            for(int j=i+1;j<n-1;j++){\n                auto &qs = ls[j];\n                P &q1=qs[0], &q2=qs[1];\n                L s11(p1,q1), s12(p1,q2), s21(p2,q1), s22(p2,q2);\n                bool ok11 = true, ok12 = true, ok21 = true, ok22 = true;\n                for(int k=i+1;k<=j-1;k++){\n                    auto &rs = ls[k];\n                    L s(rs[0],rs[1]);\n                    if(!isiSS(s,s11))ok11=false;\n                    if(!isiSS(s,s12))ok12=false;\n                    if(!isiSS(s,s21))ok21=false;\n                    if(!isiSS(s,s22))ok22=false;\n                }\n                if(ok11)d[i*2][j*2] = d[j*2][i*2] = abs(p1-q1);\n                if(ok12)d[i*2][j*2+1] = d[j*2+1][i*2] = abs(p1-q2);\n                if(ok21)d[i*2+1][j*2] = d[j*2][i*2+1] = abs(p2-q1);\n                if(ok22)d[i*2+1][j*2+1] = d[j*2+1][i*2+1] = abs(p2-q2);\n            }\n            L s1(ps[0],cs[0].p);\n            L s2(ps[1],cs[0].p);\n            bool oks1 = true, oks2 = true;\n            for(int j=0;j<i;j++){\n                auto &t = ls[j];\n                L s(t[0],t[1]);\n                if(!isiSS(s,s1)) oks1 = false;\n                if(!isiSS(s,s2)) oks2 = false;\n            }\n            if(oks1)d[N-1][i*2] = d[i*2][N-1] = abs(s1[0]-s1[1]);\n            if(oks2)d[N-1][i*2+1] = d[i*2+1][N-1] = abs(s2[0]-s2[1]);\n            L t1(ps[0],cs[n-1].p);\n            L t2(ps[1],cs[n-1].p);\n            bool okt1 = true, okt2 = true;\n            for(int j=i+1;j<n-1;j++){\n                auto t = ls[j];\n                L s(t[0],t[1]);\n                if(!isiSS(s,t1)) okt1 = false;\n                if(!isiSS(s,t2)) okt2 = false;\n            }\n            if(okt1)d[N-2][i*2] = d[i*2][N-2] = abs(t1[0]-t1[1]);\n            if(okt2)d[N-2][i*2+1] = d[i*2+1][N-2] = abs(t2[0]-t2[1]);\n        }\n        if(okst)d[N-1][N-2] = d[N-2][N-1] = abs(st[0]-st[1]);\n        rep(k,N)rep(i,N)rep(j,N)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        printf(\"%.4lf\\n\",d[N-1][N-2]);\n\n        string name = \"pCase\" + to_string(cnt++) + \".png\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y) :x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    Point operator/(double k){return Point(x/k,y/k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    \n    bool operator < (const Point &p) const{\n        return x!=p.x?x<p.x:y<p.y;\n        //grid-point only\n        //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n    }\n    \n    bool operator == (const Point &p) const{\n        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n    }\n};\n\nstruct EndPoint{\n    Point p;\n    int seg,st;\n    EndPoint(){}\n    EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n    bool operator<(const EndPoint &ep)const{\n        if(p.y==ep.p.y) return st<ep.st;\n        return p.y<ep.p.y;\n    }\n};\n\nistream &operator >> (istream &is,Point &p){\n    is>>p.x>>p.y;\n    return is;\n}\n\nostream &operator << (ostream &os,Point p){\n    os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n    return os;\n}\n\nbool sort_x(Point a,Point b){\n    return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n    return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n    for(int i=0;i<(int)p.size();i++) is>>p[i];\n    return is;\n}\n\nstruct Segment{\n    Point p1,p2;\n    Segment(){}\n    Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n    is>>s.p1>>s.p2;\n    return is;\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n    is>>c.c>>c.r;\n    return is;\n}\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n    return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1-p0;\n    Vector b = p2-p0;\n    if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n    if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n    if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n    return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n    int n=p.size();\n    for(int i=0;i<n;i++)\n        if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n    return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n    if(c1.r<c2.r) swap(c1,c2);\n    double d=abs(c1.c-c2.c);\n    double r=c1.r+c2.r;\n    if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n    if(d>r) return ICC_SEPERATE;\n    if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n    if(d+c2.r<c1.r) return ICC_CONTAIN;\n    return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n    return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n    if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n    double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n    if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n    if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n    Point h=project(s,c.c);\n    if(dot(s.p1-h,s.p2-h)<0) return 2;\n    return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n    if(intersectSS(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n    for(int k=0;k<2;k++){\n        if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n        if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n        swap(s1,s2);\n    }\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n    double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n    double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n    if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n    return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n    Polygon ps;\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    if(equals(getDistanceLP(l,c.c),c.r)){\n        ps.emplace_back(pr);\n        return ps;\n    }\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    ps.emplace_back(pr+e*base);\n    ps.emplace_back(pr-e*base);\n    return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n    Line l(s);\n    Polygon res=getCrossPointCL(c,l);\n    if(intersectCS(c,s)==2) return res;\n    if(res.size()>1u){\n        if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n        res.pop_back();\n    }\n    return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n    Polygon p(2);\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    p[0]=c1.c+polar(c1.r,t+a);\n    p[1]=c1.c+polar(c1.r,t-a);\n    return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n    Polygon u,l;\n    if(s.size()<3) return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    for(int i=2;i<(int)s.size();i++){\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    for(int i=s.size()-3;i>=0;i--){\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n    return l;\n}\n\nPolygon convex_hull(Polygon ps){\n    int n=ps.size();\n    sort(ps.begin(),ps.end(),sort_y);\n    int k=0;\n    Polygon qs(n*2);\n    for(int i=0;i<n;i++){\n        while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n        qs[k++]=ps[i];\n    }\n    for(int i=n-2,t=k;i>=0;i--){\n        while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\ndouble diameter(Polygon s){\n    Polygon p=s;\n    int n=p.size();\n    if(n==2) return abs(p[0]-p[1]);\n    int i=0,j=0;\n    for(int k=0;k<n;k++){\n        if(p[i]<p[k]) i=k;\n        if(!(p[j]<p[k])) j=k;\n    }\n    double res=0;\n    int si=i,sj=j;\n    while(i!=sj||j!=si){\n        res=max(res,abs(p[i]-p[j]));\n        if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n            i=(i+1)%n;\n        }else{\n            j=(j+1)%n;\n        }\n    }\n    return res;\n}\n\nbool isConvex(Polygon p){\n    bool f=1;\n    int n=p.size();\n    for(int i=0;i<n;i++){\n        int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n        f&=t!=CCW_CLOCKWISE;\n    }\n    return f;\n}\n\ndouble area(Polygon s){\n    double res=0;\n    for(int i=0;i<(int)s.size();i++){\n        res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n    }\n    return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n    double d=abs(c1.c-c2.c);\n    if(c1.r+c2.r<=d+EPS) return 0;\n    if(d<=abs(c1.r-c2.r)){\n        double r=min(c1.r,c2.r);\n        return PI*r*r;\n    }\n    double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n    double th=acos(rc/c1.r);\n    double ph=acos((d-rc)/c2.r);\n    return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n    Polygon q;\n    for(int i=0;i<(int)p.size();i++){\n        Point a=p[i],b=p[(i+1)%p.size()];\n        if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n        if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n            q.push_back(getCrossPointLL(Line(a,b),l));\n    }\n    return q;\n}\n\nLine bisector(Point p1,Point p2){\n    Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n    Polygon p=getCrossPointCC(c1,c2);\n    if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n    return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n    Vector res;\n    res.x=cos(theta)*v.x-sin(theta)*v.y;\n    res.y=sin(theta)*v.x+cos(theta)*v.y;\n    return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n    vector<Line> res;\n    if(isParallel(l1,l2)){\n        double d=getDistanceLP(l1,l2.p1)/2.0;\n        Vector v1=l1.p2-l1.p1;\n        v1=v1/v1.abs()*d;\n        Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n        double d1=getDistanceLP(l1,p);\n        double d2=getDistanceLP(l2,p);\n        if(abs(d1-d2)>d){\n            p=l2.p1+translate(v1,-90.0*(PI/180.0));\n        }\n        res.push_back(Line(p,p+v1));\n    }else{\n        Point p=getCrossPointLL(l1,l2);\n        Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n        v1=v1/v1.abs();\n        v2=v2/v2.abs();\n        res.push_back(Line(p,p+(v1+v2)));\n        res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n    }\n    return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n    Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n    Polygon p=getCrossPointCC(c1,c2);\n    sort(p.begin(),p.end());\n    return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n    vector<Line> ls;\n    if(c1.r<c2.r) swap(c1,c2);\n    double g=norm(c1.c-c2.c);\n    if(equals(g,0)) return ls;\n    Point u=(c2.c-c1.c)/sqrt(g);\n    Point v=orth(u);\n    for(int s=1;s>=-1;s-=2){\n        double h=(c1.r+s*c2.r)/sqrt(g);\n        if(equals(1-h*h,0)){\n            ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n        }else if(1-h*h>0){\n            Point uu=u*h,vv=v*sqrt(1-h*h);\n            ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n            ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n        }\n    }\n    \n    return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n    if(r<0){\n        r=a.size();\n        sort(a.begin(),a.end(),sort_x);\n    }\n    if(r-l<=1) return abs(a[0]-a[1]);\n    int m=(l+r)>>1;\n    double x=a[m].x;\n    double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n    inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n    \n    Polygon b;\n    for(int i=l;i<r;i++){\n        if(fabs(a[i].x-x)>=d) continue;\n        for(int j=0;j<(int)b.size();j++){\n            double dy=a[i].y-next(b.rbegin(),j)->y;\n            if(dy>=d) break;\n            d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n        }\n        b.emplace_back(a[i]);\n    }\n    return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n    int n=ss.size();\n    for(int i=0;i<n;i++){\n        ps.emplace_back(ss[i].p1);\n        ps.emplace_back(ss[i].p2);\n        for(int j=i+1;j<n;j++)\n            if(intersectSS(ss[i],ss[j]))\n                ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n    }\n    sort(ps.begin(),ps.end());\n    ps.erase(unique(ps.begin(),ps.end()),ps.end());\n    \n    vector<vector<pair<int, double> > > G(ps.size());\n    for(int i=0;i<n;i++){\n        vector<pair<double,int> > ls;\n        for(int j=0;j<(int)ps.size();j++)\n            if(getDistanceSP(ss[i],ps[j])<EPS)\n                ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n        \n        sort(ls.begin(),ls.end());\n        for(int j=0;j+1<(int)ls.size();j++){\n            int a=ls[j].second,b=ls[j+1].second;\n            G[a].emplace_back(b,abs(ps[a]-ps[b]));\n            G[b].emplace_back(a,abs(ps[a]-ps[b]));\n        }\n    }\n    return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n    const int BTM = 0;\n    const int LFT = 1;\n    const int RGH = 2;\n    const int TOP = 3;\n    \n    int n=ss.size();\n    vector<EndPoint> ep;\n    for(int i=0;i<n;i++){\n        if(ss[i].p1.y==ss[i].p2.y){\n            if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n            ep.emplace_back(ss[i].p1,i,LFT);\n            ep.emplace_back(ss[i].p2,i,RGH);\n        }else{\n            if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);\n            ep.emplace_back(ss[i].p1,i,BTM);\n            ep.emplace_back(ss[i].p2,i,TOP);\n        }\n    }\n    sort(ep.begin(),ep.end());\n    \n    set<int> bt;\n    bt.insert(INF);\n    \n    int cnt=0;\n    for(int i=0;i<n*2;i++){\n        if(ep[i].st==TOP){\n            bt.erase(ep[i].p.x);\n        }else if(ep[i].st==BTM){\n            bt.emplace(ep[i].p.x);\n        }else if(ep[i].st==LFT){\n            auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n            auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n            cnt+=distance(b,e);\n        }\n    }\n    \n    return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n    if(ps.size()<3u) return 0;\n    function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n        Vector va=c.c-a,vb=c.c-b;\n        double f=cross(va,vb),res=0;\n        if(equals(f,0.0)) return res;\n        if(max(abs(va),abs(vb))<c.r+EPS) return f;\n        Vector d(dot(va,vb),cross(va,vb));\n        if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n            return c.r*c.r*atan2(d.y,d.x);\n        auto u=getCrossPointCS(c,Segment(a,b));\n        if(u.empty()) return res;\n        if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n        u.emplace(u.begin(),a);\n        u.emplace_back(b);\n        for(int i=1;i<(int)u.size();i++)\n            res+=dfs(c,u[i-1],u[i]);\n        return res;\n    };\n    double res=0;\n    for(int i=0;i<(int)ps.size();i++)\n        res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n    return res/2;\n}\n\nvector<Polygon> P;\n\nbool is_In(Point a,Point b,ll l,ll r){\n    for(ll i=l+1;i<r;i++){\n        if(!intersectSS(a,b,P[i][0],P[i][1])){return false;}\n    }\n    return true;\n}\n\n\nint main(){\n    ll n;\n    while(cin>>n){\n        if(n==0){break;}\n        vector<Circle> C(n);\n        for(auto &i:C){cin>>i;}\n        P.resize(n+1);\n        P[0]={C[0].c,C[0].c};\n        P.back()={C.back().c,C.back().c};\n        for(int i=1;i<n;i++){\n            P[i]=getCrossPointCC(C[i-1],C[i]);\n        }\n        vector<vector<vector<double>>> dp(n+1,vector<vector<double>>(n+1,vector<double>(4,E)));\n        for(ll i=1;i<n+1;i++){\n            for(ll t=0;i+t<n+1;t++){\n                for(ll h=0;h<4;h++){\n                    ll a=h>>1;\n                    ll b=h&1;\n                    if(is_In(P[t][a],P[t+i][b],t,t+i)){dp[t][t+i][h]=abs(P[t][a]-P[t+i][b]);}\n                    else{\n                        for(ll k=t+1;k<i+t;k++){\n                            dp[t][t+i][h]=min(dp[t][t+i][h],dp[t][k][(a<<1)|0]+dp[k][i+t][(0<<1)|b]);\n                            dp[t][t+i][h]=min(dp[t][t+i][h],dp[t][k][(a<<1)|1]+dp[k][i+t][(1<<1)|b]);\n                        }\n                    }\n                }\n            }\n        }\n        cout<<fixed<<setprecision(12)<<dp[0][n][0]<<endl;\n    }\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n// double\nstruct P{\n    P(){}\n    P(double _r, double _i):r(_r), i(_i){}\n    void real(const double& v){r = v;}\n    void imag(const double& v){i = v;}\n    double r, i;\n};\n\ndouble real(const P& p){return p.r;}\ndouble imag(const P& p){return p.i;}\ndouble norm(const P& p){double r = real(p), i = imag(p); return r * r + i * i;}\ndouble dist(const P& p){return std::sqrt(norm(p));}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\ndouble cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\ndouble dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\nbool areIntersectedLines(const P& p1, const P& p2, const P& q1, const P& q2){\n    if(cross(p1-p2, q1-p2) == 0 && dot(p1-p2, q1-p2) > 0 &&\n       0 <= norm(q1-p2) && norm(q1-p2) <= norm(p1-p2)){\n        return true;\n    }\n    if(cross(p1-p2, q2-p2) == 0 && dot(p1-p2, q2-p2) > 0 &&\n       0 <= norm(q2-p2) && norm(q2-p2) <= norm(p1-p2)){\n        return true;\n    }\n    if(cross(q1-q2, p1-q2) == 0 && dot(q1-q2, p1-q2) > 0 &&\n       0 <= norm(p1-q2) && norm(p1-q2) <= norm(q1-q2)){\n        return true;\n    }\n    if(cross(q1-q2, p2-q2) == 0 && dot(q1-q2, p2-q2) > 0 &&\n       0 <= norm(p2-q2) && norm(p2-q2) <= norm(q1-q2)){\n        return true;\n    }\n\n    return (cross(p1-p2, q1-p2) * cross(p1-p2, q2-p2) < 0) &&\n        (cross(q1-q2, p1-q2) * cross(q1-q2, p2-q2) < 0);\n}\n\nint N;\nP ps[100], is[101][2];\ndouble rs[100], dp[101][2];\n\ndouble rec(int index, int which){\n    if(index == N){return 0.0;}\n    if(dp[index][which] > 0.0){return dp[index][which];}\n    \n    double res = 1e20;\n    for(int i=index+1;i<=N;i++){\n        for(int w=0;w<2;w++){\n            int j;\n            for(j=index+1;j<i;j++){\n                if(!areIntersectedLines(is[index][which], is[i][w], is[j][0], is[j][1])){\n                    break;\n                }\n            }\n\n            if(j == i){res = std::min(res, rec(i, w) + dist(is[index][which] - is[i][w]));}\n            else{break;}\n        }\n    }\n\n    return dp[index][which] = res;\n}\n\nint main(){\n    while(scanf(\"%d\", &N), N){\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<2;j++){\n                dp[i][j] = -1.0;\n            }\n        }\n    \n        for(int i=0;i<N;i++){\n            double x, y;\n            scanf(\"%lf %lf %lf\", &x, &y, rs+i);\n\n            ps[i].real(x);\n            ps[i].imag(y);\n        }\n\n        is[0][0] = ps[0];\n        is[N][0] = ps[N-1];\n        is[N][1] = ps[N-1];\n        for(int i=1;i<N;i++){\n            P u = ps[i] - ps[i-1], v{-imag(u), real(u)};\n            double d = dist(u);\n            double x = 0.5 / d * (1.*d*d + rs[i-1]*rs[i-1] - rs[i]*rs[i]),\n                y = std::sqrt(rs[i-1]*rs[i-1] - x*x);\n        \n            u = {real(u) / d * x, imag(u) / d * x};\n            v = {real(v) / d * y, imag(v) / d * y};\n        \n            P w = u + v;\n            is[i][0] = ps[i-1] + w;\n\n            w = u - v;\n            is[i][1] = ps[i-1] + w;\n        }\n\n        printf(\"%.6f\\n\", rec(0, 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n)<=(m)+EPS)\n#define GE(n,m) ((n)+EPS>=(m))\n#define EQ(n,m) (abs((n)-(m))<=EPS)\n\n#define inf 1e9\n\nD dot(P a, P b){\n  return (conj(a)*b).X;\n}\n\nD cross(P a, P b){\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b, c) > EPS) return +1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < -EPS) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isecSS(P a1, P a2, P b1, P b2){\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 && ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\nVP crosspointCC(P a, D ar, P b, D br){\n  VP ps;\n  P ab = b - a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar * ar - br * br) / (2 * d);\n  if(EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar * ar - crL * crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if(!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\nint main(){\n  while(1){\n    int N, i, j, k, l, m, f;\n    scanf(\"%d\", &N);\n    if(N == 0){\n      return 0;\n    }\n    VP cs(N);\n    vector<D> r(N);\n    for(i = 0; i < N; i++){\n      D x, y;\n      scanf(\"%lf%lf%lf\", &x, &y, &r[i]);\n      cs[i] = P(x, y);\n    }\n    VP vs(2 * N);\n    for(i = 0; i < N - 1; i++){\n      VP sub = crosspointCC(cs[i], r[i], cs[i + 1], r[i + 1]);\n      vs[2 * i] = sub[0];\n      vs[2 * i + 1] = sub[1];\n    }\n    vs[2 * N - 2] = cs[0];\n    vs[2 * N - 1] = cs[N - 1];\n    vector<vector<D>> dis(2 * N, vector<D>(2 * N, inf));\n    for(i = 0; i < N - 1; i++){\n      dis[2 * i][2 * i + 1] = abs(vs[2 * i] - vs[2 * i + 1]);\n      dis[2 * i + 1][2 * i] = abs(vs[2 * i] - vs[2 * i + 1]);\n      for(j = i + 1; j < N - 1; j++){\n        for(k = 0; k < 2; k++){\n          for(l = 0; l < 2; l++){\n            f = 1;\n            for(m = i + 1; m < j; m++){\n              if(isecSS(vs[2 * i + k], vs[2 * j + l], vs[2 * m], vs[2 * m + 1]) == false){\n                f = 0;\n              }\n            }\n            if(f == 1){\n              dis[2 * i + k][2 * j + l] = abs(vs[2 * i + k] - vs[2 * j + l]);\n            }\n          }\n        }\n      }\n    }\n    for(i = 0; i < N - 1; i++){\n      for(k = 0; k < 2; k++){\n        f = 1;\n        for(m = 0; m < i; m++){\n          if(isecSS(vs[2 * N - 2], vs[2 * i + k], vs[2 * m], vs[2 * m + 1]) == false){\n            f = 0;\n          }\n        }\n        if(f == 1){\n          dis[2 * N - 2][2 * i + k] = abs(vs[2 * N - 2] - vs[2 * i + k]);\n        }\n      }\n    }\n    for(i = 0; i < N - 1; i++){\n      for(k = 0; k < 2; k++){\n        f = 1;\n        for(m = i + 1; m < N - 1; m++){\n          if(isecSS(vs[2 * i + k], vs[2 * N - 1], vs[2 * m], vs[2 * m + 1]) == false){\n            f = 0;\n          }\n        }\n        if(f == 1){\n          dis[2 * i + k][2 * N - 1] = abs(vs[2 * i + k] - vs[2 * N - 1]);\n        }\n      }\n    }\n    f = 1;\n    for(m = 0; m < N - 1; m++){\n      if(isecSS(vs[2 * N - 2], vs[2 * N - 1], vs[2 * m], vs[2 * m + 1]) == false){\n        f = 0;\n      }\n    }\n    if(f == 1){\n      dis[2 * N - 2][2 * N - 1] = abs(vs[2 * N - 2] - vs[2 * N - 1]);\n    }\n    for(k = 0; k < 2 * N; k++){\n      for(i = 0; i < 2 * N; i++){\n        for(j = 0; j < 2 * N; j++){\n          dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n        }\n      }\n    }\n    printf(\"%.9lf\\n\", dis[2 * N - 2][2 * N - 1]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\ntypedef pair<double, int> pdi;\nconst double EPS = 1e-8;\nconst double INF = 1e10;\n\nstruct Point {\n\tdouble x, y;\n\tPoint() : x(0), y(0) { }\n\tPoint(double x, double y) : x(x), y(y) { }\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator+=(const Point &p){ x += p.x; y += p.y; return *this; }\n\tPoint &operator-=(const Point &p){ x -= p.x; y -= p.y; return *this; }\n\tPoint &operator*=(double s){ x *= s; y *= s; return *this; }\n\tPoint &operator/=(double s){ x /= s; y /= s; return *this; }\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\ninline Point operator*(double s, const Point &p){ return p * s; }\n\ninline double norm(const Point &p){ return p.x * p.x + p.y * p.y; }\ninline double abs(const Point &p){ return sqrt(norm(p)); }\ninline double arg(const Point &p){ return atan2(p.y, p.x); }\ninline Point unit(const Point &p){ return p / abs(p); }\ninline Point ortho(const Point &p){ return Point(-p.y, p.x); }\ninline double cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\ninline double dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\ninline int ccw(const Point &a, const Point &b, const Point &c){\n\tconst Point d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Line {\n\tPoint a, b;\n\tLine() : a(), b() { }\n\tLine(const Point &a, const Point &b) : a(a), b(b) { }\n\tbool operator==(const Line &l) const { return a == l.a && b == l.b; }\n\tbool operator!=(const Line &l) const { return a != l.a || b != l.b; }\n\tbool operator<(const Line &l) const {\n\t\treturn (a == l.a) ? (b < l.b) : (a < l.a);\n\t}\n};\n\nstruct Segment : public Line {\n\tSegment() : Line() { }\n\tSegment(const Point &a, const Point &b) : Line(a, b) { }\n};\n\ninline bool intersect(const Segment &a, const Segment &b){\n\tif(ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) > 0){ return false; }\n\tif(ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) > 0){ return false; }\n\treturn true;\n}\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle() : p(), r(0) { }\n\tCircle(Point p, double r) : p(p), r(r) { }\n\tbool operator==(const Circle &c) const { return p == c.p && r == c.r; }\n\tbool operator!=(const Circle &c) const { return p != c.p || r != c.r; }\n\tbool operator<(const Circle &c) const {\n\t\treturn (p == c.p) ? (r < c.r) : (p < c.p);\n\t}\n};\n\ninline double heron(double a, double b, double c){\n\tdouble s = (a + b + c) / 2.0;\n\treturn sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\ninline vector<Point> crossing_points(const Circle &a, const Circle &b){\n\tconst double l = abs(b.p - a.p);\n\tconst double d = 2.0 * heron(l, a.r, b.r) / l;\n\tconst double t = sqrt(a.r * a.r - d * d);\n\tconst Point v = t * unit(b.p - a.p);\n\tconst Point w = d * unit(ortho(v));\n\treturn vector<Point>({ a.p + v + w, a.p + v - w });\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcout << setiosflags(ios::fixed) << setprecision(10);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<Circle> circles(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tCircle &c = circles[i];\n\t\t\tcin >> c.p.x >> c.p.y >> c.r;\n\t\t}\n\t\tvector<Segment> segments(n + 1);\n\t\tsegments[0] = Segment(circles[0].p, circles[0].p);\n\t\tfor(int i = 1; i < n; ++i){\n\t\t\tconst vector<Point> points =\n\t\t\t\tcrossing_points(circles[i - 1], circles[i]);\n\t\t\tsegments[i] = Segment(points[0], points[1]);\n\t\t}\n\t\tsegments[n] = Segment(circles[n - 1].p, circles[n - 1].p);\n\t\tconst int m = (n + 1) * 2;\n\t\tvector<Point> points(m);\n\t\tfor(int i = 0; i <= n; ++i){\n\t\t\tpoints[i * 2 + 0] = segments[i].a;\n\t\t\tpoints[i * 2 + 1] = segments[i].b;\n\t\t}\n\t\tvector< vector<pdi> > conn(m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tconst int si = i / 2;\n\t\t\tfor(int j = i + 1; j < m; ++j){\n\t\t\t\tconst int sj = j / 2;\n\t\t\t\tSegment s(points[i], points[j]);\n\t\t\t\tbool accept = true;\n\t\t\t\tfor(int k = si + 1; accept && k < sj; ++k){\n\t\t\t\t\tif(!intersect(s, segments[k])){ accept = false; }\n\t\t\t\t}\n\t\t\t\tif(!accept){ continue; }\n\t\t\t\tconst double c = abs(points[i] - points[j]);\n\t\t\t\tconn[i].push_back(pdi(c, j));\n\t\t\t\tconn[j].push_back(pdi(c, i));\n\t\t\t}\n\t\t}\n\t\tvector<double> dist(m, INF);\n\t\tvector<int> done(m);\n\t\tpriority_queue< pdi, vector<pdi>, greater<pdi> > pq;\n\t\tdist[0] = 0.0;\n\t\tpq.push(pdi(0.0, 0));\n\t\twhile(!pq.empty()){\n\t\t\tconst pdi p = pq.top();\n\t\t\tpq.pop();\n\t\t\tconst double c = p.first;\n\t\t\tconst int u = p.second;\n\t\t\tif(done[u]){ continue; }\n\t\t\tdone[u] = 1;\n\t\t\tfor(int i = 0; i < conn[u].size(); ++i){\n\t\t\t\tconst double nc = c + conn[u][i].first;\n\t\t\t\tconst int v = conn[u][i].second;\n\t\t\t\tif(!done[v] && nc < dist[v]){\n\t\t\t\t\tdist[v] = nc;\n\t\t\t\t\tpq.push(pdi(nc, v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist.back() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\n#define EPS 1e-9\n#define INF 1e9\n\n// ?????¢, ??????, ??????\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(Point a, Point b){ return a.real() * b.imag() - a.imag() * b.real(); }\n\n\n// ccw\n//  1: c?????????ab??????????????´????????? (a?????????, b????\\\\??¨????????¨???)\n// -1: c?????????ab??????????????´?????????\n//  2: c?????????ab?????¶????????????a?????????????????????\n// -2: c?????????ab?????¶????????????b???????\\\\?????????\n//  0: c?????????ab????????????\nint ccw(Point a, Point b, Point c){\n  if(cross(b - a, c - a) > EPS) return 1;\n  if(cross(b - a, c - a) < -EPS) return -1;\n  if(dot(b - a, c - a) < -EPS) return 2;\n  if(dis(a, b) + EPS < dis(c, a)) return -2;\n  return 0;\n}\nint ccw(Line a, Point b){ return ccw(a.first, a.second, b); }\n\n// ??????????????????(??????2???????????¶??´????????????)\nLine CircleCross(Point a, double ra, Point b, double rb){\n  double d = dis(a, b);\n  double rc = (d * d + ra * ra - rb * rb) / (2 * d);\n  double rs = sqrt(ra * ra - rc * rc);\n  Point diff = (b - a) / d;\n  return make_pair(a + diff * Point(rc, rs), a + diff * Point(rc, -rs));\n}\n\n\nvector<double> dijk(int s, vector<vector<pair<double, int> > > adj){\n  int n = adj.size();\n  vector<double> result(n, INF);\n  priority_queue<pair<double, int> > wait;  \n  result[s] = 0;\n  wait.push(make_pair(0, s));\n\n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int nowpoint = wait.top().second;\n    wait.pop();\n    if(result[nowpoint] < nowcost){ continue; }\n    \n    for(int i = 0; i < (int)adj[nowpoint].size(); i++){\n      double nextcost = adj[nowpoint][i].first + nowcost;\n      int nextpoint = adj[nowpoint][i].second;\n      if(result[nextpoint] > nextcost){\n        wait.push(make_pair(-nextcost, nextpoint));\n        result[nextpoint] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\n\nint main(void){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    // ??????????????¨?????????????????????\n    double x, y, r;\n    vector<pair<Point, double> > circles;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y >> r;\n      circles.push_back(make_pair(Point(x, y), r));\n    }\n\n    // ????????????(+?§??????¨??????)?????????\n    // second??????????????????????????????????????????????¨????\n    vector<pair<Point, int> > vertices;\n    vertices.push_back(make_pair(circles[0].first, 0));\n    for(int i = 0; i < n - 1; i++){\n      Line tmp = CircleCross(circles[i].first, circles[i].second, circles[i + 1].first, circles[i + 1].second);\n      vertices.push_back(make_pair(tmp.first, 1));\n      vertices.push_back(make_pair(tmp.second, -1));\n    }\n    vertices.push_back(make_pair(circles[n - 1].first, 0));\n\n    // ??????i??¨j????????????????????????\n    // ??????k(i+1???j-1)????????????????????????????????????????????°OK\n    vector<vector<pair<double, int> > > adj(vertices.size());\n    for(int i = 0; i < (int)vertices.size(); i++){\n      for(int j = i + 1; j < (int)vertices.size(); j++){\n        bool flag = true;\n        for(int k = i + 1; k < j; k++){\n          int tmp = ccw(vertices[i].first, vertices[j].first, vertices[k].first);\n          if(tmp != vertices[k].second){ flag = false; }\n        }\n        if(flag){ adj[i].push_back(make_pair(dis(vertices[i].first, vertices[j].first), j)); }\n      }\n    }\n\n    // ??????????????????????????????????????????\n    vector<double> result = dijk(0, adj);\n    printf(\"%.10f\", result[result.size() - 1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <iomanip>\nusing namespace std;\n#define EPS 1e-10\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    //点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n    // bool operator<(const C a, const C b){\n    //     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n    // }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nint n;\nint main(){\n    while(cin >> n &&n!=0){\n        vector<C>v(n);\n        vector<double>r(n);\n        for(int i=0;i<n;i++){\n            double a,b;\n            cin >> a >> b >> r[i];\n            v[i] = C(a,b);\n        }\n        vector<L>l(n);\n        for(int i=0;i<n-1;i++){\n            l[i] = crosspointCC(v[i],r[i],v[i+1],r[i+1]);\n        }\n        vector<C>s(2*n);\n        s[0] = v[0];\n        s[2*n-1] = v[n-1];\n        for(int i=0;i<n-1;i++){\n            s[i*2+1] = l[i][0];\n            s[i*2+2] = l[i][1];\n        }\n        vector<vector<double>  > g(2*n,vector<double>(2*n,100000000.0));\n        for(int i=0;i<2*n;i++){\n            g[i][i] = 0.0;\n        }\n        bool fflag = 1;\n        for(int i=0;i<n-1;i++){\n            L a = L(s[0],s[2*n-1]);\n            if(!intersectSS(a,l[i])){\n                fflag = 0;\n            }\n        }\n        if(fflag){\n            g[0][2*n-1] = abs(s[0]-s[2*n-1]);\n            g[2*n-1][0] = abs(s[0]-s[2*n-1]);\n        }\n        for(int i=0;i<n-1;i++){\n            L a = L(s[0],s[1+2*i]);\n            bool flag = 1;\n            for(int j=0;j<i;j++){\n                if(!intersectSS(a,l[j])){\n                    flag =0;\n                }\n            }\n            if(flag){\n                g[0][1+2*i]=abs(s[0]-s[1+2*i]);\n                g[1+2*i][0]=abs(s[0]-s[1+2*i]);\n            }\n            a = L(s[0],s[2+2*i]);\n            flag = 1;\n            for(int j=0;j<i;j++){\n                if(!intersectSS(a,l[j])){\n                    flag =0;\n                }\n            }\n            if(flag){\n                g[0][2+2*i]=abs(s[0]-s[2+2*i]);\n                g[2+2*i][0]=abs(s[0]-s[2+2*i]);\n            }\n        }\n        for(int i=n-2;i>=0;i--){\n            L a = L(s[2*n-1],s[1+2*i]);\n            bool flag = 1;\n            for(int j=n-2;j>i;j--){\n                if(!intersectSS(a,l[j])){\n                    flag =0;\n                }\n            }\n            if(flag){\n                g[2*n-1][1+2*i]=abs(s[2*n-1]-s[1+2*i]);\n                g[1+2*i][2*n-1]=abs(s[2*n-1]-s[1+2*i]);\n            }\n            a = L(s[2*n-1],s[2+2*i]);\n            flag = 1;\n            for(int j=n-2;j>i;j--){\n                if(!intersectSS(a,l[j])){\n                    flag =0;\n                }\n            }\n            if(flag){\n                g[2*n-1][2+2*i]=abs(s[2*n-1]-s[2+2*i]);\n                g[2+2*i][2*n-1]=abs(s[2*n-1]-s[2+2*i]);\n            }\n        }\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n-1;j++){\n                for(int z=1;z<=2;z++){\n                    for(int zz=1;zz<=2;zz++){\n                    \n                        L a = L(s[z+2*i],s[zz+2*j]);\n                        bool flag =1;\n                        for(int k=i+1;k<j;k++){\n                            if(!intersectSS(l[k],a)){\n                                flag = 0;\n                            }\n                        }\n                        if(flag){\n                            g[z+2*i][zz+2*j]=abs(s[z+2*i]-s[zz+2*j]);\n                            g[zz+2*j][z+2*i]=abs(s[z+2*i]-s[zz+2*j]);\n                        }\n                    }\n                }\n            }\n        }\n        for(int k=0;k<2*n;k++){\n            for(int i=0;i<2*n;i++){\n                for(int j=0;j<2*n;j++){\n                    g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n                }\n            }   \n        }\n        cout <<fixed << setprecision(10) << g[0][2*n-1] << endl;\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> point;\n\nstruct line : public vector<point> {\n\tline() { push_back(0); push_back(0); }\n\tline(const point& a, const point& b) { push_back(a); push_back(b); }\n};\n\nstruct circle {\n\tpoint p; double r;\n\tcircle() : p(0),r(0) {}\n\tcircle(const point& p, const double r) : p(p), r(r) {}\n};\n\nconst double pi=M_PI;\nconst double inf = 1e20;\nconst double eps = 1e-10;\npoint  unit (const point& v) { return v/abs(v); }\npoint  ortho(const point& v) { return v*point(0,1); }\npoint  vec  (const line&  l) { return l[1]-l[0]; }\ndouble dot  (const point& a, const point& b) { return (a*conj(b)).real(); }\ndouble cross(const point& a, const point& b) { return (conj(a)*b).imag(); }\n\nint ccw(const point& a, const point& b, const point& c) {\n\tpoint u=b-a, v=c-a;\n\tif(cross(u,v) > 0 ) return +1;\n\tif(cross(u,v) < 0 ) return -1;\n\tif(  dot(u,v) < 0 ) return +2;\n\tif(abs(u) < abs(v)) return -2;\n\treturn 0;\n}\n\nint ccw(const line& l, const point& p) {\n\treturn ccw(l[0], l[1], p);\n}\n\nbool intersectSS(const line& s, const line& t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0\n\t    && ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\n/// [verified 1] ヘロンの公式\ndouble heron(double a, double b, double c) {\n\tdouble s = (a + b + c) / 2.0;\n\treturn sqrt( s * (s-a) * (s-b) * (s-c) );\n}\n\n/// [verified 1] 円と円の交点\nline crosspointCC(const circle& a, const circle& b) {\n\tdouble l = abs(b.p-a.p);;\n\tdouble d = 2.0 * heron(l, a.r, b.r) / l;\n\tdouble t = sqrt(a.r*a.r - d*d);\n\tpoint  v = t * unit(b.p-a.p) ;\n\tpoint  w = d * unit(ortho(v));\n\treturn line(a.p+v+w, a.p+v-w);\n}\nint N;\ncircle c[128];\t\t\nline x[128];\n\nbool check(const line& v, int s, int t) {\n\tfor(int i=s+1; i<t; i++) {\n\t\tif(!intersectSS(v, x[i])) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(cin>>N, N)\n\t{\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tcin>>c[i].p.real()>>c[i].p.imag()>>c[i].r;\n\t\t}\n\n\t\tfor(int i=0; i<N-1; i++) {\n\t\t\tx[i+1] = crosspointCC(c[i],c[i+1]);\n\t\t}\n\t\tx[0] = line(c[  0].p, c[  0].p);\n\t\tx[N] = line(c[N-1].p, c[N-1].p);\n\n\t\tdouble dp[128][2];\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tdp[i][0]=dp[i][1]=inf;\n\t\t}\n\t\tdp[0][0]=dp[0][1]=0;\n\n\t\tint test[128][2]={0};\n\n\t\tfor(int i=1; i<=N; i++)\n\t\tfor(int j=0; j<i;  j++)\n\t\t{\n\t\t\tfor(int s=0; s<2; s++)\n\t\t\tfor(int t=0; t<2; t++)\n\t\t\t{\n\t\t\t\tline l(x[j][s], x[i][t]);\n\t\t\t\tif(check(l,j,i)) { \n\t\t\t\t\tif(dp[j][s]+abs(vec(l)) < dp[i][t]) {\n\t\t\t\t\t\tdp[i][t] = dp[j][s]+abs(vec(l));\n\t\t\t\t\t\ttest[i][t] = j*100 + s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(10);\n\t\tcout << min(dp[N][0], dp[N][1]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tC c[100];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i].p.real() >> c[i].p.imag() >> c[i].r;\n\t\t}\n\t\tvector<P> p;\n\t\tp.push_back(c[0].p);\n\t\tp.push_back(c[n-1].p);\n\t\tfor(int i = 0 ; i < n-1 ; i++){\n\t\t\tvector<P> a = C_cp(c[i],c[i+1]);\n\t\t\tfor(int k = 0 ; k < a.size() ; k++)\n\t\t\t\tp.push_back(a[k]);\n\t\t}\n\t\t\n\t\tvector< vector<pair<double,int> > > g(p.size());\n\t\t\n\t\tfor(int i = 0 ; i < p.size() ; i++){\n\t\t\tfor(int j = i+1 ; j < p.size() ; j++){\n\t\t\t\tvector<C> d;\n\t\t\t\tint minIdx = 1e9;\n\t\t\t\tint maxIdx = -1e9;\n\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\tif( distanceSP(L(p[i],p[j]),c[k].p) < c[k].r + EPS ){\n\t\t\t\t\t\tminIdx = min(minIdx,k);\n\t\t\t\t\t\tmaxIdx = max(maxIdx,k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint flag = true;\n\t\t\t\tfor(int k = minIdx ; k < maxIdx ; k++){\n\t\t\t\t\tvector<P> a = C_cp(c[k],c[k+1]);\n\t\t\t\t\tif( !intersectLL(L(p[i],p[j]),L(a[0],a[1])) || distanceSP(L(a[0],a[1]), crosspoint(L(p[i],p[j]),L(a[0],a[1]) ) ) > EPS || distanceSP(L(p[i],p[j]), crosspoint(L(p[i],p[j]),L(a[0],a[1]) ) ) > EPS ){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( flag ) {\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << abs(p[i]-p[j]) << \"{\" << minIdx << \" \" << maxIdx << endl;\n\t\t\t\t\tg[i].push_back(make_pair(abs(p[i]-p[j]),j));\n\t\t\t\t\tg[j].push_back(make_pair(abs(p[i]-p[j]),i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue< pair<double,int> > Q;\n\t\tvector<int> done(p.size(),0);\n\t\tQ.push(make_pair(0,0));\n\t\twhile(Q.size()){\n\t\t\tint qi = Q.top().second;\n\t\t\tdouble qcost = Q.top().first;\n\t\t\tQ.pop();\n\t\t\tif( done[qi]++) continue;\n\t\t\t//cout << qi << p[qi] << \" \" << -qcost << endl;\n\t\t\tif( qi == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",-qcost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < g[qi].size() ; i++)\n\t\t\t\tQ.push(make_pair(qcost-g[qi][i].first,g[qi][i].second));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <list>\n#include <map>\n#include <cmath>\n#include <utility>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <set>\n#include <climits>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI = acos(-1.0);\n\ntemplate<class T>\nstruct Po{\n\tT x,y;\n\tPo() : x(0.0),y(0.0) {}\n\tPo(const T &x,const T &y) : x(x),y(y) {}\n\tPo operator+(const Po& a) const { return P(x + a.x,y + a.y); }\n\tPo operator-(const Po& a) const { return P(x - a.x,y - a.y); }\n\tPo operator*(const double& a) const { return P(x * a, y * a); }\n\tPo operator/(const double& a) const { return P(x / a, y / a); }\n};\n\nenum{ CCW = 1,CW = -1,ON = 0};\n\ntypedef Po<double> P;\n\ndouble SQ(double x) {return x* x; }\ndouble abs(const P& a) { return sqrt(SQ(a.x) + SQ(a.y)); }\ndouble dot( const P& a,const P &b){ return a.x * b.x + a.y * b.y ; }\ndouble cross( const P& a,const P &b){ return a.x * b.y - a.y * b.x ; }\n\nP rot(const P& a, double theta){\n\treturn P( a.x * cos(theta) - a.y * sin(theta) ,\n\t\ta.x * sin(theta) + a.y * cos(theta) );\n}\n\nint ccw(P a,P b,P c){\n\tb = b - a; c = c - a;\n\tdouble rdir = cross(b,c);\n\tdouble len = abs(b) * abs(c);\n\tif( rdir > EPS *len) return CCW;\n\telse if( rdir < -EPS * len) return CW;\n\treturn ON;\n}\n\nbool intersect(P& a1,P& b1,P& a2, P& b2){\n\tif(max(a1.x,b1.x) + EPS < min(a2.x,b2.x)\n\t||max(a1.y,b1.y) + EPS < min(a2.y,b2.y)\n\t||max(a2.x,b2.x) + EPS < min(a1.x,b1.x)\n\t||max(a2.y,b2.y) + EPS < min(a1.y,b1.y) ) return false;\n\treturn ccw(a1,b1,a2) * ccw(a1,b1,b2) <= 0\n\t\t&& ccw(a2,b2,a1) * ccw(a2,b2,b1) <= 0;\n}\n\ntypedef pair<P,P> PD;\n\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\nint n;\nP p[100];\ndouble r[100];\ndouble dp[202][202];\n\n#define FOR(i,n) for(int i = 0; i < (n) ; i++)\n\n\nint main(){\n\n\twhile(cin>>n,n){\n\t\tvector<P> us;\n\t\tvector<PD> vpd;\n\t\tFOR(i,n) cin>>p[i].x >> p[i].y >> r[i];\n\t\tFOR(i,202) FOR(j,202) dp[i][j] = 1e50;\n\t\tus.push_back(p[0]);\n\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tPD pd = GetContact(p[i],p[i+1],r[i],r[i+1]);\n\t\t\tus.push_back(pd.first);\n\t\t\tus.push_back(pd.second);\n\t\t\tvpd.push_back(pd);\n\t\t}\n\t\tus.push_back(p[n-1]);\n\n\t\tfor(int i = 0; i < (int)us.size(); i++){\n\t\t\tfor(int j = i + 1; j < (int)us.size(); j++){\n\t\t\t\tbool ok = true;\n\t\t\t\tint l  = (1 + i) / 2;\n\t\t\t\tint r = (1 + j) / 2 - 1;\n\t\t\t\tfor (int k = l; k < r; k++){\n\t\t\t\t\tif(!intersect(us[i],us[j],vpd[k].first,vpd[k].second))\n\t\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok) continue;\n\t\t\t\tdouble dist = abs(us[i] - us[j]);\n\t\t\t\tdp[j][i] = dp[i][j] = dist;\n\t\t\t}\n\t\t}\n\n\t\tint a = (int)us.size();\n\t\tFOR(k,a) FOR(i,a) FOR(j,a) dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\n\t\tprintf(\"%.10lf\\n\",dp[0][a - 1]);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n \n// double\nstruct P{\n    P(){}\n    P(double _r, double _i):r(_r), i(_i){}\n    void real(const double& v){r = v;}\n    void imag(const double& v){i = v;}\n    double r, i;\n};\n \ndouble real(const P& p){return p.r;}\ndouble imag(const P& p){return p.i;}\ndouble norm(const P& p){double r = real(p), i = imag(p); return r * r + i * i;}\ndouble dist(const P& p){return std::sqrt(norm(p));}\n \nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n \ndouble cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n \ndouble dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n \nbool areIntersectedLines(const P& p1, const P& p2, const P& q1, const P& q2){\n    if(cross(p1-p2, q1-p2) == 0 && dot(p1-p2, q1-p2) > 0 &&\n       0 <= norm(q1-p2) && norm(q1-p2) <= norm(p1-p2)){\n        return true;\n    }\n    if(cross(p1-p2, q2-p2) == 0 && dot(p1-p2, q2-p2) > 0 &&\n       0 <= norm(q2-p2) && norm(q2-p2) <= norm(p1-p2)){\n        return true;\n    }\n    if(cross(q1-q2, p1-q2) == 0 && dot(q1-q2, p1-q2) > 0 &&\n       0 <= norm(p1-q2) && norm(p1-q2) <= norm(q1-q2)){\n        return true;\n    }\n    if(cross(q1-q2, p2-q2) == 0 && dot(q1-q2, p2-q2) > 0 &&\n       0 <= norm(p2-q2) && norm(p2-q2) <= norm(q1-q2)){\n        return true;\n    }\n \n    return (cross(p1-p2, q1-p2) * cross(p1-p2, q2-p2) < 0) &&\n        (cross(q1-q2, p1-q2) * cross(q1-q2, p2-q2) < 0);\n}\n \nint N;\nP ps[100], is[101][2];\ndouble rs[100], dp[101][2];\n \ndouble rec(int index, int which){\n    if(index == N){return 0.0;}\n    if(dp[index][which] > 0.0){return dp[index][which];}\n     \n    double res = 1e20;\n    for(int i=index+1;i<=N;i++){\n        for(int w=0;w<2;w++){\n            int j;\n            for(j=index+1;j<i;j++){\n                if(!areIntersectedLines(is[index][which], is[i][w], is[j][0], is[j][1])){\n                    break;\n                }\n            }\n \n            if(j == i){res = std::min(res, rec(i, w) + dist(is[index][which] - is[i][w]));}\n            else{break;}\n        }\n    }\n \n    return dp[index][which] = res;\n}\n \nint main(){\n    while(scanf(\"%d\", &N), N){\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<2;j++){\n                dp[i][j] = -1.0;\n            }\n        }\n     \n        for(int i=0;i<N;i++){\n            double x, y;\n            scanf(\"%lf %lf %lf\", &x, &y, rs+i);\n \n            ps[i].real(x);\n            ps[i].imag(y);\n        }\n \n        is[0][0] = ps[0];\n        is[N][0] = ps[N-1];\n        is[N][1] = ps[N-1];\n        for(int i=1;i<N;i++){\n            P u = ps[i] - ps[i-1], v{-imag(u), real(u)};\n            double d = dist(u);\n            double x = 0.5 / d * (1.*d*d + rs[i-1]*rs[i-1] - rs[i]*rs[i]),\n                y = std::sqrt(rs[i-1]*rs[i-1] - x*x);\n         \n            u = {real(u) / d * x, imag(u) / d * x};\n            v = {real(v) / d * y, imag(v) / d * y};\n         \n            P w = u + v;\n            is[i][0] = ps[i-1] + w;\n \n            w = u - v;\n            is[i][1] = ps[i-1] + w;\n        }\n \n        printf(\"%.6f\\n\", rec(0, 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<C> c(n);\n\t\trep(i, n) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tc[i] = C{ P{(double)x,(double)y},(double)r };\n\t\t}\n\t\tvector<double[2]> dp(n - 1);\n\t\tvector<L> s(n - 1);\n\t\trep(i, n - 1) {\n\t\t\tauto x = is_cc(c[i], c[i + 1]);\n\t\t\ts[i] = { x[0],x[1] };\n\t\t}\n\t\tVP p = { c[n - 1].p };\n\t\trep1(i, n - 2) {\n\t\t\tdp[i][0] = min(dp[i - 1][0] + abs(s[i].a - s[i - 1].a), dp[i - 1][1] + abs(s[i].a - s[i - 1].b));\n\t\t\tdp[i][1] = min(dp[i - 1][0] + abs(s[i].b - s[i - 1].a), dp[i - 1][1] + abs(s[i].b - s[i - 1].b));\n\t\t}\n\t\tint prev = (dp[n - 2][0] < dp[n - 2][1] ? 0 : 1);\n\t\tp.push_back(prev ? s[n - 2].b : s[n - 2].a);\n\t\trrep(i, n - 2) {\n\t\t\tprev = (dp[i][0] + abs(s[i].a - (prev ? s[i + 1].b : s[i + 1].a)) == dp[i + 1][prev] ? 0 : 1);\n\t\t\tp.push_back(prev ? s[i].b : s[i].a);\n\t\t}\n\t\tp.push_back(c[0].p);\n\t\treverse(ALL(p));\n\t\tVP ans = { p[0] };\n\t\trep1(i, n - 1) {\n\t\t\tif (!isis_ls({ ans.back(),p[i + 1] }, s[i - 1]))ans.push_back(p[i]);\n\t\t}\n\t\tans.push_back(p.back());\n\t\tdouble a = 0;\n\t\trep(i, ans.size() - 1)a += abs(ans[i] - ans[i + 1]);\n\t\tcout << fixed << setprecision(5) << a << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n// #define EPS 1e-8\n// static const int INF=1<<24;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double M_PI = asin(0.5)*6;\n\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P,i) P[(i)%P.size()]\n#define Next(P,i) P[(i+1)%P.size()]\n#define Prev(P,i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n  bool operator<(const P a,const P b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\ndouble cross(const P a,const P b){\n  return (conj(a)*b).imag();\n}\ndouble dot(const P a,const P b){\n  return (conj(a)*b).real();\n}\n// TODO make graph (20)\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)>0)    return +1;//counter clockwise\n  if(cross(b,c)<0)    return -1;//clockwise\n  if(dot(b,c)<0)      return +2;// c--a--b\n  if(norm(b)<norm(c)) return -2;// a--b--c\n                      return  0;// a--c--b(or b==c)\n}\n\nstruct L : public vector<P>{\n  L(){}\n  L(const P a,const P b){\n    push_back(a),push_back(b);\n  }\n};\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C{\n  P p;double r;\n  C(){}\n  C(const P p,double r): p(p),r(r){}\n};\n\n\n\n//直線と点の関係\n//点から線分に垂線を下ろした点\nP projection(L a,P p){\n  double t = dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0] + t*(a[0]-a[1]);\n}\n//線対称の点\nP reflection(L a,P p){\n  return p + 2.0 * (projection(a,p)-p);\n}\n\n\n\n\n//交差判定\n//TODO CP(内包) CL CS (0)\nbool isCrossLL(L a,L b){\n  return \n    abs(cross(a[1]-a[0],b[1]-b[0])) > EPS\n    || abs(cross(a[1]-a[0],b[0]-a[0])) < EPS ;\n}\nbool isCrossLS(L a,S b){\n  return \n    cross(a[1]-a[0],b[0]-a[0]) \n    * cross(a[1]-a[0],b[1]-a[0]) < EPS;\n}\nbool isCrossLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool isCrossSS(S a,S b){\n  return\n    ccw(a[0],a[1],b[0])\n    * ccw(a[0],a[1],b[1]) <= 0\n    &&\n    ccw(b[0],b[1],a[0])\n    * ccw(b[0],b[1],a[1]) <= 0;\n}\nbool isCrossSP(S a,P p){\n  return abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\n\n// 距離 CP CL CS は(distXP(x,c.p)-c.r)\ndouble distPP(P a,P b){\n  return abs(a-b);\n}\ndouble distLP(L a,P p){\n  return abs(p-projection(a,p));\n}\ndouble distLL(L a,L b){\n  return isCrossLL(a,b) ? 0 : distLP(a,b[0]);\n}\ndouble distLS(L a,S b){\n  return isCrossLS(a,b) ? 0 : min(distLP(a,b[0]),distLP(a,b[1]));\n}\ndouble distSP(S a,P p){\n  const P r = projection(a,p);\n  return isCrossSP(a,r) ? abs(p-r) : min(abs(a[0]-p),abs(a[1]-p));\n}\ndouble distSS(S a,S b){\n  return isCrossSS(a,b)?0:\n    min(\n      min(distSP(a,b[0]),distSP(a,b[1])),\n      min(distSP(b,a[0]),distSP(b,a[1]))\n    );\n}\n\n//円の交差判定\nbool isCrossCP(C a,P p){\n  return abs(a.p-p)-a.r<=EPS;\n}\nbool isCrossCL(C a,L l){\n  return distLP(l,a.p)-a.r<EPS;\n}\ndouble distSP_MAX(S a,P p){\n  return max(abs(a[0]-p),abs(a[1]-p));\n}\nbool isCrossCS(C a,S s){\n  return distSP(s,a.p)-a.r<-EPS&&distSP_MAX(s,a.p)-a.r>+EPS;\n}\nbool isCrossCC(C a,C b){//接してる時は交差\n  return abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\n\n//交差点\n//先に交差判定をすること\nP crossP_LL(L a,L b){\n  double A = cross(a[1]-a[0],b[1]-b[0]);\n  double B = cross(a[1]-a[0],a[1]-b[0]);\n  if(abs(A)<EPS && abs(B)<EPS)return b[0];\n  if(abs(A)<EPS)assert(false);\n  return b[0]+B/A*(b[1]-b[0]);\n}\nvector<P> crossP_CL(C c,L l){\n  P tmp = projection(l,c.p);\n  P e = (l[0]-l[1])/abs(l[0]-l[1]);\n  double h = abs(c.p-tmp)*abs(c.p-tmp);\n  double t = sqrt(c.r*c.r - h*h);\n  if(t<EPS)return {tmp};\n  return {tmp + e*t,tmp - e*t};\n}\nvector<P> crossP_CC(C a,C b){\n  P A = conj(b.p-a.p);\n  P B = (b.r*b.r - a.r*a.r - (b.p-a.p)*conj(b.p-a.p));\n  P C = a.r*a.r*(b.p-a.p);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+a.p;\n  P z2 = (-B-sqrt(D))/(2.0*A)+a.p;\n  return {z1,z2};\n}\n\n\n\n//三点->円\nP PPPtoC(P a,P b,P c){\n  P x = 1.0/(conj(b-a));\n  P y = 1.0/(conj(c-a));\n  return (y-x)/( conj(x)*y - x*conj(y) ) + a;\n}\n\n//凸包\nG convex_hull(G ps){\n  int n = ps.size();\n  int k = 0;\n  G ch(2*n);\n  for(int i = 0;i<n;(ch[k++]=ps[i++])){\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  for(int i = n-2,t=k+1 ; i>=0 ; ch[k++]=ps[i--]){\n    while(k>=t && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch;\n} \n\n\n//凸性判定\nbool isConvex(G g){\n  for(int i=0; i<g.size();i++){\n    if(ccw(Prev(g,i),Curr(g,i),Next(g,i))>0)return false;\n  }\n}\n\n\n\n//接線\n//TODO check\nvector<L> TLine_CP(C c,P p){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P n2 = reflection(L(p,c.p),n1);\n  return {L(p,n1),L(p,n2)};\n}\n\n// TLine CC\nvector<L> TLine_CPr(C c,P p,double r){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P e1 = (n1-c.p)/abs(n1-c.p) * r;\n  P n2 = reflection(L(p,c.p),n1);\n  P e2 = (n2-c.p)/abs(n2-c.p) * r;\n  return {L(p+e1,n1+e1),L(p+e2,n2+e2)};\n}\nvector<L> TLine_CC(C a,C b){\n  //接してる時がヤバイ\n  vector<L> res;\n  if(!isCrossCC(a,b)&&(abs(a.r)>EPS)&&(abs(b.r>EPS))){\n    P tmp = (a.p-b.p)*(b.r)/(a.r+b.r) + b.p;\n    auto t1 = TLine_CP(a,tmp);\n    auto t2 = TLine_CP(b,tmp);\n    res.push_back(L(t1[0][1],t2[0][1]));\n    res.push_back(L(t1[1][1],t2[1][1]));\n  }\n  if(abs(a.r-b.r)<EPS){\n    const auto r = a.r;\n    P e = (a.p-b.p)/abs(a.p-b.p) * exp(P(.0,90.0/180.0*M_PI));\n    res.push_back(L(a.p+(e*r),b.p+(e*r)));\n    if(abs(r)>=EPS)res.push_back(L(a.p-(e*r),b.p-(e*r)));\n  }else{\n    if(a.r<b.r)swap(a,b);\n    auto t3 = TLine_CPr(C(a.p,a.r-b.r),b.p,b.r);\n    for(auto i:t3){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\n//原点を起点とした回転\nP rotate(P a,double r){\n  return a*exp(P(0.0,r*M_PI/180.0));\n}\n\ndouble dp[110][2];\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C> cir(n);\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b>>cir[i].r;\n      cir[i].p=P(a,b);\n      // cout<<cir[i].p.X<<\" \"<<cir[i].p.Y<<\" \"<<cir[i].r<<endl;\n\t\t}\n    VV(P) po;\n    po.PB(vector<P>(1,cir[0].p));\n    rep(i,n-1){\n      po.PB(crossP_CC(cir[i],cir[i+1]));\n    }\n    po.PB(vector<P>(1,cir[n-1].p));\n    rep(i,110){\n      rep(j,2){\n        dp[i][j]=INF;\n      }\n    }\n    // printf(\"%.6lf %.6lf\\n\",po[1][0].X,po[1][0].Y);\n    // printf(\"%.6lf %.6lf\\n\",po[1][1].X,po[1][1].Y);\n    dp[0][0]=dp[0][1]=0;\n    reep(i,1,n){\n      if(i==1){\n        dp[1][0]=distPP(cir[0].p,po[1][0]);\n        dp[1][1]=distPP(cir[0].p,po[1][1]);\n      }\n      // dp[i][0]=mkp(distPP(cir[0].p,po[0][0]),0);\n      else{\n        rep(j,2){\n          for(int k=i-1;k>=0;k--){\n            rep(g,po[k].size()){\n              S t1=S(po[i][j],po[k][g]);\n              bool f=true;\n              reep(h,k+1,i){\n                f&=isCrossSS(t1,S(po[h][0],po[h][1]));\n              }\n              if(f){\n                if(dp[i][j]>distPP(po[i][j],po[k][g])+dp[k][g]){\n                  dp[i][j]=distPP(po[i][j],po[k][g])+dp[k][g];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    double ans=INF;\n    rep(i,n){\n      rep(j,po[i].size()){\n        // cout<<i<<\" \"<<j<<\" \";\n        // printf(\"%.6lf\\n\",dp[i][j]);\n        S t1=S(po[i][j],po[n][0]);\n        bool f=true;\n        reep(k,i+1,n){\n          f&=isCrossSS(t1,S(po[k][0],po[k][1]));\n        }\n        if(f){\n          ans=min(ans,dp[i][j]+distPP(po[i][j],po[n][0]));\n        }\n      }\n    }\n    printf(\"%.6lf\\n\",ans);\n    // rep(i,n){\n      // cout<<dp[i][0].se<<\" \"<<dp[i][1].se<<endl;\n    // }\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Circle> Cir(n);\n\t\tPoint s, t;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tint x, y, r; cin >> x >> y >> r;\n\t\t\tif (i == 0)s = Point(x, y);\n\t\t\tif (i == n - 1) t = Point(x, y);\n\t\t\tCir[i] = Circle(Point(x, y), r);\n\t\t}\n\t\tvector<Point> ps;\n\t\tps.push_back(s);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tauto temp_p = is_cc(Cir[i - 1], Cir[i]);\n\t\t\tfor (auto p : temp_p) {\n\t\t\t\tps.push_back(p);\n\t\t\t}\n\t\t}\n\t\tps.push_back(t);\n\t\t/*for (auto p : ps) {\n\t\t\tcout << p << endl;\n\t\t}*/\n\t\tint Size = ps.size();\n\t\tvector<vector<ld>> dist(Size, vector<ld>(Size, INF));\n\t\t//vector<vector<int>> can_use(Size, vector<int>(Size, 0));\n\t\tfor (int i = 0; i < Size - 1;i++) {\n\t\t\tint idx;\n\t\t\tif (i == 0)idx = 1;\n\t\t\telse idx = 2 * ((i + 1) / 2) + 1;\n\t\t\tPoint v1 = ps[idx] - ps[i], v2 = ps[min(idx + 1, Size - 1)] - ps[i];\n\t\t\tld arg1 = arg(v1), arg2 = arg(v2);\n\t\t\tdist[i][idx] = abs(v1); dist[i][min(idx + 1, Size - 1)] = abs(v2);\n\t\t\t//can_use[i][idx] = can_use[i][min(idx + 1, Size - 1)] = 1;\n\t\t\t//cout << \"------------------------\" << endl;\n\t\t\tfor (int j = idx + 2; j < Size;j++) {\n\t\t\t\tPoint v3 = ps[j] - ps[i];\n\t\t\t\tld arg3 = arg(v3);\n\t\t\t\tif (j % 2 == 1 && arg3 < arg2)break;\n\t\t\t\telse if (j % 2 == 0 && arg3 > arg1)break;\n\t\t\t\tif (arg3 > arg1 || arg3 < arg2) { continue; }\n\t\t\t\tdist[i][j] = abs(v3); //can_use[i][j] = 1;\n\t\t\t\tif (j % 2 == 1) { arg1 = min(arg1, arg3); }\n\t\t\t\telse { arg2 = max(arg2, arg3); }\n\t\t\t\t//cout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Size;i++) {\n\t\t\tfor (int j = 0; j < Size;j++) {\n\t\t\t\tfor (int k = 0; k < Size;k++) {\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << dist[0][Size - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n\nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n\n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n\n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n\n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.a - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Segment& a,const Segment& b){\n  return abs( cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Segment& a,const Segment& b){\n    return dot( a.a - a.b, b.a - b.b) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n};\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\nstruct node{\n  double cost;\n  P pos;\n  int nowy, nowx;\n  bool operator < (const node &left) const {\n    return cost > left.cost;\n  }\n};\n\nint main(){\n  int n;\n  C prev, now;\n\n  Geometory::Segments seg;\n\n  while(cin >> n, n){\n    cin >> prev.p >> prev.r;\n    seg.push_back( S( prev.p, prev.p));\n    for(int i = 1; i < n; i++){\n      cin >> now.p >> now.r;\n      Geometory::PointPoint pp = geo.Crosspoint( prev, now);\n      seg.push_back( S(pp.first,pp.second));\n      prev = now;\n    }\n    seg.push_back( S( prev.p, prev.p));\n\n    typedef pair< int, int > POS;\n    typedef pair< double, P > PS;\n    priority_queue< node > que;\n    que.push((node){ 0, seg[0].a, 0, 0});\n    bool used[101][2] = {{}};\n    double ret;\n    while(!que.empty()){\n      node p = que.top(); que.pop();\n      if(p.nowy == n){ ret = p.cost; break; }\n      if(used[p.nowy][p.nowx]++) continue;\n      for(int i = p.nowy + 1; i <= n; i++){\n        S s1 = S( p.pos, seg[i].a), s2 = S( p.pos, seg[i].b);\n        bool flag1 = true, flag2 = true;\n        for(int j = i - 1; j > p.nowy; j--){\n          if(!geo.Intersect( s1, seg[j])){\n            flag1 = false;\n            break;\n          }\n        }\n        for(int j = i - 1; j > p.nowy; j--){\n          if(!geo.Intersect( s2, seg[j])){\n            flag2 = false;\n            break;\n          }\n        }\n        if(flag1) que.push((node){ p.cost + (s1.a - s1.b).abs(), s1.b, i, 0});\n        if(flag2) que.push((node){ p.cost + (s2.a - s2.b).abs(), s2.b, i, 1});\n      }\n    }\n    cout << fixed << setprecision(7) << ret << endl;\n\n    seg.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0), inf = 1e20;\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c??????????¨???¨???\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b????????§??´???\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c???????????´???\n\treturn 0;\t\t\t\t\t\t\t// a,c,b???????????´???\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tld d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tassert(d != 0.0);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tres.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line s) {\n\tvector<Point> v = is_lc(c, s), res;\n\tfor (size_t k = 0; k < v.size(); k++) {\n\t\tif (ccw(s.a, v[k], s.b) == -2) {\n\t\t\tres.push_back(v[k]);\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) return res;\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back((Line) { p, p + v1 });\n\tif (l < eps) return res;\n\tres.push_back((Line) { p, p + v2 });\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back((Line) { q1, q1 + v });\n\t\tres.push_back((Line) { q2, q2 + v });\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(5);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Circle> cs(n);\n\t\tfor (int i = 0, x, y, r; i < n; i++) {\n\t\t\tcin >> x >> y >> r;\n\t\t\tcs[i] = (Circle) { Point(x, y), (ld)r };\n\t\t}\n\t\tvector<Point> pp(n * 2); pp[0] = cs[0].p; pp[n * 2 - 1] = cs[n - 1].p;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tauto v = is_cc(cs[i - 1], cs[i]);\n\t\t\tpp[i * 2 - 1] = v[0];\n\t\t\tpp[i * 2] = v[1];\n\t\t}\n\t\tvector<vector<ld>> dis(n * 2, vector<ld>(n * 2, inf));\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tfor (int j = i + 1; j < n * 2; j++) {\n\t\t\t\tbool can = true;\n\t\t\t\tfor (int k = (i + 1) / 2 + 1; k <= (j + 1) / 2; k++) {\n\t\t\t\t\tif (!isis_ss((Line) { pp[i], pp[j] }, (Line) { pp[k * 2 - 1], pp[k * 2] })) {\n\t\t\t\t\t\tcan = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (can) {\n\t\t\t\t\tdis[i][j] = dis[j][i] = abs(pp[i] - pp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < n * 2; k++) {\n\t\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\t\tfor (int j = 0; j < n * 2; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[0][n * 2 - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\ntemplate<class T> T at(vector<T> v, int i) {return v[i % v.size()];}\n\n#define X real()\n#define Y imag()\n\ntypedef double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\n// 比較関数\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\nbool near(P a, P b) {return !sig(norm(a - b));}\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator<(L a, L b) {return !near(a.a, b.a) ? a.a < b.a : a.b < b.b;}\n}\n\n// 平方根\nD sr(D a) {return sqrt(max(a, (D)0));}\n\n// 内積\nD dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.b - a.a;}\n\n// 線分abに対する点cの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  if (near(a, c) || near(b, c)) return ON;\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\n// 射影\nP proj(P a, P b) {return a * dot(a, b) / norm(a);}\nP perp(L l, P p) {return l.a + proj(vec(l), p - l.a);}\n\n// 交差判定\nbool eqL(L a, L b) {return !sig(det(vec(a), vec(b))) && !sig(det(vec(a), b.a - a.a));}\nbool iLLs(L a, L b) {return sig(det(vec(a), vec(b)));}\nbool iLS(L a, L b) {return sig(det(vec(a), b.a - a.a)) * sig(det(vec(a), b.b - a.a)) <= 0;}\nbool iLSs(L a, L b) {return sig(det(vec(a), b.a - a.a)) * sig(det(vec(a), b.b - a.a)) < 0;}\nbool iSS(L a, L b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\n// 交点\nP pLL(L a, L b) {return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));}\n\n// 距離\nD dLP(L l, P p) {return abs(det(vec(l), p - l.a) / vec(l));}\nD dSP(L s, P p) {\n  if (dot(vec(s), p - s.a) < 0) return abs(p - s.a);\n  if (dot(vec(s), p - s.b) > 0) return abs(p - s.b);\n  return dLP(s, p);\n}\n\n// 円\nstruct C{P c; D r;};\n\n// 2円の位置関係\nenum RELATION{SAME = 1, CONTAIN = 2, OVER = 4, NO_CROSS = 8, ONE_CROSS = 16, ONE_CONTAIN_CROSS = 32, ONE_OVER_CROSS = 64, TWO_CROSS = 128};\nint cRel(C c1, C c2) {\n  D d = abs(c1.c - c2.c);\n  if (near(c1.c, c2.c) && !sig(c1.r, c2.r)) return SAME;\n  if (sig(d, c1.r - c2.r) < 0) return OVER;\n  if (sig(d, c2.r - c1.r) < 0) return CONTAIN;\n  if (!sig(d, c1.r - c2.r)) return ONE_OVER_CROSS;\n  if (!sig(d, c2.r - c1.r)) return ONE_CONTAIN_CROSS;\n  if (!sig(d, c1.r + c2.r)) return ONE_CROSS;\n  if (sig(d, c1.r + c2.r) > 0) return NO_CROSS;\n  return TWO_CROSS;\n}\n\n// 交差判定\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCS(C c, L s) {return sig(c.r, dSP(s, c.c)) >= 0;}\nbool iCC(C a, C b) {return sig(abs(a.c - b.c), a.r + b.r) <= 0;}\n\n// 交点\npair<P, P> pCC(C a, C b) {\n  D x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  P e = (b.c - a.c) / abs(b.c - a.c);\n  P y = e * P(0, sr(a.r * a.r - x * x));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\npair<P, P> pCL(C c, L l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\n// 角の内外判定 角abの内部にあれば正、辺上は0、外部は負\nint sAP(P a, P b, P c) {return sig(det(a, c)) - sig(det(b, c)) - sig(det(a, b));}\n\n// 線分をマージする\nvector<L> merge(vector<L> s) {\n  rep (i, s.size()) if (s[i].b < s[i].a) swap(s[i].a, s[i].b);\n  sort(s.begin(), s.end());\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j]) && !iLLs(s[i], s[j])) {\n    s[j].b = max(s[i].b, s[j].b);\n    s.erase(s.begin() + i--);\n    break;\n  }\n  return s;\n}\n\n// 最終防衛問題用秘密兵器\n// 同一の円はまとめておくこと\nvector<vector<int> > scArr(vector<L> s, vector<C> c, vector<P> &vp) {\n  s = merge(s);\n  rep (i, s.size()) {\n    vp.push_back(s[i].a);\n    vp.push_back(s[i].b);\n  }\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) vp.push_back(pLL(s[i], s[j]));\n  rep (i, c.size()) rep (j, s.size()) if (iCS(c[i], s[j])) {\n    pair<P, P> cs = pCL(c[i], s[j]);\n    if (ccw(s[j].a, s[j].b, cs.first) == ON) vp.push_back(cs.first);\n    if (ccw(s[j].a, s[j].b, cs.second) == ON) vp.push_back(cs.second);\n  }\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end(), near), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i].a, s[i].b, vp[j]) == ON) v.push_back(make_pair(norm(vp[j] - s[i].a), j));\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return g;\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<C> vc(n);\n    rep (i, n) cin >> vc[i].c.X >> vc[i].c.Y >> vc[i].r;\n    vector<L> vl;\n    vector<P> vp;\n    vp.push_back(vc[0].c);\n    vp.push_back(vc[n - 1].c);\n    rep (i, n - 1) {\n      pair<P, P> pp = pCC(vc[i], vc[i + 1]);\n      vp.push_back(pp.first);\n      vp.push_back(pp.second);\n    }\n    rep (i, vp.size()) rep (j, i) vl.push_back((L){vp[i], vp[j]});\n    vp.clear();\n    vector<vector<int> > g = scArr(vl, vc, vp);\n    int si = -1, gi = -1;\n    rep (i, vp.size()) if (near(vp[i], vc[0].c)) si = i;\n    rep (i, vp.size()) if (near(vp[i], vc[n - 1].c)) gi = i;\n    priority_queue<pair<D, int>, vector<pair<D, int> >, greater<pair<D, int> > > que;\n    que.push(make_pair(0, si));\n    D dis[vp.size()];\n    rep (i, vp.size()) dis[i] = 1e100;\n    while (!que.empty()) {\n      pair<D, int> now = que.top();\n      que.pop();\n      if (sig(dis[now.second], now.first) <= 0) continue;\n      dis[now.second] = now.first;\n      if (now.second == gi) break;\n      rep (i, g[now.second].size()) {\n\tif (sig(dis[g[now.second][i]], now.first + abs(vp[now.second] - vp[g[now.second][i]])) <= 0) continue; \n\tP mid = (vp[now.second] + vp[g[now.second][i]]) / (D)2;\n\trep (j, vc.size()) if (iCP(vc[j], mid)) goto next;\n\tcontinue;\n      next:;\n\tque.push(make_pair(now.first + abs(vp[now.second] - vp[g[now.second][i]]), g[now.second][i]));\n      }\n    }\n    printf(\"%.12lf\\n\", dis[gi]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\ndouble arg(Vector p){ return atan2(p.y,p.x);}\nVector polar(double a,double r){ return Point(cos(r)*a,sin(r)*a);}\n\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return mp(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint main()\n{\n  int n;\n  Point p[150][2];\n  double dp[150][2];\n  Circle C[101];\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    for(int i=0;i<n;i++)cin>>C[i].c.x>>C[i].c.y>>C[i].r;\n    for(int i=0;i<150;i++){\n      dp[i][0]=inf;\n      dp[i][1]=inf;\n    }\n\n    p[0][0]=C[0].c; // ?§????\n    p[0][1]=C[0].c;\n\n    //  ????????????????????????\n    for(int i=1;i<n;i++){\n      pair<Point,Point> pp=getCrossPoints(C[i-1],C[i]);\n      p[i][0]=pp.f;\n      p[i][1]=pp.s;\n    }\n    p[n][0]=C[n-1].c; // ??????\n    p[n][1]=Point(inf,inf);\n\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++){\n      for(int j=0;j<2;j++){\n\tfor(int k=i-1;k>=0;k--){\n\t  for(int l=0;l<2;l++){\n\t    bool flag=true;\n\t    Segment S=Segment(p[i][j],p[k][l]);\n\t      for(int c=k+1;c<i;c++){\n\t\tif(!intersect(Segment(p[c][0],p[c][1]),S))flag=false;\n\t      }\n\t    if(flag){\n\t      dp[i][j]=min(dp[i][j],dp[k][l]+abs(S.p1-S.p2));\n\t    }\n\t  }\n\t}\n      }\n    }\n    printf(\"%.10f\\n\",dp[n][0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b-a) + EPS < abs(c-a) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(abs(a.first-b.first) < EPS ||\n     abs(a.first-b.second) < EPS ||\n     abs(a.second-b.first) < EPS ||\n     abs(a.second-b.second) < EPS) return true;\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\nP n_vector(P a){\n  //a????????????????????´?????????????????????\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nL cpcc(C a, C b){\n  //?????¨????????????\n  double d = abs(a.first-b.first), ra = a.second, rb = b.second;\n  double t = (ra*ra-rb*rb+d*d)/2/d, h = sqrt(ra*ra-t*t);\n  P m = t/abs(b.first-a.first)*(b.first-a.first)+a.first;\n  L cp;\n  P n = n_vector(a.first-b.first);\n  cp = L(m-n*h, m+n*h);\n  return cp;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x, y, r;\n    vector<C> Cs;\n    vector<L> cps;\n    vector<P> points;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y >> r;\n      Cs.push_back(make_pair(P(x,y),r));\n    }\n    points.push_back(Cs[0].first);\n    for(int i = 1; i < n; ++i){\n      L cp = cpcc(Cs[i],Cs[i-1]);\n      cps.push_back(cp);\n      points.push_back(cp.first);\n      points.push_back(cp.second);\n    }\n    points.push_back(Cs[n-1].first);\n    vector< vector<double> > dist(2*n,vector<double>(2*n,INF));\n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i; j < 2*n; ++j){\n\tif(i == j){\n\t  dist[i][j] = 0;\n\t  continue;\n\t}\n\tint s = min(max(0,i-1)/2,n-2), e = min(max(0,j-1)/2,n-2);\n\t//int s = (i-1)/2, e = (j-1)/2;\n\tbool f = true;\n\tfor(int k = s; k <= e; ++k){\n\t  if(!is_cross(L(points[i],points[j]), cps[k])){\n\t    //cout << points[i] << points[j] << cps[k].first << cps[k].second << endl;\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\tif(f){\n\t  dist[i][j] = abs(points[i]-points[j]);\n\t  dist[j][i] = abs(points[i]-points[j]);\n\t}\n      }\n    }\n    /*\n    for(int i = 0; i < 2*n; ++i)\n      for(int j = 0; j < 2*n; ++j)\n\tcout << dist[i][j] << endl;\n    */\n    \n\n    for(int k = 0; k < 2*n; ++k)\n      for(int i = 0; i < 2*n; ++i)\n\tfor(int j = 0; j < 2*n; ++j)\n\t  dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\n    printf(\"%.10f\\n\", dist[0][2*n-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n// 以下 幾何部分\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair <P,P> L;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // 楕円も追加予定\ntypedef vector <P>Pol;\n\n// ソートのキー\nB cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\nB cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\nB cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// 基本操作\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// 点\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base 中心\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\nint ccw(P base, P a, P b) {              //点aと点bが与えられた問いに\n  a -= base; b -= base;\n  if (ep(a, b) > 0)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < 0)      return RIGHT;   // clockwise\n  if (ip(a, b) < 0)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;     // base--b--a on line  aとbの線分判定はこれ\n}\n\n\n\n// 線分 直線\n\t// 点と直線の距離\n\t// 点と線分の距離\n\t// 直線と直線の距離\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// 交点\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// 点と直線と線分関連の交差判定\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// 点と直線と線分関連の距離\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n\n// 円\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\nPol pCC(C a,C b){\n\tPol res;\n\tint rel=rCC(a,b);\n\tif(rel==(A_ON_B|B_ON_A)){\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&(A_ON_B|B_ON_A|ON_OUT)){\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\nD cost[210][210];\nC cir[110];\nL lines[110];\nP points[210];\nint n,m;\n\nint convert(int i){\n\tif(i==0)\n\t\treturn -1;\n\telse if(i==m-1)\n\t\treturn n-1;\n\telse\n\t\treturn (i-1)/2;\n}\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,210)rep(j,210) cost[i][j]=((i==j)?0:inf);\n\n\t\trep(i,n){\n\t\t\tint x,y,r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tcir[i].c=P(x,y);\n\t\t\tcir[i].r=r;\n\t\t}\n\n\t\tm=2*n;\n\n\t\tpoints[0]=cir[0].c;\n\t\trep(i,n-1){\n\t\t\tPol res=pCC(cir[i],cir[i+1]);\n\t\t\tpoints[2*i+1]=res[0];\n\t\t\tpoints[2*i+2]=res[1];\n\t\t\tlines[i]=L(res[0],res[1]);\n\t\t}\n\t\tpoints[m-1]=cir[n-1].c;\n\n\t\t\n\t\trep(j,m)rep(i,j){\n\t\t\tint f=convert(i);\n\t\t\tint t=convert(j);\n\t\t\tL tar=L(points[i],points[j]);\n\n\t\t\tbool ok=true;\n\t\t\t\n\t\t\tfor(int k=f+1;k<t;k++){\n\t\t\t\tif(!iSS(tar,lines[k]))\n\t\t\t\t\tok=false;\n\t\t\t}\n\t\t\tif(ok) cost[i][j]=cost[j][i]=abs(points[i]-points[j]);\n\t\t}\n\t\trep(k,m)rep(i,m)rep(j,m) cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\n\t\tcout.precision(9);\n\t\tcout << fixed << cost[0][m-1] << endl;\n\n\t\t/*dump(points[m-1])\n\t\trep(i,m){\n\t\t\trep(j,m) cout << cost[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\tdump( iSS( L(points[3],points[4]),L(points[3],points[5]) ) )\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\n\nconst double EPS=1e-8,INF=1e12;\ntypedef complex<double> P;\ntypedef P point;\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);}\n}\ndouble cross(const P &a,const P &b){\n  return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n  return real(conj(a)*b);\n}\n\nstruct L :public vector<P>{\n  L(const P &a,const P &b){\n    pb(a); pb(b);\n  }\n};\n\ntypedef pair<point,point> ppp;\n\nint ccw(P a,P b,P c){\n  b-=a; c-=a;\n  if(cross(b,c)>EPS) return 1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c)<-EPS) return +2;\n  if(norm(b)+EPS<norm(c)) return -2;\n  return 0;\n}\n\nppp c_c_inter(const point &c1,const double &r1,\n\t      const point &c2,const double &r2){\n  point A=conj(c2-c1), B=(r2*r2-r1*r1-(c2-c1)*conj(c2-c1)),C=r1*r1*(c2-c1);\n  point D=B*B-4.*A*C;\n  point z1=(-B+sqrt(D))/(2.0*A)+c1, z2=(-B-sqrt(D))/(2.0*A)+c1;\n  return ppp(z1,z2);\n}\n\nbool interLS(const L &l,const L s){\n  return cross(l[1]-l[0], s[0]-l[0])*\n    cross(l[1]-l[0],s[1]-l[0])<EPS;\n}\n\ndouble len(const L &l){\n  return abs(l[0]-l[1]);\n}\ndouble d[212][212];\n\nint main(){\n  cout<<fixed<<setprecision(10);\n  int n;\n  while(cin>>n,n){\n    vector<P> c(n);\n    vector<double> r(n);\n    double x,y;\n    rep(i,n){\n      cin>>x>>y>>r[i];\n      c[i]=P(x,y);\n    }\n    vector<ppp> ps(n-1);\n    rep(i,n-1)\n      ps[i]=c_c_inter(c[i],r[i],c[i+1],r[i+1]);\n\n    fill(d[0],d[0]+112*112,INF);\n    rep(i,n-1){\n      L lx(c[0],ps[i].X),ly(c[0],ps[i].Y);\n      int fx=1,fy=1;\n      rep(j,i){\n\tfx&=interLS(lx,L(ps[j].X,ps[j].Y));\n\tfy&=interLS(ly,L(ps[j].X,ps[j].Y));\n      }\n      if(fx)d[2*n-2][2*i]=d[2*i][2*n-2]=len(lx);\n      if(fy)d[2*n-2][2*i+1]=d[2*i+1][2*n-2]=len(ly);\n    }\n    rep(i,n-1){\n      L lx(c[n-1],ps[i].X),ly(c[n-1],ps[i].Y);\n      int fx=1,fy=1;\n      for(int j=i;j<n-1;++j){\n\tfx&=interLS(lx,L(ps[j].X,ps[j].Y));\n\tfy&=interLS(ly,L(ps[j].X,ps[j].Y));\n      }\n      if(fx)d[2*n-1][2*i]=d[2*i][2*n-1]=len(lx);\n      if(fy)d[2*n-1][2*i+1]=d[2*i+1][2*n-1]=len(ly);\n    }\n    L l(c[0],c[n-1]);\n    int f=1;\n    rep(i,n-1)\n      f&=interLS(l,L(ps[i].X,ps[i].Y));\n    if(f) d[2*n-1][2*n-2]=d[2*n-2][2*n-1]=len(l);\n    rep(i,n-1)rep(j,i)rep(a,2)rep(b,2){\n      L l(a?ps[i].Y:ps[i].X,b?ps[j].Y:ps[j].X);\n      int f=1;\n      for(int k=j+1;k<i;++k)\n\tf&=interLS(l,L(ps[k].X,ps[k].Y));\n      if(f)\n\td[2*i+a][2*j+b]=d[2*j+b][2*i+a]=len(l);\n    }\n    rep(k,2*n)rep(i,2*n)rep(j,2*n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<d[2*n-1][2*n-2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 110\n#define INF 1e9\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n \nstruct Point{\n    double x,y;\n \n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n    bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n \nPoint operator * (const Point &a,const Point &b){ return Point(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); }\n \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\ndouble getDistance(const Point &a,const Point &b){\n    return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n \ntypedef Point Vector;\n \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n \nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n    if(cross(a,b) < -EPS){ return CLOCKWISE; }\n    if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n    if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n    return ON_SEGMENT;\n}\n \nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n \nstruct Circle{\n    Point p;\n    double r;\n    Circle(){}\n    Circle(Point p,double r) : p(p),r(r) {}\n};\n \nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n \nvector<Point> crosspointCC(const Circle &a,const Circle &b){\n    vector<Point> res;\n    double d = abs(a.p-b.p);\n    double rc = (a.r*a.r-b.r*b.r+d*d)/(2.0*d);\n    double rs = sqrt(a.r*a.r-rc*rc);\n    Point p = (b.p-a.p)/d;\n    res.push_back(Point(a.p+p*Point(rc,-rs)));\n    res.push_back(Point(a.p+p*Point(rc,rs)));\n    return res;\n}\n \nstruct P{\n    double d;\n    int n,p;\n    P(double d,int n,int p) : d(d),n(n),p(p) {}\n    bool operator < (const P &p)const{\n\tif(d != p.d){\n\t    return d > p.d;\n\t}\n    }\n};\n \ndouble dist[MAX_N][2][MAX_N][2];\n \ndouble solve(int N){\n    double d[MAX_N][2];\n    fill(d[0],d[0]+MAX_N*2,INF);\n    d[0][0] = 0.0;\n \n    priority_queue<P> Q;\n    Q.push(P(0,0,0));\n \n    while(!Q.empty()){\n\tP p = Q.top(); Q.pop();\n\tint idx = p.n,pos = p.p;\n\tif(lt(d[idx][pos],p.d)){ continue; }\n\tif(idx == N){ return p.d; }\n\tfor(int i = idx+1 ; i <= N ; i++){\n\t    for(int j = 0 ; j < 2 ; j++){\n\t\tif(dist[idx][pos][i][j] == INF){ continue; }\n\t\tif(p.d+dist[idx][pos][i][j] < d[i][j]){\n\t\t    d[i][j] = p.d+dist[idx][pos][i][j];\n\t\t    Q.push(P(d[i][j],i,j));\n\t\t}\n\t    }\n\t}\n    }\n    return -1;\n}\n \nvoid init(int N){\n    for(int i = 0 ; i < N ; i++){\n\tfor(int j = 0 ; j < 2 ; j++){\n\t    for(int k = 0 ; k <= N ; k++){\n\t\tfor(int l = 0 ; l < 2 ; l++){\n\t\t    dist[i][j][k][l] = INF;\n\t\t}\n\t    }\n\t}\n    }\n}\n \nint main(){\n    int N;\n    while(cin >> N,N){\n\tvector<Point> G[MAX_N];\n\tvector<Circle> cirs(N);\n\tinit(N);\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> cirs[i].p >> cirs[i].r;\n\t    if(i == 0){\n\t\tG[i].push_back(cirs[0].p);\n\t\tG[i].push_back(cirs[0].p);\n\t    }else{\n\t\tvector<Point> cp = crosspointCC(cirs[i-1],cirs[i]);\n\t\tG[i].push_back(cp[0]); G[i].push_back(cp[1]);\n\t    }\n\t}\n\tG[N].push_back(cirs[N-1].p);\n\tG[N].push_back(cirs[N-1].p);\n \n\tfor(int i = 0 ; i < N ; i++){\n\t    for(int j = i+1 ; j <= N ; j++){\n\t\tPoint p1[2] = {G[i][0],G[i][1]};\n\t\tPoint p2[2] = {G[j][0],G[j][1]};\n\t\tfor(int k = 0 ; k < 2 ; k++){\n\t\t    for(int l = 0 ; l < 2 ; l++){\n\t\t\tSegment a = Segment(p1[k],p2[l]);\n\t\t\tbool ok = true;\n\t\t\tfor(int m = i ; m < j ; m++){\n\t\t\t    Segment b = Segment(G[m][0],G[m][1]);\n\t\t\t    if(!isIntersectSS(a,b)){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t    dist[i][k][j][l] = getDistance(p1[k],p2[l]);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tprintf(\"%.8f\\n\",solve(N));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\n\ntypedef long double R;\ntypedef complex<R> P;\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos(-1);\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (a > b) swap(a, b);\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\nstruct C {\n    P p;\n    R r;\n    C () {};\n    C (P p, R r) : p(p), r(r) {};\n};\n\nint crossSC(const L&l, const C &c) {\n    R mi = distSP(l, c.p);\n    if (sgn(c.r, mi) == 1) return 0;\n    if (sgn(c.r, mi) == 0) return 1;\n    int u = 0;\n    if (sgn(c.r, abs(l.x-c.p)) != -1) u++;\n    if (sgn(c.r, abs(l.y-c.p)) != -1) u++;\n    return u;\n}\n\n\n//return number of cross point\nint crossP(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) return -1;\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\nbool insLS(const L &l, const L &s) {\n    int a = ccw(l.x, l.y, s.x);\n    int b = ccw(l.x, l.y, s.y);\n    if (a == 1 && b == 1) return false;\n    if (a == -1 && b == -1) return false;\n    return true;\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\n/*\nexec??§res??????????????¢?????\\???\n*/\ntemplate<int V>\nstruct Dijkstra {\n    using T = R;\n    using P = pair<T, int>;\n    const R INF = 1e9;\n    vector<P> g[V];\n    void add(int from, int to, T dist) {\n        g[from].push_back(P(dist, to));\n    }\n    T res[V];\n    void exec(int s) {\n        fill_n(res, V, INF);\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push(P(0, s));\n        res[s] = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            if (res[p.second] < p.first) continue;\n            for (P e: g[p.second]) {\n                if (p.first+e.first < res[e.second]) {\n                    res[e.second] = p.first+e.first;\n                    q.push(P(e.first+p.first, e.second));\n                }\n            }\n        }\n        return;\n    }\n};\n\n\n\nconst int MN = 110;\nint n;\nC c[MN];\nL l[MN];\n\nbool calc(L ll, int i, int j) {\n    for (int k = i+1; k < j; k++) {\n        if (!insSS(ll, l[k])) return false;\n    }\n    return true;\n}\nR solve() {\n    l[0] = L(c[0].p, c[0].p);\n    for (int i = 1; i < n; i++) {\n        crossP(c[i-1], c[i], l[i]);\n    }\n    l[n] = L(c[n-1].p, c[n-1].p);\n    n++;\n    Dijkstra<MN*2> djk;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (calc(L(l[i].x, l[j].x), i, j)) {\n                djk.add(i*2, j*2, abs(l[i].x-l[j].x));\n            }\n            if (calc(L(l[i].x, l[j].y), i, j)) {\n                djk.add(i*2, j*2+1, abs(l[i].x-l[j].y));\n            }\n            if (calc(L(l[i].y, l[j].x), i, j)) {\n                djk.add(i*2+1, j*2, abs(l[i].y-l[j].x));\n            }\n            if (calc(L(l[i].y, l[j].y), i, j)) {\n                djk.add(i*2+1, j*2+1, abs(l[i].y-l[j].y));\n            }\n        }\n    }\n    djk.exec(0);\n    return djk.res[2*n-1];\n}\n\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, r;\n            cin >> x >> y >> r;\n            c[i] = C(P(x, y), r);\n        }\n        printf(\"%.20Lf\\n\", (long double)solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair< complex<double> , complex<double> > pp;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint n;\nint x[200],y[200],r[200];\n\nP ver[1000][2];\n\npp get_2cross_point_of_2circle(double x1,double y1,double r1,double x2,double y2,double r2){\n    P c1(x1,y1),c2(x2,y2);\n    double a =abs(c2 - c1);\n    double b = r1;\n    double c = r2;\n\n    double rc = (a * a + b * b - c * c) / (2.0 * a);\n    double rs = sqrt(b * b - rc * rc);\n    P diff = (c2 - c1) / a;\n\n    pp p;\n    p.first = c1 + diff * rc + (diff * P(0,1) * rs);\n    p.second = c1 + diff * rc + (diff * P(0,-1) * rs);\n\n    return p;\n}\n\nbool judge(P a1,P a2,P b1,P b2){\n    P a = a2 - a1;\n    P c1 = b1 - a1;\n    P c2 = b2 - a1;\n    return (a.real() * c1.imag() - a.imag() * c1.real()) * (a.real() * c2.imag() - a.imag() * c2.real()) <= 0.0;\n}\n\nbool judgecross(P a,P b,int a1,int b1){\n    FOR(i,a1+1,b1)\n        if(!judge(a,b,ver[i][0],ver[i][1]))\n            return false;\n    return true;\n}\n\nbool input(){\n    scanf(\"%d\",&n);\n    if(n == 0)\n        return false;\n    REP(i,n){\n        scanf(\"%d%d%d\",&x[i],&y[i],&r[i]);\n    }\n    return true;\n}\n\ndouble G[1000][1000];\nvoid solve(){\n\n    REP(i,1000)\n        REP(j,1000)\n            G[i][j] = 1000000000.0;\n    REP(i,1000)\n        G[i][i] = 0.0;\n\n    REP(i,n-1){\n        pp p = get_2cross_point_of_2circle(x[i],y[i],r[i],x[i + 1],y[i + 1],r[i + 1]);\n        ver[i][0] = p.first;\n        ver[i][1] = p.second;\n    }\n    REP(i,(n - 1) * 2){\n        FOR(j,i + 1,(n - 1) * 2){\n            int i1 = i / 2;int i2 = i % 2;\n            int j1 = j / 2;int j2 = j % 2;\n            if(!judgecross(ver[i1][i2],ver[j1][j2],i1,j1))\n                continue;\n            G[i][j] = G[j][i] = abs(ver[i1][i2] - ver[j1][j2]);\n        }\n    }\n    P start(x[0],y[0]);\n    REP(i,(n - 1) * 2){\n        int i1 = i / 2;int i2 = i % 2;\n        if(!judgecross(start,ver[i1][i2],-1,i1))\n            continue;\n        G[i][n * 2 - 2]  = G[n * 2 - 2][i] = abs(start - ver[i1][i2]);\n    }\n    P end(x[n-1],y[n-1]);\n    REP(i,(n - 1) * 2){\n        int i1 = i / 2;int i2 = i % 2;\n        if(!judgecross(ver[i1][i2],end,i1,n-1))\n            continue;\n        G[i][n * 2 - 1] = G[n * 2 - 1][i] = abs(end - ver[i1][i2]);\n    }\n    if(judgecross(start,end,-1,n-1))\n        G[n * 2 - 1][n * 2 - 2] = G[n * 2 - 2][n * 2 - 1] = abs(start - end);\n\n    REP(k,n*2){\n        REP(i,n*2){\n            REP(j,n*2){\n                G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n            }\n        }\n    }\n    printf(\"%lf\\n\",G[n*2-2][n*2-1]);\n}\n\n\n\nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n     \n    Point operator * (Point p){\n        return Point(p.x*x-p.y*y,p.x*y+p.y*x);\n    }\n\n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n    \n    Point operator = (Point p){\n        x = p.x;\n        y = p.y;\n        return *this;\n    }\n\n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n    //?????????????????§?????????2???\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n    //?????????????????§??????\n    return sqrt(norm(p));\n}\nPoint UnitVector(Point a){\n    //??????????????????\n    return a/pabs(a);\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //?????????\n    double r; //??????\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a???b ??§???????¨?????????????c ccw\n    if(cross(b,c) < 0)return -1; //a???b ??§????¨?????????????c ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\n\nPoint projection(Line l, Point p){\n    double t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + (l[0]-l[1])*t;\n}\n\nPoint reflection(Line l, Point p){\n    return p + (projection(l,p)-p)*2.0; \n}\n\nbool intersectSS(Line l,Line m){\n    //l??¨m??????????????????????????????\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<EPS)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<EPS);\n}\n\nbool intersectSP(Line l, Point p){\n    //??????l??¨???p?????????????????????\n    return !ccw(l[0],l[1],p);\n}\n\ndouble distanceLP(Line l,Point p){\n    //??????l??¨???p????????¢\n    p = p - l[0];\n    l[1] = l[1] - l[0];\n    if(intersectSP(l,p))return 0.0;\n    return fabs(cross(p,l[1])/pabs(l[1]));\n}\n\nbool intersectLL(Line l,Line m){\n    return fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //????????§??????\n            fabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //????????????\n}\n\nbool intersectCP(Circle c,Point p){\n    //???c??¨???p???????????????\n    //true->???c????????¨??????p????????¨????????????.\n    return fabs(pabs(p-c.p)-c.r)<EPS;\n}\n\nint intersectCL(Circle c,Line l,Point *p,Point *q){\n    if(norm(projection(l,c.p) - c.p) - c.r*c.r > EPS)return 0;\n    double d1 = pabs(c.p-l[0]);\n    double d2 = pabs(c.p-l[1]);\n    if(d1 < c.r + EPS && d2 < c.r + EPS)return 0;\n    if(d1 < c.r - EPS && d2 > c.r+EPS\n        || d1 > c.r + EPS && d2 < c.r -EPS)return 1;\n    Point h = projection(l,c.p);\n    if(dot(l[0] - h,l[1] - h) < 0)return 2;\n    return 0;\n}\n\nint intersectCC(Circle a,Circle b,Point *p,Point *q){\n    double dist = pabs(a.p-b.p);\n    if(dist < fabs(a.r-b.r) || dist > a.r+b.r){\n        //????????????????????´??????????????¨???\n        //????????????????????¨???????????¨???\n        *p = Point(1e15,1e15);\n        *q = Point(1e15,1e15);\n        return 0;\n    }\n    else if(fabs(dist-a.r-b.r) < EPS){\n        //??????1?????§????????£???????????¨???\n        Point way;\n        way = b.p-a.p;\n        *p = a.p+UnitVector(way)*a.r;\n        *q = *p;\n        return 1;\n    }\n    else{\n        //??????2?????§????????£???????????¨???\n        if(a.r < b.r){\n            swap(a.r,b.r);\n            swap(a.p,b.p);\n        }\n        double s = (a.r + b.r + dist) / 2.0 ;\n        double area = sqrt(s * (s - a.r) * (s - b.r) * (s - dist));\n        double h = 2.0 * area / dist;\n\n        Point  v = b.p-a.p;\n        v = UnitVector(v);\n        Point  m = a.p + (v*sqrt(a.r*a.r-h*h));\n        Point  n = v * Point(0.0,1.0);\n        \n        *p = m + (n * h);\n        *q = m - (n * h);\n        return 2;\n    }\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5; //?????????????????¨??????????????§??¨???\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea; //?????????????????¨??????????????§??¨???\n}\n\nPoint crosspoint(Line l,Line m){\n    //??????l??¨??????m?????????\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nPolygon ConvexHull(Polygon v){\n    //??????????????????\n    int n = v.size();\n    int k = 0;\n    sort(v.begin(),v.end());\n    Polygon e(2*n);\n    for(int i=0;i<n;e[k++]=v[i++])\n        while(k>=2&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n    for(int i=n-2,t=k+1;i>=0;e[k++]=v[i--])\n        while(k>=t&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n    e.resize(k-1);\n    return e;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to,double _cost){\n        to = _to;\n        cost = _cost;\n    }\n    bool operator < (const edge &a)const{\n        return a.cost<cost;\n    }\n};\ntypedef pair<Point,int> P;\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        Circle C[128];\n        vector < pair < Point , int >  > points;\n        Point start,goal;\n        rep(i,N){\n            double x,y,r;\n            scanf(\"%lf%lf%lf\",&x,&y,&r);\n            if(i == 0){\n                start = Point(x,y);\n            }\n            if(i == N-1){\n                goal = Point(x,y);\n            }\n            C[i] = Circle(Point(x,y),r);\n        }\n        vector < Line > arc;\n        points.PB(P(start,0));\n        rep(i,N){\n            reps(j,i+1,N){\n                Point p,q;\n                int tmp = intersectCC(C[i],C[j],&p,&q);\n                if(tmp > 0){\n                    points.PB(P(p,j));\n                    points.PB(P(q,j));\n                    Line l;\n                    l.PB(p);l.PB(q);\n                    arc.PB(l);\n         //         cout << p.x << \" \" << p.y << \"\\n\";\n         //         cout << q.x << \" \" << q.y << \"\\n\";\n                }\n            }\n        }\n       // puts(\"$$$$$$$$$$$$$$$$$$$$$$\");\n        points.PB(P(goal,N-1));\n        int goal_ID = points.size()-1;\n\n        vector< edge > G[128];\n        rep(i,points.size()){\n            reps(j,i+1,points.size()){\n                double dist = pabs(points[i].fi-points[j].fi);\n                Line l;\n                l.PB(points[i].fi);\n                l.PB(points[j].fi);\n                int cnt = 0;\n                Point p,q;\n                bool flg = true;\n        //        cout << \"&\" <<points[i].se+1 << \" \" << points[j].se << \"\\n\";\n                for(int k = points[i].se+1; k < points[j].se+1; k++){\n                    bool a = true;\n                    a = intersectSS(l,arc[k-1]);\n                    //cout << a << \"\\n\";\n                    if(!a){\n                        flg = false;\n                    }\n                }\n                if(!flg)continue;\n                G[i].PB(edge(j,dist));\n                G[j].PB(edge(i,dist));\n            //    cout << i << \" \" << j << \" \" << dist << \" \"<< flg <<\"\\n\";\n            }\n        }\n\n        double d[128];\n        fill(d,d+128,INF);\n        priority_queue < edge > Q;\n        Q.push(edge(0,0.0));\n\n        while(!Q.empty()){\n            edge e = Q.top();Q.pop();\n            if(d[e.to] != INF)continue;\n            d[e.to] = e.cost;\n            rep(i,G[e.to].size()){\n                Q.push(edge(G[e.to][i].to,G[e.to][i].cost+d[e.to]));\n            }\n        }\n\n        printf(\"%.10lf\\n\",d[goal_ID]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nusing R = long double;\nusing P = complex<R>;\nusing L = pair<P,P>;\nstruct C {\n    P c; R r;\n    C() {}\n    C(const P &a, const R &b) : c(a), r(b) {}\n};\nstruct S : public L {\n    S() {}\n    S(const P &a, const P &b) : L(a,b) {}\n};\n\nconst R EPS = 1e-8;\nconst R PI = atan(1)*4;\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\ninline R dot(const P& a, const P& b) {\n    return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n    return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\n\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON_SEG=16};\nint ccw(P a, P b, P c) {\n    P p = (c-a)/(b-a);\n    if(sgn(imag(p)) > 0) return LEFT;\n    if(sgn(imag(p)) < 0) return RIGHT;\n    if(sgn(real(p)) < 0) return BACK;\n    if(sgn(real(p)-1) > 0) return FRONT;\n    return ON_SEG;\n}\n\ninline bool intersect(const S& s1, const S& s2) {\n    int ccw1 = ccw(s1.first, s1.second, s2.first) | ccw(s1.first, s1.second, s2.second);\n    int ccw2 = ccw(s2.first, s2.second, s1.first) | ccw(s2.first, s2.second, s1.second);\n    return (ccw1 & ccw2) == (LEFT | RIGHT) || ((ccw1 | ccw2) & ON_SEG);\n}\n\nvector<P> crosspoint(C a, C b) {\n    R d = abs(a.c-b.c);\n    R t = (a.r*a.r-b.r*b.r+d*d)/2/d, h = sqrt(a.r*a.r-t*t);\n    P m = t/abs(b.c-a.c)*(b.c-a.c)+a.c;\n    auto n_vector = [&](P p) -> P { return P(-p.imag(), p.real())/abs(p); };\n    P n = n_vector(a.c-b.c);\n    vector<P> ret(2, m);\n    ret[0] -= h*n; ret[1] += h*n;\n    return ret;\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(1) {\n        ll n;\n        cin >> n;\n        if(!n) break;\n        vector<C> vc(n);\n        REP(i, n) {\n            R x, y, r;\n            cin >> x >> y >> r;\n            vc[i] = C(P(x, y), r);\n        }\n\n        vector<vector<P>> vp(n+1, vector<P>(2));\n        vp[0][0] = vp[0][1] = vc[0].c;\n        vp[n][0] = vp[n][1] = vc[n-1].c;\n        FOR(i, 1, n) vp[i] = crosspoint(vc[i-1], vc[i]);\n\n        auto ok = [&](PII from, PII to) {\n            S s1(vp[from.first][from.second], vp[to.first][to.second]);\n            FOR(i, from.first+1, to.first) {\n                S s2(vp[i][0], vp[i][1]);\n                if(!intersect(s1, s2)) return false;\n            }\n            return true;\n        };\n\n        vector<vector<R>> dp(n+1, vector<R>(2, LLINF));\n        dp[0][0] = dp[0][1] = 0;\n        REP(i, n) REP(j, 2) FOR(k, i+1, n+1) REP(l, 2) {\n            if(ok({i,j},{k,l})) {\n                chmin(dp[k][l], dp[i][j] + abs(vp[i][j]-vp[k][l]));\n            }\n        }\n        cout << fixed << setprecision(15) << dp[n][0] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define double long double\nusing namespace std;\ntypedef complex<double> Point;\ntypedef vector<Point> Points;\n\nint n;\nPoint c[100]; double r[100];\n\ndouble dot(Point a, Point b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Point a, Point b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\n//a->b->cの曲がる方向。反時計回り, 180°折り返しは正.\nconst double EPS = 1e-10;\t\t//大体, 座標範囲^2 / 10^(-16)くらいにしておくと無難？\n//それぞれの条件を厳しめにしておくと, 線分交差判定はちょっと緩めにYesを返すようになったりして吉.\nint ccw(Point a, Point b, Point c) {\n\tb -= a;\n\tc -= a;\n\t\n\tif (cross(b, c) > EPS) return +1;\n\tif (cross(b, c) < -EPS) return -1;\n\tif (dot(b, c) < -EPS) return +2;\t\t//c--b--a\n\tif (norm(b) < norm(c) - EPS) return -2;\t//a--b--c\n\treturn 0;\n}\n\n//線分の交差判定. ギリギリ重ならない場合も重なると判定しておく.\nbool intersect_SS(Point a, Point b, Point c, Point d) {\n\treturn ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0;\n}\n\n//円と直線の交点. 相異なる2点が交点になると仮定.\nvector<Point> kouten_CL(Point c, double r, Point s, Point e) {\n\ts -= c;\n\te -= c;\n\t\n\tdouble dt = dot(s, e - s);\n\tdouble nm = norm(e - s);\n\tdouble D = sqrt(dt * dt - nm * (norm(s) - r * r));\n\tdouble alpha1 = (-dt - D) / nm;\n\tdouble alpha2 = (-dt + D) / nm;\n\t\n\tPoint res1 = s + alpha1 * (e - s);\n\tPoint res2 = s + alpha2 * (e - s);\n\tvector<Point> ret;\n\tret.push_back(res1 + c);\n\tret.push_back(res2 + c);\n\treturn ret;\n}\n\n//円と円の交点. 相異なる2点が交点になると仮定.\nvector<Point> kouten_CC(Point c1, double r1, Point c2, double r2) {\n\tPoint r = c2 - c1;\n\tdouble theta = acos((norm(r) + r1 * r1 - r2 * r2) / (2 * r1 * abs(r)));\n\tPoint R = (r1 / abs(r)) * r;\n\tPoint res1 = R * exp(Point(0, 1) * theta);\n\tPoint res2 = R * exp(Point(0, 1) * (-theta));\n\tvector<Point> ret;\n\tret.push_back(res1 + c1);\n\tret.push_back(res2 + c1);\n\treturn ret;\n}\n\nint toId(int i) {\t//点solve.ps[i]が何番(>=0)の円に乗ってるか\n\tif (i == 0) return 0;\n\tif (i == 2 * n - 1) return n - 1;\n\treturn (i - 1) / 2 + 1;\n}\n\nbool can_connect(int i, int j, Point s, Point e) {\n\ti = toId(i);\n\tj = toId(j);\n\t\n\tvector<Point> ps;\n\tfor (int k = i; k <= j; k++) {\n\t\tdouble crs = cross(e - s, c[k] - s);\n\t\tif (crs * crs > r[k] * r[k] * norm(e - s)) return false;\n\t\tif (crs * crs == r[k] * r[k] * norm(e - s)) {\n\t\t\tif (k == j) return true;\n\t\t\treturn false;\n\t\t}\n\t\tvector<Point> p = kouten_CL(c[k], r[k], s, e);\n\t\tps.push_back(p[0]);\n\t\tps.push_back(p[1]);\n\t}\n\t\n\tfor (int k = 0; k + 3 < ps.size(); k += 2) {\n\t\t//誤差がなければ…、ギリギリ重なる場合はあって、ギリギリ重ならない場合はたぶん無い\n\t\t//ギリギリ重なる場合、誤差があるとギリギリ重ならないケースになるので、緩めにYes判定する.\n\t\tif (intersect_SS(ps[k], ps[k + 1], ps[k + 2], ps[k + 3]) == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble solve() {\n\tint i, j;\n\tvector<Point> ps;\n\tvector<int> et[200];\n\tvector<double> ec[200];\n\n\tps.push_back(c[0]);\n\trep(i, n - 1) {\n\t\tPoints p = kouten_CC(c[i], r[i], c[i + 1], r[i + 1]);\n\t\tps.push_back(p[0]);\n\t\tps.push_back(p[1]);\n\t}\n\tps.push_back(c[n - 1]);\n\t\n\t/*rep(i, 2 * n) {\n\t\tcout << \"ps[\" << i << \"] = (\" << ps[i].real() << \", \" << ps[i].imag() << \")\" << endl;\n\t}*/\n\t\n\trep(i, 2 * n) {\n\t\tfor (j = i + 1; j < 2 * n; j++) {\n\t\t\tif (can_connect(i, j, ps[i], ps[j])) {\n\t\t\t\tdouble dist = abs(ps[j] - ps[i]);\n\t\t\t\tet[i].push_back(j);\n\t\t\t\tec[i].push_back(dist);\n\t\t\t\t//cout << i << \"->\" << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//DAGなので、ダイクストラは不要\n\tdouble dp[200];\n\tdouble INF = 1145141919;\n\trep(i, 2 * n) dp[i] = INF;\n\tdp[0] = 0;\n\trep(i, 2 * n) {\n\t\trep(j, et[i].size()) {\n\t\t\tint nxt = et[i][j];\n\t\t\tdp[nxt] = min(dp[nxt], dp[i] + ec[i][j]);\n\t\t}\n\t}\n\treturn dp[2 * n - 1];\n}\n\nsigned main() {\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\t\n\t\tint i;\n\t\trep(i, n) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y >> r[i];\n\t\t\tc[i] = Point(x, y);\n\t\t}\n\t\tdouble res = solve();\n\t\tprintf(\"%.14Lf\\n\", res);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\t//for \"greater<type>\"\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//tentative\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n//Don't change because there are many \"x\"s, and \"y\"s in other uses.\n#define X real()\t//for complex\n#define Y imag()\t//for complex\n\ntypedef complex<double> point;//changed\ntypedef point vec;//changed\ntypedef array<point, 2> line;//changed\ntypedef vector<point> poly;//changed\n\nstruct circle {//changed\n\tpoint c;\n\tdouble r;\n};\n\nenum geometry {ABC=-2, CW, ACB, CCW, CAB, ON_LINE, OUTSIDE, INSIDE, ERROR};//Each means collinear(order: a-b-c), clockwise, collinear, counter clockwise,collinear, etc. Remember that ERROR means 2 of the 3 points are duplicate.//changed\n\nnamespace std {\n\tbool operator<(point a, point b) {\n\t\tif (!EQ(a.X, b.X)) return a.X < b.X;\n\t\tif (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n\t\treturn false;\n\t}\n\n\tbool operator>(point a, point b) {\n\t\treturn b<a;\n\t}\n\n\tbool operator<=(point a, point b) {\n\t\treturn !(a>b);\n\t}\n}\n\ndouble dot(point a, point b) {\n\treturn (conj(a)*b).X;\n}\n\ndouble cross(point a, point b) {\n\treturn (conj(a)*b).Y;\n}\n\ngeometry ccw(point a, point b, point c) {//changed\n\ta -= b;\n\tc -= b;\n\tif (cross(a, c) > EPS) return CCW;//counter clockwise\n\tif (cross(a, c) < -EPS) return CW;//clockwise\n\tif (dot(a, c) < -EPS) return ABC;//collinear (order: a - b - c)\n\n\tdouble al = abs(a);\n\tdouble cl = abs(c);\n\t//error: 2 of a, b, and c are duplicate.\n\tif (EQ(al, cl)) return ERROR;//At least a, and c are duplicate.\n\tif (EQ(min(al, cl), 0)) return ERROR;\n\tif (al < cl) return CAB;//collinear (order: c - a - b)\n\telse return ACB;//collinear (order: a - c - b)\n}\n\npoint proj(line l, point p) {\n\tpoint v = l[1]-l[0];\n\tdouble ratio = dot(v, p-l[0]) / norm(v);\n\treturn l[0] + ratio*v;\n}\n\npoint refl(line l, point p) {\n\treturn p + (proj(l, p) - p) * 2.0;\n}\n\nvec rotate(vec v, double r) {\n\treturn v*vec(cos(r), sin(r));\n}\n\n//Get a normal vector (??????????????????).\nvec Normalvec(line l){//changed (added)\n\tvec v=(vec)l[1]-l[0];\n\treturn vec (v.Y,-v.X);\n}\n\nbool IsOrthogonal(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(line l, line m) {\n\tif (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n\tif (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n\treturn false;\n}\n\nbool IntersectLS(line l, line s) {//This outputs true if l includes an endpoint of s.\n\tpoint b = l[0];\n\tvec v = l[1]-l[0];\n\treturn cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(line s, line t) {\n\t// hard coding: CW := -1, CCW := 1 -> Only CW*CW and CCW*CCW are equal to 1\n\tif (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) == 1) return false;\n\tif (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) == 1) return false;\n\tif (!IsParallel(s, t)) return true;\n\tif (max(s[0], s[1]) < min(t[0], t[1])) return false;\n\tif (max(t[0], t[1]) < min(s[0], s[1])) return false;\n\treturn true;\n}\n\nbool IntersectLP(line l, point p) {\n\treturn EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(line s, point p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(line l) {\n\treturn abs(l[0]-l[1]);\n}\n\ndouble DistLP(line l, point p) {\n\treturn abs(p - proj(l, p));\n}\n\ndouble DistLL(line l, line m) {\n\tif (!IntersectLL(l, m)) return 0;\n\treturn DistLP(l, m[0]);\n}\n\ndouble DistLS(line l, line s) {\n\tif (IntersectLS(l, s)) return 0;\n\treturn min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(line s, point p) {\n\tpoint r = proj(s, p);\n\tif (IntersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(line s, line t) {\n\tif (IntersectSS(s, t)) return 0;\n\n\tdouble a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n\tdouble b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n\treturn min(a, b);\n}\n\nline PerpendBisect(line seg) {//?????´????????????\n\tpoint mid = (seg[0]+seg[1])/2.0;\n\treturn line{mid, mid+(seg[1]-seg[0])*vec(0, 1)};\n}\n\npoint CrosspointLL(line l, line m) {\n\tdouble A = cross(l[1]-l[0], m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0], l[1]-m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\tif (abs(A) < EPS) assert(0);\n\treturn m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<point> CrosspointCL(circle c, line l) {\n\tvector<point> ret;\n\tdouble d = DistLP(l, c.c);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(proj(l, c.c));\n\t} else if (d < c.r) {\n\t\tdouble ratio = sqrt(c.r*c.r - d*d);\n\t\tvec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n\t\tret.emplace_back(proj(l, c.c) + ratio*sgn);\n\t\tret.emplace_back(proj(l, c.c) - ratio*sgn);\n\t}\n\n\treturn ret;\n}\n\nvector<point> CrosspointCS(circle c, line s) {\n\tvector<point> ret;\n\tvector<point> res = CrosspointCL(c, s);\n\tif (s[0] > s[1]) swap(s[0], s[1]);\n\tfor (point p : res) {\n\t\tif (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n\t}\n\treturn ret;\n}\n\nvector<point> CrosspointCC(circle c1, circle c2) {\n\tvector<point> ret;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble dfr = c1.r*c1.r - rc*rc;\n\n\tif (EQ(dfr, 0.0)) dfr = 0.0;\n\telse if(dfr < 0.0) return ret;\n\n\tdouble rs = sqrt(dfr);\n\tvec sgn = (c2.c - c1.c) / d;\n\tret.emplace_back(c1.c + sgn*point(rc, rs));\n\tif (dfr > 0.0) ret.emplace_back(c1.c + sgn*point(rc, -rs));\n\treturn ret;\n}\n\ngeometry Positioningpoint(poly poly, point p) {\n\tbool in = false;\n\tint n = poly.size();\n\tfor (int i=0; i<n; i++) {\n\t\tpoint a = poly[i];\n\t\tpoint b = poly[(i+1)%n];\n\t\tvec u = a - p;\n\t\tvec v = b - p;\n\n\t\tif (u.Y > v.Y) swap(u, v);\n\n\t\tdouble cr = cross(u, v);\n\t\tif (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n\t\tif (IntersectSP({a, b}, p)) return ON_LINE;\n\t}\n\n\tif (in) return INSIDE;\n\treturn OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\npoly GrahamScan(vector<point> ps) {\n\tif (ps.size() <= 2) return ps;\n\n\tint k = 0;\n\tint n = ps.size();\n\tpoly ret(n*2);\n\n\tsort(ps.begin(), ps.end());\n\tfor (int i=0; i<n; i++) {\n\t\twhile (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tint k_ = k;\n\tfor (int i=n-1; i>=0; i--) {\n\t\twhile (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tret.resize(k-1);\n\treturn ret;\n}\n\nbool IsConvex(poly ps) {\n\treturn GrahamScan(ps).size() == ps.size();\n}\n\npoly CapConvexes(poly pp, poly qq) {\n#if DEBUG\n\tassert (IsConvex(pp));\n\tassert (IsConvex(qq));\n#endif\n\n\tpoly ret;\n\tint a = 0;\n\tint b = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint n = pp.size();\n\tint m = qq.size();\n\tenum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n\tauto forward_a = [&](bool put) {\n\t\tif (put && in == PIN) ret.emplace_back(pp[a]);\n\t\ta = (a+1)%n;\n\t\taa++;\n\t};\n\n\tauto forward_b = [&](bool put) {\n\t\tif (put && in == QIN) ret.emplace_back(qq[b]);\n\t\tb = (b+1)%m;\n\t\tbb++;\n\t};\n\n\tauto intersect_1pt = [](point &a, point &b, point &c, point &d, point &r) {\n\t\tdouble D =\tcross(b - a, d - c);\n\t\tif (EQ(D, 0)) return false;\n\t\tdouble t =\tcross(c - a, d - c) / D;\n\t\tdouble s = -cross(a - c, b - a) / D;\n\t\tr = a + t * (b - a);\n\t\treturn GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n\t};\n\n\tdo {\n\t\tint apre = (a+n-1)%n;\n\t\tint bpre = (b+m-1)%m;\n\t\tdouble C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n\t\tdouble A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n\t\tdouble B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n\t\tpoint r;\n\t\tif (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n\t\t\tif (in == UNKNOWN) aa = bb = 0;\n\t\t\tret.emplace_back(r);\n\t\t\tif (B > 0) in = PIN;\n\t\t\telse if (A > 0) in = QIN;\n\t\t}\n\n\t\tif (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n\t\t\tif (in == PIN) forward_b(false);\n\t\t\telse forward_a(false);\n\t\t} else if (C >= 0) {\n\t\t\tif (A > 0) forward_a(true);\n\t\t\telse forward_b(true);\n\t\t} else {\n\t\t\tif (B > 0) forward_b(true);\n\t\t\telse forward_a(true);\n\t\t}\n\t} while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n\tif (in == UNKNOWN) {\n\t\tif (Positioningpoint(qq, pp[0]) != OUTSIDE) return pp;\n\t\tif (Positioningpoint(pp, qq[0]) != OUTSIDE) return qq;\n\t}\n\treturn ret;\n}\n\ndouble CalcArea(poly ps) {\n\tdouble ret = 0.0;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tret += cross(ps[i], ps[(i+1)%ps.size()]);\n\t}\n\treturn ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(poly ps) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\tint n = ps.size();\n\tint is = 0;\n\tint js = 0;\n\tfor (int i=1; i<n; i++) {\n\t\tif (ps[i].Y > ps[is].Y) is = i;\n\t\tif (ps[i].Y < ps[js].Y) js = i;\n\t}\n\n\tint maxi, maxj;\n\tdouble maxd = norm(ps[is]-ps[js]);\n\tint i = is;\n\tint j = js;\n\tdo {\n\t\tvec a = ps[i+1] - ps[i];\n\t\tvec b = ps[j+1] - ps[j];\n\t\tif (cross(a, b) > -EPS) j = (j+1)%n;\n\t\telse i = (i+1)%n;\n\n\t\tdouble d = norm(ps[i]-ps[j]);\n\t\tif (d > maxd) {\n\t\t\tmaxd = d;\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\n\treturn make_pair(maxi, maxj);\n}\n\nline ClosestPair(vector<point> ps) {\n\tauto CompareY = [](const point &a, const point &b) {\n\t\tif (a.Y != b.Y) return a.Y < b.Y;\n\t\treturn a.X < b.X;\n\t};\n\n\tfunction<line(point*,int)> Rec = [&Rec, &CompareY](point *ps, int n) {\n\t\tif (n <= 1) return line{point(0, 0), point(INF, INF)};\n\t\t\n\t\tint m = n/2;\n\t\tdouble x = ps[m].X;\n\t\tline a = Rec(ps, m);\n\t\tline b = Rec(ps+m, n-m);\n\t\tdouble mind = DistL(a);\n\t\tline ret = a;\n\t\tif (DistL(b) < mind) {\n\t\t\tmind = DistL(b);\n\t\t\tret = b;\n\t\t}\n\n\t\tsort(ps, ps+n, CompareY);\n\t\tvector<point> qs;\n\t\tqs.reserve(n);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (abs(ps[i].X - x) >= mind) continue;\n\n\t\t\tfor (int j=0; j<qs.size(); j++) {\n\t\t\t\tpoint p1 = ps[i];\n\t\t\t\tpoint p2 = qs[qs.size()-1-j];\n\t\t\t\tif (p1.Y - p2.Y >= mind) break;\n\n\t\t\t\tdouble d = abs(p1-p2);\n\t\t\t\tif (mind > d) {\n\t\t\t\t\tmind = d;\n\t\t\t\t\tret = line{p1, p2};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqs.emplace_back(ps[i]);\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tint n = ps.size();\n\tassert (n >= 2);\n\tsort(ps.begin(), ps.end());\n\treturn Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<poly, poly> CutConvex(poly ps, line l) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\t//if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n\t//else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n\tpoly left;\n\tpoly right;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tpoint a = ps[i];\n\t\tpoint b = ps[(i+1)%ps.size()];\n\n\t\tif (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n\t\telse right.emplace_back(a);\n\n\t\tline m{a, b};\n\t\tif (IntersectLS(l, m)) {\n\t\t\tpoint p = CrosspointLL(l, m);\n\t\t\tleft.emplace_back(p);\n\t\t\tright.emplace_back(p);\n\t\t}\n\t}\n\n\treturn make_pair(left, right);\n}\n\ncircle Circum(point a, point b, point c) {\n\tcircle ret{{INF, INF}, 0.0};\n\tline l{a, b};\n\tline m{b, c};\n\tline lp = PerpendBisect(l);\n\tline mp = PerpendBisect(m);\n\tif (IsParallel(lp, mp)) return ret;\n\n\tret.c = CrosspointLL(lp, mp);\n\tret.r = abs(a-ret.c);\n\treturn ret;\n}\n\nvector<point> Tangentpoints(circle c, point p) {\n\tvector<point> ret;\n\tdouble d = abs(c.c-p);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(p);\n\t\treturn ret;\n\t}\n\n\tif (d < c.r) return ret;\n\n\tvec v = (p-c.c)/d*c.r;\n\tdouble t = acos(c.r/d);\n\tret.emplace_back(c.c + rotate(v, t));\n\tret.emplace_back(c.c + rotate(v, -t));\n\treturn ret;\n}\n\nvector<line> CommonTangents(circle p, circle q) {\n#if DEBUG\n\tassert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n\tdouble pr = p.r;\n\tdouble qr = q.r;\n\tpoint pc = p.c;\n\tpoint qc = q.c;\n\tdouble d = abs(pc - qc);\n\tdouble dr = abs(pr - qr);\n\tdouble sr = abs(pr + qr);\n\n\tvector<line> ret;\n\tif (EQ(d, sr)) {//If the 2 circles tangent exclusively,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > sr) {//If the 2 have no intersection,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\tfor (int i=0; i<2; i++) {\n\t\t\tline l{pts[0], qts[i]};\n\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\tret.emplace_back(l);\n\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t}\n\t\t}\n\t} \n\n\tif (EQ(d, dr)) {//If the 2 tangent inclusively,\n\t\tpoint cp = pc + (pc-qc) / (qr-pr) * pr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > dr) {//If the 2 intersect,\n\t\tif (EQ(pr, qr)) {\n\t\t\tpoint v = (qc - pc) / d * pr;\n\t\t\tv *= point(0, 1);\n\t\t\tret.emplace_back(line{pc+v, qc+v});\n\t\t\tret.emplace_back(line{pc-v, qc-v});\n\t\t} else {\n\t\t\tpoint cp = pc + (qc-pc) * pr / (pr-qr);\n\t\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\t\tfor (int i=0; i<2; i++) {\n\t\t\t\tline l{pts[0], qts[i]};\n\t\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\t\tret.emplace_back(l);\n\t\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\n\treturn ret;\n}\n\n#define DIJKSTRA_MAX_N 200\ntypedef pair<double,int> pii;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n};\n\nconst double inf=1000000001;\nint n;//Be careful of the number of the vertexes of g (=2*n).\ndouble d[DIJKSTRA_MAX_N];\nvector<edge> g[DIJKSTRA_MAX_N];\n\nvoid dijkstra(int v){\n\tpriority_queue<pii,vector<pii>,greater<pii> > q;\n\tfill(d,d+2*n,inf);\n\td[v]=0;\n\tq.push(mp(0,v));\n\twhile(!q.empty()){\n\t\tdouble D=q.top().fi;\n\t\tint w=q.top().sc;\n\t\tq.pop();\n\t\tif(D>d[w]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<g[w].size();++j){\n\t\t\tint u=g[w][j].to;\n\t\t\tdouble c=g[w][j].cost;\n\t\t\tif(d[u]>D+c){\n\t\t\t\td[u]=D+c;\n\t\t\t\tq.push(mp(d[u],u));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tcircle c[100];\n\tvector<point> v[100];\n\tfor(int i=0;i<n;++i){\n\t\tdouble x,y;\n\t\tcin>>x>>y>>c[i].r;\n\t\tc[i].c=point (x,y);\n\t}\n\tfor(int i=0;i<n-1;++i){//v[i][j]: 2*i+j+1-th (0-indexed) in g.\n\t\tv[i]=CrosspointCC(c[i],c[i+1]);\n\t}\n\tfor(int i=0;i<n-2;++i){\n\t\tfor(int j=i+1;j<n-1;++j){\n\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\tfor(int l=0;l<2;++l){\n\t\t\t\t\tpoint p=v[i][k],q=v[j][l];\n\t\t\t\t\tline s={p,q};\n\t\t\t\t\tbool f=false;\n\t\t\t\t\tfor(int m=i;m<j;++m){\n\t\t\t\t\t\tif(!IntersectSS(s,(line){v[m][0],v[m][1]})){\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tg[2*i+k+1].pb((edge){2*j+l+1,abs(p-q)});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=0;j<n-1;++j){\n\t\tfor(int l=0;l<2;++l){\n\t\t\tpoint p=c[0].c,q=v[j][l];\n\t\t\tline s={p,q};\n\t\t\tbool f=false;\n\t\t\tfor(int m=0;m<j;++m){\n\t\t\t\tif(!IntersectSS(s,(line){v[m][0],v[m][1]})){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tg[0].pb((edge){2*j+l+1,abs(p-q)});\n\t\t}\n\t}\n\tfor(int i=0;i<n-1;++i){\n\t\tfor(int k=0;k<2;++k){\n\t\t\tpoint p=v[i][k],q=c[n-1].c;\n\t\t\tline s={p,q};\n\t\t\tbool f=false;\n\t\t\tfor(int m=i;m<n-1;++m){\n\t\t\t\tif(!IntersectSS(s,(line){v[m][0],v[m][1]})){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tg[2*i+k+1].pb((edge){2*n-1,abs(p-q)});\n\t\t}\n\t}\n\tpoint p=c[0].c,q=c[n-1].c;\n\tline s={p,q};\n\tbool f=false;\n\tfor(int m=0;m<n-1;++m){\n\t\tif(!IntersectSS(s,(line){v[m][0],v[m][1]})){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f){\n\t\tg[0].pb((edge){2*n-1,abs(p-q)});\n\t}\n\tdijkstra(0);\n\tcout<<fixed<<setprecision(3)<<d[2*n-1]<<endl;\n\tfor(int i=0;i<2*n;++i){\n\t\tg[i].clear();\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\ntypedef long double ldb;\ntypedef complex<ldb> P;\n\nldb eps = 1e-8;\n// 誤差を考慮した比較 sig(a-b) のように使う\n// ret<0 なら a<b, ret>0 なら a>b, ret=0 なら a=b\nint sig(ldb a) {return (a<-eps)?-1:(a>eps)?1:0;}\n// 誤差を考慮した比較\nbool eq(ldb a,ldb b){return abs(a-b)<eps;}\n\n// 内積\nldb dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\nldb cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 円\nstruct C {\n  P p;   //中心\n  ldb r; //半径\n  C(){}\n  C(P p,ldb r):p(p),r(r){}\n};\n// 直線,線分 (半直線は未確認だけど線分で無限に長いものを作れば良さそう)\nstruct L {\n  P a,b;\n  L(P a,P b):a(a),b(b){}\n  ldb len(){return abs(a-b);}\n};\n\n// iP = intersection Point\n// 円の交点 \nvector<P> iP(C a,C b) {\n  vector<P> res;\n  double d = abs(a.p-b.p);\n  int ret = sig(d-(a.r+b.r));\n  if( ret > 0 ) {\n  } else if( eq(d,0) ) {\n    return vector<P>(3);\n  } else if( ret <= 0 ) {\n    double th = acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r)); ;\n    res.push_back(a.p+polar( a.r, arg(b.p-a.p)+th ));\n    if( ret != 0 )res.push_back(a.p+polar( a.r, arg(b.p-a.p)-th ));\n  }\n  return res;\n}\n\n// 線分の交点\nP iP(L a,L b) {\n  P c = b.b-b.a;\n  ldb d1 = abs(cross(c, a.a-b.a));\n  ldb d2 = abs(cross(c, a.b-b.a));\n  ldb t = d1 / (d1 + d2);\n  return a.a + (a.b-a.a) * t;\n}\n\n// 線分の交差判定\nbool iI(L a,L b) {\n  return ( cross(a.b-a.a, b.a-a.a) * cross(a.b-a.a, b.b-a.a) < eps ) &&\n    ( cross(b.b-b.a, a.a-b.a) * cross(b.b-b.a, a.b-b.a) < eps );\n}\nint main(void)\n{\n  int n;\n  C c[111];\n  vector<P> v[111];\n  vector<int> vn[111];\n  ldb dp[111][2];\n  for(;;) {\n    int sz = 0;\n    scanf(\"%d\",&n); if(n==0)break;\n    for(int i = 0; i <= n; i++) {\n      v[i].clear();\n      vn[i].clear();\n    }\n    for(int i = 0; i <= n; i++) {\n      dp[i][0] = dp[i][1] = 1ll<<45;\n    }\n    dp[0][0] = 0;\n    for(int i = 0; i < n; i++) {\n      int x,y,r;\n      scanf(\"%d%d%d\",&x,&y,&r);\n      c[i] = C(P(x,y),r);\n      if( i == 0  ) {\n        v[i].push_back(P(x,y));\n        vn[i].push_back(sz++);\n      } else if( i == n-1 ) {\n        v[i] = iP(c[i],c[i-1]);\n        vn[i].push_back(sz++);\n        v[i+1].push_back(P(x,y));\n        vn[i+1].push_back(sz++);\n      } else {\n        v[i] = iP(c[i],c[i-1]);\n        vn[i].push_back(sz++);\n        vn[i].push_back(sz++);\n      }\n    }\n    /*\n    for(int i = 0; i <= n; i++) {\n      for(int j = 0; j < int(v[i].size()); j++) {\n        cout << v[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n    for(int i = 0; i <= n; i++) {\n      for(int j = 0; j < int(v[i].size()); j++) {\n        \n        for(int ii = i+1; ii <= n; ii++) {\n          for(int jj = 0; jj < int(v[ii].size()); jj++) {\n\n            bool ok = true;\n            for(int k = i+1; k <= ii && ok; k++) {\n              if( v[k].size()>1 && !iI(L(v[i][j],v[ii][jj]),L(v[k][0],v[k][1])) ) {\n                //printf(\"%d %d->%d %d p %d\\n\",i,j,ii,jj,k);\n                ok = false;\n              }\n            }\n            if( ok ) {\n              dp[ii][jj] = min(dp[ii][jj],dp[i][j]+L(v[i][j],v[ii][jj]).len());\n              //printf(\"%d %d %Lf\\n\",ii,jj,dp[ii][jj]);\n              //g[vn[i][j]].push_back(edge(vn[ii][jj],0));\n              //g[vn[ii][jj]].push_back(edge(vn[i][j],0));\n            }\n            \n          }\n        }\n        \n      }\n    }\n    printf(\"%Lf\\n\",dp[n][0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n//\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.emplace_back(c, c);\n\t\t\telse{\n\t\t\t\ts.push_back(cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.emplace_back(prev, prev);\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.4f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\nusing namespace std;\n\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing R=long double;\nconst R EPS=1e-9L;\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\nbool iss(L a,L b){\n    int sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n    int sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n    return max(sa,sb)<0;\n}\n\nVP cross(C c, L l){\n    P h=proj(l,c.c),e=polar(sq(norm(c.r)-norm(h-c.c)),arg(l.t-l.s));\n    return VP{h-e,h+e};\n}\n\nVP cross(C a,C b){\n    P d=b.c-a.c,w=(norm(d)+norm(a.r)-norm(b.r))/(2.0L*norm(d))*d;\n    return cross(a,{a.c+w,a.c+w+1il*w});\n}\n\nint n,m;\nR cost[210][210];\nC c[110];\nL l[110];\nP p[210];\n \ninline int conv(int i){\n    if(i==0) return -1;\n    if(i==m-1) return n-1;\n    return (i-1)/2;\n}\n \nint main(void){\n    while(cin >> n,n){\n        m=2*n;\n        rep(i,m)rep(j,m) cost[i][j]=((i==j)?0:INF);\n \n        rep(i,n) cin >> c[i].c >> c[i].r;\n        \n        p[0]=c[0].c;\n        rep(i,n-1){\n            VP res=cross(c[i],c[i+1]);\n            p[2*i+1]=res[0];\n            p[2*i+2]=res[1];\n            l[i]=L{res[0],res[1]};\n        }\n        p[m-1]=c[n-1].c;\n \n        rep(j,m)rep(i,j){\n            L tar=L{p[i],p[j]};\n \n            bool ok=true;             \n            for(int k=conv(i)+1;k<conv(j);k++){\n                if(iss(tar,l[k])==false)\n                    ok=false;\n            }\n            if(ok) cost[i][j]=cost[j][i]=abs(p[i]-p[j]);\n        }\n        rep(k,m)rep(i,m)rep(j,m) chmin(cost[i][j],cost[i][k]+cost[k][j]);\n         \n        cout.precision(9);\n        cout << fixed << cost[0][m-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tint p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tint q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.emplace_back(c, c);\n\t\t\telse{\n\t\t\t\ts.push_back(cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.emplace_back(prev, prev);\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.4f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <list>\n#include <map>\n#include <cmath>\n#include <utility>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <set>\n#include <climits>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI = acos(-1.0);\n\ntemplate<class T>\nstruct Po{\n\tT x,y;\n\tPo() : x(0),y(0) {}\n\tPo(const T &x,const T &y) : x(x),y(y) {}\n\tPo operator+(const Po& a) const { return P(x + a.x,y + a.y); }\n\tPo operator-(const Po& a) const { return P(x - a.x,y - a.y); }\n\tPo operator*(const double& a) const { return P(x * a, y * a); }\n\tPo operator/(const double& a) const { return P(x / a, y / a); }\n};\n\nenum{ CCW = 1,CW = -1,ON = 0};\n\ntypedef Po<double> P;\n\ndouble SQ(double x) {return x* x; }\ndouble abs(const P& a) { return sqrt(SQ(a.x) + SQ(a.y)); }\ndouble dot( const P& a,const P &b){ return a.x * b.x + a.y * b.y ; }\ndouble cross( const P& a,const P &b){ return a.x * b.y - a.y * b.x ; }\n\nP rot(const P& a, double theta){\n\treturn P( a.x * cos(theta) - a.y * sin(theta) ,\n\t\ta.x * sin(theta) + a.y * cos(theta) );\n}\n\nint ccw(P a,P b,P c){\n\tb = b - a; c = c - a;\n\tdouble rdir = cross(b,c);\n\tdouble len = abs(b) * abs(c);\n\tif( rdir > EPS *len) return CCW;\n\telse if( rdir < -EPS * len) return CW;\n\treturn ON;\n}\n\nbool intersect(P& a1,P& b1,P& a2, P& b2){\n\tif(max(a1.x,b1.x) + EPS < min(a2.x,b2.x)\n\t||max(a1.y,b1.y) + EPS < min(a2.y,b2.y)\n\t||max(a2.x,b2.x) + EPS < min(a1.x,b1.x)\n\t||max(a2.y,b2.y) + EPS < min(a1.y,b1.y) ) return false;\n\treturn ccw(a1,b1,a2) * ccw(a1,b1,b2) <= 0\n\t\t&& ccw(a2,b2,a1) * ccw(a2,b2,b1) <= 0;\n}\n\ntypedef pair<P,P> PD;\n\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\nint n;\nP p[100];\ndouble r[100];\ndouble dp[202][202];\n\n#define FOR(i,n) for(int i = 0; i < (n) ; i++)\n\n\nint main(){\n\n\twhile(cin>>n,n){\n\t\tvector<P> us;\n\t\tvector<PD> vpd;\n\t\tFOR(i,n) cin>>p[i].x >> p[i].y >> r[i];\n\t\tFOR(i,202) FOR(j,202) dp[i][j] = 1e50;\n\t\tus.push_back(p[0]);\n\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tPD pd = GetContact(p[i],p[i+1],r[i],r[i+1]);\n\t\t\tus.push_back(pd.first);\n\t\t\tus.push_back(pd.second);\n\t\t\tvpd.push_back(pd);\n\t\t}\n\t\tus.push_back(p[n-1]);\n\n\t\tfor(int i = 0; i < (int)us.size(); i++){\n\t\t\tfor(int j = i + 1; j < (int)us.size(); j++){\n\t\t\t\tbool ok = true;\n\t\t\t\tint l  = (1 + i) / 2;\n\t\t\t\tint r = (1 + j) / 2 - 1;\n\t\t\t\tfor (int k = l; k < r; k++){\n\t\t\t\t\tif(!intersect(us[i],us[j],vpd[k].first,vpd[k].second))\n\t\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok) continue;\n\t\t\t\tdouble dist = abs(us[i] - us[j]);\n\t\t\t\tdp[j][i] = dp[i][j] = dist;\n\t\t\t}\n\t\t}\n\n\t\tint a = (int)us.size();\n\t\tFOR(k,a) FOR(i,a) FOR(j,a) dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\n\t\tprintf(\"%.10lf\\n\",dp[0][a - 1]);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n#define FOR(i,k,n) for(int i=(k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n \nconst double INF = 1e8;\nconst double EPS = 1e-8;\n \n#include <complex>\n#define CURR(P, i) (P[(i) % P.size()])\n#define NEXT(P, i) (P[((i) + 1) % P.size()])\n \n \ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n    Line() {;}\n    Line(Point a, Point b) { push_back(a); push_back(b); }\n};\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {;}\n    Circle(Point p, double r) : p(p), r(r) {;}\n};\ninline double cross(const Point &a, const Point &b) {\n      return imag(conj(a) * b);\n}\ninline double dot(const Point &a, const Point &b) {\n      return real(conj(a) * b);\n}\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\ninline int ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > 0) { return 1; }\n    if (cross(b, c) < 0) { return -1; }\n    if (dot(b, c) < 0) { return 2; }\n    if (norm(b) < norm(c)) { return -2; }\n    return 0;\n}\nbool intersectSS(const Line &s, const Line &t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nvector<Point> crosspointLC(const Line &l, const Circle &c) {\n    vector<Point> ret;\n    Point center = projection(l, c.p);\n    double d = abs(center - c.p);\n    double t = sqrt(c.r * c.r - d * d);\n    if (isnan(t)) { return ret; }\n    Point vect = (l[1] - l[0]);\n    vect /= abs(vect);\n    ret.push_back(center - vect * t);\n    if (t > EPS) {\n        ret.push_back(center + vect * t);\n    }\n    return ret;\n}\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n    vector<Point> ret;\n    double d = abs(c1.p - c2.p);\n    if (max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) { return ret; }\n    double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    Point start = c1.p + (c2.p - c1.p) / d * x;\n    Point vect = (c1.p - c2.p) * Point(0.0, 1.0);\n    return crosspointLC(Line(start, start + vect), c1);\n}\nint main(){\n    int N;\n    while(cin>>N && N){\n        Point p[100];\n        double r[100];\n        vector<Circle> circles;\n        REP(i, N){\n            double x, y;\n            cin>>x>>y>>r[i];\n            p[i] = Point(x, y);\n            circles.push_back(Circle(p[i], r[i]));\n        }\n        double d[300][300];\n        vector<Point> crosses;\n        REP(i, N-1) {\n            vector<Point> cv = crosspointCC(circles[i], circles[i+1]);\n            crosses.push_back(cv[0]);\n            crosses.push_back(cv[1]);\n        }\n        const int S = 2 * (N - 1);\n        const int G = S + 1;\n        const int SIZE = G + 1;\n        REP(i, SIZE)REP(j, SIZE) d[i][j] = INF;\n        REP(i, crosses.size())FOR(j, i+1, crosses.size()){\n            Line line(crosses[i], crosses[j]);\n            int idx1 = i / 2 + 1, idx2 = j /2;\n            bool ok = true;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[i] - crosses[j]);\n        }\n        REP(j, crosses.size()){\n            int i = S;\n            Line line(p[0], crosses[j]);\n            bool ok = true;\n            int idx1 = 0, idx2 = j / 2;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[j] - p[0]);\n        }\n        REP(i, crosses.size()){\n            int j = G;\n            Line line(crosses[i], p[N-1]);\n            bool ok = true;\n            int idx1 = i / 2 + 1, idx2 = N - 1;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[i] - p[N-1]);\n        }\n        {\n            int i = S; int j = G;\n            Line line(p[0], p[N-1]);\n            bool ok = true;\n            int idx1 = 0, idx2 = N - 1;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            if(ok) d[i][j] = d[j][i] = abs(p[N-1] - p[0]);\n        }\n        REP(k, SIZE)REP(i, SIZE)REP(j, SIZE){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        printf(\"%.8lf\\n\", d[S][G]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\n#define EPS 1e-9\n#define INF 1e9\n\n// ?????¢, ??????, ??????\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(Point a, Point b){ return a.real() * b.imag() - a.imag() * b.real(); }\n\n\n// ccw\n//  1: c?????????ab??????????????´????????? (a?????????, b????\\\\??¨????????¨???)\n// -1: c?????????ab??????????????´?????????\n//  2: c?????????ab?????¶????????????a?????????????????????\n// -2: c?????????ab?????¶????????????b???????\\\\?????????\n//  0: c?????????ab????????????\nint ccw(Point a, Point b, Point c){\n  if(cross(b - a, c - a) > EPS) return 1;\n  if(cross(b - a, c - a) < -EPS) return -1;\n  if(dot(b - a, c - a) < -EPS) return 2;\n  if(dis(a, b) + EPS < dis(c, a)) return -2;\n  return 0;\n}\nint ccw(Line a, Point b){ return ccw(a.first, a.second, b); }\n\n// ??????????????????(??????2???????????¶??´????????????)\nLine CircleCross(Point a, double ra, Point b, double rb){\n  double d = dis(a, b);\n  double rc = (d * d + ra * ra - rb * rb) / (2 * d);\n  double rs = sqrt(ra * ra - rc * rc);\n  Point diff = (b - a) / d;\n  return make_pair(a + diff * Point(rc, rs), a + diff * Point(rc, -rs));\n}\n\n\nvector<double> dijk(int s, vector<vector<pair<double, int> > > adj){\n  int n = adj.size();\n  vector<double> result(n, INF);\n  priority_queue<pair<double, int> > wait;  \n  result[s] = 0;\n  wait.push(make_pair(0, s));\n\n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int nowpoint = wait.top().second;\n    wait.pop();\n    if(result[nowpoint] < nowcost){ continue; }\n    \n    for(int i = 0; i < (int)adj[nowpoint].size(); i++){\n      double nextcost = adj[nowpoint][i].first + nowcost;\n      int nextpoint = adj[nowpoint][i].second;\n      if(result[nextpoint] > nextcost){\n        wait.push(make_pair(-nextcost, nextpoint));\n        result[nextpoint] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\n\nint main(void){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    // ??????????????¨?????????????????????\n    double x, y, r;\n    vector<pair<Point, double> > circles;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y >> r;\n      circles.push_back(make_pair(Point(x, y), r));\n    }\n\n    // ????????????(+?§??????¨??????)?????????\n    // second??????????????????????????????????????????????¨????\n    vector<pair<Point, int> > vertices;\n    vertices.push_back(make_pair(circles[0].first, 0));\n    for(int i = 0; i < n - 1; i++){\n      Line tmp = CircleCross(circles[i].first, circles[i].second, circles[i + 1].first, circles[i + 1].second);\n      vertices.push_back(make_pair(tmp.first, 1));\n      vertices.push_back(make_pair(tmp.second, -1));\n    }\n    vertices.push_back(make_pair(circles[n - 1].first, 0));\n\n    // ??????i??¨j????????????????????????\n    // ??????k(i+1???j-1)????????????????????????????????????????????°OK\n    vector<vector<pair<double, int> > > adj(vertices.size());\n    for(int i = 0; i < (int)vertices.size(); i++){\n      for(int j = i + 1; j < (int)vertices.size(); j++){\n        bool flag = true;\n        for(int k = i + 1; k < j; k++){\n          int tmp = ccw(vertices[i].first, vertices[j].first, vertices[k].first);\n          if(tmp != vertices[k].second){ flag = false; }\n        }\n        if(flag){ adj[i].push_back(make_pair(dis(vertices[i].first, vertices[j].first), j)); }\n      }\n    }\n\n    // ??????????????????????????????????????????\n    vector<double> result = dijk(0, adj);\n    printf(\"%.10f\", result[result.size() - 1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\n// ヘロンの公式により三角形の面積を求める\ndouble Heron(double a, double b, double c) {\n    double s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// 2次元座標上の点、あるいはベクトル\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    double abs() { return sqrt(x * x + y * y); }\n    Point unit() {\n        double l = abs();\n        return Point(x / l, y / l);\n    }\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-() const { return Point(-x, -y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double a) const { return Point(a * x, a * y); }\n    double operator*(const Point& p) const { return x * p.y + y * p.x; }\n    Point operator/(double a) const { return Point(x / a, y / a); }\n    Point R90() const { return Point(y, -x); }\n    Point R180() const { return Point(-x, -y); }\n    Point R270() const { return Point(-y, x); }\n    static double Distance(const Point& a, const Point& b) {\n        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n#define EPS (1e-9)\n    static double CROSS(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    static int CCW(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (CROSS(b, c) > EPS) return +1;  // 反時計周り\n        if (CROSS(b, c) < -EPS) return -1; // 時計周り\n        if (b * c < 0) return +2;          // c--a--b 直線\n        if (b.abs() < c.abs()) return -2;  // a--b--c 直線\n        return 0;                          // a--c--b 直線\n    }\n};\nostream& operator<<(ostream& os, const Point& p) {\n    os << \"(\" << p.x << \",\" << p.y << \")\";\n    return os;\n}\n\nstruct Segment {\n    Point a, b;\n    Segment(Point a, Point b) : a(a), b(b) {}\n    bool DoesIntersect(const Segment &s){\n        return Point::CCW(a, b, s.a) * Point::CCW(a, b, s.b) <= 0 &&\n               Point::CCW(s.a, s.b, a) * Point::CCW(s.a, s.b, b) <= 0;\n    }\n};\n\nstruct Circle {\n    Point o;\n    double r;\n    Circle(Point o, double r) : o(o), r(r) {}\n    static pair<Point, Point> IPoints(const Circle& a, const Circle& b) {\n        double d = Point::Distance(a.o, b.o);\n        double h = Heron(a.r, b.r, d) / d * 2;\n        double l = sqrt(a.r * a.r - h * h);\n        Point e = (b.o - a.o).unit();\n        Point proj = a.o + e * l;\n        return make_pair(proj + e.R90() * h, proj + e.R270() * h);\n    }\n};\n\nint N;\n#define MN 101\ndouble X[MN], Y[MN], R[MN];\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i] >> R[i];\n    }\n    return true;\n}\n\nvoid solve() {\n    vector<Point> Ps;\n    Ps.push_back(Point(X[0], Y[0]));\n    for (int i = 0; i < N - 1; i++) {\n        Circle a(Point(X[i], Y[i]), R[i]),\n               b(Point(X[i + 1], Y[i + 1]), R[i + 1]);\n        pair<Point, Point> pp = Circle::IPoints(a, b);\n        Ps.push_back(pp.first);\n        Ps.push_back(pp.second);\n    }\n    Ps.push_back(Point(X[N - 1], Y[N - 1]));\n    static double G[MN][MN];\n    static const double INF = 1e20;\n    int N1 = 2 * N;\n    for (int i = 0; i < N1; i++) for (int j = 0; j < N1; j++) {\n        if (i == j) G[i][j] = 0;\n        else G[i][j] = INF;\n    }\n    for (int i = 0; i < Ps.size(); i++) {\n        for (int j = i + 1; j < Ps.size(); j++) {\n            Point& a = Ps[i];\n            Point& b = Ps[j];\n            Segment s(a, b);\n            int li = (i + 1) / 2 + 1,\n                lj = (j + 1) / 2;\n            for (int k = li; k < lj; k++) {\n                if (!s.DoesIntersect(Segment(Ps[k * 2 - 1], Ps[k * 2]))) {\n                    goto FAIL;\n                }\n            }\n            G[i][j] = Point::Distance(a, b);\n            FAIL:;\n        }\n    }\n    /*\n    for (int k = 0; k < N1; k++) {\n        for (int i = 0; i < N1; i++) {\n            for (int j = 0; j < N1; j++) {\n                G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n            }\n        }\n    }\n    */\n    for (int i = 0; i < N1; i++) {\n        for (int j = i + 1; j < N1; j++) {\n            G[0][j] = min(G[0][j], G[0][i] + G[i][j]);\n        }\n    }\n    printf(\"%.8lf\\n\", G[0][2 * N - 1]);\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> comp;\n\n//  外積\ndouble cross( comp a, comp b ) { return a.real()*b.imag()-a.imag()*b.real(); }\n\n//  a1とa2を結ぶ線分と、b1とb2を結ぶ線分が交差しているか\nbool inter( comp a1, comp a2, comp b1, comp b2 )\n{\n    return cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) <= 0 &&\n           cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) <= 0;\n}\n\nint main()\n{\n    while ( true )\n    {\n        int n;  cin>>n;\n        if ( n==0 )\n            break;\n        vector<comp> p(n);\n        vector<double> r(n);\n        for ( int i=0; i<n; i++ )\n        {\n            int x, y;  cin>>x>>y>>r[i];\n            p[i] = comp(x,y);\n        }\n\n        //  両端の円の中心と交点\n        vector<vector<comp> > C(n+1,vector<comp>(2));\n        C[0][0] = C[0][1] = p[0];\n        for ( int i=1; i<n; i++ )\n        {\n            comp p1 = p[i-1];\n            comp p2 = p[i];\n            double r1 = r[i-1];\n            double r2 = r[i];\n            double d = abs(p2-p1);\n            double th = acos((d*d+r1*r1-r2*r2)/(2*d*r1));\n            C[i][0] = p1 + polar( r1, arg(p2-p1)+th );\n            C[i][1] = p1 + polar( r1, arg(p2-p1)-th );\n        }\n        C[n][0] = C[n][1] = p[n-1];\n\n        //  交点C[i][j]までの最短経路\n        vector<vector<double> > D(n+1,vector<double>(2,1e10));\n        D[0][0] = D[0][1] = 0;\n\n        for ( int ti=1; ti<n+1; ti++ )\n        for ( int tj=0; tj<2; tj++ )\n        {\n            for ( int fi=0; fi<ti; fi++ )\n            for ( int fj=0; fj<2; fj++ )\n            {\n                bool f = true;\n                for ( int i=fi+1; i<ti && f; i++ )\n                    if ( !inter(C[fi][fj],C[ti][tj],C[i][0],C[i][1]) )\n                        f = false;\n                if ( f )\n                    D[ti][tj] = min( D[ti][tj], D[fi][fj]+abs(C[ti][tj]-C[fi][fj]) );\n            }\n        }\n\n        printf( \"%.10f\\n\", D[n][0] );\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\n#define EPS 1e-9\n#define INF 1e9\n\n// ?????¢, ??????, ??????\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(Point a, Point b){ return a.real() * b.imag() - a.imag() * b.real(); }\n\n\n// ccw\n//  1: c?????????ab??????????????´????????? (a?????????, b????\\\\??¨????????¨???)\n// -1: c?????????ab??????????????´?????????\n//  2: c?????????ab?????¶????????????a?????????????????????\n// -2: c?????????ab?????¶????????????b???????\\\\?????????\n//  0: c?????????ab????????????\nint ccw(Point a, Point b, Point c){\n  if(cross(b - a, c - a) > EPS) return 1;\n  if(cross(b - a, c - a) < -EPS) return -1;\n  if(dot(b - a, c - a) < -EPS) return 2;\n  if(dis(a, b) + EPS < dis(c, a)) return -2;\n  return 0;\n}\nint ccw(Line a, Point b){ return ccw(a.first, a.second, b); }\n\n// ??????????????????(??????2???????????¶??´????????????)\nLine CircleCross(Point a, double ra, Point b, double rb){\n  double d = dis(a, b);\n  double rc = (d * d + ra * ra - rb * rb) / (2 * d);\n  double rs = sqrt(ra * ra - rc * rc);\n  Point diff = (b - a) / d;\n  return make_pair(a + diff * Point(rc, rs), a + diff * Point(rc, -rs));\n}\n\n\nvector<double> dijk(int s, vector<vector<pair<double, int> > > adj){\n  int n = adj.size();\n  vector<double> result(n, INF);\n  priority_queue<pair<double, int> > wait;  \n  result[s] = 0;\n  wait.push(make_pair(0, s));\n\n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int nowpoint = wait.top().second;\n    wait.pop();\n    if(result[nowpoint] < nowcost){ continue; }\n    \n    for(int i = 0; i < (int)adj[nowpoint].size(); i++){\n      double nextcost = adj[nowpoint][i].first + nowcost;\n      int nextpoint = adj[nowpoint][i].second;\n      if(result[nextpoint] > nextcost){\n        wait.push(make_pair(-nextcost, nextpoint));\n        result[nextpoint] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\n\nint main(void){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    // ??????????????¨?????????????????????\n    double x, y, r;\n    vector<pair<Point, double> > circles;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y >> r;\n      circles.push_back(make_pair(Point(x, y), r));\n    }\n\n    // ????????????(+?§??????¨??????)?????????\n    // second??????????????????????????????????????????????¨????\n    vector<pair<Point, int> > vertices;\n    vertices.push_back(make_pair(circles[0].first, 0));\n    for(int i = 0; i < n - 1; i++){\n      Line tmp = CircleCross(circles[i].first, circles[i].second, circles[i + 1].first, circles[i + 1].second);\n      vertices.push_back(make_pair(tmp.first, 1));\n      vertices.push_back(make_pair(tmp.second, -1));\n    }\n    vertices.push_back(make_pair(circles[n - 1].first, 0));\n\n    // ??????i??¨j????????????????????????\n    // ??????k(i+1???j-1)????????????????????????????????????????????°OK\n    vector<vector<pair<double, int> > > adj(vertices.size());\n    for(int i = 0; i < (int)vertices.size(); i++){\n      for(int j = i + 1; j < (int)vertices.size(); j++){\n        bool flag = true;\n        for(int k = i + 1; k < j; k++){\n          int tmp = ccw(vertices[i].first, vertices[j].first, vertices[k].first);\n          if(tmp != vertices[k].second){ flag = false; }\n        }\n        if(flag){ adj[i].push_back(make_pair(dis(vertices[i].first, vertices[j].first), j)); }\n      }\n    }\n\n    // ??????????????????????????????????????????\n    vector<double> result = dijk(0, adj);\n    printf(\"%.4f\\n\", result[result.size() - 1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define INF 2147483647\nusing namespace std;\ntypedef complex<double> xy_t;\n\nclass vertex\n{\npublic:\n  int n;\n  double d;\n  vertex()\n  {\n    n=-1;\n    d=0;\n  }\n  vertex(int v,double dis)\n  {\n    n=v;\n    d=dis;\n  }\n  bool operator<(const vertex b) const\n  {\n    return (fabs(d-b.d)>0.00001 && d<b.d);\n  }\n};\nclass edge\n{\npublic:\n  int vt;\n  double d;\n  edge()\n  {\n    vt=-1;\n    d=0;\n  }\n  edge(int v,double dis)\n  {\n    vt=v;\n    d=dis;\n  }\n  /*bool operator<(const vertex b) const\n  {\n    return (fabs(d-b.d)>0.00001 && d<b.d)\n  }*/\n};\n\n\n\nclass circle\n{\npublic:\n  xy_t center;\n  int r;\n  circle()\n  {\n    center=xy_t(0,0);\n    r=0;\n  }\n  circle(int x, int y, int rad)\n  {\n    center=xy_t(x,y);\n    r=rad;\n  }\n};\npriority_queue<vertex> Q;\nvector<edge> E[202];\nint n;\ncircle circles[101];\nxy_t intercept[202];\ndouble dist[202];\n\nxy_t cross(circle C_1,circle C_2,bool p)\n{\n  int a=C_1.center.real();\n  int b=C_1.center.imag();\n  int r=C_1.r;\n  int c=C_2.center.real();\n  int d=C_2.center.imag();\n  int R=C_2.r;\n  int A=2*(a-c);\n  int B=2*(b-d);\n  int C=R*R-r*r+a*a+b*b-c*c-d*d;\n  double x,y;\n  if (B==0)\n  {\n    x=1.0l*C/(1.0l*A);\n    double BB=-2*b;\n    double CC=b*b-r*r+x*x-2*a*x+a*a;\n    double delta=BB*BB-4*CC;\n    if (p==true)\n      y=(-BB+sqrt(delta))/(2.0l);\n    else\n      y=(-BB-sqrt(delta))/(2.0l);\n  }\n  else\n  {\n    double AA=A*A+B*B;\n    double BB=-2*A*C-2*a*B*B+2*b*A*B;\n    double CC=-B*B*(r*r-a*a-b*b)-2*b*B*C+C*C;\n    double delta=BB*BB-4*AA*CC;\n    //cout<<AA<<' '<<BB<<' '<<CC<<endl;\n    if (p==true)\n      x=(-BB+sqrt(delta))/(2.0l*AA);\n    else\n      x=(-BB-sqrt(delta))/(2.0l*AA);\n    y=(C-A*x)/(B);\n  }\n  return xy_t(x,y);\n}\nint calc()\n{\n  int count=0;\n  intercept[count++]=circles[0].center;\n  //cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  for(int i=1;i<n;i++)\n  {\n    intercept[count++]=cross(circles[i-1],circles[i],false);\n    //cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n    intercept[count++]=cross(circles[i-1],circles[i],true);\n    //cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  }\n  intercept[count++]=circles[n-1].center;\n  //cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  return count;\n}\n\ndouble dis(int i,int j)\n{\n  return abs(intercept[i]-intercept[j]);\n}\n\ndouble cross_product(xy_t a,xy_t b)\n{\n  return (conj(a)*b).imag();\n}\n\nbool isleft(int a, int b, int c)\n{\n  xy_t a1=intercept[b]-intercept[a];\n  xy_t a2=intercept[c]-intercept[b];\n  return cross_product(a1,a2)>0;\n}\n\nbool iszero(int a, int b, int c)\n{\n  xy_t a1=intercept[b]-intercept[a];\n  xy_t a2=intercept[c]-intercept[b];\n  return abs(cross_product(a1,a2))<0.00001;\n}\n\nbool legal(int i,int j)\n{\n  for(int k=(i+3)/2;k<=(j-1)/2;k++)\n  {\n    //if(!iszero(i,2*k,j)&&!iszero(i,2*k-1,j)&&isleft(i,2*k,j)==isleft(i,2*k-1,j))\n    if(isleft(i,2*k,j)==isleft(i,2*k-1,j))\n      return false;\n  }\n  return true;\n}\nvoid make_edge(int n)\n{\n  for(int i=0;i<n;i++)\n  {\n    E[i].clear();\n    for(int j=i+1;j<n;j++)\n    {\n      if(legal(i,j))\n      {\n        E[i].push_back(edge(j,dis(i,j)));\n        //cout<<i<<\",\"<<j<<\",\"<<dis(i,j)<<endl;\n      }\n    }\n  }\n}\nvoid dijkstra(int nofv)\n{\n  for(int i=0;i<nofv;i++)\n    dist[i]=INF;\n  dist[0]=0;\n  Q.push(vertex(0,dist[0]));\n  while(!Q.empty())\n  {\n    vertex now=Q.top();\n    Q.pop();\n    int nowv=now.n;\n    for(vector<edge>::iterator it=E[nowv].begin();it!=E[nowv].end();++it)\n    {\n      int vt=(*it).vt;double d=(*it).d;\n      if (dist[vt]>dist[nowv]+d)\n      {\n        dist[vt]=dist[nowv]+d;\n        Q.push(vertex(vt,dist[vt]));\n      }\n    }\n  }\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if(n==0) break;\n    for(int i=0;i<n;i++)\n    {\n      int x,y,r;\n      cin>>x>>y>>r;\n      circles[i]=circle(x,y,r);\n    }\n    int nofv=calc();\n    make_edge(nofv);\n    dijkstra(nofv);\n    cout<<dist[nofv-1]<<endl;\n  }\n\n  //cout<<cross(circle(851,443,17),circle(856,419,17),0)<<endl;\n  //cout<<cross(circle(851,443,17),circle(856,419,17),1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint n,m,c,s,g,p[22],q[22][55],r[22][55],cost[22][20011];\nint d[22][111][111],D[111][111];\n\nint main(){\n\twhile(cin>>n>>m>>c>>s>>g && n){\n\t\ts--;g--;\n\t\trep(i,c)rep(j,n)rep(k,n)d[i][j][k]=(j==k?0:INF);\n\t\trep(i,m){\n\t\t\tint x,y,dd,cc;\n\t\t\tcin>>x>>y>>dd>>cc;\n\t\t\tx--;y--;cc--;\n\t\t\td[cc][x][y]=min(d[cc][x][y],dd);\n\t\t\td[cc][y][x]=min(d[cc][y][x],dd);\n\t\t}\n\t\trep(i,c)cin>>p[i];\n\t\trep(i,c){\n\t\t\trep(j,p[i]-1)cin>>q[i][j];\n\t\t\trep(j,p[i])cin>>r[i][j];\n\t\t\tq[i][p[i]-1]=INF;\n\t\t}\n\t\trep(h,c)rep(k,n)rep(i,n)rep(j,n){\n\t\t\td[h][i][j]=min(d[h][i][j],d[h][i][k]+d[h][k][j]);\n\t\t}\n\t\trep(h,c){\n\t\t\tint cur=0;\n\t\t\trep2(i,1,20001){\n\t\t\t\tcost[h][i]=cost[h][i-1]+r[h][cur];\n\t\t\t\tif(i==q[h][cur])cur++;\n\t\t\t}\n\t\t}\n\t\trep(i,n)rep(j,n)D[i][j]=(i==j?0:INF);\n\t\trep(h,c)rep(i,n)rep(j,n)if(d[h][i][j]<INF){\n\t\t\tD[i][j]=min(D[i][j],cost[h][d[h][i][j]]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tD[i][j]=min(D[i][j],D[i][k]+D[k][j]);\n\t\t}\n\t\tcout<<(D[s][g]<INF?D[s][g]:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define INF (DBL_MAX/4)\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a)-(b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n\nstruct Point {\n  double x, y;\n  Point(){}\n  Point(double x, double y):x(x), y(y){}\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n};\nusing Vector = Point;\n\ndouble dot(Vector a, Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Vector v) { return dot(v, v); }\ndouble abs(Vector v) { return sqrt(norm(v)); }\n\n#define CCW +1\n#define CW -1\n#define BACK -2\n#define FRONT +2\n#define ON 0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a, b) > EPS) return CCW;\n  if(cross(a, b) < -EPS) return CW;\n  if(dot(a, b) < -EPS) return BACK;\n  if(norm(a) < norm(b)) return FRONT;\n  return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) {\n  return abs(a-b);\n}\n\nstruct Segment {\n  Point s, t;\n  Segment(){}\n  Segment(Point s, Point t):s(s), t(t){}\n};\nusing Line = Segment;\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.s, s1.t, s2.s, s2.t);\n}\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle(){}\n  Circle(Point p, double r):p(p), r(r){}\n};\n\nbool intersect(Circle c1, Circle c2) {\n  double d = getDistance(c1.p, c2.p);\n  return le(d, c1.r+c2.r) && !lt(d, fabs(c1.r-c2.r));\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r)*a, sin(r)*a); }\nvector<Point> getCrossPoints(Circle c1, Circle c2) {\n  vector<Point> res;\n  if(!intersect(c1, c2)) return res;\n  double d = abs(c1.p-c2.p);\n  double a = acos((c1.r*c1.r+d*d - c2.r*c2.r)/(2*c1.r*d));\n  double t = arg(c2.p-c1.p);\n  res.push_back(c1.p+polar(c1.r, t+a));\n  res.push_back(c1.p+polar(c1.r, t-a));\n  return res;\n}\n\nstruct edge {\n  int to;\n  double cost;\n  edge(){}\n  edge(int to, double cost):to(to), cost(cost){}\n};\n\nint n;\nvector<Circle> cs;\nvector< vector<Point> > xp;\nvector<Segment> segs;\nvector< vector<edge> > graph;\nint S, T;\n\ndouble dijkstra() {\n  vector<double> mincost(graph.size(), INF);\n  priority_queue<Pi, vector<Pi>, greater<Pi> > que;\n  mincost[S] = 0;\n  que.emplace(0, S);\n  while(!que.empty()) {\n    Pi p = que.top(); que.pop();\n    int v = p.second;\n    if(v == T) return mincost[v];\n    if(mincost[v] < p.first) continue;\n    for(edge &e : graph[v]) {\n      if(e.cost + mincost[v] < mincost[e.to]) {\n\tmincost[e.to] = e.cost + mincost[v];\n\tque.emplace(mincost[e.to], e.to);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n, n) {\n    resz(cs, n);\n    rep(i, n) cin >> cs[i].p.x >> cs[i].p.y >> cs[i].r;\n\n    resz(xp, n-1);\n    resz(segs, n-1);\n    rep(i, n-1) {\n      xp[i] = getCrossPoints(cs[i], cs[i+1]);\n      assert((int)xp[i].size() == 2);\n      segs[i] = Segment(xp[i][0], xp[i][1]);\n    }\n\n    resz(graph, 2*n);\n    S = 2*n-2, T = 2*n-1;\n    //rep(i, 2) graph[S].emplace_back(i, getDistance(cs[0].p, xp[0][i]));\n    //rep(i, 2) graph[2*(n-2)+i].emplace_back(T, getDistance(xp[n-2][i], cs[n-1].p));\n    rep(i, n-1) rep(j, 2) {\n      double dist = getDistance(cs[0].p, xp[i][j]);\n      Segment s = Segment(cs[0].p, xp[i][j]);\n      rep(k, i+1) {\n\tif(!intersect(s, segs[k])) dist = INF;\n      }\n      if(dist != INF) graph[S].emplace_back(2*i+j, dist);\n    }\n    rep(i, n-1) rep(j, 2) {\n      double dist = getDistance(xp[i][j], cs[n-1].p);\n      Segment s = Segment(xp[i][j], cs[n-1].p);\n      reps(k, i, n-1) {\n\tif(!intersect(s, segs[k])) dist = INF;\n      }\n      if(dist != INF) graph[2*i+j].emplace_back(T, dist);\n    }\n    {\n      double dist = getDistance(cs[0].p, cs[n-1].p);\n      Segment s = Segment(cs[0].p, cs[n-1].p);\n      rep(i, n-1) {\n\tif(!intersect(s, segs[i])) dist = INF;\n      }\n      if(dist != INF) graph[S].emplace_back(T, dist);\n    }\n\n    rep(i, n-1) reps(j, i, n-1) {\n      rep(k, 2) rep(l, 2) {\n\tif(i == j && k == l) continue;\n\tdouble dist = getDistance(xp[i][k], xp[j][l]);\n\tSegment s = Segment(xp[i][k], xp[j][l]);\n\treps(m, i, j+1) {\n\t  if(!intersect(s, segs[m])) dist = INF;\n\t}\n\tif(dist != INF) graph[2*i+k].emplace_back(2*j+l, dist);\n      }\n    }\n\n    cout << dijkstra() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\nnamespace geom{\n#define at(i) ((*this)[i])\n#define pb push_back\n#define X real()\n#define Y imag()\n#define SELF (*this)\n    typedef long double R;\n    typedef complex<R> P;\n    const R EPS = 1e-8;\n    const R PI=3.14159265358979323846264338327950288;\n    enum { TRUE = 1, FALSE = 0, BORDER= -1};\n    inline int sig(const R&x){return (abs(x)<EPS?0:x>0?1:-1);}\n    inline int less(const R &x,const R &y){return sig(x-y)?x<y:BORDER;}\n    inline R inp(const P &a,const P &b){return (conj(a)*b).X;}\n    inline R outp(const P &a,const P & b){return (conj(a)*b).Y;}\n    inline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n    inline P unit(const P & p){return p/abs(p);}\n    inline P proj(const P &s,const P &t){return t*inp(s,t)/norm(t);}\n    inline int ccw(const P &s, const P &t, const P &p, int adv = 0) {\n        int res = sig(outp(t-s, p-s));\n        if(res || !adv) return res;\n        if(sig(inp(t-s, p-s)) < 0) return -2;\n        if(sig(inp(s-t, p-t)) < 0) return 2;\n        return 0;\n    }\n    struct L :public vector<P>{\n        L(const P &p1,const P &p2){this->pb(p1);this->pb(p2);}\n        L(){}\n        P dir()const {return at(1)-at(0);}\n        int online(const P &p) const {return !sig(outp(p-at(0),dir()));}\n    };\n    struct S: public L {\n        S(const P &p1, const P &p2): L(p1,p2){}\n        S(){}\n        int online(const P &p) const{\n            if(!sig(norm( p-at(0) )) || !sig(norm(p - at(1))) ) return BORDER;\n            return !sig(outp(p-at(0), dir())) && inp(p-at(0), dir()) > EPS && inp(p-at(1),-dir()) > -EPS;\n        }\n    };\n    struct C :public P{\n        C(){}\n        C(const P &p,const R r):P(p),r(r){}\n        R r;\n        int inside(const P &p)const { return less(norm(p-SELF),r*r);}\n    };\n    //inline P proj(const P &s,const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\n    inline int intersect (const S &s, const S &t){\n        const int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n        const int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n        return (p>0 || q>0) ? FALSE : (!p || !q) ? BORDER : TRUE;\n    }\n    inline int intersect (const C &a,const C &b){\n        return less((a.r-b.r)*(a.r-b.r),norm(a-b))+less(norm(a-b),(a.r+b.r)*(a.r+b.r))-1;\n    }\n    inline R dist2(const L &l,const P &p){\n        return norm(outp(l.dir(),p-l[0]))/norm(l.dir());\n    }\n    inline int intersect(const C &c,const L &l){\n        return less(dist2(l,c),c.r*c.r);\n    }\n\n    inline S crosspoint(const C &c1,const C &c2){\n        if(!intersect(c1,c2)) return S();\n        R d=abs(c1-c2);\n        R x=(c1.r*c1.r-c2.r*c2.r+d*d)/(2*d);\n        R h=sqrt(max<R>(0.,c1.r*c1.r-x*x));\n        P u=unit(c2-c1);\n        return S(c1+u*x+u*P(0,-1)*h,c1+u*x+u*P(0,1)*h);\n    }\n\n    // inline S crosspoint(const C &c,const L &l){\n    //   R d2=dist2(l,c);\n    //   if(c.r*c.r+EPS < d2) return S();\n    //   P m= proj(c,l);\n    //   P u = unit(l[1]-l[0]);\n    //   R d=sqrt(max<R>(.0,c.r*c.r-d2));\n    //   return S(m+u*d,m-u*d);\n    // }\n\n    S circlePPR(const P& a, const P& b, R r){\n        return crosspoint( C(a,r), C(b,r) );\n    }\n\n    vector<L> CommonTangent(C c1,C c2){\n        if(c1.r > c2.r) swap(c1,c2);\n        R d=abs(c1-c2);\n        vector<L> res;\n        if(d<EPS) return res;\n        if(d + EPS > c1.r + c2.r){\n            P crs=(c1*c2.r + c2*c1.r)/(c1.r+c2.r);\n            R rad = asin(c1.r/abs(crs-c1));\n            res.pb(L(crs,crs+(c1-crs)*polar((R)1,rad)));\n            res.pb(L(crs,crs+(c1-crs)*polar((R)1,-rad)));\n        }\n        if(c1.r+d+EPS > c2.r){\n            R rad=0.5*PI+asin((c2.r-c1.r)/d);\n            P v=unit(c2-c1)*polar((R)1,rad);\n            if(c1.r+d-EPS < c2.r){\n                res.pb(L(c1+v*c1.r, c1+v*c1.r+(c1-c2)*P(0,1)));\n            }else{\n                res.pb(L(c1+v*c1.r,c2+v*c2.r));\n                v=(R)2.*proj(v,c2-c1)-v;\n                res.pb(L(c1+v*c1.r,c2+v*c2.r));\n            }\n        }\n        return res;\n    }\n}\nusing namespace geom;\n\nR G[256][256];\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        rep(i, 256) rep(j, 256) G[i][j] = 1e9;\n        R x, y, r;\n        vector<C> cs;\n        vector<S> ss; \n        rep(i, n) {\n            cin >> x >> y >> r;\n            cs.pb(C(P(x, y), r));\n        }\n        ss.pb(S(cs[0], cs[0]));\n        rep(i, n) {\n            if(i != n-1) {\n                S s = crosspoint(cs[i], cs[i+1]);\n                ss.pb(s);\n            } else {\n                ss.pb(S(cs[n-1], cs[n-1]));\n            }\n            rep(j, i+1) {\n                rep(k, 2) {\n                    rep(l, 2) {\n                        bool ok = true;\n                        for(int  m = j; m < i+1; m++) {\n                            if(!intersect(ss[m], S(ss[i+1][k], ss[j][l]))) {\n                                ok = false;\n                            }\n                        }\n                        if(ok) G[2*(i+1)+k][2*j+l] = G[2*j+l][2*(i+1)+k] = abs(ss[i+1][k] - ss[j][l]);\n                    }\n                }\n            }\n        }\n#if 0\n        rep(i, 2*n+2) {\n            rep(j, 2*n+2) {\n                cout << G[i][j] << \" \";\n            }\n            cout << endl;\n        }\n#endif\n        rep(k, 2*n+2) rep(i, 2*n+2) rep(j, 2*n+2) {\n            G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n        printf(\"%.10lf\\n\", (double)G[0][2*n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nstruct C { P o; R r; };\nV<P> intxnCL(C c, L l) {\n  int s = sgn(distPL(c.o, l), c.r);\n  if (s > 0) return {};\n  P p = proj(c.o, l);\n  if (!s) return {p};\n  P q = sqrt(c.r * c.r - norm(p - c.o)) * l.vec() / l.abs();\n  return {p - q, p + q};\n}\nV<P> intxnCC(C c, C d) {\n  R a = distPP(c.o, d.o);\n  if (!sgn(a)) {\n    assert(sgn(c.r, d.r));\n    return {};\n  }\n  P p = polar(c.r / a, acos((a * a + c.r * c.r - d.r * d.r) / (2 * a * c.r)));\n  return {c.o + conj(p) * (d.o - c.o), c.o + p * (d.o - c.o)};\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<C> cs(n);\n    for (auto&& c : cs) {\n      cin >> c.o >> c.r;\n    }\n    VV<R> d(2 * n, V<R>(2 * n, 1e10));\n    for (int i = 0; i < 2 * n; ++i) d[i][i] = 0;\n    V<P> ps(2 * n);\n    for (int i = 0; i < n - 1; ++i) {\n      auto v = intxnCC(cs[i], cs[i + 1]);\n      ps[2 * i] = v[0], ps[2 * i + 1] = v[1];\n    }\n    ps[2 * n - 2] = cs[0].o, ps[2 * n - 1] = cs.back().o;\n    auto add = [&](int i, int j, int l, int r) -> void {\n      for (int k = l; k < r; ++k) {\n        if (ccw(ps[i], ps[j], ps[2 * k]) == 1) return;\n        if (ccw(ps[i], ps[j], ps[2 * k + 1]) == -1) return;\n      }\n      d[i][j] = min(d[i][j], distPP(ps[i], ps[j]));\n    };\n    add(2 * n - 2, 2 * n - 1, 0, n - 1);\n    for (int i = 0; i < n - 1; ++i) {\n      add(2 * n - 2, 2 * i, 0, i);\n      add(2 * n - 2, 2 * i + 1, 0, i);\n      add(2 * i, 2 * n - 1, i + 1, n - 1);\n      add(2 * i + 1, 2 * n - 1, i + 1, n - 1);\n      for (int j = i + 1; j < n - 1; ++j) {\n        add(2 * i, 2 * j, i + 1, j);\n        add(2 * i, 2 * j + 1, i + 1, j);\n        add(2 * i + 1, 2 * j, i + 1, j);\n        add(2 * i + 1, 2 * j + 1, i + 1, j);\n      }\n    }\n    for (int k = 0; k < 2 * n; ++k) for (int i = 0; i < 2 * n; ++i) for (int j = 0; j < 2 * n; ++j) {\n      d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    }\n    cout << fixed << setprecision(15) << d[2 * n - 2][2 * n - 1] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tC c[100];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i].p.real() >> c[i].p.imag() >> c[i].r;\n\t\t}\n\t\tvector<P> p;\n\t\tp.push_back(c[0].p);\n\t\tp.push_back(c[n-1].p);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\t\tvector<P> a = C_cp(c[i],c[j]);\n\t\t\t\tfor(int k = 0 ; k < a.size() ; k++)\n\t\t\t\t\tp.push_back(a[k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector< vector<pair<double,int> > > g(p.size());\n\t\t\n\t\tfor(int i = 0 ; i < p.size() ; i++){\n\t\t\tfor(int j = i+1 ; j < p.size() ; j++){\n\t\t\t\tvector<C> d;\n\t\t\t\tint minIdx = 1e9;\n\t\t\t\tint maxIdx = -1e9;\n\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\tif( distanceSP(L(p[i],p[j]),c[k].p) < c[k].r + EPS ){\n\t\t\t\t\t\tminIdx = min(minIdx,k);\n\t\t\t\t\t\tmaxIdx = max(maxIdx,k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint flag = true;\n\t\t\t\tfor(int k = minIdx ; k < maxIdx ; k++){\n\t\t\t\t\tvector<P> a = C_cp(c[k],c[k+1]);\n\t\t\t\t\tif( !intersectLL(L(p[i],p[j]),L(a[0],a[1])) || distanceSP(L(a[0],a[1]), crosspoint(L(p[i],p[j]),L(a[0],a[1]) ) ) > EPS || distanceSP(L(p[i],p[j]), crosspoint(L(p[i],p[j]),L(a[0],a[1]) ) ) > EPS ){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( flag ) {\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << abs(p[i]-p[j]) << \"{\" << minIdx << \" \" << maxIdx << endl;\n\t\t\t\t\tg[i].push_back(make_pair(abs(p[i]-p[j]),j));\n\t\t\t\t\tg[j].push_back(make_pair(abs(p[i]-p[j]),i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue< pair<double,int> > Q;\n\t\tvector<int> done(p.size(),0);\n\t\tQ.push(make_pair(0,0));\n\t\twhile(Q.size()){\n\t\t\tint qi = Q.top().second;\n\t\t\tdouble qcost = Q.top().first;\n\t\t\tQ.pop();\n\t\t\tif( done[qi]++) continue;\n\t\t\t//cout << qi << p[qi] << \" \" << -qcost << endl;\n\t\t\tif( qi == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",-qcost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < g[qi].size() ; i++)\n\t\t\t\tQ.push(make_pair(qcost-g[qi][i].first,g[qi][i].second));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Circle> Cir(n);\n\t\tPoint s, t;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tint x, y, r; cin >> x >> y >> r;\n\t\t\tif (i == 0)s = Point(x, y);\n\t\t\tif (i == n - 1) t = Point(x, y);\n\t\t\tCir[i] = Circle(Point(x, y), r);\n\t\t}\n\t\tvector<Point> ps;\n\t\tps.push_back(s);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tauto temp_p = is_cc(Cir[i - 1], Cir[i]);\n\t\t\tfor (auto p : temp_p) {\n\t\t\t\tps.push_back(p);\n\t\t\t}\n\t\t}\n\t\tps.push_back(t);\n\t\t/*for (auto p : ps) {\n\t\t\tcout << p << endl;\n\t\t}*/\n\t\tint Size = ps.size();\n\t\tvector<vector<ld>> dist(Size, vector<ld>(Size, INF));\n\t\t//vector<vector<int>> can_use(Size, vector<int>(Size, 0));\n\t\tfor (int i = 0; i < Size - 1;i++) {\n\t\t\tint idx;\n\t\t\tif (i == 0)idx = 1;\n\t\t\telse idx = 2 * ((i + 1) / 2) + 1;\n\t\t\tPoint v1 = ps[idx] - ps[i], v2 = ps[min(idx + 1, Size - 1)] - ps[i];\n\t\t\tld arg1 = arg(v1), arg2 = arg(v2);\n\t\t\tdist[i][idx] = abs(v1); dist[i][min(idx + 1, Size - 1)] = abs(v2);\n\t\t\t//can_use[i][idx] = can_use[i][min(idx + 1, Size - 1)] = 1;\n\t\t\t//cout << \"------------------------\" << endl;\n\t\t\tint f = 0;\n\t\t\tfor (int j = idx + 2; j < Size;j++) {\n\t\t\t\tif (f > 11)break;\n\t\t\t\tPoint v3 = ps[j] - ps[i];\n\t\t\t\tld arg3 = arg(v3);\n\t\t\t\tif (arg3 > arg1 || arg3 < arg2) { f++; continue; }\n\t\t\t\tf = 0;\n\t\t\t\tdist[i][j] = abs(v3); //can_use[i][j] = 1;\n\t\t\t\tif (j % 2 == 1) { arg1 = min(arg1, arg3); }\n\t\t\t\telse { arg2 = max(arg2, arg3); }\n\t\t\t\t//cout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Size;i++) {\n\t\t\tfor (int j = 0; j < Size;j++) {\n\t\t\t\tfor (int k = 0; k < Size;k++) {\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << dist[0][Size - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nstruct coord {\n\tdouble x, y;\n\tcoord() {}\n\tcoord(double a, double b) {\n\t\tx = a; y = b;\n\t}\n\tbool operator<(const coord & a) const {\n\t\treturn (sqr(x) + sqr(y)) < (a.sqr(x) + sqr(y));\n\t}\n};\n\nstruct circle {\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coord a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coord,coord> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coord,coord> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coord(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coord(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\treturn ret;\n}\n\nbool cross_lseg(coord a_start, coord a_end, coord b_start, coord b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\ndouble distance(coord a, coord b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coord,coord> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coord(v[0].x, v[0].y), coord(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coord,coord> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(pair<coord,coord>(coord(v[v.size() - 1].x, v[v.size() - 1].y), coord(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoord start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoord end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nstruct C{P p;D r;};\nPol ps;\nvector<int> qs;\nvector<L> ls;\nD eps=1e-9;\nD cro(P a,P b){return imag(conj(a)*b);}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(c-b)-abs(a-c))<eps) return -2;\n\treturn 2;\n}\nbool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nPol intCC(C a,C b){\n\tD d=abs(a.p-b.p);\n\tD theta=acos((a.r*a.r+d*d-b.r*b.r)/(2.0*a.r*d));\n\tPol ret;\n\tret.pb(a.p+(b.p-a.p)/d*polar(a.r,theta));\n\tret.pb(a.p+(b.p-a.p)/d*polar(a.r,-theta));\n\treturn ret;\n}\nD d[200][200],inf=1e9;\nC c[100];\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tps.clear();\n\t\tqs.clear();\n\t\tls.clear();\n\t\trep(i,N){\n\t\t\tint x,y,r;\n\t\t\tcin>>x>>y>>r;\n\t\t\tc[i]=C{P(x,y),r};\n\t\t}\n\t\tps.pb(c[0].p);\n\t\tqs.pb(0);\n\t\trep(i,N-1){\n\t\t\tPol h=intCC(c[i],c[i+1]);\n\t\t\trep(j,2) ps.pb(h[j]);\n\t\t\trep(j,2) qs.pb(i+1);\n\t\t\tls.pb(L(h[0],h[1]));\n\t\t}\n\t\tps.pb(c[N-1].p);\n\t\tqs.pb(N-1);\n\t\tint M=ps.size();\n\t\trep(i,M) for(int j=i+1;j<M;j++){\n\t\t\td[i][j]=d[j][i]=inf;\n\t\t\tL l=L(ps[i],ps[j]);\n\t\t\tbool can=true;\n\t\t\tfor(int k=qs[i];k<qs[j];k++){\n\t\t\t\tif(!iSS(l,ls[k])) can=0;\n\t\t\t}\n\t\t\tif(can){\n\t\t\t\td[i][j]=d[j][i]=abs(ps[i]-ps[j]);\n//\t\t\t\tprintf(\"d[%d][%d]=%.5f\\n\",i,j,d[i][j]);\n\t\t\t}\n\t\t}\n\t\trep(i,M) rep(j,M) rep(k,M) d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\tprintf(\"%.12f\\n\",d[0][M-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b-a) + EPS < abs(c-a) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(abs(a.first-b.first) < EPS ||\n     abs(a.first-b.second) < EPS ||\n     abs(a.second-b.first) < EPS ||\n     abs(a.second-b.second) < EPS) return true;\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\nP n_vector(P a){\n  //a????????????????????´?????????????????????\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nL cpcc(C a, C b){\n  //?????¨????????????\n  double d = abs(a.first-b.first), ra = a.second, rb = b.second;\n  double t = (ra*ra-rb*rb+d*d)/2/d, h = sqrt(ra*ra-t*t);\n  P m = t/abs(b.first-a.first)*(b.first-a.first)+a.first;\n  L cp;\n  P n = n_vector(a.first-b.first);\n  cp = L(m-n*h, m+n*h);\n  return cp;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x, y, r;\n    vector<C> Cs;\n    vector<L> cps;\n    vector<P> points;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y >> r;\n      Cs.push_back(make_pair(P(x,y),r));\n    }\n    points.push_back(Cs[0].first);\n    for(int i = 1; i < n; ++i){\n      L cp = cpcc(Cs[i],Cs[i-1]);\n      cps.push_back(cp);\n      points.push_back(cp.first);\n      points.push_back(cp.second);\n    }\n    points.push_back(Cs[n-1].first);\n    vector< vector<double> > dist(2*n,vector<double>(2*n,INF));\n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i; j < 2*n; ++j){\n\tif(i == j){\n\t  dist[i][j] = 0;\n\t  continue;\n\t}\n\tint s = min(max(0,i-1)/2,n-2), e = min(max(0,j-1)/2,n-2);\n\t//int s = (i-1)/2, e = (j-1)/2;\n\tbool f = true;\n\tfor(int k = s; k <= e; ++k){\n\t  if(!is_cross(L(points[i],points[j]), cps[k])){\n\t    //cout << points[i] << points[j] << cps[k].first << cps[k].second << endl;\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\tif(f){\n\t  dist[i][j] = abs(points[i]-points[j]);\n\t  dist[j][i] = abs(points[i]-points[j]);\n\t}\n      }\n    }\n    /*\n    for(int i = 0; i < 2*n; ++i)\n      for(int j = 0; j < 2*n; ++j)\n\tcout << dist[i][j] << endl;\n    */\n    \n\n    for(int k = 0; k < 2*n; ++k)\n      for(int i = 0; i < 2*n; ++i)\n\tfor(int j = 0; j < 2*n; ++j)\n\t  dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\n    printf(\"%.10f\\n\", dist[0][2*n-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n//num\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// point, line, circle\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X != b.X)? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// vector operation\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\n//utility\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //counter clockwise\n    if(cross(b,c) <-EPS) return -1; //clockwise\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nvoid crosspointCC(const C& a, const C& b, vector<P>& ps){\n    P ab = b.p-a.p;\n    double dist = abs(ab);\n    double l = ((a.r*a.r -b.r*b.r)/dist +dist) /2; //|am|/|ab|\n    double n = sqrt(a.r*a.r -l*l);\n    P mid = a.p + (ab)*(l/dist); //ab/dist: unit vector\n    P hei = ab *(n/dist) *P(0,1); //orthogonal to ab\n    ps.push_back(mid+hei);\n    ps.push_back(mid-hei);\n}\n\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        \n        vector<C> c;\n        for(int i=0; i<n; i++){\n            int x,y,r;\n            cin >> x >> y >> r;\n            c.push_back(C(P(x,y),r));\n        }\n\n        vector<P> cp;\n        cp.push_back(c[0].p);\n        for(int i=0; i<(int)c.size()-1; i++){\n            crosspointCC(c[i], c[i+1], cp);\n        }\n        cp.push_back(c[n-1].p);\n\n        //construct graph\n        vector<vector<double> > adj(2*n, vector<double>(2*n, INF));\n        for(int i=0; i<2*n; i++){\n            adj[i][i]=0;\n        }\n        for(int s=0; s<2*n; s++){\n            for(int e=s+1; e<2*n; e++){\n                bool flag=true;\n                for(int i=s+1; i<e; i++){\n                    if((i%2==1 && ccw(cp[s], cp[e], cp[i])==-1) ||\n                       (i%2==0 && ccw(cp[s], cp[e], cp[i])==+1)){\n                        flag=false;\n                        break;\n                    }\n                }\n                if(flag){\n                    double dist = abs(cp[s]-cp[e]);\n                    adj[s][e] = dist;\n                }\n            }\n        }\n\n        //search the minimum path with Dijkstra algorithm\n        priority_queue<pair<double, int> > wait;\n        vector<double> cost(2*n,INF);\n        cost[0] = 0.0;\n        wait.push(make_pair(0.0, 0));\n        while(!wait.empty()){\n            int nowpoint = wait.top().second;\n            double nowcost = -wait.top().first;\n            wait.pop();\n            if(cost[nowpoint] < nowcost){\n                continue;\n            }\n            for(int i=0; i<2*n; i++){\n                double nextcost = adj[nowpoint][i] + nowcost;\n                if(nextcost < cost[i]){\n                    cost[i]=nextcost;\n                    wait.push(make_pair(-nextcost, i));\n                }\n            }   \n        }\n\n        cout << fixed;\n        cout << setprecision(10);\n        cout << cost[2*n-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define mp(a,b) make_pair(a,b)\n#define SZ(a) ((int)(a).size())\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntypedef pair<int,int> PI;\ntypedef complex<double> pt;\n\nint n;\nint x[100],y[100],r[100];\n\n\n\nvector<pt> cross(int c1,int c2){\n  int dx=x[c1]-x[c2];\n  int dy=y[c1]-y[c2];\n  int rr=r[c1]+r[c2];\n  if(dx*dx+dy*dy> rr*rr) return vector<pt>();\n\n  /*\n     /|\\\n    /_|_\\\n    x1\n\n    r1*r1 -x1*x1 = r2*r2-(rr-x1)*(rr-x1) = r2*r2-rr*rr+2*rr*x1-x1*x1\n    r1*r1 = r2*r2-rr*rr+2*rr*x1\n    2*rr*x1=r1*r1-r2*r2+rr*rr\n    x1 = (r1*r1-r2*r2+rr*rr)/2/rr\n  */\n  int r1 = r[c1];\n  int r2 = r[c2];\n  double rrr = sqrt(dx*dx+dy*dy);\n  double x1 = (r1*r1-r2*r2+rrr*rrr)/2./rrr;\n  //cout << x1 << endl;\n  double dd=sqrt(dx*dx+dy*dy);\n  double mx = -dx/dd*x1 + x[c1];\n  double my = -dy/dd*x1 + y[c1];\n  \n  double diax = -dy;\n  double diay = dx;\n  \n  double y1 = sqrt(r1*r1-x1*x1);\n  vector<pt> ret;\n  ret.pb(pt(mx+diax/dd*y1,my+diay/dd*y1));\n  ret.pb(pt(mx-diax/dd*y1,my-diay/dd*y1));\n  \n  return ret;\n}\n\n\n#define ALL(a) (a).begin(),(a).end()\n\nbool can(pt a, pt b){\n  vector<pair<double,double> > check;\n  if(abs(b-a) < 1e-5) return true;\n  \n  rep(i,n){\n    pt c(x[i],y[i]);\n    pt ac = c-a;\n    pt v=(b-a);\n    double acv = ac.real()*v.real()+ac.imag()*v.imag();\n    double cc=norm(ac)-r[i]*r[i];\n    double aa=norm(v);\n    double bb=-2.*acv;\n    if(bb*bb-4.*aa*cc < 1e-4) continue;\n    double p1 = (-bb-sqrt(bb*bb-4.*aa*cc))/2./aa;\n    double p2 = (-bb+sqrt(bb*bb-4.*aa*cc))/2./aa;\n    if(p1 > 1 - 1e-5) continue;\n    if(p2 < 1e-5) continue;\n    //cout << \" \" << p1 << \" \" << p2 << endl;\n    p1=max(0.,p1);\n    p2=min(1.,p2);\n    check.pb(mp(p1,p2));\n  }\n  sort(ALL(check));\n  \n  double cur = 0;\n  FOR(it,check){\n    if(it->F > cur + 1e-8) return false;\n    cur = max(it->S,cur);\n  }\n  \n  return cur > 1-1e-8;\n}\n  \nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> r[i];\n  vector<pt> plist;\n  plist.pb(pt(x[0],y[0]));\n  plist.pb(pt(x[n-1],y[n-1]));\n  \n  rep(i,n-1){\n    vector<pt> t=cross(i,i+1);\n    rep(j,SZ(t)){\n      plist.pb(t[j]);\n      //cout << t[j].real() << \" \" << t[j].imag() << endl;\n    }\n  }\n\n  //can(pt(0,0),pt(5,4));\n  \n  //exit(0);\n  \n  priority_queue<pair<double,int> > q;\n  \n  q.push(mp(0,0));\n  vector<bool> vis(100000);\n  while(!q.empty()){\n    double cc = -q.top().F;\n    int cv = q.top().S;\n    q.pop();\n    if(vis[cv]) continue;\n    //cout << \" \" << plist[cv].real() << \" \" << plist[cv].imag() << \" \" << cc << endl;\n    vis[cv] = 1;\n    if(cv == 1){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }\n    \n    rep(j,SZ(plist)){\n      if(!vis[j] && can(plist[cv],plist[j]))\n        q.push(mp(-cc-abs(plist[cv]-plist[j]),j));\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <limits>\n#include <complex>\n#include <vector>\n#include <queue>\n#include <cmath>\n\n//#define _DEBUG\n//#ifdef _DEBUG\n//#endif\n\nusing namespace std;\n\ntypedef complex< double > Point;\ntypedef complex< double > Vector;\nconst double kEps = 1e-8;\nconst double kInf = numeric_limits< double >::max() / 2;\n\nstruct Circle {\n  Point cntr;\n  double r;\n\n  friend istream & operator >> (istream &is, Circle &rc) {\n    double x, y;\n    is >> x >> y >> rc.r, rc.cntr = Point(x, y);\n    return is;\n  }\n};\n\nstruct PQNode {\n  int u;\n  double cst;\n\n  PQNode(int _u, double _cst) { u = _u, cst = _cst; }\n  bool operator > (const PQNode &rpq) const { return cst > rpq.cst + kEps; }\n};\n\ntypedef priority_queue< PQNode, vector< PQNode >, greater< PQNode > > PQue;\n\nstruct Edge {\n  int v, nxt;\n  double ln;\n} edges[100000];\n\nint N, S, T;\nCircle crc[105];\nPoint p[210];\nint gph[210], edge_cnt;\ndouble f[210];\n\nvoid read_circle(void);\nvoid build_graph(void);\nvoid solve(void);\nbool is_intr(Point, Point, Point, Point);\nvoid add_edge(int, int, double);\n\ninline bool fle(double a, double b) { return a < b + kEps; }\ninline bool flt(double a, double b) { return a + kEps < b; }\ninline double cross(Vector u, Vector v) { return imag(conj(u) * v); }\n\nint main() {\n  cout.setf(ios::fixed), cout.precision(4);\n  while (cin >> N, N) {\n    read_circle();\n    build_graph();\n    solve();\n  }\n\n  return 0;\n}\n\nvoid read_circle(void) {\n  for (int i = 0; i < N; ++i)\n    cin >> crc[i];\n}\n\nvoid build_graph(void) {\n  for (int i = 0; i < N - 1; ++i) {\n    Point &c1 = crc[i].cntr, &c2 = crc[i + 1].cntr;\n    double r1 = crc[i].r, r2 = crc[i + 1].r, d, cos_tht;\n\n    d = abs(c2 - c1);\n    cos_tht = (r1 * r1 + d * d - r2 * r2) / (2 * r1 * d);\n\n    Vector rv1, rv2, u1, u2;\n\n    rv1 = Vector(cos_tht, sqrt(1 - cos_tht * cos_tht));\n    rv2 = Vector(cos_tht, -sqrt(1 - cos_tht * cos_tht));\n    u1 = u2 = c2 - c1;\n    u1 = u1 * rv1 * r1 / d, u2 = u2 * rv2 * r1 / d;\n\n    p[2 * i] = c1 + u1, p[2 * i + 1] = c1 + u2;\n\n#ifdef _DEBUG\n  cout << 2 * i << \": \" << p[2 * i] << endl;\n  cout << 2 * i + 1 << \": \" << p[2 * i + 1] << endl;\n#endif\n  }\n  p[S = 2 * (N - 1)] = crc[0].cntr, p[T = 2 * (N - 1) + 1] = crc[N - 1].cntr;\n\n  bool is_valid;\n\n  fill(&gph[0], &gph[2 * N], -1), edge_cnt = 0;\n  for (int i = 0; i < 2 * (N - 1); ++i) {\n    is_valid = true;\n    for (int j = 0; j < i / 2 && is_valid; ++j)\n      if (!is_intr(p[S], p[i], p[2 * j], p[2 * j + 1]))\n        is_valid = false;\n    if (is_valid)\n      add_edge(S, i, abs(p[i] - p[S]));\n  }\n\n  for (int i = 0; i < 2 * (N - 1); ++i) {\n    is_valid = true;\n    for (int j = i / 2 + 1; j < N - 1 && is_valid; ++j)\n      if (!is_intr(p[i], p[T], p[2 * j], p[2 * j + 1]))\n        is_valid = false;\n    if (is_valid)\n      add_edge(i, T, abs(p[T] - p[i]));\n  }\n\n  for (int i = 0; i < 2 * (N - 1); ++i)\n    for (int j = i + 1; j < 2 * (N - 1); ++j) {\n      is_valid = true;\n      for (int k = i / 2 + 1; k < j / 2 && is_valid; ++k)\n        if (!is_intr(p[i], p[j], p[2 * k], p[2 * k + 1]))\n          is_valid = false;\n      if (is_valid)\n        add_edge(i, j, abs(p[j] - p[i]));\n    }\n\n  is_valid = true;\n  for (int i = 0; i < N - 1 && is_valid; ++i)\n    if (!is_intr(p[S], p[T], p[2 * i], p[2 * i + 1]))\n      is_valid = false;\n  if (is_valid)\n    add_edge(S, T, abs(p[T] - p[S]));\n\n#ifdef _DEBUG\n  for (int u = 0; u < 2 * N; ++u) {\n    cout << \"u = \" << u << endl;\n    for (int eid = gph[u]; eid != -1; eid = edges[eid].nxt) {\n      int v = edges[eid].v;\n      double ln = edges[eid].ln;\n      cout << \"  v = \" << v << \", ln = \" << ln << endl;\n    }\n  }\n#endif\n}\n\nvoid solve(void) {\n  PQue pq;\n  double res = 0;\n\n  fill(&f[0], &f[2 * N], kInf), f[S] = 0, pq.push(PQNode(S, 0));\n  while (!pq.empty()) {\n    PQNode tp(pq.top());  pq.pop();\n    int u = tp.u;\n    double cst = tp.cst;\n\n    if (flt(f[u], cst)) continue;\n    if (u == T) { res = cst;  break; }\n\n    for (int eid = gph[u]; eid != -1; eid = edges[eid].nxt) {\n      int v = edges[eid].v;\n      double ln = edges[eid].ln;\n\n      if (flt(f[u] + ln, f[v]))\n        f[v] = f[u] + ln, pq.push(PQNode(v, f[v]));\n    }\n  }\n\n  cout << res << endl;\n}\n\nbool is_intr(Point p1, Point p2, Point p3, Point p4) {\n  return (fle(min(real(p3), real(p4)), max(real(p1), real(p2))) &&\n          fle(min(real(p1), real(p2)), max(real(p3), real(p4))) &&\n          fle(min(imag(p3), imag(p4)), max(imag(p1), imag(p2))) &&\n          fle(min(imag(p1), imag(p2)), max(imag(p3), imag(p4))) &&\n          fle(cross(p3 - p1, p3 - p4) * cross(p3 - p2, p3 - p4), 0) &&\n          fle(cross(p1 - p3, p1 - p2) * cross(p1 - p4, p1 - p2), 0)\n          );\n}\n\nvoid add_edge(int u, int v, double ln) {\n  Edge &r1 = edges[edge_cnt], &r2 = edges[edge_cnt + 1];\n  r1.v = v, r1.ln = ln, r1.nxt = gph[u], gph[u] = edge_cnt;\n  r2.v = u, r2.ln = ln, r2.nxt = gph[v], gph[v] = edge_cnt + 1;\n  edge_cnt += 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\nbool operator<(const Point &lhs, const Point &rhs) {\n  if (lhs.real() < rhs.real() - eps) return true;\n  if (lhs.real() > rhs.real() + eps) return false;\n  return lhs.imag() < rhs.imag();\n}\n}  // namespace std\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) { return (abs(a - b) < eps); }\n//内積\nld dot(Point a, Point b) { return real(conj(a) * b); }\n//外積\nld cross(Point a, Point b) { return imag(conj(a) * b); }\n\nclass Line {\n public:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\n public:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\n// 3点の位置関係\nint ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > eps) return 1;    // a,b,cで反時計周り\n  if (cross(b, c) < -eps) return -1;  // a,b,cで時計周り\n  if (dot(b, c) < 0) return 2;        // c,a,bで直線\n  if (norm(b) < norm(c)) return -2;   // a,b,cで直線\n  return 0;                           // a,c,bで直線\n}\n\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n\nbool isis_ls(Line l, Line s) {\n  return isis_ll(l, s) &&\n         (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n\nbool isis_sp(Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) { return abs(p - proj(l, p)); }\n\nld dist_ll(Line l, Line m) { return isis_ll(l, m) ? 0 : dist_lp(l, m.a); }\n\nld dist_ls(Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min(\n      {dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps)\n    dfr = 0.0;\n  else if (dfr < 0.0)\n    return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps) {\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l) {\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) {\n    return ret;\n  }\n  Point v1 = v * Point(l / d, c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  } else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0, 1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j, n) res += cross(p[j], p[(j + 1) % n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i, n) {\n    Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i, n) {\n    Point a = poly[i], b = poly[(i + 1) % n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i, n) {\n    Point A = ps[i], B = ps[(i + 1) % n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps)\n    if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge {\n  int from, to;\n  Weight weight;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i, m) {\n    vector<pair<ld, int>> vec;\n    REP(j, n) if (isis_sp(s[i], p[j])) vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j, vec.size() - 1) {\n      int from = vec[j].second, to = vec[j + 1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i, m) {\n    vector<pair<ld, int>> vec;\n    REP(j, n)\n    if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j, vec.size() - 1) {\n      int from = vec[j].second, to = vec[j + 1].second;\n      ld angle = vec[j + 1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld, int, bool>>> tup(N);\n  REP(i, s.size()) {\n    int a = -1, b = -1;\n    REP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i, N) sort(ALL(tup[i]));\n  REP(i, N) {\n    REP(j, tup[i].size()) {\n      ld angle;\n      int pos = j, from = i, to;\n      bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to;\n        tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i, N) REP(j, i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p), cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<Circle> Curls(n);\n    for (int i = 0; i < n; ++i) {\n      int x, y;\n      cin >> x >> y;\n      Point p(x, y);\n      int r;\n      cin >> r;\n      Curls[i] = Circle(p, r);\n    }\n    vector<Line> ls;\n    ls.push_back(Line(Curls[0].p, Curls[0].p));\n    for (int i = 0; i < n - 1; ++i) {\n      auto l = is_cc(Curls[i], Curls[i + 1]);\n      ls.push_back(Line(l[0], l[1]));\n    }\n    ls.push_back(Line(Curls[n - 1].p, Curls[n - 1].p));\n    vector<vector<ld>> dist(2 * n + 2, vector<ld>(2 * n + 2, 1e9));\n    for (int i = 0; i < (n + 1) * 2; ++i) {\n      for (int j = i + 1; j < (n + 1) * 2; ++j) {\n        Line s;\n        if (i % 2 == 0 && j % 2 == 0)\n          s = Line(ls[i / 2].a, ls[j / 2].a);\n        else if (i % 2 && j % 2)\n          s = Line(ls[i / 2].b, ls[j / 2].b);\n        else if (i % 2 == 0 && j % 2)\n          s = Line(ls[i / 2].a, ls[j / 2].b);\n        else if (i % 2 && j % 2 == 0)\n          s = Line(ls[i / 2].b, ls[j / 2].a);\n        bool flag = 1;\n        for (int k = i / 2 + 1; k < j / 2; ++k) {\n          if (isis_ss(s, ls[k]) == 0) {\n            flag = 0;\n            break;\n          }\n        }\n        Point c = s.a - s.b;\n        if (flag) dist[i][j] = sqrtl(c.imag() * c.imag() + c.real() * c.real());\n      }\n    }\n    for (int k = 0; k < 2 * n + 2; ++k) {\n      for (int i = 0; i < 2 * n + 2; ++i) {\n        for (int j = 0; j < 2 * n + 2; ++j) {\n          if (dist[i][j] > dist[i][k] + dist[k][j]) {\n            dist[i][j] = dist[i][k] + dist[k][j];\n          }\n        }\n      }\n    }\n    cout << fixed << setprecision(6) << dist[0][2 * n + 1] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\nconst double eps=1e-8;\nconst double inf=1e12;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return abs(a.X-b.X)<eps?a.Y<b.Y:a.X<b.X;\n  }\n}\n\ndouble cross(P a,P b){return (conj(a)*b).Y; }\ndouble dot(P a,P b){return (conj(a)*b).X; }\n\nstruct L : public vector<P>\n{\n  L(const P& a,const P& b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nstruct C\n{\n  P p; double r;\n  C(const P& p,double r):p(p),r(r){}\n};\n\nint ccw(P a,P b,P c){\n  b=b-a; c=c-a;\n  if(cross(b,c)>0)return +1;\n  if(cross(b,c)<0)return -1;\n  if(dot(b,c)>0)return +2;\n  if(norm(b)>norm(c))return -2;\n  return 0;\n}\n\nbool intersectSS(L s,L t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\npair<P,P> crosspointCC(C c1,C c2){\n  P p1=c1.p,p2=c2.p;\n  double r1=c1.r,r2=c2.r;\n  P A=conj(p2-p1),B=(r2*r2-r1*r1-(p2-p1)*conj(p2-p1)),C=r1*r1*(p2-p1);\n  P D1=B*B-(double)4.0*A*C;\n  P z1=(-B+sqrt(D1))/((double)2.0*A)+p1,z2=(-B-sqrt(D1))/((double)2.0*A)+p1;\n  if(z2<z1)swap(z1,z2);\n  return pair<P,P>(z1,z2);\n}\n\nint n;\ndouble dist[222][222];\nvector<C> cs;\nvector<L> ls;\nvector<P> ps;\n\nint main(void) {\n  while(1) {\n    cin>>n;\n    if(n==0)break;\n    cs.clear(); ps.clear(); ls.clear();\n    rep(i,n){\n      double x,y,r;\n      cin>>x>>y>>r;\n      cs.push_back(C(P(x,y),r));\n    }\n    ps.push_back(cs[0].p);\n    rep(i,n-1){\n      pair<P,P> cp=crosspointCC(cs[i],cs[i+1]);\n      ps.push_back(cp.first); ps.push_back(cp.second);\n      ls.push_back(L(cp.first,cp.second));\n    }\n    ps.push_back(cs[n-1].p);\n    int m=ps.size();\n    int lsize=ls.size();\n    rep(i,222)rep(j,222)dist[i][j]=i==j?0:inf;\n    rep(i,m)repl(j,i+1,m){\n      L tmp=L(ps[i],ps[j]);\n      bool ok=true;\n      repl(k,(i+1)/2,min(lsize,(j-1)/2)){\n        if(!intersectSS(tmp,ls[k]))ok=false;\n      }\n      if(ok){\n        dist[i][j]=min(dist[i][j],abs(ps[i]-ps[j]));\n      }\n    }\n    /*\n    rep(i,m)rep(j,m){\n      printf(\"%.3f %c\", dist[i][j]==inf?-1:dist[i][j],j==m-1?'\\n':'\\t');\n    }*/\n    rep(k,m)rep(i,m)rep(j,m)dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    printf(\"%.10f\\n\", dist[0][m-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\tif(p<0 || q<0) return BORDER;\n\t\treturn p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.emplace_back(c, c);\n\t\t\telse{\n\t\t\t\ts.push_back(cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.emplace_back(prev, prev);\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.4f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-12;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n//int index(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;\t//counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;\t\t//c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;\t\t\t\t\t\t\t//a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - s.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\n\nbool isis_cl(Circle c, Line l)\n{\n\tdouble d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\n\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\n\nint main()\n{\n\tint n;;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<Circle> cs;\n\t\tREP(i, n)\n\t\t{\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tcs.push_back(Circle(Point(x, y), r));\n\t\t}\n\t\tvector<vector<Point>> ps(n + 1);\n\t\tps[0].push_back(cs[0].p);\n\t\tps[n].push_back(cs.back().p);\n\t\tFOR(i,1, n)\n\t\t{\n\t\t\tps[i] = is_cc(cs[i - 1], cs[i]);\n\t\t}\n\t\tdouble wf[250][250];\n\t\tREP(i, n * 2)REP(j, n * 2) wf[i][j] = (i == j ? 0 : INF);\n\t\tREP(i, ps.size())FOR(j, i + 1, ps.size())REP(k, ps[i].size())REP(l, ps[j].size())\n\t\t{\n\t\t\tLine tmp(ps[i][k], ps[j][l]);\n\t\t\tbool f = true;\n\t\t\tFOR(m, i + 1, j)\n\t\t\t{\n\t\t\t\tLine tmpl(ps[m][0], ps[m][1]);\n\t\t\t\tif (!isis_ss(tmp, tmpl)) f = false;\n\t\t\t}\n\t\t\tint L = i * 2 - k;\n\t\t\tint R = j * 2 - l;\n\t\t\tif (i == 0) L = 0;\n\t\t\tif (j == ps.size() - 1) R = 2 * n - 1;\n\n\t\t\tif (f) wf[L][R] = wf[R][L] = abs(ps[i][k] - ps[j][l]);\n\t\t}\n\t\tREP(k, 2 * n)REP(i, 2 * n)REP(j, 2 * n)\n\t\t\tchmin(wf[i][j], wf[i][k] + wf[k][j]);\n\t\tcout << D10 << wf[0][2 * n - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ld INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nstruct Point {\n  ld x, y;\n\n  Point(ld x = 0, ld y = 0): x(x), y(y) {}\n\n  Point operator + (Point &p) {\n    return Point(x + p.x, y + p.y);\n  }\n\n  Point operator - (Point &p) {\n    return Point(x - p.x, y - p.y);\n  }\n\n  Point operator * (ld k) {\n    return Point(x * k, y * k);\n  }\n\n  Point operator / (ld k) {\n    return Point(x / k, y / k);\n  }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\nld norm(Point p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nld dist(Point p) {\n  return sqrt(norm(p));\n}\n\nld dot(Point p1, Point p2) {\n  return p1.x * p2.x + p1.y * p2.y;\n}\n\nld cross(Point p1, Point p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\nPoint rotate(Point p, ld theta) {\n  return Point(p.x * cos(theta) - p.y * sin(theta), p.x * sin(theta) + p.y * cos(theta));\n}\n\n//1:反時計回り\n//-1:時計回り\n//2:p2, p0, p1の順で同一直線上\n//-2:p0, p1, p2の順\n//0:p2が線分p0, p1上\nint ccw(Point p0, Point p1, Point p2) {\n  Point v1 = p1 - p0, v2 = p2 - p0;\n  if (cross(v1, v2) > 0) return 1;\n  else if (cross(v1, v2) < 0) return -1;\n  else if (dot(v1, v2) < 0) return 2;\n  else if (norm(v1) < norm(v2)) return -2;\n  else return 0;\n}\n\n//線分p1, p2がp3, p4と交差するか\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n//直線p2-p1と点p3の距離\nld getDistanceLP(Point p1, Point p2, Point p3) {\n  return fabs(cross(p2-p1, p3-p1) / dist(p2-p1));\n}\n\n//線分s(p2-p1)と点p3の距離\nld getDistanceSP(Point p1, Point p2, Point p3) {\n  if (dot(p2-p1, p3-p1) < 0) return dist(p3-p1);\n  else if (dot(p1-p2, p3-p2) < 0) return dist(p3-p2);\n  else return getDistanceLP(p1, p2, p3);\n}\n\n//線分s1(p2-p1)と線分s2(p4-p3)の距離\nld getDistanceTS(Point p1, Point p2, Point p3, Point p4) {\n  if (intersect(p1, p2, p3, p4)) return 0;\n  ld ans = INF;\n  ans = min(ans, getDistanceSP(p1, p2, p3));\n  ans = min(ans, getDistanceSP(p1, p2, p4));\n  ans = min(ans, getDistanceSP(p3, p4, p1));\n  ans = min(ans, getDistanceSP(p3, p4, p2));\n  return ans;\n}\n\nvector<Point> convex_hull(vector<Point>& ps, int n) {\n  sort(ps.begin(), ps.end());\n  int k = 0;\n  vector<Point> qs(2 * n);\n  rep(i, n) {\n    while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for (int i = n - 2, t = k; i >= 0; i--) {\n    while (k > t && (cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) <= 0)) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\n//円\nstruct Circle {\n  Point p;\n  ld r;\n\n  Circle() {}\n  Circle(Point p, ld r): p(p), r(r) {}\n};\n\n//２円の交点\narray<Point, 2> getIntersections(Circle c1, Circle c2) {\n  ld d = dist(c2.p - c1.p);\n  ld rc = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * d);\n  ld rs = sqrt(c1.r * c1.r - rc * rc);\n  Point e1 = (c2.p - c1.p) / d;\n  Point e2 = rotate(e1, M_PI / 2) * rs;\n  Point e3 = rotate(e1, -M_PI / 2) * rs;\n  e1 = e1 * rc;\n  Point a = c1.p + e1 + e2;\n  Point b = c1.p + e1 + e3;\n  return {a, b};\n}\n\nint n;\nCircle c[105];\n\nPoint p[205];\nld d[205][205];\n\nvoid init() {\n  rep(i, 205) rep(j, 205) d[i][j] = INF;\n  rep(i, 205) d[i][i] = 0;\n}\n\nbool check(Point p1, Point p2, int s, int t) {\n  FOR(i, s, t) {\n    if (!intersect(p1, p2, p[i * 2], p[i * 2 + 1])) return false;\n  }\n  return true;\n}\n\nvoid solve() {\n  rep(i, n - 1) {\n    array<Point, 2> a = getIntersections(c[i], c[i + 1]);\n    rep(j, 2) p[i * 2 + j] = a[j];\n  }\n  int s = n * 2 - 2, t = s + 1;\n  p[s] = c[0].p;\n  p[t] = c[n - 1].p;\n  rep(i, s) {\n    rep(j, i) {\n      if (check(p[i], p[j], j / 2, i / 2)) {\n        d[i][j] = d[j][i] = dist(p[i] - p[j]);\n      }\n    }\n  }\n  rep(i, s) {\n    if (check(p[s], p[i], 0, i / 2)) {\n      d[s][i] = d[i][s] = dist(p[s] - p[i]);\n    }\n    if (check(p[i], p[t], i / 2, n - 1)) {\n      d[i][t] = d[t][i] = dist(p[i] - p[t]);\n    }\n  }\n  if (check(p[s], p[t], 0, n - 1)) {\n    d[s][t] = d[t][s] = dist(p[s] - p[t]);\n  }\n  rep(k, t + 1) {\n    rep(i, t + 1) {\n      rep(j, t + 1) {\n        chmin(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n  cout << d[s][t] << '\\n';\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (cin >> n, n) {\n    init();\n\n    rep(i, n) {\n      cin >> c[i].p.x >> c[i].p.y >> c[i].r;\n    }\n\n    solve();\n  }\n\n  \n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nconst double eps = 1e-6;\ndouble sq(double x) { return pow(x, 2); }\n\nstruct point { double y, x; };\nstruct circle { point p; double r; };\nstruct segment { point s, t; };\n\npoint operator + (point a, point b) { return (point) { a.y + b.y, a.x + b.x }; }\npoint operator - (point a, point b) { return (point) { a.y - b.y, a.x - b.x }; }\npoint operator * (point a, double b) { return (point) { a.y * b, a.x * b }; }\npoint operator / (point a, double b) { return (point) { a.y / b, a.x / b }; }\nbool operator < (point a, point b) { return make_pair(a.y, a.x) < make_pair(b.y, b.x); }\ndouble distance(point a, point b) { return sqrt(sq(a.y - b.y) + sq(a.x - b.x)); }\ndouble   dot(point a, point b) { return a.x * b.x + a.y * b.y; }\ndouble cross(point a, point b) { return a.x * b.y - a.y * b.x; }\nint ccw(point a, point b, point c) { double z = cross(b - a, c - a); return z > eps ? 1 : z < - eps ? -1 : 0; }\nbool does_intersect(segment const & a, segment const & b){\n    return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <= 0 and\n           ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\n}\n\nsegment intersections(circle c1, circle c2) {\n    double a = c1.r;\n    double b = c2.r;\n    double c = distance(c1.p, c2.p);\n    double x = (sq(a) - sq(b) + sq(c)) / (2 * c);\n    double y = sqrt(sq(a) - sq(x));\n    point e = (c2.p - c1.p) / c;\n    point center = e * x + c1.p;\n    point f = { e.x, - e.y };\n    point p = center + f * y;\n    point q = center - f * y;\n    return { p, q };\n}\n\nint main() {\n    while (true) {\n        // input\n        int n; scanf(\"%d\", &n);\n        if (n == 0) break;\n        vector<circle> c(n);\n        repeat (i, n) {\n            scanf(\"%lf%lf%lf\", &c[i].p.x, &c[i].p.y, &c[i].r);\n        }\n        // solve\n        vector<segment> gate(n - 1);\n        repeat (i, n - 1) {\n            gate[i] = intersections(c[i], c[i+1]);\n        }\n        vector<point> p(2 * n);\n        const int src = 2 * (n - 1);\n        const int dst = 2 * (n - 1) + 1;\n        repeat (i, n - 1) {\n            p[2 * i    ] = gate[i].s;\n            p[2 * i + 1] = gate[i].t;\n        }\n        p[src] = c[0].p;\n        p[dst] = c[n - 1].p;\n        vector<vector<pair<int, double> > > g(2 * n);\n        auto is_valid = [&](segment a, int l, int r) { // [l, r)\n            repeat_from (i, l, r) {\n                if (not does_intersect(a, gate[i])) return false;\n            }\n            return true;\n        };\n        repeat (l, n - 1) {\n            for (int i : { 2 * l, 2 * l + 1 }) {\n                repeat_from (r, l + 1, n - 1) { // [l, r]\n                    for (int j : { 2 * r, 2 * r + 1 }) {\n                        if (is_valid((segment) { p[i], p[j] }, l + 1, r)) {\n                            g[i].emplace_back(j, distance(p[i], p[j]));\n                        }\n                    }\n                }\n                if (is_valid((segment) { p[src], p[i] }, 0, l)) {\n                    g[src].emplace_back(i, distance(p[src], p[i]));\n                }\n                if (is_valid((segment) { p[i], p[dst] }, l + 1, n - 1)) {\n                    g[i].emplace_back(dst, distance(p[i], p[dst]));\n                }\n            }\n        }\n        if (is_valid((segment) { p[src], p[dst] }, 0, n - 1)) {\n            g[src].emplace_back(dst, distance(p[src], p[dst]));\n        }\n        auto dist = vectors(2 * n, 2 * n, INFINITY);\n        repeat (i, 2 * n) {\n            dist[i][i] = 0;\n            for (auto e : g[i]) {\n                int j; double d; tie(j, d) = e;\n                dist[i][j] = d;\n            }\n        }\n        repeat (k, 2 * n) repeat (i, 2 * n) repeat (j, 2 * n) { // Warshall-Floyd\n            setmin(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n        printf(\"%.10lf\\n\", dist[src][dst]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\t//for \"greater<type>\"\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//tentative\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n//Don't change because there are many \"x\"s, and \"y\"s in other uses.\n#define X real()\t//for complex\n#define Y imag()\t//for complex\n\ntypedef complex<double> point;//changed\ntypedef point vec;//changed\ntypedef array<point, 2> line;//changed\ntypedef vector<point> poly;//changed\n\nstruct circle {//changed\n\tpoint c;\n\tdouble r;\n};\n\nenum geometry {ABC=-2, CW, ACB, CCW, CAB, ON_LINE, OUTSIDE, INSIDE, ERROR};//Each means collinear(order: a-b-c), clockwise, collinear, counter clockwise,collinear, etc. Remember that ERROR means 2 of the 3 points are duplicate.//changed\n\nnamespace std {\n\tbool operator<(point a, point b) {\n\t\tif (!EQ(a.X, b.X)) return a.X < b.X;\n\t\tif (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n\t\treturn false;\n\t}\n\n\tbool operator>(point a, point b) {\n\t\treturn b<a;\n\t}\n\n\tbool operator<=(point a, point b) {\n\t\treturn !(a>b);\n\t}\n}\n\ndouble dot(point a, point b) {\n\treturn (conj(a)*b).X;\n}\n\ndouble cross(point a, point b) {\n\treturn (conj(a)*b).Y;\n}\n\ngeometry ccw(point a, point b, point c) {//changed\n\ta -= b;\n\tc -= b;\n\tif (cross(a, c) > EPS) return CCW;//counter clockwise\n\tif (cross(a, c) < -EPS) return CW;//clockwise\n\tif (dot(a, c) < -EPS) return ABC;//collinear (order: a - b - c)\n\n\tdouble al = abs(a);\n\tdouble cl = abs(c);\n\t//error: 2 of a, b, and c are duplicate.\n\tif (EQ(al, cl)) return ERROR;//At least a, and c are duplicate.\n\tif (EQ(min(al, cl), 0)) return ERROR;\n\tif (al < cl) return CAB;//collinear (order: c - a - b)\n\telse return ACB;//collinear (order: a - c - b)\n}\n\npoint proj(line l, point p) {\n\tpoint v = l[1]-l[0];\n\tdouble ratio = dot(v, p-l[0]) / norm(v);\n\treturn l[0] + ratio*v;\n}\n\npoint refl(line l, point p) {\n\treturn p + (proj(l, p) - p) * 2.0;\n}\n\nvec rotate(vec v, double r) {\n\treturn v*vec(cos(r), sin(r));\n}\n\n//Get a normal vector (??????????????????).\nvec Normalvec(line l){//changed (added)\n\tvec v=(vec)l[1]-l[0];\n\treturn vec (v.Y,-v.X);\n}\n\nbool IsOrthogonal(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(line l, line m) {\n\tvec v1 = l[1]-l[0];\n\tvec v2 = m[1]-m[0];\n\treturn EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(line l, line m) {\n\tif (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n\tif (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n\treturn false;\n}\n\nbool IntersectLS(line l, line s) {//This outputs true if l includes an endpoint of s.\n\tpoint b = l[0];\n\tvec v = l[1]-l[0];\n\treturn cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(line s, line t) {\n\t// hard coding: CW := -1, CCW := 1 -> Only CW*CW and CCW*CCW are equal to 1\n\tif (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) == 1) return false;\n\tif (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) == 1) return false;\n\tif (!IsParallel(s, t)) return true;\n\tif (max(s[0], s[1]) < min(t[0], t[1])) return false;\n\tif (max(t[0], t[1]) < min(s[0], s[1])) return false;\n\treturn true;\n}\n\nbool IntersectLP(line l, point p) {\n\treturn EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(line s, point p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(line l) {\n\treturn abs(l[0]-l[1]);\n}\n\ndouble DistLP(line l, point p) {\n\treturn abs(p - proj(l, p));\n}\n\ndouble DistLL(line l, line m) {\n\tif (!IntersectLL(l, m)) return 0;\n\treturn DistLP(l, m[0]);\n}\n\ndouble DistLS(line l, line s) {\n\tif (IntersectLS(l, s)) return 0;\n\treturn min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(line s, point p) {\n\tpoint r = proj(s, p);\n\tif (IntersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(line s, line t) {\n\tif (IntersectSS(s, t)) return 0;\n\n\tdouble a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n\tdouble b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n\treturn min(a, b);\n}\n\nline PerpendBisect(line seg) {//?????´????????????\n\tpoint mid = (seg[0]+seg[1])/2.0;\n\treturn line{mid, mid+(seg[1]-seg[0])*vec(0, 1)};\n}\n\npoint CrosspointLL(line l, line m) {\n\tdouble A = cross(l[1]-l[0], m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0], l[1]-m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\tif (abs(A) < EPS) assert(0);\n\treturn m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<point> CrosspointCL(circle c, line l) {\n\tvector<point> ret;\n\tdouble d = DistLP(l, c.c);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(proj(l, c.c));\n\t} else if (d < c.r) {\n\t\tdouble ratio = sqrt(c.r*c.r - d*d);\n\t\tvec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n\t\tret.emplace_back(proj(l, c.c) + ratio*sgn);\n\t\tret.emplace_back(proj(l, c.c) - ratio*sgn);\n\t}\n\n\treturn ret;\n}\n\nvector<point> CrosspointCS(circle c, line s) {\n\tvector<point> ret;\n\tvector<point> res = CrosspointCL(c, s);\n\tif (s[0] > s[1]) swap(s[0], s[1]);\n\tfor (point p : res) {\n\t\tif (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n\t}\n\treturn ret;\n}\n\nvector<point> CrosspointCC(circle c1, circle c2) {\n\tvector<point> ret;\n\tdouble d = abs(c1.c - c2.c);\n\tdouble rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n\tdouble dfr = c1.r*c1.r - rc*rc;\n\n\tif (EQ(dfr, 0.0)) dfr = 0.0;\n\telse if(dfr < 0.0) return ret;\n\n\tdouble rs = sqrt(dfr);\n\tvec sgn = (c2.c - c1.c) / d;\n\tret.emplace_back(c1.c + sgn*point(rc, rs));\n\tif (dfr > 0.0) ret.emplace_back(c1.c + sgn*point(rc, -rs));\n\treturn ret;\n}\n\ngeometry Positioningpoint(poly poly, point p) {\n\tbool in = false;\n\tint n = poly.size();\n\tfor (int i=0; i<n; i++) {\n\t\tpoint a = poly[i];\n\t\tpoint b = poly[(i+1)%n];\n\t\tvec u = a - p;\n\t\tvec v = b - p;\n\n\t\tif (u.Y > v.Y) swap(u, v);\n\n\t\tdouble cr = cross(u, v);\n\t\tif (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n\t\tif (IntersectSP({a, b}, p)) return ON_LINE;\n\t}\n\n\tif (in) return INSIDE;\n\treturn OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\npoly GrahamScan(vector<point> ps) {\n\tif (ps.size() <= 2) return ps;\n\n\tint k = 0;\n\tint n = ps.size();\n\tpoly ret(n*2);\n\n\tsort(ps.begin(), ps.end());\n\tfor (int i=0; i<n; i++) {\n\t\twhile (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tint k_ = k;\n\tfor (int i=n-1; i>=0; i--) {\n\t\twhile (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n\t\tret[k++] = ps[i];\n\t}\n\n\tret.resize(k-1);\n\treturn ret;\n}\n\nbool IsConvex(poly ps) {\n\treturn GrahamScan(ps).size() == ps.size();\n}\n\npoly CapConvexes(poly pp, poly qq) {\n#if DEBUG\n\tassert (IsConvex(pp));\n\tassert (IsConvex(qq));\n#endif\n\n\tpoly ret;\n\tint a = 0;\n\tint b = 0;\n\tint aa = 0;\n\tint bb = 0;\n\tint n = pp.size();\n\tint m = qq.size();\n\tenum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n\tauto forward_a = [&](bool put) {\n\t\tif (put && in == PIN) ret.emplace_back(pp[a]);\n\t\ta = (a+1)%n;\n\t\taa++;\n\t};\n\n\tauto forward_b = [&](bool put) {\n\t\tif (put && in == QIN) ret.emplace_back(qq[b]);\n\t\tb = (b+1)%m;\n\t\tbb++;\n\t};\n\n\tauto intersect_1pt = [](point &a, point &b, point &c, point &d, point &r) {\n\t\tdouble D =\tcross(b - a, d - c);\n\t\tif (EQ(D, 0)) return false;\n\t\tdouble t =\tcross(c - a, d - c) / D;\n\t\tdouble s = -cross(a - c, b - a) / D;\n\t\tr = a + t * (b - a);\n\t\treturn GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n\t};\n\n\tdo {\n\t\tint apre = (a+n-1)%n;\n\t\tint bpre = (b+m-1)%m;\n\t\tdouble C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n\t\tdouble A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n\t\tdouble B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n\t\tpoint r;\n\t\tif (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n\t\t\tif (in == UNKNOWN) aa = bb = 0;\n\t\t\tret.emplace_back(r);\n\t\t\tif (B > 0) in = PIN;\n\t\t\telse if (A > 0) in = QIN;\n\t\t}\n\n\t\tif (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n\t\t\tif (in == PIN) forward_b(false);\n\t\t\telse forward_a(false);\n\t\t} else if (C >= 0) {\n\t\t\tif (A > 0) forward_a(true);\n\t\t\telse forward_b(true);\n\t\t} else {\n\t\t\tif (B > 0) forward_b(true);\n\t\t\telse forward_a(true);\n\t\t}\n\t} while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n\tif (in == UNKNOWN) {\n\t\tif (Positioningpoint(qq, pp[0]) != OUTSIDE) return pp;\n\t\tif (Positioningpoint(pp, qq[0]) != OUTSIDE) return qq;\n\t}\n\treturn ret;\n}\n\ndouble CalcArea(poly ps) {\n\tdouble ret = 0.0;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tret += cross(ps[i], ps[(i+1)%ps.size()]);\n\t}\n\treturn ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(poly ps) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\tint n = ps.size();\n\tint is = 0;\n\tint js = 0;\n\tfor (int i=1; i<n; i++) {\n\t\tif (ps[i].Y > ps[is].Y) is = i;\n\t\tif (ps[i].Y < ps[js].Y) js = i;\n\t}\n\n\tint maxi, maxj;\n\tdouble maxd = norm(ps[is]-ps[js]);\n\tint i = is;\n\tint j = js;\n\tdo {\n\t\tvec a = ps[i+1] - ps[i];\n\t\tvec b = ps[j+1] - ps[j];\n\t\tif (cross(a, b) > -EPS) j = (j+1)%n;\n\t\telse i = (i+1)%n;\n\n\t\tdouble d = norm(ps[i]-ps[j]);\n\t\tif (d > maxd) {\n\t\t\tmaxd = d;\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t} while (i != is || j != js);\n\n\treturn make_pair(maxi, maxj);\n}\n\nline ClosestPair(vector<point> ps) {\n\tauto CompareY = [](const point &a, const point &b) {\n\t\tif (a.Y != b.Y) return a.Y < b.Y;\n\t\treturn a.X < b.X;\n\t};\n\n\tfunction<line(point*,int)> Rec = [&Rec, &CompareY](point *ps, int n) {\n\t\tif (n <= 1) return line{point(0, 0), point(INF, INF)};\n\t\t\n\t\tint m = n/2;\n\t\tdouble x = ps[m].X;\n\t\tline a = Rec(ps, m);\n\t\tline b = Rec(ps+m, n-m);\n\t\tdouble mind = DistL(a);\n\t\tline ret = a;\n\t\tif (DistL(b) < mind) {\n\t\t\tmind = DistL(b);\n\t\t\tret = b;\n\t\t}\n\n\t\tsort(ps, ps+n, CompareY);\n\t\tvector<point> qs;\n\t\tqs.reserve(n);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (abs(ps[i].X - x) >= mind) continue;\n\n\t\t\tfor (int j=0; j<qs.size(); j++) {\n\t\t\t\tpoint p1 = ps[i];\n\t\t\t\tpoint p2 = qs[qs.size()-1-j];\n\t\t\t\tif (p1.Y - p2.Y >= mind) break;\n\n\t\t\t\tdouble d = abs(p1-p2);\n\t\t\t\tif (mind > d) {\n\t\t\t\t\tmind = d;\n\t\t\t\t\tret = line{p1, p2};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqs.emplace_back(ps[i]);\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tint n = ps.size();\n\tassert (n >= 2);\n\tsort(ps.begin(), ps.end());\n\treturn Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<poly, poly> CutConvex(poly ps, line l) {\n#if DEBUG\n\tassert (IsConvex(ps));\n#endif\n\n\t//if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n\t//else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n\tpoly left;\n\tpoly right;\n\tfor (int i=0; i<ps.size(); i++) {\n\t\tpoint a = ps[i];\n\t\tpoint b = ps[(i+1)%ps.size()];\n\n\t\tif (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n\t\telse right.emplace_back(a);\n\n\t\tline m{a, b};\n\t\tif (IntersectLS(l, m)) {\n\t\t\tpoint p = CrosspointLL(l, m);\n\t\t\tleft.emplace_back(p);\n\t\t\tright.emplace_back(p);\n\t\t}\n\t}\n\n\treturn make_pair(left, right);\n}\n\ncircle Circum(point a, point b, point c) {\n\tcircle ret{{INF, INF}, 0.0};\n\tline l{a, b};\n\tline m{b, c};\n\tline lp = PerpendBisect(l);\n\tline mp = PerpendBisect(m);\n\tif (IsParallel(lp, mp)) return ret;\n\n\tret.c = CrosspointLL(lp, mp);\n\tret.r = abs(a-ret.c);\n\treturn ret;\n}\n\nvector<point> Tangentpoints(circle c, point p) {\n\tvector<point> ret;\n\tdouble d = abs(c.c-p);\n\tif (EQ(d, c.r)) {\n\t\tret.emplace_back(p);\n\t\treturn ret;\n\t}\n\n\tif (d < c.r) return ret;\n\n\tvec v = (p-c.c)/d*c.r;\n\tdouble t = acos(c.r/d);\n\tret.emplace_back(c.c + rotate(v, t));\n\tret.emplace_back(c.c + rotate(v, -t));\n\treturn ret;\n}\n\nvector<line> CommonTangents(circle p, circle q) {\n#if DEBUG\n\tassert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n\tdouble pr = p.r;\n\tdouble qr = q.r;\n\tpoint pc = p.c;\n\tpoint qc = q.c;\n\tdouble d = abs(pc - qc);\n\tdouble dr = abs(pr - qr);\n\tdouble sr = abs(pr + qr);\n\n\tvector<line> ret;\n\tif (EQ(d, sr)) {//If the 2 circles tangent exclusively,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > sr) {//If the 2 have no intersection,\n\t\tpoint cp = (pc * qr + qc * pr) / sr;\n\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\tfor (int i=0; i<2; i++) {\n\t\t\tline l{pts[0], qts[i]};\n\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\tret.emplace_back(l);\n\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t}\n\t\t}\n\t} \n\n\tif (EQ(d, dr)) {//If the 2 tangent inclusively,\n\t\tpoint cp = pc + (pc-qc) / (qr-pr) * pr;\n\t\tvec v = cp - pc;\n\t\tret.emplace_back(line{cp, cp + v*vec(0, 1)});\n\t} else if (d > dr) {//If the 2 intersect,\n\t\tif (EQ(pr, qr)) {\n\t\t\tpoint v = (qc - pc) / d * pr;\n\t\t\tv *= point(0, 1);\n\t\t\tret.emplace_back(line{pc+v, qc+v});\n\t\t\tret.emplace_back(line{pc-v, qc-v});\n\t\t} else {\n\t\t\tpoint cp = pc + (qc-pc) * pr / (pr-qr);\n\t\t\tvector<point> pts = Tangentpoints(p, cp);\n\t\t\tvector<point> qts = Tangentpoints(q, cp);\n\t\t\tfor (int i=0; i<2; i++) {\n\t\t\t\tline l{pts[0], qts[i]};\n\t\t\t\tif(IntersectLP(l, cp)) {\n\t\t\t\t\tret.emplace_back(l);\n\t\t\t\t\tret.emplace_back(line{pts[1], qts[i^1]});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\n\treturn ret;\n}\n\n#define DIJKSTRA_MAX_N 200\ntypedef pair<double,int> pii;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n};\n\nconst double inf=1000000001;\nint n;//Be careful of the number of the vertexes of g (=2*n).\ndouble d[DIJKSTRA_MAX_N];\nvector<edge> g[DIJKSTRA_MAX_N];\n\nvoid dijkstra(int v){\n\tpriority_queue<pii,vector<pii>,greater<pii> > q;\n\tfill(d,d+2*n,inf);\n\td[v]=0;\n\tq.push(mp(0,v));\n\twhile(!q.empty()){\n\t\tdouble D=q.top().fi;\n\t\tint w=q.top().sc;\n\t\tq.pop();\n\t\tif(D>d[w]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<g[w].size();++j){\n\t\t\tint u=g[w][j].to;\n\t\t\tdouble c=g[w][j].cost;\n\t\t\tif(d[u]>D+c){\n\t\t\t\td[u]=D+c;\n\t\t\t\tq.push(mp(d[u],u));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tcircle c[100];\n\tvector<point> v[100];\n\tfor(int i=0;i<n;++i){\n\t\tdouble x,y;\n\t\tcin>>x>>y>>c[i].r;\n\t\tc[i].c=point (x,y);\n\t}\n\tfor(int i=0;i<n-1;++i){//v[i][j]: 2*i+j+1-th (0-indexed) in g.\n\t\tv[i]=CrosspointCC(c[i],c[i+1]);\n\t}\n\tfor(int i=0;i<n-2;++i){\n\t\tfor(int j=i+1;j<n-1;++j){\n\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\tfor(int l=0;l<2;++l){\n\t\t\t\t\tpoint p=v[i][k],q=v[j][l];\n\t\t\t\t\tline s={p,q};\n\t\t\t\t\tbool f=false;\n\t\t\t\t\tfor(int m=i;m<j;++m){\n\t\t\t\t\t\tif(!IntersectSS(s,(line){v[m][0],v[m][1]})){\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tg[2*i+k+1].pb((edge){2*j+l+1,abs(p-q)});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=0;j<n-1;++j){\n\t\tfor(int l=0;l<2;++l){\n\t\t\tpoint p=c[0].c,q=v[j][l];\n\t\t\tline s={p,q};\n\t\t\tbool f=false;\n\t\t\tfor(int m=0;m<j;++m){\n\t\t\t\tif(!IntersectSS(s,(line){v[m][0],v[m][1]})){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tg[0].pb((edge){2*j+l+1,abs(p-q)});\n\t\t}\n\t}\n\tfor(int i=0;i<n-1;++i){\n\t\tfor(int k=0;k<2;++k){\n\t\t\tpoint p=v[i][k],q=c[n-1].c;\n\t\t\tline s={p,q};\n\t\t\tbool f=false;\n\t\t\tfor(int m=i;m<n-1;++m){\n\t\t\t\tif(!IntersectSS(s,(line){v[m][0],v[m][1]})){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tg[2*i+k+1].pb((edge){2*n-1,abs(p-q)});\n\t\t}\n\t}\n\tpoint p=c[0].c,q=c[n-1].c;\n\tline s={p,q};\n\tbool f=false;\n\tfor(int m=0;m<n-1;++m){\n\t\tif(!IntersectSS(s,(line){v[m][0],v[m][1]})){\n\t\t\tf=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!f){\n\t\tg[0].pb((edge){2*n-1,abs(p-q)});\n\t}\n\tdijkstra(0);\n\tcout<<fixed<<setprecision(3)<<d[2*n-1]<<endl;\n\tfor(int i=0;i<2*n;++i){\n\t\tg[i].clear();\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C {\n\tP p; double r;\n\tC(){ }\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n\tb-=a;c-=a;\n\tif(cross(b, c) > 0)  return +1;// counter clockwise\n\tif(cross(b, c) < 0)  return -1;// clockwise\n\tif(dot(b, c) < 0)    return +2;// c--a--b on line\n\tif(norm(b) < norm(c))return -2;// a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n\nclass State{\npublic:\n\tdouble sum;\n\tint t,s;\n\tP cur;\n\tState(){}\n\tState(double c, int a, int b, P p):sum(c),t(a),s(b),cur(p){}\n\tbool operator < (const State &opp)const{\n\t\treturn sum > opp.sum;\n\t}\n};\nP rotate(P t , P p , double r){\n\tdouble ta=cos(r)*real(t-p)-sin(r)*imag(t-p)+real(p);\n\tdouble tb=sin(r)*real(t-p)+cos(r)*imag(t-p)+imag(p);\n\treturn P(ta , tb);\n}\n\n\nP unit_vector(P t){\n\treturn t/fabs(abs(t));\n}\n\nL interpointCC(C a , C b){\n\tdouble di=fabs(abs(a.p-b.p));\n\tif(di > a.r+b.r || di < fabs(a.r-b.r)) return L(P(0, 0), P(0, 0));\n\tdouble t=(a.r*a.r-b.r*b.r+di*di)/(di+di);\n\tdouble rd=acos(t/a.r);\n\n\tP dv=unit_vector(b.p-a.p);\n\tP g1=rotate(dv , P(0,0) , rd);\n\tP g2=rotate(dv , P(0,0) , -rd);\n\treturn L(a.p+g1*a.r, a.p+g2*a.r);\n}\n\ndouble dp[101][2];\nint v[101][2];\nvector <L> Lines;\n\nbool check(L l, int s, int t){\n\tfor(;s<t;s++) if(!intersectSS(l, Lines[s]))return 0;\n\treturn 1;\n}\n\nmain(){\n\tint i,j,n;\n\n\twhile(cin>>n, n){\n\t\tpriority_queue<State> S;\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor(i=0;i<=100;i++) dp[i][0] = dp[i][1] = INF;\n\t\tLines.clear();\n\t\tC Prev, Now;\n\t\tdouble x, y, r;\n\t\tcin >> x >> y >> r;\n\t\tNow = C(P(x, y), r);\n\t\tP Start = Now.p;\n\t\tLines.push_back(L(Start, Start));\n\t\tfor(i=1;i<n;i++){\n\t\t\tPrev = Now;\n\t\t\tcin >> x >> y >> r;\n\t\t\tNow = C(P(x, y), r);\n\t\t\tLines.push_back(interpointCC(Now, Prev));\n\t\t}\n\t\tLines.push_back(L(Now.p, Now.p));\n\t\tS.push(State(0, 0, 0, Start));\n\t\twhile(!S.empty()){\n\t\t\tState t = S.top();S.pop();\n\t\t\tif(v[t.t][t.s]) continue;\n\t\t\tv[t.t][t.s] = 1;\n\t\t\tif(t.t == n) break;\n\t\t\tfor(i=t.t+1;i<=n;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\tif(v[i][j]) continue;\n\t\t\t\t\tL l = L(t.cur, Lines[i][j]);\n\t\t\t\t\tif(!check(l, t.t+1, i)) continue;\n\t\t\t\t\tif(dp[i][j] < abs(l[1]-l[0]) + t.sum) continue;\n\t\t\t\t\tdp[i][j] = abs(l[1]-l[0]) + t.sum;\n\t\t\t\t\tS.push(State(dp[i][j], i, j, l[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\", dp[n][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define EPS 1e-10\n#define INF 1e9\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\treturn a+b;\n}\n\nclass P{\npublic:\n\tdouble x,y,r;\n\tP(){}\n\tP(double xx,double yy,double rr){\n\t\tx=xx;\n\t\ty=yy;\n\t\tr=rr;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),r);\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),r);\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,r);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d,r);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nclass node{\npublic:\n\tdouble cost;\n\tint v,v2;\n\tnode(){}\n\tnode(double cc,int vv,int vv2){\n\t\tcost=cc;\n\t\tv=vv;\n\t\tv2=vv2;\n\t}\n\tbool operator<(const node& n1)const{\n\t\treturn cost>n1.cost;\n\t}\n};\n\nint n;\nP p[105];\nP data[105][2];\ndouble dp[105][2];\n\ndouble dijk(){\n\tfor(int i=0;i<=n;i++){\n\t\tdp[i][0]=dp[i][1]=INF;\n\t}\n\tpriority_queue<node> que;\n\tque.push(node(0.0,0,0));\n\tdp[0][0]=0.0;\n\twhile(que.size()){\n\t\tnode q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.v2]<q.cost)continue;\n\t\tfor(int next=q.v;next<=n;next++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tif((next==n+1 || next==0) && j==1)continue;\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int k=q.v+1;k<next;k++){\n\t\t\t\t\tif((data[q.v][q.v2]-data[k][0]).det(data[next][j]-data[k][1])==0){\n\t\t\t\t\t\tif(!(on_seg(data[q.v][q.v2],data[k][0],data[next][j])\n\t\t\t\t\t\t  || on_seg(data[q.v][q.v2],data[k][0],data[k][1])\n\t\t\t\t\t\t  || on_seg(data[next][j],data[k][1],data[next][j])\n\t\t\t\t\t\t  || on_seg(data[next][j],data[k][1],data[k][0])))flag=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tP r=intersection(data[q.v][q.v2],data[next][j],data[k][0],data[k][1]);\n\t\t\t\t\t\tif(!(on_seg(data[k][0],data[k][1],r) && on_seg(data[q.v][q.v2],data[next][j],r)))flag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tP len=data[next][j]-data[q.v][q.v2];\n\t\t\t\t\tdouble len2=sqrt(add((len.x*len.x),(len.y*len.y)));\n\t\t\t\t\tif(add(dp[q.v][q.v2],len2)<dp[next][j]){\n\t\t\t\t\t\tdp[next][j]=add(dp[q.v][q.v2],len2);\n\t\t\t\t\t\tque.push(node(dp[next][j],next,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n][0];\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf\",&p[i].x,&p[i].y,&p[i].r);\n\t\t}\n\t\tdata[0][0]=p[0];\n\t\tdata[n][0]=p[n-1];\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tP pp=p[i+1]-p[i];\n\t\t\tdouble len=add(pp.x*pp.x,pp.y*pp.y);\n\t\t\tdouble d=(add(p[i].r*p[i].r,-p[i+1].r*p[i+1].r)+len)/(2*sqrt(len));\n\t\t\tdouble c=sqrt(add(p[i].r*p[i].r,-d*d));\n\t\t\tdouble ang=atan2(pp.y,pp.x);\n\t\t\tdouble ang2=atan2(c,d);\n\t\t\tdata[i+1][0]=p[i]+P(p[i].r*cos(add(ang,ang2)),p[i].r*sin(add(ang,ang2)),0);\n\t\t\tdata[i+1][1]=p[i]+P(p[i].r*cos(add(ang,-ang2)),p[i].r*sin(add(ang,-ang2)),0);\n\t\t}\n\t\tprintf(\"%.4f\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <complex>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst double eps = 1e-8, inf = 1e+8;\n\ntemplate<typename T> T sqr(T x){return x*x;}\n\ndouble cross(const Point &a, const Point &b){\n    return imag(conj(a) * b);\n}\n\nstruct Line : vector<Point> {\n    Line(const Point &a, const Point &b){\n        push_back(a); push_back(b);\n    }\n};\n\nbool interLS(const Line &l, const Line &s){\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < eps;\n}\n\nstruct Circle : Point {\n    double r;\n    Circle(const Point &a, double r):Point(a), r(r){}\n};\n\nvector<Point> xptCC(const Circle &c1, const Circle &c2){\n    vector<Point> res;\n    double d = abs(c1-c2);\n    if(d < eps)return res;\n    double rc = (sqr(d) + sqr(c1.r) - sqr(c2.r)) / (2.*d);\n    double rs = sqrt(sqr(c1.r) - sqr(rc));\n    Point diff = (c2-c1) / d;\n    res.push_back(c1 + diff * Point(rc, rs));\n    res.push_back(c1 + diff * Point(rc, -rs));\n    return res;\n}\n\nint n;\nvector<Circle> cir;\n\ndouble solve(){\n    vector<Point> ps{cir[0]};\n    rep(i, n-1){\n        vector<Point> xpt(xptCC(cir[i], cir[i+1]));\n        ps.insert(ps.end(), all(xpt));\n    }\n    ps.push_back(cir[n-1]);\n    int m = (int)ps.size();\n    vector<vector<pair<int, double> > > G(m);\n    rep(i, m)rep(j, i){\n        bool ok = true;\n        int s = j|1, t = i - (!i&1);\n        for(int k=s; k<t; k+=2){\n            if(interLS(Line(ps[i], ps[j]), Line(ps[k], ps[k+1])))continue;\n            ok = false;\n            break;\n        }\n        if(ok)G[j].emplace_back(i, abs(ps[i] - ps[j]));\n    }\n    vector<double> mem(m, inf); mem[0] = 0;\n    priority_queue<pair<double, int> > q;\n    for(q.emplace(0, 0); !q.empty();){\n        double c; int v;\n        tie(c, v) = q.top(); q.pop();\n        if(mem[v] + c < -eps)continue;\n        for(auto e: G[v]){\n            double nc = e.second - c;\n            if(mem[e.first] + eps <= nc)continue;\n            mem[e.first] = nc;\n            q.emplace(-nc, e.first);\n        }\n    }\n    return mem[m-1];\n}\n\nint main(){\n    while(cin >> n, n){\n        cir.clear();\n        rep(i, n){\n            int x, y, r;\n            cin >> x >> y >> r;\n            cir.emplace_back(Point(x, y), r);\n        }\n        cout << fixed << setprecision(6) << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double, double> Point;\ntypedef pair<Point, Point> Segment; // (frm, to)\nconst double eps = 1e-9;\n\ndouble norm(Point a) {\n    return sqrt(a.first * a.first + a.second * a.second);\n}\nPoint normalize(Point vec) {\n    double d = norm(vec);\n    return d < eps ? vec : Point(vec.first / d, vec.second / d);\n}\nPoint normalize(Point vec, double len) {\n    Point a = normalize(vec);\n    return Point(a.first * len, a.second * len);\n}\nPoint getvert(Point v) {\n    return Point(-v.second, v.first);\n}\nPoint getv(Point frm, Point to) {\n    return Point(to.first - frm.first, to.second - frm.second);\n}\nPoint getv(Segment a) {\n    return getv(a.first, a.second);\n}\ndouble dist(Point a, Point b) {\n    return norm(getv(a, b));\n}\ndouble getlen(Segment a) {\n    return dist(a.first, a.second);\n}\n\ndouble cross(Point v, Point w) {\n    return v.first * w.second - v.second * w.first;\n}\nbool iscross(Segment a, Segment b) {\n    return cross(getv(a), getv(a.first, b.first)) * cross(getv(a), getv(a.first, b.second)) < eps && cross(getv(b), getv(b.first, a.first)) * cross(getv(b), getv(b.first, a.second)) < eps;\n}\n\nSegment getcrosses(Point a, double ra, Point b, double rb) {\n    double c = dist(a, b);\n    double d = (c * c + ra * ra - rb * rb) / (2 * c);\n    Point p = normalize(getv(a, b), d);\n    Point ctr = Point(p.first + a.first, p.second + a.second);\n    double h = sqrt(ra * ra - d * d);\n    Point pp = normalize(getvert(getv(a, b)), h);\n    return Segment(Point(ctr.first + pp.first, ctr.second + pp.second), Point(ctr.first - pp.first, ctr.second - pp.second));\n}\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n        vector<Point> c(n);\n        vector<int> r(n);\n        vector<Segment> s(n - 1);\n        for (int i = 0; i < n; ++i) {\n            cin >> c[i].first >> c[i].second >> r[i];\n            if (i) s[i - 1] = getcrosses(c[i - 1], r[i - 1], c[i], r[i]);\n        }\n        vector<Point> p;\n        p.push_back(c[0]);\n        for (auto i : s) {\n            p.push_back(i.first);\n            p.push_back(i.second);\n        }\n        p.push_back(c[n - 1]);\n        vector<double> dp(n * 2, 1e9);\n        dp[0] = 0;\n        for (int i = 1; i < n * 2; ++i) {\n            for (int j = 0; j < i; ++j) {\n                bool ok = true;\n                for (int k = (j + 1) / 2; k < (i - 1) / 2; ++k) {\n                    if (!iscross(Segment(p[j], p[i]), s[k])) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok)\n                    dp[i] = min(dp[i], dp[j] + dist(p[j], p[i]));\n            }\n        }\n        printf(\"%.9lf\\n\", dp[n * 2 - 1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/////////////////\n// 2D geometry //\n/////////////////\n\n// 2D geometry basic //\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n#define X real\n#define Y imag\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n// UVA 453 (Intersecting Circles)\npair<P, P> circle_circle_intersect(const P& c1, const double& r1, const P& c2, const double& r2) {\n  P A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<P, P>(z1, z2);\n}\n\n//////////\n// data //\n//////////\n\nstruct E{\n  int n1,n2;\n  double l;\n};\nbool operator<(E a,E b){\n  return a.l>b.l;\n}\nvector<C> in;\nvector<vector<P>> node;\nvector<vector<vector<E>>> edge;\n\nvoid init(){\n  in.clear();\n  node.clear();\n  edge.clear();\n}\n\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    double x,y,r;\n    cin>>x>>y>>r;\n    in.push_back(C(P(x,y),r));\n  }\n  return true;\n}\n\ndouble dist(int a,int b,int n,int m){\n  const P tmp = node[a][b]-node[n][m];\n  return sqrt(tmp.X()*tmp.X() + tmp.Y()*tmp.Y());\n}\nbool valid(int a,int b,int n,int m){\n  P vec = node[n][m] - node[a][b];\n  for(int i=a+1;i<n;i++){\n    int tmpa = ccw(node[a][b],node[n][m],node[i][0]);\n    int tmpb = ccw(node[a][b],node[n][m],node[i][1]);\n    if(!(abs(tmpa)==1 && tmpa==(-1*tmpb))){\n      return false;\n    }\n  }\n  return true;\n}\nvoid set_edge(int n,int m){\n  for(int i=0;i<n;i++){\n    for(int j=0;j<node[i].size();j++){\n      if(valid(i,j,n,m)){\n        edge[i][j].push_back(E{n,m,dist(i,j,n,m)}); \n      }\n    }\n  }\n}\n\nvoid make_g(){\n  //make_node;\n  node.resize(in.size()+1);\n  node[0].push_back(in[0].p);\n  for(int i=1;i<in.size();i++){\n    auto tmp = circle_circle_intersect(in[i-1].p,in[i-1].r,in[i].p,in[i].r);\n    node[i].push_back(tmp.first);\n    node[i].push_back(tmp.second);\n  }\n  node[in.size()].push_back(in[in.size()-1].p);\n  //meke_edge\n  edge.resize(node.size());\n  for(int i=0;i<node.size();i++){\n    edge[i].resize(node[i].size());\n    for(int j=0;j<node[i].size();j++){\n      set_edge(i,j);\n    }\n  }\n\n  for(int i=0;i<edge.size();i++){\n    for(int j=0;j<edge[i].size();j++){\n      //cerr<<\"node:\"<<i<<\",\"<<j<<endl;\n      for(int k=0;k<edge[i][j].size();k++){\n        //cerr<<\"  \"<<edge[i][j][k].n1<<\",\"<<edge[i][j][k].n2<<\" \"<<edge[i][j][k].l<<endl;\n      }\n    }\n  }\n}\n\ndouble solve_dist(){\n  priority_queue<E> q;\n  q.push(E{0,0,0});\n  vector<vector<double>> dp(node.size());\n  for(int i=0;i<dp.size();i++){\n    dp[i] = vector<double>(node[i].size(),-1);\n  }\n  while(!q.empty()){\n    E now = q.top();q.pop();\n    if(dp[now.n1][now.n2]!=-1)continue;\n    dp[now.n1][now.n2] = now.l;\n    const auto e = edge[now.n1][now.n2];\n    for(int i=0;i<e.size();i++){\n      q.push(E{e[i].n1,e[i].n2,now.l+e[i].l});\n    }\n  }\n  for(int i=0;i<dp.size();i++){\n    for(int j=0;j<dp[i].size();j++){\n      //cerr<<\"(\"<<i<<\",\"<<j<<\")::\"<<dp[i][j]<<endl;\n    }\n  }\n  return dp[node.size()-1][node[node.size()-1].size()-1];\n}\n\n\nlong double solve(){\n  make_g();\n  return solve_dist();\n}\n\nint main(){\n  while(init(),input()){\n    cout<<fixed<<setprecision(10)<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(pair<P, P> pp) {\n    push_back(pp.first); push_back(pp.second);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> circle_circle_intersect(const C& c1, const C& c2) {\n  P A = conj(c2.p-c1.p), B = (c2.r*c2.r-c1.r*c1.r-(c2.p-c1.p)*conj(c2.p-c1.p)), C = c1.r*c1.r*(c2.p-c1.p);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+c1.p, z2 = (-B-sqrt(D))/(2.0*A)+c1.p;\n  return pair<P, P>(z1, z2);\n}\n\nstruct Edge {\n  int to;\n  double cost;\n};\n\nvector<Edge> G[300];\n\nmap<P, int> mp;\nint nidx;\nvoid init_node_map(P ps, P pt, int N) {\n  mp.clear();\n  mp[ps] = 0;\n  mp[pt] = (N-1)*2+1;\n  nidx = 1;\n}\n\nint get_node(P p) {\n  if(mp.find(p) == mp.end()) {\n    mp[p] = nidx++;\n  }\n  return mp[p];\n}\n\n#define MAX (300)\ndouble dist[MAX];\n\ntypedef pair<double, int> Pdi;\n \ndouble dijkstra(int S, int T) {\n  \n  priority_queue<Pdi, vector<Pdi>, greater<Pdi> > PQ;\n  fill(dist, dist+MAX, INF);\n  dist[S] = 0;\n  PQ.push(Pdi(0., S));\n   \n  while(!PQ.empty()) {\n    Pdi pdi = PQ.top(); PQ.pop();\n    const int u = pdi.second;\n    for(int i=0; i<(int)G[u].size(); i++) {\n      const Edge& e = G[u][i];\n      if(dist[e.to] > dist[u]+e.cost) {\n\tdist[e.to] = dist[u]+e.cost;\n\tPQ.push(Pdi(dist[e.to], e.to));\n      }\n    }\n  }\n   \n  return dist[T];\n}\n\n#define IINF2 (INT_MAX/2)\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n\n    for(int i=0; i<300; i++) G[i].clear();\n\n    vector<C> cs;\n    for(int i=0; i<N; i++) {\n      double x, y, r; cin >> x >> y >> r;\n      cs.push_back(C(P(x, y), r));\n    }\n    \n    vector<pair<P, P> > ips(N+1);\n    ips[0].first = cs[0].p; // ips[0].second = P(-IINF2, -IINF2);\n    for(int i=0; i<N-1; i++) {\n      ips[i+1] = circle_circle_intersect(cs[i], cs[i+1]);\n    }\n    ips[N].first = cs[N-1].p; // ips.back().second = P(+IINF2, +IINF2);\n    \n    init_node_map(ips[0].first, ips[N].first, N);\n    \n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N+1; j++) {\n\t\n\tconst int dij = j-i;\n\t\n\tfor(int k=0; k<2; k++) {\n\t  \n\t  if(i == 0 && k == 1) continue;\n\t  \n\t  const P pti = k == 0 ? ips[i].first : ips[i].second;\n\t  const int a = get_node(pti);\n\t  \n\t  for(int l=0; l<2; l++) {\n\t    \n\t    if(j == N && l == 1) continue;\n\t    \n\t    const P ptj = l == 0 ? ips[j].first : ips[j].second;\n\t    const int b = get_node(ptj);\n\t    \n\t    bool ok = true;\n\t    const L sa(pti, ptj);\n\t    // 超えなければならない壁\n\t    for(int didx=1; didx<dij; didx++) {\n\t      const L sb(ips[i+didx]);\n\t      ok = ok && intersectSS(sa, sb);\n\t    }\n\n\t    \n\t    if(ok) {\n\t      const double len = abs(pti-ptj);\n\t      G[a].push_back((Edge){b, len});\n\t      G[b].push_back((Edge){a, len});\n\t    }\n\t    \n\t    \n\t  }\n\t}\n      }\n    }\n    \n    printf(\"%.6f\\n\", dijkstra(get_node(cs[0].p), get_node(cs[N-1].p)));\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define EPS 1e-5\n#define INF 1e9\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\treturn a+b;\n}\n\nclass P{\npublic:\n\tdouble x,y,r;\n\tP(){}\n\tP(double xx,double yy,double rr){\n\t\tx=xx;\n\t\ty=yy;\n\t\tr=rr;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),r);\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),r);\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,r);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d,r);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nclass node{\npublic:\n\tdouble cost;\n\tint v,v2;\n\tnode(){}\n\tnode(double cc,int vv,int vv2){\n\t\tcost=cc;\n\t\tv=vv;\n\t\tv2=vv2;\n\t}\n\tbool operator< (const node& n1)const{\n\t\treturn cost<n1.cost;\n\t}\n};\n\nint n;\nP p[105];\nP data[105][2];\ndouble dp[105][2];\n\ndouble dijk(){\n\tfor(int i=0;i<=n;i++){\n\t\tdp[i][0]=dp[i][1]=INF;\n\t}\n\tpriority_queue<node> que;\n\tque.push(node(0.0,0,0));\n\tdp[0][0]=0.0;\n\twhile(que.size()){\n\t\tnode q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.v2]<q.cost)continue;\n\t\tfor(int next=q.v+1;next<=n;next++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tif(next==n+1 && j==1)continue;\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int k=q.v+1;k<next;k++){\n\t\t\t\t\tif((data[q.v][q.v2]-data[k][0]).det(data[next][j]-data[k][1])==0){\n\t\t\t\t\t\tif(!(on_seg(data[q.v][q.v2],data[k][0],data[next][j])|| on_seg(data[q.v][q.v2],data[k][0],data[k][1]) || on_seg(data[next][j],data[k][1],data[q.v][q.v2])|| on_seg(data[q.v][q.v2],data[k][1],data[k][0])))flag=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tP r=intersection(data[q.v][q.v2],data[next][j],data[k][0],data[k][1]);\n\t\t\t\t\t\tif(!(on_seg(data[k][0],data[k][1],r) && on_seg(data[q.v][q.v2],data[next][j],r)))flag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tP len=data[next][j]-data[q.v][q.v2];\n\t\t\t\t\tdouble len2=sqrt((len.x*len.x)+(len.y*len.y));\n\t\t\t\t\tif(dp[q.v][q.v2]+len2<dp[next][j]){\n\t\t\t\t\t\tdp[next][j]=dp[q.v][q.v2]+len2;\n\t\t\t\t\t\tque.push(node(dp[next][j],next,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n][0];\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf\",&p[i].x,&p[i].y,&p[i].r);\n\t\t}\n\t\tdata[0][0]=p[0];\n\t\tdata[n][0]=p[n-1];\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tdouble len=(p[i].x-p[i+1].x)*(p[i].x-p[i+1].x)+(p[i].y-p[i+1].y)*(p[i].y-p[i+1].y);\n\t\t\tdouble d=(p[i].r*p[i].r-p[i+1].r*p[i+1].r+len)/(2*sqrt(len));\n\t\t\tdouble c=sqrt(p[i].r*p[i].r-d*d);\n\t\t\tP pp=p[i+1]-p[i];\n\t\t\tdouble ang=atan2(pp.y,pp.x);\n\t\t\tdouble ang2=atan2(c,d);\n\t\t\tdata[i+1][0]=p[i]+P(p[i].r*cos(ang+ang2),p[i].r*sin(ang+ang2),0);\n\t\t\tdata[i+1][1]=p[i]+P(p[i].r*cos(ang-ang2),p[i].r*sin(ang-ang2),0);\n\t\t}\n\t\tprintf(\"%f\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<Circle>cirs;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y, r; cin >> x >> y >> r;\n\t\t\tcirs.emplace_back(Point(x, y),r);\n\t\t}\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tvector<Point> ps(is_cc(cirs[i], cirs[i + 1]));\n\t\t\tls.emplace_back(ps[0], ps[1]);\n\t\t}\n\t\tvector<vector<long double>>totallen(n - 1, vector<long double>(2,99999999));\n\t\tlong double finlen = 99999999;\n\t\t{\n\t\t\tPoint from = cirs[0].p;\n\t\t\tlong double fromtime = 0;\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\tLine tryline(from, ls[i][j]);\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int m = 0; m < i; ++m) {\n\t\t\t\t\t\tif (!isis_ss(tryline, ls[m])) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\ttotallen[i][j] = min(totallen[i][j], abs(ls[i][j] - from)+fromtime);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLine tryline(from, cirs[n - 1].p);\n\t\t\tbool ok = true;\n\t\t\tfor (int k = 0; k < n - 1; ++k) {\n\t\t\t\tif (!isis_ss(tryline, ls[k])) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tfinlen = min(finlen, abs(cirs[n - 1].p - cirs[0].p) + fromtime);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < n - 1; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tPoint from = ls[k][l];\n\t\t\t\tlong double fromtime = totallen[k][l];\n\t\t\t\tfor (int i = k+1; i < n - 1; ++i) {\n\t\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\t\tLine tryline(from, ls[i][j]);\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int m = k+1; m < i; ++m) {\n\t\t\t\t\t\t\tif (!isis_ss(tryline, ls[m])) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\ttotallen[i][j] = min(totallen[i][j], abs(ls[i][j] - from) + fromtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tLine tryline(from, cirs[n - 1].p);\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int i = k+1; i < n - 1; ++i) {\n\t\t\t\t\tif (!isis_ss(tryline, ls[i])) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tfinlen = min(finlen, abs(cirs[n - 1].p - from) + fromtime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(10)<< finlen << endl;\n\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tC c[100];\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i].p.real() >> c[i].p.imag() >> c[i].r;\n\t\t}\n\t\tvector<P> p;\n\t\tp.push_back(c[0].p);\n\t\tp.push_back(c[n-1].p);\n\t\tfor(int i = 0 ; i < n-1 ; i++){\n\t\t\tvector<P> a = C_cp(c[i],c[i+1]);\n\t\t\tfor(int k = 0 ; k < a.size() ; k++)\n\t\t\t\tp.push_back(a[k]);\n\t\t}\n\t\t\n\t\tvector< vector<pair<double,int> > > g(p.size());\n\t\t\n\t\tpriority_queue< pair<double,int> > Q;\n\t\tvector<int> done(p.size(),0);\n\t\tQ.push(make_pair(0,0));\n\t\twhile(Q.size()){\n\t\t\tint qi = Q.top().second;\n\t\t\tdouble qcost = Q.top().first;\n\t\t\tQ.pop();\n\t\t\tif( done[qi]++) continue;\n\t\t\t//cout << qi << p[qi] << \" \" << -qcost << endl;\n\t\t\tif( qi == 1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",-qcost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < p.size() ; i++){\n\t\t\t\tif( !done[i] ){\n\t\t\t\t\tint minIdx = 1e9;\n\t\t\t\t\tint maxIdx = -1e9;\n\t\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\t\tif( distanceSP(L(p[i],p[qi]),c[k].p) < c[k].r + EPS ){\n\t\t\t\t\t\t\tminIdx = min(minIdx,k);\n\t\t\t\t\t\t\tmaxIdx = max(maxIdx,k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint flag = true;\n\t\t\t\t\tfor(int k = minIdx ; k < maxIdx ; k++){\n\t\t\t\t\t\tvector<P> a = C_cp(c[k],c[k+1]);\n\t\t\t\t\t\tif( !intersectLL(L(p[i],p[qi]),L(a[0],a[1])) || distanceSP(L(a[0],a[1]), crosspoint(L(p[i],p[qi]),L(a[0],a[1]) ) ) > EPS || distanceSP(L(p[i],p[qi]), crosspoint(L(p[i],p[qi]),L(a[0],a[1]) ) ) > EPS ){\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( flag ) {\n\t\t\t\t\t\tQ.push(make_pair(qcost-abs(p[i]-p[qi]),i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-6;\ndouble add(double a,double b){\n    if(abs(a+b)<eps)return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\ndouble d(P p,P q){\n    return sqrt(dot(p-q,p-q));\n}\n\nint main(){\n    int n;\n    vector<int>ans;\n    while(cin>>n,n!=0){\n        P a[n];\n        double r[n];\n        rep(i,n)cin>>a[i].first>>a[i].second>>r[i];\n        P b[n-1][2];\n        rep(i,n-1){\n            P v=(a[i+1]-a[i])*(1.0/d(a[i+1],a[i]));\n            P h={v.second,-v.first};\n            double l=(r[i]*r[i]+d(a[i],a[i+1])*d(a[i],a[i+1])-r[i+1]*r[i+1])/2/d(a[i],a[i+1]);\n            b[i][0]=a[i]+v*l+h*sqrt(r[i]*r[i]-l*l);\n            b[i][1]=a[i]+v*l-h*sqrt(r[i]*r[i]-l*l);\n        }\n        double x[2*n][2*n];\n        rep(i,2*n)rep(j,2*n)x[i][j]=inf;\n        rep(i,n-1)rep(j,2){\n            bool ok=true;\n            rep(k,i)if(!cross(a[0],b[i][j],b[k][0],b[k][1]))ok=false;\n            if(ok)x[0][2*i+j+1]=d(a[0],b[i][j]);\n        }\n        rep(i,n-1)rep(j,2){\n            bool ok=true;\n            REP(k,i+1,n-1)if(!cross(a[n-1],b[i][j],b[k][0],b[k][1]))ok=false;\n            if(ok)x[2*n-1][2*i+j+1]=d(a[n-1],b[i][j]);\n        }\n        rep(i,n-1)REP(j,i+1,n-1)rep(k,2)rep(l,2){\n            bool ok=true;\n            REP(m,i+1,j)if(!cross(b[i][k],b[j][l],b[m][0],b[m][1]))ok=false;\n            if(ok)x[2*i+k+1][2*j+l+1]=d(b[i][k],b[j][l]);\n        }\n        bool ok=true;\n        rep(i,n-1)if(!cross(a[0],a[n-1],b[i][0],b[i][1]))ok=false;\n        if(ok)x[0][2*n-1]=d(a[0],a[n-1]);\n        rep(i,2*n)x[i][i]=0;\n        rep(i,n)x[2*i+1][2*i+2]=d(b[i][0],b[i][1]);\n        rep(i,2*n)rep(j,2*n)x[i][j]=min(x[i][j],x[j][i]);\n        rep(i,2*n)rep(j,2*n)rep(k,2*n)x[j][k]=min(x[i][j]+x[i][k],x[j][k]);\n        cout<<setprecision(10)<<x[0][2*n-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define fi first\n#define fs first\n#define se second\n#define sc second\n//#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\n#define ll long long\n\n#define mp make_pair\n#define all(v) begin(v), end(v)\n//#define M_PI 3.14159265353238\n#define pb push_back\n\nnamespace geo\n{\n#define IL inline\n\ttypedef double D;\n\ttypedef bool B;\n\ttypedef complex<D> P;\n#define X real()\n#define Y imag()\n\tostream &operator<<(ostream &out, const P &point1) // Pの出力\n\t{\n\t\tout << '(' << point1.X << \", \" << point1.Y << ')';\n\t\treturn out;\n\t}\n\tB comp(const P &l, const P &r)\n\t{\n\t\treturn (l.X == r.X) ? l.Y < r.Y : l.X < r.X;\n\t}\n\ttypedef pair<P, P> L;  //line\n\ttypedef pair<P, P> LS; //line segment\n\ttypedef pair<P, D> C;  //circle\n\ttypedef vector<P> Poly;\n\tconst D EPS = 1e-8;\n\t//Decompotision Macro\n#define DCl(a, b, l) \\\n  P a, b;            \\\n  tie(a, b) = l\n#define DCc(a, b, c) \\\n  P a;               \\\n  D b;               \\\n  tie(a, b) = c\n\n//A dot B\n\tIL D dot(P a, P b) { return a.X * b.X + a.Y * b.Y; }\n\t//A cross B\n\tIL D cross(P a, P b) { return a.X * b.Y - a.Y * b.X; }\n\tIL D ccw(P a, P b, P c)\n\t{\n\t\treturn cross(b - a, c - a);\n\t}\n\n\t// 未検証!!\n\tIL P rotation(P a, double angle) {\n\t\ta *= exp(complex<double>(.0, angle * M_PI / 180.0));\n\t\treturn a;\n\t}\n\n\tIL int sgn(P a, P b, P c)\n\t{\n\t\tif (cross(b - a, c - a) > EPS)\n\t\t\treturn 1;\n\t\tif (cross(b - a, c - a) < -EPS)\n\t\t\treturn -1;\n\t\tif (dot(b - a, c - a) < -EPS)\n\t\t\treturn 2; // b-a-c\n\t\tif (dot(a - b, c - b) < -EPS)\n\t\t\treturn -2; // a-b-c\n\t\treturn 0;\n\t}\n\tIL D signed_distance_P_L(P p, L l)\n\t{\n\t\tDCl(a, b, l);\n\t\treturn ccw(a, b, p) / abs(b - a);\n\t}\n\n\tIL D distance_P_L(P p, L l) // 点と直線の距離\n\t{\n\t\treturn abs(signed_distance_P_L(p, l));\n\t}\n\n\tIL D distance_P_P(P p1, P p2) // 二点間距離\n\t{\n\t\treturn abs(p1 - p2);\n\t}\n\n\tIL D distance_P_LS(P p, LS ls) // 点と線分の距離\n\t{\n\t\tDCl(a, b, ls);\n\t\tif (dot(b - a, p - a) < EPS)\n\t\t\treturn abs(p - a);\n\t\tif (dot(a - b, p - b) < EPS)\n\t\t\treturn abs(p - b);\n\t\treturn abs(cross(b - a, p - a)) / abs(b - a);\n\t}\n\n\tIL B is_L_L(L p, L q)\n\t{\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn abs(cross(a - b, c - d)) > EPS ||\n\t\t\tabs(cross(a - b, d - b)) < EPS;\n\t}\n\tIL B is_L_LS(L l, LS ls)\n\t{\n\t\tDCl(a, b, l);\n\t\tDCl(c, d, ls);\n\t\treturn ccw(a, b, c) * ccw(a, b, d) < EPS;\n\t}\n\tIL B is_LS_LS(LS p, LS q)\n\t{\n\t\tDCl(a, b, p);\n\t\tDCl(c, d, q);\n\t\treturn sgn(a, b, c) * sgn(a, b, d) <= 0 && sgn(c, d, a) * sgn(c, d, b) <= 0;\n\t}\n\n\tIL D distance_LS_LS(LS p, LS q)\n\t{\n\t\tif (is_LS_LS(p, q))\n\t\t\treturn 0;\n\t\treturn min({ distance_P_LS(p.fi, q),\n\t\t\t\t\tdistance_P_LS(p.se, q),\n\t\t\t\t\tdistance_P_LS(q.fi, p),\n\t\t\t\t\tdistance_P_LS(q.se, p) });\n\t}\n\n\t//caution: have to use isintersected_L_L before this function\n\tIL P cross_L_L(L p, L q)\n\t{\n\t\tDCl(a, b, p);\n\t\tD d1 = signed_distance_P_L(a, q);\n\t\tD d2 = signed_distance_P_L(b, q);\n\t\treturn (a * d2 - b * d1) / (d2 - d1);\n\t}\n\n\tIL B is_C_C(C p, C q)\n\t{\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\treturn abs(rp - rq) - d < EPS &&\n\t\t\trp + rq - d > -EPS;\n\t}\n\tIL LS cross_C_C(C p, C q)\n\t{\n\t\tDCc(cp, rp, p);\n\t\tDCc(cq, rq, q);\n\t\tD d = abs(cp - cq);\n\t\tD rc = (d * d + rp * rp - rq * rq) / (2 * d);\n\t\tD rs = sqrt(rp * rp - rc * rc);\n\t\tP diff = (cq - cp) / d;\n\t\treturn { cp + P(rc, rs) * diff, cp + P(rc, -rs) * diff };\n\t}\n\tIL Poly convex_hull(Poly p)\n\t{\n\t\tint n = p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(all(p), comp);\n\t\trep(i, 0, n)\n\t\t{\n\t\t\twhile (k > 1 && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n\t\t\t\tk--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\trep(j, 0, n - 1)\n\t\t{\n\t\t\tint i = n - 2 - j;\n\t\t\twhile (k > t && ccw(res[k - 2], res[k - 1], p[i]) < EPS)\n\t\t\t\tk--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\tIL B convex_in(Poly &l, P &p)\n\t{\n\t\tint a = 0, b = l.size(), c;\n\t\tD A, C;\n\t\tP g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1)\n\t\t{\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0)\n\t\t\t{\n\t\t\t\tif (A > -EPS && C < -EPS)\n\t\t\t\t\tb = c;\n\t\t\t\telse\n\t\t\t\t\ta = c;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (C < -EPS || A > -EPS)\n\t\t\t\t\tb = c;\n\t\t\t\telse\n\t\t\t\t\ta = c;\n\t\t\t}\n\t\t}\n\t\treturn (cross(l[b % l.size()] - l[a], p - l[b % l.size()]) > -EPS);\n\t}\n\n\t//not necessary?\n\tIL D convex_area(Poly &l)\n\t{\n\t\tdouble res = 0;\n\t\tint n = l.size();\n\t\trep(i, 2, n)\n\t\t\tres += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n\t\treturn res;\n\t}\n\tIL D area(Poly &l)\n\t{\n\t\tdouble res = 0;\n\t\tint n = l.size();\n\t\trep(i, 0, n)\n\t\t\tres += cross(l[i], l[(i + 1) % n]);\n\t\treturn abs(res) / 2.0;\n\t}\n\tinline vector<L> tangent_line(C c, P p)\n\t{\n\t\tvector<L> res;\n\t\tDCc(cp, r, c);\n\t\tP v = p - cp;\n\t\tD dist = abs(v);\n\t\tif (dist - r > -EPS)\n\t\t{\n\t\t\tdouble _cos = r / dist;\n\t\t\tdouble _sin = sqrt(1.0 - _cos * _cos);\n\t\t\tv = v * (r / dist);\n\t\t\t{\n\t\t\t\tP e = P(_cos * v.X - _sin * v.Y, _sin * v.X + _cos * v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t\tif (dist - r > EPS)\n\t\t\t{\n\t\t\t\tP e = P(_cos * v.X + _sin * v.Y, -_sin * v.X + _cos * v.Y);\n\t\t\t\tres.push_back({ p, cp + e });\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tIL vector<L> inner_common_tangent_line(C p, C q)\n\t{\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tD dist = abs(Mp - Mq);\n\t\tif (dist - (Rp + Rq) > -EPS)\n\t\t{\n\t\t\tP mid = (Mq * Rp + Mp * Rq) / (Rp + Rq);\n\t\t\tres = tangent_line(p, mid);\n\t\t}\n\t\treturn res;\n\t}\n\tinline vector<L> outer_common_tangent_line(C p, C q)\n\t{\n\t\tvector<L> res;\n\t\tDCc(Mp, Rp, p);\n\t\tDCc(Mq, Rq, q);\n\t\tP v = Mp - Mq;\n\t\tD dist = abs(v);\n\t\tif (dist - abs(Rp - Rq) > -EPS)\n\t\t{\n\t\t\tif (abs(Rp - Rq) < EPS)\n\t\t\t{\n\t\t\t\tP e = v * P(0, 1);\n\t\t\t\te = e / dist;\n\t\t\t\tres.pb(L(Mp + e, Mq + e));\n\t\t\t\tres.pb(L(Mp - e, Mq - e));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tP mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n\t\t\t\tres = tangent_line(p, mid);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<Poly> decomposition(Poly p)\n\t{\n\t\tint n = p.size();\n\t\tvector<Poly> res;\n\t\twhile (n >= 3)\n\t\t{\n\t\t\t[&]() {\n\t\t\t\trep(i, 0, n)\n\t\t\t\t{\n\t\t\t\t\tP a = p[i];\n\t\t\t\t\tP b = p[(i + 1) % n];\n\t\t\t\t\tP c = p[(i + 2) % n];\n\t\t\t\t\tif (ccw(a, b, c) < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ([&]() {\n\t\t\t\t\t\trep(j, 3, n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP d = p[(i + j) % n];\n\t\t\t\t\t\t\t\tif (ccw(a, b, d) > -EPS && ccw(b, c, d) > -EPS && ccw(c, a, d) > -EPS)\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}())\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tPoly nxt;\n\t\t\t\t\t\trep(j, 0, n) if ((i + j) % n != (i + 1) % n)\n\t\t\t\t\t\t\tnxt.push_back(p[(i + j) % n]);\n\t\t\t\t\t\tswap(p, nxt);\n\t\t\t\t\t\tres.push_back({ a, b, c });\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}();\n\t\t}\n\t\treturn res;\n\t}\n\tint in_triangle(P p, Poly q)\n\t{\n\t\trep(i, 0, 3) if (abs(p - q[i]) < EPS) return 3; //on point\n\t\trep(i, 0, 3)\n\t\t{\n\t\t\tint s = sgn(q[i], q[(i + 1) % 3], p);\n\t\t\tif (s != 1)\n\t\t\t{\n\t\t\t\tif (s == 0)\n\t\t\t\t\treturn 2; //on line\n\t\t\t\telse\n\t\t\t\t\treturn 0; // not in\n\t\t\t}\n\t\t}\n\t\treturn 1; // inside triangle\n\t}\n\tint in_C(P q, C c) // 円での点の内外判定(円周上も判定)\n\t{\n\t\tDCc(p, r, c);\n\t\tif (abs(r - abs(p - q)) < EPS)\n\t\t\treturn 2; // 円周\n\t\treturn r - abs(p - q) > -EPS ? 1 : 0;\n\t}\n\tint is_triangle_C(Poly t, C c)\n\t{\n\t\tt = convex_hull(t);\n\t\tDCc(p, r, c);\n\t\tint cnt = 0;\n\t\trep(i, 0, 3)\n\t\t\tcnt += (in_C(t[i], c) > 0);\n\t\tif (cnt == 3)\n\t\t\treturn 3; // t in c\n\t\tif (cnt == 0)\n\t\t{\n\t\t\tdouble d = distance_P_LS(p, LS(t[2], t[0]));\n\t\t\trep(i, 0, 2)\n\t\t\t\td = min(d, distance_P_LS(p, LS(t[i], t[i + 1])));\n\t\t\tif (r - d > EPS)\n\t\t\t\treturn 1; //intersect\n\t\t\tif (in_triangle(p, t))\n\t\t\t\treturn 2; //c in t\n\t\t\telse if (r - d < -EPS)\n\t\t\t\treturn 0; //not intersect\n\t\t}\n\t\treturn 1; //intersect\n\t}\n\n\t//p must be convex and ccw\n\tLS diameter(Poly &p)\n\t{\n\t\tint n = p.size();\n\t\tint is = 0, js = 0;\n\t\trep(i, 0, n) if (p[i].Y > p[is].Y)\n\t\t\tis = i;\n\t\trep(i, 0, n) if (p[i].Y < p[js].Y)\n\t\t\tjs = i;\n\t\tLS res = { p[is], p[js] };\n\t\t{\n\t\t\tint i = is;\n\t\t\tint j = js;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tint ni = (i + 1) % n;\n\t\t\t\tint nj = (j + 1) % n;\n\t\t\t\tif (cross(p[ni] - p[i], p[nj] - p[j]) < EPS)\n\t\t\t\t\ti = ni;\n\t\t\t\telse\n\t\t\t\t\tj = nj;\n\t\t\t\tif (abs(res.fi - res.se) < abs(p[i] - p[j]))\n\t\t\t\t\tres = LS(p[i], p[j]);\n\t\t\t} while (i != is || j != js);\n\t\t}\n\t\treturn res;\n\t}\n\n\tPoly cross_C_L(C c, L v)\n\t{\n\t\tDCc(p, r, c);\n\t\tDCl(a, b, v);\n\t\ta -= p;\n\t\tb -= p;\n\t\tP u = a - b;\n\t\tu = P(-u.Y, u.X);\n\t\tP x = cross_L_L({ a, b }, { P(0, 0), u });\n\t\tD d = abs(x);\n\t\tPoly res;\n\t\tif (d - r > EPS)\n\t\t\treturn res;\n\t\tD y = sqrt(r * r - d * d);\n\t\tres.pb(p + x + (b - a) * y / abs(b - a));\n\t\t//if(d-r>-EPS)return res;\n\t\tres.pb(p + x + (a - b) * y / abs(b - a));\n\t\treturn res;\n\t}\n\n\tpair<C, C> GetC_p_p_r(P p1, P p2, D r) // 二点と半径から２つの円を求める\n\t{\n\t\tD d = distance_P_P(p1, p2);\n\t\tassert(d <= 2. * r); // 二点間の距離は2 * r以内じゃないと同じ円周上に存在することはできない.\n\t\tP mid = (p1 + p2) / 2.;\n\t\tP NormalVector = (p1 - p2) / d * sqrt(r * r - d * d / 4.);\n\t\tNormalVector = P(NormalVector.Y, -NormalVector.X);\n\t\tP center1 = mid + NormalVector;\n\t\tP center2 = mid - NormalVector;\n\t\treturn mp(C(center1, r), C(center2, r));\n\t}\n}\n\ndouble dis[300][300];\n\nvoid solve(int &n) {\n\tcout.precision(12); cout << fixed;\n\tusing namespace geo;\n\trep(i, 0, 300) rep(j, 0, 300) dis[i][j] = 1000000000.;\n\trep(i, 0, 300) dis[i][i] = 0.;\n\tvector<C> circles;\n\trep(i, 0, n) {\n\t\tint x, y, r; cin >> x >> y >> r;\n\t\tcircles.pb(pair<P, D>(P(x, y), r));\n\t}\n\tvector<LS> lss;\n\tvector<P> ps;\n\tps.push_back(circles[0].first);\n\tint now = 1;\n\trep(i, 0, n - 1) {\n\t\tLS ls = cross_C_C(circles[i], circles[i + 1]);\n\t\tP now1 = ls.first;\n\t\tP now2 = ls.second;\n\t\trep(j, 0, ps.size()) {\n\t\t\tbool ok = true;\n\t\t\trep(k, (j + 1) / 2, lss.size()) {\n\t\t\t\tif (!is_LS_LS(LS(now1, ps[j]), LS(lss[k]))) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tdis[j][now] = min(dis[j][now], distance_P_P(now1, ps[j]));\n\t\t\t\tdis[now][j] = min(dis[now][j], distance_P_P(now1, ps[j]));\n\t\t\t}\n\t\t}\n\t\trep(j, 0, ps.size()) {\n\t\t\tbool ok = true;\n\t\t\trep(k, (j + 1) / 2, lss.size()) {\n\t\t\t\tif (!is_LS_LS(LS(now2, ps[j]), LS(lss[k]))) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tdis[j][now + 1] = min(dis[j][now + 1], distance_P_P(now2, ps[j]));\n\t\t\t\tdis[now + 1][j] = min(dis[now + 1][j], distance_P_P(now2, ps[j]));\n\t\t\t}\n\t\t}\n\t\tps.pb(now1);\n\t\tps.pb(now2);\n\t\tlss.pb(ls);\n\t\tnow += 2;\n\t}\n\t{\n\t\tP now1 = circles.back().first;\n\t\trep(j, 0, ps.size()) {\n\t\t\tbool ok = true;\n\t\t\trep(k, (j + 1) / 2, lss.size()) {\n\t\t\t\tif (!is_LS_LS(LS(now1, ps[j]), LS(lss[k]))) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tdis[j][now] = min(dis[j][now], distance_P_P(now1, ps[j]));\n\t\t\t\tdis[now][j] = min(dis[now][j], distance_P_P(now1, ps[j]));\n\t\t\t}\n\t\t}\n\t}\n\trep(k, 0, 300) rep(i, 0, 300) rep(j, 0, 300) {\n\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t}\n\tcout << dis[0][now] << endl;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) solve(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\n\nconst double EPS=1e-8,INF=1e12;\ntypedef complex<double> P;\ntypedef P point;\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);}\n}\ndouble cross(const P &a,const P &b){\n  return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n  return real(conj(a)*b);\n}\n\nstruct L :public vector<P>{\n  L(const P &a,const P &b){\n    pb(a); pb(b);\n  }\n};\n\ntypedef pair<point,point> ppp;\n\nint ccw(P a,P b,P c){\n  b-=a; c-=a;\n  if(cross(b,c)>EPS) return 1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c)<-EPS) return +2;\n  if(norm(b)+EPS<norm(c)) return -2;\n  return 0;\n}\n\nppp c_c_inter(const point &c1,const double &r1,\n\t      const point &c2,const double &r2){\n  point A=conj(c2-c1), B=(r2*r2-r1*r1-(c2-c1)*conj(c2-c1)),C=r1*r1*(c2-c1);\n  point D=B*B-4.*A*C;\n  point z1=(-B+sqrt(D))/(2.0*A)+c1, z2=(-B-sqrt(D))/(2.0*A)+c1;\n  return ppp(z1,z2);\n}\n\nbool interLS(const L &l,const L s){\n  return cross(l[1]-l[0], s[0]-l[0])*\n    cross(l[1]-l[0],s[1]-l[0])<EPS;\n}\n\ndouble len(const L &l){\n  return abs(l[0]-l[1]);\n}\ndouble d[212][212];\n\nint main(){\n  cout<<fixed<<setprecision(10);\n  int n;\n  while(cin>>n,n){\n    vector<P> c(n);\n    vector<double> r(n);\n    double x,y;\n    rep(i,n){\n      cin>>x>>y>>r[i];\n      c[i]=P(x,y);\n    }\n    vector<ppp> ps(n-1);\n    rep(i,n-1)\n      ps[i]=c_c_inter(c[i],r[i],c[i+1],r[i+1]);\n\n    fill(d[0],d[0]+212*212,INF);\n    rep(i,n-1){\n      L lx(c[0],ps[i].X),ly(c[0],ps[i].Y);\n      int fx=1,fy=1;\n      rep(j,i){\n\tfx&=interLS(lx,L(ps[j].X,ps[j].Y));\n\tfy&=interLS(ly,L(ps[j].X,ps[j].Y));\n      }\n      if(fx)d[2*n-2][2*i]=d[2*i][2*n-2]=len(lx);\n      if(fy)d[2*n-2][2*i+1]=d[2*i+1][2*n-2]=len(ly);\n    }\n    rep(i,n-1){\n      L lx(c[n-1],ps[i].X),ly(c[n-1],ps[i].Y);\n      int fx=1,fy=1;\n      for(int j=i;j<n-1;++j){\n\tfx&=interLS(lx,L(ps[j].X,ps[j].Y));\n\tfy&=interLS(ly,L(ps[j].X,ps[j].Y));\n      }\n      if(fx)d[2*n-1][2*i]=d[2*i][2*n-1]=len(lx);\n      if(fy)d[2*n-1][2*i+1]=d[2*i+1][2*n-1]=len(ly);\n    }\n    L l(c[0],c[n-1]);\n    int f=1;\n    rep(i,n-1)\n      f&=interLS(l,L(ps[i].X,ps[i].Y));\n    if(f) d[2*n-1][2*n-2]=d[2*n-2][2*n-1]=len(l);\n    rep(i,n-1)rep(j,i)rep(a,2)rep(b,2){\n      L l(a?ps[i].Y:ps[i].X,b?ps[j].Y:ps[j].X);\n      int f=1;\n      for(int k=j+1;k<i;++k)\n\tf&=interLS(l,L(ps[k].X,ps[k].Y));\n      if(f)\n\td[2*i+a][2*j+b]=d[2*j+b][2*i+a]=len(l);\n    }\n    rep(k,2*n)rep(i,2*n)rep(j,2*n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<d[2*n-1][2*n-2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nbool isCrossed(complex<double> p1, complex<double> p2, complex<double> p3, complex<double> p4) {\n    if ( ((p1.real() - p2.real()) * (p3.imag() - p1.imag()) + (p1.imag() - p2.imag()) * (p1.real() - p3.real())) *\n            ((p1.real() - p2.real()) * (p4.imag() - p1.imag()) + (p1.imag() - p2.imag()) * (p1.real() - p4.real())) > 0)\n        return false;\n    return true;\n}\n\nint main() {\n    int N = 0;\n    while (cin>>N && N) {\n        vector<pair<complex<double>, double> > circles(N);\n        for (int n = 0; n < N; n++) {\n            int x,y,r;\n            cin>>x>>y>>r;\n            circles[n] = make_pair(complex<double>(x,y), (double)r);\n        }\n\n        vector<complex<double> > vertices(2 * N);\n        vertices[0] = circles[0].first;\n        vertices[1] = circles[N-1].first;\n        for (int n = 0; n < N-1; n++) {\n            complex<double> v = circles[n+1].first - circles[n].first;\n            double a = atan2(v.imag(), v.real());\n            double theta = acos((norm(v) + circles[n].second*circles[n].second - circles[n+1].second*circles[n+1].second)\n                / (2 * abs(v) * circles[n].second));\n            vertices[2+2*n] = circles[n].second * complex<double>(cos(a+theta), sin(a+theta)) + circles[n].first;\n            vertices[3+2*n] = circles[n].second * complex<double>(cos(a-theta), sin(a-theta)) + circles[n].first;\n        }\n\n        multimap<int, pair<int, double> > ds;\n        for (int n = 0; n < N; n++) {\n            for (int s = 0; s < 2; s++) {\n                for (int i = n+1; i < N+1; i++) {\n                    for (int t = 0; t < 2; t++) {\n                        if (i != N) {\n                            bool flag = true;\n                            for (int u = n+1; u < i; u++) {\n                                if (!(isCrossed(vertices[2*n+s], vertices[2*i+t], vertices[2*u], vertices[2*u+1]) &&\n                                        isCrossed(vertices[2*u], vertices[2*u+1], vertices[2*n+s], vertices[2*i+t]))) {\n                                    flag = false;\n                                    break;\n                                }\n                            }\n                            if (flag) ds.insert(make_pair(2*n+s, make_pair(2*i+t, (double)abs(vertices[2*i+t] - vertices[2*n+s]))));\n                        } else {\n                            bool flag = true;\n                            for (int u = n+1; u < i; u++) {\n                                if (!(isCrossed(vertices[2*n+s], vertices[1], vertices[2*u], vertices[2*u+1]) &&\n                                        isCrossed(vertices[2*u], vertices[2*u+1], vertices[2*n+s], vertices[1]))) {\n                                    flag = false;\n                                    break;\n                                }\n                            }\n                            if (flag) ds.insert(make_pair(2*n+s, make_pair(1, (double)abs(vertices[1] - vertices[2*n+s]))));\n                            break;\n                        }\n                    }\n                }\n                if (n == 0) break;\n            }\n        }\n\n        priority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > pqueue;\n        double finalDs[1000] = {};\n        for (int n = 0; n < N; n++) {\n            finalDs[2*n] = -1.0;\n            finalDs[2*n+1] = -1.0;\n        }\n\n        pqueue.push(make_pair(0.0, 0));\n        while (!pqueue.empty()) {\n            auto p = pqueue.top();\n            pqueue.pop();\n            if (finalDs[p.second] < 0.0) finalDs[p.second] = p.first;\n            else continue;\n\n            auto it = ds.lower_bound(p.second);\n            auto last = ds.upper_bound(p.second);\n            for (; it != last; it++) {\n                pqueue.push(make_pair(p.first+it->second.second, it->second.first));\n            }\n        }\n        cout<<finalDs[1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* 解答時間→ 101:22(途中) */\n#include <cmath>\n#include <iostream>\t\t//基本入出力\nusing namespace std;\n\ndouble dist2d(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main(){\n\twhile(1){\n\t\t//入力\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tdouble x[25],y[25],r[25];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\t\tint V = n * 2;\n\t\tdouble pos_x[50], pos_y[50];\n\t\tpos_x[0] = x[0];\n\t\tpos_y[0] = y[0];\n\t\tpos_x[V - 1] = x[n - 1];\n\t\tpos_y[V - 1] = y[n - 1];\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tdouble d = sqrt(1.0 * (x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1]));\n\t\t\tdouble a = (d * d + r[i] * r[i] - r[i + 1] * r[i + 1]) / (d * 2);\n\t\t\tdouble b = sqrt(-a * a + r[i] * r[i]);\n\t\t\tdouble va_x = a * (x[i + 1] - x[i]) / d, va_y = a * (y[i + 1] - y[i]) / d;\n\t\t\tdouble vb_x = b * (y[i] - y[i + 1]) / d, vb_y = b * (x[i + 1] - x[i]) / d;\n\t\t\tpos_x[i * 2 + 1] = va_x + vb_x + x[i];\n\t\t\tpos_y[i * 2 + 1] = va_y + vb_y + y[i];\n\t\t\tpos_x[i * 2 + 2] = va_x - vb_x + x[i];\n\t\t\tpos_y[i * 2 + 2] = va_y - vb_y + y[i];\n\t\t}\n\t\t//総当りで距離を計算\n\t\tdouble dist[50][50];\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tdist[i][j] = DBL_MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < V - 1; i++){\n\t\t\tfor(int j = i + 1; j < V; j++){\n\t\t\t\t//交差判定(準備)\n\t\t\t\tint flg = 1;\n\t\t\t\tdouble x1, y1, x2, y2, x3, y3, x4, y4;\n\t\t\t\tx1 = pos_x[i];\n\t\t\t\ty1 = pos_y[i];\n\t\t\t\tx2 = pos_x[j];\n\t\t\t\ty2 = pos_y[j];\n\t\t\t\tint pos_ls, pos_lg;\n\t\t\t\tif(i == 0)\n\t\t\t\t\tpos_ls = 1;\n\t\t\t\telse\n\t\t\t\t\tpos_ls = (i + 1) / 2 + 1;\n\t\t\t\tif(j == V - 1)\n\t\t\t\t\tpos_lg = n - 1;\n\t\t\t\telse\n\t\t\t\t\tpos_lg = (j + 1) / 2 - 1;\n\t\t\t\t//交差判定(本番)\n\t\t\t\tdouble ta, tb, tc, td;\n\t\t\t\tfor(int k = pos_ls; k <= pos_lg; k++){\n\t\t\t\t\tx3 = pos_x[k * 2 - 1];\n\t\t\t\t\ty3 = pos_y[k * 2 - 1];\n\t\t\t\t\tx4 = pos_x[k * 2];\n\t\t\t\t\ty4 = pos_y[k * 2];\n\t\t\t\t\tta = (x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\t\t\t\ttb = (x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\t\t\t\ttc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\t\t\t\ttd = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\t\t\tif((tc*td>=0.0)||(ta*tb>=0.0)){\n\t\t\t\t\t\tflg=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg == 1){\n\t\t\t\t\tdist[i][j] = dist2d(pos_x[i], pos_y[i], pos_x[j], pos_y[j]);\n\t\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ワーシャル・フロイド法\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j])\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tcout << dist[0][V - 1] << \"\\n\";\n\t}\n\tcout << flush;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\nconst double INF = DBL_MAX / 1000;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\nvoid circlesIntersection(const Point& p1, double r1, const Point& p2, double r2, vector<Point>& intersection)\n{\n    double y = p2.y - p1.y;\n    double x = p2.x - p1.x;\n    double a = (y*y + x*x + r1*r1 - r2*r2) / 2;\n    double b = (y*y + x*x) * r1*r1 - a*a;\n\n    intersection.assign(2, Point(x, -y) * sqrt(b));\n    intersection[1] = intersection[1] * -1;\n    for(int i=0; i<2; ++i)\n        intersection[i] = (intersection[i] + Point(y, x) * a) / (y*y + x*x) + p1;\n}\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < EPS);\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Point> p(n);\n        vector<double> r(n);\n        for(int i=0; i<n; ++i)\n            cin >> p[i].x >> p[i].y >> r[i];\n\n        vector<vector<Point> > intersection(n+1);\n        for(int i=1; i<n; ++i)\n            circlesIntersection(p[i], r[i], p[i-1], r[i-1], intersection[i]);\n        intersection[0].assign(2, p[0]);\n        intersection[n].assign(2, p[n-1]);\n\n        vector<vector<double> > dp(n+1, vector<double>(2, INF));\n        dp[0][0] = 0.0;\n        for(int a=0; a<n+1; ++a){\n            for(int b=0; b<2; ++b){\n                for(int c=a+1; c<n+1; ++c){\n                    for(int d=0; d<2; ++d){\n                        bool ok = true;\n                        for(int i=a+1; i<c; ++i){\n                            if(!segmentsCollide(intersection[a][b], intersection[c][d], intersection[i][0], intersection[i][1]))\n                                ok = false;\n                        }\n                        if(ok)\n                            dp[c][d] = min(dp[c][d], dp[a][b] + intersection[a][b].dist(intersection[c][d]));\n                    }\n                }\n            }\n        }\n\n        printf(\"%.10f\\n\", dp[n][0]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double EPS = 1e-8, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nvector<P> isCC(P c1, double r1, P c2, double r2){\n\tdouble x = norm(c1 - c2);\n\tdouble y = ((r1 * r1 - r2 * r2) / x + 1) / 2;\n\tdouble d = r1 * r1 / x - y * y;\n\tif(d < -EPS) return vector<P>(0);\n\tif(d < 0) d = 0;\n\tP q1 = c1 + (c2 - c1) * y, q2 = (c2 - c1) * sqrt(d) * P(0, 1);\n\tvector<P> res;\n\tres.pb(q1 - q2); res.pb(q1 + q2);\n\treturn res;\n}\nG isCL(const P &c, double r, const P &p1, const P &p2){\n\tdouble x = dot(p1 - c, p2 - p1);\n\tdouble y = norm(p2 - p1);\n\tdouble d = x * x - y * (norm(p1 - c) - r * r);\n\tif(d < -EPS) return G(0);\n\tif(d < 0) d = 0;\n\tP q1 = p1 - (p2 - p1) * (x / y);\n\tP q2 = (p2 - p1) * (sqrt(d) / y);\n\tG res; res.pb(q1 - q2); res.pb(q1 + q2);\n\treturn res;\n}\n\n\nint n;\nG o;\ndouble r[100];\nbool v[300];\n\nbool ok(const P &a, const P &b){\n\tmap<double, int> m;\n\tm[0] = 0; m[1] = 0;\n\trep(i, n){\n\t\tG cp = isCL(o[i], r[i], a, b);\n\t\tif(cp.size() == 2){\n\t\t\tdouble x = dot(cp[0] - a, b - a) / norm(a - b);\n\t\t\tdouble y = dot(cp[1] - a, b - a) / norm(a - b);\n\t\t\tx = max(x, 0.0); y = max(y, 0.0);\n\t\t\tx = min(x, 1.0); y = min(y, 1.0);\n\t\t\tif(x > y) swap(x, y);\n\t\t\tm[x - EPS]++; m[y + EPS]--;\n\t\t}\n\t}\n\tint cnt = 0;\n\teach(i, m){\n\t\tcnt += i->second;\n\t\tif(0 <= i->first && i->first <= 1 && cnt <= 0) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\to.clear(); o.resize(n);\n\t\trep(i, n) cin >> o[i].real() >> o[i].imag() >> r[i];\n\t\t\n\t\tvector<pair<int, P> > ps;\n\t\trep(i, n - 1){\n\t\t\tG cp = isCC(o[i], r[i], o[i + 1], r[i + 1]);\n\t\t\teach(j, cp) ps.pb(mp(i + 1, *j));\n\t\t}\n\t\tps.pb(mp(0, o[0]));\n\t\tps.pb(mp(n, o[n - 1]));\n\t\t\n\t\tint m = ps.size();\n\t\tmemset(v, 0, sizeof(v));\n\t\tpriority_queue<pair<double, int> > q;\n\t\tq.push(mp(0, m - 2));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tint c = q.top().second;\n\t\t\tdouble co = q.top().first; q.pop();\n\t\t\t\n\t\t\tif(v[c]) continue;\n\t\t\tv[c] = 1;\n\t\t\tif(c == m - 1){\n\t\t\t\tprintf(\"%.9f\\n\", -co);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, m) if(!v[i] && ok(ps[c].second, ps[i].second)){\n\t\t\t\tq.push(mp(co - abs(ps[i].second - ps[c].second), i));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define EPS 1e-9\n#define INF 1e9\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\treturn a+b;\n}\n\nclass P{\npublic:\n\tdouble x,y,r;\n\tP(){}\n\tP(double xx,double yy,double rr){\n\t\tx=xx;\n\t\ty=yy;\n\t\tr=rr;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),r);\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),r);\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,r);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d,r);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nclass node{\npublic:\n\tdouble cost;\n\tint v,v2;\n\tnode(){}\n\tnode(double cc,int vv,int vv2){\n\t\tcost=cc;\n\t\tv=vv;\n\t\tv2=vv2;\n\t}\n\tbool operator<(const node& n1)const{\n\t\treturn cost>n1.cost;\n\t}\n};\n\nint n;\nP p[105];\nP data[105][2];\ndouble dp[105][2];\n\ndouble dijk(){\n\tfor(int i=0;i<=n;i++){\n\t\tdp[i][0]=dp[i][1]=INF;\n\t}\n\tpriority_queue<node> que;\n\tque.push(node(0.0,0,0));\n\tdp[0][0]=0.0;\n\twhile(que.size()){\n\t\tnode q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.v2]<q.cost)continue;\n\t\tfor(int next=q.v;next<=n;next++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tif((next==n+1 || next==0) && j==1)continue;\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int k=q.v+1;k<next;k++){\n\t\t\t\t\tif((data[q.v][q.v2]-data[k][0]).det(data[next][j]-data[k][1])==0){\n\t\t\t\t\t\tif(!(on_seg(data[q.v][q.v2],data[k][0],data[next][j])|| on_seg(data[q.v][q.v2],data[k][0],data[k][1]) || on_seg(data[next][j],data[k][1],data[q.v][q.v2])|| on_seg(data[q.v][q.v2],data[k][1],data[k][0])))flag=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tP r=intersection(data[q.v][q.v2],data[next][j],data[k][0],data[k][1]);\n\t\t\t\t\t\tif(!(on_seg(data[k][0],data[k][1],r) && on_seg(data[q.v][q.v2],data[next][j],r)))flag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tP len=data[next][j]-data[q.v][q.v2];\n\t\t\t\t\tdouble len2=sqrt(add((len.x*len.x),(len.y*len.y)));\n\t\t\t\t\tif(add(dp[q.v][q.v2],len2)<dp[next][j]){\n\t\t\t\t\t\tdp[next][j]=add(dp[q.v][q.v2],len2);\n\t\t\t\t\t\tque.push(node(dp[next][j],next,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n][0];\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf\",&p[i].x,&p[i].y,&p[i].r);\n\t\t}\n\t\tdata[0][0]=p[0];\n\t\tdata[n][0]=p[n-1];\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tdouble len=add((p[i].x-p[i+1].x)*(p[i].x-p[i+1].x),(p[i].y-p[i+1].y)*(p[i].y-p[i+1].y));\n\t\t\tdouble d=(add(p[i].r*p[i].r,-p[i+1].r*p[i+1].r)+len)/(2*sqrt(len));\n\t\t\tdouble c=sqrt(add(p[i].r*p[i].r,-d*d));\n\t\t\tP pp=p[i+1]-p[i];\n\t\t\tdouble ang=atan2(pp.y,pp.x);\n\t\t\tdouble ang2=atan2(c,d);\n\t\t\tdata[i+1][0]=p[i]+P(p[i].r*cos(ang+ang2),p[i].r*sin(ang+ang2),0);\n\t\t\tdata[i+1][1]=p[i]+P(p[i].r*cos(ang-ang2),p[i].r*sin(ang-ang2),0);\n\t\t}\n\t\tprintf(\"%.4f\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <cfloat>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define eps 10e-5\n#define INF 1e8\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\n\n#define M INT_MAX\n\n//Point\nstruct P{\n    double x, y;\n    P(){ x=M; y=M;}\n\n    P(const double &s , const double &e)\n    {x=s; y=e;}\n\n    P operator - (const P &t) const\n    { return P(x-t.x , y-t.y);}\n\n    P operator + (const P &t) const\n    { return P(x+t.x , y+t.y); }\n\n    P operator * (const double &d) const\n    { return P(x*d , y*d); }\n};\n\n\n//Line\ndouble dis(P t);\nstruct L{\n    P p1,p2;\n\n    L(){}\n\n    L(const P &s , const P &e)\n        { p1=s; p2=e;}\n    double ldis(){\n        return dis(p1-p2);\n    }\n};\n \n//Circle\nstruct C{\n    P a;\n    double r;\n    C(){}\n    C(const P &s , const double &e)\n        { a=s; r=e;}\n};\n\n//距離を求める\ndouble dis(P t){\n    return sqrt(t.x*t.x+t.y*t.y);\n}\n\n//単位ベクトルを求める\nP unit_vector(P t){\n    double u=fabs(dis(t));\n    return P(t.x/u , t.y/u);\n}\n\n//外積を求める a×b\ndouble cross(P a,P b){\n    return (a.x*b.y-a.y*b.x);\n}\n\n//線分交差判定\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n    return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < eps) &&\n           ( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < eps);\n}\n\n//点pを中心としてr(radian)回転       p(0,0)で原点を中心として回転\nP rotate(P t , P p , double r){\n    //double r=radians(angle);\n    double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n    double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n    return P(ta , tb);\n}\n \n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nL interpoint_cc(C a , C b){\n    double di=fabs(dis(a.a-b.a));\n    if(di > a.r+b.r || di < fabs(a.r-b.r)) return L(P(0, 0), P(0, 0));\n    double t=(a.r*a.r-b.r*b.r+di*di)/(di+di);\n    double rd=acos(t/a.r);\n \n    P dv=unit_vector(b.a-a.a);\n    P g1=rotate(dv , P(0,0) , rd);\n    P g2=rotate(dv , P(0,0) , -rd);\n    return L(a.a+g1*a.r, a.a+g2*a.r);\n}\n\n\nclass State{\npublic:\n\t\tC c;\n   \tL l;\n\t\tdouble s1, s2;\n    State(){}\n    State(C cc, L ll){c = cc; l = ll;}\n};\n\n\n\nState dp[110];\n\nbool check(L l, int s, int t){\n    for(;s<t;s++) if(!intersect_s(l.p1, l.p2, dp[s].l.p1, dp[s].l.p2))return 0;\n    return 1;\n}\n\n\n\nint main(void){\n\tint n;\n\twhile(cin>>n, n){\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(i,110) dp[i].s1 = dp[i].s2 = INF;\n\t\tint x, y;\n\t\tdouble r;\n\t\tcin >> x >> y >> r;\n\t\tState s = State(C(P(x,y),r), L(P(x,y),P(x,y)));\n\t\tdp[0] = s;\n\t\tdp[0].s1 = dp[0].s2 = 0;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tcin >> x >> y >> r;\n\t\t\tC c = C(P(x,y),r);\n\t\t\tdp[i] = State(c, interpoint_cc(c, dp[i-1].c));\n\t\t\tREP(k,i){\n\t\t\t\tL l1 = L(dp[k].l.p1, dp[i].l.p1);\n\t\t\t\tL l2 = L(dp[k].l.p2, dp[i].l.p1);\n\t\t\t\tif(dp[k].s1 != INF && check(l1, k, i)){\n\t\t\t\t\tdp[i].s1 = min(dp[i].s1, dp[k].s1 + l1.ldis());\n\t\t\t\t}\n\t\t\t\tif(dp[k].s2 != INF && check(l2, k, i)){\n\t\t\t\t\tdp[i].s2 = min(dp[i].s2, dp[k].s1 + l2.ldis());\n\t\t\t\t}\n\t\t\t\tl1 = L(dp[k].l.p1, dp[i].l.p2);\n\t\t\t\tl2 = L(dp[k].l.p2, dp[i].l.p2);\n\t\t\t\tif(dp[k].s1 != INF && check(l1, k, i)){\n\t\t\t\t\tdp[i].s1 = min(dp[i].s1, dp[k].s2 + l1.ldis());\n\t\t\t\t}\n\t\t\t\tif(dp[k].s2 != INF && check(l2, k, i)){\n\t\t\t\t\tdp[i].s2 = min(dp[i].s2, dp[k].s2 + l2.ldis());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(k,n){\n\t\t\tL l1 = L(dp[k].l.p1, dp[n-1].c.a);\n\t\t\tif(dp[k].s1 != INF && check(l1, k, n)){\n\t\t\t\tdp[n].s1 = min(dp[n].s1, dp[k].s1 + l1.ldis());\n\t\t\t}\n\t\t\tl1 = L(dp[k].l.p2, dp[n-1].c.a);\n\t\t\tif(dp[k].s2 != INF && check(l1, k, n)){\n\t\t\t\tdp[n].s1 = min(dp[n].s1, dp[k].s2 + l1.ldis());\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\", dp[n].s1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-10L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nvoid solve(){\n    vector<long double> answ;\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            REP(i, answ.size()) {\n                cout << answ[i] << endl;\n            }\n            return;\n        }\n        vector<Circle> inputs;\n        REP(i, n) {\n            long double a, b, c;\n            cin >> a >> b >> c;\n            inputs.push_back(Circle{ Point{a,b},c });\n        }\n        vector<Line> barriers;\n        REP(i, n - 1) {\n            barriers.push_back(intersection_Circle_Circle(inputs[i], inputs[i + 1]));\n        }\n        long double dp[101][2] = {};\n        REP(i, n-1) {\n            dp[i][0] = 1e9;\n            dp[i][1] = 1e9;\n            for (int j = 0; j < i; ++j) {\n                {\n                    int ok = 1;\n                    for (int t = j+1; t < i; ++t) {\n                        if (is_intersected_ls(barriers[t], Line{ barriers[j].first,barriers[i].first }) == 0) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok == 1) {\n                        dp[i][0] = min(dp[i][0], dp[j][0] + abs(barriers[i].first - barriers[j].first));\n                    }\n                }\n                {\n                    int ok = 1;\n                    for (int t = j + 1; t < i; ++t) {\n                        if (is_intersected_ls(barriers[t], Line{ barriers[j].second,barriers[i].first }) == 0) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok == 1) {\n                        dp[i][0] = min(dp[i][0], dp[j][1] + abs(barriers[i].first - barriers[j].second));\n                    }\n                }\n                {\n                    int ok = 1;\n                    for (int t = j + 1; t < i; ++t) {\n                        if (is_intersected_ls(barriers[t], Line{ barriers[j].second,barriers[i].second }) == 0) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok == 1) {\n                        dp[i][1] = min(dp[i][1], dp[j][1] + abs(barriers[i].second - barriers[j].second));\n                    }\n                }\n                {\n                    int ok = 1;\n                    for (int t = j + 1; t < i; ++t) {\n                        if (is_intersected_ls(barriers[t], Line{ barriers[j].first,barriers[i].second }) == 0) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok == 1) {\n                        dp[i][1] = min(dp[i][1], dp[j][0] + abs(barriers[i].second - barriers[j].first));\n                    }\n                }\n            }\n            \n            {\n                int ok = 1;\n                REP(j,i){\n                    if (is_intersected_ls(barriers[j], Line{ inputs[0].center,barriers[i].first }) == 0) {\n                        ok = 0;\n                        break;\n                    }\n                }\n                if (ok == 1) {\n                    dp[i][0] = min(dp[i][0], abs(barriers[i].first - inputs[0].center));\n                }\n            }\n            {\n                int ok = 1;\n                REP(j, i) {\n                    if (is_intersected_ls(barriers[j], Line{ inputs[0].center,barriers[i].second }) == 0) {\n                        ok = 0;\n                        break;\n                    }\n                }\n                if (ok == 1) {\n                    dp[i][1] = min(dp[i][1], abs(barriers[i].second - inputs[0].center));\n                }\n            }\n        }\n        long double ans = 1e9;\n        for (int j = n - 2; j >= 0; --j) {\n            {\n                int ok = 1;\n                for (int t = j + 1; t < n - 1;++t) {\n                    if (is_intersected_ls(barriers[t], Line{ inputs.back().center,barriers[j].first }) == 0) {\n                        ok = 0;\n                        break;\n                    }\n                }\n                if (ok == 1) {\n                    ans = min(ans, dp[j][0] + abs(barriers[j].first - inputs.back().center));\n                }\n            }\n            {\n                int ok = 1;\n                for (int t = j + 1; t < n - 1; ++t) {\n                    if (is_intersected_ls(barriers[t], Line{ inputs.back().center,barriers[j].second }) == 0) {\n                        ok = 0;\n                        break;\n                    }\n                }\n                if (ok == 1) {\n                    ans = min(ans, dp[j][1] + abs(barriers[j].second - inputs.back().center));\n                }\n            }\n        }\n        {\n            int ok = 1;\n            for (int t = 0; t < barriers.size(); ++t) {\n                if (is_intersected_ls(barriers[t], Line{ inputs.back().center,inputs[0].center }) == 0) {\n                    ok = 0;\n                    break;\n                }\n            }\n            if (ok == 1) {\n                ans = min(ans, abs(inputs[0].center - inputs.back().center));\n            }\n        }\n        answ.push_back(ans);\n        //cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define EPS 1e-10\n#define INF 10000000000.0\n \nusing namespace std;\ntypedef long long int ll;\n \ndouble add(double a, double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\n \nstruct P{\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y): x(x), y(y){\n\t}\n\tP operator+ (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator- (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator* (double d){\n\t\treturn P(x*d, y*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n};\n\ntypedef pair<P, P> Ppair;\n \nbool on_seg(P p1, P p2, P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n \nP intersection(P p1, P p2, P q1, P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1) / (q2-q1).det(p2-p1));\n}\n\nPpair circ_intersection(P p1, double r1, P p2, double r2){ //2点で交わるとき\n\tP q=(p2-p1)*((r1*r1-r2*r2-p1.dot(p1)+p2.dot(p2))/(2.0*((p2-p1).dot(p2-p1))));\n\tP r=P((p2-p1).y, (p1-p2).x);\n\tdouble sq=sqrt((r.dot(q-p1))*(r.dot(q-p1))-(r.dot(r))*((q-p1).dot(q-p1)-r1*r1));\n\tdouble t1=(-(r.dot(q-p1))+sq)/(r.dot(r));\n\tdouble t2=(-(r.dot(q-p1))-sq)/(r.dot(r));\n\tP s1=q+r*t1, s2=q+r*t2;\n\treturn Ppair(s1, s2);\n}\n\nint main()\n{\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0) return 0;\n\t\tdouble d[202][202];\n\t\tfor(int i=0; i<2*n; i++){\n\t\t\tfor(int j=0; j<2*n; j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t}else{\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tP c[100];\n\t\tdouble r[100];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf %lf %lf\", &x, &y, &r[i]);\n\t\t\tc[i]=P(x, y);\n\t\t}\n\t\tP p1[101], p2[101];\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tPpair p=circ_intersection(c[i], r[i], c[i+1], r[i+1]);\n\t\t\tp1[i]=p.first, p2[i]=p.second;\n\t\t}\n\t\tbool e0=0;\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tif((c[0]-c[n-1]).det(p1[i]-p2[i])==0){\n\t\t\t\te0=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tP q=intersection(c[0], c[n-1], p1[i], p2[i]);\n\t\t\tif(!(on_seg(c[0], c[n-1], q) && on_seg(p1[i], p2[i], q))){\n\t\t\t\te0=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(e0==0){\n\t\t\tprintf(\"%.6lf\\n\", sqrt((c[0]-c[n-1]).dot(c[0]-c[n-1])));\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\td[2*i+1][2*i+2]=sqrt((p1[i]-p2[i]).dot(p1[i]-p2[i]));\n\t\t\td[2*i+2][2*i+1]=d[2*i+1][2*i+2];\n\t\t}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tbool e=0;\n\t\t\tfor(int j=0; j<i; j++){\n\t\t\t\tif((c[0]-p1[i]).det(p1[j]-p2[j])==0){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP q=intersection(c[0], p1[i], p1[j], p2[j]);\n\t\t\t\tif(!(on_seg(c[0], p1[i], q) && on_seg(p1[j], p2[j], q))){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e==0){\n\t\t\t\td[0][2*i+1]=sqrt((c[0]-p1[i]).dot(c[0]-p1[i]));\n\t\t\t\td[2*i+1][0]=d[0][2*i+1];\n\t\t\t}\n\t\t\te=0;\n\t\t\tfor(int j=0; j<i; j++){\n\t\t\t\tif((c[0]-p2[i]).det(p1[j]-p2[j])==0){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP q=intersection(c[0], p2[i], p1[j], p2[j]);\n\t\t\t\tif(!(on_seg(c[0], p2[i], q) && on_seg(p1[j], p2[j], q))){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e==0){\n\t\t\t\td[0][2*i+2]=sqrt((c[0]-p2[i]).dot(c[0]-p2[i]));\n\t\t\t\td[2*i+2][0]=d[0][2*i+2];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tbool e=0;\n\t\t\tfor(int j=i+1; j<n-1; j++){\n\t\t\t\tif((c[n-1]-p1[i]).det(p1[j]-p2[j])==0){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP q=intersection(c[n-1], p1[i], p1[j], p2[j]);\n\t\t\t\tif(!(on_seg(c[n-1], p1[i], q) && on_seg(p1[j], p2[j], q))){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e==0){\n\t\t\t\td[2*n-1][2*i+1]=sqrt((c[n-1]-p1[i]).dot(c[n-1]-p1[i]));\n\t\t\t\td[2*i+1][2*n-1]=d[2*n-1][2*i+1];\n\t\t\t}\n\t\t\te=0;\n\t\t\tfor(int j=i+1; j<n-1; j++){\n\t\t\t\tif((c[n-1]-p2[i]).det(p1[j]-p2[j])==0){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP q=intersection(c[n-1], p2[i], p1[j], p2[j]);\n\t\t\t\tif(!(on_seg(c[n-1], p2[i], q) && on_seg(p1[j], p2[j], q))){\n\t\t\t\t\te=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e==0){\n\t\t\t\td[2*n-1][2*i+2]=sqrt((c[n-1]-p2[i]).dot(c[n-1]-p2[i]));\n\t\t\t\td[2*i+2][2*n-1]=d[2*n-1][2*i+2];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tfor(int j=i+1; j<n-1; j++){\n\t\t\t\tbool e=0;\n\t\t\t\tfor(int k=i+1; k<j; k++){\n\t\t\t\t\tif((p1[i]-p1[j]).det(p1[k]-p2[k])==0){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP q=intersection(p1[i], p1[j], p1[k], p2[k]);\n\t\t\t\t\tif(!(on_seg(p1[i], p1[j], q) && on_seg(p1[k], p2[k], q))){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(e==0){\n\t\t\t\t\td[2*i+1][2*j+1]=sqrt((p1[i]-p1[j]).dot(p1[i]-p1[j]));\n\t\t\t\t\td[2*j+1][2*i+1]=d[2*i+1][2*j+1];\n\t\t\t\t}\n\t\t\t\te=0;\n\t\t\t\tfor(int k=i+1; k<j; k++){\n\t\t\t\t\tif((p1[i]-p2[j]).det(p1[k]-p2[k])==0){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP q=intersection(p1[i], p2[j], p1[k], p2[k]);\n\t\t\t\t\tif(!(on_seg(p1[i], p2[j], q) && on_seg(p1[k], p2[k], q))){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(e==0){\n\t\t\t\t\td[2*i+1][2*j+2]=sqrt((p1[i]-p2[j]).dot(p1[i]-p2[j]));\n\t\t\t\t\td[2*j+2][2*i+1]=d[2*i+1][2*j+2];\n\t\t\t\t}\n\t\t\t\te=0;\n\t\t\t\tfor(int k=i+1; k<j; k++){\n\t\t\t\t\tif((p2[i]-p1[j]).det(p1[k]-p2[k])==0){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP q=intersection(p2[i], p1[j], p1[k], p2[k]);\n\t\t\t\t\tif(!(on_seg(p2[i], p1[j], q) && on_seg(p1[k], p2[k], q))){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(e==0){\n\t\t\t\t\td[2*i+2][2*j+1]=sqrt((p2[i]-p1[j]).dot(p2[i]-p1[j]));\n\t\t\t\t\td[2*j+1][2*i+2]=d[2*i+2][2*j+1];\n\t\t\t\t}\n\t\t\t\te=0;\n\t\t\t\tfor(int k=i+1; k<j; k++){\n\t\t\t\t\tif((p2[i]-p2[j]).det(p1[k]-p2[k])==0){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP q=intersection(p2[i], p2[j], p1[k], p2[k]);\n\t\t\t\t\tif(!(on_seg(p2[i], p2[j], q) && on_seg(p1[k], p2[k], q))){\n\t\t\t\t\t\te=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(e==0){\n\t\t\t\t\td[2*i+2][2*j+2]=sqrt((p2[i]-p2[j]).dot(p2[i]-p2[j]));\n\t\t\t\t\td[2*j+2][2*i+2]=d[2*i+2][2*j+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=0; k<2*n; k++){\n\t\t\tfor(int i=0; i<2*n; i++){\n\t\t\t\tfor(int j=0; j<2*n; j++){\n\t\t\t\t\tif(d[i][j]>d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6lf\\n\", d[0][2*n-1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <list>\n#include <map>\n#include <cmath>\n#include <utility>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <set>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI = acos(-1.0);\n\ntemplate<class T>\nstruct Po{\n\tT x,y;\n\tPo() : x(0.0),y(0.0) {}\n\tPo(const T &x,const T &y) : x(x),y(y) {}\n\tPo operator+(const Po& a) const { return Po(x + a.x,y + a.y); }\n\tPo operator-(const Po& a) const { return Po(x - a.x,y - a.y); }\n\tPo operator*(const double& a) const { return Po(x * a, y * a); }\n\tPo operator/(const double& a) const { return Po(x / a, y / a); }\n};\n\nenum{ CCW = 1,CW = -1,ON = 0};\n\ntypedef Po<double> P;\n\ndouble SQ(double x) {return x* x; }\ndouble abs(const P& a) { return sqrt(SQ(a.x) + SQ(a.y)); }\ndouble dot( const P& a,const P &b){ return a.x * b.x + a.y * b.y ; }\ndouble cross( const P& a,const P &b){ return a.x * b.y - a.y * b.x ; }\n\nP rot(const P& a, double theta){\n\treturn P( a.x * cos(theta) - a.y * sin(theta) ,\n\t\ta.x * sin(theta) + a.y * cos(theta) );\n}\n\nint ccw(P a,P b,P c){\n\tb = b - a; c = c - a;\n\tdouble rdir = cross(b,c);\n\tdouble len = abs(b) * abs(c);\n\tif( rdir > EPS *len) return CCW;\n\telse if( rdir < -EPS * len) return CW;\n\treturn ON;\n}\n\nbool intersect(P& a1,P& b1,P& a2, P& b2){\n\tif(max(a1.x,b1.x) + EPS < min(a2.x,b2.x)\n\t||max(a1.y,b1.y) + EPS < min(a2.y,b2.y)\n\t||max(a2.x,b2.x) + EPS < min(a1.x,b1.x)\n\t||max(a2.y,b2.y) + EPS < min(a1.y,b1.y) ) return false;\n\treturn ccw(a1,b1,a2) * ccw(a1,b1,b2) <= 0\n\t\t&& ccw(a2,b2,a1) * ccw(a2,b2,b1) <= 0;\n}\n\ntypedef pair<P,P> PD;\n\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\nint n;\nP p[100];\ndouble r[100];\ndouble dp[202][202];\n\n#define FOR(i,n) for(int i = 0; i < (n) ; i++)\n\n\nint main(){\n\n\twhile(cin>>n,n){\n\t\tvector<P> us;\n\t\tvector<PD> vpd;\n\t\tFOR(i,n) cin>>p[i].x >> p[i].y >> r[i];\n\t\tFOR(i,202) FOR(j,202) dp[i][j] = 1e50;\n\t\tus.push_back(p[0]);\n\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tPD pd = GetContact(p[i],p[i+1],r[i],r[i+1]);\n\t\t\tus.push_back(pd.first);\n\t\t\tus.push_back(pd.second);\n\t\t\tvpd.push_back(pd);\n\t\t}\n\t\tus.push_back(p[n-1]);\n\n\t\tfor(int i = 0; i < (int)us.size(); i++){\n\t\t\tfor(int j = i + 1; j < (int)us.size(); j++){\n\t\t\t\tbool ok = true;\n\t\t\t\tint l  = (1 + i) / 2;\n\t\t\t\tint r = (1 + j) / 2 - 1;\n\t\t\t\tfor (int k = l; k < r; k++){\n\t\t\t\t\tif(!intersect(us[i],us[j],vpd[k].first,vpd[k].second))\n\t\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok) continue;\n\t\t\t\tdouble dist = abs(us[i] - us[j]);\n\t\t\t\tdp[j][i] = dp[i][j] = dist;\n\t\t\t}\n\t\t}\n\n\t\tint a = (int)us.size();\n\t\tFOR(k,a) FOR(i,a) FOR(j,a) dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\n\t\tprintf(\"%.10lf\\n\",dp[0][a - 1]);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <cfloat>\n \nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define eps 10e-5\n#define INF 1e8\n \ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n \n \n#define M INT_MAX\n \n//Point\nstruct P{\n    double x, y;\n    P(){ x=M; y=M;}\n \n    P(const double &s , const double &e)\n    {x=s; y=e;}\n \n    P operator - (const P &t) const\n    { return P(x-t.x , y-t.y);}\n \n    P operator + (const P &t) const\n    { return P(x+t.x , y+t.y); }\n \n    P operator * (const double &d) const\n    { return P(x*d , y*d); }\n};\n \n \n//Line\ndouble dis(P t);\nstruct L{\n    P p1,p2;\n \n    L(){}\n \n    L(const P &s , const P &e)\n        { p1=s; p2=e;}\n    double ldis(){\n        return dis(p1-p2);\n    }\n};\n  \n//Circle\nstruct C{\n    P a;\n    double r;\n    C(){}\n    C(const P &s , const double &e)\n        { a=s; r=e;}\n};\n \n//距離を求める\ndouble dis(P t){\n    return sqrt(t.x*t.x+t.y*t.y);\n}\n \n//単位ベクトルを求める\nP unit_vector(P t){\n    double u=fabs(dis(t));\n    return P(t.x/u , t.y/u);\n}\n \n//外積を求める a×b\ndouble cross(P a,P b){\n    return (a.x*b.y-a.y*b.x);\n}\n \n//線分交差判定\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n    return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < eps) &&\n           ( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < eps);\n}\n \n//点pを中心としてr(radian)回転       p(0,0)で原点を中心として回転\nP rotate(P t , P p , double r){\n    //double r=radians(angle);\n    double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n    double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n    return P(ta , tb);\n}\n  \n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nL interpoint_cc(C a , C b){\n    double di=fabs(dis(a.a-b.a));\n    if(di > a.r+b.r || di < fabs(a.r-b.r)) return L(P(0, 0), P(0, 0));\n    double t=(a.r*a.r-b.r*b.r+di*di)/(di+di);\n    double rd=acos(t/a.r);\n  \n    P dv=unit_vector(b.a-a.a);\n    P g1=rotate(dv , P(0,0) , rd);\n    P g2=rotate(dv , P(0,0) , -rd);\n    return L(a.a+g1*a.r, a.a+g2*a.r);\n}\n \n \nclass State{\npublic:\n        C c;\n    L l;\n        double s1, s2;\n    State(){}\n    State(C cc, L ll){c = cc; l = ll;}\n};\n \n \n \nState dp[110];\n \nbool check(L l, int s, int t){\n    for(s++;s<t;s++) if(!intersect_s(l.p1, l.p2, dp[s].l.p1, dp[s].l.p2))return 0;\n    return 1;\n}\n \n \n \nint main(void){\n    int n;\n    while(cin>>n, n){\n        memset(dp, 0, sizeof(dp));\n        REP(i,110) dp[i].s1 = dp[i].s2 = INF;\n        int x, y;\n        double r;\n        cin >> x >> y >> r;\n        State s = State(C(P(x,y),r), L(P(x,y),P(x,y)));\n        dp[0] = s;\n        dp[0].s1 = dp[0].s2 = 0;\n        for(int i = 1; i < n; i++){\n            cin >>x>>y>>r;\n            C c = C(P(x,y),r);\n            State s = State(c, interpoint_cc(c, dp[i-1].c));\n            s.s1 = s.s2 = INF;\n            dp[i] = s;\n            REP(k,i){\n                L l1 = L(dp[k].l.p1, dp[i].l.p1);\n                if(dp[k].s1 != INF && check(l1, k, i)){\n                    dp[i].s1 = min(dp[i].s1, dp[k].s1 + l1.ldis());\n                }\n                L l2 = L(dp[k].l.p2, dp[i].l.p1);\n                if(dp[k].s2 != INF && check(l2, k, i)){\n                    dp[i].s1 = min(dp[i].s1, dp[k].s2 + l2.ldis());\n                }\n                l1 = L(dp[k].l.p1, dp[i].l.p2);\n                if(dp[k].s1 != INF && check(l1, k, i)){\n                    dp[i].s2 = min(dp[i].s2, dp[k].s1 + l1.ldis());\n                }\n                l2 = L(dp[k].l.p2, dp[i].l.p2);\n                if(dp[k].s2 != INF && check(l2, k, i)){\n                    dp[i].s2 = min(dp[i].s2, dp[k].s2 + l2.ldis());\n                }\n            }\n        }\n/*\n        REP(i,n){\n        \tprintf(\"%.9f %0.9f\\n\", dp[i].s1, dp[i].s2);\n        }\n*/\n\tREP(k,n){\n            L l1 = L(dp[k].l.p1, dp[n-1].c.a);\n            if(dp[k].s1 != INF && check(l1, k, n)){\n//printf(\"dp[%d] : min(%.9f, %.9f + %.9f)\\n\", k, dp[n].s1, dp[k].s1, l1.ldis());\n                dp[n].s1 = min(dp[n].s1, dp[k].s1 + l1.ldis());\n            }\n            L l2 = L(dp[k].l.p2, dp[n-1].c.a);\n            if(dp[k].s2 != INF && check(l2, k, n)){\n//printf(\"dp[%d] : min(%.9f, %.9f + %.9f)\\n\", k, dp[n].s1, dp[k].s2, l2.ldis());\n                dp[n].s1 = min(dp[n].s1, dp[k].s2 + l2.ldis());\n            }\n        }\n        printf(\"%.9f\\n\", dp[n].s1);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\n\n#include<complex>\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8, pi = acos(-1.0);\nld dot(Point a, Point b) { return real(conj(a)*b); }\nld cross(Point a, Point b) { return imag(conj(a)*b); }\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\treturn lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n\t}\n}\nstruct Line {\n\tPoint a, b;\n};\nstruct Circle {\n\tPoint p; ld r;\n};\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//counter clockwise\n\tif (cross(b, c) < -eps)return -1;//clock wise\n\tif (dot(b, c) < 0)return 2;//c--a--b on line\n\tif (norm(b) < norm(c))return -2;//a--b--c on line\n\treturn 0; //a--c--b on line\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2 * d);\n\tld dfr = c1.r*c1.r - rc * rc;\n\tif (abs(dfr) < eps)dfr = 0.0;\n\tif (dfr < 0.0)return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0)res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\nbool isis_ss(Line s, Line t) {\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps)return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\nvector<Point> is_sc(Circle c, Line s) {\n\tvector<Point> res, cop; cop = is_lc(c, s);\n\tint len = cop.size();\n\trep(k, len) {\n\t\tif (ccw(s.a, cop[k], s.b) == -2) {\n\t\t\tres.push_back(cop[k]);\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct edge {\n\tint to; ld cost;\n};\ntypedef pair<ld, int> speP;\n\nint n;\n\nvoid solve() {\n\tvector<Circle> c(n);\n\tvector<Line> a(n-1);\n\trep(i, n) {\n\t\tld x, y, r; cin >> x >> y >> r;\n\t\tc[i] = { {x,y},r };\n\t}\n\tvector<vector<Point>> v(n-1);\n\trep(i, n - 1) {\n\t\tv[i].resize(2);\n\t\tvector<Point> p=is_cc(c[i], c[i + 1]);\n\t\trep(j, 2)v[i][j] = p[j];\n\t\ta[i] = { v[i][0],v[i][1] };\n\t}\n\tvector<vector<edge>> G(2*n);\n\trep(i, n - 1) {\n\t\tRep(j,i+1, n - 1) {\n\t\t\trep(k1, 2) {\n\t\t\t\trep(k2, 2) {\n\t\t\t\t\tPoint le = v[i][k1],ri=v[j][k2];\n\t\t\t\t\tLine l = { le,ri };\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tRep1(k, i + 1, j - 1) {\n\t\t\t\t\t\tif (!isis_ss(l, a[k])) {\n\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tld dis = abs(ri - le);\n\t\t\t\t\t\t//cout << 2 * i + k1 << \" \" << 2 * j + k2 << \" \" << le << \" \" << ri << \" \" << dis << endl;\n\t\t\t\t\t\tG[2 * i + k1].push_back({2*j+k2,dis});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n - 1) {\n\t\tPoint le = c[0].p;\n\t\trep(j, 2) {\n\t\t\tPoint ri = v[i][j];\n\t\t\tLine l = { le,ri };\n\t\t\tbool f = true;\n\t\t\trep(k, i) {\n\t\t\t\tif (!isis_ss(l, a[k])) {\n\t\t\t\t\tf = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tld dis = abs(ri - le);\n\n\t\t\t\t//cout << 2 * n-2 << \" \" << 2 * i+j << \" \" << le << \" \" << ri << \" \" << dis << endl;\n\t\t\t\tG[2 * n - 2].push_back({ 2 * i + j,dis });\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n - 1) {\n\t\tPoint ri = c[n-1].p;\n\t\trep(j, 2) {\n\t\t\tPoint le = v[i][j];\n\t\t\tLine l = { le,ri };\n\t\t\tbool f = true;\n\t\t\tRep(k, i+1,n-1) {\n\t\t\t\tif (!isis_ss(l, a[k])) {\n\t\t\t\t\tf = false; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tld dis = abs(ri - le);\n\t\t\t\t//cout << 2 * i + j << \" \" << 2 * n-1 << \" \" << le << \" \" << ri << \" \" << dis << endl;\n\t\t\t\tG[2 * i+j].push_back({ 2 * n-1,dis });\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tPoint le = c[0].p, ri = c[n - 1].p;\n\t\tLine l = { le,ri };\n\t\tbool f = true;\n\t\trep(k, n - 1) {\n\t\t\tif (!isis_ss(l, a[k])) {\n\t\t\t\tf = false; break;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tld dis = abs(ri - le);\n\t\t\tG[2 * n - 2].push_back({ 2 * n - 1,dis });\n\t\t}\n\n\t}\n\n\tvector<ld> dist(2 * n, mod);\n\tdist[2*n-2] = 0;\n\tpriority_queue<speP, vector<speP>, greater<speP>> q;\n\tq.push({ 0,2 * n - 2 });\n\twhile (!q.empty()) {\n\t\tspeP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\tif (p.first > dist[id])continue;\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j].to;\n\t\t\tld nd = G[id][j].cost + p.first;\n\t\t\tif (nd < dist[to]) {\n\t\t\t\tdist[to] = nd;\n\t\t\t\tq.push({ nd,to });\n\t\t\t}\n\t\t}\n\t}\n\t/*rep(i, 2 * n) {\n\t\tcout << i << \" \" << dist[i] << endl;\n\t}*/\n\tcout << dist[2 * n - 1] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(9);\n\t//init();\n\twhile (cin >> n,n)solve();\n\t//solve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n \nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n  }\n  bool operator == (const P& a, const P& b) {\n    return a.real()==b.real()&&a.imag()==b.imag();\n  }\n}\nP pin(){\n  double x,y;\n  char d;\n  cin>>x>>y;\n  P p(x,y);\n  return p;\n}\nvoid PIN(P* a,int n){\n  rep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n  double t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n  return p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n  return (distanceLP(l,c.c) < c.r+EPS &&\n  (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n  }*/\nint intersectCS(C c,L &l){\n  if(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n  const double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n  if(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n  if(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n  const P h=projection(l,c.c);\n  if(dot(l[0]-h,l[1]-h)<0)return 2;\n  return 0;\n}\nP crosspointSS(L a,L b){\n  double t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n  double t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n  return b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n  P pr=projection(l,c.c);\n  P e=(l[1]-l[0])/abs(l[1]-l[0]);\n  double t=sqrt(c.r*c.r-norm(pr-c.c));\n  P a=pr+t*e;\n  P b=pr-t*e;\n  if(b<a)swap(a,b);\n  return L(a,b);\n}\nL crosspointCS(C c,L l){\n  if(intersectCS(c,l)==2)return crosspointCL(c,l);\n  L ret=crosspointCL(c,l);\n  if(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n  else ret[0]=ret[1];\n  return ret;\n}\nL crosspointCC(C a,C b){\n  P tmp=b.c-a.c;\n  double d=abs(tmp);\n  double q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n  double t=arg(tmp);//atan(tmp.imag()/tmp.real());\n  P p1=a.c+polar(a.r,t+q);\n  P p2=a.c+polar(a.r,t-q);\n  if(p2<p1)swap(p1,p2);\n  return L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n  double S =0;\n  for(int i =0;i <g.size();i++){\n    S +=(cross(g[i],g[(i+1)%g.size()]));\n  }\n  return abs(S/2.0);\n}\nbool isconvex(const G &g){\n  int n=g.size();\n  rep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n  return true;\n}\nint inconvex(const G& g, const P& p) {\n  bool in = false;\n  int n=g.size();\n  rep(i,n){\n    P a=g[i%n]-p;\n    P b=g[(i+1)%n]-p;\n    if(imag(a)>imag(b))swap(a, b);\n    if(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n    if(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n  }\n  return in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n  int n=ps.size(),k=0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n  for(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n    while(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n  ch.resize(k-1);\n  return ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n  return p*exp(P(.0,t*PI/180.0));\n}\nvector<L> tangentCC(C a,C b){\n  if(a.r<b.r)swap(a,b);\n  double d=abs(a.c-b.c);\n  vector<L>l;\n  if(d<EPS)return l;\n  if(a.r+b.r<d-EPS){//hanareteiru\n    double t=acos((a.r+b.r)/d);\n    t=t*180/PI;\n    l.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n    l.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n  }else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n    P p=a.c+a.r/d*(b.c-a.c);\n    l.pb(L(p,p+turn(b.c-a.c,90)));\n  }\n  if(abs(a.r-b.r)<d-EPS){//majiwatteiru\n    double t1=acos((a.r-b.r)/d);\n    t1=t1*180/PI;\n    double t2=180-t1;\n    l.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n    l.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n  }else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n    P p=a.c+a.r/d*(b.c-a.c);\n    l.pb(L(p,p+turn(b.c-a.c,90)));\n  }\n  return l;\n}\nvoid printL(const L &out){\n  printf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n  P p=pin();\n  double r;\n  cin>>r;\n  return C(p,r);\n}\nbool para(L a,L b){\n  return (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\n \n \ndouble Min(double a,double b){return (a<b?a:b);}\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<C>c;\n    rep(i,n){\n      double a,b;\n      cin>>a>>b;\n      P p(a,b);\n      double r;\n      cin>>r;\n      c.pb(C(p,r));\n    }\n    vector<L>g;\n    g.pb(L(c[0].c,P(inf,inf)));\n    rep(i,n-1){\n      L l=crosspointCC(c[i],c[i+1]);\n      g.pb(l);\n    }\n    g.pb(L(c[n-1].c,P(inf,inf)));\n    vector<vector<double> >dp(n+1,vector<double>(2,inf));\n    dp[0][0]=0;\n    rep(i,n)rep(j,2){\n      if(i==0&&j==1)continue;\n      P p=g[i][j];\n      loop(k,i+1,n+1)rep(l,2){\n    if(k==n&&l==1)continue;\n    bool h=true;\n    loop(q,i+1,k){\n      if(q==n)continue;\n      if(intersectSS(L(p,g[k][l]),L(g[q][0],g[q][1]))==0)h=false;\n    }\n    if(h){\n      dp[k][l]=Min(dp[k][l],dp[i][j]+abs(g[k][l]-g[i][j]));\n    }\n      }\n    }\n    printf(\"%.9f\\n\",Min(dp[n][0],dp[n][1]));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "import java.awt.geom.Line2D;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tdouble[] r = new double[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tdouble[][] p = new double[2 * n][];\n\t\t\tp[0] = new double[] { x[0], y[0] };\n\t\t\tp[2 * n - 1] = new double[] { x[n - 1], y[n - 1] };\n\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tdouble a = -2 * (x[i] - x[i + 1]);\n\t\t\t\tdouble b = -2 * (y[i] - y[i + 1]);\n\t\t\t\tdouble c = x[i] * x[i] - x[i + 1] * x[i + 1] + y[i] * y[i] - y[i + 1] * y[i + 1] - r[i] * r[i]\n\t\t\t\t\t\t+ r[i + 1] * r[i + 1];\n\n\t\t\t\tdouble w = -c * a / (a * a + b * b);\n\t\t\t\tdouble v = -c * b / (a * a + b * b);\n\n\t\t\t\tdouble f = 1 / (a * a + b * b) * (-b * (w - x[i]) + a * (v - y[i]));\n\t\t\t\tdouble g = 1 / (a * a + b * b) * ((w - x[i]) * (w - x[i]) + (v - y[i]) * (v - y[i]) - r[i] * r[i]);\n\t\t\t\tdouble t1 = -f + Math.sqrt(f * f - g);\n\t\t\t\tdouble t2 = -f - Math.sqrt(f * f - g);\n\t\t\t\tp[2 * i + 1] = new double[] { w - b * t1, v + a * t1 };\n\t\t\t\tp[2 * i + 2] = new double[] { w - b * t2, v + a * t2 };\n\n\t\t\t}\n\n\t\t\tLine2D.Double[] seg = new Line2D.Double[n - 1];\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tseg[i] = new Line2D.Double(p[2 * i + 1][0], p[2 * i + 1][1], p[2 * i + 2][0], p[2 * i + 2][1]);\n\t\t\t}\n\n\t\t\tdouble[][] dis = new double[2 * n][2 * n];\n\t\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\t\tfor (int j = 0; j < 2 * n; ++j) {\n\t\t\t\t\tif (i != j)\n\t\t\t\t\t\tdis[i][j] = Double.MAX_VALUE / 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int src = 0; src < 2 * n; ++src) {\n\t\t\t\tfor (int dst = src + 1; dst < 2 * n; ++dst) {\n\t\t\t\t\tint s = (src == 0 ? -1 : (src - 1) / 2) + 1;\n\t\t\t\t\tint d = (dst - 1) / 2 - 1;\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tLine2D.Double path = new Line2D.Double(p[src][0], p[src][1], p[dst][0], p[dst][1]);\n\t\t\t\t\tfor (int i = s; i <= d; ++i) {\n\t\t\t\t\t\tif (!path.intersectsLine(seg[i]))\n\t\t\t\t\t\t\tf = false;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tdouble distance = Math.sqrt((p[src][0] - p[dst][0]) * (p[src][0] - p[dst][0])\n\t\t\t\t\t\t\t\t+ (p[src][1] - p[dst][1]) * (p[src][1] - p[dst][1]));\n\t\t\t\t\t\tdis[src][dst] = distance;\n\t\t\t\t\t\tdis[dst][src] = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int mid = 0; mid < 2 * n; ++mid) {\n\t\t\t\tfor (int src = 0; src < 2 * n; ++src) {\n\t\t\t\t\tfor (int dst = 0; dst < 2 * n; ++dst) {\n\t\t\t\t\t\tdis[src][dst] = Math.min(dis[src][dst], dis[src][mid] + dis[mid][dst]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(dis[0][2 * n - 1]);\n\n\t\t}\n\t\tsc.close();\n\t\tpw.close();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* 解答時間→ 101:22(途中) */\n#include <cmath>\n#include <iomanip>\n#include <iostream>\t\t//基本入出力\nusing namespace std;\n\ndouble dist2d(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main(){\n\tcout << setprecision(16);\n\twhile(1){\n\t\t//入力\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tdouble x[25],y[25],r[25];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\t\tint V = n * 2;\n\t\tdouble pos_x[50], pos_y[50];\n\t\tpos_x[0] = x[0];\n\t\tpos_y[0] = y[0];\n\t\tpos_x[V - 1] = x[n - 1];\n\t\tpos_y[V - 1] = y[n - 1];\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tdouble d = sqrt(1.0 * (x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1]));\n\t\t\tdouble a = (d * d + r[i] * r[i] - r[i + 1] * r[i + 1]) / (d * 2);\n\t\t\tdouble b = sqrt(-a * a + r[i] * r[i]);\n\t\t\tdouble va_x = a * (x[i + 1] - x[i]) / d, va_y = a * (y[i + 1] - y[i]) / d;\n\t\t\tdouble vb_x = b * (y[i] - y[i + 1]) / d, vb_y = b * (x[i + 1] - x[i]) / d;\n\t\t\tpos_x[i * 2 + 1] = va_x + vb_x + x[i];\n\t\t\tpos_y[i * 2 + 1] = va_y + vb_y + y[i];\n\t\t\tpos_x[i * 2 + 2] = va_x - vb_x + x[i];\n\t\t\tpos_y[i * 2 + 2] = va_y - vb_y + y[i];\n\t\t}\n\t\t//総当りで距離を計算\n\t\tdouble dist[50][50];\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\t//dist[i][j] = DBL_MAX;\n\t\t\t\tdist[i][j] = sqrt(2.0 * 1000 * 1000);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < V - 1; i++){\n\t\t\tfor(int j = i + 1; j < V; j++){\n\t\t\t\t//交差判定(準備)\n\t\t\t\tint flg = 1;\n\t\t\t\tdouble x1, y1, x2, y2, x3, y3, x4, y4;\n\t\t\t\tx1 = pos_x[i];\n\t\t\t\ty1 = pos_y[i];\n\t\t\t\tx2 = pos_x[j];\n\t\t\t\ty2 = pos_y[j];\n\t\t\t\tint pos_ls, pos_lg;\n\t\t\t\tif(i == 0)\n\t\t\t\t\tpos_ls = 1;\n\t\t\t\telse\n\t\t\t\t\tpos_ls = (i + 1) / 2 + 1;\n\t\t\t\tif(j == V - 1)\n\t\t\t\t\tpos_lg = n - 1;\n\t\t\t\telse\n\t\t\t\t\tpos_lg = (j + 1) / 2 - 1;\n\t\t\t\t//交差判定(本番)\n\t\t\t\tdouble ta, tb, tc, td;\n\t\t\t\tfor(int k = pos_ls; k <= pos_lg; k++){\n\t\t\t\t\tx3 = pos_x[k * 2 - 1];\n\t\t\t\t\ty3 = pos_y[k * 2 - 1];\n\t\t\t\t\tx4 = pos_x[k * 2];\n\t\t\t\t\ty4 = pos_y[k * 2];\n\t\t\t\t\tta = (x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\t\t\t\ttb = (x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\t\t\t\ttc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\t\t\t\ttd = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\t\t\tif((tc*td>=0.0)||(ta*tb>=0.0)){\n\t\t\t\t\t\tflg=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg == 1){\n\t\t\t\t\tdist[i][j] = dist2d(pos_x[i], pos_y[i], pos_x[j], pos_y[j]);\n\t\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ワーシャル・フロイド法\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j])\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tcout << dist[0][V - 1] << \"\\n\";\n\t}\n\tcout << flush;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nPolygon tangent(Circle c1,Circle c2){\n  Polygon p;\n  return p;\n}\n\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    Circle c[n];\n    for(int i=0;i<n;i++) cin>>c[i];\n    Segment s[n-1];\n    for(int i=0;i<n-1;i++){\n      auto p=getCrossPointCC(c[i],c[i+1]);\n      s[i]=Segment(p[0],p[1]);\n    }\n    double e[n*2][n*2];\n    for(int i=0;i<n*2;i++)\n      for(int j=0;j<n*2;j++)\n\te[i][j]=1e12;\n    int a=n*2-2,z=n*2-1;\n    {\n      bool flg=1;\n      for(int k=0;k<n-1;k++)\n\tflg&=equals(getDistanceSS(Segment(c[0].c,c[n-1].c),s[k]),0.0);\n      if(flg) e[a][z]=e[z][a]=abs(c[0].c-c[n-1].c);\n    }\n    for(int i=0;i<n;i++){\n      int u=i*2,v=i*2+1;\n      {\n\tbool flg=1;\n\tfor(int j=0;j<i;j++)\n\t  flg&=equals(getDistanceSS(Segment(c[0].c,s[i].p1),s[j]),0.0);\n\tif(flg) e[a][u]=e[u][a]=abs(c[0].c-s[i].p1);\n      }\n      {\n\tbool flg=1;\n\tfor(int j=0;j<i;j++)\n\t  flg&=equals(getDistanceSS(Segment(c[0].c,s[i].p2),s[j]),0.0);\n\tif(flg) e[a][v]=e[u][v]=abs(c[0].c-s[i].p2);\n      }\n    }\n    for(int i=n-2;i>=0;i--){\n      int u=i*2,v=i*2+1;\n      {\n\tbool flg=1;\n\tfor(int j=n-2;j>i;j--)\n\t  flg&=equals(getDistanceSS(Segment(c[n-1].c,s[i].p1),s[j]),0.0);\n\tif(flg) e[z][u]=e[u][z]=abs(c[n-1].c-s[i].p1);\n      }\n      {\n\tbool flg=1;\n\tfor(int j=n-2;j>i;j--)\n\t  flg&=equals(getDistanceSS(Segment(c[n-1].c,s[i].p2),s[j]),0.0);\n\tif(flg) e[z][v]=e[v][z]=abs(c[n-1].c-s[i].p2);\n      }\n    }\n    for(int i=0;i<n-1;i++){\n      int u=i*2,v=i*2+1;\n      for(int j=i+1;j<n-1;j++){\n\tint w=j*2,x=j*2+1;\n\t{\n\t  bool flg=1;\n\t  for(int k=i+1;k<j;k++)\n\t    flg&=equals(getDistanceSS(Segment(s[i].p1,s[j].p1),s[k]),0.0);\n\t  if(flg) e[u][w]=e[w][u]=abs(s[i].p1-s[j].p1);\n\t}\n\t{\n\t  bool flg=1;\n\t  for(int k=i+1;k<j;k++)\n\t    flg&=equals(getDistanceSS(Segment(s[i].p1,s[j].p2),s[k]),0.0);\n\t  if(flg) e[u][x]=e[x][u]=abs(s[i].p1-s[j].p2);\n\t}\n\t{\n\t  bool flg=1;\n\t  for(int k=i+1;k<j;k++)\n\t    flg&=equals(getDistanceSS(Segment(s[i].p2,s[j].p1),s[k]),0.0);\n\t  if(flg) e[v][w]=e[w][v]=abs(s[i].p2-s[j].p1);\n\t}\n\t{\n\t  bool flg=1;\n\t  for(int k=i+1;k<j;k++)\n\t    flg&=equals(getDistanceSS(Segment(s[i].p2,s[j].p2),s[k]),0.0);\n\t  if(flg) e[v][x]=e[x][v]=abs(s[i].p2-s[j].p2);\n\t}\n\t//cout<<\"u w:\"<<e[u][w]<<endl;\n\t//cout<<\"u x:\"<<e[u][x]<<endl;\n\t//cout<<\"v w:\"<<e[v][w]<<endl;\n\t//cout<<\"v x:\"<<e[v][x]<<endl;\n      }\n    }\n    for(int k=0;k<n*2;k++)\n      for(int i=0;i<n*2;i++)\n\tfor(int j=0;j<n*2;j++)\n\t  e[i][j]=min(e[i][j],e[i][k]+e[k][j]);\n    printf(\"%.12f\\n\",e[a][z]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-6;\ndouble add(double a,double b){\n    if(abs(a+b)<eps)return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\ndouble dist(P p1,P p2,P q){\n    if(dot(q-p1,p2-p1)<=0)return sqrt(dot(q-p1,q-p1));\n    if(dot(q-p2,p1-p2)<=0)return sqrt(dot(q-p2,q-p2));\n    P d=p1-p2;\n    P ret=q+P{d.second,-d.first};\n    P h=intersection(p1, p2, q, ret);\n    return sqrt(dot(q-h,q-h));\n}\ndouble d(P p,P q){\n    return sqrt(dot(p-q,p-q));\n}\n\nint main(){\n    int n;\n    vector<int>ans;\n    while(cin>>n,n!=0){\n        P a[n];\n        double r[n];\n        rep(i,n)cin>>a[i].first>>a[i].second>>r[i];\n        P b[n-1][2];\n        rep(i,n-1){\n            P v=(a[i+1]-a[i])*(1.0/d(a[i+1],a[i]));\n            P h={v.second,-v.first};\n            double l=(r[i]*r[i]+d(a[i],a[i+1])*d(a[i],a[i+1])-r[i+1]*r[i+1])/2/d(a[i],a[i+1]);\n            b[i][0]=a[i]+v*l+h*sqrt(r[i]*r[i]-l*l);\n            b[i][1]=a[i]+v*l-h*sqrt(r[i]*r[i]-l*l);\n        }\n        double x[2*n][2*n];\n        rep(i,2*n)rep(j,2*n)x[i][j]=inf;\n        rep(i,n-1)rep(j,2){\n            bool ok=true;\n            rep(k,i)if(!cross(a[0],b[i][j],b[k][0],b[k][1]))ok=false;\n            if(ok)x[0][2*i+j+1]=d(a[0],b[i][j]);\n        }\n        rep(i,n-1)rep(j,2){\n            bool ok=true;\n            REP(k,i+1,n-1)if(!cross(a[n-1],b[i][j],b[k][0],b[k][1]))ok=false;\n            if(ok)x[2*n-1][2*i+j+1]=d(a[n-1],b[i][j]);\n        }\n        rep(i,n-1)REP(j,i+1,n-1)rep(k,2)rep(l,2){\n            bool ok=true;\n            REP(m,i+1,j)if(!cross(b[i][k],b[j][l],b[m][0],b[m][1]))ok=false;\n            if(ok)x[2*i+k+1][2*j+l+1]=d(b[i][k],b[j][l]);\n        }\n        bool ok=true;\n        rep(i,n-1)if(!cross(a[0],a[n-1],b[i][0],b[i][1]))ok=false;\n        if(ok)x[0][2*n-1]=d(a[0],a[n-1]);\n        rep(i,2*n)x[i][i]=0;\n        rep(i,n)x[2*i+1][2*i+2]=d(b[i][0],b[i][1]);\n        rep(i,2*n)rep(j,2*n)x[i][j]=min(x[i][j],x[j][i]);\n        rep(i,2*n)rep(j,2*n)rep(k,2*n)x[j][k]=min(x[i][j]+x[i][k],x[j][k]);\n        cout<<setprecision(10)<<x[0][2*n-1]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tint p = ccw(at(0), at(1),  s[0]) * ccw(at(0), at(1),  s[1]);\n\t\t\tint q = ccw( s[0],  s[1], at(0)) * ccw( s[0],  s[1], at(1));\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less(abs(a.r-b.r), abs(a-b)) + less(abs(a-b), a.r+b.r) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.push_back(S(c, c));\n\t\t\telse{\n\t\t\t\ts.push_back(cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.push_back(S(prev, prev));\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.4f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <sstream>\n \nusing namespace std;\n \n#define EPS 1e-9\n\nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n} P[111],cP[111][2];\n \ndouble dis(point p1,point p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n\nstruct Line {\n\tdouble x1,y1,x2,y2;\n\tdouble Dis() {\n\t\treturn dis(point(x1,y1),point(x2,y2));\n\t}\n\tLine() {}\n\tLine(double a1, double b1, double a2, double b2) : x1(a1), y1(b1), x2(a2), y2(b2) {}\n\tLine(point p1, point p2) {\n\t\tx1 = p1.x, y1 = p1.y;\n\t\tx2 = p2.x, y2 = p2.y;\n\t}\n\tpoint point1() {return point(x1,y1);}\n\tpoint point2() {return point(x2,y2);}\n};\n\nint ccw(point p1, point p2, point p3) {\n\tdouble ret = (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x);\n\tif(abs(ret)<EPS) return 0;\n\treturn ret > 0 ? 1 : -1;\n}\n \nbool isIn(double x, double y, Line LL) {\n    if(!( min(LL.x1,LL.x2)-EPS <= x && x <= max(LL.x1,LL.x2)+EPS \n        && min(LL.y1,LL.y2)-EPS <= y && y <= max(LL.y1,LL.y2)+EPS))\n        return false;\n    return abs( (LL.y1-y) * (LL.x2-x) - (LL.y2-y) * (LL.x1-x) ) < EPS;\n}\n \nbool isCross(Line L1, Line L2) {\n    if(abs(L1.x1-L2.x1)<EPS && abs(L1.y1-L2.y1)<EPS\n        || abs(L1.x2-L2.x2)<EPS && abs(L1.y2-L2.y2)<EPS        || abs(L1.x1-L2.x2)<EPS && abs(L1.y1-L2.y2)<EPS        || abs(L1.x2-L2.x1)<EPS && abs(L1.y2-L2.y1)<EPS)\n        return true;\n \n    if(isIn(L1.x1,L1.y1,L2) || isIn(L1.x2,L1.y2,L2))\n        return true;\n    if(isIn(L2.x1,L2.y1,L1) || isIn(L2.x2,L2.y2,L1))\n        return true;\n \n    int ccw1, ccw2;\n \n    ccw1=ccw(L1.point1(),L1.point2(),L2.point1());\n    ccw2=ccw(L1.point1(),L1.point2(),L2.point2());\n \n    if(ccw1 * ccw2 >= 0) return false;\n \n    ccw1=ccw(L2.point1(),L2.point2(),L1.point1());\n    ccw2=ccw(L2.point1(),L2.point2(),L1.point2());\n \n    if(ccw1 * ccw2 >= 0) return false;\n \n    return true;\n}\n \npoint intersection(point &u1,point &u2,point &v1,point &v2){\n    point ret=u1;\n    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\n    /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\n    ret.x+=(u2.x-u1.x)*t;\n    ret.y+=(u2.y-u1.y)*t;\n    return ret;\n}\n \nvoid intersection_line_circle(point c, double r,point &l1,point &l2,point& p1,point&p2){\n    point p=c;\n    double t;\n    p.x+=l1.y-l2.y;\n    p.y+=l2.x-l1.x;\n    p=intersection(p,c,l1,l2);\n    t=sqrt(r*r-dis(p,c)*dis(p,c))/dis(l1,l2);\n    p1.x=p.x+(l2.x-l1.x)*t;\n    p1.y=p.y+(l2.y-l1.y)*t;\n    p2.x=p.x-(l2.x-l1.x)*t;\n    p2.y=p.y-(l2.y-l1.y)*t;\n}\n \nvoid intersection_circle_circle(point c1, double r1,point c2,double r2,point& p1, point& p2){\n    point u,v;\n    double t;\n    t=(1+(r1*r1-r2*r2)/dis(c1,c2)/dis(c1,c2))/2;\n    u.x=c1.x+(c2.x-c1.x)*t;\n    u.y=c1.y+(c2.y-c1.y)*t;\n    v.x=u.x+c1.y-c2.y;\n    v.y=u.y-c1.x+c2.x;\n    intersection_line_circle(c1,r1,u,v,p1,p2);\n}\n\nint X[111],Y[111],R[111],n;\ndouble dp[111][2];\nLine LL[111];\n\nint main() {\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\twhile(1) {\n\t\tfor(int i=0;i<111;++i) dp[i][0] = 1e20, dp[i][1] = 1e20;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tfor(int i=0;i<n;++i) scanf(\"%d%d%d\",X+i,Y+i,R+i), P[i] = point(X[i],Y[i]);\n\t\tcP[0][0] = P[0], cP[0][1] = P[0];\n\t\tcP[n][0] = P[n-1], cP[n][1] = P[n-1];\n\t\tfor(int i=0;i<n-1;++i) {\n\t\t\tintersection_circle_circle(P[i],R[i],P[i+1],R[i+1],cP[i+1][0],cP[i+1][1]);\n\t\t\tLL[i+1] = Line(cP[i+1][0],cP[i+1][1]);\n\t\t}\n\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\tfor(int i=1;i<=n;++i) for(int ai=0;ai<2;++ai) {\n\t\t\tfor(int j=0;j<i;++j) for(int aj=0;aj<2;++aj) {\n\t\t\t\tbool can = 1;\n\t\t\t\tLine line = Line(cP[i][ai],cP[j][aj]);\n\t\t\t\tfor(int k=j+1;k<i;++k) {\n\t\t\t\t\tif(!isCross(line,LL[k])) {can = 0; break;}\n\t\t\t\t}\n\n\t\t\t\tif(can) dp[i][ai] = min(dp[i][ai], dp[j][aj] + line.Dis());\n\t\t\t}\n\t\t} printf(\"%.10lf\\n\",dp[n][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n//#define DEBUG(x) \n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-9\n#define INT(a) int((a)+1e-9)\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\ntypedef pair<int,int> Pii;\ntypedef complex<double> Point;\n\ndouble dotProd(Point ap, Point bp){\n\treturn real(conj(ap)*bp);\n}\ndouble croProd(Point ap, Point bp){\n\treturn imag(conj(ap)*bp);\n}\n\nPoint rotated(Point p, double th){\n\treturn Point(cos(th), sin(th)) * p;\n};\n\nstruct Line{\n\tPoint ap;\n\tPoint bp;\n\tPoint dp;\n\tLine(){}\n\tLine(Point ap_, Point bp_){ ap=ap_; bp=bp_; dp=bp-ap;}\n};\n\nstruct Segline{\n\tPoint ap;\n\tPoint bp;\n\tPoint dp;\n\tSegline(){}\n\tSegline(Point ap_, Point bp_){ ap=ap_; bp=bp_; dp=bp-ap;}\n\tdouble length(){ return abs(dp);}\n};\n\nstruct Circle{\n\tPoint cp;\n\tdouble r;\n\tCircle(){}\n\tCircle(Point cp_, double r_){ cp=cp_; r=r_;}\n};\n\nSegline getSeglineOfCrossingPoints_Circle_Circle(Circle m, Circle n){\n\tdouble d = abs(n.cp-m.cp);\n\tdouble x = (d*d+m.r*m.r-n.r*n.r)/(2*d);\n\tdouble y = sqrt(m.r*m.r-x*x);\n\tdouble th= arg(n.cp-m.cp);\n\tPoint ap = rotated(Point(x,y),th) + m.cp;\n\tPoint bp = rotated(Point(x,-y), th) + m.cp;\n\treturn Segline(ap,bp);\n}\n\nbool isCross_Line_Segline(Line m, Segline n){\n\tdouble det=croProd(m.dp,n.dp);\n\tif(abs(det)<EPS) return false;\n\tdouble s=croProd(n.dp, m.ap-n.ap)/det;\n\tdouble t=croProd(m.dp, m.ap-n.ap)/det;\n\t//DEBUG(s);DEBUG(t);\n\tif(0-EPS<=t && t<=1+EPS) return true;\n\telse return false;\n}\n\n\n#define SUPcl 102\n#define INF 1e+9\n\nint cl;\nCircle cs[SUPcl];\nSegline segs[SUPcl];\nCircle startc;\nCircle endc;\ndouble startc_endc_w;\ndouble startc_c_w[SUPcl][2];\ndouble c_endc_w[SUPcl][2];\ndouble c_c_w[SUPcl][2][SUPcl][2];\ndouble c_d[SUPcl][2];\ndouble re;\n\nvoid calc_segs(){\n\tFOR(ci,0,cl-1){\n\t\tSegline l = getSeglineOfCrossingPoints_Circle_Circle(cs[ci],cs[ci+1]);\n\t\tsegs[ci]=l;\n\t\t//DEBUG(ci); DEBUG(l.ap); DEBUG(l.bp);\n\t}\n}\n\ndouble calc_startc_endc_w(){\n\tLine m = Line(startc.cp, endc.cp);\n\tstartc_endc_w=abs(m.dp);\n\tFOR(ci,0,cl-1){\n\t\tSegline n=segs[ci];\n\t\tif(!isCross_Line_Segline(m,n)){startc_endc_w=INF; break;}\n\t}\n\t//DEBUG(startc_endc_w);\n}\ndouble calc_startc_c_w(){\n\tFOR(cj,0,cl-1) FOR(j,0,2){\n\t\tLine m = Line(startc.cp, j ? segs[cj].bp : segs[cj].ap);\n\t\tstartc_c_w[cj][j]=abs(m.dp);\n\t\tFOR(ck,0,cj){\n\t\t\tSegline n=segs[ck];\n\t\t\tif(!isCross_Line_Segline(m,n)){startc_c_w[cj][j]=INF; break;}\n\t\t}\n\t\t//DEBUG(cj);DEBUG(j);DEBUG(startc_c_w[cj][j]);\n\t}\n}\ndouble calc_c_endc_w(){\n\tFOR(ci,0,cl-1) FOR(i,0,2){\n\t\tLine m = Line(i ? segs[ci].bp : segs[ci].ap, endc.cp);\n\t\tc_endc_w[ci][i]=abs(m.dp);\n\t\tFOR(ck,ci+1,cl-1){\n\t\t\tSegline n=segs[ck];\n\t\t\tif(!isCross_Line_Segline(m,n)){c_endc_w[ci][i]=INF; break;}\n\t\t}\n\t\t//DEBUG(ci);DEBUG(i);DEBUG(c_endc_w[ci][i]);\n\t}\n}\ndouble calc_c_c_w(){\n\tFOR(ci,0,cl-1) FOR(i,0,2) FOR(cj,ci+1,cl-1) FOR(j,0,2){\n\t\tLine m = Line(i ? segs[ci].bp : segs[ci].ap, j ? segs[cj].bp : segs[cj].ap);\n\t\tc_c_w[ci][i][cj][j]=abs(m.dp);\n\t\tFOR(ck,ci+1,cj){\n\t\t\tSegline n=segs[ck];\n\t\t\tif(!isCross_Line_Segline(m,n)){c_c_w[ci][i][cj][j]=INF; break;}\n\t\t}\n\t\t//DEBUG(ci);DEBUG(i);DEBUG(cj);DEBUG(j);DEBUG(c_c_w[ci][i][cj][j]);\n\t}\n}\n\ndouble calc_c_d(){\n\tFOR(cj,0,cl-1) FOR(j,0,2){\n\t\tc_d[cj][j]= startc_c_w[cj][j];\n\t}\n\tFOR(ci,0,cl-1) FOR(i,0,2) FOR(cj,ci+1,cl-1) FOR(j,0,2){\n\t\tc_d[cj][j]= min( c_d[cj][j], c_d[ci][i] + c_c_w[ci][i][cj][j] );\n\t}\n}\n\ndouble calc_re(){\n\tre=startc_endc_w;\n\tFOR(ci,0,cl-1) FOR(i,0,2){\n\t\tre = min(re, c_d[ci][i] + c_endc_w[ci][i]);\n\t}\n}\n\n\n\n\nint main(){\n\twhile(true){\n\t\tcin>>cl;\t\tif(!cl)break;\n\t\tFOR(ci,0,cl){\n\t\t\tint x,y,r;\n\t\t\tcin>>x>>y>>r;\n\t\t\tcs[ci]=Circle(Point(x,y),r);\n\t\t}\n\t\tcalc_segs();\n\t\tstartc=cs[0]; endc=cs[cl-1];\n\t\tcalc_startc_endc_w();\n\t\tcalc_startc_c_w();\n\t\tcalc_c_endc_w();\n\t\tcalc_c_c_w();\n\t\tcalc_c_d();\n\t\tcalc_re();\n\t\tcout<<re<<endl;\n\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //std==c++14\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a,b) ( fabs(a-b) < EPS )\n#define PI acos(-1)\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intersect Circle and Circle\nstatic const int ICC_SEPARATE = 4;//離れている\nstatic const int ICC_CIRCUMSCRIBE = 3;//外接\nstatic const int ICC_INTERSECT = 2;// 交わる\nstatic const int ICC_INSCRIBE = 1;// 内接\nstatic const int ICC_CONTAIN = 0;//内包\n\nstruct point{\n\tdouble x,y;\n\t//construct\n\tpoint() {} \n\tpoint(double x,double y):x(x),y(y){}\n\t//演算子\n\tpoint operator + (point p) { return point(x+p.x,y+p.y); }\n\tpoint operator - (point p) { return point(x-p.x,y-p.y); }\n\tpoint operator * (double k) { return point(x*k,y*k); }\n\tpoint operator / (double k) { return point(x/k,y/k); }\n\tpoint operator / (point p) { return point( (x*p.x + y*p.y)/p.norm()  , (-x*p.y + y*p.x)/p.norm() ) ; }\n\tbool operator < (point p) { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (point p) { return equals(x,p.x) && equals(y,p.y) ; }\n\t//function\n\tdouble arg() { return atan2(y,x) ; }\n\tdouble norm(){return x*x+y*y; }\n\tdouble abs() { return sqrt(norm() ) ;}\n\tdouble dot(point p) { return p.x*x + p.y*y; }\n\tdouble cross(point p) { return x*p.y - y*p.x; }\n\tpoint roll(double theta){ return point( cos(theta)*x - sin(theta)*y , sin(theta)*x + cos(theta)*y ) ; }\t\n\t//input output\n\tvoid input(){cin>>x>>y;}\n\tvoid polar(double r,double theta){ x = r*cos(theta), y= r*sin(theta) ; }\n\tvoid print(){cout<<x<<' '<<y<<endl;};\n\n};\n\nbool sort_x(point a,point b){\n\treturn a.x!=b.x?a.x<b.x:a.y<b.y ;\n}\nbool sort_y(point a,point b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x ;\n}\n\ntypedef vector<point> polygon;\n\nstruct segment{\n\tpoint s,t;\n\tsegment() {}\n\tsegment(point s,point t) : s(s),t(t){}\n\tvoid input(){s.input(),t.input(); }\n};\ntypedef segment line;\n\nstruct circle{\n\tpoint c;\n\tdouble r;\n\tcircle() {}\n\tcircle(point c,double r) : c(c),r(r){}\n\tvoid input(){c.input(); cin>>r; }\n};\n\ndouble norm(point a){\treturn a.norm(); }\ndouble abs(point a){ return a.abs(); }\ndouble arg(point a){ return a.arg(); }\ndouble dot(point a,point b) { return a.x*b.x + a.y*b.y ; }\ndouble cross(point a,point b) { return a.x * b.y - a.y * b.x ; }\npoint polar(double r,double theta){ point a; a.polar(r,theta); return a; }\npoint orth(point p){ return point(-p.y,p.x); }\n\n//isOrthgonal 垂直\nbool isOrthogonal(point a,point b) { return equals(dot(a,b), 0.0 ) ; }\nbool isOrthogonal(point a,point b,point c,point d) { return isOrthogonal(a-b,c-d) ; }\nbool isOrthogonal(line l1,line l2 ){ return isOrthogonal(l1.t-l1.s,l2.t-l2.s); }\n//isParallel 平行\nbool isParallel(point a,point b) { return equals(cross(a,b), 0.0) ; }\nbool isParallel(point a,point b,point c,point d) { return isParallel(a-b,c-d); }\nbool isParallel(line l1,line l2) { return isParallel(l1.t-l1.s,l2.t-l2.s) ; }\n\npoint project(line l,point p){\n\tpoint base = l.t-l.s;\n\tdouble r = dot(p-l.s,base) / norm(base) ;\n\treturn l.s + base*r;\n}\npoint reflect(line l,point p){\n\treturn p + (project(l,p) - p) *2.0;\n}\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\n\tif(cross(a,b) > EPS ) return CCW_COUNTER_CLOCKWISE ;\n\tif(cross(a,b) < -EPS ) return CCW_CLOCKWISE;\n\tif(dot(a,b) < -EPS ) return CCW_ONLINE_BACK;\n\tif(a.norm() < b.norm() ) return CCW_ONLINE_FRONT;\n\treturn CCW_ON_SEGMENT;\n}\n\n\n//intersect\nbool intersect(point p1,point p2,point p3,point p4){return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 ) ; }\nbool intersect(line l1,line l2) { return intersect(l1.s,l1.t,l2.s,l2.t) ; }\nbool intersect(polygon p,line l){\n\tint n = p.size();\n\tfor(int i=0;i<n;i++)  if(intersect(line(p[i],p[(i+1)%n] ) , l ) ) return true;\n\treturn false;\n}\nint intersect(circle c1,circle c2){\n\tif(c1.r < c2.r) swap(c1,c2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble r = c1.r + c2.r;\n\tif(equals(d,r) ) return ICC_CIRCUMSCRIBE;\n\tif(d > r ) return ICC_SEPARATE;\n\tif(equals(d+c2.r,c1.r) ) return ICC_INSCRIBE;\n\tif( d + c2.r < c1.r ) return ICC_CONTAIN;\n\treturn ICC_INTERSECT;\n}\n\n//bool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; } distanceののち\nint intersectcs(circle c,line l ){// 0\t\t1\t\t2\n\tif(norm(project(l,c.c) - c.c )  - c.r*c.r  > EPS ) return 0;\n\tdouble d1 = abs(c.c-l.s),d2  = abs(c.c-l.t);\n\tif(d1 < c.r + EPS && d2 < c.r + EPS ) return 0;\n\tif( (d1<c.r - EPS && d2 > c.r +EPS) || (d1 > c.r +EPS &&d2 < c.r -EPS ) ) return 1;\n\tpoint h = project(l,c.c) ;\n\tif(dot(l.s-h,l.t-h) < 0 ) return 2;\n\treturn 0;\n}\n\n//distance\n//line point\ndouble distancelp(line l,point p){ return abs(cross(l.t-l.s,p-l.s)/ abs(l.t-l.s)  ); }\n//segment point\ndouble distancesp(line l,point p){ \n\tif(dot(l.t-l.s,p-l.s) < 0.0 ) return abs(p-l.s);\n\tif(dot(l.s-l.t,p-l.t) < 0.0 ) return abs(p-l.t);\n\treturn distancelp(l,p);\n}\n//segment segment \ndouble distancess(line l1,line l2){\n\tif(intersect(l1,l2) ) return 0.0;\n\treturn min( min(distancesp(l1,l2.s) ,distancesp(l1,l2.t) ) , min(distancesp(l2,l1.s),distancesp(l2,l1.t)  ) );\n}\n\nbool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; }\n\n//crosspoint \n//segment segment\npoint crosspointss(line l1,line l2){\n\tfor(int k=0;k<2;k++){\n\t\tif(distancesp(l1,l2.s) < EPS ) return l2.s;\n\t\tif(distancesp(l1,l2.t) < EPS ) return l2.t;\n\t\tswap(l1,l2);\n\t}\n\tpoint base = l2.t-l2.s;\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.t-l2.s) );\n\tdouble t = d1/(d1+d2);\n\treturn l1.s + (l1.t-l1.s) * t;\n}\n//line line\npoint crosspointll(line l1,line l2){\n\tdouble a = cross(l1.t-l1.s,l2.t-l2.s);\n\tdouble b = cross(l1.t-l1.s,l1.t-l2.s);\n\tif(abs(a) < EPS && abs(b) < EPS ) return l2.s;\n\treturn l2.s + (l2.t-l2.s) * (b/a) ;\n}\n//circle line\npolygon crosspointCL(circle c,line l){\n\tpolygon ps;\n\tpoint pr = project(l,c.c);\n\tpoint e = (l.t - l.s) / abs(l.t-l.s) ;\n\tif(equals(distancelp(l,c.c),c.r) ){\n\t\tps.emplace_back(pr);\n\t\treturn ps;\n\t}\n\tdouble base = sqrt(c.r*c.r - norm(pr-c.c) );\n\tps.emplace_back(pr + e*base ) ;\n\tps.emplace_back(pr - e*base ) ;\n\treturn ps;\n}\n//circle segment\npolygon crosspointCS(circle c,line l ){\n\tpolygon res = crosspointCL(c,l);\n\tif(intersectcs(c,l) == 2 ) return res;\n\tif(res.size() > 1u ){//一つのみ削る\n\t\tif(dot(l.s-res[0] ,l.t-res[0] ) > 0) swap(res[0],res[1] );\n\t\tres.pop_back();\n\t}\n\treturn res;\n}\npolygon crosspointcc(circle c1,circle c2){\n\tpolygon p(2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble a = acos( (c1.r *c1.r + d*d -c2.r*c2.r) /(2*c1.r*d ) );\n\tdouble t = arg(c2.c-c1.c);\n\tp[0] = c1.c + polar(c1.r,t+a);\n\tp[1] = c1.c + polar(c1.r,t-a);\n\t//if(cross(c2.c-c1.c,p[0]-c1.c) > EPS) swap(p[0],p[1]); //c1に関する偏角の順\n\treturn p;\n}\n\nint contains(polygon g,point p) { //IN:2 ON:1 OUT:0\n    int n = g.size();\n    bool f = false;\n    for(int i=0;i<n;i++){\n\tpoint a = g[i] - p,b = g[(i+1)%n] - p;\n\tif( fabs(cross(a,b) ) < EPS && dot(a,b) < EPS) return 1;\n\tif( a.y > b.y ) swap(a,b);\n\tif( a.y < EPS && EPS < b.y && cross(a,b) > EPS ) f = !f;\n    }\n    return (f?2:0) ;\n}\n\npolygon andrewscan(polygon &s){ //convex hull\n\tpolygon u,l;\n\tif(s.size() < 3) return s;\n\t//sort(s.begin(),s.end() );\n\t//最も左で最も右の点にする\n\tsort(s.begin(),s.end(),sort_y);\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\tfor(int i=2;i<s.size();i++){\n\t\tfor(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\n\t\t//for(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tu.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\t\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tl.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n\ndouble diameter(polygon &s){\n\tpolygon p = s;\n\tint n = p.size();\n\tif(n==2) return abs(p[0]-p[1]);\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++){\n\t\tif(p[i] < p[k]) i = k;\n\t\tif(!(p[j]<p[k]) ) j = k;\n\t}\n\tdouble res = 0;\n\tint si = i,sj = j;\n\twhile( i != sj || j != si ){\n\t\tres = max(res,abs(p[i]-p[j]) );\n\t\tif(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j] ) < 0.0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\nbool isconvex(polygon p){\n\tbool f = 1;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tint t = ccw(p[(i+n-1)%n],p[i],p[(i+1)%n] );\n\t\tf&= t!=CCW_CLOCKWISE;\n\t}\n\treturn f;\n}\ndouble area(polygon p){\n\tdouble res =  0.0;\n\tfor(int i=0;i<p.size();i++) res += cross(p[i],p[ (i+1)%p.size() ]);\n\treturn res/2.0;\n}\ndouble area(circle c1,circle c2){\n\tdouble d = abs(c1.c-c2.c);\n\tif(c1.r + c2.r <= d + EPS ) return 0.0;\n\tif(d<=abs(c1.r-c2.r) ){\n\t\tdouble r = min(c1.r,c2.r);\n\t\treturn PI*r*r;\n\t}\n\tdouble rc = (d*d + c1.r*c1.r -c2.r*c2.r)/(2*d);\n\tdouble th = acos(rc/c1.r);\n\tdouble ph = acos( (d-rc)/c2.r);\n\treturn c1.r*c1.r*th + c2.r*c2.r*ph - d * c1.r * sin(th) ;\n}\n\npolygon convex_cut(polygon p,line l){\n\tpolygon q;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tpoint a = p[i] , b = p[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a) != -1 ) q.push_back(a);\n\t\tif(ccw(l.s,l.t,a) * ccw(l.s,l.t,b) < 0) q.push_back(crosspointss(line(a,b),l) );\n\t}\n\treturn q;\n}\n//[s,t) 再帰 devide and conquer\ndouble inf  = 1e10;\ndouble closest_pair_dac(polygon &p,int s,int t,double &res){\n\tif(t-s<=1)return inf;\n\tif(t-s==2){\n\t\tsort(p.begin()+s,p.begin()+t,sort_y);\n\t\treturn (p[s]-p[s+1]).abs();\n\t}\n\tint mid = (s+t)/2;\n\tdouble x = p[mid].x;\n\tres = min(closest_pair_dac(p,s,mid,res),closest_pair_dac(p,mid,t,res) );\n\tauto it = p.begin();\n\tauto its = it+s,itm = it+mid,itt = it + t;\n\tinplace_merge(its,itm,itt,sort_y);\n\tvector<point> tmp;\n\tfor(int i=s;i<t;i++){\n\t\tif(abs(p[i].x-x) >= res) continue;\n\t\tfor(int j=tmp.size()-1;j>=0;j--){\n\t\t\tpoint d = p[i]-tmp[j];\n\t\t\tif(d.y >= res) break;\n\t\t\tres = min( res , d.abs() );\n\t\t}\n\t\ttmp.push_back(p[i]);\n\t}\n\treturn res;\n}\ndouble closest_pair(polygon &p){\n\tdouble res = inf;\n\tsort(p.begin(),p.end());\n\treturn  closest_pair_dac(p,0,p.size(),res);\n}\n\npolygon tangent(circle c,point p){//点から円への接戦\n\tcircle c2 = circle(p,sqrt(norm(c.c-p)-c.r*c.r ) );\n\tpolygon res = crosspointcc(c,c2);\n\tsort(res.begin(),res.end() );\n\treturn res;\n}\nvector<line> tangent(circle c1,circle c2){//円の共通接戦\n    vector<line> res;\n    if(c1.r < c2.r ) swap(c1,c2);\n    point g  = c2.c-c1.c;\n    if( equals( g.norm() ,0.0 ) ) return res;\n    point u = g/g.abs();\n    point v = orth(u);\n    for(int s=1;s>=-1;s-=2){\n\tdouble h = (c1.r + s*c2.r)/g.abs();\n\tif( equals(1-h*h,0.0) ){\n\t\tres.emplace_back( line(c1.c+u*c1.r,c1.c+(u+v)*c1.r) );\n\t}else if(1-h*h>0) {\n\t\tpoint uu = u*h,vv = v*sqrt(1-h*h) ;\n\t\tres.emplace_back( line(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s) );\n\t\tres.emplace_back( line(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s) );\n\t}\n    }\n\treturn res;\n}\npolygon tangent_point(circle c1,circle c2){//円の共通接戦における接点集合\n    vector<line> ls = tangent(c1,c2);\n    polygon res ;\n    for(auto l:ls){\n\tpolygon tmp = crosspointCL(c1,l);\n\tif(tmp.size()!=0)res.emplace_back(tmp[0]);\n    }\n    sort(res.begin(),res.end());\n    return res;\n}\n\ndouble calcu(circle c,point a,point b){\n\tpoint va = c.c-a,vb = c.c - b;\n\tdouble f = cross(va,vb);\n\tdouble res = 0.0;\n\tif(equals(f,0.0) )return res;\n\tif(max(abs(va),abs(vb) ) < c.r + EPS) return f;\n\tpoint d( dot(va,vb),cross(va,vb) );\n\tif( distancesp(line(a,b),c.c) > c.r -EPS ) return c.r*c.r*atan2(d.y,d.x);\n\tauto u = crosspointCS(c,line(a,b) );\n\tif(u.empty() ) return res;\n\tif(u.size() > 1u && dot(u[1]-u[0],a-u[0] ) > 0 ) swap(u[0],u[1]);\n\tu.emplace(u.begin(),a);\n\tu.emplace_back(b);\n\tfor(int i=1;i<u.size();i++)res+=calcu(c,u[i-1],u[i]);\n\treturn res;\n}\ndouble area(polygon ps,circle c){\n\tif(ps.size() < 3u) return 0.0;\n\tdouble res = 0.0;\n\tfor(int i=0;i<ps.size();i++) res += calcu(c,ps[i],ps[(i+1)%ps.size()] );\n\treturn res/2;\n}\n\n\n\ntypedef pair<double,double> mp;\ntypedef pair<int,int> mi;\ntypedef pair<double,mi> mmp;\nint main(){\n    \twhile(1){\n\t    int n;\n\t    cin>>n;\n\t    if(n==0)break;\n\t    vector<circle> c(n);\n\t    for(int i=0;i<n;i++)c[i].input();\n\t    polygon ps[2];\n\t    ps[0].push_back( c[0].c );\n\t    ps[1].push_back( c[0].c );\n\t    for(int i=1;i<n;i++){\n\t\tpolygon tmp = crosspointcc(c[i-1],c[i]);\n\t\tfor(int j=0;j<2;j++) ps[j].push_back( tmp[j] );\n\t    }\n\t    ps[0].push_back( c[n-1].c );\n\t    ps[1].push_back( c[n-1].c );\n\t    vector<vector<vector<mmp> > > g(n+1,vector<vector<mmp> >(2) );\n\t    for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t //   g[i][j].push_back( mmp( ( ps[j][i]-ps[0][i+1] ).abs()  ,mi(i+1,0)  ) ); \n\t\t   // g[i][j].push_back( mmp( ( ps[j][i]-ps[1][i+1] ).abs()  ,mi(i+1,1)  ) ); \n\t\t    for(int k=i+1;k<=n;k++){\n\t\t\tfor(int l=0;l<2;l++){\n\t\t\t    line l1 = line( ps[j][i] , ps[l][k] );\n\t\t\t    bool f = true;\n\t\t\t    for(int m=i+1;m<k;m++){\n\t\t\t\tline l2 = line( ps[0][m] , ps[1][m] );\n\t\t\t\tif( !intersect(l1,l2) ){\n\t\t\t\t    f = false;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if(f) g[i][j].push_back(mmp( ( ps[j][i]-ps[l][k]  ).abs() , mi( k,l )  )  );\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t/*    for(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t    cout<<i<<' '<<j<<\": \";\n\t\t    for(int k=0;k<g[i][j].size();k++){\n\t\t\tcout<<g[i][j][k].first<<' '<<g[i][j][k].second.first<<' '<<g[i][j][k].second.second<<' ';\n\t\t    }\n\t\t    cout<<endl;\n\t\t}\n\t    }*/\n\t    priority_queue<mmp,vector<mmp>,greater<mmp> > q;\n\t    q.push( mmp(0,mi(0,0) ) );\n\t    q.push( mmp(0,mi(0,1) ) );\n\t    vector<vector<bool> > used(n+1,vector<bool>(2,false) );\n\t    while(!q.empty() ){\n\t\tmmp now = q.top();\n\t\tq.pop();\n\t\tint x = now.second.first;\n\t\tint y = now.second.second;\n\t\tdouble cost = now.first;\n\t\t//cout<<x<<' '<<y<<\": \"<<endl;\n\t\tif(x==n){\n\t\t    printf(\"%0.10lf\\n\",cost);\n\t\t    break;\n\t\t}\n\t\tif( used[x][y] ) continue;\n\t\tused[x][y] = true;\n\t\t//cout<<g[x][y].size()<<endl;\n\t\tfor(int i=0;i<g[x][y].size();i++){\n\t\t    int nx = g[x][y][i].second.first;\n\t\t    int ny = g[x][y][i].second.second;\n\t\t    double nc = cost +  g[x][y][i].first;\n\t\t//    cout<<nx<<' '<<ny<<' '<<cost<<endl;\n\t\t    if( used[nx][ny] ) continue;\n\t\t    q.push( mmp(nc, mi(nx,ny)  ) );\n\t\t}\n\t    }\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n \n// double\nstruct P{\n    P(){}\n    P(double _r, double _i):r(_r), i(_i){}\n    void real(const double& v){r = v;}\n    void imag(const double& v){i = v;}\n    double r, i;\n};\n \ndouble real(const P& p){return p.r;}\ndouble imag(const P& p){return p.i;}\ndouble norm(const P& p){double r = real(p), i = imag(p); return r * r + i * i;}\ndouble dist(const P& p){return std::sqrt(norm(p));}\n \nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n \ndouble cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n \ndouble dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n \nbool areIntersectedLines(const P& p1, const P& p2, const P& q1, const P& q2){\n    if(cross(p1-p2, q1-p2) == 0 && dot(p1-p2, q1-p2) > 0 &&\n       0 <= norm(q1-p2) && norm(q1-p2) <= norm(p1-p2)){\n        return true;\n    }\n    if(cross(p1-p2, q2-p2) == 0 && dot(p1-p2, q2-p2) > 0 &&\n       0 <= norm(q2-p2) && norm(q2-p2) <= norm(p1-p2)){\n        return true;\n    }\n    if(cross(q1-q2, p1-q2) == 0 && dot(q1-q2, p1-q2) > 0 &&\n       0 <= norm(p1-q2) && norm(p1-q2) <= norm(q1-q2)){\n        return true;\n    }\n    if(cross(q1-q2, p2-q2) == 0 && dot(q1-q2, p2-q2) > 0 &&\n       0 <= norm(p2-q2) && norm(p2-q2) <= norm(q1-q2)){\n        return true;\n    }\n \n    return (cross(p1-p2, q1-p2) * cross(p1-p2, q2-p2) < 0) &&\n        (cross(q1-q2, p1-q2) * cross(q1-q2, p2-q2) < 0);\n}\n \nint N;\nP ps[100], is[101][2];\ndouble rs[100], dp[101][2];\n \ndouble rec(int index, int which){\n    if(index == N){return 0.0;}\n    if(dp[index][which] > 0.0){return dp[index][which];}\n     \n    double res = 1e20;\n    for(int i=index+1;i<=N;i++){\n        for(int w=0;w<2;w++){\n            int j;\n            for(j=index+1;j<i;j++){\n                if(!areIntersectedLines(is[index][which], is[i][w], is[j][0], is[j][1])){\n                    break;\n                }\n            }\n \n            if(j == i){res = std::min(res, rec(i, w) + dist(is[index][which] - is[i][w]));}\n        }\n    }\n \n    return dp[index][which] = res;\n}\n \nint main(){\n    while(scanf(\"%d\", &N), N){\n        for(int i=0;i<=N;i++){\n            for(int j=0;j<2;j++){\n                dp[i][j] = -1.0;\n            }\n        }\n     \n        for(int i=0;i<N;i++){\n            double x, y;\n            scanf(\"%lf %lf %lf\", &x, &y, rs+i);\n \n            ps[i].real(x);\n            ps[i].imag(y);\n        }\n \n        is[0][0] = ps[0];\n        is[N][0] = ps[N-1];\n        is[N][1] = ps[N-1];\n        for(int i=1;i<N;i++){\n            P u = ps[i] - ps[i-1], v{-imag(u), real(u)};\n            double d = dist(u);\n            double x = 0.5 / d * (1.*d*d + rs[i-1]*rs[i-1] - rs[i]*rs[i]),\n                y = std::sqrt(rs[i-1]*rs[i-1] - x*x);\n         \n            u = {real(u) / d * x, imag(u) / d * x};\n            v = {real(v) / d * y, imag(v) / d * y};\n         \n            P w = u + v;\n            is[i][0] = ps[i-1] + w;\n \n            w = u - v;\n            is[i][1] = ps[i-1] + w;\n        }\n \n        printf(\"%.6f\\n\", rec(0, 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// AOJ0214\n// a contains b?\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-10;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.pb(q + v);\n    if (h > feps)\n        res.pb(q - v); // 2点\n    return res;\n}\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.pb(p + v);\n    if (t > feps)\n        res.pb(p - v); // 2点\n    return res;\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_LC(const Line& line, const Circle& c)\n{\n    return ip_CL(c, line);\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.pb(ip[i]);\n    return res;\n}\n// AOJ1183(必ず交点が2点あるテストケース)\nvector<Point> ip_SC(const Seg& seg, const Circle& c)\n{\n    return ip_CS(c, seg);\n}\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\n\n\nint n;\nCircle c[111];\nPoint ip[111][2];\nbool reachable(int i, int a, int j, int b)\n{\n    Seg seg(ip[i][a], ip[j][b]);\n    Point vec = seg.second - seg.first;\n    vec *= 1e-2 / abs(vec);\n    // for (int w = max(0, i - 1); w < min(n, j); ++w)\n    rep(w, n)\n    {\n        vector<Point> pp = ip_CS(c[w], seg);\n        foreach (p, pp)\n        {\n            bool ok = false;\n            rep(t, n)\n            {\n                if (contain_CP(c[t], *p + vec))\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n    }\n    return true;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        rep(i, n)\n            cin >> c[i].p >> c[i].r;\n\n        rep(i, 2)\n        {\n            ip[0][i] = c[0].p;\n            ip[n][i] = c[n - 1].p;\n        }        \n        rep(i, n - 1)\n        {\n            vector<Point> t = ip_CC(c[i], c[i + 1]);\n            assert(t.size() == 2);\n            ip[i + 1][0] = t[0], ip[i + 1][1] = t[1];\n        }\n        \n        const double eps = 1e-9;\n        const double inf = 1e9;\n        typedef pair<double, pint> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        double dp[111][2];\n        erep(i, n) rep(j, 2)\n            dp[i][j] = inf;\n        dp[0][0] = dp[0][1] = 0;\n        q.push(P(0, pint(0, 0)));\n        double res = -1;\n        while (!q.empty())\n        {\n            P t = q.top();\n            q.pop();\n\n            int u = t.second.first, w = t.second.second;\n            double d = t.first;\n            if (d > dp[u][w] + eps)\n                continue;\n            else if (u == n)\n            {\n                res = d;\n                break;\n            }\n\n            for (int v = u; v <= n; ++v) rep(s, 2)\n            {\n                double nd = d + abs(ip[v][s] - ip[u][w]);\n                if (nd + eps < dp[v][s] && reachable(u, w, v, s))\n                {\n                    dp[v][s] = nd;\n                    q.push(P(nd, pint(v, s)));\n                }\n            }\n        }\n        assert(res >= 0);\n        printf(\"%.6f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <cfloat>\n \nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define eps 10e-5\n#define INF 1e8\n \ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n \n \n#define M INT_MAX\n \n//Point\nstruct P{\n    double x, y;\n    P(){ x=M; y=M;}\n \n    P(const double &s , const double &e)\n    {x=s; y=e;}\n \n    P operator - (const P &t) const\n    { return P(x-t.x , y-t.y);}\n \n    P operator + (const P &t) const\n    { return P(x+t.x , y+t.y); }\n \n    P operator * (const double &d) const\n    { return P(x*d , y*d); }\n};\n \n \n//Line\ndouble dis(P t);\nstruct L{\n    P p1,p2;\n \n    L(){}\n \n    L(const P &s , const P &e)\n        { p1=s; p2=e;}\n    double ldis(){\n        return dis(p1-p2);\n    }\n};\n  \n//Circle\nstruct C{\n    P a;\n    double r;\n    C(){}\n    C(const P &s , const double &e)\n        { a=s; r=e;}\n};\n \n//距離を求める\ndouble dis(P t){\n    return sqrt(t.x*t.x+t.y*t.y);\n}\n \n//単位ベクトルを求める\nP unit_vector(P t){\n    double u=fabs(dis(t));\n    return P(t.x/u , t.y/u);\n}\n \n//外積を求める a×b\ndouble cross(P a,P b){\n    return (a.x*b.y-a.y*b.x);\n}\n \n//線分交差判定\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n    return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < eps) &&\n           ( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < eps);\n}\n \n//点pを中心としてr(radian)回転       p(0,0)で原点を中心として回転\nP rotate(P t , P p , double r){\n    //double r=radians(angle);\n    double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n    double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n    return P(ta , tb);\n}\n  \n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nL interpoint_cc(C a , C b){\n    double di=fabs(dis(a.a-b.a));\n    if(di > a.r+b.r || di < fabs(a.r-b.r)) return L(P(0, 0), P(0, 0));\n    double t=(a.r*a.r-b.r*b.r+di*di)/(di+di);\n    double rd=acos(t/a.r);\n  \n    P dv=unit_vector(b.a-a.a);\n    P g1=rotate(dv , P(0,0) , rd);\n    P g2=rotate(dv , P(0,0) , -rd);\n    return L(a.a+g1*a.r, a.a+g2*a.r);\n}\n \n \nclass State{\npublic:\n        C c;\n    L l;\n        double s1, s2;\n    State(){}\n    State(C cc, L ll){c = cc; l = ll;}\n};\n \n \n \nState dp[110];\n \nbool check(L l, int s, int t){\n    for(s++;s<t;s++) if(!intersect_s(l.p1, l.p2, dp[s].l.p1, dp[s].l.p2))return 0;\n    return 1;\n}\n \n \n \nint main(void){\n    int n;\n    while(cin>>n, n){\n        memset(dp, 0, sizeof(dp));\n        REP(i,110) dp[i].s1 = dp[i].s2 = INF;\n        int x, y;\n        double r;\n        cin >> x >> y >> r;\n        State s = State(C(P(x,y),r), L(P(x,y),P(x,y)));\n        dp[0] = s;\n        dp[0].s1 = dp[0].s2 = 0;\n        for(int i = 1; i < n; i++){\n            cin >>x>>y>>r;\n            C c = C(P(x,y),r);\n            dp[i] = State(c, interpoint_cc(c, dp[i-1].c));\n            REP(k,i){\n                L l1 = L(dp[k].l.p1, dp[i].l.p1);\n                if(dp[k].s1 != INF && check(l1, k, i)){\n                    dp[i].s1 = min(dp[i].s1, dp[k].s1 + l1.ldis());\n                }\n                L l2 = L(dp[k].l.p2, dp[i].l.p1);\n                if(dp[k].s2 != INF && check(l2, k, i)){\n                    dp[i].s1 = min(dp[i].s1, dp[k].s2 + l2.ldis());\n                }\n                l1 = L(dp[k].l.p1, dp[i].l.p2);\n                if(dp[k].s1 != INF && check(l1, k, i)){\n                    dp[i].s2 = min(dp[i].s2, dp[k].s1 + l1.ldis());\n                }\n                l2 = L(dp[k].l.p2, dp[i].l.p2);\n                if(dp[k].s2 != INF && check(l2, k, i)){\n                    dp[i].s2 = min(dp[i].s2, dp[k].s2 + l2.ldis());\n                }\n            }\n        }\n\t\t\t\tREP(k,n){\n            L l1 = L(dp[k].l.p1, dp[n-1].c.a);\n            if(dp[k].s1 != INF && check(l1, k, n)){\n                dp[n].s1 = min(dp[n].s1, dp[k].s1 + l1.ldis());\n            }\n            L l2 = L(dp[k].l.p2, dp[n-1].c.a);\n            if(dp[k].s2 != INF && check(l2, k, n)){\n                dp[n].s1 = min(dp[n].s1, dp[k].s2 + l2.ldis());\n            }\n        }\n        printf(\"%.9f\\n\", dp[n].s1);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\n// ヘロンの公式により三角形の面積を求める\ndouble Heron(double a, double b, double c) {\n    double s = (a + b + c) / 2;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// 2次元座標上の点、あるいはベクトル\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    double abs() { return sqrt(x * x + y * y); }\n    Point unit() {\n        double l = abs();\n        return Point(x / l, y / l);\n    }\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-() const { return Point(-x, -y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double a) const { return Point(a * x, a * y); }\n    double operator*(const Point& p) const { return x * p.y + y * p.x; }\n    Point operator/(double a) const { return Point(x / a, y / a); }\n    Point R90() const { return Point(y, -x); }\n    Point R180() const { return Point(-x, -y); }\n    Point R270() const { return Point(-y, x); }\n    static double Distance(const Point& a, const Point& b) {\n        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n#define EPS (1e-9)\n    static double CROSS(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    static int CCW(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (CROSS(b, c) > EPS) return +1;  // 反時計周り\n        if (CROSS(b, c) < -EPS) return -1; // 時計周り\n        if (b * c < 0) return +2;          // c--a--b 直線\n        if (b.abs() < c.abs()) return -2;  // a--b--c 直線\n        return 0;                          // a--c--b 直線\n    }\n};\nostream& operator<<(ostream& os, const Point& p) {\n    os << \"(\" << p.x << \",\" << p.y << \")\";\n    return os;\n}\n\nstruct Segment {\n    Point a, b;\n    Segment(Point a, Point b) : a(a), b(b) {}\n    bool DoesIntersect(const Segment& s) const {\n        return Point::CCW(a, b, s.a) * Point::CCW(a, b, s.b) <= 0 &&\n               Point::CCW(s.a, s.b, a) * Point::CCW(s.a, s.b, b) <= 0;\n    }\n};\n\nstruct Circle {\n    Point o;\n    double r;\n    Circle(Point o, double r) : o(o), r(r) {}\n    static pair<Point, Point> IPoints(const Circle& a, const Circle& b) {\n        double d = Point::Distance(a.o, b.o);\n        double h = Heron(a.r, b.r, d) / d * 2;\n        double l = sqrt(a.r * a.r - h * h);\n        Point e = (b.o - a.o).unit();\n        Point proj = a.o + e * l;\n        return make_pair(proj + e.R90() * h, proj + e.R270() * h);\n    }\n};\n\nint N;\n#define MN 100\ndouble X[MN + 1]; \ndouble Y[MN + 1];\ndouble R[MN + 1];\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    for (int i = 0; i < N; i++) {\n        cin >> X[i] >> Y[i] >> R[i];\n    }\n    return true;\n}\n\nvoid solve() {\n    static const double INF = 1e20;\n    static double G[MN * 2][MN * 2];\n    vector<Point> Ps;\n    Ps.push_back(Point(X[0], Y[0]));\n    for (int i = 0; i < N - 1; i++) {\n        Circle a(Point(X[i], Y[i]), R[i]),\n               b(Point(X[i + 1], Y[i + 1]), R[i + 1]);\n        pair<Point, Point> pp = Circle::IPoints(a, b);\n        Ps.push_back(pp.first);\n        Ps.push_back(pp.second);\n    }\n    Ps.push_back(Point(X[N - 1], Y[N - 1]));\n    int N1 = 2 * N;\n    for (int i = 0; i < N1; i++) for (int j = 0; j < N1; j++) {\n        if (i == j) G[i][j] = 0;\n        else G[i][j] = INF;\n    }\n    for (int i = 0; i < Ps.size(); i++) {\n        for (int j = i + 1; j < Ps.size(); j++) {\n            Point a = Ps[i];\n            Point b = Ps[j];\n            Segment s(a, b);\n            int li = (i + 1) / 2 + 1,\n                lj = (j + 1) / 2;\n            for (int k = li; k < lj; k++) {\n                if (!s.DoesIntersect(Segment(Ps[k * 2 - 1], Ps[k * 2]))) {\n                    goto FAIL;\n                }\n            }\n            G[i][j] = Point::Distance(a, b);\n            FAIL:;\n        }\n    }\n    for (int i = 0; i < N1; i++) {\n        for (int j = i + 1; j < N1; j++) {\n            G[0][j] = min(G[0][j], G[0][i] + G[i][j]);\n        }\n    }\n    printf(\"%.8lf\\n\", G[0][2 * N - 1]);\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef struct Point {\n\tdouble x, y;\n\tPoint operator - (const Point& o) const { return Point{x - o.x, y - o.y}; }\n\tPoint operator + (const Point& o) const { return Point{x + o.x, y + o.y}; }\n\tPoint operator * (double d) const { return Point{x * d, y * d}; }\n\tPoint operator / (double d) const { return Point{x / d, y / d}; }\n} Vector;\n\ndouble angle(double a, double b, double c) { return acos((b * b + c * c - a * a) / (2.0 * b * c)); }\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\nVector unitVector(Vector a) { return a / abs(a); }\nVector rotate(Vector a, double s) { return Vector{a.x * cos(s) - a.y * sin(s), a.x * sin(s) + a.y * cos(s)}; }\n\nint n;\ndouble x[100], y[100], r[100];\n\npair< Point, Point > crossPoint(int i, int j) {\n\tPoint a{x[i], y[i]}, b{x[j], y[j]};\n\tPoint x = unitVector(b - a) * r[i];\n\tdouble s = angle(r[j], abs(b - a), r[i]);\n\treturn pair< Point, Point >(a + rotate(x, s), a + rotate(x, -s));\n}\n\nint ccw(Point a, Point b, Point c) {\n\tVector ba = b - a, ca = c - a;\n\tif (cross(ba, ca) > 0) return 1;\n\tif (cross(ba, ca) < 0) return -1;\n\tif (dot(ba, ca) < 0) return 2;\n\tif (abs(ba) < abs(ca)) return -2;\n\treturn 0;\n}\n\nvoid solve() {\n\tvector< vector< Point > > vp(2, {Point{x[0], y[0]}});\n\t\n\tfor_(i,0,n-1) {\n\t\tpair< Point, Point > cp = crossPoint(i, i + 1);\n\t\tvp[0].push_back(cp.first);\n\t\tvp[1].push_back(cp.second);\n\t}\n\t\n\tvp[0].push_back(Point{x[n-1], y[n-1]});\n\tvp[1].push_back(Point{x[n-1], y[n-1]});\n\t\n\tassert((int)vp[0].size() == n+1);\n\tvector< vector< double > > dst(2, vector< double >(n+1, 1e9));\n\tdst[0][0] = 0;\n\t\n\tfor_(i,0,n) for_(bi,0,2) {\n\t\tif (dst[bi][i] < 1e9) {\n\t\t\tfor_(j,i+1,n+1) for_(bj,0,2) {\n\t\t\t\tbool flag = true;\n\t\t\t\tfor_(k,i+1,j) flag &= (ccw(vp[bi][i], vp[bj][j], vp[0][k]) * ccw(vp[bi][i], vp[bj][j], vp[1][k]) == -1);\n\t\t\t\tif (flag) dst[bj][j] = min(dst[bj][j], dst[bi][i] + abs(vp[bi][i] - vp[bj][j]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%.9f\\n\", dst[0][n]);\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor_(i,0,n) cin >> x[i] >> y[i] >> r[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\n\n\ntypedef long double R;\ntypedef complex<R> P;\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos(-1);\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (a > b) swap(a, b);\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(l.y-l.x, p-l.x)/abs(l.y-l.x));\n}\n\n//????????¨??????????°??????¢\nR distSP(const L &s, const P &p) {\n    R r = min(abs(s.x-p), abs(s.y-p));\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return r;\n    if (ccw(s.y, s.y+s2, p) == -1) return r;\n    return min(r, distLP(s, p));\n}\n\nstruct C {\n    P p;\n    R r;\n    C () {};\n    C (P p, R r) : p(p), r(r) {};\n};\n\nint crossSC(const L&l, const C &c) {\n    R mi = distSP(l, c.p);\n    if (sgn(c.r, mi) == 1) return 0;\n    if (sgn(c.r, mi) == 0) return 1;\n    int u = 0;\n    if (sgn(c.r, abs(l.x-c.p)) != -1) u++;\n    if (sgn(c.r, abs(l.y-c.p)) != -1) u++;\n    return u;\n}\n\n\n//return number of cross point\nint crossP(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) return -1;\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\nbool insLS(const L &l, const L &s) {\n    int a = ccw(l.x, l.y, s.x);\n    int b = ccw(l.x, l.y, s.y);\n    if (a == 1 && b == 1) return false;\n    if (a == -1 && b == -1) return false;\n    return true;\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s.x,s.y,t.x), b = ccw(s.x,s.y,t.y);\n    int c = ccw(t.x,t.y,s.x), d = ccw(t.x,t.y,s.y);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\n/*\nexec??§res??????????????¢?????\\???\n*/\ntemplate<int V>\nstruct Dijkstra {\n    typedef R T;\n    typedef pair<T, int> P;\n    const R INF = 1e9;\n    vector<P> g[V];\n    void add(int from, int to, T dist) {\n        g[from].push_back(P(dist, to));\n    }\n    T res[V];\n    void exec(int s) {\n        fill_n(res, V, INF);\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push(P(0, s));\n        res[s] = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            if (res[p.second] < p.first) continue;\n            for (P e: g[p.second]) {\n                if (p.first+e.first < res[e.second]) {\n                    res[e.second] = p.first+e.first;\n                    q.push(P(e.first+p.first, e.second));\n                }\n            }\n        }\n        return;\n    }\n};\n\n\n\nconst int MN = 110;\nint n;\nC c[MN];\nL l[MN];\n\nbool calc(L ll, int i, int j) {\n    for (int k = i+1; k < j; k++) {\n        if (!insSS(ll, l[k])) return false;\n    }\n    return true;\n}\nR solve() {\n    l[0] = L(c[0].p, c[0].p);\n    for (int i = 1; i < n; i++) {\n        crossP(c[i-1], c[i], l[i]);\n    }\n    l[n] = L(c[n-1].p, c[n-1].p);\n    n++;\n    Dijkstra<MN*2> djk;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (calc(L(l[i].x, l[j].x), i, j)) {\n                djk.add(i*2, j*2, abs(l[i].x-l[j].x));\n            }\n            if (calc(L(l[i].x, l[j].y), i, j)) {\n                djk.add(i*2, j*2+1, abs(l[i].x-l[j].y));\n            }\n            if (calc(L(l[i].y, l[j].x), i, j)) {\n                djk.add(i*2+1, j*2, abs(l[i].y-l[j].x));\n            }\n            if (calc(L(l[i].y, l[j].y), i, j)) {\n                djk.add(i*2+1, j*2+1, abs(l[i].y-l[j].y));\n            }\n        }\n    }\n    djk.exec(0);\n    return djk.res[2*n-1];\n}\n\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (!n) break;\n        for (int i = 0; i < n; i++) {\n            R x, y, r;\n            cin >> x >> y >> r;\n            c[i] = C(P(x, y), r);\n        }\n        printf(\"%.20Lf\\n\", (long double)solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn !(a==b);\n}\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\nPoint operator/(Point p,double c){\n\treturn Point(p.x/c,p.y/c);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\n\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble radius;\n\tCircle(){}\n\tCircle(Point c,double r):center(c),radius(r){}\n\tCircle(double x,double y,double r):center(x,y),radius(r){}\n};\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\nostream& operator<<(ostream& os,const Circle& c){\n\treturn os<<'('<<c.center.x<<','<<c.center.y<<','<<c.radius<<')';\n}\n\npair<Point,Point> InterCC(Circle c1,Circle c2){\n\tPoint p1=c1.center,p2=c2.center;\n\tdouble r1=c1.radius,r2=c2.radius;\n\tdouble d=Abs(p1-p2);\n\tdouble a=(d*d+r1*r1-r2*r2)/(2*d);\n\tdouble s=sqrt(r1*r1-a*a);\n\treturn mp(p1+a/d*(p2-p1)+s*Rot((p2-p1)/d,PI/2),\n\t\t\t  p1+a/d*(p2-p1)-s*Rot((p2-p1)/d,PI/2));\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Circle> cs(n);\n\t\trep(i,n) cin>>cs[i].center.x>>cs[i].center.y>>cs[i].radius;\n\t\t\n\t\tvector<pair<Point,Point> > ps(n-1);\n\t\trep(i,n-1)\n\t\t\tps[i]=InterCC(cs[i],cs[i+1]);\n\t\t\n\t\tvvd dp(2*n,vd(2*n,INFTY));\n\t\trep(i,n-1) repi(j,i,n-1){\n\t\t\tif(i==j){\n\t\t\t\tdp[i*2+0][i*2+0]=dp[i*2+1][i*2+1]=0;\n\t\t\t\tdp[i*2+0][i*2+1]=dp[i*2+1][i*2+0]=Abs(ps[i].first-ps[i].second);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPoint pi1=ps[i].first,pi2=ps[i].second;\n\t\t\tPoint pj1=ps[j].first,pj2=ps[j].second;\n\t\t\tbool flg11=true,flg12=true,flg21=true,flg22=true;\n\t\t\trepi(k,i+1,j){\n\t\t\t\tPoint pk1=ps[k].first,pk2=ps[k].second;\n\t\t\t\tflg11&=CCW(pi1,pk1,pj1)*CCW(pi1,pk2,pj1)<=0;\n\t\t\t\tflg12&=CCW(pi1,pk1,pj2)*CCW(pi1,pk2,pj2)<=0;\n\t\t\t\tflg21&=CCW(pi2,pk1,pj1)*CCW(pi2,pk2,pj1)<=0;\n\t\t\t\tflg22&=CCW(pi2,pk1,pj2)*CCW(pi2,pk2,pj2)<=0;\n\t\t\t}\n\t\t\tif(flg11) dp[i*2+0][j*2+0]=dp[j*2+0][i*2+0]=Abs(pi1-pj1);\n\t\t\tif(flg12) dp[i*2+0][j*2+1]=dp[j*2+1][i*2+0]=Abs(pi1-pj2);\n\t\t\tif(flg21) dp[i*2+1][j*2+0]=dp[j*2+0][i*2+1]=Abs(pi2-pj1);\n\t\t\tif(flg22) dp[i*2+1][j*2+1]=dp[j*2+1][i*2+1]=Abs(pi2-pj2);\n\t\t}\n\t\tint src=2*(n-1),dst=src+1;\n\t\tdp[src][src]=dp[dst][dst]=0;\n\t\trep(j,n-1){\n\t\t\tPoint psrc=cs[0].center,pj1=ps[j].first,pj2=ps[j].second;\n\t\t\tbool flgs1=true,flgs2=true;\n\t\t\trep(k,j){\n\t\t\t\tPoint pk1=ps[k].first,pk2=ps[k].second;\n\t\t\t\tflgs1&=CCW(psrc,pk1,pj1)*CCW(psrc,pk2,pj1)<=0;\n\t\t\t\tflgs2&=CCW(psrc,pk1,pj2)*CCW(psrc,pk2,pj2)<=0;\n\t\t\t}\n\t\t\tif(flgs1) dp[src][j*2+0]=dp[j*2+0][src]=Abs(psrc-pj1);\n\t\t\tif(flgs2) dp[src][j*2+1]=dp[j*2+1][src]=Abs(psrc-pj2);\n\t\t}\n\t\trep(i,n-1){\n\t\t\tPoint pdst=cs[n-1].center,pi1=ps[i].first,pi2=ps[i].second;\n\t\t\tbool flgd1=true,flgd2=true;\n\t\t\tperi(k,i+1,n-1){\n\t\t\t\tPoint pk1=ps[k].first,pk2=ps[k].second;\n\t\t\t\tflgd1&=CCW(pdst,pk1,pi1)*CCW(pdst,pk2,pi1)<=0;\n\t\t\t\tflgd2&=CCW(pdst,pk1,pi2)*CCW(pdst,pk2,pi2)<=0;\n\t\t\t}\n\t\t\tif(flgd1) dp[dst][i*2+0]=dp[i*2+0][dst]=Abs(pdst-pi1);\n\t\t\tif(flgd2) dp[dst][i*2+1]=dp[i*2+1][dst]=Abs(pdst-pi2);\n\t\t}\n\t\t{\n\t\t\tPoint psrc=cs[0].center,pdst=cs[n-1].center;\n\t\t\tbool flgsd=true;\n\t\t\trep(k,n-1){\n\t\t\t\tPoint pk1=ps[k].first,pk2=ps[k].second;\n\t\t\t\tflgsd&=CCW(psrc,pk1,pdst)*CCW(psrc,pk2,pdst)<=0;\n\t\t\t}\n\t\t\tif(flgsd) dp[src][dst]=dp[dst][src]=Abs(psrc-pdst);\n\t\t}\n\t\t\n\t\trep(k,2*n) rep(i,2*n) rep(j,2*n)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tprintf(\"%f\\n\",dp[src][dst]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\ntemplate<class T> T at(vector<T> v, int i) {return v[i % v.size()];}\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\n// 比較関数\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\nbool near(P a, P b) {return !sig(norm(a - b));}\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator<(L a, L b) {return !near(a.a, b.a) ? a.a < b.a : a.b < b.b;}\n}\n\n// 平方根\nD sr(D a) {return sqrt(max(a, (D)0));}\n\n// 内積\nD dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.b - a.a;}\n\n// 線分abに対する点cの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  if (near(a, c) || near(b, c)) return ON;\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\n// 射影\nP proj(P a, P b) {return a * dot(a, b) / norm(a);}\nP perp(L l, P p) {return l.a + proj(vec(l), p - l.a);}\n\n// 交差判定\nbool eqL(L a, L b) {return !sig(det(vec(a), vec(b))) && !sig(det(vec(a), b.a - a.a));}\nbool iLLs(L a, L b) {return sig(det(vec(a), vec(b)));}\nbool iLS(L a, L b) {return sig(det(vec(a), b.a - a.a)) * sig(det(vec(a), b.b - a.a)) <= 0;}\nbool iLSs(L a, L b) {return sig(det(vec(a), b.a - a.a)) * sig(det(vec(a), b.b - a.a)) < 0;}\nbool iSS(L a, L b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\n\n// 交点\nP pLL(L a, L b) {return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));}\n\n// 距離\nD dLP(L l, P p) {return abs(det(vec(l), p - l.a) / vec(l));}\nD dSP(L s, P p) {\n  if (dot(vec(s), p - s.a) < 0) return abs(p - s.a);\n  if (dot(vec(s), p - s.b) > 0) return abs(p - s.b);\n  return dLP(s, p);\n}\n\n// 円\nstruct C{P c; D r;};\n\n// 2円の位置関係\nenum RELATION{SAME = 1, CONTAIN = 2, OVER = 4, NO_CROSS = 8, ONE_CROSS = 16, ONE_CONTAIN_CROSS = 32, ONE_OVER_CROSS = 64, TWO_CROSS = 128};\nint cRel(C c1, C c2) {\n  D d = abs(c1.c - c2.c);\n  if (near(c1.c, c2.c) && !sig(c1.r, c2.r)) return SAME;\n  if (sig(d, c1.r - c2.r) < 0) return OVER;\n  if (sig(d, c2.r - c1.r) < 0) return CONTAIN;\n  if (!sig(d, c1.r - c2.r)) return ONE_OVER_CROSS;\n  if (!sig(d, c2.r - c1.r)) return ONE_CONTAIN_CROSS;\n  if (!sig(d, c1.r + c2.r)) return ONE_CROSS;\n  if (sig(d, c1.r + c2.r) > 0) return NO_CROSS;\n  return TWO_CROSS;\n}\n\n// 交差判定\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCS(C c, L s) {return sig(c.r, dSP(s, c.c)) >= 0;}\nbool iCC(C a, C b) {return sig(abs(a.c - b.c), a.r + b.r) <= 0;}\n\n// 交点\npair<P, P> pCC(C a, C b) {\n  D x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  P e = (b.c - a.c) / abs(b.c - a.c);\n  P y = e * P(0, sr(a.r * a.r - x * x));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\npair<P, P> pCL(C c, L l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\n// 角の内外判定 角abの内部にあれば正、辺上は0、外部は負\nint sAP(P a, P b, P c) {return sig(det(a, c)) - sig(det(b, c)) - sig(det(a, b));}\n\n// 線分をマージする\nvector<L> merge(vector<L> s) {\n  rep (i, s.size()) if (s[i].b < s[i].a) swap(s[i].a, s[i].b);\n  sort(s.begin(), s.end());\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j]) && !iLLs(s[i], s[j])) {\n    s[j].b = max(s[i].b, s[j].b);\n    s.erase(s.begin() + i--);\n    break;\n  }\n  return s;\n}\n\n// 最終防衛問題用秘密兵器\n// 同一の円はまとめておくこと\nvector<vector<int> > scArr(vector<L> s, vector<C> c, vector<P> &vp) {\n  s = merge(s);\n  rep (i, s.size()) {\n    vp.push_back(s[i].a);\n    vp.push_back(s[i].b);\n  }\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) vp.push_back(pLL(s[i], s[j]));\n  rep (i, c.size()) rep (j, s.size()) if (iCS(c[i], s[j])) {\n    pair<P, P> cs = pCL(c[i], s[j]);\n    if (ccw(s[j].a, s[j].b, cs.first) == ON) vp.push_back(cs.first);\n    if (ccw(s[j].a, s[j].b, cs.second) == ON) vp.push_back(cs.second);\n  }\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end(), near), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i].a, s[i].b, vp[j]) == ON) v.push_back(make_pair(norm(vp[j] - s[i].a), j));\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return g;\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    vector<C> vc(n);\n    rep (i, n) cin >> vc[i].c.X >> vc[i].c.Y >> vc[i].r;\n    vector<L> vl;\n    vector<P> vp;\n    vp.push_back(vc[0].c);\n    vp.push_back(vc[n - 1].c);\n    rep (i, n - 1) {\n      pair<P, P> pp = pCC(vc[i], vc[i + 1]);\n      vp.push_back(pp.first);\n      vp.push_back(pp.second);\n    }\n    rep (i, vp.size()) rep (j, i) vl.push_back((L){vp[i], vp[j]});\n    vp.clear();\n    vector<vector<int> > g = scArr(vl, vc, vp);\n    int si = -1, gi = -1;\n    rep (i, vp.size()) if (near(vp[i], vc[0].c)) si = i;\n    rep (i, vp.size()) if (near(vp[i], vc[n - 1].c)) gi = i;\n    priority_queue<pair<D, int>, vector<pair<D, int> >, greater<pair<D, int> > > que;\n    que.push(make_pair(0, si));\n    D dis[vp.size()];\n    rep (i, vp.size()) dis[i] = 1e100;\n    while (!que.empty()) {\n      pair<D, int> now = que.top();\n      que.pop();\n      if (sig(dis[now.second], now.first) <= 0) continue;\n      dis[now.second] = now.first;\n      if (now.second == gi) break;\n      rep (i, g[now.second].size()) {\n\tP mid = (vp[now.second] + vp[g[now.second][i]]) / (D)2;\n\trep (j, vc.size()) if (iCP(vc[j], mid)) goto next;\n\tcontinue;\n      next:;\n\tque.push(make_pair(now.first + abs(vp[now.second] - vp[g[now.second][i]]), g[now.second][i]));\n      }\n    }\n    printf(\"%.12Lf\\n\", dis[gi]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "10\n802 0 10\n814 0 4\n820 1 4\n826 1 4\n832 3 5\n838 5 5\n845 7 3\n849 10 3\n853 14 4\n857 18 3\n3\n0 0 5\n8 0 5\n8 8 5\n3\n0 0 5\n7 3 6\n16 0 5\n9\n0 3 5\n8 0 8\n19 2 8\n23 14 6\n23 21 6\n23 28 6\n19 40 8\n8 42 8\n0 39 5\n11\n0 0 5\n8 0 5\n18 8 10\n8 16 5\n0 16 5\n0 24 5\n3 32 5\n10 32 5\n17 28 8\n27 25 3\n30 18 5\n0\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <sstream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define mp(a,b) make_pair(a,b)\n#define SZ(a) ((int)(a).size())\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntypedef pair<int,int> PI;\ntypedef complex<double> pt;\n\nint n;\nint x[100],y[100],r[100];\n\n\n\nvector<pt> cross(int c1,int c2){\n  int dx=x[c1]-x[c2];\n  int dy=y[c1]-y[c2];\n  int rr=r[c1]+r[c2];\n  if(dx*dx+dy*dy> rr*rr) return vector<pt>();\n\n  /*\n     /|\\\n    /_|_\\\n    x1\n\n    r1*r1 -x1*x1 = r2*r2-(rr-x1)*(rr-x1) = r2*r2-rr*rr+2*rr*x1-x1*x1\n    r1*r1 = r2*r2-rr*rr+2*rr*x1\n    2*rr*x1=r1*r1-r2*r2+rr*rr\n    x1 = (r1*r1-r2*r2+rr*rr)/2/rr\n  */\n  int r1 = r[c1];\n  int r2 = r[c2];\n  double rrr = sqrt(dx*dx+dy*dy);\n  double x1 = (r1*r1-r2*r2+rrr*rrr)/2./rrr;\n  //cout << x1 << endl;\n  double dd=sqrt(dx*dx+dy*dy);\n  double mx = -dx/dd*x1 + x[c1];\n  double my = -dy/dd*x1 + y[c1];\n  \n  double diax = -dy;\n  double diay = dx;\n  \n  double y1 = sqrt(r1*r1-x1*x1);\n  vector<pt> ret;\n  ret.pb(pt(mx+diax/dd*y1,my+diay/dd*y1));\n  ret.pb(pt(mx-diax/dd*y1,my-diay/dd*y1));\n  \n  return ret;\n}\n\n\n#define ALL(a) (a).begin(),(a).end()\n\nbool can(pt a, pt b){\n  vector<pair<double,double> > check;\n  if(abs(b-a) < 1e-5) return true;\n  \n  rep(i,n){\n    pt c(x[i],y[i]);\n    pt ac = c-a;\n    pt v=(b-a);\n    double acv = ac.real()*v.real()+ac.imag()*v.imag();\n    double cc=norm(ac)-r[i]*r[i];\n    double aa=norm(v);\n    double bb=-2.*acv;\n    if(bb*bb-4.*aa*cc < 1e-4) continue;\n    double p1 = (-bb-sqrt(bb*bb-4.*aa*cc))/2./aa;\n    double p2 = (-bb+sqrt(bb*bb-4.*aa*cc))/2./aa;\n    if(p1 > 1 - 1e-5) continue;\n    if(p2 < 1e-5) continue;\n    //cout << \" \" << p1 << \" \" << p2 << endl;\n    p1=max(0.,p1);\n    p2=min(1.,p2);\n    check.pb(mp(p1,p2));\n  }\n  sort(ALL(check));\n  \n  double cur = 0;\n  FOR(it,check){\n    if(it->F > cur + 1e-8) return false;\n    cur = max(it->S,cur);\n  }\n  \n  return cur > 1-1e-8;\n}\n  \nvoid solve(){\n  rep(i,n) cin >> x[i] >> y[i] >> r[i];\n  vector<pt> plist;\n  plist.pb(pt(x[0],y[0]));\n  plist.pb(pt(x[n-1],y[n-1]));\n  \n  rep(i,n-1){\n    vector<pt> t=cross(i,i+1);\n    rep(j,SZ(t)){\n      plist.pb(t[j]);\n      //cout << t[j].real() << \" \" << t[j].imag() << endl;\n    }\n  }\n\n  //can(pt(0,0),pt(5,4));\n  \n  //exit(0);\n  \n  priority_queue<pair<double,int> > q;\n  \n  q.push(mp(0,0));\n  vector<bool> vis(100000);\n  while(!q.empty()){\n    double cc = -q.top().F;\n    int cv = q.top().S;\n    q.pop();\n    if(vis[cv]) continue;\n    //cout << \" \" << plist[cv].real() << \" \" << plist[cv].imag() << \" \" << cc << endl;\n    vis[cv] = 1;\n    if(cv == 1){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }\n    \n    rep(j,SZ(plist)){\n      if(!vis[j] && can(plist[cv],plist[j]))\n        q.push(mp(-cc-abs(plist[cv]-plist[j]),j));\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <complex>\n#include <cassert>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P, i) P[(i)%P.size()]\n#define Next(P, i) P[(i+1)%P.size()]\n#define Prev(P, i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n\tbool operator<(const P a, const P b) {\n\t\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n\t}\n}\n\ndouble cross(const P a, const P b) {\n\treturn (conj(a)*b).imag();\n}\ndouble dot(const P a, const P b) {\n\treturn (conj(a)*b).real();\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > 0) return +1;\n\tif (cross(b, c) < 0) return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nstruct L : public vector<P> {\n\tL(const P a, const P b) {\n\t\tpush_back(a), push_back(b);\n\t}\n};\n\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C {\n\tP p;\t\n\tdouble r;\n\tC(const P p, double r): p(p), r(r){}\n};\n\nP projection(L a, P p) {\n\tdouble t = dot(p-a[0], a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0] + t*(a[0]-a[1]);\n}\n\nP reflection(L a, P p) {\n\treturn p + 2.0 * (projection(a, p)-p);\n}\n\nbool isCrossLL(L a, L b) {\n\treturn abs(cross(a[1]-a[0], b[1]-b[0])) > EPS \n\t\t|| abs(cross(a[1]-a[0], b[0]-a[0])) < EPS;\n}\n\nbool isCrossLS(L a, S b) {\n\treturn cross(a[1]-a[0], b[0]-a[0])\n\t\t * cross(a[1]-a[0], b[1]-a[0]) < EPS;\n}\n\nbool isCrossLP(L l, P p) {\n\treturn abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool isCrossSS(S a, S b) {\n\treturn ccw(a[0], a[1], b[0])\n\t\t * ccw(a[0], a[1], b[1]) <= 0\n\t\t &&\n\t\t   ccw(b[0], b[1], a[0])\n\t\t * ccw(b[0], b[1], a[1]) <= 0;\n}\n\nbool isCrossSP(S a, P p) {\n\treturn abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\ndouble distPP(P a, P b) {\n\treturn abs(a-b);\n}\n\ndouble distLP(L a, P p) {\n\treturn abs(p-projection(a, p));\n}\n\ndouble distLL(L a, L b) {\n\treturn isCrossLL(a, b) ? 0 : distLP(a, b[0]);\n}\n\ndouble distLS(L a, S b) {\n\treturn isCrossLS(a, b) ? 0 : min(distLP(a, b[0]), distLP(a, b[1]));\n}\n\ndouble distSP(S a, P p) {\n\tconst P r = projection(a, p);\n\treturn isCrossSP(a, r) ? abs(p-r) : min(abs(a[0]-p), abs(a[1]-p));\n}\n\ndouble distSS(S a, S b) {\n\treturn isCrossSS(a, b) ? 0 :\n\t\tmin(\n\t\t     min(distSP(a, b[0]), distSP(a, b[1])),\n\t\t\t min(distSP(b, a[0]), distSP(b, a[1]))\n\t    );\n}\n\nbool isCrossCP(C a, P p) {\n\treturn abs(a.p-p)-a.r <= EPS;\n}\n\nbool isCrossCL(C a, L l) {\n\treturn distLP(l, a.p)-a.r < EPS;\n}\n\ndouble distSP_MAX(S a, P p) {\n\treturn max(abs(a[0]-p), abs(a[1]-p));\n}\n\nbool isCrossCS(C a, S s) {\n\treturn distSP(s, a.p)-a.r<-EPS&&distSP_MAX(s, a.p)-a.r>+EPS;\n}\n\nbool isCrossCC(C a, C b) {\n\treturn abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\nP crossP_LL(L a, L b) {\n\tdouble A = cross(a[1]-a[0], b[1]-b[0]);\n\tdouble B = cross(a[1]-a[0], a[1]-b[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return b[0];\n\tif (abs(A) < EPS) assert(false);\n\treturn b[0]+B/A*(b[1]-b[0]);\n}\n\nvector<P> crossP_CL(C c, L l) {\n\tP tmp = projection(l, c.p);\n\tP e = (l[0]-l[1])/abs(l[0]-l[1]);\n\tdouble h = abs(c.p-tmp)*abs(c.p-tmp);\n\tdouble t = sqrt(c.r*c.r-h*h);\n\tvector<P> p;\n\tif (t < EPS) {\n\t\tp.push_back(tmp);\n\t\treturn p;\n\t}\n\tp.push_back(tmp+e*t);\n\tp.push_back(tmp-e*t);\n\treturn p;\n}\n\nvector<P> crossP_CC(C a, C b) {\n\tdouble dx = (b.p).X-(a.p).X;\n\tdouble dy = (b.p).Y-(a.p).Y;\n\tdouble A = dx * dx + dy * dy;\n\tdouble B = ((a.r * a.r - b.r * b.r) / A + 1) / 2;\n\tdouble D = a.r * a.r / A - B * B;\n\tD = sqrt(D);\n\tdouble x3 = (a.p).X + dx * B;\n\tdouble y3 = (a.p).Y + dy * B;\n\tdouble x4 = -dy * D;\n\tdouble y4 = dx * D;\n\tvector<P> p;\n\tp.push_back(P(x3-x4, y3-y4));\n\tp.push_back(P(x3+x4, y3+y4));\n\treturn p;\n}\n\ntypedef pair<double, int> R;\n\nint V;\n\nstruct edge {\n\tint to;\n\tdouble cost;\n};\n\nvector<edge> GG[200];\ndouble d[200];\n\nvoid dijkstra(int s) {\n\tpriority_queue<R, vector<R>, greater<R> > que;\n\tfill(d, d+V, INF);\n\td[s] = 0;\n\tque.push(R(0.0, s));\n\n\twhile (!que.empty()) {\n\t\tR p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tfor (int i = 0; i < GG[v].size(); i++) {\n\t\t\tedge e = GG[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(R(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tGG[i].clear();\n\t\t}\n\t\tvector<C> en;\n\t\tvector<P> ten;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tC k = C(P(a, b), c);\n\t\t\ten.push_back(k);\n\t\t}\n\t\tten.push_back(en[0].p);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tvector<P> p = crossP_CC(en[i-1], en[i]);\n\t\t\tten.push_back(p[0]);\n\t\t\tten.push_back(p[1]);\n\t\t}\n\t\tten.push_back(en[n-1].p);\n\t\tfor (int i = 1; i < 2*n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint t;\n\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\tt = j+1;\n\t\t\t\t} else {\n\t\t\t\t\tt = j+2;\n\t\t\t\t}\n\t\t\t\tbool hantei = true;\n\t\t\t\tfor (int k = t; k < i; k += 2) {\n\t\t\t\t\tif (!isCrossSS(S(ten[k], ten[k+1]), S(ten[i], ten[j]))) {\n\t\t\t\t\t\thantei = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hantei) {\n\t\t\t\t\tedge e = {j, distPP(ten[i], ten[j])};\n\t\t\t\t\tGG[i].push_back(e);\n\t\t\t\t\te.to = i;\n\t\t\t\t\tGG[j].push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV = 2*n;\n\t\tdijkstra(0);\n\t\tcout << d[2*n-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef complex<double> point;\nconst double EPS = 1e-9;\nconst double INF = 1e10;\n\n\nstruct Circle{\n    point p;\n    double r;\n    Circle(double x,double y,double r) : p(x,y),r(r) {}\n};\n\nvector<point> circles_point(Circle a,Circle b){\n    double d = abs(a.p - b.p);\n    double s = (a.r+b.r+d) / 2;\n    double S = sqrt(s*(s-a.r)*(s-b.r)*(s-d));\n    double h = 2*S / d;\n    point v = (b.p-a.p) / abs(b.p-a.p);\n\n    double m = sqrt(a.r*a.r - h*h);\n\n    vector<point> ret;\n    ret.push_back(a.p + m*v + (h*v*point(0,1)));\n    ret.push_back(a.p + m*v - (h*v*point(0,1)));\n\n    return ret;\n}\n\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n\n    return (cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS) and\n           (cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) < EPS);\n}\n\ndouble solve(vector<Circle> cs){\n    vector<point> ps;\n    ps.push_back(cs.front().p);\n    for(int i=0;i<cs.size()-1;i++){\n        vector<point> pp = circles_point(cs[i],cs[i+1]);\n        for(int j=0;j<2;j++){\n            ps.push_back(pp[j]);\n        }\n    }\n    ps.push_back(cs.back().p);\n\n    vector<vector<double> > dist(2*cs.size(),vector<double>(2*cs.size(),INF));\n    for(int i=0;i<cs.size()*2;i++){\n        int cur = (i+1) / 2;\n        for(int j=i;j<cs.size()*2;j++){\n            int nex = (j+1) / 2;\n            bool ok = true;\n            for(int k=cur+1;k<nex;k++){\n                point a1 = ps[2*k-1];\n                point a2 = ps[2*k];\n                if(not is_intersected_linesegment(a1,a2,ps[i],ps[j])){\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok){\n                dist[i][j] = dist[j][i] = abs(ps[i]-ps[j]);\n            }\n        }\n    }\n    for(int k=0;k<2*cs.size();k++){\n        for(int i=0;i<2*cs.size();i++){\n            for(int j=0;j<2*cs.size();j++){\n                dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n    return dist[0][2*cs.size()-1];\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        vector<Circle> cs;\n        for(int i=0;i<n;i++){\n            double x,y,r;\n            cin >> x >> y >> r;\n            cs.push_back(Circle(x,y,r));\n        }\n        cout << solve(cs) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* Problem link\n* \n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<map>\n#include<math.h>\nusing namespace std;\nnamespace geo {\n\n\ttypedef complex<double> P;\n\ttypedef vector<P> Poly;\n\tconst double eps = 1e-8;\n\ttypedef tuple<P, P> Line;\n\ttypedef tuple<P, double> Circle;\n#define mp(a,b) make_pair(a,b)\n\n\tinline void x(P& p, double n) { p.real(n); }\n\tinline void y(P& p, double n) { p.imag(n); }\n\tinline double x(P& p) { return p.real(); }\n\tinline double y(P& p) { return p.imag(); }\n\n\tinline double dot(const P a, const  P b) {//A dot B\n\t\treturn a.real()*b.real() + a.imag()*b.imag();\n\t}\n\n\tinline double cross(const P a, const P b) {//A cross B\n\t\treturn a.real()*b.imag() - a.imag()*b.real();\n\t}\n\n\n\tinline double distance_line(P p, Line l) {\n\t\tauto c = p;\n\t\tP a, b;\n\t\ttie(a, b) = l;\n\t\treturn abs(cross(b - a, c - a)) / abs(b - a);\n\t}\n\tinline double signed_distance_line(P p, Line l) {\n\t\tauto c = p;\n\t\tP a, b;\n\t\ttie(a, b) = l;\n\t\treturn cross(b - a, c - a) / abs(b - a);\n\t}\n\tinline double distance_line_segment(P p, Line l) {\n\t\tP a, b;\n\t\ttie(a, b) = l;\n\t\tauto c = p;\n\t\tif (dot(b - a, c - a) < eps) return abs(c - a);\n\t\tif (dot(a - b, c - b) < eps) return abs(c - b);\n\t\treturn abs(cross(b - a, c - a)) / abs(b - a);\n\t}\n\n\tinline bool isintersected_L_L(Line p, Line q) {\n\t\tP a, b, c, d;\n\t\ttie(a, b) = p;\n\t\ttie(c, d) = q;\n\t\treturn (abs(cross(a - b, c -d))>eps);\n\t}\n\tinline bool isintersected_L_LS(Line l, Line ls) {\n\t\tP a, b, c, d;\n\t\ttie(a, b) = l;\n\t\ttie(c, d) = ls;\n\t\treturn !((cross(a - b, b - a) > -eps) ^ (cross(a - b, d - a) < eps));\n\t}\n\tinline bool isintersected_LS_LS(Line p, Line q) {\n\t\tP a, b, c, d;\n\t\ttie(a, b) = p;\n\t\ttie(c, d) = q;\n\t\treturn cross(b - a, c - a)*cross(b - a, d - a) < eps&&cross(d - c, a - c)*cross(d - c, b - c) < eps;\n\t}\n\t//caution: have to use isintersected_L_L before this function\n\tinline P cross_point_L_L(Line p, Line q) {\n\t\tP a, b;\n\t\ttie(a, b) = p;\n\t\tauto d1 = signed_distance_line(a, q);\n\t\tauto d2 = signed_distance_line(b, q);\n\t\tcout << d1 << \" \" << d2 << endl;\n\t\treturn (a * d2 - b * d1) / (d2 - d1);\n\t}\n\n\n\tint comp(const P &l, const P &r) {\n\t\tif (l.real() == r.real())\n\t\t\treturn(l.imag() < r.imag());\n\t\treturn(l.real() < r.real());\n\t}\n\n\tinline bool isintersected_C_C(Circle p, Circle q){\n\t\tP cp, cq;\n\t\tdouble rp, rq;\n\t\ttie(cp, rp) = p;\n\t\ttie(cq, rq) = q;\n\t\tauto d = abs(cp - cq);\n\t\treturn abs(rp - rq) < d + eps&&d < rp + rq + eps;\n\t}\n\tinline Line cross_C_C(Circle p, Circle q) {\n\t\tP cp, cq;\n\t\tdouble rp, rq;\n\t\ttie(cp, rp) = p;\n\t\ttie(cq, rq) = q;\n\t\tauto d = abs(cp - cq);\n\t\tauto rc = (d*d + rp*rp - rq*rq) / (2 * d);\n\t\tauto rs = sqrt(rp*rp - rc*rc);\n\t\tauto diff = (cq - cp) / d;\n\t\treturn Line(cp + diff*P(rc, rs), cp + diff*P(rc, -rs));\n\t}\n}\n#define rep(i,N) for(auto i=(N)*0;i<N;i++)\n#define range(it,v) for(auto &it:v)\nstruct INIT{INIT(){cin.tie(0);ios_base::sync_with_stdio(false);} }init;\nusing namespace geo;\nconst double INF = 1e9;\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcout << setprecision(10);\n\tcout << fixed;\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Circle> C(n);\n\t\trange(it, C) {\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tit = Circle(P(x, y), r);\n\t\t}\n\t\tP s, g; \n\t\t{\n\t\t\tdouble t;\n\t\t\ttie(s, t) = C[0];\n\t\t\ttie(g, t) = C[n - 1];\n\t\t}\n\t\n\t\tvector<Line> L;\n\t\tL.push_back(Line(s, s));\n\t\trep(i, n-1) \n\t\t\tL.push_back(cross_C_C(C[i], C[i + 1]));\n\t\tL.push_back(Line(g, g));\n\t\tvector<vector<double>> DP(n+1, vector<double>(2, INF));\n\t\tDP[0][0] = 0;\n\t\tDP[0][1] = 0;\n\t\tfor (int i = 1; i < n + 1;i++) {\n\t\t\tP p, q;\n\t\t\ttie(p, q) = L[i];\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tP u, v;\n\t\t\t\ttie(u, v) = L[j];\n\t\t\t\t{\n\t\t\t\t\tauto ls = Line(u, p);\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int k = j + 1; k < i; k++)flag &= (isintersected_LS_LS(ls, L[k]));\n\t\t\t\t\tif (flag)DP[i][0] = min(DP[i][0],DP[j][0]+abs(p - u));\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tauto ls = Line(v, p);\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int k = j + 1; k < i; k++)flag &= (isintersected_LS_LS(ls, L[k]));\n\t\t\t\t\tif (flag)DP[i][0] = min(DP[i][0], DP[j][1] + abs(p - v));\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tauto ls = Line(u, q);\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int k = j + 1; k < i; k++)flag &= (isintersected_LS_LS(ls, L[k]));\n\t\t\t\t\tif (flag)DP[i][1] = min(DP[i][1], DP[j][0] + abs(q - u));\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tauto ls = Line(v, q);\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int k = j + 1; k < i; k++)flag &= (isintersected_LS_LS(ls, L[k]));\n\t\t\t\t\tif (flag)DP[i][1] = min(DP[i][1], DP[j][1] + abs(q - v));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcout << min(DP[n][0], DP[n][1]) << endl;\n\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <set>\n#include <complex>\n#include <map>\n#include <iomanip>\n\n#define FOR(i, a, b) for(int i=(int)a; i < (int)b; ++i)\n#define REP(i, n) FOR(i,0,n)\n#define RFOR(i, a, b) for(int i=(int)b-1; i >= (int)a; --i)\n#define RREP(i, n) RFOR(i,0,n)\n#define IN(a,x,b) (a<=x && x < b)\ntemplate<class T> inline void chmax(T& a, const T& b){if(a<b) a = b;}\ntemplate<class T> inline void chmin(T& a, const T& b){if(a>b) a = b;}\n\nusing namespace std;\nusing ll = long long;\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n//---------------------幾何ここから----------------------\nusing Real = double;\nusing Point = std::complex<Real>;\nconst Real EPS = 1e-8, PI = std::acos(-1);\n\ninline bool eq(Real a, Real b) { return std::fabs(b - a) < EPS; }\nPoint operator*(const Point& p, const Real & d) {\n  return Point(real(p) * d, imag(p) * d);\n};\nReal distance(Point& a, Point& b) {\n  return abs(a - b);\n}\n\nstruct Line {\n  Point a, b;\n  Line() = default;\n  Line(Point a, Point b) : a(a), b(b) {}\n  Line(Real A, Real B, Real C) {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle{\n  Point p;\n  Real r;\n  Circle() = default;\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nReal cross(const Point& a, const Point& b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\nReal dot(const Point& a, const Point& b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point& a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // COUNTER_CLOCKWISE\n  if(cross(b, c) < -EPS) return -1; // CLOCKWISE\n  if(dot(b, c) < 0) return +2;      // ONLINE_BACK\n  if(norm(b) < norm(c)) return -2;  // ONLINE_FRONT\n  return 0;                         // ON_SEGMENT\n}\n\nbool intersect(const Segment& s, const Segment& t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0; // ?\n}\n\npair<Point, Point> crosspoint(const Circle& c1, const Circle& c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n//---------------------幾何ここまで----------------------\n\nReal dist[202][202];\n\nsigned main(){\n  int n;\n  while(std::cin >> n, n) {\n    V<int> x(n), y(n), r(n);\n    REP(i, n) std::cin >> x[i] >> y[i] >> r[i];\n\n    V<Point> points;\n    points.emplace_back(x[0], y[0]);\n    REP(i, n-1) {\n      Circle c1(Point(x[i], y[i]), r[i]);\n      Circle c2(Point(x[i + 1], y[i + 1]), r[i + 1]);\n      auto ps = crosspoint(c1, c2);\n      points.emplace_back(ps.first);\n      points.emplace_back(ps.second);\n    }\n    points.emplace_back(x[n-1], y[n-1]);\n\n    V<Segment> segs;\n    for(int i = 1; i < points.size(); i += 2) {\n      segs.emplace_back(points[i], points[i + 1]);\n    }\n\n    auto check = [&](int i, int j) -> bool {\n      Segment s(points[i], points[j]);\n      int l = (i + 1) / 2;\n      int r = (j - 3) / 2;\n      FOR(k, l, r + 1){\n        if(!intersect(s, segs[k])) return false;\n      }\n      return true;\n    };\n\n    REP(i, points.size()) REP(j, points.size()) dist[i][j] = 1e100;\n    REP(i, points.size()) dist[i][i] = 0;\n    REP(i, points.size()) FOR(j, i + 1, points.size()) {\n      if(check(i, j)) dist[i][j] = distance(points[i], points[j]);\n    }\n\n    REP(k, points.size()) REP(i, points.size()) REP(j, points.size()) {\n      chmin(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n\n    std::cout << std::fixed << std::setprecision(6) << dist[0][points.size() - 1] << std::endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nstruct C{P p;D r;};\nPol ps;\nvector<int> qs;\nvector<L> ls;\nD eps=1e-9;\nD cro(P a,P b){return imag(conj(a)*b);}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(c-b)-abs(a-c))<eps) return -2;\n\treturn 2;\n}\nbool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nPol intCC(C a,C b){\n\tD d=abs(a.p-b.p);\n\tD theta=acos((a.r*a.r+d*d-b.r*b.r)/(2.0*a.r*d));\n\tPol ret;\n\tret.pb(a.p+(b.p-a.p)/d*polar(a.r,theta));\n\tret.pb(a.p+(b.p-a.p)/d*polar(a.r,-theta));\n\treturn ret;\n}\nD d[200][200],inf=1e9;\nC c[100];\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tps.clear();\n\t\tqs.clear();\n\t\tls.clear();\n\t\trep(i,N){\n\t\t\tint x,y,r;\n\t\t\tcin>>x>>y>>r;\n\t\t\tc[i].p=P(x,y),c[i].r=r;\n\t\t}\n\t\tps.pb(c[0].p);\n\t\tqs.pb(0);\n\t\trep(i,N-1){\n\t\t\tPol h=intCC(c[i],c[i+1]);\n\t\t\trep(j,2) ps.pb(h[j]);\n\t\t\trep(j,2) qs.pb(i+1);\n\t\t\tls.pb(L(h[0],h[1]));\n\t\t}\n\t\tps.pb(c[N-1].p);\n\t\tqs.pb(N-1);\n\t\tint M=ps.size();\n\t\trep(i,M) for(int j=i+1;j<M;j++){\n\t\t\td[i][j]=d[j][i]=inf;\n\t\t\tL l=L(ps[i],ps[j]);\n\t\t\tbool can=true;\n\t\t\tfor(int k=qs[i];k<qs[j];k++){\n\t\t\t\tif(!iSS(l,ls[k])) can=0;\n\t\t\t}\n\t\t\tif(can){\n\t\t\t\td[i][j]=d[j][i]=abs(ps[i]-ps[j]);\n//\t\t\t\tprintf(\"d[%d][%d]=%.5f\\n\",i,j,d[i][j]);\n\t\t\t}\n\t\t}\n\t\trep(i,M) rep(j,M) rep(k,M) d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\tprintf(\"%.12f\\n\",d[0][M-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max()/2;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c : counter-clockwise\n\tif (cross(b, c) < -eps) return -1; // a,b,c : clockwise\n\tif (dot(b, c) < 0) return 2;       // c,a,b : on a line\n\tif (norm(b) < norm(c)) return -2;  // a,b,c : on a line\n\treturn 0;                          // a,c,b : on a line\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<Circle> c;\n        for(int i=0;i<n;i++){\n            ld x,y,r;cin>>x>>y>>r;\n            c.push_back(Circle(Point(x,y),r));\n        }\n        Point st=c[0].p, gt=c[n-1].p;\n        vector<Point> ps;\n        vector<Line> ls;\n        ps.push_back(st);\n        for(int i=1;i<n;i++){\n            vector<Point> res=is_cc(c[i],c[i-1]);\n            ps.push_back(res[0]);\n            ps.push_back(res[1]);\n            ls.push_back(Line(res[0],res[1]));\n        }\n        ps.push_back(gt);\n        \n        int sz=ps.size();\n        vector<vector<ld>> dis(sz,vector<ld>(sz,INF));\n        for(int i=0;i<sz;i++) dis[i][i]=0;\n\n        // st->mid\n        for(int i=1;i<sz-1;i++){\n            int idx=(i+1)/2;\n            ld d=abs(st-ps[i]);\n            bool ftmp=true;\n            for(int j=0;j<idx-1;j++){\n                if(isis_ss(ls[j],Line(st,ps[i]))) continue;\n                ftmp=false;\n            }\n            if(ftmp) dis[0][i]=dis[i][0]=d;\n        }\n        // st->gt\n        bool f=true;\n        for(int i=0;i<(int)ls.size();i++){\n            if(isis_ss(ls[i],Line(st,gt))) continue;\n            f=false;\n        }\n        if(f) dis[0][sz-1]=dis[sz-1][0]=abs(st-gt);\n\n        // mid->mid\n        for(int i=1;i<sz-1;i++){\n            int idx=(i+1)/2;\n            for(int j=i+1;j<sz-1;j++){\n                int jdx=(j+1)/2;\n                if(idx==jdx){\n                    dis[i][j]=dis[j][i]=abs(ps[i]-ps[j]);\n                    continue;\n                }\n                ld d=abs(ps[i]-ps[j]);\n                bool ftmp=true;\n                for(int k=idx;k<jdx-1;k++){\n                    if(isis_ss(ls[k],Line(ps[i],ps[j]))) continue;\n                    ftmp=false;\n                }\n                if(ftmp) dis[i][j]=dis[j][i]=d;\n            }\n        }\n        // mid->gt\n        for(int i=1;i<sz-1;i++){\n            int idx=(i+1)/2;\n            ld d=abs(ps[i]-gt);\n            bool ftmp=true;\n            for(int j=idx+1;j<(int)ls.size();j++){\n                if(isis_ss(ls[j],Line(ps[i],gt))) continue;\n                ftmp=false;\n            }\n            if(ftmp) dis[i][sz-1]=dis[sz-1][i]=d;\n        }\n\n        for(int k=0;k<sz;k++){\n            for(int i=0;i<sz;i++){\n                for(int j=0;j<sz;j++){\n                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n                }\n            }\n        }\n        cout<<fixed<<setprecision(10)<<dis[0][sz-1]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:heroming\n * File:heroming.cpp\n * Time:2012/7/21 9:25:16\n */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\nconst double EPS = 1e-8, INFI = 1e8;\nconst int MAXN = 102;\n\nint sgn(const double &x)\n{\n        return (int)(x > EPS) - (x < -EPS);\n}\n\nstruct Point\n{\n        double x, y;\n} P[MAXN][2];\n\nint n, C[MAXN][3], N[MAXN];\ndouble dp[MAXN][2];\n\ndouble dist(const Point &A, const Point &B)\n{\n        return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));\n}\n\ndouble dis(const double &x1, const double &y1, const double &x2, const double &y2)\n{\n        return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nbool interact(const Point &A, const Point &B, const Point &C, const Point &D)\n{\n        double d1 = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y);\n        double d2 = (B.x - A.x) * (D.y - A.y) - (D.x - A.x) * (B.y - A.y);\n        double d3 = (D.x - C.x) * (A.y - C.y) - (A.x - C.x) * (D.y - C.y);\n        double d4 = (D.x - C.x) * (B.y - C.y) - (B.x - C.x) * (D.y - C.y);\n        return (sgn(d1 * d2) <= 0 && sgn(d3 * d4) <= 0);\n}\n\n//bool check(const Point &A, int k)\n//{\n        //return sgn(dis(A.x, A.y, C[k][0], C[k][1]) - C[k][2]) == 0;\n//}\n\nint main()\n{\n        while (scanf(\"%d\", &n) != EOF && n)\n        {\n                for (int i = 0; i < n; ++ i)\n                        scanf(\"%d%d%d\", &C[i][0], &C[i][1], &C[i][2]);\n                \n                P[0][0].x = C[0][0];\n                P[0][1].y = C[0][1];\n                P[n][0].x = C[n - 1][0];\n                P[n][0].y = C[n - 1][1];\n                for (int i = 1; i < n; ++ i)\n                {\n                        double a = C[i - 1][2] + 0.0;\n                        double c = C[i][2] + 0.0;\n                        double b = dis(C[i - 1][0], C[i - 1][1], C[i][0], C[i][1]);\n                        double cos_x = (a * a + b * b - c * c) / (2 * a * b);\n                        double sin_x = sqrt(1 - cos_x * cos_x);\n                        double d = a * cos_x;\n                        double h = a * sin_x;\n                        double k1 = d / b;\n                        double k2 = h / b;\n                        P[i][0].x = C[i - 1][0] + k1 * (C[i][0] - C[i - 1][0]) + k2 * (C[i - 1][1] - C[i][1]);\n                        P[i][0].y = C[i - 1][1] + k1 * (C[i][1] - C[i - 1][1]) + k2 * (C[i][0] - C[i - 1][0]);\n                        P[i][1].x = C[i - 1][0] + k1 * (C[i][0] - C[i - 1][0]) + k2 * (C[i][1] - C[i - 1][1]);\n                        P[i][1].y = C[i - 1][1] + k1 * (C[i][1] - C[i - 1][1]) + k2 * (C[i - 1][0] - C[i][0]);\n                        //if (check(P[i][0], i - 1) && check(P[i][1], i))\n                                //printf(\"%d -- ok\\n\", i);\n                        //printf(\"(%.2lf, %.2lf) -- (%.2lf, %.2lf)\\n\", P[i][0].x, P[i][0].y, P[i][1].x, P[i][1].y);\n                }\n                \n                N[0] = N[n] = 1;\n                for (int i = 1; i < n; ++ i)\n                        N[i] = 2;\n                \n                for (int i = 1; i <= n; ++ i)\n                        for (int j = 0; j < N[i]; ++ j)\n                                dp[i][j] = INFI;\n                dp[0][0] = 0.0;\n                for (int i = 1; i <= n; ++ i)\n                        for (int a = 0; a < N[i]; ++ a)\n                                for (int j = 0; j < i; ++ j)\n                                        for (int b = 0; b < N[j]; ++ b)\n                                        {\n                                                bool flag = 1;\n                                                for (int k = j + 1; k < i; ++ k)\n                                                        if (! interact(P[i][a], P[j][b], P[k][0], P[k][1]))\n                                                        {\n                                                                flag = 0;\n                                                                break;\n                                                        }\n                                                if (flag)\n                                                {\n                                                        double d = dist(P[i][a], P[j][b]);\n                                                        //printf(\"(%d, %d) <-- (%d, %d)\\n\", i, a, j, b);\n                                                        if (sgn(dp[j][b] + d - dp[i][a]) < 0)\n                                                        //{\n                                                                dp[i][a] = dp[j][b] + d;\n                                                                //printf(\"(%d, %d) <----------- (%d, %d) : %.4lf\\n\", i, a, j, b, dp[i][a]);\n                                                        //}\n                                                }\n                                        }\n                //printf(\"%.6lf\\n\", dist(P[0][0], P[2][0]) + dist(P[2][0], P[3][0]) + dist(P[3][0], P[6][0]) + dist(P[6][0], P[7][0]) + dist(P[7][0], P[9][0]));\n                printf(\"%.6lf\\n\", dp[n][0]);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;};\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;};\n\n#define F first\n#define S second\ntypedef long long ll;\n\nnamespace Geometry{\n  typedef long double D;\n  typedef complex<long double> P;\n  typedef pair<P,D> C;\n    \n  const D EPS=1e-9;\n  const D PI=asin(1)*2;\n  const D INF=1e18;\n    \n  static bool comp(const P &p1,const P &p2){\n    if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n    return p1.real()<p2.real();\n  }\n    \n  static bool comp_y(const P &p1,const P &p2){\n    if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n    return p1.imag()<p2.imag();\n  }\n    \n  static bool eqls(const P &p1,const P &p2){return abs(p1-p2)<EPS;}\n    \n  D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n  D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n  P project(P vec,P x){return vec*(x/vec).real();}\n    \n  P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n  P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n  P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n  bool intersectSL(P p1,P p2,P vec){\n    vec/=abs(vec); p1/=vec; p2/=vec;\n    return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);\n  }\n    \n  bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n  bool intersectSS(P p1,P p2,P p3,P p4){\n    if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n    if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n    return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n  }\n    \n  D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n  D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n  D distSP(P p1,P p2,P x){\n    if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n    if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n    return distLP(p1,p2,x);\n  }\n    \n  D distSS(P p1,P p2,P p3,P p4){\n    if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n    return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n          distSP(p3,p4,p1),distSP(p3,p4,p2)});\n  }\n    \n  P crosspointLL(P p1,P p2,P vec){\n    if(abs(cross(p2-p1,vec))<EPS){return vec;}\n    return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n  }\n    \n  P crosspointLL(P p1,P p2,P p3,P p4){\n    return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n  }\n    \n  P crosspointSS(P p1,P p2,P p3,P p4){\n    if(distSP(p1,p2,p3)<EPS){return p3;}\n    if(distSP(p1,p2,p4)<EPS){return p4;}\n    return crosspointLL(p1,p2,p3,p4);\n  }\n    \n  bool intersectShL(P p1,P p2,P vec){\n    vec/=abs(vec);\n    return intersectSL(p1,p2,vec) &&\n      crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n  }\n    \n  bool intersectShL(P p1,P p2,P p3,P p4){\n    return intersectShL(p1-p3,p2-p3,p4-p3);\n  }\n    \n  //1::in,0::on edge,-1::out\n  int contain(const vector<P> &poly,const P &p){\n    vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n    int s=A.size();\n    vector<bool> cnt(s,false);\n    for(int i=0;i<(int)poly.size();i++){\n      int k=(i+1)%poly.size();\n      if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n      for(int j=0;j<s;j++){\n        if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n      }\n    }\n    int in=0;\n    for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n    return in>s/2?1:-1;\n  }\n    \n  vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n    vector<P> ret;\n    for(int i=0;i<(int)poly.size();i++){\n      int j=(i+1)%poly.size();\n      if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n      if(intersectSL(poly[i],poly[j],p1,p2) &&\n         distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n        ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly){\n    D ans=0;\n    for(int i=2;i<(int)poly.size();i++){\n      ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n    }\n    return abs(ans)/2;\n  }\n    \n  vector<P> convexhull(vector<P> pts){\n    vector<P> ret;\n    sort(pts.begin(),pts.end(),comp);\n    auto fnc=[&](){\n      for(auto &I:pts){\n        if(!ret.empty() && I==ret.back()){continue;}\n        while(ret.size()>=2 && cross(ret.back()-ret[ret.size()-2],I-ret.back())<-EPS){\n          ret.pop_back();\n        }\n        ret.push_back(I);\n      }\n    };\n    fnc();\n    reverse(pts.begin(),pts.end());\n    fnc();\n    if(ret[0]==ret.back()){ret.pop_back();}\n    return ret;\n  }\n    \n  //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n  int intersectCC(C c1,C c2){\n    D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n    if(d<EPS && dif<EPS){return -1;}\n    if(d-r>EPS){return 4;}\n    if(d-r>-EPS){return 3;}\n    if(d-dif>EPS){return 2;}\n    if(d-dif>-EPS){return 1;}\n    return 0;\n  }\n    \n  vector<P> crosspointLC(P p1,P p2,C c){\n    vector<P> ret;\n    P pr=project(p1,p2,c.F);\n    D d=distLP(p1,p2,c.F);\n    if(d-c.S>EPS){return ret;}\n    if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n    P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n    ret.push_back(pr-vec);\n    ret.push_back(pr+vec);\n    return ret;\n  }\n    \n  vector<P> crosspointSC(P p1,P p2,C c){\n    vector<P> ret;\n    for(auto &I:crosspointLC(p1,p2,c)){\n      if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n    }\n    return ret;\n  }\n    \n  vector<P> crosspointCC(C c1,C c2){\n    vector<P> ret;\n    P vec=c2.F-c1.F;\n    D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n    D h=sqrt(c1.S*c1.S-base*base);\n    vec/=abs(vec);\n    ret.push_back(c1.F+vec*P(base,-h));\n    ret.push_back(c1.F+vec*P(base,h));\n    return ret;\n  }\n    \n  vector<P> tangentCP(C c,P p){\n    return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n  }\n    \n  vector<pair<P,P>> tangentCC(C c1,C c2){\n    vector<pair<P,P>> ret;\n    P d=c2.F-c1.F;\n    for(D i:{-1,1}){\n      D r=c1.S+c2.S*i;\n      if(intersectCC(c1,c2)>i+1){\n        for(P s:{-1i,1i}){\n          P p=r+s*sqrt(norm(d)-norm(r));\n          ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n        }\n      }\n    }\n    return ret;\n  }\n    \n  D area(const vector<P> &poly,C c){\n    D ret=0;\n    for(int i=0;i<(int)poly.size();i++){\n      P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n      if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n      else{\n        vector<P> A=crosspointSC(a,b,{0,c.S});\n        if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n        else{\n          ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n          ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n          ret+=cross(A[0],A.back());\n        }\n      }\n    }\n    return abs(ret)/2;\n  }\n    \n  //反時計回り\n  D diameter(const vector<P> &poly){\n    D ret=0;\n    ll l=0,r=0,n=poly.size();\n    if(n==2){return abs(poly[0]-poly[1]);}\n    for(int i=0;i<n;i++){\n      if(comp(poly[l],poly[i])){l=i;}\n      if(comp(poly[i],poly[r])){r=i;}\n    }\n    ll sl=r,sr=l;\n    while(sl!=l || sr!=r){\n      ret=max(ret,abs(poly[r]-poly[l]));\n      if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n      else{(++r)%=n;}\n    }\n    return ret;\n  }\n    \n  D closestpair(vector<P> pt){\n    sort(pt.begin(),pt.end(),comp);\n    D ret=INF;\n    int N=pt.size();\n    for(int i=1;i<N;i<<=1){\n      for(int j=0;i+j<N;j+=i*2){\n        int m=i+j;\n        vector<P> R;\n        D l=-INF,r=INF;\n        for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n        for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n        for(int k=0;m+k<N && k<i;k++){\n          if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n        }\n        int idx=0;\n        for(int k=j;k<m;k++){\n          if(r-pt[k].real()>ret){continue;}\n          int M=R.size();\n          while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n          for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n            ret=min(ret,abs(R[s]-pt[k]));\n          }\n        }\n        auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n        inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n      }\n    }\n    return ret;\n  }\n    \n  P centerofgravity(const vector<P> &pt){\n    P ret(0,0);\n    D wt=0;\n    for(int i=2;i<(int)pt.size();i++){\n      D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n      P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n      wt+=w2;\n      ret+=p*w2;\n    }\n    return ret/wt;\n  }\n    \n  void segment_arrangement(const vector<pair<P,P>> &L,vector<pair<int,int>> &seg,vector<P> &pt){\n    int N=L.size();\n    for(int i=0;i<N;i++){\n      pt.push_back(L[i].F);\n      pt.push_back(L[i].S);\n      for(int j=i+1;j<N;j++){\n        if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n          pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n        }\n      }\n    }\n    auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n    sort(pt.begin(),pt.end(),le);\n    pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n    for(auto &I:L){\n      vector<pair<D,int>> on;\n      for(int j=0;j<(int)pt.size();j++){\n        if(distSP(I.F,I.S,pt[j])<EPS){\n          on.emplace_back(abs(pt[j]-I.F),j);\n        }\n      }\n      sort(on.begin(),on.end());\n      for(int j=1;j<(int)on.size();j++){\n        seg.emplace_back(on[j-1].S,on[j].S);\n      }\n    }\n    sort(seg.begin(),seg.end());\n    seg.erase(unique(seg.begin(),seg.end()),seg.end());\n  }\n    \n  vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n    vector<pair<int,int>> seg;\n    vector<P> pt;\n    segment_arrangement(L,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n      edge[I.F].push_back(I.S);\n      edge[I.S].push_back(I.F);\n    }\n    vector<P> ret;\n    function<void(int,int)> dfs=[&](int v,int pre){\n      if(pre!=-1 && v==0){return;}\n      ret.push_back(pt[v]);\n      vector<pair<D,int>> nx;\n      for(auto &u:edge[v]){\n        D a=arg((pt[u]-pt[v])/(pre==-1 || eqls(pt[v],pt[pre])?P(1):pt[v]-pt[pre]));\n        if(abs(a+PI)<EPS){a=PI;}\n        nx.emplace_back(a,u);\n      }\n      sort(nx.begin(),nx.end());\n      dfs(nx[0].S,v);\n    };\ndfs(0,-1);\n        return ret;\n    }\n    \n    istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n    istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n};\n\nusing namespace Geometry;\n\nll n;\nvector<C> A;\n\nbool connect(P a,P b,int l,int r){\n  for(int i=l;i<r;i++){\n    auto pt=crosspointCC(A[i],A[i+1]);\n    if(!intersectSS(a,b,pt[0],pt[1])){return false;}\n  }\n  return true;\n}\n\n\n//BEGIN CUT HERE\ntemplate <typename T>\nvector<T> dijkstra(int s,vector<vector<pair<int, T> > > & G){  \n  const T INF = numeric_limits<T>::max();    \n  using P = pair<T, int>;\n  int n=G.size();\n  vector<T> d(n,INF);\n  vector<int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n        d[u]=d[v]+c;\n        b[u]=v;\n        q.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n//END CUT HERE\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  while(cin>>n,n){\n  A.resize(n);\n  for(auto &I:A){cin>>I;}\n  vector<vector<pair<int,D>>> G(2*n+2);\n  int s=2*n;\n  int g=s+1;\n  int m=n;\n  vector<P> pts={A[0].F,A.back().F};\n  for(int i=0;i+1<n;i++){\n    auto pt=crosspointCC(A[i],A[i+1]);\n    for(int j=i;j+1<n;j++){\n      auto pt2=crosspointCC(A[j],A[j+1]);\n      for(int k=0;k<2;k++){\n        for(int l=0;l<2;l++){\n          if(connect(pt[k],pt2[l],i+1,j) || i==j){\n            G[k*m+i].push_back({l*m+j,abs(pt[k]-pt2[l])});\n          }\n        }\n      }\n    }\n    for(int k=0;k<2;k++){\n      if(connect(pts[0],pt[k],0,i)){\n        G[s].push_back({(int)(k*m+i),abs(pts[0]-pt[k])});\n      }\n      \n      \n      if(connect(pts[1],pt[k],i+1,n-1)){\n        G[k*m+i].push_back({g,abs(pts[1]-pt[k])});\n      }\n    }\n  }\n  if(connect(pts[0],pts[1],0,n-1)){G[s].push_back({g,abs(pts[0]-pts[1])});}\n  cout<<fixed<<setprecision(12)<<dijkstra<D>(s,G).back()<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <numeric>\n#include <cmath>\n#include <iterator>\n\nusing namespace std;\n\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i, a) for(int i=0;i<(int)(a);i++)\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n\n\ntypedef double D;\nconst D EPS = 1e-12;\nconst D INF = 1e+10;\nconst int MAX_N = 100;\ntypedef complex<D> P;\n\nnamespace std{\n  bool operator<(const P &a, const P &b){\n    return real(a) == real(b) ? imag(a) < imag(b): real(a) < real(b);\n  }\n}\n\nP unit(P p){ return p / abs(p);}\npair<P, P> norm(P p){ return make_pair(p*P(0, 1), p*P(0, -1));}\n\nD dot(P x, P y){ return real(conj(x)*y);}\nD cross(P x, P y){ return imag(conj(x)*y);}\n\nP rotate(P v, double s){\n  return P(real(v)*cos(s) - imag(v) * sin(s), real(v) * sin(s) + imag(v) * cos(s));\n}\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b, c) > EPS) return 1; // counter clockwise\n  if(cross(b, c) < -EPS) return -1; // clockwise\n  if(dot(b, c) < -EPS) return 2; // c--a--b on line\n  if(abs(b) < abs(c)) return -2; // a--b--c on line\n  return 0;\n}\n\nD arg(P a, P b, P c){ return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\nD arg(D a, D b, D c){ return acos((b*b+c*c-a*a)/(2*b*c));}\n\ntypedef pair<P, P> L;\ntypedef pair<P, D> C;\n\nbool in_cir(C c, P x){ return (abs(x-c.fs) + EPS < c.sc);}\nbool on_cir(C c, P x){ return EQ(abs(x - c.fs), c.sc); }\n\nvector<L>adj_line(C c, P p){\n  vector<L>res;\n  if(in_cir(c,p)) return res;\n  if(on_cir(c, p)){\n    pair<P, P> n = norm(c.fs-p);\n    res.pb(L(n.fs + p, p));\n    return res;\n  }\n  D x = c.sc, z = abs(c.fs-p);\n  D y = sqrt(z*z-x*x);\n  D s = arg(y, x, z);\n  P v = unit(p -c.fs) * c.sc;\n\n  res.pb(L(rotate(v, s) + c.fs, p));\n  res.pb(L(rotate(v, -s) + c.fs, p));\n  return res;\n}\n\nvector<P> cp_cir_to_cir(C a, C b){\n  vector<P> v;\n  D s = arg(b.sc, abs(b.fs-a.fs),a.sc);\n  P x = a.sc * unit(b.fs - a.fs);\n  v.pb(a.fs + rotate(x, s));\n  v.pb(a.fs + rotate(x, -s));\n  return v;    \n}\n\nvector<L> common_adj_line(C a, C b){\n  vector<L> res;\n  if(a.sc + EPS < b.sc) return common_adj_line(b, a);\n  if(EQ(real(a.fs), real(b.fs)) && EQ(imag(a.fs), imag(b.fs)) && EQ(a.sc, b.sc)) return res;\n  P pos = (b.fs - a.fs) * a.sc/(a.sc + b.sc) + a.fs;\n  if(!in_cir(a, pos)) res = adj_line(a, pos);\n\n  if(EQ(a.sc, b.sc)){\n    pair<P, P> n = norm(unit(b.fs - a.fs) * a.sc);\n    res.pb(L(a.fs+n.fs, b.fs + n.fs));\n    res.pb(L(a.fs + n.sc, b.fs + n.sc));\n  }else{\n    D c = abs(b.fs - a.fs);\n    pos = unit(b.fs-a.fs)*( (a.sc * c) / (a.sc - b.sc) ) + a.fs;\n    if(!in_cir(a, pos)){\n      vector<L>tmp = adj_line(a, pos);\n      rep(i, tmp.sz) res.pb(tmp[i]);\n    }\n  }\n  return res;\n}\n\nD dis(L a, P x){\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccws(const P a, const P b, const vector<P> c){\n  vector<int>x;\n  for(int i=0;i<c.size();i++){\n    x.push_back(ccw(a, b, c[i]));\n  }\n  for(int i=0;i<x.size()-1;i++){\n    if(x[i] != x[i+1]) return -10;\n  }\n  return x[0];\n}\n  \nint main(){\n  int N;\n  while(cin >> N, N){\n    vector<P>c(N);\n    vector<D>r(N);\n    for(int i=0;i<N;i++){\n      D x, y;\n      cin >> x >> y >> r[i];\n      c[i] = P(x, y);\n    }\n\n    vector<P> nodesl(N+1);\n    vector<P> nodesr(N+1);\n    nodesl[0] = c[0];\n    nodesr[0] = c[0];\n    nodesl[N] = c[N-1];\n    nodesr[N] = c[N-1];\n\n    for(int i=0;i<N-1;i++){\n      vector<P> cp = cp_cir_to_cir(C(c[i], r[i]), C(c[i+1], r[i+1]));\n      nodesr[i+1] = cp[0];\n      nodesl[i+1] = cp[1];\n    }\n\n    // for(int i=0;i<N+1;i++){\n    //   cout << nodesr[i] << endl;\n    //   cout << nodesl[i] << endl;\n    // }\n    double G[2*(MAX_N+1)][2*(MAX_N+1)];\n    for(int i=0;i<2*(MAX_N+1);i++){\n      for(int j=0;j<2*(MAX_N+1);j++){\n\tG[i][j] = INF;\n      }\n    }\n    for(int i=0;i<N;i++){\n      // nodesl[i] - nodesl[i+1]\n      G[i][i+1] = abs(nodesl[i] - nodesl[i+1]);\n      // nodesl[i] - nodesr[i+1]\n      G[i][i+2+N] = abs(nodesl[i] - nodesr[i+1]);\n      // nodesr[i] - nodesr[i+1]\n      G[i+N+1][i+2+N] = abs(nodesr[i] - nodesr[i+1]);\n      // nodesr[i] - nodesl[i+1]\n      G[i+N+1][i+1] = abs(nodesr[i] - nodesl[i+1]);\n    }\n    for(int i=0;i<N+1;i++){\n      for(int j=i+2;j<N+1;j++){\n\tvector<P> nl(nodesl.begin() + i+1, nodesl.begin() + j);\n\tvector<P> nr(nodesr.begin() + i+1, nodesr.begin() + j);\n\tint idx1[4] = {i, i, i+N+1, i+N+1};\n\tint idx2[4] = {j, j+N+1, j+N+1, j};\n\tP nis[4] = {nodesl[i], nodesl[i], nodesr[i], nodesr[i]};\n\tP njs[4] = {nodesl[j], nodesr[j], nodesr[j], nodesl[j]};\n\tfor(int k=0;k<4;k++){\n\t  P ni = nis[k];\n\t  P nj = njs[k];\n\t  int l = ccws(ni, nj, nl);\n\t  int r = ccws(ni, nj, nr);\n\t  if(l != -10 && r != -10 && l != r){\n\t    G[idx1[k]][idx2[k]] = abs(ni - nj);\n\t    // cout << idx1[k] << \" \" << idx2[k] << \" \" << abs(ni - nj) << endl;\n\t  }\n\t}\n      }\n    }\n\n    const int V = 2*(N+1);\n    // for(int i=0;i<V;i++){\n    //   for(int j=0;j<V;j++){\n    // \tif(G[i][j] == INF){\n    // \t  printf(\"%3.2lf \", -1.0);\n    // \t}else{\n    // \t  printf(\"%3.2lf \", G[i][j]);\n    // \t}\n    //   }\n    //   printf(\"\\n\");\n    // }    \n    for(int k=0;k<V;k++){\n      for(int i=0;i<V;i++){\n\tfor(int j=0;j<V;j++){\n\t  G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n\t}\n      }\n    }\n    // printf(\"\\n\");\n    // for(int i=0;i<V;i++){\n    //   for(int j=0;j<V;j++){\n    // \tif(G[i][j] == INF){\n    // \t  printf(\"%3.2lf \", -1.0);\n    // \t}else{\n    // \t  printf(\"%3.2lf \", G[i][j]);\n    // \t}\n    //   }\n    //   printf(\"\\n\");\n    // }        \n    // cout << G[0][N] << \" \" <<  G[0][V-1] << \" \" <<  G[N+1][N] << \" \" <<  G[N+1][V-1] << endl;\n    printf(\"%.10lf\\n\", min({G[0][N], G[0][V-1], G[N+1][N], G[N+1][V-1]}));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nstruct coordinate {\n\tdouble x, y;\n\tdouble normal;\n\tbool normal_flag;\n\tcoordinate() {}\n\tcoordinate(double a, double b) {\n\t\tx = a; y = b;\n\t\tnormal_flag = false;\n\t}\n\tvoid set_normal(double n) {\n\t\tnormal = n;\n\t\tnormal_flag = false;\n\t}\n};\n\nstruct circle {\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coordinate a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coordinate,coordinate> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coordinate,coordinate> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coordinate(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coordinate(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\tret.first.set_normal(atan2(ret.second.y - ret.first.y, ret.second.x - ret.first.x));\n\tret.first.set_normal(atan2(ret.first.y - ret.second.y, ret.first.x - ret.second.x));\n\n\treturn ret;\n}\n\nbool cross_lseg(coordinate a_start, coordinate a_end, coordinate b_start, coordinate b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\ndouble distance(coordinate a, coordinate b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tbitset<512> reachable(0UL);\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coordinate,coordinate> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coordinate(v[0].x, v[0].y), coordinate(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coordinate,coordinate> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(make_pair(coordinate(v[v.size() - 1].x, v[v.size() - 1].y), coordinate(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoordinate start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoordinate end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\n#define EPS 1e-9\n#define INF 1e9\n\n// ?????¢, ??????, ??????\ndouble dis(Point a, Point b){ return abs(a - b); }\ndouble dot(Point a, Point b){ return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(Point a, Point b){ return a.real() * b.imag() - a.imag() * b.real(); }\n\n\n// ccw\n//  1: c?????????ab??????????????´????????? (a?????????, b????\\\\??¨????????¨???)\n// -1: c?????????ab??????????????´?????????\n//  2: c?????????ab?????¶????????????a?????????????????????\n// -2: c?????????ab?????¶????????????b???????\\\\?????????\n//  0: c?????????ab????????????\nint ccw(Point a, Point b, Point c){\n  if(cross(b - a, c - a) > EPS) return 1;\n  if(cross(b - a, c - a) < -EPS) return -1;\n  if(dot(b - a, c - a) < -EPS) return 2;\n  if(dis(a, b) + EPS < dis(c, a)) return -2;\n  return 0;\n}\nint ccw(Line a, Point b){ return ccw(a.first, a.second, b); }\n\n// ??????????????????(??????2???????????¶??´????????????)\nLine CircleCross(Point a, double ra, Point b, double rb){\n  double d = dis(a, b);\n  double rc = (d * d + ra * ra - rb * rb) / (2 * d);\n  double rs = sqrt(ra * ra - rc * rc);\n  Point diff = (b - a) / d;\n  return make_pair(a + diff * Point(rc, rs), a + diff * Point(rc, -rs));\n}\n\n\nvector<double> dijk(int s, vector<vector<pair<double, int> > > adj){\n  int n = adj.size();\n  vector<double> result(n, INF);\n  priority_queue<pair<double, int> > wait;  \n  result[s] = 0;\n  wait.push(make_pair(0, s));\n\n  while(!wait.empty()){\n    double nowcost = -wait.top().first;\n    int nowpoint = wait.top().second;\n    wait.pop();\n    if(result[nowpoint] < nowcost){ continue; }\n    \n    for(int i = 0; i < (int)adj[nowpoint].size(); i++){\n      double nextcost = adj[nowpoint][i].first + nowcost;\n      int nextpoint = adj[nowpoint][i].second;\n      if(result[nextpoint] > nextcost){\n        wait.push(make_pair(-nextcost, nextpoint));\n        result[nextpoint] = nextcost;\n      }\n    }\n  }\n\n  return result;\n}\n\n\nint main(void){\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0){ break; }\n\n    // ??????????????¨?????????????????????\n    double x, y, r;\n    vector<pair<Point, double> > circles;\n    for(int i = 0; i < n; i++){\n      cin >> x >> y >> r;\n      circles.push_back(make_pair(Point(x, y), r));\n    }\n\n    // ????????????(+?§??????¨??????)?????????\n    // second??????????????????????????????????????????????¨????\n    vector<pair<Point, int> > vertices;\n    vertices.push_back(make_pair(circles[0].first, 0));\n    for(int i = 0; i < n - 1; i++){\n      Line tmp = CircleCross(circles[i].first, circles[i].second, circles[i + 1].first, circles[i + 1].second);\n      vertices.push_back(make_pair(tmp.first, 1));\n      vertices.push_back(make_pair(tmp.second, -1));\n    }\n    vertices.push_back(make_pair(circles[n - 1].first, 0));\n\n    // ??????i??¨j????????????????????????\n    // ??????k(i+1???j-1)????????????????????????????????????????????°OK\n    vector<vector<pair<double, int> > > adj(vertices.size());\n    for(int i = 0; i < (int)vertices.size(); i++){\n      for(int j = i + 1; j < (int)vertices.size(); j++){\n        bool flag = true;\n        for(int k = i + 1; k < j; k++){\n          int tmp = ccw(vertices[i].first, vertices[j].first, vertices[k].first);\n          if(tmp != vertices[k].second){ flag = false; }\n        }\n        if(flag){ adj[i].push_back(make_pair(dis(vertices[i].first, vertices[j].first), j)); }\n      }\n    }\n\n    // ??????????????????????????????????????????\n    vector<double> result = dijk(0, adj);\n    printf(\"%.10f\\n\", result[result.size() - 1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n#define FOR(i,k,n) for(int i=(k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n\nconst double INF = 1e8;\nconst double EPS = 1e-8;\n\n#include <complex>\n#define CURR(P, i) (P[(i) % P.size()])\n#define NEXT(P, i) (P[((i) + 1) % P.size()])\n\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n    Line() {;}\n    Line(Point a, Point b) { push_back(a); push_back(b); }\n};\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {;}\n    Circle(Point p, double r) : p(p), r(r) {;}\n};\ninline double cross(const Point &a, const Point &b) {\n      return imag(conj(a) * b);\n}\ninline double dot(const Point &a, const Point &b) {\n      return real(conj(a) * b);\n}\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\ninline int ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > 0) { return 1; }\n    if (cross(b, c) < 0) { return -1; }\n    if (dot(b, c) < 0) { return 2; }\n    if (norm(b) < norm(c)) { return -2; }\n    return 0;\n}\nbool intersectSS(const Line &s, const Line &t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nvector<Point> crosspointLC(const Line &l, const Circle &c) {\n    vector<Point> ret;\n    Point center = projection(l, c.p);\n    double d = abs(center - c.p);\n    double t = sqrt(c.r * c.r - d * d);\n    if (isnan(t)) { return ret; }\n    Point vect = (l[1] - l[0]);\n    vect /= abs(vect);\n    ret.push_back(center - vect * t);\n    if (t > EPS) {\n        ret.push_back(center + vect * t);\n    }\n    return ret;\n}\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n    vector<Point> ret;\n    double d = abs(c1.p - c2.p);\n    if (max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) { return ret; }\n    double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    Point start = c1.p + (c2.p - c1.p) / d * x;\n    Point vect = (c1.p - c2.p) * Point(0.0, 1.0);\n    return crosspointLC(Line(start, start + vect), c1);\n}\nint main(){\n    int N;\n    while(cin>>N && N){\n        Point p[100];\n        double r[100];\n        vector<Circle> circles;\n        REP(i, N){\n            double x, y;\n            cin>>x>>y>>r[i];\n            p[i] = Point(x, y);\n            circles.push_back(Circle(p[i], r[i]));\n        }\n        double d[300][300];\n        vector<Point> crosses;\n        REP(i, N-1) {\n            vector<Point> cv = crosspointCC(circles[i], circles[i+1]);\n            crosses.push_back(cv[0]);\n            crosses.push_back(cv[1]);\n        }\n        const int S = 2 * (N - 1);\n        const int G = S + 1;\n        const int SIZE = G + 1;\n        REP(i, SIZE)REP(j, SIZE) d[i][j] = INF;\n        REP(i, crosses.size())FOR(j, i+1, crosses.size()){\n            Line line(crosses[i], crosses[j]);\n            int idx1 = i / 2 + 1, idx2 = j /2;\n            bool ok = true;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[i] - crosses[j]);\n        }\n        REP(j, crosses.size()){\n            int i = S;\n            Line line(p[0], crosses[j]);\n            bool ok = true;\n            int idx1 = 0, idx2 = j / 2;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[j] - p[0]);\n        }\n        REP(i, crosses.size()){\n            int j = G;\n            Line line(crosses[i], p[N-1]);\n            bool ok = true;\n            int idx1 = i / 2 + 1, idx2 = N - 1;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[i] - p[N-1]);\n        }\n        {\n            int i = S; int j = G;\n            Line line(p[0], p[N-1]);\n            bool ok = true;\n            int idx1 = 0, idx2 = N - 1;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            if(ok) d[i][j] = d[j][i] = abs(p[N-1] - p[0]);\n        }\n        REP(k, SIZE)REP(i, SIZE)REP(j, SIZE){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        cout<<d[S][G]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n//#define DEBUG(x) \n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-9\n#define INT(a) int((a)+1e-9)\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\ntypedef pair<int,int> Pii;\ntypedef complex<double> Point;\n\ndouble dotProd(Point ap, Point bp){\n\treturn real(conj(ap)*bp);\n}\ndouble croProd(Point ap, Point bp){\n\treturn imag(conj(ap)*bp);\n}\n\nPoint rotated(Point p, double th){\n\treturn Point(cos(th), sin(th)) * p;\n};\n\nstruct Line{\n\tPoint ap;\n\tPoint bp;\n\tPoint dp;\n\tLine(){}\n\tLine(Point ap_, Point bp_){ ap=ap_; bp=bp_; dp=bp-ap;}\n};\n\nstruct Segline{\n\tPoint ap;\n\tPoint bp;\n\tPoint dp;\n\tSegline(){}\n\tSegline(Point ap_, Point bp_){ ap=ap_; bp=bp_; dp=bp-ap;}\n\tdouble length(){ return abs(dp);}\n};\n\nstruct Circle{\n\tPoint cp;\n\tdouble r;\n\tCircle(){}\n\tCircle(Point cp_, double r_){ cp=cp_; r=r_;}\n};\n\nSegline getSeglineOfCrossingPoints_Circle_Circle(Circle m, Circle n){\n\tdouble d = abs(n.cp-m.cp);\n\tdouble x = (d*d+m.r*m.r-n.r*n.r)/(2*d);\n\tdouble y = sqrt(m.r*m.r-x*x);\n\tdouble th= arg(n.cp-m.cp);\n\tPoint ap = rotated(Point(x,y),th) + m.cp;\n\tPoint bp = rotated(Point(x,-y), th) + m.cp;\n\treturn Segline(ap,bp);\n}\n\nbool isCross_Line_Segline(Line m, Segline n){\n\tdouble det=croProd(m.dp,n.dp);\n\tif(abs(det)<EPS) return false;\n\tdouble s=croProd(n.dp, m.ap-n.ap)/det;\n\tdouble t=croProd(m.dp, m.ap-n.ap)/det;\n\t//DEBUG(s);DEBUG(t);\n\tif(0-EPS<=t && t<=1+EPS) return true;\n\telse return false;\n}\n\n\n#define SUPcl 102\n#define INF 1e+9\n\nint cl;\nCircle cs[SUPcl];\nSegline segs[SUPcl];\nCircle startc;\nCircle endc;\ndouble startc_endc_w;\ndouble startc_c_w[SUPcl][2];\ndouble c_endc_w[SUPcl][2];\ndouble c_c_w[SUPcl][2][SUPcl][2];\ndouble c_d[SUPcl][2];\ndouble re;\n\nvoid calc_segs(){\n\tFOR(ci,0,cl-1){\n\t\tSegline l = getSeglineOfCrossingPoints_Circle_Circle(cs[ci],cs[ci+1]);\n\t\tsegs[ci]=l;\n\t\t//DEBUG(ci); DEBUG(l.ap); DEBUG(l.bp);\n\t}\n}\n\ndouble calc_startc_endc_w(){\n\tLine m = Line(startc.cp, endc.cp);\n\tstartc_endc_w=abs(m.dp);\n\tFOR(ci,0,cl-1){\n\t\tSegline n=segs[ci];\n\t\tif(!isCross_Line_Segline(m,n)){startc_endc_w=INF; break;}\n\t}\n\t//DEBUG(startc_endc_w);\n}\ndouble calc_startc_c_w(){\n\tFOR(cj,0,cl-1) FOR(j,0,2){\n\t\tLine m = Line(startc.cp, j ? segs[cj].bp : segs[cj].ap);\n\t\tstartc_c_w[cj][j]=abs(m.dp);\n\t\tFOR(ck,0,cj){\n\t\t\tSegline n=segs[ck];\n\t\t\tif(!isCross_Line_Segline(m,n)){startc_c_w[cj][j]=INF; break;}\n\t\t}\n\t\t//DEBUG(cj);DEBUG(j);DEBUG(startc_c_w[cj][j]);\n\t}\n}\ndouble calc_c_endc_w(){\n\tFOR(ci,0,cl-1) FOR(i,0,2){\n\t\tLine m = Line(i ? segs[ci].bp : segs[ci].ap, endc.cp);\n\t\tc_endc_w[ci][i]=abs(m.dp);\n\t\tFOR(ck,ci+1,cl-1){\n\t\t\tSegline n=segs[ck];\n\t\t\tif(!isCross_Line_Segline(m,n)){c_endc_w[ci][i]=INF; break;}\n\t\t}\n\t\t//DEBUG(ci);DEBUG(i);DEBUG(c_endc_w[ci][i]);\n\t}\n}\ndouble calc_c_c_w(){\n\tFOR(ci,0,cl-1) FOR(i,0,2) FOR(cj,ci+1,cl-1) FOR(j,0,2){\n\t\tLine m = Line(i ? segs[ci].bp : segs[ci].ap, j ? segs[cj].bp : segs[cj].ap);\n\t\tc_c_w[ci][i][cj][j]=abs(m.dp);\n\t\tFOR(ck,ci+1,cj){\n\t\t\tSegline n=segs[ck];\n\t\t\tif(!isCross_Line_Segline(m,n)){c_c_w[ci][i][cj][j]=INF; break;}\n\t\t}\n\t\t//DEBUG(ci);DEBUG(i);DEBUG(cj);DEBUG(j);DEBUG(c_c_w[ci][i][cj][j]);\n\t}\n}\n\ndouble calc_c_d(){\n\tFOR(cj,0,cl-1) FOR(j,0,2){\n\t\tc_d[cj][j]= startc_c_w[cj][j];\n\t}\n\tFOR(ci,0,cl-1) FOR(i,0,2) FOR(cj,ci+1,cl-1) FOR(j,0,2){\n\t\tc_d[cj][j]= min( c_d[cj][j], c_d[ci][i] + c_c_w[ci][i][cj][j] );\n\t}\n}\n\ndouble calc_re(){\n\tre=startc_endc_w;\n\tFOR(ci,0,cl-1) FOR(i,0,2){\n\t\tre = min(re, c_d[ci][i] + c_endc_w[ci][i]);\n\t}\n}\n\n\n\n\nint main(){\n\twhile(true){\n\t\tcin>>cl;\t\tif(!cl)break;\n\t\tFOR(ci,0,cl){\n\t\t\tint x,y,r;\n\t\t\tcin>>x>>y>>r;\n\t\t\tcs[ci]=Circle(Point(x,y),r);\n\t\t}\n\t\tcalc_segs();\n\t\tstartc=cs[0]; endc=cs[cl-1];\n\t\tcalc_startc_endc_w();\n\t\tcalc_startc_c_w();\n\t\tcalc_c_endc_w();\n\t\tcalc_c_c_w();\n\t\tcalc_c_d();\n\t\tcalc_re();\n\t\tcout<<fixed<<setprecision(7)<<re<<endl;\n\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define EPS 1e-5\n#define INF 1e9\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\treturn a+b;\n}\n\nclass P{\npublic:\n\tdouble x,y,r;\n\tP(){}\n\tP(double xx,double yy,double rr){\n\t\tx=xx;\n\t\ty=yy;\n\t\tr=rr;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),r);\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),r);\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,r);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d,r);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nclass node{\npublic:\n\tdouble cost;\n\tint v,v2;\n\tnode(){}\n\tnode(double cc,int vv,int vv2){\n\t\tcost=cc;\n\t\tv=vv;\n\t\tv2=vv2;\n\t}\n\tbool operator< (const node& n1)const{\n\t\treturn cost>n1.cost;\n\t}\n};\n\nint n;\nP p[105];\nP data[105][2];\ndouble dp[105][2];\n\ndouble dijk(){\n\tfor(int i=0;i<=n;i++){\n\t\tdp[i][0]=dp[i][1]=INF;\n\t}\n\tpriority_queue<node> que;\n\tque.push(node(0.0,0,0));\n\tdp[0][0]=0.0;\n\twhile(que.size()){\n\t\tnode q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.v2]<q.cost)continue;\n\t\tfor(int next=q.v;next<=n;next++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tif((next==n+1 || next==0) && j==1)continue;\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int k=q.v+1;k<next;k++){\n\t\t\t\t\tif((data[q.v][q.v2]-data[k][0]).det(data[next][j]-data[k][1])==0){\n\t\t\t\t\t\tif(!(on_seg(data[q.v][q.v2],data[k][0],data[next][j])|| on_seg(data[q.v][q.v2],data[k][0],data[k][1]) || on_seg(data[next][j],data[k][1],data[q.v][q.v2])|| on_seg(data[q.v][q.v2],data[k][1],data[k][0])))flag=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tP r=intersection(data[q.v][q.v2],data[next][j],data[k][0],data[k][1]);\n\t\t\t\t\t\tif(!(on_seg(data[k][0],data[k][1],r) && on_seg(data[q.v][q.v2],data[next][j],r)))flag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tP len=data[next][j]-data[q.v][q.v2];\n\t\t\t\t\tdouble len2=sqrt((len.x*len.x)+(len.y*len.y));\n\t\t\t\t\tif(dp[q.v][q.v2]+len2<dp[next][j]){\n\t\t\t\t\t\tdp[next][j]=dp[q.v][q.v2]+len2;\n\t\t\t\t\t\tque.push(node(dp[next][j],next,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n][0];\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf\",&p[i].x,&p[i].y,&p[i].r);\n\t\t}\n\t\tdata[0][0]=p[0];\n\t\tdata[n][0]=p[n-1];\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tdouble len=(p[i].x-p[i+1].x)*(p[i].x-p[i+1].x)+(p[i].y-p[i+1].y)*(p[i].y-p[i+1].y);\n\t\t\tdouble d=(p[i].r*p[i].r-p[i+1].r*p[i+1].r+len)/(2*sqrt(len));\n\t\t\tdouble c=sqrt(p[i].r*p[i].r-d*d);\n\t\t\tP pp=p[i+1]-p[i];\n\t\t\tdouble ang=atan2(pp.y,pp.x);\n\t\t\tdouble ang2=atan2(c,d);\n\t\t\tdata[i+1][0]=p[i]+P(p[i].r*cos(ang+ang2),p[i].r*sin(ang+ang2),0);\n\t\t\tdata[i+1][1]=p[i]+P(p[i].r*cos(ang-ang2),p[i].r*sin(ang-ang2),0);\n\t\t}\n\t\tprintf(\"%f\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// AOJ0214\n// a contains b?\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-10;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.pb(q + v);\n    if (h > feps)\n        res.pb(q - v); // 2点\n    return res;\n}\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.pb(p + v);\n    if (t > feps)\n        res.pb(p - v); // 2点\n    return res;\n}\nvector<Point> ip_LC(const Line& line, const Circle& c)\n{\n    return ip_CL(c, line);\n}\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.pb(ip[i]);\n    return res;\n}\nvector<Point> ip_SC(const Seg& seg, const Circle& c)\n{\n    return ip_CS(c, seg);\n}\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\n\n\nint n;\nCircle c[111];\nPoint ip[111][2];\nbool reachable(int i, int a, int j, int b)\n{\n    Seg seg(ip[i][a], ip[j][b]);\n    Point vec = seg.second - seg.first;\n    vec *= 1e-5 / abs(vec);\n    rep(w, n)\n    {\n        vector<Point> pp = ip_CS(c[w], seg);\n        foreach (p, pp)\n        {\n            bool ok = false;\n            rep(t, n)\n            {\n                if (contain_CP(c[t], *p + vec))\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n    }\n    return true;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        rep(i, n)\n            cin >> c[i].p >> c[i].r;\n\n        rep(i, 2)\n        {\n            ip[0][i] = c[0].p;\n            ip[n][i] = c[n - 1].p;\n        }        \n        rep(i, n - 1)\n        {\n            vector<Point> t = ip_CC(c[i], c[i + 1]);\n            assert(t.size() == 2);\n            ip[i + 1][0] = t[0], ip[i + 1][1] = t[1];\n        }\n        \n        // erep(i, n) rep(j, 2)\n        // {\n        //     printf(\"%d, %d: \", i, j);\n        //     cout << ip[i][j] << endl;\n        // }\n\n        const double eps = 1e-9;\n        const double inf = 1e9;\n        typedef pair<double, pint> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        double dp[111][2];\n        erep(i, n) rep(j, 2)\n            dp[i][j] = inf;\n        dp[0][0] = dp[0][1] = 0;\n        q.push(P(0, pint(0, 0)));\n        double res = -1;\n        while (!q.empty())\n        {\n            P t = q.top();\n            q.pop();\n\n            int u = t.second.first, w = t.second.second;\n            double d = t.first;\n            if (d > dp[u][w] + eps)\n                continue;\n            else if (u == n)\n            {\n                res = d;\n                break;\n            }\n\n            for (int v = u; v <= n; ++v) rep(s, 2)\n            {\n                if (reachable(u, w, v, s))\n                {\n                    double nd = d + abs(ip[v][s] - ip[u][w]);\n                    if (nd + eps < dp[v][s])\n                    {\n                        dp[v][s] = nd;\n                        q.push(P(nd, pint(v, s)));\n                    }\n                }\n            }\n        }\n        assert(res >= 0);\n        printf(\"%.6f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-6;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n\tbool input(){\n\t\tif(cin>>x>>y) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n\tbool input(){\n\t\tif(a.input() && b.input()) return true;\n\t\treturn false;\n\t}\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ \n\tPoint v1 = b-a;\n\tPoint v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; \n    if(cross(v1,v2)<-EPS) return -1; \n\tif(dot(v1,v2)<-EPS) return +2; \n\tif(v1.norm()<v2.norm()) return -2; \n    return 0; \n}\n \nbool intersect_ss(Line l,Line m){\n\treturn ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ll(Line l,Line m,Point &p){\n    Point a1,a2,b1,b2;\n    a1 = l.b-l.a; a2 = m.b-m.a;\n    b1 = m.a-l.a; b2 = l.a-m.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; \n    p = Point(m.a.x+a2.x*s1/(s1+s2),m.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ss(Line l,Line m,Point &p){\n    if(intersect_ss(l,m)==false) return 0; \n    if(crosspoint_ll(l,m,p)==true) return 1;\n\treturn -1; \n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n\tif(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n\t\treturn -1; \n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; \n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; \n    return 2; \n}\n\nint contains(Polygon g,Point p){\n\tLine l = Line(p,Point(INF,p.y));\n\tint cnt = 0, n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tPoint a = g[i]-p;\n\t\tPoint b = g[(i+1)%n]-p;\n\t\tif(ccw(g[i],g[(i+1)%n],p)==0) return 1; \n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n\t}\n\tif((cnt&1)==1) return 2; \n\treturn 0; \n}\n\nPolygon andrewScan(Polygon s){\n\tif(s.size()<=2) return s;\n\tsort(s.begin(),s.end());\n\tPolygon g;\n\tfor(int i=0;i<s.size();i++){\n\t\tfor(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\tint upper_n = g.size();\n\tfor(int i=s.size()-2;i>=0;i--){\n\t\tfor(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n\t\t\tg.pop_back();\n\t\t}\n\t\tg.push_back(s[i]);\n\t}\n\treverse(g.begin(),g.end());\n\tg.pop_back();\n\treturn g;\n}\n\nint main(){\n\tint N;\n\tCircle C[100];\n\twhile(cin>>N,N){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>C[i].c.x>>C[i].c.y>>C[i].r;\n\t\t}\n\t\tPolygon way[2];\n\t\tway[0].push_back(C[0].c); way[1].push_back(C[1].c);\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tPoint p1,p2;\n\t\t\tcrosspoint_cc(C[i],C[i+1],p1,p2);\n\t\t\tway[0].push_back(p1); way[1].push_back(p2);\n\t\t}\n\t\tway[0].push_back(C[N-1].c); way[1].push_back(C[N-1].c);\n\t\tdouble dp[101][2];\n\t\tfill_n((double*)dp,101*2,INF); dp[0][0] = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tfor(int k=i+1;k<=N;k++){\n\t\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\t\tLine l1(way[j][i],way[l][k]);\n\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\tfor(int m=i+1;m<k;m++){\n\t\t\t\t\t\t\tif(intersect_ss(l1,Line(way[0][m],way[1][m]))==false)\n\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag==true){\n\t\t\t\t\t\t\tdouble d = sqrt((way[l][k]-way[j][i]).norm());\n\t\t\t\t\t\t\tdp[k][l] = min(dp[k][l],dp[i][j]+d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\",dp[N][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<complex>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\n\n\ntypedef complex<double> Point;\ntypedef pair<int,double> pid;\n\nclass Line{\n\tpublic:\n\tdouble A,B,C;\n\tLine(double A,double B,double C):A(A),B(B),C(C){}\n\tLine(){}\n};\nclass Circle : public Point{\n\tpublic:\n\tdouble R;\n\tCircle(Point pt, double R):Point(pt),R(R){}\n\tCircle(){}\n};\ndouble Dot(Point p1, Point p2){return p1.X*p2.X + p1.Y*p2.Y;}\ndouble Cross(Point p1, Point p2){return p1.X*p2.Y - p1.Y*p2.X;}\n\nbool CircleHit(Circle a, Circle b){return abs(a-b) <= a.R + b.R;}\n\nLine CircleCommonLine(Circle a,Circle b){\n\tdouble C = pow(b.R, 2)-pow(a.R, 2)+norm(a)-norm(b);\n\treturn Line(2*(b.X-a.X), 2*(b.Y-a.Y), C);\n}\n\npair<Point,Point> Suisen(Line line, Point pt){\n\tPoint v(line.A, line.B);  v/=Point(abs(v),0);\n\tPoint toPoint;\n\t\n\tif(line.B!=0){\n\t\tPoint slide = pt-Point(0, -line.C/line.B);\n\t\ttoPoint = v*Point(Dot(v,slide),0);\n\t}else{\n\t\ttoPoint = Point(pt.X + line.C/line.A, 0);\n\t}\n\treturn pair<Point,Point>(pt-toPoint, toPoint);\n}\n\npair<Point,Point> CircleCross(Circle a, Circle b){\n\tLine commonLine = CircleCommonLine(a,b);\n\tpair<Point,Point> s = Suisen(commonLine, a);\n\t\n\tdouble d = abs(s.second);\n\tif(d!=0){\n\t\tPoint e = s.second*Point(0,1)/d;\n\t\tif(a.R<d)d=a.R;\n\t\tdouble dist = sqrt(a.R*a.R - d*d);\n\t\treturn pair<Point,Point>(s.first+e*Point(dist,0), s.first+e*Point(-dist,0));\n\t}\n\treturn pair<Point,Point>(s.first-Point(0,a.R), s.first+Point(0,a.R));\n}\n\nbool ccw(Point p1, Point p2, Point p3){\n\tdouble ret = Cross(p2-p1, p3-p1);\n\t//cout<<\"ccw \"<<(p2-p1)<<\" \"<<(p3-p1)<<\" \"<<ret<<endl;\n\treturn ret>=0;\n}\n\nconst int N = 111;\ntypedef pair<int,double> pid;\n\nint n;\nCircle cir[N];\n\nvector<pid> edge[N];\npair<Point,Point> cross[N];\n\nvoid init(){\n\trep(i,N){\n\t\tedge[i].clear();\n\t\tcir[i] = Circle();\n\t\tcross[i] = pair<Point,Point>(Point(),Point());\n\t}\n}\n\nvoid setCross(){\n\trep(i,n-1){\n\t\tcross[i] = CircleCross(cir[i],cir[i+1]);\n\t}\n\trep(i,n-1){\n\t\tif(!ccw(cir[i], cross[i].first, cross[i].second)){\n\t\t\tswap(cross[i].first, cross[i].second);\n\t\t}\n\t}\n\t/*\n\trep(i,n-1){\n\t\tcout<<\"cross \"<<cross[i].first<<\" \"<<cross[i].second<<endl;\n\t}*/\n}\n\nbool canAdd(Point pt, Point pt2, int from, int to){\n\tif(from<0)from=0;\n\treps(i,from,to){\n\t\tif(!ccw(pt, pt2, cross[i].second))return false;\n\t}\n\treps(i,from,to){\n\t\tif(ccw(pt, pt2, cross[i].first))return false;\n\t}\n\treturn true;\n}\n\nvoid addEdge(Point pt,int num, int now){\n\treps(i,now+1,n){\n\t\tif(i!=n-1){\n\t\t\tif(canAdd(pt, cross[i].second, now+1, i)){\n\t\t\t\tedge[num].push_back(pid(i*2, abs(cross[i].second-pt)));\n\t\t\t}\n\t\t\tif(canAdd(pt, cross[i].first, now+1, i)){\n\t\t\t\tedge[num].push_back(pid(i*2+1, abs(cross[i].first-pt)));\n\t\t\t}\n\t\t}else{\n\t\t\tif(canAdd(pt, cir[n-1], now+1, n-1)){\n\t\t\t\tedge[num].push_back(pid(n*2, abs(cir[n-1]-pt)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid makeEdge(){\n\t\n\treps(i,-1,n-1){\n\t\tif(i==-1){\n\t\t\taddEdge(cir[0],n*2-1,i);\n\t\t}else{\n\t\t\taddEdge(cross[i].first,i*2+1, i);\n\t\t\taddEdge(cross[i].second,i*2, i);\n\t\t}\n\t}\n}\n\nclass P{\n\tpublic:\n\tint now;\n\tdouble val;\n\tP(int now,double val):now(now),val(val){}\n\tbool operator<(const P& a)const{\n\t\treturn val>a.val;\n\t}\n};\ndouble dijkstra(){\n\t\n\t/*\n\trep(i,n*2+2){\n\t\tprintf(\"i(%d) :: \",i);\n\t\trep(j,edge[i].size()){\n\t\t\tprintf(\"(%d,%lf)\",edge[i][j].first, edge[i][j].second);\n\t\t}puts(\"\");\n\t}*/\n\t\n\tpriority_queue<P> que;\n\tque.push(P(n*2-1, 0));\n\t\n\tint visit[111]={0};\n\twhile(1){\n\t\tif(que.empty())break;\n\t\t\n\t\tP u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(u.now==n*2)return u.val;\n\t\tif(visit[u.now]==1)continue;\n\t\tvisit[u.now]=1;\n\t\t\n\t\t//printf(\"ijk %d %lf\\n\",u.now,u.val);\n\t\trep(i,edge[u.now].size()){\n\t\t\tpid e = edge[u.now][i];\n\t\t\tque.push(P(e.first, u.val+e.second));\n\t\t}\n\t}\n\treturn -1;\n}\n\ndouble solve(){\n\tinit();\n\t\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tcir[i] = Circle(Point(a,b),c);\n\t}\n\t\n\tsetCross();\n\tmakeEdge();\n\t\n\treturn dijkstra();\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%.9lf\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<complex>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\n\n\ntypedef complex<double> Point;\ntypedef pair<int,double> pid;\n\nclass Line{\n\tpublic:\n\tdouble A,B,C;\n\tLine(double A,double B,double C):A(A),B(B),C(C){}\n\tLine(){}\n};\nclass Circle : public Point{\n\tpublic:\n\tdouble R;\n\tCircle(Point pt, double R):Point(pt),R(R){}\n\tCircle(){}\n};\ndouble Dot(Point p1, Point p2){return p1.X*p2.X + p1.Y*p2.Y;}\ndouble Cross(Point p1, Point p2){return p1.X*p2.Y - p1.Y*p2.X;}\n\nbool CircleHit(Circle a, Circle b){return abs(a-b) <= a.R + b.R;}\n\nLine CircleCommonLine(Circle a,Circle b){\n\tdouble C = pow(b.R, 2)-pow(a.R, 2)+norm(a)-norm(b);\n\treturn Line(2*(b.X-a.X), 2*(b.Y-a.Y), C);\n}\n\npair<Point,Point> Suisen(Line line, Point pt){\n\tPoint v(line.A, line.B);  v/=Point(abs(v),0);\n\tPoint toPoint;\n\t\n\tif(line.B!=0){\n\t\tPoint slide = pt-Point(0, -line.C/line.B);\n\t\ttoPoint = v*Point(Dot(v,slide),0);\n\t}else{\n\t\ttoPoint = Point(pt.X + line.C/line.A, 0);\n\t}\n\treturn pair<Point,Point>(pt-toPoint, toPoint);\n}\n\npair<Point,Point> CircleCross(Circle a, Circle b){\n\tLine commonLine = CircleCommonLine(a,b);\n\tpair<Point,Point> s = Suisen(commonLine, a);\n\t\n\tdouble d = abs(s.second);\n\tPoint e = s.second*Point(0,1)/d;\n\t\n\tdouble dist = sqrt(a.R*a.R - d*d);\n\treturn pair<Point,Point>(s.first+e*Point(dist,0), s.first+e*Point(-dist,0));\n}\n\nbool ccw(Point p1, Point p2, Point p3){\n\tdouble ret = Cross(p2-p1, p3-p1);\n\t//cout<<\"ccw \"<<(p2-p1)<<\" \"<<(p3-p1)<<\" \"<<ret<<endl;\n\treturn ret>=0;\n}\n\nconst int N = 111;\ntypedef pair<int,double> pid;\n\nint n;\nCircle cir[N];\n\nvector<pid> edge[N];\npair<Point,Point> cross[N];\n\nvoid init(){\n\trep(i,N){\n\t\tedge[i].clear();\n\t\tcir[i] = Circle();\n\t\tcross[i] = pair<Point,Point>(Point(),Point());\n\t}\n}\n\nvoid setCross(){\n\trep(i,n-1){\n\t\tcross[i] = CircleCross(cir[i],cir[i+1]);\n\t}\n\trep(i,n-1){\n\t\tif(!ccw(cir[i], cross[i].first, cross[i].second)){\n\t\t\tswap(cross[i].first, cross[i].second);\n\t\t}\n\t}\n\t/*\n\trep(i,n-1){\n\t\tcout<<\"cross \"<<cross[i].first<<\" \"<<cross[i].second<<endl;\n\t}*/\n}\n\nbool canAdd(Point pt, Point pt2, int from, int to){\n\tif(from<0)from=0;\n\treps(i,from,to){\n\t\tif(!ccw(pt, pt2, cross[i].second))return false;\n\t}\n\treps(i,from,to){\n\t\tif(ccw(pt, pt2, cross[i].first))return false;\n\t}\n\treturn true;\n}\n\nvoid addEdge(Point pt,int num, int now){\n\treps(i,now+1,n){\n\t\tif(i!=n-1){\n\t\t\tif(canAdd(pt, cross[i].second, now+1, i)){\n\t\t\t\tedge[num].push_back(pid(i*2, abs(cross[i].second-pt)));\n\t\t\t}\n\t\t\tif(canAdd(pt, cross[i].first, now+1, i)){\n\t\t\t\tedge[num].push_back(pid(i*2+1, abs(cross[i].first-pt)));\n\t\t\t}\n\t\t}else{\n\t\t\tif(canAdd(pt, cir[n-1], now+1, n-1)){\n\t\t\t\tedge[num].push_back(pid(n*2, abs(cir[n-1]-pt)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid makeEdge(){\n\t\n\treps(i,-1,n-1){\n\t\tif(i==-1){\n\t\t\taddEdge(cir[0],n*2-1,i);\n\t\t}else{\n\t\t\taddEdge(cross[i].first,i*2+1, i);\n\t\t\taddEdge(cross[i].second,i*2, i);\n\t\t}\n\t}\n}\n\nclass P{\n\tpublic:\n\tint now;\n\tdouble val;\n\tP(int now,double val):now(now),val(val){}\n\tbool operator<(const P& a)const{\n\t\treturn val>a.val;\n\t}\n};\ndouble dijkstra(){\n\t\n\t/*\n\trep(i,n*2+2){\n\t\tprintf(\"i(%d) :: \",i);\n\t\trep(j,edge[i].size()){\n\t\t\tprintf(\"(%d,%lf)\",edge[i][j].first, edge[i][j].second);\n\t\t}puts(\"\");\n\t}*/\n\t\n\tpriority_queue<P> que;\n\tque.push(P(n*2-1, 0));\n\t\n\tint visit[111]={0};\n\twhile(1){\n\t\tif(que.empty())break;\n\t\t\n\t\tP u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(u.now==n*2)return u.val;\n\t\tif(visit[u.now]==1)continue;\n\t\tvisit[u.now]=1;\n\t\t\n\t\t//printf(\"ijk %d %lf\\n\",u.now,u.val);\n\t\trep(i,edge[u.now].size()){\n\t\t\tpid e = edge[u.now][i];\n\t\t\tque.push(P(e.first, u.val+e.second));\n\t\t}\n\t}\n\treturn -1;\n}\n\ndouble solve(){\n\tinit();\n\t\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tcir[i] = Circle(Point(a,b),c);\n\t}\n\t\n\tsetCross();\n\tmakeEdge();\n\t\n\treturn dijkstra();\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%.9lf\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <map>\n#include <queue>\n#include <assert.h>\n#include <cmath>\n\nusing namespace std;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n \nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(pair<P, P> pp) {\n    push_back(pp.first); push_back(pp.second);\n  }\n};\n \nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n \nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> circle_circle_intersect(C c1, C c2) {\n  if(c1.p.real() > c2.p.real()) swap(c1, c2);\n  const double d = abs(c2.p - c1.p);\n  const double alpha  = acos((c2.p.real() - c1.p.real()) / d) * ((c1.p.imag() > c2.p.imag()) ? -1.0 : 1.0);\n  const double beta   = acos((c1.r * c1.r - c2.r * c2.r + d * d) / 2.0 / d / c1.r);\n  return make_pair(c1.p + polar(c1.r, alpha - beta), c1.p + polar(c1.r, alpha + beta));\n}\n\nstruct Edge {\n  int to;\n  double cost;\n};\n \nvector<Edge> G[300];\n \nmap<P, int> mp;\nint nidx;\nvoid init_node_map(P ps, P pt, int N) {\n  mp.clear();\n  mp[ps] = 0;\n  mp[pt] = (N-1)*2+1;\n  nidx = 1;\n}\n \nint get_node(P p) {\n  if(mp.find(p) == mp.end()) {\n    mp[p] = nidx++;\n  }\n  return mp[p];\n}\n \n#define MAX (300)\ndouble dist[MAX];\n \ntypedef pair<double, int> Pdi;\n  \ndouble dijkstra(int S, int T) {\n   \n  priority_queue<Pdi, vector<Pdi>, greater<Pdi> > PQ;\n  fill(dist, dist+MAX, INF);\n  dist[S] = 0;\n  PQ.push(Pdi(0., S));\n    \n  while(!PQ.empty()) {\n    Pdi pdi = PQ.top(); PQ.pop();\n    const int u = pdi.second;\n    for(int i=0; i<(int)G[u].size(); i++) {\n      const Edge& e = G[u][i];\n      if(dist[e.to] > dist[u]+e.cost) {\n    dist[e.to] = dist[u]+e.cost;\n    PQ.push(Pdi(dist[e.to], e.to));\n      }\n    }\n  }\n    \n  return dist[T];\n}\n \n#define IINF2 (INT_MAX/2)\n \nint main() {\n   \n  int N;\n  while(cin >> N && N) {\n \n    for(int i=0; i<300; i++) G[i].clear();\n \n    vector<C> cs;\n    for(int i=0; i<N; i++) {\n      double x, y, r; cin >> x >> y >> r;\n      cs.push_back(C(P(x, y), r));\n    }\n     \n    vector<pair<P, P> > ips(N+1);\n    ips[0].first = cs[0].p; // ips[0].second = P(-IINF2, -IINF2);\n    for(int i=0; i<N-1; i++) {\n      ips[i+1] = circle_circle_intersect(cs[i], cs[i+1]);\n    }\n    ips[N].first = cs[N-1].p; // ips.back().second = P(+IINF2, +IINF2);\n     \n    init_node_map(ips[0].first, ips[N].first, N);\n     \n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N+1; j++) {\n     \n    const int dij = j-i;\n     \n    for(int k=0; k<2; k++) {\n       \n      if(i == 0 && k == 1) continue;\n       \n      const P pti = k == 0 ? ips[i].first : ips[i].second;\n      const int a = get_node(pti);\n       \n      for(int l=0; l<2; l++) {\n         \n        if(j == N && l == 1) continue;\n         \n        const P ptj = l == 0 ? ips[j].first : ips[j].second;\n        const int b = get_node(ptj);\n         \n        bool ok = true;\n        const L sa(pti, ptj);\n        // ?¶???????????????°?????????????£?\n        for(int didx=1; didx<dij; didx++) {\n          const L sb(ips[i+didx]);\n          ok = ok && intersectSS(sa, sb);\n        }\n \n         \n        if(ok) {\n          const double len = abs(pti-ptj);\n          G[a].push_back((Edge){b, len});\n          G[b].push_back((Edge){a, len});\n        }\n         \n         \n      }\n    }\n      }\n    }\n     \n    printf(\"%.6f\\n\", dijkstra(get_node(cs[0].p), get_node(cs[N-1].p)));\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\n\ndouble dot(xy_t a, xy_t b){\n    return (conj(a) * b).X;\n}\n\ndouble cross(xy_t a, xy_t b){\n    return (conj(a) * b).Y;\n}\n\npair<xy_t, xy_t> cc_inter(xy_t a, double r, xy_t b, double s){\n    double d = abs(a - b);\n    double t = (r*r - s*s + d*d) / (2*d);\n    double x = sqrt(r*r - t*t);\n    xy_t v = t/d * (b-a) + a;\n    xy_t u = x/d * (b-a) * xy_t(0, 1);\n    return make_pair(v+u, v-u);\n}\n\ndouble f(xy_t a, xy_t b, xy_t c){\n    return (b.Y-a.Y)*(c.X-a.X) - (b.X-a.X)*(c.Y-a.Y);\n}\n\nbool is_crossing(xy_t a, xy_t b, xy_t c, xy_t d){\n    bool b1 = f(a, b, c) * f(a, b, d) <= 0;\n    bool b2 = f(c, d, a) * f(c, d, b) <= 0;\n    return b1 & b2;\n}\n\nint n;\ndouble d[210][210];\nxy_t p[210];\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        double x[110], y[110], r[110];\n        rep(i, n) scanf(\"%lf%lf%lf\", &x[i], &y[i], &r[i]);\n        p[0] = xy_t(x[0], y[0]);\n        p[2*n-1] = xy_t(x[n-1], y[n-1]);\n        rep(i, n-1){\n            auto tmp = cc_inter(xy_t(x[i], y[i]), r[i], xy_t(x[i+1], y[i+1]), r[i+1]);\n            p[i*2+1] = tmp.fi;\n            p[i*2+2] = tmp.se;\n        }\n        rep(i, 2*n){\n            rep(j, 2*n) d[i][j] = 1e18;\n            d[i][i] = 0;\n        }\n        rep(i, 2*n-1)For(j, i+1, 2*n){\n            bool flag = true;\n            for(int k=(i+1)/2*2+1; k<(j-1)/2*2; k+=2){\n                if(!is_crossing(p[i], p[j], p[k], p[k+1])){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag) d[i][j] = d[j][i] = abs(p[i] - p[j]);\n        }\n        rep(k, 2*n)rep(i, 2*n)rep(j, 2*n)if(d[i][k] < 1e18 && d[k][j] < 1e18){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        printf(\"%.10lf\\n\", d[0][2*n-1]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n// struct G : public vector<Point>\n// {\n//     G() {}\n//     G(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// AOJ0214\n// a contains b?\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-10;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.pb(q + v);\n    if (h > feps)\n        res.pb(q - v); // 2点\n    return res;\n}\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.pb(p + v);\n    if (t > feps)\n        res.pb(p - v); // 2点\n    return res;\n}\nvector<Point> ip_LC(const Line& line, const Circle& c)\n{\n    return ip_CL(c, line);\n}\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.pb(ip[i]);\n    return res;\n}\nvector<Point> ip_SC(const Seg& seg, const Circle& c)\n{\n    return ip_CS(c, seg);\n}\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\n\n\nint n;\nCircle c[111];\nPoint ip[111][2];\nbool reachable(int i, int a, int j, int b)\n{\n    Seg seg(ip[i][a], ip[j][b]);\n    Point vec = seg.second - seg.first;\n    vec *= 1e-4 / abs(vec);\n    rep(w, n)\n    {\n        vector<Point> pp = ip_CS(c[w], seg);\n        foreach (p, pp)\n        {\n            bool ok = false;\n            rep(t, n)\n            {\n                if (contain_CP(c[t], *p + vec))\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n    }\n    return true;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        rep(i, n)\n            cin >> c[i].p >> c[i].r;\n\n        rep(i, 2)\n        {\n            ip[0][i] = c[0].p;\n            ip[n][i] = c[n - 1].p;\n        }        \n        rep(i, n - 1)\n        {\n            vector<Point> t = ip_CC(c[i], c[i + 1]);\n            assert(t.size() == 2);\n            ip[i + 1][0] = t[0], ip[i + 1][1] = t[1];\n        }\n        \n        // erep(i, n) rep(j, 2)\n        // {\n        //     printf(\"%d, %d: \", i, j);\n        //     cout << ip[i][j] << endl;\n        // }\n\n        const double eps = 1e-9;\n        const double inf = 1e9;\n        typedef pair<double, pint> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        double dp[111][2];\n        erep(i, n) rep(j, 2)\n            dp[i][j] = inf;\n        dp[0][0] = dp[0][1] = 0;\n        q.push(P(0, pint(0, 0)));\n        double res = -1;\n        while (!q.empty())\n        {\n            P t = q.top();\n            q.pop();\n\n            int u = t.second.first, w = t.second.second;\n            double d = t.first;\n            if (d > dp[u][w] + eps)\n                continue;\n            else if (u == n)\n            {\n                res = d;\n                break;\n            }\n\n            for (int v = u; v <= n; ++v) rep(s, 2)\n            {\n                if (reachable(u, w, v, s))\n                {\n                    double nd = d + abs(ip[v][s] - ip[u][w]);\n                    if (nd + eps < dp[v][s])\n                    {\n                        dp[v][s] = nd;\n                        q.push(P(nd, pint(v, s)));\n                    }\n                }\n            }\n        }\n        printf(\"%.6f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cfloat>\nusing namespace std;\n\ntypedef double Weight;\nconst double INF = DBL_MAX;\nclass Edge {\npublic:\n    int source, target;\n    Weight weight;\n    Edge(int s, int t, Weight w) :source(s), target(t), weight(w) {}\n    bool operator<(const Edge& e) const {\n        if(weight != e.weight) return weight > e.weight;    // !!INVERSE!!\n        return source != e.source ? source < e.source : target < e.target;\n    }\n};\nclass Graph {\npublic:\n    vector< vector<Edge> > list;\n    int size;\n    Graph(int n) :size(n), list(vector< vector<Edge> >(n, vector<Edge>())) {};\n    Weight Dijkstra(int, int) const;\n};\nWeight Graph::Dijkstra(int from, int to) const {\n    vector<Weight> distance(size, INF);\n    distance[from] = 0;\n    priority_queue<Edge> q;\n    q.push(Edge(from, from, 0));\n    while(!q.empty()) {\n        Edge now = q.top(); q.pop();\n        int u = now.target;\n        if(distance[u] == INF) break;\n        for(vector<Edge>::const_iterator next = list[u].begin(); next != list[u].end(); next++) {\n            int v = next->target;\n            if(distance[v] <= distance[u] + next->weight) continue;\n            distance[v] = distance[u] + next->weight;\n            q.push(Edge(u, v, distance[v]));\n        }\n    }\n    return distance[to];\n}\n\nconst double EPS = 1e-10;\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\npublic:\n    double x, y;\n    Point(double a = 0.0, double b = 0.0) :x(a), y(b) {};\n    bool operator== (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    Point operator+(const Point&) const;\n    Point operator-(const Point&) const;\n    Point operator-() const;\n    Point times(double) const;\n    Point& operator=(const Point&);\n    Point& operator+=(const Point&);\n    Point& operator-=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Line&) const;\n    Point reflection(const Line&) const;\n    int ccw(const Point&, const Point&) const;              // a.ccw(b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n};\nclass Segment {\npublic:\n    Point source, target;\n    Segment(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\npublic:\n    Point source, target;\n    Line(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Point&) const;\n    Point reflection(const Point&) const;\n    Point crosspoint(const Line&) const;\n};\nclass Circle {\npublic:\n    double x, y, r;\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :x(a), y(b), r(c) {};\n    Point point() const;\n    double distance(const Point&) const;                    // 円の中心と点の距離\n    double distance(const Circle&) const;                   // 円の中心同士の距離\n    bool include(const Point&) const;                       // 点を含むか\n    bool include(const Circle&) const;                      // 円を含むか\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x == p.x && y == p.y;}\nbool Point::operator<(const Point &p) const {return x != p.x ? x < p.x : y < p.y;}\nbool Point::operator>(const Point &p) const {return x != p.x ? x > p.x : y > p.y;}\nbool Point::operator<=(const Point &p) const {return x != p.x ? x < p.x : y <= p.y;}\nbool Point::operator>=(const Point &p) const {return x != p.x ? x > p.x : y >= p.y;}\nPoint Point::operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\nPoint Point::operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\nPoint Point::operator-() const {return Point(-x, -y);}\nPoint Point::times(double d) const {return Point(x * d, y * d);}\nPoint& Point::operator=(const Point& p) {x = p.x; y = p.y; return *this;}\nPoint& Point::operator+=(const Point& p) {x += p.x; y += p.y; return *this;}\nPoint& Point::operator-=(const Point& p) {x -= p.x; y -= p.y; return *this;}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\ndouble Point::abs() const {return hypot(x, y);}\ndouble Point::norm() const {return x * x + y * y;}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nPoint Point::projection(const Line& l) const {return l.projection(*this);}\nPoint Point::reflection(const Line& l) const {return l.reflection(*this);}\nint Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > 0.0) return 1;\n    if(v1.cross(v2) < 0.0) return -1;\n    if(v1.dot(v2) < 0.0) return 2;\n    if(v1.norm() < v2.norm()) return -2;\n    return 0;\n}\n// Segment\nLine Segment::line() const {return Line(source, target);}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source.distance(p);\n    double b = target.distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    double c = s.distance(source);\n    double d = s.distance(target);\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source.distance(p) + target.distance(p) - target.distance(source) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source.ccw(s.target, source) * s.source.ccw(s.target, target) <= EPS;\n    bool b = source.ccw(target, s.source) * source.ccw(target, s.target) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nSegment Line::segment() const {return Segment(source, target);}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source);}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source - p;\n    Point v2 = target - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target - source;\n    Point v2 = s.source - source;\n    Point v3 = s.target - source;\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = l.source - source;\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nPoint Line::projection(const Point& p) const {\n    Point v1 = p - source;\n    Point v2 = source - target;\n    return Point(source + v2.times(v1.dot(v2) / v2.norm()));\n}\nPoint Line::reflection(const Point& p) const {\n    return p + (projection(p) - p).times(2.0);\n}\nPoint Line::crosspoint(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = target - l.source;\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source;\n    return l.source + v2.times(b / a);\n}\n// Circle\nPoint Circle::point() const {return Point(x, y);}\ndouble Circle::distance(const Point& p) const {return point().distance(p);}\ndouble Circle::distance(const Circle& c) const {return point().distance(c.point());}\nbool Circle::include(const Point& p) const {return distance(p) - r <= EPS;}\nbool Circle::include(const Circle& c) const {return distance(c) - (r - c.r) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return distance(c) - r - c.r <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y - y, c.x - x);\n    double d = distance(c);\n    double add = acos((d * d + r * r - c.r * c.r) / (2.0 * d * r));\n    vector<Point> result;\n    result.push_back(Point(x + r * cos(angle + add), y + r * sin(angle + add)));\n    result.push_back(Point(x + r * cos(angle - add), y + r * sin(angle - add)));\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<Circle> circle(n);\n        for(int i = 0; i < n; i++) {\n            double x, y, r;\n            cin>>x>>y>>r;\n            circle[i] = Circle(x, y, r);\n        }\n        vector<Segment> gate;\n        vector<Point> vertex;\n        vertex.push_back((*circle.begin()).point());\n        for(int i = 0; i < n - 1; i++) {\n            vector<Point> p = circle[i].crosspoint(circle[i + 1]);\n            gate.push_back(Segment(p[0], p[1]));\n            vertex.insert(vertex.end(), p.begin(), p.end());\n        }\n        vertex.push_back((*circle.rbegin()).point());\n        Graph g(vertex.size());\n        for(int i = 0; i < vertex.size() - 1; i++) {\n            for(int j = i + 1; j < vertex.size(); j++) {\n                Line edge(vertex[i], vertex[j]);\n                int firstGate = (i + 1) / 2;\n                int lastGate = (j + 1) / 2 - 1;\n                if(j == vertex.size() - 1) lastGate--;\n                bool ok = true;\n                for(int k = firstGate; k <= lastGate; k++) {\n                    if(!edge.intersect(gate[k])) ok = false;\n                }\n                if(ok) (g.list[i]).push_back(Edge(i, j, vertex[i].distance(vertex[j])));\n            }\n        }\n        cout<<g.Dijkstra(0, vertex.size() - 1)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define P pair<v2,v2>\nint n;\nint x[200],y[200],r[200];\nstruct v2{\n    double x;\n    double y;\n    v2 operator + (v2 a){\n        v2 r;\n        r.x = this->x + a.x;\n        r.y = this->y + a.y;\n        return r;\n    }\n    v2 operator - (v2 a){\n        v2 r;\n        r.x = this->x - a.x;\n        r.y = this->y - a.y;\n        return r;\n    }\n    v2 operator * (double a){\n        v2 r;\n        r.x = this->x * a;\n        r.y = this->y * a;\n        return r;\n    }\n    v2 operator / (double a){\n        v2 r;\n        r.x = this->x / a;\n        r.y = this->y / a;\n        return r;\n    }\n};\n\nv2 crossv[200][2];\ndouble v2abs(v2 a){\n    return sqrt(a.x * a.x + a.y * a.y);\n}\n\nv2 rot90plus(v2 a){\n    v2 r;r.x = -a.y;r.y = a.x;\n    return r;\n}\n\nv2 rot90minus(v2 a){\n    v2 r;r.x = a.y;r.y = -a.x;\n    return r;\n}\n\n\n\nP get_2crossv_of_circle(double x1,double y1,double r1,double x2,double y2,double r2){\n    v2 c1,c2;\n    c1.x = x1;c1.y = y1;c2.x = x2;c2.y = y2;\n    double a = v2abs(c2 - c1);\n    double b = r1;\n    double c = r2;\n\n    double rc = (a * a + b * b - c * c) / (2.0 * a);\n    double rs = sqrt(b * b - rc * rc);\n    v2 diff = (c2 - c1) / a;\n\n    P p;\n    p.first = c1 + diff * rc + (rot90plus(diff) * rs);\n    p.second = c1 + diff * rc + (rot90minus(diff) * rs);\n\n    return p;\n}\n\nbool judge(v2 a1,v2 a2,v2 b1,v2 b2){\n    v2 a = a2 - a1;\n    v2 c1 = b1 - a1;\n    v2 c2 = b2 - a1;\n    return (a.x * c1.y - a.y * c1.x) * (a.x * c2.y - a.y * c2.x) <= 0.0;\n}\n\nbool judgecross(v2 a,v2 b,int a1,int b1){\n    for(int i = a1 + 1;i < b1;i++){\n        if(!judge(a,b,crossv[i][0],crossv[i][1])){\n            return false;\n        }\n    }\n    return true;\n}\n\nbool input(){\n    scanf(\"%d\",&n);\n    if(n == 0)\n        return false;\n    REP(i,n){\n        scanf(\"%d%d%d\",&x[i],&y[i],&r[i]);\n    }\n    return true;\n}\n\ndouble G[1000][1000];\n\nvoid solve(){\n\n    REP(i,1000)\n        REP(j,1000)\n            G[i][j] = 1000000000.0;\n    REP(i,1000)\n        G[i][i] = 0.0;\n\n    REP(i,n - 1){\n        P p = get_2crossv_of_circle(x[i],y[i],r[i],x[i + 1],y[i + 1],r[i + 1]);\n        crossv[i][0] = p.first;\n        crossv[i][1] = p.second;\n    }\n\n    REP(i,(n - 1) * 2){\n        FOR(j,i + 1,(n - 1) * 2){\n            int i1 = i / 2;int i2 = i % 2;\n            int j1 = j / 2;int j2 = j % 2;\n            if(!judgecross(crossv[i1][i2],crossv[j1][j2],i1,j1))\n                continue;\n            G[i][j] = G[j][i] = v2abs(crossv[i1][i2] - crossv[j1][j2]);\n        }\n    }\n    v2 start;start.x = x[0];start.y = y[0];\n    REP(i,(n - 1) * 2){\n        int i1  = i / 2;int i2 = i % 2;\n        if(!judgecross(start,crossv[i1][i2],-1,i1))\n            continue;\n        \n        G[i][n * 2 - 2] = G[n * 2 - 2][i] = v2abs(start - crossv[i1][i2]);\n    }\n    v2 end;end.x = x[n - 1];end.y = y[n - 1];\n    REP(i,(n - 1) * 2){\n        int i1  = i / 2;int i2 = i % 2;\n        if(!judgecross(crossv[i1][i2],end,i1,n - 1))\n            continue;\n        \n        G[i][n * 2 - 1] = G[n * 2 - 1][i] = v2abs(end - crossv[i1][i2]);\n    }\n    if(judgecross(start,end,-1,n - 1))\n        G[n * 2 - 1][n * 2 - 2] = G[n * 2 - 2][n * 2 - 1] = v2abs(start - end);\n\n    REP(k,n*2){\n        REP(i,n*2){\n            REP(j,n*2){\n                G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n            }\n        }\n    }\n    printf(\"%lf\\n\",G[n*2-2][n*2-1]);\n}\n\nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n/*\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n*/\n//const ll mod = 1000000007;\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nCircle C[105];\nPoint Center[105];\ndouble Radius[105];\nPoint Pdp[105][2];\ndouble Vdp[105][2];\n\ntemplate<typename T>\nvoid chmin(T &a, T b) {\n    a = min(a, b);\n}\n\nint N;\n\nbool check(int before, int after, Segment L) {\n    for(int i = before + 1; i < after; i++) {\n      Segment now(Pdp[i][0], Pdp[i][1]);\n      if(!intersect(now, L)) return false;\n    }\n    return true;\n}\n\nint main() {\n    cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> N;\n        if(N == 0) break;\n        for(int i = 1; i <= N; i++) {\n            cin >> Center[i] >> Radius[i];\n            C[i] = Circle(Center[i], Radius[i]);\n        }\n        for(int i = 0; i <= 1; i++) {\n            Pdp[0][i] = Center[1];\n            Vdp[0][i] = 0;\n            Pdp[N][i] = Center[N];\n        }\n        for(int index = 1; index < N; index++) {\n          auto pp = crosspoint(C[index], C[index+1]);\n          Pdp[index][0] = pp.first;\n          Pdp[index][1] = pp.second;\n        }\n        for(int index = 1; index <= N; index++) {\n            for(int i = 0; i <= 1; i++) {\n                Vdp[index][i] = 1e18;\n                for(int before = 0; before < index; before++) {\n                    for(int k = 0; k <= 1; k++) {\n                        Segment seg(Pdp[before][k], Pdp[index][i]);\n                        if(check(before, index, seg)) {\n                            chmin(Vdp[index][i], Vdp[before][k] + distance(Pdp[before][k], Pdp[index][i]));\n                        }\n                    }\n                }\n            }\n        }\n        cout << Vdp[N][0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r;\n\tC() {}\n\tC(P pp, D rr) : p(pp), r(rr) {}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn abs(res)/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tif (ps.size()==1) return ps;\n\t\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// 凸多角形を直線で切断し、左側を残す\nG convex_cut(G g, L l)\n{\n\tG res;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(l.a, l.b, a) != RIGHT) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) res.push_back(cLL(L(a, b), l));\n\t}\n\treturn res;\n}\n\n/** Problem1183 : Chain-Confined Path **/\nconst int MAX_V = 1000;\n\nD cost[MAX_V][MAX_V];\n\n\nvector<C> list;\nvector<vector<P> > cp;\nint N;\n\nvoid check(P sp, P tp, int si, int ti, int id1, int id2)\n{\n\tbool ok=true;\n\t\n\tL l(sp, tp);\n\tfor (int i = si; i<ti; i++) {\n\t\tL m(cp[i][0], cp[i][1]);\n\t\tif (!iSS(l, m)) {\n\t\t\tok = false;\n\t\t}\n\t}\n\t\n\tif (ok) {\n\t\tcost[id1][id2] = cost[id2][id1] = abs(sp-tp);\n\t}\n}\n\nint main()\n{\n\twhile (cin>>N, N) {\n\t\tlist.clear();\n\t\tcp.clear();\n\t\t\n\t\tfill(cost[0], cost[0]+MAX_V*MAX_V, INF);\n\t\t\n\t\tlist.resize(N);\n\t\trep(i, N) {\n\t\t\tcin>>list[i].p.X>>list[i].p.Y>>list[i].r;\n\t\t}\n\t\t\n\t\tcp.resize(N+1);\n\t\tcp[0].push_back(list[0].p);\n\t\tcp[0].push_back(list[0].p);\n\t\tcp[N].push_back(list[N-1].p);\n\t\tcp[N].push_back(list[N-1].p);\n\t\t\n\t\tfor (int i=1; i<N; i++) {\n\t\t\tcp[i] = cCC(list[i], list[i-1]);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<N+1; i++) {\n\t\t\tfor (int j=i+1; j<N+1; j++) {\n\t\t\t\tcheck(cp[i][0], cp[j][0], i+1, j, 2*i, 2*j);\n\t\t\t\tcheck(cp[i][0], cp[j][1], i+1, j, 2*i, 2*j+1);\n\t\t\t\tcheck(cp[i][1], cp[j][0], i+1, j, 2*i+1, 2*j);\n\t\t\t\tcheck(cp[i][1], cp[j][1], i+1, j, 2*i+1, 2*j+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0; k<2*(N+1); k++) {\n\t\t\tfor (int i=0; i<2*(N+1); i++) {\n\t\t\t\tfor (int j=0; j<2*(N+1); j++) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << fixed << setprecision(15);\n\t\tcout << cost[0][2*(N+1)-1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\nbool operator > (Edge<int> e1, Edge<int> e2) {\n    return e1.cost < e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate <typename T>\nstd::vector<T> dijkstra(const Graph<T> &g, int s) {\n    int sz = (int)(g.size());\n    std::vector<T> dist(sz, -1);\n    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n    while(!pq.empty()) {\n        T d = pq.top().first;\n        int now = pq.top().second;\n        pq.pop();\n        if(dist[now] == -1 || d > dist[now]) continue;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            T cost = g[now][i].cost;\n            if(dist[next] == -1 || dist[next] > dist[now] + cost) {\n                dist[next] = dist[now] + cost;\n                pq.push({cost, next});\n            }\n        }\n    }\n    return dist;\n}\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nusing Point = std::complex<ld>;\nconst ld pi = acos(-1.0);\nnamespace std {\nbool operator<(const Point &lhs, const Point &rhs) {\n  if (lhs.real() < rhs.real() - eps) return true;\n  if (lhs.real() > rhs.real() + eps) return false;\n  return lhs.imag() < rhs.imag();\n}\n}\nPoint input_point() {\n  ld x, y;\n  std::cin >> x >> y;\n  return Point(x, y);\n}\nbool eq(ld a, ld b) { return (abs(a - b) < eps); }\nld dot(Point a, Point b) { return real(conj(a) * b); }\nld cross(Point a, Point b) { return imag(conj(a) * b); }\nint ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nclass Line {\n public:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n};\nld dot(Line l, Line m) { return dot((l.a - l.b), (m.a - m.b)); }\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\nbool isis_ls(Line l, Line s) {\n  return isis_ll(l, s) &&\n         (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\nbool isis_sp(Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nPoint proj(Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\nPoint is_ll(Line l, Line m) {\n  Point lv = l.b - l.a, mv = m.b - m.a;\n  assert(cross(lv, mv) != 0);\n  return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\nld dist_lp(Line l, Point p) { return abs(p - proj(l, p)); }\nld dist_ll(Line l, Line m) { return isis_ll(l, m) ? 0 : dist_lp(l, m.a); }\nld dist_ls(Line l, Line s) {\n  return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\nld dist_sp(Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\nld dist_ss(Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return std::min(\n      {dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\nLine bisector(Point a, Point b) {\n  Point mid = (a + b) * Point(0.5, 0);\n  return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\nld degree_ll(Line l, Line m) {\n  ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n  if (cos_shita < -1.0) cos_shita = -1.0;\n  if (cos_shita > 1.0) cos_shita = 1.0;\n  ld shita = acos(cos_shita);\n  return shita;\n}\nclass Circle {\n public:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\nstd::vector<Point> is_cc(Circle c1, Circle c2) {\n  std::vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps)\n    dfr = 0.0;\n  else if (dfr < 0.0)\n    return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.emplace_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.emplace_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\nstd::vector<Point> is_lc(Circle c, Line l) {\n  std::vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps) {\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.emplace_back(proj(l, c.p) + len * nor);\n    res.emplace_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\nstd::vector<Point> is_sc(Circle c, Line l) {\n  std::vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.emplace_back(p);\n  return res;\n}\nstd::vector<Line> tangent_cp(Circle c, Point p) {\n  std::vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) {\n    return ret;\n  }\n  Point v1 = v * Point(l / d, c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.emplace_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.emplace_back(Line(p, p + v2));\n  return ret;\n}\nvoid solve(int n) {\n  vector<Circle> circles;\n  for(int i=0;i<n;++i) {\n    Point p = input_point();\n    ld r; cin >> r;\n    circles.emplace_back(Circle(p, r));\n  }\n  Point s = circles[0].p, g = circles[n-1].p;\n  vector<Point> p0(n-1), p1(n-1);\n  for(int i=0;i<n-1;++i) {\n    auto res = is_cc(circles[i], circles[i+1]);\n    p0[i] = res[0];\n    p1[i] = res[1];\n  }\n  Graph<ld> graph(2*n);\n  Line line(s, g);\n  bool ok = true;\n  for(int i=0;i<n-1;++i) {\n    ld lp0 = cross(line.b - line.a, p0[i] - line.a), lp1 = cross(line.b - line.a, p1[i] - line.a);\n    ok &= (signbit(lp0) != signbit(lp1));\n  }\n  if(ok) graph[0].push_back(Edge<ld>(0, 2*n-1, abs(s - g)));\n  for(int i=0;i<n-1;++i) {\n    Line l0(s, p0[i]), l1(s, p1[i]);\n    bool ok0 = true, ok1 = true;\n    for(int j=0;j<i;++j) {\n      ld l0p0 = cross(l0.b - l0.a, p0[j] - l0.a), l0p1 = cross(l0.b - l0.a, p1[j] - l0.a);\n      ld l1p0 = cross(l1.b - l1.a, p0[j] - l1.a), l1p1 = cross(l1.b - l1.a, p1[j] - l1.a);\n      ok0 &= (signbit(l0p0) != signbit(l0p1));\n      ok1 &= (signbit(l1p0) != signbit(l1p1));\n    }\n    if(ok0) graph[0].push_back(Edge<ld>(0, 1 + i*2, abs(s - p0[i])));\n    if(ok1) graph[0].push_back(Edge<ld>(0, 2 + i*2, abs(s - p1[i])));\n  }\n  for(int i=0;i<n-1;++i) {\n    Line l0(p0[i], g), l1(p1[i], g);\n    bool ok0 = true, ok1 = true;\n    for(int j=i+1;j<n-1;++j) {\n      ld l0p0 = cross(l0.b - l0.a, p0[j] - l0.a), l0p1 = cross(l0.b - l0.a, p1[j] - l0.a);\n      ld l1p0 = cross(l1.b - l1.a, p0[j] - l1.a), l1p1 = cross(l1.b - l1.a, p1[j] - l1.a);\n      ok0 &= (signbit(l0p0) != signbit(l0p1));\n      ok1 &= (signbit(l1p0) != signbit(l1p1));\n    }\n    if(ok0) graph[1+i*2].push_back(Edge<ld>(1+i*2, 2*n-1, abs(g - p0[i])));\n    if(ok1) graph[2+i*2].push_back(Edge<ld>(2+i*2, 2*n-1, abs(g - p1[i])));\n  }\n  for(int i=0;i<n-2;++i) {\n    for(int j=i+1;j<n-1;++j) {\n      Line l0(p0[i], p0[j]), l1(p0[i], p1[j]), l2(p1[i], p0[j]), l3(p1[i], p1[j]);\n      bool ok0 = true, ok1 = true, ok2 = true, ok3 = true;\n      for(int k=i+1;k<j;++k) {\n        ld l0p0 = cross(l0.b - l0.a, p0[k] - l0.a), l0p1 = cross(l0.b - l0.a, p1[k] - l0.a);\n        ld l1p0 = cross(l1.b - l1.a, p0[k] - l1.a), l1p1 = cross(l1.b - l1.a, p1[k] - l1.a);\n        ld l2p0 = cross(l2.b - l2.a, p0[k] - l2.a), l2p1 = cross(l2.b - l2.a, p1[k] - l2.a);\n        ld l3p0 = cross(l3.b - l3.a, p0[k] - l3.a), l3p1 = cross(l3.b - l3.a, p1[k] - l3.a);\n        ok0 &= (signbit(l0p0) != signbit(l0p1));\n        ok1 &= (signbit(l1p0) != signbit(l1p1));\n        ok2 &= (signbit(l2p0) != signbit(l2p1));\n        ok3 &= (signbit(l3p0) != signbit(l3p1));\n      }\n      if(ok0) graph[1+i*2].push_back(Edge<ld>(1+i*2, 1+j*2, abs(p0[i] - p0[j])));\n      if(ok1) graph[1+i*2].push_back(Edge<ld>(1+i*2, 2+j*2, abs(p0[i] - p1[j])));\n      if(ok2) graph[2+i*2].push_back(Edge<ld>(2+i*2, 1+j*2, abs(p1[i] - p0[j])));\n      if(ok3) graph[2+i*2].push_back(Edge<ld>(2+i*2, 2+j*2, abs(p1[i] - p1[j])));\n    }\n  }\n  cout << dijkstra(graph, 0)[2*n-1] << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n\nconst double EPS = 1e-8;\ninline double dot(P a, P b) {return real( conj(a)*b);}\ninline double cross(P a, P b) {return imag( conj(a)*b);}\ninline double sq(double x) {return x * x;}\ninline int signum(double x) {return x > EPS ? +1 : x < -EPS ? -1 : 0;} // 未検証\n\nstruct C : public P {\n  double r;\n  C() {}\n  C(const P &p,double r):P(p),r(r){}\n};\n\n// 2円の交点\nvector<P> IntersectionCC(const C& c1, const C& c2) {\n  vector<P> ret;\n  double d = abs(c1 - c2);\n  P diff = (c2 - c1) / d;\n  if( c1.r + c2.r < d - EPS ) {                        // 離れていて交点0\n\n  } else if( d < EPS && abs(c1.r - c2.r) < EPS ) {     // 2円が重なる\n\n  } else if( abs( c1.r + c2.r - d ) < EPS ) {          // 外側で1点で接する\n      ret.push_back( c1 + diff * c1.r );\n  } else if( abs( c1.r - c2.r ) > d + EPS ) {          // 内側に含む。交点0\n\n  } else if( abs( abs( c1.r - c2.r ) - d ) < EPS) {    // 内側で1点で接する\n      ret.push_back( c1 + diff * c1.r );\n  } else {                                            // 2点で交わる\n//     assert( d < c1.r + c2.r );\n      double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n      double rs = sqrt(c1.r*c1.r - rc*rc);\n\n      ret.push_back( c1 + diff * P(rc, -rs) );\n      ret.push_back( c1 + diff * P(rc, rs) );\n  }\n  return ret;\n}\n\nbool IsIntersectSP(P a, P b, P c) {\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\nbool IsIntersectLL(P a,P b,P c,P d){\n  return abs(cross(b-a, d-c)) > EPS || // non-parallel\n      abs(cross(b-a, c-a)) < EPS;   // same line\n}\nP IntersectionLL(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\ndouble DistanceLP(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// ベクトルpをベクトルbに射影したベクトルを計算する\nP proj(P p, P b) {\n  return b * dot(p,b) / norm(b);\n}\n\n// 点pから直線abに引いた垂線の足となる点を計算する\nP FootOfLP(P a, P b, P p){\n  return a + proj(p-a,b-a);\n}\n\n\n// 直線abと円cの交点をvectorで返す\nvector<P> IntersectionLC(P a, P b, C c){\n  double dist = DistanceLP(a,b,c);\n  vector<P> ret;\n  if( abs(dist - c.r) < EPS ) {\n      ret.push_back( FootOfLP(a,b,c) );\n  } else if( dist < c.r ) {\n      P m = FootOfLP(a,b,c);\n      P u = (b-a) / abs(b-a);\n      double t = sqrt( c.r * c.r - dist * dist );\n      ret.push_back( m + t * u );\n      ret.push_back( m - t * u );\n  }\n  return ret;\n}\n\n\nint N;\nvector<C> c;\nvector<P> p;\n\nbool canSee(P a, P b) {\n  vector<P> m; // 線分 a-b と円の交点\n  REP(i, c.size()) {\n      vector<P> cur = IntersectionLC(a, b, c[i]);\n      for (int j = 0; j < cur.size(); j++) {\n          if (IsIntersectSP(a, b, cur[j])) {\n              m.push_back(cur[j]);\n          }\n      }\n  }\n  m.push_back((a + b) / 2.0);\n\n  for (int i = 0; i < m.size(); i++) {\n      int in = 0;\n      for (int j = 0; j < c.size(); j++) {\n          double d = abs(c[j] - m[i]);\n          if (d < c[j].r - EPS) {\n              in++;\n          }\n          if (d < c[j].r + EPS) {\n              in++;\n          }\n      }\n      if (in <= 1) return false;\n  }\n\n  return true;\n}\n\nint psize;\ndouble dist[512][512];\n\nint main() {\n  for (; cin >> N && N; ) {\n      c.clear();\n      p.clear();\n      REP(i,N) {\n          int x, y, r; cin >> x >> y >> r;\n          c.push_back(C(P(x,y), r));\n      }\n      p.push_back(c[0]);\n      p.push_back(c[N-1]);\n\n      REP(i, N) {\n          REP(j, i) if ( abs(i - j) <= 2) {\n              double d = abs(c[i] - c[j]);\n              if(c[i].r + c[j].r <= d + EPS) {\n\n              } else {\n                  vector<P> m = IntersectionCC(c[i], c[j]);\n                  for (int i = 0; i < m.size(); i++)\n                      p.push_back(m[i]);\n              }\n          }\n      }\n\n      psize = p.size();\n      REP(i, psize) {\n          REP(j, psize) {\n              if (canSee(p[i], p[j])) {\n                  dist[i][j] = dist[j][i] = abs(p[i] - p[j]);\n              } else {\n                  dist[i][j] = dist[j][i] = 1001001001;\n              }\n          }\n      }\n\n\n      REP(k, psize) REP(i, psize) REP(j, psize) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n\n//       cout << \"---\" << endl;\n//       REP(k, psize) {\n//           if (abs(-dist[0][1] + dist[0][k] + dist[k][1]) < EPS)\n//               cout << p[k] << endl;\n//       }\n\n      printf(\"%.8f\\n\", dist[0][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <map>\n#include <queue>\n#include <assert.h>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n \nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(pair<P, P> pp) {\n    push_back(pp.first); push_back(pp.second);\n  }\n};\n \nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n \nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> circle_circle_intersect(C c1, C c2) {\n  if(c1.p.real() > c2.p.real()) swap(c1, c2);\n  const double d = abs(c2.p - c1.p);\n  const double alpha  = acos((c2.p.real() - c1.p.real()) / d) * ((c1.p.imag() > c2.p.imag()) ? -1.0 : 1.0);\n  const double beta   = acos((c1.r * c1.r - c2.r * c2.r + d * d) / 2.0 / d / c1.r);\n  return make_pair(c1.p + polar(c1.r, alpha - beta), c1.p + polar(c1.r, alpha + beta));\n}\n\nstruct Edge {\n  int to;\n  double cost;\n};\n \nvector<Edge> G[300];\n \nmap<P, int> mp;\nint nidx;\nvoid init_node_map(P ps, P pt, int N) {\n  mp.clear();\n  mp[ps] = 0;\n  mp[pt] = (N-1)*2+1;\n  nidx = 1;\n}\n \nint get_node(P p) {\n  if(mp.find(p) == mp.end()) {\n    mp[p] = nidx++;\n  }\n  return mp[p];\n}\n \n#define MAX (300)\ndouble dist[MAX];\n \ntypedef pair<double, int> Pdi;\n  \ndouble dijkstra(int S, int T) {\n   \n  priority_queue<Pdi, vector<Pdi>, greater<Pdi> > PQ;\n  fill(dist, dist+MAX, INF);\n  dist[S] = 0;\n  PQ.push(Pdi(0., S));\n    \n  while(!PQ.empty()) {\n    Pdi pdi = PQ.top(); PQ.pop();\n    const int u = pdi.second;\n    for(int i=0; i<(int)G[u].size(); i++) {\n      const Edge& e = G[u][i];\n      if(dist[e.to] > dist[u]+e.cost) {\n    dist[e.to] = dist[u]+e.cost;\n    PQ.push(Pdi(dist[e.to], e.to));\n      }\n    }\n  }\n    \n  return dist[T];\n}\n \n#define IINF2 (INT_MAX/2)\n \nint main() {\n   \n  int N;\n  while(cin >> N && N) {\n \n    for(int i=0; i<300; i++) G[i].clear();\n \n    vector<C> cs;\n    for(int i=0; i<N; i++) {\n      double x, y, r; cin >> x >> y >> r;\n      cs.push_back(C(P(x, y), r));\n    }\n     \n    vector<pair<P, P> > ips(N+1);\n    ips[0].first = cs[0].p; // ips[0].second = P(-IINF2, -IINF2);\n    for(int i=0; i<N-1; i++) {\n      ips[i+1] = circle_circle_intersect(cs[i], cs[i+1]);\n    }\n    ips[N].first = cs[N-1].p; // ips.back().second = P(+IINF2, +IINF2);\n     \n    init_node_map(ips[0].first, ips[N].first, N);\n     \n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N+1; j++) {\n     \n    const int dij = j-i;\n     \n    for(int k=0; k<2; k++) {\n       \n      if(i == 0 && k == 1) continue;\n       \n      const P pti = k == 0 ? ips[i].first : ips[i].second;\n      const int a = get_node(pti);\n       \n      for(int l=0; l<2; l++) {\n         \n        if(j == N && l == 1) continue;\n         \n        const P ptj = l == 0 ? ips[j].first : ips[j].second;\n        const int b = get_node(ptj);\n         \n        bool ok = true;\n        const L sa(pti, ptj);\n        // ?¶???????????????°?????????????£?\n        for(int didx=1; didx<dij; didx++) {\n          const L sb(ips[i+didx]);\n          ok = ok && intersectSS(sa, sb);\n        }\n \n         \n        if(ok) {\n          const double len = abs(pti-ptj);\n          G[a].push_back((Edge){b, len});\n          G[b].push_back((Edge){a, len});\n        }\n         \n         \n      }\n    }\n      }\n    }\n     \n    printf(\"%.6f\\n\", dijkstra(get_node(cs[0].p), get_node(cs[N-1].p)));\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Chain-Confined Path\n\n// 円同士の交点を頂点, 円内部を通る線分を辺としたダイクストラ\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<cfloat>\nusing namespace std;\n\ntypedef double Weight;\nconst double INF = DBL_MAX;\nclass Edge {\npublic:\n    int source, target;\n    Weight weight;\n    Edge(int s, int t, Weight w) :source(s), target(t), weight(w) {}\n    bool operator<(const Edge& e) const {\n        if(weight != e.weight) return weight > e.weight;    // !!INVERSE!!\n        return source != e.source ? source < e.source : target < e.target;\n    }\n};\nclass Graph {\npublic:\n    vector< vector<Edge> > list;\n    int size;\n    Graph(int n) :size(n), list(vector< vector<Edge> >(n, vector<Edge>())) {};\n    Weight Dijkstra(int, int) const;\n};\nWeight Graph::Dijkstra(int from, int to) const {\n    vector<Weight> distance(size, INF);\n    distance[from] = 0;\n    priority_queue<Edge> q;\n    q.push(Edge(from, from, 0));\n    while(!q.empty()) {\n        Edge now = q.top(); q.pop();\n        int u = now.target;\n        if(distance[u] == INF) break;\n        for(vector<Edge>::const_iterator next = list[u].begin(); next != list[u].end(); next++) {\n            int v = next->target;\n            if(distance[v] <= distance[u] + next->weight) continue;\n            distance[v] = distance[u] + next->weight;\n            q.push(Edge(u, v, distance[v]));\n        }\n    }\n    return distance[to];\n}\n\nconst double EPS = 0.0;\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\npublic:\n    double x, y;\n    Point(double a = 0.0, double b = 0.0) :x(a), y(b) {};\n    bool operator== (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    Point operator+(const Point&) const;\n    Point operator-(const Point&) const;\n    Point operator-() const;\n    Point times(double) const;\n    Point& operator=(const Point&);\n    Point& operator+=(const Point&);\n    Point& operator-=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Line&) const;\n    Point reflection(const Line&) const;\n    int ccw(const Point&, const Point&) const;              // a.ccw(b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n};\nclass Segment {\npublic:\n    Point source, target;\n    Segment(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n};\nclass Line {\npublic:\n    Point source, target;\n    Line(Point a = Point(), Point b = Point()) :source(a), target(b) {};\n    Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    Point projection(const Point&) const;\n    Point reflection(const Point&) const;\n    Point crosspoint(const Line&) const;\n};\nclass Circle {\npublic:\n    double x, y, r;\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :x(a), y(b), r(c) {};\n    Point point() const;\n    double distance(const Point&) const;                    // 円の中心と点の距離\n    double distance(const Circle&) const;                   // 円の中心同士の距離\n    bool include(const Point&) const;                       // 点を含むか\n    bool include(const Circle&) const;                      // 円を含むか\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x == p.x && y == p.y;}\nbool Point::operator<(const Point &p) const {return x != p.x ? x < p.x : y < p.y;}\nbool Point::operator>(const Point &p) const {return x != p.x ? x > p.x : y > p.y;}\nbool Point::operator<=(const Point &p) const {return x != p.x ? x < p.x : y <= p.y;}\nbool Point::operator>=(const Point &p) const {return x != p.x ? x > p.x : y >= p.y;}\nPoint Point::operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\nPoint Point::operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\nPoint Point::operator-() const {return Point(-x, -y);}\nPoint Point::times(double d) const {return Point(x * d, y * d);}\nPoint& Point::operator=(const Point& p) {x = p.x; y = p.y; return *this;}\nPoint& Point::operator+=(const Point& p) {x += p.x; y += p.y; return *this;}\nPoint& Point::operator-=(const Point& p) {x -= p.x; y -= p.y; return *this;}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\ndouble Point::abs() const {return hypot(x, y);}\ndouble Point::norm() const {return x * x + y * y;}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nPoint Point::projection(const Line& l) const {return l.projection(*this);}\nPoint Point::reflection(const Line& l) const {return l.reflection(*this);}\nint Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > 0.0) return 1;\n    if(v1.cross(v2) < 0.0) return -1;\n    if(v1.dot(v2) < 0.0) return 2;\n    if(v1.norm() < v2.norm()) return -2;\n    return 0;\n}\n// Segment\nLine Segment::line() const {return Line(source, target);}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source.distance(p);\n    double b = target.distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    double c = s.distance(source);\n    double d = s.distance(target);\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source.distance(p) + target.distance(p) - target.distance(source) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source.ccw(s.target, source) * s.source.ccw(s.target, target) <= EPS;\n    bool b = source.ccw(target, s.source) * source.ccw(target, s.target) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nSegment Line::segment() const {return Segment(source, target);}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source);\n    double b = distance(s.target);\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source);}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source - p;\n    Point v2 = target - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target - source;\n    Point v2 = s.source - source;\n    Point v3 = s.target - source;\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = l.source - source;\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nPoint Line::projection(const Point& p) const {\n    Point v1 = p - source;\n    Point v2 = source - target;\n    return Point(source + v2.times(v1.dot(v2) / v2.norm()));\n}\nPoint Line::reflection(const Point& p) const {\n    return p + (projection(p) - p).times(2.0);\n}\nPoint Line::crosspoint(const Line& l) const {\n    Point v1 = target - source;\n    Point v2 = l.target - l.source;\n    Point v3 = target - l.source;\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source;\n    return l.source + v2.times(b / a);\n}\n// Circle\nPoint Circle::point() const {return Point(x, y);}\ndouble Circle::distance(const Point& p) const {return point().distance(p);}\ndouble Circle::distance(const Circle& c) const {return point().distance(c.point());}\nbool Circle::include(const Point& p) const {return distance(p) - r <= EPS;}\nbool Circle::include(const Circle& c) const {return distance(c) - (r - c.r) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return distance(c) - r - c.r <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y - y, c.x - x);\n    double d = distance(c);\n    double add = acos((d * d + r * r - c.r * c.r) / (2.0 * d * r));\n    vector<Point> result;\n    result.push_back(Point(x + r * cos(angle + add), y + r * sin(angle + add)));\n    result.push_back(Point(x + r * cos(angle - add), y + r * sin(angle - add)));\n    return result;\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<Circle> circle(n);\n        for(int i = 0; i < n; i++) {\n            double x, y, r;\n            cin>>x>>y>>r;\n            circle[i] = Circle(x, y, r);\n        }\n        vector<Segment> gate;\n        vector<Point> vertex;\n        vertex.push_back((*circle.begin()).point());\n        for(int i = 0; i < n - 1; i++) {\n            vector<Point> p = circle[i].crosspoint(circle[i + 1]);\n            gate.push_back(Segment(p[0], p[1]));\n            vertex.insert(vertex.end(), p.begin(), p.end());\n        }\n        vertex.push_back((*circle.rbegin()).point());\n        Graph g(vertex.size());\n        for(int i = 0; i < vertex.size() - 1; i++) {\n            for(int j = i + 1; j < vertex.size(); j++) {\n                Segment edge(vertex[i], vertex[j]);\n                int firstGate = (i + 1) / 2;\n                int lastGate = (j + 1) / 2 - 1;\n                if(j == vertex.size() - 1) lastGate--;\n                bool ok = true;\n                for(int k = firstGate; k <= lastGate; k++) {\n                    if(!edge.intersect(gate[k])) ok = false;\n                }\n                if(ok) (g.list[i]).push_back(Edge(i, j, vertex[i].distance(vertex[j])));\n            }\n        }\n        printf(\"%.6f\\n\", g.Dijkstra(0, vertex.size() - 1));\n//         for(int i=0; i<(g.list).size(); i++) {cout<<vertex[i].x<<\", \"<<vertex[i].y<<endl;}\n//         for(int i=0; i<(g.list).size(); i++) {\n//             for(int j=0; j<(g.list[i]).size(); j++) {\n//                 cout<<\" \"<<((g.list[i])[j]).target<<\":\"<<((g.list[i])[j]).weight;\n//             }\n//             cout<<endl;\n//         }\n//         return(1);\n//         cout<<g.Dijkstra(0, vertex.size() - 1)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define X(r) real((r))\n#define Y(r) imag((r))\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n\n//?????¨????????????????±???????\nvector<point> crossPoint(const C& a, const C& b){\n\tdouble d = abs(b.p-a.p);\n\tdouble arg = atan2(Y(b.p-a.p), X(b.p-a.p));\n\tdouble arg2 = acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r));\n\tif(abs(arg2)<EPS) return {a.r*complex<double>(cos(arg), sin(arg))+a.p};\n\tif(abs(a.r-b.r)<d && d < a.r+b.r) return {a.r*complex<double>(cos(arg+arg2), sin(arg+arg2))+a.p, a.r*complex<double>(cos(arg-arg2), sin(arg-arg2))+a.p};\n\treturn {};\n}\nstruct Edge{\n\tint to;\n\tdouble cost;\n};\n\ndouble dist[100010];\nvector<Edge> es[100010];\n\nint main(){\n\tint n;\n\twhile(cin>>n && n){\n\t\tvector<C> c;\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin>>x>>y>>r;\n\t\t\tc.pb(C({x, y}, r));\n\t\t}\n\t\tvector<vector<P> > v;\n\t\tfor(int i = 0; i < n-1; i++) v.pb(crossPoint(c[i], c[i+1]));\n\t\trep(i, 100010) dist[i] = 1e18, es[i].clear();\n\t\tdist[0] = 0.0;\n\t\tint goal=n*2-1;\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\tauto& p = v[i][j];\n\t\t\t\tint now = i*2+j+1;\n\t\t\t\tfor(int k = -1; k <= (int)v.size(); k++){\n\t\t\t\t\tif(k == i) continue;\n\t\t\t\t\tvector<point> ps;\n\t\t\t\t\tint nxt;\n\t\t\t\t\tif(k == -1) ps.pb(c[0].p), nxt = 0;\n\t\t\t\t\telse if(k == v.size()) ps.pb(c.back().p), nxt = goal;\n\t\t\t\t\telse ps = v[k], nxt = k*2+1;\n\t\t\t\t\tfor(auto& p2 : ps){\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor(int l = (k < i ? k+1 : i+1); l < (k < i ? i:k); l++){\n\t\t\t\t\t\t\tif(!intersectSS({p, p2}, {v[l][0], v[l][1]})) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f) {\n\t\t\t\t\t\t\tes[now].pb({nxt, abs(p - p2)});\n\t\t\t\t\t\t\tes[nxt].pb({now, abs(p - p2)});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnxt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto dijkstra = [&](){\n\t\t\ttypedef pair<double, int> PP;\n\t\t\tpriority_queue<PP, vector<PP>, greater<PP> > q;\n\t\t\tPP p;\n\t\t\tq.push({0.0, 0});\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top();\tq.pop();\n\t\t\t\tint from = p.se;\n\t\t\t\tdouble cost = p.fi;\n\t\t\t\tif(dist[from] < cost - EPS) continue;\n\t\t\t\tfor(auto& e : es[from]) {\n\t\t\t\t\tint to = e.to;\n\t\t\t\t\tdouble newCost = cost+e.cost;\n\t\t\t\t\tif(dist[to] > newCost + EPS) {\n\t\t\t\t\t\tdist[to] = newCost;\n\t\t\t\t\t\tq.push({dist[to], to});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\tprintf(\"%.15lf\\n\", dist[goal]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <cfloat>\n \nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define eps 10e-5\n#define INF 1e8\n \ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n \n \n#define M INT_MAX\n \n//Point\nstruct P{\n    double x, y;\n    P(){ x=M; y=M;}\n \n    P(const double &s , const double &e)\n    {x=s; y=e;}\n \n    P operator - (const P &t) const\n    { return P(x-t.x , y-t.y);}\n \n    P operator + (const P &t) const\n    { return P(x+t.x , y+t.y); }\n \n    P operator * (const double &d) const\n    { return P(x*d , y*d); }\n};\n \n \n//Line\ndouble dis(P t);\nstruct L{\n    P p1,p2;\n \n    L(){}\n \n    L(const P &s , const P &e)\n        { p1=s; p2=e;}\n    double ldis(){\n        return dis(p1-p2);\n    }\n};\n  \n//Circle\nstruct C{\n    P a;\n    double r;\n    C(){}\n    C(const P &s , const double &e)\n        { a=s; r=e;}\n};\n \n//距離を求める\ndouble dis(P t){\n    return sqrt(t.x*t.x+t.y*t.y);\n}\n \n//単位ベクトルを求める\nP unit_vector(P t){\n    double u=fabs(dis(t));\n    return P(t.x/u , t.y/u);\n}\n \n//外積を求める a×b\ndouble cross(P a,P b){\n    return (a.x*b.y-a.y*b.x);\n}\n \n//線分交差判定\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n    return ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < eps) &&\n           ( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < eps);\n}\n \n//点pを中心としてr(radian)回転       p(0,0)で原点を中心として回転\nP rotate(P t , P p , double r){\n    //double r=radians(angle);\n    double ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n    double tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n    return P(ta , tb);\n}\n  \n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nL interpoint_cc(C a , C b){\n    double di=fabs(dis(a.a-b.a));\n    if(di > a.r+b.r || di < fabs(a.r-b.r)) return L(P(0, 0), P(0, 0));\n    double t=(a.r*a.r-b.r*b.r+di*di)/(di+di);\n    double rd=acos(t/a.r);\n  \n    P dv=unit_vector(b.a-a.a);\n    P g1=rotate(dv , P(0,0) , rd);\n    P g2=rotate(dv , P(0,0) , -rd);\n    return L(a.a+g1*a.r, a.a+g2*a.r);\n}\n \n \nclass State{\npublic:\n        C c;\n    L l;\n        double s1, s2;\n    State(){}\n    State(C cc, L ll){c = cc; l = ll;}\n};\n \n \n \nState dp[110];\n \nbool check(L l, int s, int t){\n    for(s++;s<t;s++) if(!intersect_s(l.p1, l.p2, dp[s].l.p1, dp[s].l.p2))return 0;\n    return 1;\n}\n \n \n \nint main(void){\n    int n;\n    while(cin>>n, n){\n        memset(dp, 0, sizeof(dp));\n        REP(i,110) dp[i].s1 = dp[i].s2 = INF;\n        int x, y;\n        double r;\n        cin >> x >> y >> r;\n        State s = State(C(P(x,y),r), L(P(x,y),P(x,y)));\n        dp[0] = s;\n        dp[0].s1 = dp[0].s2 = 0;\n        for(int i = 1; i < n; i++){\n            cin >>x>>y>>r;\n            C c = C(P(x,y),r);\n            dp[i] = State(c, interpoint_cc(c, dp[i-1].c));\n            REP(k,i){\n                L l1 = L(dp[k].l.p1, dp[i].l.p1);\n                if(dp[k].s1 != INF && check(l1, k, i)){\n                    dp[i].s1 = min(dp[i].s1, dp[k].s1 + l1.ldis());\n                }\n                L l2 = L(dp[k].l.p2, dp[i].l.p1);\n                if(dp[k].s2 != INF && check(l2, k, i)){\n                    dp[i].s1 = min(dp[i].s1, dp[k].s2 + l2.ldis());\n                }\n                l1 = L(dp[k].l.p1, dp[i].l.p2);\n                if(dp[k].s1 != INF && check(l1, k, i)){\n                    dp[i].s2 = min(dp[i].s2, dp[k].s1 + l1.ldis());\n                }\n                l2 = L(dp[k].l.p2, dp[i].l.p2);\n                if(dp[k].s2 != INF && check(l2, k, i)){\n                    dp[i].s2 = min(dp[i].s2, dp[k].s2 + l2.ldis());\n                }\n            }\n        }\n/*\n        REP(i,n){\n        \tprintf(\"%.9f %0.9f\\n\", dp[i].s1, dp[i].s2);\n        }\n*/\n\t\t\t\tREP(k,n){\n            L l1 = L(dp[k].l.p1, dp[n].c.a);\n            if(dp[k].s1 != INF && check(l1, k, n)){\n                dp[n].s1 = min(dp[n].s1, dp[k].s1 + l1.ldis());\n            }\n            L l2 = L(dp[k].l.p2, dp[n].c.a);\n            if(dp[k].s2 != INF && check(l2, k, n)){\n                dp[n].s1 = min(dp[n].s1, dp[k].s2 + l2.ldis());\n            }\n        }\n        printf(\"%.9f\\n\", dp[n].s1);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n    return (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n    return (conj(a)*b).Y;\n}\n// ?????????????????? a->b->c\nint ccw(P a, P b, P c) {\n    b -= a;\tc -= a;\n    //3???????????´???????????????\n    if (cross(b,c) > EPS) return +1;\t// counter clockwise\n    if (cross(b,c) < -EPS) return -1;\t// clockwise\n    //3???????????´???????????????\n    if (dot(b,c) < -EPS) return +2;\t\t// c--a--b on line\n    if (norm(b) < norm(c)) return -2;\t// a--b--c on line or a==b\n    return 0;\t\t\t\t\t\t\t// a--c--b on line or a==c or b==c\n}\n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n    return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n    ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n    VP ps;\n    P ab = b-a;\n    D d = abs(ab);\n    D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n    if (EQ(d, 0) || ar < abs(crL)) return ps;\n    \n    P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n    P cp = a + crL/d * ab;\n    ps.push_back(cp + abN);\n    if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n    return ps;\n}\n\nclass Circle{\npublic:\n    P c;\n    D r;\n    Circle(D x, D y, D r){\n        c = P(x, y);\n        this->r = r;\n    }\n};\n\nclass Edge{\npublic:\n    int to;\n    D cost;\n    Edge(int to, D cost): to(to), cost(cost){};\n};\n\nint N;\nvector<Circle> circles;\nvector<P> points;\n\nD dijkstra(vector<vector<Edge>>& G, int s){\n    int N = G.size();\n    vector<D> d(N, INF);\n    \n    priority_queue<pair<D, int>, vector<pair<D, int>>, greater<pair<D, int>>> q;\n    d[s] = 0;\n    q.push(make_pair(d[s], s));\n    \n    while(!q.empty()){\n        pair<D, int> v = q.top(); q.pop();\n        if(v.first != d[v.second])\n            continue;\n        \n        for(Edge &e: G[v.second]){\n            if(e.cost + d[v.second] < d[e.to]){\n                d[e.to] = e.cost + d[v.second];\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[N-1];\n}\n\nbool check(int a, int b){\n    for(int i=a/2+1; i<b/2; i++){\n        if(!isecSS(points[a], points[b], points[i*2], points[i*2+1]))\n            return false;\n    }\n    return true;\n}\n\nvoid solve(){\n    points.clear();\n    \n    points.push_back(circles[0].c);\n    points.push_back(circles[0].c);\n    for(int i=1; i<N; i++){\n        Circle &c1 = circles[i-1];\n        Circle &c2 = circles[i];\n        auto vp = crosspointCC(c1.c, c1.r, c2.c, c2.r);\n        points.push_back(vp[0]);\n        points.push_back(vp[1]);\n    }\n    points.push_back(circles[N-1].c);\n    points.push_back(circles[N-1].c);\n    \n    vector<vector<Edge>> G(2*N+2);\n    for(int i=0; i<=N; i++){\n        for(int j=i+1; j<=N; j++){\n            for(int k=0; k<2; k++){\n                for(int l=0; l<2; l++){\n                    if(check(i*2+k, j*2+l)){\n                        G[i*2+k].push_back(Edge(j*2+l, abs(points[i*2+k]-points[j*2+l])));\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << dijkstra(G, 0) << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(16);\n    cout.setf(ios::fixed);\n    \n    while (cin>>N, N) {\n        circles.clear();\n        for(int i=0; i<N; i++){\n            D x, y, r; cin >> x >> y >> r;\n            circles.push_back(Circle(x, y, r));\n        }\n        \n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0), inf = 1e20;\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c??????????¨???¨???\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b????????§??´???\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c???????????´???\n\treturn 0;\t\t\t\t\t\t\t// a,c,b???????????´???\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n\nint nct(Circle c1, Circle c2) {\n\tld d = abs(c1.p - c2.p);\n\tld r1 = max(c1.r, c2.r), r2 = min(c1.r, c2.r);\n\tif (d > r1 + r2 + eps) return 4;\n\tif (eq(d, r1 + r2)) return 3;\n\tif (d > r1 - r2 + eps) return 2;\n\tif (eq(d, r1 - r2)) return 1;\n\treturn 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tassert(d != 0.0);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tres.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + eps) return res;\n\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(proj(l, c.p) + len * nor);\n\tres.push_back(proj(l, c.p) - len * nor);\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line s) {\n\tvector<Point> v = is_lc(c, s), res;\n\tfor (size_t k = 0; k < v.size(); k++) {\n\t\tif (ccw(s.a, v[k], s.b) == -2) {\n\t\t\tres.push_back(v[k]);\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) return res;\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back((Line) { p, p + v1 });\n\tif (l < eps) return res;\n\tres.push_back((Line) { p, p + v2 });\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back((Line) { q1, q1 + v });\n\t\tres.push_back((Line) { q2, q2 + v });\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(5);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Circle> cs(n);\n\t\tfor (int i = 0, x, y, r; i < n; i++) {\n\t\t\tcin >> x >> y >> r;\n\t\t\tcs[i] = (Circle) { Point(x, y), r };\n\t\t}\n\t\tvector<Point> pp(n * 2); pp[0] = cs[0].p; pp[n * 2 - 1] = cs[n - 1].p;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tauto v = is_cc(cs[i - 1], cs[i]);\n\t\t\tpp[i * 2 - 1] = v[0];\n\t\t\tpp[i * 2] = v[1];\n\t\t}\n\t\tvector<vector<ld>> dis(n * 2, vector<ld>(n * 2, inf));\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tfor (int j = i + 1; j < n * 2; j++) {\n\t\t\t\tbool can = true;\n\t\t\t\tfor (int k = (i + 1) / 2 + 1; k <= (j + 1) / 2; k++) {\n\t\t\t\t\tif (!isis_ss((Line) { pp[i], pp[j] }, (Line) { pp[k * 2 - 1], pp[k * 2] })) {\n\t\t\t\t\t\tcan = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (can) {\n\t\t\t\t\tdis[i][j] = dis[j][i] = abs(pp[i] - pp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < n * 2; k++) {\n\t\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\t\tfor (int j = 0; j < n * 2; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dis[0][n * 2 - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-7;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n\n\n#include <complex>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle() {;}\n  Circle(Point p, double r) : p(p), r(r) {;}\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\ninline int ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\n\nbool intersectLL(const Line &l, const Line &m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n         abs(cross(l[1] - l[0], m[0] - l[0])) < EPS;\n}\n\nbool intersectLS(const Line &l, const Line &s) {\n  return cross(l[1] - l[0], s[0] - l[0]) *\n         cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nbool intersectSPolygon(const Line &l, const Polygon &P) {\n  for (int i = 0; i < (int)P.size(); i++) {\n    Point A = CURR(P, i), B = NEXT(P, i);\n    if (intersectSS(l, Line(A, B))) { return true; }\n  }\n  return false;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\nPoint reflection(const Line &l, const Point &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distanceLL(const Line &l, const Line &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\ndouble distanceLS(const Line &l, const Line &s) {\n  if (intersectLS(l, s)) { return 0; }\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) { return abs(r - p); }\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) { return 0; }\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nPoint crosspointSS(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) {\n    assert(false);\n    if (intersectSP(l, m[0])) { return m[0]; }\n    if (intersectSP(l, m[1])) { return m[1]; }\n    if (intersectSP(m, l[0])) { return l[0]; }\n    if (intersectSP(m, l[1])) { return l[1]; }\n    return m[0];\n  }\n  if (abs(A) < EPS) { assert(false); }\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<Point> crosspointLC(const Line &l, const Circle &c) {\n  vector<Point> ret;\n  Point center = projection(l, c.p);\n  double d = abs(center - c.p);\n  double t = sqrt(c.r * c.r - d * d);\n  if (isnan(t)) { return ret; }\n  Point vect = (l[1] - l[0]);\n  vect /= abs(vect);\n  ret.push_back(center - vect * t);\n  if (t > EPS) {\n    ret.push_back(center + vect * t);\n  }\n  return ret;\n}\n\nvector<Point> crosspointSC(const Line &s, const Circle &c) {\n  vector<Point> ret;\n  vector<Point> nret = crosspointLC(s, c);\n  for (int i = 0; i < (int)nret.size(); i++) {\n    if (intersectSP(s, nret[i])) { ret.push_back(nret[i]); }\n  }\n  return ret;\n}\n\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n  vector<Point> ret;\n  double d = abs(c1.p - c2.p);\n  if (max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) { return ret; }\n  double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  Point start = c1.p + (c2.p - c1.p) / d * x;\n  Point vect = (c1.p - c2.p) * Point(0.0, 1.0);\n  return crosspointLC(Line(start, start + vect), c1);\n}\n\n\ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.8f \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n  const int n = g.size();\n  vector<bool> visit(n, false);\n  Array dist(n, 2000000000LL);\n  priority_queue<Edge> que;\n  que.push(Edge(s, s, 0));\n  Weight ans = -1;\n  dist[s] = 0;\n  while (!que.empty()) {\n    Edge edge = que.top();\n    que.pop();\n    int from = edge.dest;\n    if (visit[from]) { continue; }\n    visit[from] = true;\n    if (from == t) {\n      ans = edge.weight;\n      break;\n    }\n    for (int i = 0; i < (int)g[from].size(); i++) {\n      int to = g[from][i].dest;\n      Weight ncost = edge.weight + g[from][i].weight;\n      if (visit[to] || ncost >= dist[to] - EPS) { continue; }\n      dist[to] = ncost;\n      que.push(Edge(from, to, ncost));\n    }\n  }\n  return ans;\n}\n\nint n, m;\nvector<Circle> cs;\nvector<Point> ps;\n\nint main(int argc, char *argv[]) {\n  while (scanf(\"%d\", &n), n) {\n    m = 0;\n    cs.clear();\n    ps.clear();\n    REP(i, n) {\n      double x, y, r;\n      scanf(\"%lf %lf %lf\", &x, &y, &r);\n      cs.push_back(Circle(Point(x, y), r));\n    }\n    ps.push_back(cs[0].p);\n    ps.push_back(cs[n - 1].p);\n    REP(i, n) {\n      REP(j, i) {\n        vector<Point> nret = crosspointCC(cs[i], cs[j]);\n        FORIT(it, nret) { ps.push_back(*it); }\n      }\n    }\n    m = ps.size();\n    Graph g(m);\n    REP(j, m) {\n      REP(i, j) {\n        Line l(ps[i], ps[j]);\n        double d = abs(ps[i] - ps[j]);\n        int cnt = 0;\n        vector<pair<double, int> > events;\n        events.push_back(make_pair(EPS, 2));\n        events.push_back(make_pair(d - EPS, 0));\n        REP(k, n) {\n          vector<Point> nret = crosspointSC(l, cs[k]);\n          if (nret.size() == 0) {\n            continue;\n          } else if (nret.size() == 1) {\n            double d1 = abs(ps[i] - nret[0]);\n            if (abs(ps[i] - cs[k].p) - cs[k].r <= EPS) {\n              cnt++;\n              events.push_back(make_pair(d1 + EPS, -1));\n            } else {\n              events.push_back(make_pair(d1 - EPS, 1));\n            }\n          } else if (nret.size() == 2) {\n            double d1 = abs(ps[i] - nret[0]);\n            double d2 = abs(ps[i] - nret[1]);\n            if (d1 > d2) { swap(d1, d2); }\n            events.push_back(make_pair(d1 - EPS, 1));\n            events.push_back(make_pair(d2 + EPS, -1));\n          }\n        }\n        sort(events.begin(), events.end());\n        int begin = 0;\n        FORIT(it, events) {\n          if (begin && cnt == 0) { goto next; }\n          if (it->second == 0) { break; }\n          if (it->second == 2) { begin = 1; continue; }\n          if (it->second == 1) {\n            cnt++;\n          } else if (it->second == -1) {\n            cnt--;\n          }\n        }\n        g[i].push_back(Edge(i, j, d));\n        g[j].push_back(Edge(j, i, d));\nnext:;\n      }\n    }\n    double ans = Dijkstra(g, 0, 1);\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-6\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n    //return a.Y < b.Y;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) return CCW; // ccw\n  if (cross(b, c) < -EPS) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  if (s[0] > s[1]) swap(s[0], s[1]);\n  for (Point p : res) {\n    if (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nLine CapCS(Circle c, Line s) {\n  Point inf(INF, INF);\n  vector<Point> cros = CrossPointCS(c, s);\n  if (cros.empty()) return Line{inf, inf};\n\n  if (cros.size() == 1) {\n    double ad = abs(s[0]-c.c);\n    double bd = abs(s[1]-c.c);\n    if (ad <= min(bd, c.r)) cros.push_back(s[0]);\n    else if (bd <= min(ad, c.r)) cros.push_back(s[1]);\n    else { \n      Point p = cros[0];\n      cros.push_back(p); // avoid an undefined behavior\n    }\n  }\n\n  if (cros[1] < cros[0]) {\n    swap(cros[0], cros[1]);\n  }\n  \n  return Line{cros[0], cros[1]};\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nGeometory ContainsPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\nint n;\nCircle cs[114514];\ndouble mind[400][400];\nvector<Point> ps;\n\ntypedef pair<Point, int> Event;\nvector<Event> es;\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    ps.clear();\n    for (int i=0; i<n; i++) {\n      int x, y;\n      double r;\n      scanf(\"%d%d%lf\", &x, &y, &r);\n      cs[i] = Circle{Point(x, y), r};\n      ps.push_back(cs[i].c);\n    }\n  \n    for (int i=1; i<n; i++) {\n      vector<Point> cros = CrossPointCC(cs[i-1], cs[i]);\n      assert (cros.size() == 2);\n      ps.push_back(cros[0]);\n      ps.push_back(cros[1]);\n    }\n  \n    int m = ps.size();\n    for (int i=0; i<m; i++) for (int j=0; j<m; j++) mind[i][j] = INF;\n    for (int i=0; i<m; i++) {\n      mind[i][i] = 0;\n      for (int j=i+1; j<m; j++) {\n        es.clear();\n\n        for (int k=0; k<n; k++) {\n          Line s = CapCS(cs[k], Line{ps[i], ps[j]});\n          if (::isinf(s[0].X)) continue;\n          //if (EQ(s[0], s[1])) continue;\n          es.push_back(Event(s[0], -1));\n          es.push_back(Event(s[1], +1));\n  \n          Vec v1 = ps[i]-cs[k].c;\n          Vec v2 = ps[j]-cs[k].c;\n          if (EQ(abs(v1), cs[k].r) && EQ(abs(v2), cs[k].r)) {\n            double ar = abs(arg(v2/v1)) * cs[k].r;\n            double g = min(mind[i][j], ar);\n            mind[i][j] = mind[j][i] = g;\n          }\n        }\n  \n        sort(es.begin(), es.end());\n        int cnt = 0;\n        bool fail = false;\n        Point lim = Point(-INF, -INF);\n        for (int idx=0; idx<es.size(); idx++) {\n          Event &e = es[idx];\n          Point p = e.first;\n          if (idx == 0 && !EQ(p, min(ps[i], ps[j]))) {\n            fail = true;\n            break;\n          }\n\n          cnt += e.second;\n          lim = max(lim, p);\n          if (cnt > 0 || (cnt == 0 && idx < es.size()-1)) {\n            fail = true;\n            break;\n          }\n        }\n        if (!es.empty() && !EQ(lim, max(ps[i], ps[j]))) fail = true;\n  \n        if (!fail) {\n          mind[i][j] = mind[j][i] = abs(ps[i]-ps[j]);\n        }\n      }\n    }\n  \n    for (int k=0; k<m; k++) {\n      for (int i=0; i<m; i++) {\n        for (int j=0; j<m; j++) {\n          mind[i][j] = min(mind[i][j], mind[i][k]+mind[k][j]);\n        }\n      }\n    }\n  \n    printf(\"%.10f\\n\", mind[0][n-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nbool isCrossed(complex<double> p1, complex<double> p2, complex<double> p3, complex<double> p4) {\n    if ( ((p1.real() - p2.real()) * (p3.imag() - p1.imag()) + (p1.imag() - p2.imag()) * (p1.real() - p3.real())) *\n            ((p1.real() - p2.real()) * (p4.imag() - p1.imag()) + (p1.imag() - p2.imag()) * (p1.real() - p4.real())) > 0)\n        return false;\n    return true;\n}\n\nint main() {\n    int N = 0;\n    while (cin>>N && N) {\n        vector<pair<complex<double>, double> > circles(N);\n        complex<double> centerize;\n        for (int n = 0; n < N; n++) {\n            int x,y,r;\n            cin>>x>>y>>r;\n            if (n == 0) {\n                centerize = complex<double>(x,y);\n                circles[n] = make_pair(complex<double>(0.0, 0.0), (double)r);\n            }\n            circles[n] = make_pair(complex<double>(x,y)-centerize, (double)r);\n        }\n\n        vector<complex<double> > vertices(2 * N);\n        vertices[0] = circles[0].first;\n        vertices[1] = circles[N-1].first;\n        for (int n = 0; n < N-1; n++) {\n            complex<double> v = circles[n+1].first - circles[n].first;\n            double a = atan2(v.imag(), v.real());\n            double theta = acos((norm(v) + circles[n].second*circles[n].second - circles[n+1].second*circles[n+1].second)\n                / (2 * abs(v) * circles[n].second));\n            vertices[2+2*n] = complex<double>(circles[n].second * cos(a+theta), circles[n].second * sin(a+theta)) + circles[n].first;\n            vertices[3+2*n] = complex<double>(circles[n].second * cos(a-theta), circles[n].second * sin(a-theta)) + circles[n].first;\n            /*\n            double a = (v.real()*v.real()+v.imag()*v.imag()+circles[n].second*circles[n].second-circles[n+1].second*circles[n+1].second) / 2.0;\n            double x1 = ( a*v.real() + v.imag()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double y1 = ( a*v.imag() - v.real()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double x2 = ( a*v.real() - v.imag()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double y2 = ( a*v.imag() + v.real()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            vertices[2+2*n] = complex<double>(x1,y1);\n            vertices[3+2*n] = complex<double>(x2,y2);*/\n        }\n\n        multimap<int, pair<int, double> > ds;\n        for (int n = 0; n < N; n++) {\n            for (int s = 0; s < 2; s++) {\n                for (int i = n+1; i < N+1; i++) {\n                    for (int t = 0; t < 2; t++) {\n                        if (i != N) {\n                            bool flag = true;\n                            for (int u = n+1; u < i; u++) {\n                                if (!(isCrossed(vertices[2*n+s], vertices[2*i+t], vertices[2*u], vertices[2*u+1]) &&\n                                        isCrossed(vertices[2*u], vertices[2*u+1], vertices[2*n+s], vertices[2*i+t]))) {\n                                    flag = false;\n                                    break;\n                                }\n                            }\n                            if (flag) ds.insert(make_pair(2*n+s, make_pair(2*i+t, (double)abs(vertices[2*i+t] - vertices[2*n+s]))));\n                        } else {\n                            bool flag = true;\n                            for (int u = n+1; u < i; u++) {\n                                if (!(isCrossed(vertices[2*n+s], vertices[1], vertices[2*u], vertices[2*u+1]) &&\n                                        isCrossed(vertices[2*u], vertices[2*u+1], vertices[2*n+s], vertices[1]))) {\n                                    flag = false;\n                                    break;\n                                }\n                            }\n                            if (flag) ds.insert(make_pair(2*n+s, make_pair(1, (double)abs(vertices[1] - vertices[2*n+s]))));\n                            break;\n                        }\n                    }\n                }\n                if (n == 0) break;\n            }\n        }\n\n        priority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > pqueue;\n        double finalDs[1000] = {};\n        for (int n = 0; n < N; n++) {\n            finalDs[2*n] = -1.0;\n            finalDs[2*n+1] = -1.0;\n        }\n\n        pqueue.push(make_pair(0.0, 0));\n        while (!pqueue.empty()) {\n            auto p = pqueue.top();\n            pqueue.pop();\n            if (finalDs[p.second] < 0.0) finalDs[p.second] = p.first;\n            else continue;\n\n            auto it = ds.lower_bound(p.second);\n            auto last = ds.upper_bound(p.second);\n            for (; it != last; it++) {\n                pqueue.push(make_pair(p.first+it->second.second, it->second.first));\n            }\n        }\n        cout<<finalDs[1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\n\nconst double EPS=1e-8,INF=1e12;\ntypedef complex<double> P;\ntypedef P point;\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);}\n}\ndouble cross(const P &a,const P &b){\n  return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n  return real(conj(a)*b);\n}\n\nstruct L :public vector<P>{\n  L(const P &a,const P &b){\n    pb(a); pb(b);\n  }\n};\n\ntypedef pair<point,point> ppp;\n\nint ccw(P a,P b,P c){\n  b-=a; c-=a;\n  if(cross(b,c)>EPS) return 1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c)<-EPS) return +2;\n  if(norm(b)+EPS<norm(c)) return -2;\n  return 0;\n}\n\nppp c_c_inter(const point &c1,const double &r1,\n\t      const point &c2,const double &r2){\n  point A=conj(c2-c1), B=(r2*r2-r1*r1-(c2-c1)*conj(c2-c1)),C=r1*r1*(c2-c1);\n  point D=B*B-4.*A*C;\n  point z1=(-B+sqrt(D))/(2.0*A)+c1, z2=(-B-sqrt(D))/(2.*A)+c1;\n  return ppp(z1,z2);\n}\n\nbool interLS(const L &l,const L s){\n  return cross(l[1]-l[0], s[0]-l[0])*\n    cross(l[1]-l[0],s[1]-l[0])<EPS;\n}\n\ndouble len(const L &l){\n  return abs(l[0]-l[1]);\n}\ndouble d[112][112];\n\nint main(){\n  cout<<fixed<<setprecision(10);\n  int n;\n  while(cin>>n){\n    vector<P> c(n);\n    vector<double> r(n);\n    double x,y;\n    rep(i,n){\n      cin>>x>>y>>r[i];\n      c[i]=P(x,y);\n    }\n    vector<ppp> ps(n-1);\n    rep(i,n-1)\n      ps[i]=c_c_inter(c[i],r[i],c[i+1],r[i+1]);\n\n    fill(d[0],d[0]+112*112,INF);\n    rep(i,n-1){\n      L lx(c[0],ps[i].X),ly(c[0],ps[i].Y);\n      int fx=1,fy=1;\n      rep(j,i){\n\tfx&=interLS(lx,L(ps[j].X,ps[j].Y));\n\tfy&=interLS(ly,L(ps[j].X,ps[j].Y));\n      }\n      if(fx)d[2*n-2][2*i]=d[2*i][2*n-2]=len(lx);\n      if(fy)d[2*n-2][2*i+1]=d[2*i+1][2*n-2]=len(ly);\n    }\n    rep(i,n-1){\n      L lx(c[n-1],ps[i].X),ly(c[n-1],ps[i].Y);\n      int fx=1,fy=1;\n      for(int j=i;j<n-1;++j){\n\tfx&=interLS(lx,L(ps[j].X,ps[j].Y));\n\tfy&=interLS(ly,L(ps[j].X,ps[j].Y));\n      }\n      if(fx)d[2*n-1][2*i]=d[2*i][2*n-1]=len(lx);\n      if(fy)d[2*n-1][2*i+1]=d[2*i+1][2*n-1]=len(ly);\n    }\n    L l(c[0],c[n-1]);\n    int f=1;\n    rep(i,n-1)\n      f&=interLS(l,L(ps[i].X,ps[i].Y));\n    if(f) d[2*n-1][2*n-2]=d[2*n-2][2*n-1]=len(l);\n    rep(i,n-1)rep(j,i)rep(a,2)rep(b,2){\n      L l(a?ps[i].Y:ps[i].X,b?ps[j].Y:ps[j].X);\n      int f=1;\n      for(int k=j+1;k<i;++k)\n\tf&=interLS(l,L(ps[k].X,ps[k].Y));\n      if(f)\n\td[2*i+a][2*j+b]=d[2*j+b][2*i+a]=len(l);\n    }\n    rep(k,2*n)rep(i,2*n)rep(j,2*n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    cout<<d[2*n-1][2*n-2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\n\ntypedef complex < double > P;\ntypedef line               L;\ntypedef vector< L >        LLL;\ntypedef vector< P >        Ps;\ntypedef circle             C;\nconst double EPS = 1e-9;\nconst double INF = 1e8;\n\ndouble cross( P a, P b){\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){\n  return real( conj(a) * b);\n}\nint ccw( P a, P b, P c){\n  b -= a, c -= a;\n  if(cross(b,c) > EPS)    return 1;  // a → b で 時計方向におれて c\n  if(cross(b,c) < -EPS)    return -1; // a → b で 反時計方向におれて c\n  if(dot(b,c) < -EPS)      return 2;  // c -- a -- b\n  if(norm(b) < norm(c) - EPS) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nPs crosspoint(C c1, C c2){\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  Ps ret;\n  ret.push_back( c1.p + m * v + h * v * P(0,1));\n  ret.push_back( c1.p + m * v - h * v * P(0,1));\n  return ret;\n}\nstruct dC{\n  double cost;\n  P pos;\n  int nowi,nowj;\n  bool operator < (const dC &left) const {\n    return cost > left.cost;\n  }\n};\nL make_2_cross(C c1, C c2){\n  Ps a(crosspoint( c1, c2));\n  return L( a[0], a[1]);\n}\n\nint main(){\n  C prev, now;\n  int n;\n\n  while(cin >> n , n){\n    LLL ls;\n\n    cin >> prev.p.real() >> prev.p.imag() >> prev.r;\n    ls.push_back( L( prev.p, prev.p));\n\n    for(int i = 1 ; i < n ; i++ ){\n      cin >> now.p.real() >> now.p.imag() >> now.r;\n      ls.push_back( make_2_cross( prev, now));\n      prev = now;\n    }\n    ls.push_back( L( prev.p, prev.p)); // G\n\n    priority_queue< dC > que;\n    que.push((dC){ 0, ls[0][0], 0, 0});\n    bool used[101][2] = {{}};\n    double ret = INF;\n    while(!que.empty()){\n      dC p = que.top();\n      que.pop();\n      if(p.nowj == n){\n        ret = p.cost;\n        break;\n      }\n      if(used[p.nowj][p.nowi]++) continue;\n      for(int i = 0 ; i < 2 ; i++ ){\n        for(int j = p.nowj + 1 ; j <= n ; j++ ){\n          L l = L( p.pos, ls[j][i]);\n\n          bool flag = true;\n          for(int k = j - 1 ; k > p.nowj ; k-- ){\n            if(!intersect( l, ls[k])){\n              flag = false;\n              break;\n            }\n          }\n          if(flag) que.push( (dC){ abs( l[0] - l[1]) + p.cost, l[1], i, j});\n        }\n      }\n    }\n    cout << fixed << setprecision(7) << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-5;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// AOJ 1183 鎖中経路\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-10;\nconst double inf=1e12;\nconst double PI=acos(-1);\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nstruct C{\n  P p;\n  double r;\n  C(const P& p,double r):p(p),r(r){}\n};\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\nbool intersectSS(const L& s,const L& t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\ndouble distanceSP(const L& s,const P& p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\n\ndouble d[333];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int n;\n    vector<C> cs;\n    vector<P> ps;\n    cin>>n;\n    if(n==0)break;\n    rep(i,n){\n      double x,y,r;\n      cin>>x>>y>>r;\n      cs.pb(C(P(x,y),r));\n    }\n    ps.push_back(cs[0].p);\n    rep(i,n-1){\n      double x1=x(cs[i+1].p)-x(cs[i].p),y1=y(cs[i+1].p)-y(cs[i].p);\n      double r1=cs[i].r,r2=cs[i+1].r;\n      double a=(x1*x1+y1*y1+r1*r1-r2*r2)/2.0;\n      double xx1=((a*x1+y1*sqrt((x1*x1+y1*y1)*r1*r1-a*a))/(x1*x1+y1*y1))+x(cs[i].p);\n      double xx2=((a*x1-y1*sqrt((x1*x1+y1*y1)*r1*r1-a*a))/(x1*x1+y1*y1))+x(cs[i].p);\n      double yy1=((a*y1-x1*sqrt((x1*x1+y1*y1)*r1*r1-a*a))/(x1*x1+y1*y1))+y(cs[i].p);\n      double yy2=((a*y1+x1*sqrt((x1*x1+y1*y1)*r1*r1-a*a))/(x1*x1+y1*y1))+y(cs[i].p);\n      ps.push_back(P(xx1,yy1));\n      ps.push_back(P(xx2,yy2));\n    }\n    ps.push_back(cs[n-1].p);\n    rep(i,333)d[i]=inf;\n    d[0]=0;\n    int m=ps.size();\n    rep(i,m)repl(j,i+i%2+1,m){\n      // i->j\n      bool ok=true;\n      repl(k,(i%2==0?i-1:i),(j%2==0?j:j+1)){\n        if(!intersectSS(L(ps[k],ps[k+1]),L(ps[i],ps[j])))ok=false;\n        k++;\n      }\n      if(ok){\n        minch(d[j],d[i]+abs(ps[i]-ps[j]));\n      }\n    }\n    printf(\"%.10f\\n\", d[m-1]);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(){ }\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//線分x線分交差判定\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n\nclass State{\npublic:\n\tdouble sum;\n\tint t,s;\n\tP cur;\n\tState(){}\n\tState(double c, int a, int b, P p):sum(c),t(a),s(b),cur(p){}\n\tbool operator < (const State &opp)const{\n\t\treturn sum > opp.sum;\n\t}\n};\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nP rotate(P t , P p , double r){\n\tdouble ta=cos(r)*real(t-p)-sin(r)*imag(t-p)+real(p);\n\tdouble tb=sin(r)*real(t-p)+cos(r)*imag(t-p)+imag(p);\n\treturn P(ta , tb);\n}\n\n\n//単位ベクトルを求める\nP unit_vector(P t){\n\treturn t/fabs(abs(t));\n}\n\n//２円 |x-a|=raと|x-b|=rbの交点計算\nL interpointCC(C a , C b){\n\tdouble di=fabs(abs(a.p-b.p));\n\tif(di > a.r+b.r || di < fabs(a.r-b.r)) return L(P(0, 0), P(0, 0));\n\tdouble t=(a.r*a.r-b.r*b.r+di*di)/(di+di);\n\tdouble rd=acos(t/a.r);\n\n\tP dv=unit_vector(b.p-a.p);\n\tP g1=rotate(dv , P(0,0) , rd);\n\tP g2=rotate(dv , P(0,0) , -rd);\n\treturn L(a.p+g1*a.r, a.p+g2*a.r);\n}\n\ndouble dp[101][2];\nint v[101][2];\nvector <L> Lines;\n\nbool check(L l, int s, int t){\n\tfor(;s<t;s++) if(!intersectSS(l, Lines[s]))return 0;\n\treturn 1;\n}\n\nmain(){\n\tint i,j,n;\n\n\twhile(cin>>n, n){\n\t\tpriority_queue<State> S;\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor(i=0;i<=100;i++) dp[i][0] = dp[i][1] = INF;\n\t\tLines.clear();\n\t\tC Prev, Now;\n\t\tdouble x, y, r;\n\t\tcin >> x >> y >> r;\n\t\tNow = C(P(x, y), r);\n\t\tP Start = Now.p;\n\t\tLines.push_back(L(Start, Start));\n\t\tfor(i=1;i<n;i++){\n\t\t\tPrev = Now;\n\t\t\tcin >> x >> y >> r;\n\t\t\tNow = C(P(x, y), r);\n\t\t\tLines.push_back(interpointCC(Now, Prev));\n\t\t}\n\t\tLines.push_back(L(Now.p, Now.p));\n\t\tS.push(State(0, 0, 0, Start));\n\t\twhile(!S.empty()){\n\t\t\tState t = S.top();S.pop();\n\t\t\tif(v[t.t][t.s]) continue;\n\t\t\tv[t.t][t.s] = 1;\n\t\t\tif(t.t == n) break;\n\t\t\tfor(i=t.t+1;i<=n;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\tif(v[i][j]) continue;\n\t\t\t\t\tL l = L(t.cur, (j?Lines[i][1]:Lines[i][0]));\n\t\t\t\t\tif(!check(l, t.t+1, i)) continue;\n\t\t\t\t\tif(dp[i][j] < abs(l[1]-l[0]) + t.sum) continue;\n\t\t\t\t\tdp[i][j] = abs(l[1]-l[0]) + t.sum;\n\t\t\t\t\tS.push(State(dp[i][j], i, j, l[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\", dp[n][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* 解答時間→ 101:22(途中) */\n#include <math.h>\n#include <iomanip>\n#include <iostream>\t\t//基本入出力\nusing namespace std;\n\ndouble dist2d(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main(){\n\tcout << setprecision(16);\n\twhile(1){\n\t\t//入力\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tdouble x[25],y[25],r[25];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\t\tint V = n * 2;\n\t\tdouble pos_x[50], pos_y[50];\n\t\tpos_x[0] = x[0];\n\t\tpos_y[0] = y[0];\n\t\tpos_x[V - 1] = x[n - 1];\n\t\tpos_y[V - 1] = y[n - 1];\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tdouble d = sqrt(1.0 * (x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1]));\n\t\t\tdouble a = (d * d + r[i] * r[i] - r[i + 1] * r[i + 1]) / (d * 2);\n\t\t\tdouble b = sqrt(-a * a + r[i] * r[i]);\n\t\t\tdouble va_x = a * (x[i + 1] - x[i]) / d, va_y = a * (y[i + 1] - y[i]) / d;\n\t\t\tdouble vb_x = b * (y[i] - y[i + 1]) / d, vb_y = b * (x[i + 1] - x[i]) / d;\n\t\t\tpos_x[i * 2 + 1] = va_x + vb_x + x[i];\n\t\t\tpos_y[i * 2 + 1] = va_y + vb_y + y[i];\n\t\t\tpos_x[i * 2 + 2] = va_x - vb_x + x[i];\n\t\t\tpos_y[i * 2 + 2] = va_y - vb_y + y[i];\n\t\t}\n\t\t//総当りで距離を計算\n\t\tdouble dist[50][50];\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tdist[i][j] = DBL_MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < V - 1; i++){\n\t\t\tfor(int j = i + 1; j < V; j++){\n\t\t\t\t//交差判定(準備)\n\t\t\t\tint flg = 1;\n\t\t\t\tdouble x1, y1, x2, y2, x3, y3, x4, y4;\n\t\t\t\tx1 = pos_x[i];\n\t\t\t\ty1 = pos_y[i];\n\t\t\t\tx2 = pos_x[j];\n\t\t\t\ty2 = pos_y[j];\n\t\t\t\tint pos_ls, pos_lg;\n\t\t\t\tif(i == 0)\n\t\t\t\t\tpos_ls = 1;\n\t\t\t\telse\n\t\t\t\t\tpos_ls = (i + 1) / 2 + 1;\n\t\t\t\tif(j == V - 1)\n\t\t\t\t\tpos_lg = n - 1;\n\t\t\t\telse\n\t\t\t\t\tpos_lg = (j + 1) / 2 - 1;\n\t\t\t\t//交差判定(本番)\n\t\t\t\tdouble ta, tb, tc, td;\n\t\t\t\tfor(int k = pos_ls; k <= pos_lg; k++){\n\t\t\t\t\tx3 = pos_x[k * 2 - 1];\n\t\t\t\t\ty3 = pos_y[k * 2 - 1];\n\t\t\t\t\tx4 = pos_x[k * 2];\n\t\t\t\t\ty4 = pos_y[k * 2];\n\t\t\t\t\tta = (x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\t\t\t\ttb = (x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\t\t\t\ttc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\t\t\t\ttd = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\t\t\tif((tc*td>=0.0)||(ta*tb>=0.0)){\n\t\t\t\t\t\tflg=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg == 1){\n\t\t\t\t\tdist[i][j] = dist2d(pos_x[i], pos_y[i], pos_x[j], pos_y[j]);\n\t\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ワーシャル・フロイド法\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j])\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tcout << dist[0][V - 1] << \"\\n\";\n\t}\n\tcout << flush;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n// #define EPS 1e-8\n// static const int INF=1<<24;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = asin(0.5)*6;\n\ntypedef complex<double> P;\n\n#define X real()\n#define Y imag()\n\n#define Curr(P,i) P[(i)%P.size()]\n#define Next(P,i) P[(i+1)%P.size()]\n#define Prev(P,i) P[(i+P.size()-1)%P.size()]\n\nnamespace std{\n  bool operator<(const P a,const P b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\ndouble cross(const P a,const P b){\n  return (conj(a)*b).imag();\n}\ndouble dot(const P a,const P b){\n  return (conj(a)*b).real();\n}\n// TODO make graph (20)\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)>0)    return +1;//counter clockwise\n  if(cross(b,c)<0)    return -1;//clockwise\n  if(dot(b,c)<0)      return +2;// c--a--b\n  if(norm(b)<norm(c)) return -2;// a--b--c\n                      return  0;// a--c--b(or b==c)\n}\n\nstruct L : public vector<P>{\n  L(){}\n  L(const P a,const P b){\n    push_back(a),push_back(b);\n  }\n};\ntypedef L S;\ntypedef vector<P> G;\n\nstruct C{\n  P p;double r;\n  C(){}\n  C(const P p,double r): p(p),r(r){}\n};\n\n\n\n//直線と点の関係\n//点から線分に垂線を下ろした点\nP projection(L a,P p){\n  double t = dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n  return a[0] + t*(a[0]-a[1]);\n}\n//線対称の点\nP reflection(L a,P p){\n  return p + 2.0 * (projection(a,p)-p);\n}\n\n\n\n\n//交差判定\n//TODO CP(内包) CL CS (0)\nbool isCrossLL(L a,L b){\n  return \n    abs(cross(a[1]-a[0],b[1]-b[0])) > EPS\n    || abs(cross(a[1]-a[0],b[0]-a[0])) < EPS ;\n}\nbool isCrossLS(L a,S b){\n  return \n    cross(a[1]-a[0],b[0]-a[0]) \n    * cross(a[1]-a[0],b[1]-a[0]) < EPS;\n}\nbool isCrossLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool isCrossSS(S a,S b){\n  return\n    ccw(a[0],a[1],b[0])\n    * ccw(a[0],a[1],b[1]) <= 0\n    &&\n    ccw(b[0],b[1],a[0])\n    * ccw(b[0],b[1],a[1]) <= 0;\n}\nbool isCrossSP(S a,P p){\n  return abs(a[0]-p)+abs(a[1]-p)-abs(a[0]-a[1]) < EPS;\n}\n\n\n// 距離 CP CL CS は(distXP(x,c.p)-c.r)\ndouble distPP(P a,P b){\n  return abs(a-b);\n}\ndouble distLP(L a,P p){\n  return abs(p-projection(a,p));\n}\ndouble distLL(L a,L b){\n  return isCrossLL(a,b) ? 0 : distLP(a,b[0]);\n}\ndouble distLS(L a,S b){\n  return isCrossLS(a,b) ? 0 : min(distLP(a,b[0]),distLP(a,b[1]));\n}\ndouble distSP(S a,P p){\n  const P r = projection(a,p);\n  return isCrossSP(a,r) ? abs(p-r) : min(abs(a[0]-p),abs(a[1]-p));\n}\ndouble distSS(S a,S b){\n  return isCrossSS(a,b)?0:\n    min(\n      min(distSP(a,b[0]),distSP(a,b[1])),\n      min(distSP(b,a[0]),distSP(b,a[1]))\n    );\n}\n\n//円の交差判定\nbool isCrossCP(C a,P p){\n  return abs(a.p-p)-a.r<=EPS;\n}\nbool isCrossCL(C a,L l){\n  return distLP(l,a.p)-a.r<EPS;\n}\ndouble distSP_MAX(S a,P p){\n  return max(abs(a[0]-p),abs(a[1]-p));\n}\nbool isCrossCS(C a,S s){\n  return distSP(s,a.p)-a.r<-EPS&&distSP_MAX(s,a.p)-a.r>+EPS;\n}\nbool isCrossCC(C a,C b){//接してる時は交差\n  return abs(a.p-b.p)-(a.r+b.r) <= EPS;\n}\n\n\n//交差点\n//先に交差判定をすること\nP crossP_LL(L a,L b){\n  double A = cross(a[1]-a[0],b[1]-b[0]);\n  double B = cross(a[1]-a[0],a[1]-b[0]);\n  if(abs(A)<EPS && abs(B)<EPS)return b[0];\n  if(abs(A)<EPS)assert(false);\n  return b[0]+B/A*(b[1]-b[0]);\n}\nvector<P> crossP_CL(C c,L l){\n  P tmp = projection(l,c.p);\n  P e = (l[0]-l[1])/abs(l[0]-l[1]);\n  double h = abs(c.p-tmp)*abs(c.p-tmp);\n  double t = sqrt(c.r*c.r - h*h);\n  if(t<EPS)return {tmp};\n  return {tmp + e*t,tmp - e*t};\n}\nvector<P> crossP_CC(C a,C b){\n  P A = conj(b.p-a.p);\n  P B = (b.r*b.r - a.r*a.r - (b.p-a.p)*conj(b.p-a.p));\n  P C = a.r*a.r*(b.p-a.p);\n  P D = B*B-4.0*A*C;\n  P z1 = (-B+sqrt(D))/(2.0*A)+a.p;\n  P z2 = (-B-sqrt(D))/(2.0*A)+a.p;\n  return {z1,z2};\n}\n\n\n\n//三点->円\nP PPPtoC(P a,P b,P c){\n  P x = 1.0/(conj(b-a));\n  P y = 1.0/(conj(c-a));\n  return (y-x)/( conj(x)*y - x*conj(y) ) + a;\n}\n\n//凸包\nG convex_hull(G ps){\n  int n = ps.size();\n  int k = 0;\n  G ch(2*n);\n  for(int i = 0;i<n;(ch[k++]=ps[i++])){\n    while(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  for(int i = n-2,t=k+1 ; i>=0 ; ch[k++]=ps[i--]){\n    while(k>=t && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch;\n} \n\n\n//凸性判定\nbool isConvex(G g){\n  for(int i=0; i<g.size();i++){\n    if(ccw(Prev(g,i),Curr(g,i),Next(g,i))>0)return false;\n  }\n}\n\n\n\n//接線\n//TODO check\nvector<L> TLine_CP(C c,P p){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P n2 = reflection(L(p,c.p),n1);\n  return {L(p,n1),L(p,n2)};\n}\n\n// TLine CC\nvector<L> TLine_CPr(C c,P p,double r){\n  P v = c.p - p;\n  double t = asin(abs(c.r)/(abs(v)));\n  P e = v/abs(v) * exp(P(.0,t));\n  P n1 = sqrt(abs(v)*abs(v) - c.r*c.r)*e + p;\n  P e1 = (n1-c.p)/abs(n1-c.p) * r;\n  P n2 = reflection(L(p,c.p),n1);\n  P e2 = (n2-c.p)/abs(n2-c.p) * r;\n  return {L(p+e1,n1+e1),L(p+e2,n2+e2)};\n}\nvector<L> TLine_CC(C a,C b){\n  //接してる時がヤバイ\n  vector<L> res;\n  if(!isCrossCC(a,b)&&(abs(a.r)>EPS)&&(abs(b.r>EPS))){\n    P tmp = (a.p-b.p)*(b.r)/(a.r+b.r) + b.p;\n    auto t1 = TLine_CP(a,tmp);\n    auto t2 = TLine_CP(b,tmp);\n    res.push_back(L(t1[0][1],t2[0][1]));\n    res.push_back(L(t1[1][1],t2[1][1]));\n  }\n  if(abs(a.r-b.r)<EPS){\n    const auto r = a.r;\n    P e = (a.p-b.p)/abs(a.p-b.p) * exp(P(.0,90.0/180.0*PI));\n    res.push_back(L(a.p+(e*r),b.p+(e*r)));\n    if(abs(r)>=EPS)res.push_back(L(a.p-(e*r),b.p-(e*r)));\n  }else{\n    if(a.r<b.r)swap(a,b);\n    auto t3 = TLine_CPr(C(a.p,a.r-b.r),b.p,b.r);\n    for(auto i:t3){\n      res.push_back(i);\n    }\n  }\n  return res;\n}\n\n//原点を起点とした回転\nP rotate(P a,double r){\n  return a*exp(P(0.0,r*PI/180.0));\n}\n\ndouble dp[110][2];\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C> cir(n);\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b>>cir[i].r;\n      cir[i].p=P(a,b);\n      // cout<<cir[i].p.X<<\" \"<<cir[i].p.Y<<\" \"<<cir[i].r<<endl;\n\t\t}\n    VV(P) po;\n    po.PB(vector<P>(1,cir[0].p));\n    rep(i,n-1){\n      po.PB(crossP_CC(cir[i],cir[i+1]));\n    }\n    po.PB(vector<P>(1,cir[n-1].p));\n    rep(i,110){\n      rep(j,2){\n        dp[i][j]=INF;\n      }\n    }\n    // printf(\"%.6lf %.6lf\\n\",po[1][0].X,po[1][0].Y);\n    // printf(\"%.6lf %.6lf\\n\",po[1][1].X,po[1][1].Y);\n    dp[0][0]=dp[0][1]=0;\n    reep(i,1,n){\n      if(i==1){\n        dp[1][0]=distPP(cir[0].p,po[1][0]);\n        dp[1][1]=distPP(cir[0].p,po[1][1]);\n      }\n      // dp[i][0]=mkp(distPP(cir[0].p,po[0][0]),0);\n      else{\n        rep(j,2){\n          for(int k=i-1;k>=0;k--){\n            rep(g,po[k].size()){\n              S t1=S(po[i][j],po[k][g]);\n              bool f=true;\n              reep(h,k+1,i){\n                f&=isCrossSS(t1,S(po[h][0],po[h][1]));\n              }\n              if(f){\n                if(dp[i][j]>distPP(po[i][j],po[k][g])+dp[k][g]){\n                  dp[i][j]=distPP(po[i][j],po[k][g])+dp[k][g];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    double ans=INF;\n    rep(i,n){\n      rep(j,po[i].size()){\n        // cout<<i<<\" \"<<j<<\" \";\n        // printf(\"%.6lf\\n\",dp[i][j]);\n        S t1=S(po[i][j],po[n][0]);\n        bool f=true;\n        reep(k,i+1,n){\n          f&=isCrossSS(t1,S(po[k][0],po[k][1]));\n        }\n        if(f){\n          ans=min(ans,dp[i][j]+distPP(po[i][j],po[n][0]));\n        }\n      }\n    }\n    printf(\"%.6lf\\n\",ans);\n    // rep(i,n){\n      // cout<<dp[i][0].se<<\" \"<<dp[i][1].se<<endl;\n    // }\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;       // counter clockwise\n\tif(cross(b, c) < 0)   return -1;       // clockwise\n\tif(dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif(norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\ntypedef double W;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> State;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph G, vector<W>& d, vector<int>& prev) {\n\tpriority_queue< State, vector<State>, greater<State> > que;\n\tfill(d.begin(), d.end(), INF);\n\tfill(prev.begin(), prev.end(), -1);\n\n\td[s] = 0;\n\tque.push(State(0, s));\n\twhile(!que.empty()) {\n\t\tState p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\tprev[e.to] = v;\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(State(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble x[100], y[100], r[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\n\t\tGraph G(2 * n);\n\t\tvector<P> c;\n\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\tdouble r1 = r[i], r2 = r[i + 1];\n\t\t\tP p1(x[i], y[i]), p2(x[i + 1], y[i + 1]);\n\t\t\tP v = p2 - p1;\n\t\t\tdouble t = (r1 * r1 + norm(v) - r2 * r2) / (2 * abs(v));\n\t\t\tdouble theta = acos(t / r1);\n\t\t\tP b1 = p1 + v / abs(v) * r1 * polar(1.0, theta);\n\t\t\tP b2 = p1 + v / abs(v) * r1 * polar(1.0, -theta);\n\t\t\tc.push_back(b1);\n\t\t\tc.push_back(b2);\n\t\t}\n\n\t\tfor(int i = 0; i < c.size(); i++) {\n\t\t\tfor(int j = i + 1; j < c.size(); j++) {\n\t\t\t\tint n1 = i / 2, n2 = j / 2;\n\t\t\t\tif(n1 == n2) continue;\n\n\t\t\t\tL line(c[i], c[j]);\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = n1 + 1; k <= n2 - 1; k++) {\n\t\t\t\t\tif(!intersectSS(line, L(c[2 * k], c[2 * k + 1]))) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag) {\n\t\t\t\t\tdouble cost = abs(c[i] - c[j]);\n\t\t\t\t\tG[i].push_back(edge{ j, cost });\n\t\t\t\t\tG[j].push_back(edge{ i, cost });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint start = 2 * n - 2, goal = 2 * n - 1;\n\t\tc.push_back(P(x[0], y[0]));\n\t\tc.push_back(P(x[n - 1], y[n - 1]));\n\t\tfor(int i = 0; i < start; i++) {\n\t\t\tint n1 = i / 2;\n\t\t\tL line(c[i], c[start]);\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0; k <= n1 - 1; k++) {\n\t\t\t\tif(!intersectSS(line, L(c[2 * k], c[2 * k + 1]))) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tdouble cost = abs(c[i] - c[start]);\n\t\t\t\tG[start].push_back(edge{ i, cost });\n\t\t\t\tG[i].push_back(edge{ start, cost });\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < start; i++) {\n\t\t\tint n1 = i / 2;\n\t\t\tL line(c[i], c[goal]);\n\t\t\tbool flag = true;\n\t\t\tfor(int k = n1 + 1; k < n - 1; k++) {\n\t\t\t\tif(!intersectSS(line, L(c[2 * k], c[2 * k + 1]))) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tdouble cost = abs(c[i] - c[goal]);\n\t\t\t\tG[i].push_back(edge{ goal, cost });\n\t\t\t\tG[goal].push_back(edge{ i, cost });\n\t\t\t}\n\t\t}\n\n\t\tL line(c[start], c[goal]);\n\t\tbool flag = true;\n\t\tfor(int k = 0; k <= n - 1; k++) {\n\t\t\tif(!intersectSS(line, L(c[2 * k], c[2 * k + 1]))) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) {\n\t\t\tdouble cost = abs(c[start] - c[goal]);\n\t\t\tG[start].push_back(edge{ goal, cost });\n\t\t}\n\n\t\tvector<W> d(2 * n);\n\t\tvector<int> prev(2 * n);\n\t\tdijkstra(start, G, d, prev);\n\t\tcout << setprecision(15) << d[goal] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 110\n#define INF 1e9\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\nPoint operator * (const Point &a,const Point &b){ return Point(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); }\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\ndouble getDistance(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nstruct Circle{\n  Point p;\n  double r;\n  Circle(){}\n  Circle(Point p,double r) : p(p),r(r) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0\n    && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nvector<Point> crosspointCC(const Circle &a,const Circle &b){\n  vector<Point> res;\n  double d = abs(a.p-b.p);\n  double rc = (a.r*a.r-b.r*b.r+d*d)/(2.0*d);\n  double rs = sqrt(a.r*a.r-rc*rc);\n  Point p = (b.p-a.p)/d;\n  res.push_back(Point(a.p+p*Point(rc,-rs)));\n  res.push_back(Point(a.p+p*Point(rc,rs)));\n  return res;\n}\n\nstruct P{\n  double d;\n  int n,p;\n  P(double d,int n,int p) : d(d),n(n),p(p) {}\n  bool operator < (const P &p)const{\n    if(d != p.d){\n      return d > p.d;\n    }\n  }\n};\n\ndouble dist[MAX_N][2][MAX_N][2];\n\ndouble solve(int N){\n  double d[MAX_N][2];\n  fill(d[0],d[0]+MAX_N*2,INF);\n  d[0][0] = 0.0;\n\n  priority_queue<P> Q;\n  Q.push(P(0,0,0));\n\n  while(!Q.empty()){\n    P p = Q.top(); Q.pop();\n    int idx = p.n,pos = p.p;\n    if(lt(d[idx][pos],p.d)){ continue; }\n    if(idx == N){ return p.d; }\n    for(int i = idx+1 ; i <= N ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n        if(dist[idx][pos][i][j] == INF){ continue; }\n        if(p.d+dist[idx][pos][i][j] < d[i][j]){\n          d[i][j] = p.d+dist[idx][pos][i][j];\n          Q.push(P(d[i][j],i,j));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(int N){\n  for(int i = 0 ; i < N ; i++){\n    for(int j = 0 ; j < 2 ; j++){\n      for(int k = 0 ; k <= N ; k++){\n        for(int l = 0 ; l < 2 ; l++){\n          dist[i][j][k][l] = INF;\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(cin >> N,N){\n    vector<Point> G[MAX_N];\n    vector<Circle> cirs(N);\n    init(N);\n    for(int i = 0 ; i < N ; i++){\n      cin >> cirs[i].p >> cirs[i].r;\n      if(i == 0){\n        G[i].push_back(cirs[0].p);\n        G[i].push_back(cirs[0].p);\n      }else{\n        vector<Point> cp = crosspointCC(cirs[i-1],cirs[i]);\n        G[i].push_back(cp[0]); G[i].push_back(cp[1]);\n      }\n    }\n    G[N].push_back(cirs[N-1].p);\n    G[N].push_back(cirs[N-1].p);\n\n    for(int i = 0 ; i < N ; i++){\n      for(int j = i+1 ; j <= N ; j++){\n        Point p1[2] = {G[i][0],G[i][1]};\n        Point p2[2] = {G[j][0],G[j][1]};\n        for(int k = 0 ; k < 2 ; k++){\n          for(int l = 0 ; l < 2 ; l++){\n            Segment a = Segment(p1[k],p2[l]);\n            bool ok = true;\n            for(int m = i ; m < j ; m++){\n              Segment b = Segment(G[m][0],G[m][1]);\n              if(!isIntersectSS(a,b)){\n                ok = false;\n                break;\n              }\n            }\n            if(ok){\n              dist[i][k][j][l] = getDistance(p1[k],p2[l]);\n            }\n          }\n        }\n      }\n    }\n    printf(\"%.8f\\n\",solve(N));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.emplace_back(c, c);\n\t\t\telse{\n\t\t\t\ts.push_back(cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.emplace_back(prev, prev);\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.6f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define INF 1e99\n#define EPS 1e-6\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> P2;\ntypedef pair<double,double> pdd;\ntypedef pair<double,bool> pdb;\n\ndouble dot(rP va, rP vb){\n\treturn real(va) * real(vb) + imag(va) * imag(vb);\n}\n\nP2 intersectcircle(rP p1, double r1, rP p2, double r2){\n\tdouble d = abs(p2 - p1);\n\tdouble phi = arg(p2 - p1);\n\n\tdouble theta = acos((d * d + r1 * r1 - r2 * r2) / (2.0 * d * r1));\n\treturn P2(p1 + polar(r1, phi + theta), p1 + polar(r1, phi - theta));\n}\n\npdd intersectlc(rP p1, rP p2, rP pc, double r){\n\tP v12 = p2 - p1;\n\tP v1c = pc - p1;\n\t\n\tvector<P> ret;\n\n\tdouble a = norm(v12);\n\tdouble b = -dot(v12, v1c);\n\tdouble c = norm(v1c) - r * r;\n\n\tdouble D = b * b - a * c;\n\tif( D < 0.0 ){\n\t\treturn pdd(INF, INF);\n\t}\n\n\tdouble t1 = (-b - sqrt(D)) / a;\n\tdouble t2 = (-b + sqrt(D)) / a;\n\treturn pdd(t1, t2);\n}\n\nint n;\nP pc[105];\ndouble r[105];\nP intr[105][2];\ndouble dp[105][2];\n\nbool reachable(int a, int k1, int b, int k2){\n\tvector<pdb> v;\n\t\n\tfor(int i = a; i <= b + 1; ++i){\n\t\tpdd p = intersectlc(intr[a][k1], intr[b][k2], pc[i], r[i]);\n\t\tv.push_back( pdb(p.first, false) );\n\t\tv.push_back( pdb(p.second, true) );\n\t}\n\t\n\tsort(v.begin(), v.end());\n\t\n\tint c = 0;\n\tfor(int i = 0; i < v.size(); ++i){\n\t\tif( v[i].first > EPS && c == 0 ) return false;\n\t\tif( v[i].first > 1.0 - EPS ) return true;\n\n\t\tif( v[i].second ){\n\t\t\t--c;\n\t\t}\n\t\telse{\n\t\t\t++c;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nint main(){\n\tdouble x, y;\n\twhile( scanf(\"%d\", &n), n != 0 ){\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tscanf(\"%lf%lf%lf\", &x, &y, &r[i]);\n\t\t\tpc[i] = P(x, y);\n\t\t}\n\t\t\n\t\tpc[0] = pc[1];\n\t\tr[0] = r[1];\n\t\tpc[n + 1] = pc[n];\n\t\tr[n + 1] = r[n];\n\t\t\n\t\tfor(int i = 1; i <= n - 1; ++i){\n\t\t\tP2 p = intersectcircle(pc[i], r[i], pc[i+1], r[i+1]);\n\t\t\tintr[i][0] = p.first;\n\t\t\tintr[i][1] = p.second;\n\t\t}\n\t\t\n\t\tintr[0][0] = intr[0][1] = pc[1];\n\t\tintr[n][0] = intr[n][1] = pc[n];\n\t\t\n\t\tfill(*dp, *dp + sizeof(dp) / sizeof(double), INF);\n\t\tdp[0][0] = dp[0][1] = 0.0;\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\tfor(int k1 = 0; k1 < 2; ++k1)\n\t\tfor(int k2 = 0; k2 < 2; ++k2){\n\t\t\tif( reachable(i, k1, j, k2) ){\n\t\t\t\tdouble d = abs(intr[i][k1] - intr[j][k2]);\n\t\t\t\tdp[j][k2] = min(dp[j][k2], dp[i][k1] + d);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%f\\n\", dp[n][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* 解答時間→ 101:22(途中) */\n#include <cmath>\n#include <iomanip>\n#include <iostream>\t\t//基本入出力\nusing namespace std;\n\ndouble dist2d(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main(){\n\tcout << setprecision(16);\n\twhile(1){\n\t\t//入力\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tdouble x[25],y[25],r[25];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\t\tint V = n * 2;\n\t\tdouble pos_x[50], pos_y[50];\n\t\tpos_x[0] = x[0];\n\t\tpos_y[0] = y[0];\n\t\tpos_x[V - 1] = x[n - 1];\n\t\tpos_y[V - 1] = y[n - 1];\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tdouble d = sqrt(1.0 * (x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1]));\n\t\t\tdouble a = (d * d + r[i] * r[i] - r[i + 1] * r[i + 1]) / (d * 2);\n\t\t\tdouble b = sqrt(-a * a + r[i] * r[i]);\n\t\t\tdouble va_x = a * (x[i + 1] - x[i]) / d, va_y = a * (y[i + 1] - y[i]) / d;\n\t\t\tdouble vb_x = b * (y[i] - y[i + 1]) / d, vb_y = b * (x[i + 1] - x[i]) / d;\n\t\t\tpos_x[i * 2 + 1] = va_x + vb_x + x[i];\n\t\t\tpos_y[i * 2 + 1] = va_y + vb_y + y[i];\n\t\t\tpos_x[i * 2 + 2] = va_x - vb_x + x[i];\n\t\t\tpos_y[i * 2 + 2] = va_y - vb_y + y[i];\n\t\t}\n\t\t//総当りで距離を計算\n\t\tdouble dist[50][50];\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\t//dist[i][j] = DBL_MAX;\n\t\t\t\tdist[i][j] = sqrt(2.0 * 1000 * 1000);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < V - 1; i++){\n\t\t\tfor(int j = i + 1; j < V; j++){\n\t\t\t\t//交差判定(準備)\n\t\t\t\tint flg = 1;\n\t\t\t\tdouble x1, y1, x2, y2, x3, y3, x4, y4;\n\t\t\t\tx1 = pos_x[i];\n\t\t\t\ty1 = pos_y[i];\n\t\t\t\tx2 = pos_x[j];\n\t\t\t\ty2 = pos_y[j];\n\t\t\t\tint pos_ls, pos_lg;\n\t\t\t\tif(i == 0)\n\t\t\t\t\tpos_ls = 1;\n\t\t\t\telse\n\t\t\t\t\tpos_ls = (i + 1) / 2 + 1;\n\t\t\t\tif(j == V - 1)\n\t\t\t\t\tpos_lg = n - 1;\n\t\t\t\telse\n\t\t\t\t\tpos_lg = (j + 1) / 2 - 1;\n\t\t\t\t//交差判定(本番)\n\t\t\t\tdouble ta, tb, tc, td;\n\t\t\t\tfor(int k = pos_ls; k <= pos_lg; k++){\n\t\t\t\t\tx3 = pos_x[k * 2 - 1];\n\t\t\t\t\ty3 = pos_y[k * 2 - 1];\n\t\t\t\t\tx4 = pos_x[k * 2];\n\t\t\t\t\ty4 = pos_y[k * 2];\n\t\t\t\t\tta = (x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\t\t\t\ttb = (x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\t\t\t\ttc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\t\t\t\ttd = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\t\t\tif((tc*td>=0.0)||(ta*tb>=0.0)){\n\t\t\t\t\t\tflg=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg == 1){\n\t\t\t\t\tdist[i][j] = dist2d(pos_x[i], pos_y[i], pos_x[j], pos_y[j]);\n\t\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ワーシャル・フロイド法\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j])\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tcout << dist[0][V - 1] << \"\\n\";\n\t}\n\tcout << flush;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n// using Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\nstruct C {\n    P p;\n    double r;\n    C(){}\n    C(P _p, double _r) : p(_p), r(_r) {}\n    C(double _x, double _y, double _r) : p(_x, _y), r(_r) {}\n    void print() {\n        cerr << p.real() << \" \" << p.imag() << \" \" << r << endl;\n    }\n};\n\nC readC() {\n    double x, y, r;\n    cin >> x >> y >> r;\n    return C(x, y, r);\n}\n\nL intersectSegmentCC(C c1, C c2) {\n    P v = c2.p - c1.p;\n    double ac = (norm(v) + c1.r * c1.r - c2.r * c2.r) / (2 * abs(v));\n    double as = sqrt(c1.r * c1.r - ac * ac);\n    P u = v / abs(v);\n    P h = u * P(0, as);\n    u *= ac;\n    return L(c1.p + u + h, c1.p + u - h);\n}\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\n// include endpoints\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\nstruct edge {\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to, double _cost) : to(_to), cost(_cost) {}\n    void print() {\n        printf(\"{%d, %.2f}, \", to, cost);\n    }\n};\nusing Graph = vector<vector<edge>>;\n\n// undirected\nvoid addEdge(Graph& G, int x, int y, double c) {\n    G[x].emplace_back(y, c);\n    G[y].emplace_back(x, c);\n}\ndouble dijkstra(const Graph& G, int s, int g) {\n    int n = G.size();\n    using State = pair<double, int>;\n    priority_queue<State, vector<State>, greater<State>> pq;   // cost, vertex\n    vector<double> d(n, 1e18);\n    d[s] = 0.;\n    pq.push(make_pair(0., s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<C> circles(n);\n        rep(i, n) circles[i] = readC();\n\n        vector<L> segments(n - 1);\n        const int N = 2 * n, s = N - 2, t = N - 1;\n        vector<P> points(N);\n        rep(i, n - 1) {\n            segments[i] = intersectSegmentCC(circles[i], circles[i + 1]);\n            points[2 * i] = segments[i].a;\n            points[2 * i + 1] = segments[i].b;\n        }\n        points[s] = circles[0].p;\n        points[t] = circles.back().p;\n\n        auto canConnect = [&](int a, int b) {\n            L seg(points[a], points[b]);\n\n            int l, r; // [l, r)\n            if (a == s && b == t) {\n                l = 0, r = n - 1;\n            }\n            else if (b == s) {\n                l = 0, r = a / 2;\n            }\n            else if (b == t) {\n                l = a / 2, r = n - 1;\n            }\n            else {\n                l = a / 2, r = b / 2;\n            }\n\n            for (int i = l; i < r; i++) {\n                if (!intersectSS(seg, segments[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        Graph G(N);\n        rep(i, N) {\n            rep2(j, i + 1, N) {\n                if (canConnect(i, j)) {\n                    addEdge(G, i, j, abs(points[i] - points[j]));\n                }\n            }\n        }\n\n        cout << fixed << setprecision(10) << dijkstra(G, s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n#define FOR(i,k,n) for(int i=(k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n\nconst double INF = 1e8;\nconst double EPS = 1e-8;\n\n#include <complex>\n#define CURR(P, i) (P[(i) % P.size()])\n#define NEXT(P, i) (P[((i) + 1) % P.size()])\n\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n    Line() {;}\n    Line(Point a, Point b) { push_back(a); push_back(b); }\n};\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {;}\n    Circle(Point p, double r) : p(p), r(r) {;}\n};\ninline double cross(const Point &a, const Point &b) {\n      return imag(conj(a) * b);\n}\ninline double dot(const Point &a, const Point &b) {\n      return real(conj(a) * b);\n}\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n    return l[0] + t * (l[0] - l[1]);\n}\ninline int ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > 0) { return 1; }\n    if (cross(b, c) < 0) { return -1; }\n    if (dot(b, c) < 0) { return 2; }\n    if (norm(b) < norm(c)) { return -2; }\n    return 0;\n}\nbool intersectSS(const Line &s, const Line &t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nvector<Point> crosspointLC(const Line &l, const Circle &c) {\n    vector<Point> ret;\n    Point center = projection(l, c.p);\n    double d = abs(center - c.p);\n    double t = sqrt(c.r * c.r - d * d);\n    if (isnan(t)) { return ret; }\n    Point vect = (l[1] - l[0]);\n    vect /= abs(vect);\n    ret.push_back(center - vect * t);\n    if (t > EPS) {\n        ret.push_back(center + vect * t);\n    }\n    return ret;\n}\nvector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n    vector<Point> ret;\n    double d = abs(c1.p - c2.p);\n    if (max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) { return ret; }\n    double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    Point start = c1.p + (c2.p - c1.p) / d * x;\n    Point vect = (c1.p - c2.p) * Point(0.0, 1.0);\n    return crosspointLC(Line(start, start + vect), c1);\n}\nint main(){\n    int N;\n    while(cin>>N && N){\n        Point p[100];\n        double r[100];\n        vector<Circle> circles;\n        REP(i, N){\n            double x, y;\n            cin>>x>>y>>r[i];\n            p[i] = Point(x, y);\n            circles.push_back(Circle(p[i], r[i]));\n        }\n        double d[300][300];\n        vector<Point> crosses;\n        REP(i, N-1) {\n            vector<Point> cv = crosspointCC(circles[i], circles[i+1]);\n            crosses.push_back(cv[0]);\n            crosses.push_back(cv[1]);\n        }\n        const int S = 2 * (N - 1);\n        const int G = S + 1;\n        const int SIZE = G + 1;\n        REP(i, SIZE)REP(j, SIZE) d[i][j] = INF;\n        REP(i, crosses.size())FOR(j, i+1, crosses.size()){\n            Line line(crosses[i], crosses[j]);\n            int idx1 = i / 2 + 1, idx2 = j /2;\n            bool ok = true;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[i] - crosses[j]);\n        }\n        REP(j, crosses.size()){\n            int i = S;\n            Line line(p[0], crosses[j]);\n            bool ok = true;\n            int idx1 = 0, idx2 = j / 2;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[j] - p[0]);\n        }\n        REP(i, crosses.size()){\n            int j = G;\n            Line line(crosses[i], p[N-1]);\n            bool ok = true;\n            int idx1 = i / 2 + 1, idx2 = N - 1;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            if(!ok) continue;\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            d[i][j] = d[j][i] = abs(crosses[i] - p[N-1]);\n        }\n        {\n            int i = S; int j = G;\n            Line line(p[0], p[N-1]);\n            bool ok = true;\n            int idx1 = 0, idx2 = N - 1;\n            for(int k = idx1; k < idx2; k++){\n                Line t(crosses[2*k], crosses[2*k+1]);\n                if(!intersectSS(line, t)) ok = false;\n            }\n            //printf(\"ok %d %d %f\\n\", i, j, abs(crosses[i] - crosses[j]));\n            if(ok) d[i][j] = d[j][i] = abs(p[N-1] - p[0]);\n        }\n        REP(k, SIZE)REP(i, SIZE)REP(j, SIZE){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        printf(\"%.8lf\\n\", d[S][G]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <utility>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<(n); i++)\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define X real();\n#define Y imag();\n#define LE(n,m) ((n)<(m)+EPS)\n#define GE(n,m) ((n)+EPS < (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : vector<P> {\n  L(P a, P b){push_back(a); push_back(b);}\n};\nstruct C{\n  P p;\n  double r;\n  C(const P& p, const double& r) : p(p), r(r){}\n};\n\ndouble dot(P a, P b){\n  return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c)>EPS) return +1;\n  if(cross(b,c)<-EPS) return -1;\n  if(dot(b,c)<EPS) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nVP crosspointCC(const C& a, const C& b){\n  VP ps;\n  P ab = b.p-a.p;\n  double dist = abs(ab);\n  double l = ((a.r*a.r-b.r*b.r)/dist + dist)/2;\n  double n= sqrt(a.r*a.r - l*l);\n  P mid = a.p + (ab)*(l/dist);\n  P hei = ab * (n/dist) * P(0,1);\n  ps.push_back(mid+hei);\n  ps.push_back(mid-hei);\n  return ps;\n}\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) break;\n\n    vector<C> c;\n    for(int i=0; i<n; i++){\n      double x,y,r;\n      cin >> x >> y >> r;\n      c.push_back(C(P(x,y), r));\n    }\n\n    VP ps;\n    ps.push_back(c[0].p);\n    for(int i=0; i<n-1; i++){\n      VP cp = crosspointCC(c[i], c[i+1]);\n      ps.push_back(cp[0]);\n      ps.push_back(cp[1]);\n    }\n    ps.push_back(c[n-1].p);\n\n    int numpoints = ps.size();\n    vector<vector<double> > adj((int)ps.size(), vector<double>(ps.size(), INF));\n    for(int i=0; i<numpoints; i++){\n      for(int j=i; j<numpoints; j++){\n        bool flag = true;\n        for(int k=i+1; k<j; k++){\n          if(k%2==0 && ccw(ps[i], ps[j], ps[k])==1){\n            flag = false;\n          }\n          if(k%2!=0 && ccw(ps[i], ps[j], ps[k])==-1){\n            flag = false;\n          }\n        }\n        if(flag){\n          adj[i][j] = abs(ps[i]-ps[j]);\n        }\n      }\n    }\n\n    for(int k=0; k < numpoints; k++){\n      for(int i=0; i<numpoints; i++){\n        for(int j=0; j<numpoints; j++){\n          adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n        }\n      }\n    }\n\n    cout << fixed;\n    cout << setprecision(10);\n    cout << adj[0][numpoints-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<C> c(n);\n\t\trep(i, n) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tc[i] = C{ P{(double)x,(double)y},(double)r };\n\t\t}\n\t\tvector<double[2]> dp(n - 1);\n\t\tvector<L> s(n - 1);\n\t\trep(i, n - 1) {\n\t\t\tauto x = is_cc(c[i], c[i + 1]);\n\t\t\ts[i] = { x[0],x[1] };\n\t\t}\n\t\tVP p = { c[n - 1].p };\n\t\trep1(i, n - 2) {\n\t\t\tdp[i][0] = min(dp[i - 1][0] + abs(s[i].a - s[i - 1].a), dp[i - 1][1] + abs(s[i].a - s[i - 1].b));\n\t\t\tdp[i][1] = min(dp[i - 1][0] + abs(s[i].b - s[i - 1].a), dp[i - 1][1] + abs(s[i].b - s[i - 1].b));\n\t\t}\n\t\tint prev = (dp[n - 2][0] < dp[n - 2][1] ? 0 : 1);\n\t\tp.push_back(prev ? s[n - 2].b : s[n - 2].a);\n\t\trrep(i, n - 2) {\n\t\t\tprev = (dp[i][0] + abs(s[i].a - (prev ? s[i + 1].b : s[i + 1].a)) == dp[i + 1][prev] ? 0 : 1);\n\t\t\tp.push_back(prev ? s[i].b : s[i].a);\n\t\t}\n\t\tp.push_back(c[0].p);\n\t\treverse(ALL(p));\n\t\tVP ans = { p[0] };\n\t\tvi pos;\n\t\trep1(i, n - 1) {\n\t\t\tif (!isis_ls({ ans.back(),p[i + 1] }, s[i - 1])) {\n\t\t\t\twhile (!pos.empty() && isis_ls({ ans[ans.size() - 2],p[i] }, s[pos.back()]))ans.pop_back(), pos.pop_back();\n\t\t\t\tans.push_back(p[i]);\n\t\t\t\tpos.push_back(i - 1);\n\t\t\t}\n\t\t}\n\t\tans.push_back(p.back());\n\t\tdouble a = 0;\n\t\trep(i, ans.size() - 1)a += abs(ans[i] - ans[i + 1]);\n\t\tcout << fixed << setprecision(5) << a << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<map>\nusing namespace std;\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n//線分p1-p2と線分q1-q2が交差するか\nbool intersecting(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n\n\nint main(){\n\tint n,ans;\n\tdouble x[100],y[100],r[100];\n\tdouble d[200][200];\n\tvector<P> v;\n\tvector<pair<P,P> > line;\n\tvector<int> L;\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i];\n\t\tfor(int i=0;i<200;i++)for(int j=0;j<200;j++)d[i][j]=INF;\n\t\tline.clear();\n\t\tv.clear();\n\t\tv.push_back(P(x[0],y[0]));\n\t\tL.clear();\n\t\tL.push_back(-1);\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tpair<P,P> a = circle_intersection(x[i],y[i],r[i],x[i+1],y[i+1],r[i+1]);\n\t\t\tv.push_back(a.first);\n\t\t\tv.push_back(a.second);\n\t\t\tL.push_back(i);L.push_back(i);\n\t\t\tline.push_back(a);\n\t\t}\n\t\tv.push_back(P(x[n-1],y[n-1]));\n\t\tL.push_back(n-1);\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\t\tint k;\n\t\t\t\tfor(k=L[i]+1;k<L[j];k++){\n\t\t\t\t\tif(!intersecting(v[i],v[j],line[k].first,line[k].second))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k>=L[j])//間の交点間の線分全てと交差する\n\t\t\t\t\td[i][j]=d[j][i]=dist(v[i],v[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<v.size();k++)\n\t\t\tfor(int i=0;i<v.size();i++)\n\t\t\t\tfor(int j=0;j<v.size();j++)\n\t\t\t\t\td[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\tprintf(\"%.4f\\n\",d[0][v.size()-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\ntemplate<class T> T at(vector<T> v, int i) {return v[i % v.size()];}\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\n// 比較関数\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator==(P a, P b) {return norm(a - b) < EPS;}\n  bool operator<(L a, L b) {return a.a != b.a ? a.a < b.a : a.b < b.b;}\n}\n\nD sr(D a) {return sqrt(max(a, (D)0));}\n\n// 内積\nD dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.b - a.a;}\n\n// 線分abに対する点cの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  if (a == c || b == c) return ON;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\n// 有向角度\nD arg(P base, P a, P b) {return arg((b - base) / (a - base));}\nL sortBase;\nbool lessArg(P a, P b) {\n  D ang1 = arg(sortBase.a, sortBase.b, a);\n  D ang2 = arg(sortBase.a, sortBase.b, b);\n  return sig(ang1, ang2) ? ang1 < ang2 : norm(a) > norm(b);\n}\n\n// 射影\nP proj(P a, P b) {return a * dot(a, b) / norm(a);}\nP perp(L l, P p) {return l.a + proj(vec(l), p - l.a);}\nP refl(L l, P p) {return perp(l, p) * (D)2 - p;}\n\n// 交差判定\nbool eqL(L a, L b) {return !sig(det(vec(a), vec(b))) && !sig(det(vec(a), b.a - a.a));}\nbool iLL(L a, L b) {return sig(det(vec(a), vec(b))) || !sig(det(vec(a), b.a - a.a));}\nbool iLLs(L a, L b) {return sig(det(vec(a), vec(b)));}\nbool iLS(L a, L b) {return sig(det(vec(a), b.a - a.a)) * sig(det(vec(a), b.b - a.a)) <= 0;}\nbool iLSs(L a, L b) {return sig(det(vec(a), b.a - a.a)) * sig(det(vec(a), b.b - a.a)) < 0;}\nbool iSS(L a, L b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nbool iSSs(L a, L b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// 交点\nP pLL(L a, L b) {return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));}\n\n// 距離\nD dLP(L l, P p) {return abs(det(vec(l), p - l.a)) / abs(vec(l));}\nD dSP(L s, P p) {\n  if (dot(vec(s), p - s.a) < 0) return abs(p - s.a);\n  if (dot(vec(s), p - s.b) > 0) return abs(p - s.b);\n  return dLP(s, p);\n}\nD dLL(L a, L b) {return iLL(a, b) ? 0 : dLP(a, b.a);}\nD dLS(L a, L b) {return iLS(a, b) ? 0 : min(dLP(a, b.a), dLP(a, b.b));}\nD dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.a), dSP(a, b.b)), min(dSP(b, a.a), dSP(b, a.b)));}\n\n// 円\nstruct C{P c; D r;};\n\n// 2円の位置関係\nenum RELATION{SAME = 1, CONTAIN = 2, OVER = 4, NO_CROSS = 8, ONE_CROSS = 16, ONE_CONTAIN_CROSS = 32, ONE_OVER_CROSS = 64, TWO_CROSS = 128};\nint cRel(C c1, C c2) {\n  D d = abs(c1.c - c2.c);\n  if (c1.c == c2.c && !sig(c1.r, c2.r)) return SAME;\n  if (sig(d, c1.r - c2.r) < 0) return OVER;\n  if (sig(d, c2.r - c1.r) < 0) return CONTAIN;\n  if (!sig(d, c1.r - c2.r)) return ONE_OVER_CROSS;\n  if (!sig(d, c2.r - c1.r)) return ONE_CONTAIN_CROSS;\n  if (!sig(d, c1.r + c2.r)) return ONE_CROSS;\n  if (sig(d, c1.r + c2.r) > 0) return NO_CROSS;\n  return TWO_CROSS;\n}\n\n// 交差判定\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCL(C c, L l) {return sig(c.r, dLP(l, c.c)) >= 0;}\nbool iCS(C c, L s) {return sig(c.r, dSP(s, c.c)) >= 0;}\nbool iCSc(C c, L s) {return iCS(c, s) && sig(c.r, max(abs(s.a - c.c), abs(s.b - c.c))) <= 0;}\nbool iCC(C a, C b) {return sig(abs(a.c - b.c), a.r + b.r) <= 0;}\nbool iCCc(C a, C b) {return iCC(a, b) && sig(abs(a.c - b.c), abs(a.r - b.r)) >= 0;}\n\n// 交点\npair<P, P> pCC(C a, C b) {\n  D x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  P e = (b.c - a.c) / abs(b.c - a.c);\n  P y = e * P(0, sr(a.r * a.r - x * x));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\npair<P, P> pCL(C c, L l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\n// 角の内外判定 角abの内部にあれば正、辺上は0、外部は負\nint sAP(P a, P b, P c) {return sig(det(a, c)) - sig(det(b, c)) - sig(det(a, b));}\n\n// 多角形の面積\nD aPol(Pol vp) {\n  D ret = 0;\n  rep (i, vp.size()) ret += det(vp[i], at(vp, i + 1));\n  return ret / 2;\n}\n\n// 多角形の内外判定 内部:1、周上:0、外部:-1\nint sGP(Pol pol, P p) {\n  int side = -1;\n  rep (i, pol.size()) {\n    P p0 = pol[i] - p, p1 = at(pol, i + 1) - p;\n    if (ccw(p0, p1, 0) == ON) return 0;\n    if (p0.Y > p1.Y) swap(p0, p1);\n    if (sig(p0.Y) <= 0 && 0 < sig(p1.Y) && sig(det(p0, p1)) > 0) side *= -1;\n  }\n  return side;\n}\n\n// 凸包\nPol convexHull(Pol p) {\n  int m = -1, n = p.size();\n  if (n < 3) return p;\n  vector<P> q(n * 2);\n  sort(p.begin(), p.end());\n  for (int i = 0; i < n; q[++m] = p[i++])\n    for (; m > 0 && ccw(q[m - 1], q[m], p[i]) != LEFT; --m);\n  for (int i = n - 2, r = m; i >= 0; q[++m] = p[i--])\n    for (; m > r && ccw(q[m - 1], q[m], p[i]) != LEFT; --m);\n  q.resize(m);\n  return q;\n}\n\n// 凸包カット\nPol convexCut(Pol p, L l) {\n  vector<P> q;\n  rep (i, p.size() - 1) {\n    if (ccw(l.a, l.b, p[i]) != RIGHT) q.push_back(p[i]);\n    L s = {p[i], at(p, i + 1)};\n    if (iLSs(l, s)) q.push_back(pLL(l, s));\n  }\n  return q;\n}\n\n// 線分をマージする\nvector<L> merge(vector<L> s) {\n  rep (i, s.size()) if (s[i].b < s[i].a) swap(s[i].a, s[i].b);\n  sort(s.begin(), s.end());\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j]) && !iLL(s[i], s[j])) {\n    s[j].b = max(s[i].b, s[j].b);\n    s.erase(s.begin() + i--);\n    break;\n  }\n  return s;\n}\n\n// 線分アレンジメント 隣の点への辺のみを持つ\nvector<vector<int> > sArr(vector<L> s, vector<P> &vp) {\n  s = merge(s);\n  rep (i, s.size()) {\n    vp.push_back(s[i].a);\n    vp.push_back(s[i].b);\n  }\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) vp.push_back(pLL(s[i], s[j]));\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end()), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i].a, s[i].b, vp[j]) == ON) {\n      v.push_back(make_pair(norm(vp[j] - s[i].a), j));\n    }\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return g;\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    C c[n];\n    rep (i, n) cin >> c[i].c.X >> c[i].c.Y >> c[i].r;\n    vector<P> vp;\n    vp.push_back(c[0].c);\n    vp.push_back(c[n - 1].c);\n    rep (i, n - 1) {\n      pair<P, P> pp = pCC(c[i], c[i + 1]);\n      vp.push_back(pp.first);\n      vp.push_back(pp.second);\n    }\n    vector<L> vs;\n    rep (i, vp.size()) rep (j, i) {\n      L s = {vp[i], vp[j]};\n      vector<P> v;\n      rep (k, n) if (iCSc(c[k], s)) {\n\tpair<P, P> pp = pCL(c[k], s);\n\tif (ccw(s.a, s.b, pp.first) == ON) v.push_back(pp.first);\n\tif (ccw(s.a, s.b, pp.second) == ON) v.push_back(pp.second);\n      }\n      sort(v.begin(), v.end());\n      //cout << s.a << \" \" << s.b;\n      //rep (i, v.size()) cout << \" \" << v[i];\n      //cout << endl;\n      rep (t, v.size() - 1) {\n\tbool ok = false;\n\tP m = (v[t] + v[t + 1]) / (D)2;\n\trep (k, n) if (iCP(c[k], m)) {\n\t  ok = true;\n\t  break;\n\t}\n\tif (!ok) goto next;\n      }\n      vs.push_back(s);\n    next:;\n    }\n    //rep (i, vs.size()) cout << vs[i].a << \" \" << vs[i].b << endl;\n    vector<P> p;\n    vector<vector<int> > g = sArr(vs, p);\n    int start = -1, goal = -1;\n    rep (i, p.size()) if (p[i] == c[0].c) start = i;\n    rep (i, p.size()) if (p[i] == c[n - 1].c) goal = i;\n    D dis[p.size()];\n    rep (i, p.size()) dis[i] = 1e100;\n    priority_queue<pair<D, int>, vector<pair<D, int> >, greater<pair<D, int> > > que;\n    que.push(make_pair(0, start));\n    while (!que.empty()) {\n      pair<D, int> now = que.top();\n      que.pop();\n      if (dis[now.second] <= now.first) continue;\n      dis[now.second] = now.first;\n      rep (i, g[now.second].size()) {\n\tque.push(make_pair(now.first + abs(p[now.second] - p[g[now.second][i]]), g[now.second][i]));\n      }\n    }\n    printf(\"%.12Lf\\n\", dis[goal]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nsave\n\n*/\n#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<complex>\n#include<queue>\n#include<cassert>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define inf (1<<28) \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const{ return x != p.x?x<p.x:y<p.y; }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a) {  return a.x*a.x+a.y*a.y; }\n\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble abs(Point p)\n{\n  return sqrt(norm(p));\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\nstruct P\n{\n  int to;\n  double cost;\n  P(int to=-inf,double cost=-inf):to(to),cost(cost){}\n};\n\nstruct Pox\n{\n  int cur;\n  double cost;\n  Pox(int cur=-inf,double cost=-inf):cur(cur),cost(cost){}\n  bool operator < (const Pox& a)const{ return cost > a.cost; }\n\n};\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(),double r=-inf):p(p),r(r){}\n};\n\npair<Point, Point> circle_circle_intersect( Point C1, double r1, Point C2, double r2) {\n  complex<double> c1(C1.x,C1.y);\n  complex<double> c2(C2.x,C2.y);\n  complex<double> A = conj(c2-c1), B = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), C = r1*r1*(c2-c1);\n  complex<double> D = B*B-4.0*A*C;\n  complex<double> z1 = (-B+sqrt(D))/(2.0*A)+c1, z2 = (-B-sqrt(D))/(2.0*A)+c1;\n  return pair<Point, Point>(Point(z1.real(),z1.imag()),Point(z2.real(),z2.imag()));\n}\n\nint n;\n\nint main()\n{\n  /*\n  Point a,b,c,d;\n  while(cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y >> d.x >> d.y)\n    {\n      cout << intersectSS(Segment(a,b) , Segment(c,d)) << endl;\n    }\n  */\n  while(cin >> n,n)\n    {\n      vector<Circle> cs(n);\n      vector<Segment> ss(n-1);\n      vector<Point> ps;\n      rep(i,n)cin >> cs[i].p.x >> cs[i].p.y >> cs[i].r;\n     \n      ps.push_back(cs[0].p);\n      rep(i,n-1)\n\t{\n\n\t  pair<Point,Point> pp = circle_circle_intersect(cs[i].p,cs[i].r,cs[i+1].p,cs[i+1].r);\n\t  ss[i].p1 = pp.first,ss[i].p2 = pp.second; \n\t  cout << \"ss[\" << i << \"] = (\" << ss[i].p1.x << \",\" << ss[i].p1.y <<\") (\" << ss[i].p2.x << \",\" << ss[i].p2.y << \")\" << endl;\n\t  ps.push_back(pp.first);\n\t  ps.push_back(pp.second);\n\t  ps.push_back(cs[i+1].p);\n\t}\n\n      int N = n + (n-1)*2;\n      vector<vector<P> > G(N,vector<P>());\n\n      int pssize = ps.size();\n      rep(i,pssize)\n\t{\n\t  cout << \"from \" << i << endl;\n\t  REP(j,i+1,pssize)\n\t    {\n\n\t      bool pass = true;\n\t      for(int k=1;k<=j;k+=3)\n\t\t{\n\t\t  cout << \"Segment( ( \"<< ps[i].x << \",\" << ps[i].y << \") , (\" << ps[j].x << \",\" << ps[j].y << \") ) and Segment( (\" << ps[k].x << \",\" << ps[k].y << \") , (\" << ps[k+1].x << \",\" << ps[k+1].y << \") )\" << endl;  \t\t  \n\t\t  cout << \"result : \" << intersectSS(Segment(ps[i],ps[j]),Segment(ps[k],ps[k+1])) << endl;\n\t\t  if(!intersectSS(Segment(ps[i],ps[j]),Segment(ps[k],ps[k+1])))\n\t\t    {\n\t\t      pass = false;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      cout <<\"pass?\" << pass << endl;\n\t      if(!pass)continue;\n\t      cout << \"IN!\" << endl;\n\t      G[i].push_back(P(j,abs(ps[j]-ps[i])));\n\t    }\n\t}\n\n      rep(i,G.size())\n\t{\n\t  cout << i << \"-th\" << endl;\n\t  rep(j,G[i].size())\n\t    {\n\t      cout << \"(\" << G[i][j].to << \",\" << G[i][j].cost << \") \";\n\t    }\n\t  cout << endl;\n\t}\n      double mincost[N];\n      rep(i,N)mincost[i] = inf;\n      mincost[0] = 0;\n      priority_queue<Pox> Q;\n      Q.push(Pox(0,0));\n      while(!Q.empty())\n\t{\n\t  Pox pox = Q.top(); Q.pop();\n\t  if(pox.cur == N-1)\n\t    {\n\t      cout << setiosflags(ios::fixed) << setprecision(10) << pox.cost << endl;\n\t      break;\n\t    }\n\n\t  rep(i,G[pox.cur].size())\n\t    {\n\t      P p = G[pox.cur][i];\n\t      if(mincost[p.to] > mincost[pox.cur] + p.cost)\n\t\t{\n\t\t  mincost[p.to] = mincost[pox.cur] + p.cost;\n\t\t  Q.push(Pox(p.to,mincost[p.to]));\n\t\t}\n\t    }\n\t}\n     \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Circle> Cir(n);\n\t\tPoint s, t;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tint x, y, r; cin >> x >> y >> r;\n\t\t\tif (i == 0)s = Point(x, y);\n\t\t\tif (i == n - 1) t = Point(x, y);\n\t\t\tCir[i] = Circle(Point(x, y), r);\n\t\t}\n\t\tvector<Point> ps;\n\t\tps.push_back(s);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tauto temp_p = is_cc(Cir[i - 1], Cir[i]);\n\t\t\tfor (auto p : temp_p) {\n\t\t\t\tps.push_back(p);\n\t\t\t}\n\t\t}\n\t\tps.push_back(t);\n\t\t/*for (auto p : ps) {\n\t\t\tcout << p << endl;\n\t\t}*/\n\t\tint Size = ps.size();\n\t\tvector<vector<ld>> dist(Size, vector<ld>(Size, INF));\n\t\t//vector<vector<int>> can_use(Size, vector<int>(Size, 0));\n\t\tfor (int i = 0; i < Size - 1;i++) {\n\t\t\tint idx;\n\t\t\tif (i == 0)idx = 1;\n\t\t\telse idx = 2 * ((i + 1) / 2) + 1;\n\t\t\tPoint v1 = ps[idx] - ps[i], v2 = ps[min(idx + 1, Size - 1)] - ps[i];\n\t\t\tld arg1 = arg(v1), arg2 = arg(v2);\n\t\t\tdist[i][idx] = abs(v1); dist[i][min(idx + 1, Size - 1)] = abs(v2);\n\t\t\t//can_use[i][idx] = can_use[i][min(idx + 1, Size - 1)] = 1;\n\t\t\t//cout << \"------------------------\" << endl;\n\t\t\tint f = 0;\n\t\t\tfor (int j = idx + 2; j < Size;j++) {\n\t\t\t\tif (f > 10)break;\n\t\t\t\tPoint v3 = ps[j] - ps[i];\n\t\t\t\tld arg3 = arg(v3);\n\t\t\t\tif (arg3 > arg1 || arg3 < arg2) { f++; continue; }\n\t\t\t\tf = 0;\n\t\t\t\tdist[i][j] = abs(v3); //can_use[i][j] = 1;\n\t\t\t\tif (j % 2 == 1) { arg1 = min(arg1, arg3); }\n\t\t\t\telse { arg2 = max(arg2, arg3); }\n\t\t\t\t//cout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Size;i++) {\n\t\t\tfor (int j = 0; j < Size;j++) {\n\t\t\t\tfor (int k = 0; k < Size;k++) {\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << dist[0][Size - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-7;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle() {;}\n  Circle(Point p, double r) : p(p), r(r) {;}\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\n\ninline bool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\ninline Point projection(const Line &l, const Point &p) {\n  double t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n  return l[0] + t * (l[0] - l[1]);\n}\n\ninline vector<Point> crosspointLC(const Line &l, const Circle &c) {\n  vector<Point> ret;\n  Point center = projection(l, c.p);\n  double d = abs(center - c.p);\n  double t = sqrt(c.r * c.r - d * d);\n  if (isnan(t)) { return ret; }\n  Point vect = (l[1] - l[0]);\n  vect *= t / abs(vect);\n  ret.push_back(center - vect);\n  if (t > EPS) {\n    ret.push_back(center + vect);\n  }\n  return ret;\n}\n\ninline vector<Point> crosspointSC(const Line &s, const Circle &c) {\n  vector<Point> ret;\n  vector<Point> nret = crosspointLC(s, c);\n  for (int i = 0; i < (int)nret.size(); i++) {\n    if (intersectSP(s, nret[i])) { ret.push_back(nret[i]); }\n  }\n  return ret;\n}\n\ninline vector<Point> crosspointCC(const Circle &c1, const Circle &c2) {\n  vector<Point> ret;\n  double d = abs(c1.p - c2.p);\n  if (max(c1.r, c2.r) - min(c1.r, c2.r) - d> -EPS) { return ret; }\n  double x = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  Point start = c1.p + (c2.p - c1.p) / d * x;\n  Point vect = (c1.p - c2.p) * Point(0.0, 1.0);\n  return crosspointLC(Line(start, start + vect), c1);\n}\n\n\ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.8f \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n  const int n = g.size();\n  vector<bool> visit(n, false);\n  Array dist(n, 2000000000LL);\n  priority_queue<Edge> que;\n  que.push(Edge(s, s, 0));\n  Weight ans = -1;\n  dist[s] = 0;\n  while (!que.empty()) {\n    Edge edge = que.top();\n    que.pop();\n    int from = edge.dest;\n    if (visit[from]) { continue; }\n    visit[from] = true;\n    if (from == t) {\n      ans = edge.weight;\n      break;\n    }\n    for (int i = 0; i < (int)g[from].size(); i++) {\n      int to = g[from][i].dest;\n      Weight ncost = edge.weight + g[from][i].weight;\n      if (visit[to] || ncost >= dist[to] - EPS) { continue; }\n      dist[to] = ncost;\n      que.push(Edge(from, to, ncost));\n    }\n  }\n  return ans;\n}\n\nint n, m;\nvector<Circle> cs;\nvector<Point> ps;\nvector<int> indexes;\n\nint main(int argc, char *argv[]) {\n  while (scanf(\"%d\", &n), n) {\n    m = 0;\n    cs.clear();\n    ps.clear();\n    indexes.clear();\n    REP(i, n) {\n      double x, y, r;\n      scanf(\"%lf %lf %lf\", &x, &y, &r);\n      cs.push_back(Circle(Point(x, y), r));\n    }\n    ps.push_back(cs[0].p);\n    indexes.push_back(0);\n    ps.push_back(cs[n - 1].p);\n    indexes.push_back(n - 1);\n    REP(i, n - 1) {\n      vector<Point> nret = crosspointCC(cs[i], cs[i + 1]);\n      FORIT(it, nret) {\n        ps.push_back(*it);\n        indexes.push_back(i);\n      }\n    }\n    m = ps.size();\n    Graph g(m);\n    REP(j, m) {\n      REP(i, j) {\n        Line l(ps[i], ps[j]);\n        double d = abs(ps[i] - ps[j]);\n        int cnt = 0;\n        vector<pair<double, int> > events;\n        events.push_back(make_pair(EPS, 2));\n        events.push_back(make_pair(d - EPS, 0));\n        int lower = max(0, min(indexes[i], indexes[j]) - 0);\n        int upper = min(n, max(indexes[i], indexes[j]) + 1);\n        FOR(k, lower, upper) {\n          vector<Point> nret = crosspointSC(l, cs[k]);\n          if (nret.size() == 0) {\n            continue;\n          } else if (nret.size() == 1) {\n            double d1 = abs(ps[i] - nret[0]);\n            if (abs(ps[i] - cs[k].p) - cs[k].r <= EPS) {\n              cnt++;\n              events.push_back(make_pair(d1 + EPS, -1));\n            } else {\n              events.push_back(make_pair(d1 - EPS, 1));\n            }\n          } else if (nret.size() == 2) {\n            double d1 = abs(ps[i] - nret[0]);\n            double d2 = abs(ps[i] - nret[1]);\n            if (d1 > d2) { swap(d1, d2); }\n            events.push_back(make_pair(d1 - EPS, 1));\n            events.push_back(make_pair(d2 + EPS, -1));\n          }\n        }\n        sort(events.begin(), events.end());\n        int begin = 0;\n        FORIT(it, events) {\n          if (begin && cnt == 0) { goto next; }\n          if (it->second == 0) { break; }\n          if (it->second == 2) { begin = 1; continue; }\n          if (it->second == 1) {\n            cnt++;\n          } else if (it->second == -1) {\n            cnt--;\n          }\n        }\n        g[i].push_back(Edge(i, j, d));\n        g[j].push_back(Edge(j, i, d));\nnext:;\n      }\n    }\n    double ans = Dijkstra(g, 0, 1);\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#include <complex>\ntypedef complex<double> P;\n#define LT(x, y) ((x) - (y) <= -EPS)\n//２円の交点計算\nvector<P> crossCircles(P c1, double r1, P c2, double r2){\n    double d=abs(c2-c1);\n    if ( LT(r1+r2, d) || LT(d, fabs(r1-r2)) )\n    return vector<P>();\n    double l = 0.5* ( (r1*r1-r2*r2)/d+d);\n    double h = sqrt(r1*r1-l*l);\n    vector<P> ret(2);\n    ret[0]=P(l,+h)*(c2-c1)/d+c1;\n    ret[1]=P(l,-h)*(c2-c1)/d+c1;\n    return ret;\n}\n// 点cが線分a,b上にあるかないか(2)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  if (( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n          ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS ))\n        return true;\n  return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2) ||\n             is_point_on_line(b1, b2, a1) || is_point_on_line(b1, b2, a2);\n}\nstruct point{\n\tP p;int circle;\n\tpoint(P p,int circle):p(p),circle(circle){}\n};\nstruct node{\n    int index;double cost;\n    node(int index,double cost):index(index),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nconst double MAX=INT_MAX/10;\nint main(){\n\tcout.precision(16);\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi x(n),y(n),r(n);\n\t\tvector<point> points;\n\t\tvector<vector<point> > circle_to_points(n);\n\t\tREP(i,n){\n\t\t\tcin>>x[i]>>y[i]>>r[i];\n\t\t\tif(i>0){\n\t\t\t\tvector<P> ps=crossCircles(P(x[i],y[i]),r[i],P(x[i-1],y[i-1]),r[i-1]);\n\t\t\t\tpoints.push_back(point(ps[0],i));\n\t\t\t\tpoints.push_back(point(ps[1],i));\n\t\t\t\tcircle_to_points[i].push_back(point(ps[0],i));\n\t\t\t\tcircle_to_points[i].push_back(point(ps[1],i));\n\t\t\t}\n\t\t}\n\t\tpoints.push_back(point(P(x[0],y[0]),0));\n\t\tpoints.push_back(point(P(x[n-1],y[n-1]),n));\n\t\tvector<vector<double> > dist(points.size(),vector<double>(points.size(),MAX));\n\t\tREP(i,points.size()){\n\t\t\tREP(j,points.size()){\n\t\t\t\tbool flag=true;\n\t\t\t\tFOR(k,points[i].circle+1,points[j].circle){\n\t\t\t\t\tif(!is_intersected_ls(points[i].p,points[j].p,circle_to_points[k][0].p,circle_to_points[k][1].p)){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tdist[i][j]=abs(points[i].p-points[j].p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tpriority_queue<node> q;\n\t\tq.push(node(points.size()-2,0));\n\t\tvector<double> cost(points.size(),MAX);\n\t\tcost[points.size()-2]=0;\n\t\twhile(!q.empty()){\n\t\t\tnode cnode=q.top();q.pop();\n\t\t\tif(cost[cnode.index]<cnode.cost){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(i,points.size()){\n\t\t\t\tif(i!=cnode.index&&dist[cnode.index][i]!=MAX){\n\t\t\t\t\tdouble newcost=cnode.cost+dist[cnode.index][i];\n\t\t\t\t\tif(cost[i]>newcost){\n\t\t\t\t\t\tcost[i]=newcost;\n\t\t\t\t\t\tq.push(node(i,newcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cost[points.size()-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ndouble eps = 0.0000001;\nusing p2 = complex<double>;\n// x: real\n// y: img\n\ndouble det(p2 v1, p2 v2) {\n  return v1.real() * v2.imag() - v1.imag() * v2.real();\n}\ndouble dot(p2 v1, p2 v2) {\n  return v1.real() * v2.real() + v1.imag() * v2.imag();\n}\nbool same(double x, double y) { return fabs(x - y) < eps; }\ndouble dist2(p2 l1, p2 l2) { return dot(l1 - l2, l1 - l2); }\ndouble dist(p2 l1, p2 l2) { return sqrt(dist2(l1, l2)); }\n\nauto p2comp = [](const p2 &l, const p2 &r) {\n  if (fabs(l.real() - r.real()) > eps) {\n    return l.real() < r.real();\n  }\n  return l.imag() < r.imag();\n};\nstruct Line {\n  p2 st, ed;\n  Line(p2 st, p2 ed) : st(st), ed(ed) {}\n  Line(double x1, double y1, double x2, double y2)\n      : st(p2(x1, y1)), ed(p2(x2, y2)) {}\n  Line(p2 st, double x, double y) : st(st), ed(p2(x, y)) {}\n  Line(double x, double y, p2 ed) : st(p2(x, y)), ed(ed) {}\n  double dist() { return sqrt(dist2(st, ed)); }\n  double isPalla(Line l) { return fabs(det(ed - st, l.ed - l.st)) < eps; }\n  double x() { return ed.real() - st.real(); }\n  double y() { return ed.imag() - st.imag(); }\n};\n\npair<double, double> interP(Line l1, Line l2) {\n  double a = l1.x();\n  double b = -l2.x();\n  double c = l1.y();\n  double d = -l2.y();\n  double inv = 1. / (a * d - c * b);\n  double e1 = -l1.st.real() + l2.st.real();\n  double e2 = -l1.st.imag() + l2.st.imag();\n  return make_pair((d * e1 - b * e2) * inv, (-c * e1 + a * e2) * inv);\n}\n\nbool intersec(Line l1, Line l2) {\n  if (l1.isPalla(l2))\n    return false;\n  auto r = interP(l1, l2);\n  return eps < r.first && r.first < 1. - eps && eps < r.second &&\n         r.second < 1. - eps;\n}\n\nstruct Circle {\n  p2 p;\n  double r;\n  Circle(p2 p, double r) : p(p), r(r) {}\n  bool include(p2 l) { return dist2(p, r) < r * r + eps; }\n\n  vector<p2> intersec(Circle c) {\n    p2 diff = c.p - p;\n    double dist = dot(diff, diff);\n    double a = (dist + r * r - c.r * c.r) / 2.;\n    double D = dist * r * r - a * a;\n    if (D < eps)\n      return vector<p2>();\n    double Dsqrt = sqrt(D);\n    vector<p2> ps;\n    ps.emplace_back((a * diff.real() + diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() - diff.real() * Dsqrt) / dist + p.imag());\n    ps.emplace_back((a * diff.real() - diff.imag() * Dsqrt) / dist + p.real(),\n                    (a * diff.imag() + diff.real() * Dsqrt) / dist + p.imag());\n    return ps;\n  }\n};\n\nstruct L {\n  p2 p;\n  int i;\n};\n\nstruct N {\n  int i;\n  double d;\n};\nbool operator<(const N &l, const N &r) { return l.d < r.d; }\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n    vector<Circle> v;\n    for (int i = 0; i < n; i++) {\n      double x, y, r;\n      cin >> x >> y >> r;\n      v.push_back(Circle(p2(x, y), r));\n    }\n    vector<L> inter;\n    inter.push_back(L{p2(v[0].p), -1});\n    vector<Line> ls;\n    for (int i = 0; i < n - 1; i++) {\n      auto ps = v[i].intersec(v[i + 1]);\n      for (auto &p : ps) {\n        inter.push_back(L{p, i});\n      }\n      ls.push_back(Line(ps[0], ps[1]));\n    }\n    inter.push_back(L{p2(v[n - 1].p), n - 1});\n    int goal = inter.size() - 1;\n\n    // st: 0, ed: goal\n    multiset<N> q;\n    vector<bool> used(inter.size());\n    q.insert(N{0, 0.});\n    while (q.size() > 0) {\n      N now = *q.begin();\n      q.erase(q.begin());\n      if (used[now.i])\n        continue;\n      used[now.i] = true;\n      if (now.i == goal) {\n        printf(\"%.9lf\\n\", now.d);\n        break;\n      }\n      for (int j = 0; j < inter.size(); j++) {\n        if (now.i == j)\n          continue;\n        if (used[j])\n          continue;\n        if (abs(inter[now.i].i - inter[j].i) <= 1) {\n          q.insert(N{j, now.d + dist(inter[now.i].p, inter[j].p)});\n        } else {\n          bool ok = true;\n\n          int ii = min(inter[now.i].i, inter[j].i);\n          int jj = max(inter[now.i].i, inter[j].i);\n\n          Line l(inter[now.i].p, inter[j].p);\n          for (int k = ii + 1; k < jj; k++) {\n            if (!intersec(ls[k], l)) {\n              ok = false;\n              break;\n            }\n          }\n\n          if (ok) {\n            q.insert(N{j, now.d + dist(inter[now.i].p, inter[j].p)});\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <utility>\nusing namespace std;\n#define REP(i,n) for(int i=0; i < (n); i++)\n\n//num\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// point, line, circle\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : vector<P> {\n    L(P a, P b){ push_back(a); push_back(b);}\n};\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X != b.X)? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// vector operation\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\n//utility\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //counter clockwise\n    if(cross(b,c) <-EPS) return -1; //clockwise\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nVP crosspointCC(const C& a, const C& b){\n    VP ps;\n    P ab = b.p-a.p;\n    double dist = abs(ab);\n    if(GE(dist, a.r +b.r) || LE(dist, abs(a.r-b.r))){\n        return ps;\n    }\n    if(EQ(dist, a.r+b.r)){ //circumscribed\n        ps.push_back( a.p +ab*(a.r/dist) );\n        return ps;\n    }\n    if(EQ(dist, a.r-b.r)){ //inscribed\n        ps.push_back( a.p +ab*(a.r/dist) );\n        return ps;\n    }\n    if(EQ(dist, b.r-a.r)){\n        ps.push_back( b.p -ab*(b.r/dist) );\n        return ps;\n    }\n    double l = ((a.r*a.r -b.r*b.r)/dist +dist) /2; //|am|/|ab|\n    double n = sqrt(a.r*a.r -l*l);\n    P mid = a.p + (ab)*(l/dist); //ab/dist: unit vector\n    P hei = ab *(n/dist) *P(0,1); //orthogonal to ab\n    ps.push_back(mid+hei);\n    ps.push_back(mid-hei);\n    return ps;\n}\n\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        \n        vector<C> c;\n        for(int i=0; i<n; i++){\n            int x,y,r;\n            cin >> x >> y >> r;\n            c.push_back(C(P(x,y),r));\n        }\n\n        vector<vector<P> > cp(2); //0:left 1:right\n        vector<P> ap;\n        ap.push_back(c[0].p);\n        for(int i=0; i<(int)c.size()-1; i++){\n            vector<P> isp = crosspointCC(c[i], c[i+1]);\n            cp[0].push_back(isp[0]);\n            cp[1].push_back(isp[1]);\n            ap.push_back(isp[0]);\n            ap.push_back(isp[1]);\n        }\n        ap.push_back(c[n-1].p);\n\n        //construct graph\n        vector<vector<double> > adj(2*n, vector<double>(2*n, INF));\n        for(int i=0; i<2*n; i++){\n            adj[i][i]=0;\n        }\n        for(int s=0; s<2*n; s++){\n            for(int e=s+1; e<2*n; e++){\n                bool flag=true;\n                for(int i=(s-1)/2; i<(e-1)/2; i++){\n                    //out of leftpoints or rightpoints\n                    if(ccw(ap[s], ap[e], cp[0][i])==-1 ||\n                       ccw(ap[s], ap[e], cp[1][i])==+1){\n                        flag=false;\n                        break;\n                    }\n                }\n                if(flag){\n                    double dist = abs(ap[s]-ap[e]);\n                    adj[s][e] = dist;\n                    adj[e][s] = dist;\n                }\n            }\n        }\n\n        //search the minimum path with Dijkstra algorithm\n        priority_queue<pair<double, int> > wait;\n        vector<double> cost(2*n,INF);\n        cost[0] = 0.0;\n        wait.push(make_pair(0.0, 0));\n        while(!wait.empty()){\n            int nowpoint = wait.top().second;\n            double nowcost = -wait.top().first;\n            wait.pop();\n            if(cost[nowpoint] < nowcost){\n                continue;\n            }\n            for(int i=0; i<2*n; i++){\n                double nextcost = adj[nowpoint][i] + nowcost;\n                if(nextcost < cost[i]){\n                    cost[i]=nextcost;\n                    wait.push(make_pair(-nextcost, i));\n                }\n            }   \n        }\n\n        cout << fixed;\n        cout << setprecision(10);\n        cout << cost[2*n-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <utility>\n#include <functional>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> point;\nconst double INF = 1e10;\nconst double EPS = 1e-9;\n\n\ndouble cross(point a,point b){\n\treturn imag(conj(a)*b);\n}\n\nbool is_intersected(point a1,point a2,point b1,point b2){\n\treturn (cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS and\n\t \t(cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) < EPS));\n}\n\nvector<point> circles_point(point c1,double r1,point c2,double r2){\n\tdouble d = abs(c1-c2);\n\tdouble s = (r1+r2+d) / 2;\n\tdouble S = sqrt(s*(s-r1)*(s-r2)*(s-d));\n\tdouble h = 2 * S / d;\n\tpoint v = (c2-c1) / (abs(c2-c1));\n\n\tdouble m = sqrt(r1*r1 - h*h);\n\n\tvector<point> ret;\n\tret.push_back(c1 + m*v+h*v*point(0,1));\n\tret.push_back(c1 + m*v-h*v*point(0,1));\n\treturn ret;\n}\n\nint main(){\ncout << fixed << setprecision(10);\n \tint n;\n \twhile(cin>>n,n!=0){\n\t\tvector<vector<double> > dist(200,vector<double>(200,INF));\n\n \t\tvector<int> x(n),y(n),r(n);\n \t\tfor(int i=0;i<n;i++){\n \t\t\tcin>>x[i]>>y[i]>>r[i];\n\t\t}\n\t\tvector<point> ps(2*n);\n\n\t\tps[0] = point(x[0],y[0]);\n\t\tps.back() = point(x.back(),y.back());\n\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tvector<point> ks = circles_point(point(x[i],y[i]),r[i],point(x[i+1],y[i+1]),r[i+1]);\n\t\t\tps[2*i+1] = ks[0];\n\t\t\tps[2*i+2] = ks[1];\n\t\t\t// ps[1],ps[2]\n\t\t}\n\n \t\tfor(int i=0;i<2*n;i++){\n \t\t\tfor(int j=i;j<2*n;j++){\n \t\t\t\tif(i==j){\n \t\t\t\t\tdist[i][i]=INF;\n \t\t\t\t}else{\n\t\t\t\t\tint k = (i+1) / 2;\n\t\t\t\t\tint l = (j+1) / 2;\n\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\t// ayasii\n\t\t\t\t\tfor(int m=k+1;m<l;m++){\n\t\t\t\t\t\tif(not is_intersected(ps[2*m-1],ps[2*m],ps[i],ps[j])){\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tdist[i][j]=dist[j][i]= abs(ps[i]-ps[j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdist[i][j]=dist[j][i]= INF;\n\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n\t\t}\n\t\tpriority_queue<pair<double,int>,vector<pair<double,int> >,greater<pair<double,int> > > que;\n\t\tque.push(make_pair(0,0));\n\t\tvector<char> visited(2*n,false);\n\t\tdouble ans = INF;\n\t\twhile(not que.empty()){\n\t\t\tdouble cost;\n\t\t\tint where;\n\t\t\tcost = que.top().first;\n\t\t\twhere = que.top().second;\n\t\t\tque.pop();\n\n\t\t\tif(where == 2*n-1){\n\t\t\t\tans = cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(visited[where]) continue;\n\t\t\tvisited[where] = true;\n\t\t\tfor(int i=0;i<2*n;i++){\n\t\t\t\tque.push(make_pair(cost+dist[where][i],i));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n \t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst double EPS=1e-7;\nconst double INF=1e77;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\nbool operator<(const point<T> &a,const point<T> &b){ return a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y; }\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a,b;\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nT abs2(const point<T> &a){ return a.x*a.x+a.y*a.y; }\n\nint get_intersect(const circle<double> &C1,const circle<double> &C2,vector< point<double> > &res){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint<double> p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif(d<EPS && abs(r1-r2)<EPS){\n\t\treturn -1;\n\t}\n\telse if(r1+r2<d-EPS || d+EPS<abs(r1-r2)){\n\t\treturn 0;\n\t}\n\telse{\n\t\tdouble a=(r1*r1-r2*r2+d*d)/(2*d);\n\t\tdouble h=sqrt(max(r1*r1-a*a,0.0));\n\t\tpoint<double> tmp1=p1+a/d*(p2-p1);\n\t\tpoint<double> tmp2=h/d*(p2-p1);\n\t\tif(abs(tmp2)<EPS){\n\t\t\tres.push_back(tmp1);\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\tres.push_back((point<double>){tmp1.x-tmp2.y,tmp1.y+tmp2.x});\n\t\t\tres.push_back((point<double>){tmp1.x+tmp2.y,tmp1.y-tmp2.x});\n\t\t\treturn 2;\n\t\t}\n\t}\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ntemplate<class T>\npoint<double> proj(const point<T> &p,const line<T> &L){\n\treturn L.a+dot(p-L.a,L.b-L.a)/abs2(L.b-L.a)*(L.b-L.a);\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nint get_intersect(const circle<double> &C,const segment<double> &S,vector< point<double> > &res){\n\tpoint<double> h=proj(C.c,line<double>(S));\n\tdouble d=dist(C.c,h);\n\tif(d>C.r+EPS) return 0;\n\tif(d>C.r-EPS){\n\t\tint cnt=0;\n\t\tif(cover(S,h)) res.push_back(h), cnt++;\n\t\treturn cnt;\n\t}\n\telse{\n\t\tpoint<double> v=S.b-S.a;\n\t\tv=(sqrt(C.r*C.r-d*d)/abs(v))*v;\n\t\tint cnt=0;\n\t\tif(cover(S,h+v))  res.push_back(h+v), cnt++;\n\t\tif(cover(S,h-v))  res.push_back(h-v), cnt++;\n\t\treturn cnt;\n\t}\n}\n\nbool cover(const circle<double> &C,const point<double> &p){\n\treturn dist(C.c,p)<C.r+EPS;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tcircle<double> C[100];\n\t\trep(i,n) scanf(\"%lf%lf%lf\",&C[i].c.x,&C[i].c.y,&C[i].r);\n\t\tvector< point<double> > P;\n\t\tP.push_back(C[0].c);\n\t\tP.push_back(C[n-1].c);\n\t\trep(i,n-1) get_intersect(C[i],C[i+1],P);\n\n\t\tint m=P.size();\n\t\tstatic double d[300][300]={};\n\t\trep(i,m) rep(j,m) if(i!=j) {\n\t\t\tvector< point<double> > Q;\n\t\t\tQ.push_back(P[i]);\n\t\t\tQ.push_back(P[j]);\n\t\t\trep(k,n) get_intersect(C[k],(segment<double>){P[i],P[j]},Q);\n\t\t\tsort(Q.begin(),Q.end());\n\n\t\t\tbool ok=true;\n\t\t\trep(k,(int)Q.size()-1){\n\t\t\t\tpoint<double> c=0.5*(Q[k]+Q[k+1]);\n\t\t\t\tbool ok2=false;\n\t\t\t\trep(l,n) if(cover(C[l],c)) { ok2=true; break; }\n\t\t\t\tif(!ok2){ ok=false; break; }\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\td[i][j]=abs(P[i]-P[j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\td[i][j]=INF;\n\t\t\t}\n\t\t}\n\n\t\trep(k,m) rep(i,m) rep(j,m) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\n\t\tprintf(\"%.9f\\n\",d[0][1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\ntypedef pair<int, int> P;\n\nstruct Point{\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double norm() {return x * x + y * y; }\n    double abs() {return sqrt(norm()); }\n\n    bool operator < (const Point &p) const{\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n\n    bool operator == (const Point &p) const{\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nstruct Circle{\n    Point c;\n    double r;\n\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(cos(r) * a, sin(r) * a);\n}\n\npair<Point, Point> getCrossPointsCC(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// ベクトルと点の位置関係\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CLOCKWISE;\n    if(dot(a, b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm()) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            return 0;\n        }\n\n        vector<Circle> cir;\n        for (int i = 0; i < n; i++){\n            double x, y, r;\n            cin >> x >> y >> r;\n            cir.emplace_back(Point(x, y), r);\n        }\n\n        vector<Point> po;\n\n        po.emplace_back(cir[0].c.x, cir[0].c.y);\n\n        vector<Segment> seg;\n        for (int i = 0; i < n - 1; i++){\n            auto crosspoint = getCrossPointsCC(cir[i], cir[i + 1]);\n            po.emplace_back(crosspoint.first.x, crosspoint.first.y);\n            po.emplace_back(crosspoint.second.x, crosspoint.second.y);\n            seg.emplace_back(crosspoint.first, crosspoint.second);\n        }\n\n        po.emplace_back(cir[n - 1].c.x, cir[n - 1].c.y);\n\n        int m = po.size();\n        vector<double> dist(m, 1e9);\n        dist[0] = 0;\n\n        for (int i = 1; i < m; i++){\n            for (int j = 0; j < i; j++){\n                // from j to i\n\n                Segment s1 = {po[j], po[i]};\n\n                int nsegid = (i - 1) / 2;\n                int psegid = (j - 1) / 2;\n                int needinter = max(0, nsegid - psegid - 1);\n                if(j == 0){\n                    needinter = nsegid;\n                    psegid = -1;\n                }\n\n                int cntinter = 0;\n                for (int k = psegid + 1; k < nsegid; k++){\n                    if(intersect(s1, seg[k])){\n                        cntinter++;\n                    }\n                }\n\n                if(needinter == cntinter){\n                    double cdist = abs(po[i] - po[j]);\n                    dist[i] = min(dist[i], dist[j] + cdist);\n                }\n            }\n        }\n\n        printf(\"%.10f\\n\", dist[m - 1]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Circle> Cir(n);\n\t\tPoint s, t;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tint x, y, r; cin >> x >> y >> r;\n\t\t\tif (i == 0)s = Point(x, y);\n\t\t\tif (i == n - 1) t = Point(x, y);\n\t\t\tCir[i] = Circle(Point(x, y), r);\n\t\t}\n\t\tvector<Point> ps;\n\t\tps.push_back(s);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tauto temp_p = is_cc(Cir[i - 1], Cir[i]);\n\t\t\tfor (auto p : temp_p) {\n\t\t\t\tps.push_back(p);\n\t\t\t}\n\t\t}\n\t\tps.push_back(t);\n\n\t\tint Size = ps.size();\n\t\tvector<vector<ld>> dist(Size, vector<ld>(Size, INF));\n\t\tfor (int i = 0; i < Size - 1;i++) {\n\t\t\tint idx;\n\t\t\tif (i == 0)idx = 1;\n\t\t\telse idx = 2 * ((i + 1) / 2) + 1;\n\t\t\tPoint v1 = ps[idx] - ps[i], v2 = ps[min(idx + 1, Size - 1)] - ps[i];\n\t\t\tld arg1 = arg(v1), arg2 = arg(v2);\n\t\t\tif (arg1 < arg2) swap(arg1, arg2);\n\t\t\tdist[i][idx] = abs(v1); dist[i][min(idx + 1, Size - 1)] = abs(v2);\n\n\t\t\tfor (int j = idx + 2; j < Size;j++) {\n\t\t\t\tPoint v3 = ps[j] - ps[i];\n\t\t\t\tld arg3 = arg(v3);\n\n\t\t\t\tif (j % 2 == 1 && arg3 < arg2)break;\n\t\t\t\telse if (j % 2 == 0 && arg3 > arg1)break;\n\t\t\t\t\n\t\t\t\tif (arg3 > arg1 || arg3 < arg2) { continue; }\n\t\t\t\tdist[i][j] = abs(v3);\n\t\t\t\tif (j % 2 == 1) { arg1 = min(arg1, arg3); }\n\t\t\t\telse { arg2 = max(arg2, arg3); }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Size;i++) {\n\t\t\tfor (int j = 0; j < Size;j++) {\n\t\t\t\tfor (int k = 0; k < Size;k++) {\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << dist[0][Size - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Circle> Cir(n);\n\t\tPoint s, t;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tint x, y, r; cin >> x >> y >> r;\n\t\t\tif (i == 0)s = Point(x, y);\n\t\t\tif (i == n - 1) t = Point(x, y);\n\t\t\tCir[i] = Circle(Point(x, y), r);\n\t\t}\n\t\tvector<Point> ps;\n\t\tps.push_back(s);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tauto temp_p = is_cc(Cir[i - 1], Cir[i]);\n\t\t\tfor (auto p : temp_p) {\n\t\t\t\tps.push_back(p);\n\t\t\t}\n\t\t}\n\t\tps.push_back(t);\n\t\t/*for (auto p : ps) {\n\t\t\tcout << p << endl;\n\t\t}*/\n\t\tint Size = ps.size();\n\t\tvector<vector<ld>> dist(Size, vector<ld>(Size, INF));\n\t\t//vector<vector<int>> can_use(Size, vector<int>(Size, 0));\n\t\tfor (int i = 0; i < Size - 1;i++) {\n\t\t\tint idx;\n\t\t\tif (i == 0)idx = 1;\n\t\t\telse idx = 2 * ((i + 1) / 2) + 1;\n\t\t\tPoint v1 = ps[idx] - ps[i], v2 = ps[min(idx + 1, Size - 1)] - ps[i];\n\t\t\tld arg1 = arg(v1), arg2 = arg(v2);\n\t\t\tdist[i][idx] = abs(v1); dist[i][min(idx + 1, Size - 1)] = abs(v2);\n\t\t\t//can_use[i][idx] = can_use[i][min(idx + 1, Size - 1)] = 1;\n\t\t\t//cout << \"------------------------\" << endl;\n\t\t\tint f = 0;\n\t\t\tfor (int j = idx + 2; j < Size;j++) {\n\t\t\t\tif (f > 5)break;\n\t\t\t\tPoint v3 = ps[j] - ps[i];\n\t\t\t\tld arg3 = arg(v3);\n\t\t\t\tif (arg3 > arg1 || arg3 < arg2) { f++; continue; }\n\t\t\t\tf = 0;\n\t\t\t\tdist[i][j] = abs(v3); //can_use[i][j] = 1;\n\t\t\t\tif (j % 2 == 1) { arg1 = min(arg1, arg3); }\n\t\t\t\telse { arg2 = max(arg2, arg3); }\n\t\t\t\t//cout << i << \" \" << j << endl;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < Size;i++) {\n\t\t\tfor (int j = 0; j < Size;j++) {\n\t\t\t\tfor (int k = 0; k < Size;k++) {\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << dist[0][Size - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nstruct coordinate {\n\tdouble x, y;\n\tcoordinate() {}\n\tcoordinate(double a, double b) {\n\t\tx = a; y = b;\n\t}\n};\n\nstruct circle {\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coordinate a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coordinate,coordinate> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coordinate,coordinate> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coordinate(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coordinate(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\treturn ret;\n}\n\nbool cross_lseg(coordinate a_start, coordinate a_end, coordinate b_start, coordinate b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\ndouble distance(coordinate a, coordinate b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coordinate,coordinate> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coordinate(v[0].x, v[0].y), coordinate(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coordinate,coordinate> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(make_pair(coordinate(v[v.size() - 1].x, v[v.size() - 1].y), coordinate(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoordinate start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoordinate end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst double EPS = 1e-12;\nconst double INF = 1e12;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\ntypedef complex<double> P;\nconst int MAX_N = 105;\n#define DEBUG\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nvector<P> crosspointCC(const C &c1, const C &c2){\n  vector<P> res;\n  double d = abs(c1.p - c2.p);\n  double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  double dfr = c1.r * c1.r - rc * rc;\n  if(EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return res;\n  double rs = sqrt(dfr);\n\n  P diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * P(rc, rs));\n  res.push_back(c1.p + diff * P(rc, -rs));\n  return res;\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ndouble dist(P &a, P &b, vector<L> &ls, int s, int t){\n  L l = L(a, b);\n  FOR(i, s, t) if(!intersectSS(l, ls[i])) return INF;\n  return abs(a - b);\n}\n\nint main() {\n  int N;\n  while(cin >>N && N){\n    vector<P> ps;\n    vector<L> ls;\n    int bx, by, br, x, y, r;\n    scanf(\"%d %d %d\", &bx, &by, &br);\n    ps.push_back(P(bx, by));\n    FOR(i, 1, N){\n      scanf(\"%d %d %d\", &x, &y, &r);\n      vector<P> cs = crosspointCC(C(P(bx, by), br), C(P(x, y), r));\n      REP(j, cs.size()) ps.push_back(cs[j]);\n      ls.push_back(L(cs[0], cs[1]));\n      bx = x;\n      by = y;\n      br = r;\n    }\n    ps.push_back(P(bx, by));\n    int psize = ps.size();\n    vector< vector<double> > d(psize, vector<double>(psize, INF));\n    REP(i, psize) FOR(j, i + 1, psize) d[i][j] = d[j][i] = dist(ps[i], ps[j], ls, (i + 1 == psize ? (int)ls.size() : (i - 1) / 2), (j + 1 == psize ? (int)ls.size() : (j - 1) / 2 + 1));\n    vector<double> dp(psize, INF);\n    dp[0] = 0.0;\n    REP(i, psize){\n      if(dp[i] == INF) continue;\n      FOR(j, i + 1, psize){\n        if(d[i][j] == INF) continue;\n        dp[j] = min(dp[j], dp[i] + d[i][j]);\n      }\n    }\n    printf(\"%.6lf\\n\", dp[psize - 1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n\nconst double EPS = 1e-8;\ninline double dot(P a, P b) {return real( conj(a)*b);}\ninline double cross(P a, P b) {return imag( conj(a)*b);}\ninline double sq(double x) {return x * x;}\ninline int signum(double x) {return x > EPS ? +1 : x < -EPS ? -1 : 0;} // 未検証\n\nstruct C : public P {\n  double r;\n  C() {}\n  C(const P &p,double r):P(p),r(r){}\n};\n\n// 2円の交点\nvector<P> IntersectionCC(const C& c1, const C& c2) {\n  vector<P> ret;\n  double d = abs(c1 - c2);\n  P diff = (c2 - c1) / d;\n  if( c1.r + c2.r < d - EPS ) {                        // 離れていて交点0\n\n  } else if( d < EPS && abs(c1.r - c2.r) < EPS ) {     // 2円が重なる\n\n  } else if( abs( c1.r + c2.r - d ) < EPS ) {          // 外側で1点で接する\n      ret.push_back( c1 + diff * c1.r );\n  } else if( abs( c1.r - c2.r ) > d + EPS ) {          // 内側に含む。交点0\n\n  } else if( abs( abs( c1.r - c2.r ) - d ) < EPS) {    // 内側で1点で接する\n      ret.push_back( c1 + diff * c1.r );\n  } else {                                            // 2点で交わる\n//     assert( d < c1.r + c2.r );\n      double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n      double rs = sqrt(c1.r*c1.r - rc*rc);\n\n      ret.push_back( c1 + diff * P(rc, -rs) );\n      ret.push_back( c1 + diff * P(rc, rs) );\n  }\n  return ret;\n}\n\nbool IsIntersectSP(P a, P b, P c) {\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\nbool IsIntersectLL(P a,P b,P c,P d){\n  return abs(cross(b-a, d-c)) > EPS || // non-parallel\n      abs(cross(b-a, c-a)) < EPS;   // same line\n}\nP IntersectionLL(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\ndouble DistanceLP(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// ベクトルpをベクトルbに射影したベクトルを計算する\nP proj(P p, P b) {\n  return b * dot(p,b) / norm(b);\n}\n\n// 点pから直線abに引いた垂線の足となる点を計算する\nP FootOfLP(P a, P b, P p){\n  return a + proj(p-a,b-a);\n}\n\n\n// 直線abと円cの交点をvectorで返す\nvector<P> IntersectionLC(P a, P b, C c){\n  double dist = DistanceLP(a,b,c);\n  vector<P> ret;\n  if( abs(dist - c.r) < EPS ) {\n      ret.push_back( FootOfLP(a,b,c) );\n  } else if( dist < c.r ) {\n      P m = FootOfLP(a,b,c);\n      P u = (b-a) / abs(b-a);\n      double t = sqrt( c.r * c.r - dist * dist );\n      ret.push_back( m + t * u );\n      ret.push_back( m - t * u );\n  }\n  return ret;\n}\n\n\nint N;\nvector<C> c;\nvector<P> p;\n\nbool canSee(P a, P b) {\n\n  {\n      P m = (a + b) / 2.0;\n\n      int in = 0;\n      for (int j = 0; j < c.size(); j++) {\n          double d = abs(c[j] - m);\n          if (d < c[j].r - EPS) {\n              in++;\n          }\n          if (d < c[j].r + EPS) {\n              in++;\n          }\n      }\n      if (in <= 1) return false;\n  }\n\n  REP(i, c.size()) {\n      vector<P> cur = IntersectionLC(a, b, c[i]);\n      for (int j = 0; j < cur.size(); j++) {\n          if (IsIntersectSP(a, b, cur[j])) {\n              P m = cur[j];\n\n              int in = 0;\n              for (int j = 0; j < c.size(); j++) {\n                  double d = abs(c[j] - m);\n                  if (d < c[j].r - EPS) {\n                      in++;\n                  }\n                  if (d < c[j].r + EPS) {\n                      in++;\n                  }\n              }\n              if (in <= 1) return false;\n\n          }\n      }\n  }\n\n  return true;\n}\n\nint psize;\ndouble dist[512][512];\n\nint main() {\n  for (; cin >> N && N; ) {\n      c.clear();\n      p.clear();\n      REP(i,N) {\n          int x, y, r; cin >> x >> y >> r;\n          c.push_back(C(P(x,y), r));\n      }\n      p.push_back(c[0]);\n      p.push_back(c[N-1]);\n\n      REP(i, N) {\n          REP(j, i) if ( abs(i - j) <= 2) {\n              double d = abs(c[i] - c[j]);\n              if(c[i].r + c[j].r <= d + EPS) {\n\n              } else {\n                  vector<P> m = IntersectionCC(c[i], c[j]);\n                  for (int i = 0; i < m.size(); i++)\n                      p.push_back(m[i]);\n              }\n          }\n      }\n\n      psize = p.size();\n      REP(i, psize) {\n          REP(j, i) {\n              if (canSee(p[i], p[j])) {\n                  dist[i][j] = dist[j][i] = abs(p[i] - p[j]);\n              } else {\n                  dist[i][j] = dist[j][i] = 1001001001;\n              }\n          }\n      }\n\n      REP(k, psize) REP(i, psize) REP(j, psize) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n      }\n\n//       cout << \"d\" << endl;\n\n//       cout << \"---\" << endl;\n//       REP(k, psize) {\n//           if (abs(-dist[0][1] + dist[0][k] + dist[k][1]) < EPS)\n//               cout << p[k] << endl;\n//       }\n\n      printf(\"%.8f\\n\", dist[0][1]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define SZ(v) ((int) (v).size())\nconst double ESP = 1e-8;\n\ndouble sqr(double a) {\n\treturn a * a;\n}\n\nint sgn(const double x) {\n\treturn (int) (x > ESP) - (x < -ESP);\n}\n\nstruct Circle {\n\tint x, y, r;\n} c[105];\n\nstruct Point {\n\tdouble x, y;\n} p[2][105];\n\nint path1[105], path2[105];\n\ndouble ans;\n\ndouble dist(const Point & A, const Point & B) {\n\treturn sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));\n}\n\ndouble dist(const Circle & A, const Circle & B) {\n\treturn sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));\n}\n\nvoid getPoint(Circle A, Circle B, Point &ia,Point &ib) {\n    double dd = dist(A, B);\n    double k, a, b, d, aa, bb, cc, c, drt;\n    k = A.r;\n    a = B.x - A.x;\n    b = B.y - A.y;\n    c = B.r;\n    d = sqr(c) - sqr(k) - sqr(a) - sqr(b);\n    \n    aa = 4 * sqr(a) + 4 * sqr(b);\n    bb = 4 * b * d;\n    cc = sqr(d) - 4 * sqr(a) * sqr(k);\n    \n    drt = sqr(bb) - 4 * aa * cc;\n    drt = sqrt (drt);\n    ia.y = (-bb + drt) / 2.0 / aa;\n    ib.y = (-bb - drt) / 2.0 / aa;\n    if (abs (a) < ESP)\n    {\n        ia.x = sqrt (sqr (k) - sqr (ia.y));\n        ib.x = -ia.x;\n    }\n    else\n    {\n        ia.x = (2 * b * ia.y + d) / -2 / a;\n        ib.x = (2 * b * ib.y + d) / -2 / a;\n    }\n    ia.x += A.x;\n    ia.y += A.y;\n    ib.x += A.x;\n    ib.y += A.y;\n}\n\nint main() {\n\tint n, i;\n\twhile(1) {\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tfor(i=0; i<n; i++) {\n\t\t\tscanf(\"%d%d%d\", &c[i].x, &c[i].y, &c[i].r);\n\t\t}\n\t\tp[0][0].x = p[1][0].x = c[0].x;\n\t\tp[0][0].y = p[1][0].y = c[0].y;\n\t\tp[0][n-1].x = p[1][n-1].x = c[n-1].x;\n\t\tp[0][n-1].y = p[1][n-1].y = c[n-1].y;\n\t\tfor(i=0; i<n-1; i++) {\n\t\t\tgetPoint(c[i], c[i+1], p[0][i+1], p[1][i+1]);\n\t\t}\n\t\t//printf(\"%lf %lf\\n%lf %lf\\n%lf %lf\\n%lf %lf\\n\", p[0][0].x, p[0][0].y, p[1][0].x, p[1][0].y, p[0][1].x, p[0][1].y, p[1][1].x, p[1][1].y);\n\t\t\n\t\tdouble pathlen1 = 0.0, pathlen2 = 0.0;\n\t\tdouble t1, t2;\n\t\tfor(i=0; i<n; i++) {\n\t\t\tt1 = dist(p[0][i], p[0][i+1]);\n\t\t\tt2 = dist(p[1][i], p[0][i+1]);\n\t\t\t//printf(\"t1=%lf\\tt2=%lf\\n\", t1, t2);\n\t\t\tif(sgn( pathlen1 + t1 - pathlen2 - t2 ) <= 0 ) {\n\t\t\t\tpathlen1 = pathlen1 + t1;\n\t\t\t\tpath1[i] = 0;\n\t\t\t} else {\n\t\t\t\tpathlen1 = pathlen2 + t2;\n\t\t\t\tpath1[i] = 1;\n\t\t\t}\n//\t\t\tprintf(\"%lf\\n\", pathlen1);\n\t\t}\n\t\tfor(i=0; i<n; i++) {\n\t\t\tt1 = dist(p[0][i], p[1][i+1]);\n\t\t\tt2 = dist(p[1][i], p[1][i+1]);\n\t\t\tif(sgn( pathlen1 + t1 - pathlen2 - t2 ) <= 0 ) {\n\t\t\t\tpathlen2 = pathlen1 + t1;\n\t\t\t\tpath2[i] = 0;\n\t\t\t} else {\n\t\t\t\tpathlen2 = pathlen2 + t2;\n\t\t\t\tpath2[i] = 1;\n\t\t\t}\t\n\t\t}\n//\t\tprintf(\"%lf\\n\", pathlen1);\n\t\tif(pathlen1 > pathlen2) {\n\t\t\tfor(i=0; i<n; i++)\n\t\t\t\tpath1[i] = path2[i];\n\t\tpathlen1 = pathlen2;\n\t\t}\n\t\t//for(i=0; i<n; i++) {\n\t\t\t\n\t\t\t\n\t\t//}\n\t\tprintf(\"%lf\\n\", pathlen1);\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<complex>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\n\n\ntypedef complex<double> Point;\ntypedef pair<int,double> pid;\n\nclass Line{\n\tpublic:\n\tdouble A,B,C;\n\tLine(double A,double B,double C):A(A),B(B),C(C){}\n\tLine(){}\n};\nclass Circle : public Point{\n\tpublic:\n\tdouble R;\n\tCircle(Point pt, double R):Point(pt),R(R){}\n\tCircle(){}\n};\ndouble Dot(Point p1, Point p2){return p1.X*p2.X + p1.Y*p2.Y;}\ndouble Cross(Point p1, Point p2){return p1.X*p2.Y - p1.Y*p2.X;}\n\nbool CircleHit(Circle a, Circle b){return abs(a-b) <= a.R + b.R;}\n\nLine CircleCommonLine(Circle a,Circle b){\n\tdouble C = pow(b.R, 2)-pow(a.R, 2)+norm(a)-norm(b);\n\treturn Line(2*(b.X-a.X), 2*(b.Y-a.Y), C);\n}\n\npair<Point,Point> Suisen(Line line, Point pt){\n\tPoint v(line.A, line.B);  v/=Point(abs(v),0);\n\tPoint toPoint;\n\t\n\tif(line.B!=0){\n\t\tPoint slide = pt-Point(0, -line.C/line.B);\n\t\ttoPoint = v*Point(Dot(v,slide),0);\n\t}else{\n\t\ttoPoint = Point(pt.X + line.C/line.A, 0);\n\t}\n\treturn pair<Point,Point>(pt-toPoint, toPoint);\n}\n\npair<Point,Point> CircleCross(Circle a, Circle b){\n\tLine commonLine = CircleCommonLine(a,b);\n\tpair<Point,Point> s = Suisen(commonLine, a);\n\t\n\tdouble d = abs(s.second);\n\tif(d!=0){\n\t\tPoint e = s.second*Point(0,1)/d;\n\t\tif(a.R<d)d=a.R;\n\t\tdouble dist = sqrt(a.R*a.R - d*d);\n\t\treturn pair<Point,Point>(s.first+e*Point(dist,0), s.first+e*Point(-dist,0));\n\t}\n\treturn pair<Point,Point>(s.first-Point(0,a.R), s.first+Point(0,a.R));\n}\n\nbool ccw(Point p1, Point p2, Point p3){\n\tdouble ret = Cross(p2-p1, p3-p1);\n\t//cout<<\"ccw \"<<(p2-p1)<<\" \"<<(p3-p1)<<\" \"<<ret<<endl;\n\treturn ret>=0;\n}\n\nconst int N = 222;\ntypedef pair<int,double> pid;\n\nint n;\nCircle cir[N];\n\nvector<pid> edge[N];\npair<Point,Point> cross[N];\n\nvoid init(){\n\trep(i,N){\n\t\tedge[i].clear();\n\t\tcir[i] = Circle();\n\t\tcross[i] = pair<Point,Point>(Point(),Point());\n\t}\n}\n\nvoid setCross(){\n\trep(i,n-1){\n\t\tcross[i] = CircleCross(cir[i],cir[i+1]);\n\t}\n\trep(i,n-1){\n\t\tif(!ccw(cir[i], cross[i].first, cross[i].second)){\n\t\t\tswap(cross[i].first, cross[i].second);\n\t\t}\n\t}\n\t/*\n\trep(i,n-1){\n\t\tcout<<\"cross \"<<cross[i].first<<\" \"<<cross[i].second<<endl;\n\t}*/\n}\n\nbool canAdd(Point pt, Point pt2, int from, int to){\n\tif(from<0)from=0;\n\treps(i,from,to){\n\t\tif(!ccw(pt, pt2, cross[i].second))return false;\n\t}\n\treps(i,from,to){\n\t\tif(ccw(pt, pt2, cross[i].first))return false;\n\t}\n\treturn true;\n}\n\nvoid addEdge(Point pt,int num, int now){\n\treps(i,now+1,n){\n\t\tif(i!=n-1){\n\t\t\tif(canAdd(pt, cross[i].second, now+1, i)){\n\t\t\t\tedge[num].push_back(pid(i*2, abs(cross[i].second-pt)));\n\t\t\t}\n\t\t\tif(canAdd(pt, cross[i].first, now+1, i)){\n\t\t\t\tedge[num].push_back(pid(i*2+1, abs(cross[i].first-pt)));\n\t\t\t}\n\t\t}else{\n\t\t\tif(canAdd(pt, cir[n-1], now+1, n-1)){\n\t\t\t\tedge[num].push_back(pid(n*2, abs(cir[n-1]-pt)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid makeEdge(){\n\t\n\treps(i,-1,n-1){\n\t\tif(i==-1){\n\t\t\taddEdge(cir[0],n*2-1,i);\n\t\t}else{\n\t\t\taddEdge(cross[i].first,i*2+1, i);\n\t\t\taddEdge(cross[i].second,i*2, i);\n\t\t}\n\t}\n}\n\nclass P{\n\tpublic:\n\tint now;\n\tdouble val;\n\tP(int now,double val):now(now),val(val){}\n\tbool operator<(const P& a)const{\n\t\treturn val>a.val;\n\t}\n};\ndouble dijkstra(){\n\t\n\t/*\n\trep(i,n*2+2){\n\t\tprintf(\"i(%d) :: \",i);\n\t\trep(j,edge[i].size()){\n\t\t\tprintf(\"(%d,%lf)\",edge[i][j].first, edge[i][j].second);\n\t\t}puts(\"\");\n\t}*/\n\t\n\tpriority_queue<P> que;\n\tque.push(P(n*2-1, 0));\n\t\n\tint visit[N]={0};\n\twhile(1){\n\t\tif(que.empty())break;\n\t\t\n\t\tP u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(u.now==n*2)return u.val;\n\t\tif(visit[u.now]==1)continue;\n\t\tvisit[u.now]=1;\n\t\t\n\t\t//printf(\"ijk %d %lf\\n\",u.now,u.val);\n\t\trep(i,edge[u.now].size()){\n\t\t\tpid e = edge[u.now][i];\n\t\t\tque.push(P(e.first, u.val+e.second));\n\t\t}\n\t}\n\treturn -1;\n}\n\ndouble solve(){\n\tinit();\n\t\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tcir[i] = Circle(Point(a,b),c);\n\t}\n\t\n\tsetCross();\n\tmakeEdge();\n\t\n\treturn dijkstra();\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%.9lf\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n\nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n  };\n\n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n};\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\nstruct node{\n  double cost;\n  P pos;\n  int nowy, nowx;\n  bool operator < (const node &left) const {\n    return cost > left.cost;\n  }\n};\ntypedef pair< int, int > POS;\ntypedef pair< double, P > PS;\n\nint main(){\n  int n;\n  C prev, now;\n  S seg[101];\n  bool used[101][101];\n\n  while(scanf(\"%d\", &n), n){\n    scanf(\"%lf %lf %lf\", &prev.p.x, &prev.p.y, &prev.r);\n    seg[0] = S( prev.p, prev.p);\n    for(int i = 1; i < n; i++){\n      scanf(\"%lf %lf %lf\", &now.p.x, &now.p.y, &now.r);\n      Geometory::PointPoint pp = geo.Crosspoint( prev, now);\n      seg[i] = S(pp.first,pp.second);\n      prev = now;\n    }\n    seg[n] = S( prev.p, prev.p);\n\n    priority_queue< node > que;\n    que.push((node){ 0, seg[0].a, 0, 0});\n    memset( used, false, sizeof used);\n    double ret;\n    while(!que.empty()){\n      node p = que.top(); que.pop();\n      if(p.nowy == n){ ret = p.cost; break; }\n      if(used[p.nowy][p.nowx]++) continue;\n      for(int i = p.nowy + 1; i <= n; i++){\n        S s1 = S( p.pos, seg[i].a), s2 = S( p.pos, seg[i].b);\n        bool flag1 = true, flag2 = true;\n        for(int j = i - 1; j > p.nowy; j--){\n          if(!geo.Intersect( s1, seg[j])){\n            flag1 = false;\n            break;\n          }\n        }\n        for(int j = i - 1; j > p.nowy; j--){\n          if(!geo.Intersect( s2, seg[j])){\n            flag2 = false;\n            break;\n          }\n        }\n        if(flag1) que.push((node){ p.cost + (s1.a - s1.b).abs(), s1.b, i, 0});\n        if(flag2) que.push((node){ p.cost + (s2.a - s2.b).abs(), s2.b, i, 1});\n      }\n    }\n    printf(\"%.7lf\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define range(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef struct {P s,t;} L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef vector <C> VC;\n\nconst D eps=1.0e-10;\nconst D pi=acos(-1.0);\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\n//template<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\ntemplate<class T> int sig(T a,T b = 0) {return a < b ? -1 : b > a ? 1 : 0;}\n#define X real()\n#define Y imag()\n\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sq(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.t-l.s;}\ninline P input(){D x,y;cin >> x >> y; return P(x,y);}\n//??\\??? ???????????¬????????¨???\n\n\n// ??? not verify\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ??????\nP rot (P base, P a, D theta){\n\tP tar=a-base;return base+polar(abs(tar), arg(tar)+theta );\n}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P b,P p){ return b*ip(b,p)/norm(b);}\nP proj(L l,P p){ return l.s+proj(vec(l),p-l.s);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ???????????? verify AOJ CGL_1_C\nenum CCW{\n\tLEFT = 1,\n\tRIGHT = 2,\n\tBACK = 4,\n\tFRONT = 8,\n\tMID = 16,\n\tON=FRONT|BACK|MID\n};\n\ninline int ccw(P base, P a, P b) {              //???a??¨???b???????????????????????????\n\ta -= base; b -= base;\n\tif (ep(a, b) > 0)\n\t\treturn LEFT;    // counter clockwise\n\tif (ep(a, b) < 0)\n\t\treturn RIGHT;   // clockwise\n\tif (ip(a, b) < 0)\n\t\treturn BACK;    // b--base--a on line\n\tif (norm(a) < norm(b))\n\t\treturn FRONT;   // base--a--b on line\n\t// otherwise\n\treturn MID;      // base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????? ??´???\n// verify AOJ CGL_2_A\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ?????¨??´?????¨????????¢??£??????????????? (s??????????????????????????§?????????????¨±?????????)\nB iLL(L a,L b){return !ipar(a,b);}\n\nB eqL(L a,L b){return !iLL(a, b) && ep(vec(a), b.s - a.s)==0;}\nB iLS(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) <= 0;}\nB iLSs(L a,L b){return sig(ep(vec(a),b.s-a.s))*sig(ep(vec(a),b.t-a.s)) < 0;}\n\n// ????????¨?????????????????????\n// verify AOJ CGL_2_B\nB iSS(L a,L b){\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a,L b) {\n\tint cwa = ccw(a.s,a.t, b.s) | ccw(a.s,a.t, b.t);\n\tint cwb = ccw(b.s,b.t, a.s) | ccw(b.s,b.t, a.t);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ??????\n// verify AOJ CGL_2_C\nP pLL(L a,L b){ return a.s+vec(a)*ep(vec(b),b.s-a.s)/ep(vec(b),vec(a));}\n\n// ?????¨??´???????????¢\nD dLP(L l,P p){return abs( ep(vec(l),p-l.s) )/abs(vec(l));}\n// ?????¨??????????????¢\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.s)) <= 0) return abs(p - s.s);\n\tif (sig( ip(-vec(s), p - s.t)) <= 0) return abs(p - s.t);\n\treturn dLP(s,p);\n}\n\n// ??´?????¨??´???????????¢\nD dLL(L a,L b){ return iLL(a,b)?0:dLP(a,b.s);}\n\n// ?????¨??´?????¨????????¢??£????????¢\nD dLS(L a,L b){ return iLS(a,b)?0:min(dLP(a, b.s),dLP(a, b.t));}\n\n// ????????¨??????????????¢\n// verify AOJ CGL_2_D\nD dSS(L a,L b){ return iSS(a,b)?0:\n\tmin({ dSP(a,b.s),dSP(a,b.t),dSP(b,a.s),dSP(b,a.t)});\n}\n\n\n// ??????????????????\ninline B cmp_x(const P &a,const P &b){\n\treturn (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;\n}  // base x\ninline B cmp_y(const P &a,const P &b){\n\treturn (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;\n}  // base y\ninline B cmp_a(const P &a,const P &b){\n\treturn (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);\n} // base arg\n\n// ????§???¢\n\n// ??¢???\n// Verify AOJ 1100\n// verify CGL_3_A\nD area(VP pol){\n\tint n=pol.size();\n\tD sum=0.0;\n\trep(i,n){\n\t\tD x=pol[i%n].X-pol[(i+1)%n].X;\n\t\tD y=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=x*y;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢?????????\n// verify CGL_3_B\nB is_convex(VP pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tP prev=pol[(i+n-1)%n];\n\t\tP next=pol[(i+1)%n];\n\t\tif(ccw(prev,pol[i],next)==RIGHT) return false;\n\t}\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????)\n//verify AOJ CGL_3-C\nint in_polygon(VP pol,P p){\n\tint n=pol.size();\n\tint res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==MID)\n\t\t\treturn 1;\n\t\tD vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n\t\tD dx=pol[(i+1)%n].X-pol[i].X;\n\t\tif((pol[i].Y<=p.Y)&&(p.Y< pol[(i+1)%n].Y)&&(p.X<pol[i].X+vt*dx))res++;\n\t\tif((pol[i].Y> p.Y)&&(p.Y>=pol[(i+1)%n].Y)&&(p.X<pol[i].X+vt*dx))res--;\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????)\n// Verify AOJ 2514\n\nbool in_polygon(VP pol,L l){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar={pol[i],pol[(i+1)%n]};\n\t\tif(iSS(l,tar))\n\t\t\tcheck.push_back(pLL(l,tar));\n\t}\n\n\tcheck.push_back(l.s);\n\tcheck.push_back(l.t);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m)) return false;\n\t}\n\treturn true;\n}\n\n\n// convex_hull\n// Verify AOJ 0063\n// Verify AOJ CGL_4_A\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tVP res(2*n);\n\n\t//??\\??????while?????????????????????\n\t//????????????????????????????????????????????´??????<=0\n\t//???????????????????????????????????????????????´??????<0\n\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// ????????????\n// verify AOJ CGL_4_C\nVP convex_cut(const VP& pol, const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i], b = pol[(i+1)%n];\n\t\tif(ccw(l.s, l.t, a) != RIGHT) res.push_back(a);\n\t\tif((ccw(l.s, l.t, a)|ccw(l.s, l.t, b))==(LEFT|RIGHT))\n\t\t\tres.push_back(pLL({a,b}, l));\n\t}\n\treturn res;\n}\n\n// ???\n// Verify AOJ 1183\n\nenum RCC{\n\tA_IN_B=1,\n\tB_IN_A=2,\n\tA_ON_B=4,\n\tB_ON_A=8,\n\tISC=16,\n\tON_OUT=32,\n\tOUT=64,\n\tSAME=12,\n\tONS=48\n};\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n// ?????¢??£???????????????\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCS(C c, L l) {return sig(c.r, dSP(l, c.c)) >= 0;}\nbool iCSc(C c, L l) {return iCS(c, l) && sig(c.r, max(abs(l.s - c.c), abs(l.t - c.c))) <= 0;}\n\n//2??????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.push_back(a.c+P(a.r,0));\n\t\tres.push_back(a.c+P(-a.r,0));\n\t\tres.push_back(a.c+P(0,a.r));\n\t\tres.push_back(a.c+P(0,-a.r));\n\t}else{\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (norm(d) + norm(a.r) - norm(b.r)) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c);\n\t\tif(rel==ISC){ // 2points\n\t\t\tP w = e * P(0, 1) * sq(norm(a.r)-norm(x));\n\t\t\tres.push_back(a.c + e * x - w);\n\t\t\tres.push_back(a.c + e * x + w);\n\t\t}else if(rel&ONS){ // 1points\n\t\t\tres.push_back(a.c + e * x);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l,c.c);\n\tP e = vec(l) / abs(vec(l)) * sq(norm(c.r) - norm(h - c.c));\n\tres.push_back(h - e);\n\tres.push_back(h + e);\n\treturn res;\n}\n\n\n// ????????\\???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n\n// ????????±?????\\???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tP ba=b.c-a.c;\n\tD d=ang(ba);\n\tD i=acos((a.r+b.r)/abs(ba));\n\tD o=acos((a.r-b.r)/abs(ba));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//??±????????\\???\n\t\tres.push_back(tanC(a,d+i));\n\t\tres.push_back(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ??±????????\\???\n\t\tres.push_back(tanC(a,d+o));\n\t\tres.push_back(tanC(a,d-o));\n\t}\n\n\tif(r&ONS) res.push_back(tanC(a,d)); //??\\????????±???????????\\???\n\n\tif(r==SAME) rep(i,5) res.push_back(tanC(a,i));\n\treturn res;\n}\n\n\nconst int vmax=1010;\nstruct node{int to;D cost;};\n// segments arrangement\nvector<node> graph[vmax];\nvoid sArr(const vector<L> &seg, vector<P> &point){\n\trep(i,seg.size()){\n\t\tpoint.push_back(seg[i].s);\n\t\tpoint.push_back(seg[i].t);\n\t\trange(j,i+1,seg.size()){\n\t\t\tif (iSS(seg[i],seg[j]))\n\t\t\t\tpoint.push_back( pLL(seg[i],seg[j]));\n\t\t}\n\t}\n\tsort(point.begin(),point.end(),cmp_x);\n\tpoint.erase(unique(point.begin(),point.end(),cmp_x), point.end());\n\n\trep(i,seg.size()){\n\t\tvector< pair<D, int> > list;\n\t\trep(j,point.size())\n\t\t\tif (ccw(seg[i].s,seg[i].t, point[j])==MID)\n\t\t\t\tlist.push_back(make_pair(norm(seg[i].s-point[j]), j));\n\t\tsort(list.begin(),list.end());\n\t\trange(j,1,list.size()){\n\t\t\tint a = list[j-1].second, b = list[j].second;\n\t\t\tgraph[a].push_back( {b, abs(point[a]-point[b])} );\n\t\t\tgraph[b].push_back( {a, abs(point[a]-point[b])} );\n\t\t}\n\t}\n}\n\n\n\n// under not verify\n\n// ????????????????????????\n/*\nvector<L> merge(vector<L> lines) {\n\trep(i,lines.size())\n\t\tif(lines[i].t < lines[i].s)\n\t\t\tswap(lines[i].s, lines[i].t);\n\tsort(lines.begin(),lines.end());\n\trep(i,lines.size())rep(j,i){\n\t\tif (iSS(lines[i],lines[j])&&!iSSs(lines[i],lines[j])){\n\t\t\tif(abs(lines[i].t-lines[j].s) > abs(vec(lines[j])))\n\t\t\t\tlines[j].t = lines[i].t;\n\t\t\tlines.erase(lines.begin() + i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lines;\n}\n*/\n\n// ???????????£??¨????????°?\n// ????§???¢???????????????????????????????????????\nVP normalize_polygon(VP pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tP prev=pol[(i+n-1)%n];\n\t\tP next=pol[(i+1)%n];\n\t\tif(ccw(prev,pol[i],next)==MID)\n\t\t\tpol.erase(pol.begin() + i--);\n\t}\n\treturn pol;\n}\n\n\nL bisector(P a, P b) {\n  P mid=(a+b)*P(0.5,0);\n  return L{mid, mid+(b-a)*P(0, pi/2)};\n}\n\nVP voronoi_cell(VP pol,VP v, int s) {\n  rep(i, v.size()) if(i!=s) pol = convex_cut(pol,bisector(v[s], v[i]));\n  return pol;\n}\n\nusing Edge = tuple<int, D>;\nusing State = tuple<D, int>;\n\nconst D inf = 1e30;\n\nint main(void){\n    for(int n; cin >> n, n;){\n        VC circles(n);\n        rep(i, n){\n            circles[i].c = input();\n            cin >> circles[i].r;\n        }\n\n        VP ps;\n        rep(i, n - 1){\n            VP cur = pCC(circles[i], circles[i + 1]);\n            ps.push_back(cur[0]);\n            ps.push_back(cur[1]);\n        }\n        ps.push_back(circles[0].c);\n        ps.push_back(circles[n - 1].c);\n\n        vector<vector<Edge>> edge(2 * n);\n\n        // mid -> mid\n        rep(i, n - 1){\n            rep(j, i){\n                rep(k, 2){\n                    rep(l, 2){\n                        int a = i * 2 + k, b = j * 2 + l;\n                        L line = {ps[a], ps[b]};\n\n                        bool ok = true;\n                        range(m, j + 1, i){\n                            if(not iSS(line, {ps[m * 2], ps[m * 2 + 1]})) ok = false;\n                        }\n                        if(ok){\n                            edge[a].push_back(Edge(b, sq(ip(vec(line), vec(line)))));\n                            edge[b].push_back(Edge(a, sq(ip(vec(line), vec(line)))));\n                        }\n                    }\n                }\n            }\n        }\n\n        // start -> mid\n        rep(i, n - 1){\n            rep(j, 2){\n                int a = 2 * n - 2, b = i * 2 + j;\n                L line = {ps[a], ps[b]};\n\n                bool ok = true;\n                rep(k, i){\n                    if(not iSS(line, {ps[k * 2], ps[k * 2 + 1]})) ok = false;\n                }\n                if(ok){\n                    edge[a].push_back(Edge(b, sq(ip(vec(line), vec(line)))));\n                    edge[b].push_back(Edge(a, sq(ip(vec(line), vec(line)))));\n                }\n            }\n        }\n\n        // mid -> goal\n        rep(i, n - 1){\n            rep(j, 2){\n                int a = i * 2 + j, b = 2 * n - 1;\n                L line = {ps[a], ps[b]};\n\n                bool ok = true;\n                range(k, i + 1, n - 1){\n                    if(not iSS(line, {ps[k * 2], ps[k * 2 + 1]})) ok = false;\n                }\n                if(ok){\n                    edge[a].push_back(Edge(b, sq(ip(vec(line), vec(line)))));\n                    edge[b].push_back(Edge(a, sq(ip(vec(line), vec(line)))));\n                }\n            }\n        }\n\n        // start -> goal\n        {\n            int a = 2 * n - 2, b = 2 * n - 1;\n            L line = {ps[a], ps[b]};\n\n            bool ok = true;\n            rep(i, n - 1){\n                if(not iSS(line, {ps[i * 2], ps[i * 2 + 1]})) ok = false;\n            }\n            if(ok){\n                edge[a].push_back(Edge(b, sq(ip(vec(line), vec(line)))));\n                edge[b].push_back(Edge(a, sq(ip(vec(line), vec(line)))));\n            }\n        }\n\n        vector<D> min_dist(2 * n, inf);\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(0.0, 2 * n - 2));\n\n        while(q.size()){\n            int v;\n            D cost;\n            tie(cost, v) = q.top(); q.pop();\n\n            // cerr << v << endl;\n            if(min_dist[v] != inf) continue;\n            min_dist[v] = cost;\n\n            for(auto & e : edge[v]){\n                int nv;\n                D dist;\n                tie(nv, dist) = e;\n\n                if(min_dist[nv] != inf) continue;\n                q.push(State(cost + dist, nv));\n            }\n        }\n\n        cout.precision(12);\n        cout << min_dist[2 * n - 1] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define INF 1e9\nconst double EPS = 1e-9;\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\nVP crosspointCC(Point a, double ar, Point b, double br){\n  double d = abs(b-a);\n  if(abs(ar-br)>d || abs(ar+br)<d) return {};\n  double t = acos(double((d*d+ar*ar-br*br)/(2*d*ar)));\n  Point p1 = a+polar(ar,arg(b-a)+t);\n  Point p2 = a+polar(ar,arg(b-a)-t);\n  if(abs(p1-p2) < EPS) return {p1};\n  return {p1,p2};\n}\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on ps\n  if (norm(b) < norm(c)) return -2;  // a--b--c on ps or a==b\n  return 0;                          // a--c--b on ps or a==c or b==c\n}\n\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        VP c(n);\n        vector<double> r(n);\n        rep(i,n){\n            double x,y;\n            cin>>x>>y>>r[i];\n            c[i] = {x,y};\n        }\n\n        vector<VP> ps(n+1);\n        ps[0] = {c[0],c[0]};\n        ps[n] = {c[n-1],c[n-1]};\n        rep(i,n-1){\n            ps[i+1] = crosspointCC(c[i],r[i],c[i+1],r[i+1]);\n            assert(ps[i+1].size()==2);\n        }\n\n        vector<vector<double>> d((n+1)*2,vector<double>((n+1)*2,INF));\n        rep(i,n) for(int j=i+1;j<=n;j++) rep(i2,2) rep(j2,2) {\n            bool connect=true;\n            for(int k=i+1;k<j;k++) {\n                connect &= isecSS(ps[i][i2],ps[j][j2],ps[k][0],ps[k][1]);\n            }\n            if(connect){\n                d[i*2+i2][j*2+j2] = abs(ps[i][i2]-ps[j][j2]);\n            }\n        }\n\n        rep(k,(n+1)*2) rep(i,(n+1)*2) rep(j,(n+1)*2)\n            d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        printf(\"%.9f\\n\",d[0][n*2]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (sqrt(dot(b-a, c-a)) < -EPS) return 2;\n    if (abs(b-a) < abs(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing val_t = double;\nconstexpr val_t EPS = 1e-12;\nusing Point = complex<val_t>;\nstruct Line : public pair<Point, Point> {\n    Line(const Point &a, const Point &b) : pair<Point, Point>(a, b) {}\n};\nstruct Segment : public pair<Point, Point> {\n    Segment(const Point &a, const Point &b) : pair<Point, Point>(a, b) {}\n};\nval_t dot(const Point &a, const Point &b) {\n    return real(conj(a) * b);\n}\nval_t cross(const Point &a, const Point &b) {\n    return imag(conj(a) * b);\n}\nval_t X(const Point &a) {\n    return real(a);\n}\nval_t Y(const Point &a) {\n    return imag(a);\n}\nval_t norm2(const Point &a) {\n    return X(a) * X(a) + Y(a) * Y(a);\n}\nint sign(val_t x) {\n    if (x < -EPS) return -1;\n    if (x > EPS) return 1;\n    return 0;\n}\nint ccw(const Point &a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    if (cross(b, c) > EPS) return 1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return 0;\n    if (norm2(b) < norm2(c)) return 2;\n    return -2;\n}\n\nbool is_crossing(const Segment &a, const Segment &b) {\n    return ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0\n    && ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0;\n}\n\nval_t dist2(const Point &a, const Point &b) {\n    return norm2(a - b);\n}\n\npair<Point, Point> get_isec(int x, int y, int r, int X, int Y, int R) {\n    double d = hypot(abs(x - X), abs(y - Y));\n    double s = (r + R + d) / 2;\n    double l = 2 * sqrt(s * (s - r) * (s - R) * (s - d)) / d;\n    Point ret1(x, y), ret2(x, y);\n    double A = sqrt(r * r - l * l) / d;\n    double B = l / d;\n    Point p(X - x, Y - y), q(Y - y, -X + x);\n    return make_pair(ret1 + A * p + B * q, ret2 + A * p - B * q);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        vector<int> xs(n), ys(n), rs(n);\n        for (int i = 0; i < n; i++) cin >> xs[i] >> ys[i] >> rs[i];\n        int N = 2 * (n - 1);\n        vector<vector<double>> dist(N + 2, vector<double>(N + 2, 1e9));\n        vector<Point> isec(N);\n        for (int i = 0; i < n - 1; i++) {\n            pair<Point, Point> is = get_isec(xs[i], ys[i], rs[i], xs[i + 1], ys[i + 1], rs[i + 1]);\n            isec[2 * i] = is.first;\n            isec[2 * i + 1] = is.second;\n        }\n\n        auto ok = [&](int i, int j) -> bool {\n            int I = i / 2, J = j / 2;\n            if (J - I <= 1) return true;\n            Segment ma(isec[i], isec[j]);\n            for (int k = I + 1; k < J; k++) {\n                Segment ho(isec[2 * k], isec[2 * k + 1]);\n                if (is_crossing(ma, ho) == false) return false;\n            }\n            return true;\n        };\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (ok(i, j)) {\n                    dist[i][j] = dist[j][i] = sqrt(dist2(isec[i], isec[j]));\n                }\n            }\n        }\n        auto ok2 = [&](int i) -> bool {\n            int I = i / 2;\n            if (I == 0) return true;\n            Segment ma(isec[i], Point(xs[0], ys[0]));\n            for (int j = 0; j < I; j++) {\n                Segment ho(isec[2 * j], isec[2 * j + 1]);\n                if (is_crossing(ma, ho) == false) return false;\n            }\n            return true;\n        };\n        auto ok3 = [&](int i) -> bool {\n            int I = i / 2;\n            if (I == n - 2) return true;\n            Segment ma(isec[i], Point(xs[n - 1], ys[n - 1]));\n            for (int j = I + 1; j < n - 1; j++) {\n                Segment ho(isec[2 * j], isec[2 * j + 1]);\n                if (is_crossing(ma, ho) == false) return false;\n            }\n            return true;\n        };\n        for (int i = 0; i < N; i++) {\n            if (ok2(i)) {\n                dist[N][i] = dist[i][N] = sqrt(dist2(isec[i], Point(xs[0], ys[0])));\n            }\n            if (ok3(i)) {\n                dist[N + 1][i] = dist[i][N + 1] = sqrt(dist2(isec[i], Point(xs[n - 1], ys[n - 1])));\n            }\n        }\n\n        for (int k = 0; k < N + 2; k++) {\n            for (int i = 0; i < N + 2; i++) {\n                for (int j = 0; j < N + 2; j++) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        double ans = dist[N][N + 1];\n        auto ok4 = [&]() {\n            Segment ma(Point(xs[0], ys[0]), Point(xs[n - 1], ys[n - 1]));\n            for (int j = 0; j < n - 1; j++) {\n                Segment ho(isec[2 * j], isec[2 * j + 1]);\n                if (is_crossing(ma, ho) == false) return false;\n            }\n            return true;\n        };\n        if (ok4()) {\n            ans = min(ans, sqrt(dist2(Point(xs[0], ys[0]), Point(xs[n - 1], ys[n - 1]))));\n        }\n\n        cout << setprecision(20) << fixed << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\n#define PI 3.14159265353238463\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P,i) - curr(P,i))\nenum { OUT, ON, IN };\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nvector<P> crosspointCC(P c1, double r1, P c2, double r2){\n\tvector<P> res;\n\tP d=c2-c1;\n\tif(abs(d)>r1+r2 || abs(d)<abs(r1-r2))return res;\n\tdouble t=acos((r1*r1+norm(d)-r2*r2)/(2*r1*abs(d)));\n\tres.pb(c1+d*r1/abs(d)*P(cos(t),sin(t)));\n\tres.pb(c1+d*r1/abs(d)*P(cos(-t),sin(-t)));\n\treturn res;\n}\n\ntypedef pair<double,int> DI;\n\nint n;\nP c[111],p[222];\nL line[111];\ndouble r[111],d[222];\n\nint main(){\n\twhile(cin>>n && n){\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y>>r[i];\n\t\t\tc[i]=P(x,y);\n\t\t}\n\t\tp[0]=c[0];\n\t\trep(i,n-1){\n\t\t\tvector<P> v=crosspointCC(c[i],r[i],c[i+1],r[i+1]);\n\t\t\trep(j,2)p[1+2*i+j]=v[j];\n\t\t\tline[i]=L(v[0],v[1]);\n\t\t}\n\t\tp[2*n-1]=c[n-1];\n\t\tpriority_queue<DI,vector<DI>,greater<DI> > Q;\n\t\tQ.push(DI(0,0));\n\t\tfill(d,d+2*n,INF);\n\t\td[0]=0;\n\t\twhile(1){\n\t\t\tDI q=Q.top();Q.pop();\n\t\t\tdouble dist=q.fir;\n\t\t\tint v=q.sec;\n\t\t\tif(dist>d[v])continue;\n\t\t\tif(v==2*n-1){\n\t\t\t\tcout<<setprecision(11)<<dist<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep2(i,v+1,2*n){\n\t\t\t\tdouble nd=dist+abs(p[i]-p[v]);\n\t\t\t\tif(nd<d[i]){\n\t\t\t\t\tL course=L(p[v],p[i]);\n\t\t\t\t\trep2(j,(v==0 ? -1:(v-1)/2)+1,(i-1)/2){\n\t\t\t\t\t\tif(!intersectSS(course,line[j]))goto fail;\n\t\t\t\t\t}\n\t\t\t\t\td[i]=nd;\n\t\t\t\t\tQ.push(DI(nd,i));\n\t\t\t\t\tfail:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double mEPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst double INF = 1e9;\n\nclass Point{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\t//EPS??????????°??????????\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n\t}\n\n};\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n};\n\ntypedef vector<Point> Polygon;\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble arg(Vector p){ return atan2(p.y, p.x); }\nVector polar(double a, double r){ return Point(cos(r)*a, sin(r)*a); }\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\ndouble getDistancePP(Point a, Point b){\n\treturn (a - b).abs();\n}\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -mEPS) return CLOCKWISE;\n\tif (dot(a, b) < -mEPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\nbool intersect(Segment s1, Segment s2){\n\treturn(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\n// ??????l??????????????????????????±????????´??\\????????????\nbool isdirect(vector<Point>& ps, int s, int e, Segment& l){\n  for(int i=s;i<e;++i){\n\tSegment s; s.p1 = ps[i*3+1], s.p2 = ps[i*3+2];\n\tif(!intersect(s,l)) return false;\n  }\n  return true;\n}\n\nstruct Edge{\n  int to;\n  double cost;\n\n  Edge(int t, double c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\nvoid Dijkstra(const Graph& edges, vector<double>& d, int s){\n  typedef pair<double,int> PDI;\n  const int V = edges.size();\n  priority_queue<PDI, vector<PDI>, greater<PDI> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<Circle> cs(N);\n\tREP(i,N)\n\t  cin >> cs[i].c.x >> cs[i].c.y >> cs[i].r;\n\n\tvector<Point> ps(N*3);\n\tREP(i,N-1){\n\t  ps[i*3] = cs[i].c;\n\t  auto pss = getCrossPoints(cs[i], cs[i+1]);\n\t  ps[i*3+1] = pss.first, ps[i*3+2] = pss.second;\n\t}\n\tps[3*N-1] = ps[3*N-2] = ps[3*N-3] = cs[N-1].c;\n\n\tGraph G(3*N);\n\tREP(i,3*N) FOR(j,i+1,3*N){\n\t  Segment seg;\n\t  seg.p1 = ps[i], seg.p2 = ps[j];\n\t  if(isdirect(ps, i/3, j/3, seg)){\n\t\tG[i].PB(Edge(j, getDistancePP(ps[i], ps[j])));\n\t\tG[j].PB(Edge(i, getDistancePP(ps[i], ps[j])));\t\t\t\t\n\t  }\n\t}\n\tvector<double> dist(3*N);\n\tDijkstra(G, dist, 0);\n\n\tcout << fixed << setprecision(9) << dist[3*N-3] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tP[][] cps;\n\tC[] cs;\n\tdouble[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tcs = new C[n];\n\t\t\tfor(int i=0;i<n;i++) cs[i] = new C(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t\n\t\t\tcps = new P[n-1][];\n\t\t\tfor(int i=0;i<n-1;i++) cps[i] = circleIntersection(cs[i].p, cs[i+1].p, cs[i].r, cs[i+1].r);\n//\t\t\tfor(int i=0;i<n-1;i++) debug(cps[i][0].x, cps[i][0].y, cps[i][1].x, cps[i][1].y);\n\t\t\t\n\t\t\tes = new double[2*n][2*n];\n\t\t\tfor(double[] a: es) fill(a, INF);\n\t\t\t\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tif(isCross(cs[0].p, cps[i][0], 0, i)) es[0][2*(i+1)-1] = cs[0].p.abs(cps[i][0]);\n\t\t\t\tif(isCross(cs[0].p, cps[i][1], 0, i)) es[0][2*(i+1)] = cs[0].p.abs(cps[i][1]);\n\t\t\t\tif(isCross(cs[n-1].p, cps[i][0], i+1, n-1)) es[2*(i+1)-1][2*n-1] = cs[n-1].p.abs(cps[i][0]);\n\t\t\t\tif(isCross(cs[n-1].p, cps[i][1], i+1, n-1)) es[2*(i+1)][2*n-1] = cs[n-1].p.abs(cps[i][1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n-1;i++) for(int j=i+1;j<n-1;j++) {\n\t\t\t\tif(isCross(cps[i][0], cps[j][0], i+1, j)) es[2*(i+1)-1][2*(j+1)-1] = cps[i][0].abs(cps[j][0]);\n\t\t\t\tif(isCross(cps[i][0], cps[j][1], i+1, j)) es[2*(i+1)-1][2*(j+1)] = cps[i][0].abs(cps[j][1]);\n\t\t\t\tif(isCross(cps[i][1], cps[j][0], i+1, j)) es[2*(i+1)][2*(j+1)-1] = cps[i][1].abs(cps[j][0]);\n\t\t\t\tif(isCross(cps[i][1], cps[j][1], i+1, j)) es[2*(i+1)][2*(j+1)] = cps[i][1].abs(cps[j][1]);\n\t\t\t}\n\t\t\t\n\t\t\tif(isCross(cs[0].p, cs[n-1].p, 0, n-1)) es[0][2*n-1] = cs[0].p.abs(cs[n-1].p);\n\t\t\t\n//\t\t\tfor(double[] a: es) debug(a);\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\t\n\tdouble dijkstra() {\n\t\tdouble[] d = new double[2*n];\n\t\tboolean[] used = new boolean[2*n];\n\t\tint[] path = new int[2*n];\n\t\tfill(d, INF);d[0] = 0;\n\t\tfor(;;) {\n\t\t\tint v = -1;\n\t\t\tfor(int u=0;u<2*n;u++) if(!used[u] && (v == -1 || d[v] > d[u])) v = u;\n\t\t\tif(v == -1) {\n//\t\t\t\tdebug(path);\n\t\t\t\treturn d[2*n-1];\n\t\t\t}\n\t\t\t\n\t\t\tused[v] = true;\n\t\t\tfor(int u=0;u<2*n;u++) {\n\t\t\t\tpath[u] = d[u] > d[v] + es[v][u]? v: path[u];\n\t\t\t\td[u] = min(d[u], d[v] + es[v][u]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isCross(P s, P e, int p, int q) {\n//\t\tdebug(s.x, s.y, e.x, e.y);\n\t\tfor(int i=p;i<q;i++) {\n\t\t\tif(!cross(s, e, cps[i][0], cps[i][1])) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\t\n\n\tP[] circleIntersection(P a, P b, double r1, double r2) {\n\t\tP AB = b.sub(a);\n\n\t\tdouble ab = AB.abs();\n\t\tdouble ai = ( r1*r1 - r2*r2 + ab*ab ) / ( 2 * ab );\n\t\tP AI = AB.mlt(ai/ab);\n\n\t\tdouble ip = sqrt( r1*r1 - ai * ai);\n\t\tP IP = new P(AB.y * ip/ab, -AB.x* ip/ab);\n\n\t\tP P1 = a.add(AI).add(IP);\n\n\t\tIP = IP.mlt(-1.0);\n\t\tP P2 = a.add(AI).add(IP);\n\t\t\n//\t\tdebug(ab, ai, ip);\n//\t\tdebug(\"P1:\", P1.x, P1.y);\n//\t\tdebug(\"P2:\", P2.x, P2.y);\n\t\t\n\t\t\n\t\treturn new P[] {P1, P2};\n\t}\n\t\n\t//線分交差判定\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t}\n\n\t//時計回りなのか．反時計回りなのか，直線状なのか，とにかく位置関係をみる\n\tint ccw (P a, P b, P c) {\n\t\tP s = b.sub(a);\n\t\tP t = c.sub(a);\n\t\tif( s.det(t) > EPS ) return 1;\n\t\tif( s.det(t) < -EPS ) return -1;\n\t\tif( s.dot(t) < -EPS ) return 2;\n\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\treturn 0;\n\t}\n\t\n\tclass C {\n\t\tP p;\n\t\tdouble r;\n\t\tC(double x, double y, double r) {\n\t\t\tp = new P(x, y);\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\t\n\tclass P {\n\t\tdouble EPS = 1e-10;\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble add(double a, double b) {\n\t\t\t//誤差を考慮\n\t\t\tif( Math.abs(a+b) < EPS * ( Math.abs(a) + Math.abs(b) ) ) return 0;\n\t\t\treturn a + b;\n\t\t}\n\n\t\tP add(P p) {\t//和\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p) {\t//差\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\n\t\tP mlt(double k) {\n\t\t\treturn new P(x*k, y*k);\n\t\t}\n\n\t\tdouble dot(P p) {\t//内積\n\t\t\t\treturn add(x*p.x, y*p.y);\n\t\t}\n\n\t\tdouble det(P p) {\t//外積\n\t\t\treturn add(x*p.y, -y*p.x);\n\t\t}\n\n\t\tdouble abs() {\n\t\t\tdouble ret = sqrt( add(x*x, y*y) );\n\t\t\tif ( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble abs(P p) {\n\t\t\tdouble dx = add( x, -p.x );\n\t\t\tdouble dy = add( y, -p.y );\n\t\t\tdouble ret = sqrt( add(dx*dx, dy*dy) );\n\t\t\tif( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n \nstruct Point{\n    double x, y;\n     \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n \n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n \n    double norm() {return x * x + y * y; }\n    double abs() {return sqrt(norm()); }\n \n    bool operator < (const Point &p) const{\n        return (x != p.x ? x < p.x : y < p.y);\n    }\n \n    bool operator == (const Point &p) const{\n        return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n    }\n};\n \ntypedef Point Vector;\n \nstruct Circle{\n    Point c;\n    double r;\n \n    Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n \ndouble norm(Vector a){\n    return a.x * a.x + a.y * a.y;\n}\n \ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n \ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n \nVector polar(double a, double r){\n    return Point(cos(r) * a, sin(r) * a);\n}\n \npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n /*\nint main(){\n    double c1x, c1y, c1r; cin>>c1x>>c1y>>c1r;\n    double c2x, c2y, c2r; cin>>c2x>>c2y>>c2r;\n \n    Circle c1 = {Point(c1x, c1y), c1r};\n    Circle c2 = {Point(c2x, c2y), c2r};\n \n    pair<Point, Point> ansp = getCrossPoints(c1, c2);\n    Point p1 = min(ansp.first, ansp.second);\n    Point p2 = max(ansp.first, ansp.second);\n \n    printf(\"%.10f %.10f %.10f %.10f\\n\", p1.x, p1.y, p2.x, p2.y);\n}\n*/\nint n;\n\ndouble dist(double x1,double y1,double x2,double y2){\n    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)  );\n}\n\nbool judgeIenter(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy) {\n    double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n    double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n    double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n    double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n   // return (tc * td < 0 && ta * tb < 0);\n     return (tc * td <= 0 && ta * tb <= 0); // 端点を含む場合\n}\ndouble INF = 10000000;\ndouble dp[110][2];\ndouble d[110][3];\ndouble p[110][2][2];\nbool check(int a,int aa,int b,int bb){\n    double ax,ay,bx,by;\n    if(a == -1){\n        ax = d[0][0];\n        ay = d[0][1];\n    }else{\n        ax = p[a][aa][0];\n        ay = p[a][aa][1];\n    }\n    if(b == n-1){\n        bx = d[n-1][0];\n        by = d[n-1][1];\n    }else{\n        bx = p[b][bb][0];\n        by = p[b][bb][1];\n    }\n    bool flag = true;\n    for(int i = max(0,a);i < b;i++){\n      //  cout << judgeIenter(ax,ay,bx,by,p[i][0][0],p[i][0][1],p[i][1][0],p[i][1][1]) << \":\";\n    //    printf(\"%.2lf %.2lf %.2lf %.2lf %.2lf %.2lf %.2lf %.2lf\\n\",ax,ay,bx,by,p[i][0][0],p[i][0][1],p[i][1][0],p[i][1][1]);\n        if(judgeIenter(ax,ay,bx,by,p[i][0][0],p[i][0][1],p[i][1][0],p[i][1][1]) == false){\n            flag = false;\n            break;\n        } \n    }\n    \n    return (flag);\n}\n\n\n\nint main(){\n //   int n;\n    while(true){\n        cin >> n;\n        if(n == 0)break;\n        for(int i = 0;i <= n+1;i++){\n            dp[i][0] = INF;\n            dp[i][1] = INF;\n        }\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < 3;j++){\n                cin >> d[i][j];\n            }\n        }\n        for(int i = 0;i < n-1;i++){\n            Circle c1 = {Point(d[i][0], d[i][1]), d[i][2]};\n            Circle c2 = {Point(d[i+1][0], d[i+1][1]), d[i+1][2]};\n            pair<Point, Point> ansp = getCrossPoints(c1, c2);\n            p[i][0][0] = ansp.first.x;\n            p[i][0][1] = ansp.first.y;\n            p[i][1][0] = ansp.second.x;\n            p[i][1][1] = ansp.second.y;\n        //    printf(\"(%lf,%lf), (%lf,%lf)\\n\",p[i][0][0],p[i][0][1],p[i][1][0],p[i][1][1]);\n        }\n        for(int i = 0;i < 2;i++){\n            dp[0][i] = dist(d[0][0],d[0][1],p[0][i][0],p[0][i][1]);\n         //   printf(\"dp[0][%d] = %lf\\n\",i,dp[0][i]);\n        }\n        \n        for(int i = 1;i < n-1;i++){\n            for(int k = 0;k < 2;k++){\n                double nx = p[i][k][0],ny = p[i][k][1];\n                if(check(-1,0,i,k)) dp[i][k] = dist(d[0][0],d[0][1],nx,ny);\n                for(int j = 0;j < i;j++){\n                    for(int kk = 0;kk < 2;kk++){\n                        if(check(j,kk,i,k))dp[i][k] = min(dp[i][k],dp[j][kk]+dist(p[j][kk][0],p[j][kk][1],nx,ny));\n                    }\n                }\n            //    printf(\"dp[%d][%d] = %lf\\n\",i,k,dp[i][k]);\n            }\n        }\n        double ans = INF;\n        for(int i = -1;i < n-1;i++){\n            for(int k = 0;k < 2;k++){\n                if(check(i,k,n-1,0)){\n                //    printf(\"i:%d,k:%d,ans=%lf\\n\",i,k,ans);\n                    if(i == -1)ans = min(ans,dist(d[0][0],d[0][1],d[n-1][0],d[n-1][1]));\n                    else ans = min(ans,dp[i][k]+dist(p[i][k][0],p[i][k][1],d[n-1][0],d[n-1][1]));\n                }\n            }\n        }\n        printf(\"%lf\\n\",ans);\n     //   cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nstruct coordinate {\n\tdouble x, y;\n\tdouble normal;\n\tbool normal_flag;\n\tcoordinate() {}\n\tcoordinate(double a, double b) {\n\t\tx = a; y = b;\n\t\tnormal_flag = false;\n\t}\n\tvoid set_normal(double n) {\n\t\tnormal = n;\n\t\tnormal_flag = false;\n\t}\n};\n\nstruct circle {\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coordinate a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coordinate,coordinate> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coordinate,coordinate> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coordinate(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coordinate(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\tret.first.set_normal(atan2(ret.second.y - ret.first.y, ret.second.x - ret.first.x));\n\tret.first.set_normal(atan2(ret.first.y - ret.second.y, ret.first.x - ret.second.x));\n\n\treturn ret;\n}\n\nbool cross_lseg(coordinate a_start, coordinate a_end, coordinate b_start, coordinate b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\ndouble distance(coordinate a, coordinate b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coordinate,coordinate> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coordinate(v[0].x, v[0].y), coordinate(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coordinate,coordinate> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(make_pair(coordinate(v[v.size() - 1].x, v[v.size() - 1].y), coordinate(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoordinate start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoordinate end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\nconst double INF=1e+10;\nint N;\ndouble xs[101];\ndouble ys[101];\ndouble rs[101];\nP cps[101];\nP ps[1001];\ndouble d[301][301];\nint prv[301][301];\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n\treturn P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 2円の交点を求める\npair<P,P> crossPointsTwoCircle(P c1,double r1,P c2,double r2){\n  double a=abs(c1-c2);\n  //double b=sqrt(r1*r1-(a/2)*(a/2));\n  double tmp=((r1*r1-r2*r2+a*a)/(2*a));\n  double b=sqrt(r1*r1-tmp*tmp);\n  P p=c1-c2;p/=abs(p);\n  p=roundPoint(p,PI/2);\n  P p1=p;\n  P p2=p;p2*=-1;\n  p1*=b;p2*=b;\n  P cp=(c2*tmp+c1*(a-tmp));\n  cp*=(1.0/a);\n  P res1=cp+p1;\n  P res2=cp+p2;\n  return make_pair(res1,res2);\n}\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 円の中にaがあるか\nbool isDotInCiecle(P cp,double r,P a){\n  double dist=abs(cp-a);\n  if(EQ(dist,r)||dist<r)return true;\n  return false;\n}\nbool isCircleCrossLine(P a,P b,P c,double r){\n  double d1 = abs(a-c);\n  double d2 = abs(b-c);\n  // 線分が中に含まれるとき、ここのコメントアウトをはずせばtrue(交差)となる\n  if(d1<r&&d2<r)return true;\n  double d = distance_ls_p(a,b,c);\n  return (EQ(d,r)||d<r);\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 円と直線の交点計算\n// 接する場合は同じ点を２つ返す\nvector<P> calcCrossPointLineAndCircle(P a,P b,P c,double r){\n  vector<P> res;\n  // もし直線と円がcrossしないなら、空リスト\n  if(!isCircleCrossLine(a,b,c,r))return res;\n  for(int i=0;i<2;i++){\n    double x=distance_l_p(a,b,c);\n    double y=sqrt(r*r-x*x);\n    P e=(b-a);e/=abs(e);e=roundPoint(e,(2*i+1)*PI/2);\n    P e2=e;e2*=x;\n    P cp2=c+e2;\n    P addV=(b-a);addV/=abs(addV);addV*=y;\n    P res1=cp2+addV;\n    addV*=-1;\n    P res2=cp2+addV;\n    // 今回求めた点が線分に乗ってない場合、向きを変えて再計算\n    if(!EQ(0,distance_l_p(a,b,res1)))continue;\n    res.push_back(res1);\n    res.push_back(res2);\n    return res;\n  }\n}\n// 円と線分の交点計算\nvector<P> calcCrossPointSegmentAndCircle(P a,P b,P c,double r){\n  // 直線との交点計算\n  vector<P> v=calcCrossPointLineAndCircle(a,b,c,r);\n  vector<P> res;\n  for(int i=0;i<(int)v.size();i++){\n    // 線分と今回の点の距離が0ならリストへ\n    double dis=distance_ls_p(a,b,v[i]);\n    if(EQ(dis,0))res.push_back(v[i]);\n  }\n  return res;\n}\n\n// 線分a,bが円の内側にあるか\n// fromからtoの円について調査する\nbool check(P a,P b,int from,int to){\n  vector<P> points;\n  // 線分a-bと各円との交点を全列挙する\n  for(int i=from;i<=to;i++){\n    // 線分との交点を取得\n    vector<P> res=calcCrossPointSegmentAndCircle(a,b,cps[i],rs[i]);\n    for(int j=0;j<(int)res.size();j++)\n      points.push_back(res[j]);\n    // もし線分がない円が存在すれば、false\n    if(res.size()==0||\n       (!(i==from||i==to)&&(res.size()==1)))\n      return false;\n  }\n  // pointsの点がそれぞれ2つ以上の点の内部にあるか\n  for(int i=0;i<(int)points.size();i++){\n    int cnt=0;\n    for(int j=0;j<N;j++)\n      if(isDotInCiecle(cps[j],rs[j],points[i]))cnt++;\n    if(cnt<2)return false;\n  }\n  return true;\n}\n\nint main(){\n\n  while(cin>>N&&N){\n    for(int i=0;i<N;i++){\n      cin>>xs[i]>>ys[i]>>rs[i];\n      cps[i]=P(xs[i],ys[i]);\n    }\n    for(int i=1;i<N;i++){\n      pair<P,P> p2=crossPointsTwoCircle(cps[i-1],rs[i-1],cps[i],rs[i]);\n      ps[2*(i-1)]=p2.first;\n      ps[2*(i-1)+1]=p2.second;\n    }\n    for(int i=0;i<=2*N-1;i++)\n      for(int j=0;j<=2*N-1;j++)\n    \tif(i==j)d[i][j]=0;\n    \telse d[i][j]=INF;\n    const int s=(N-1)*2;\n    const int g=(N-1)*2+1;\n    ps[(N-1)*2]=cps[0];\n    ps[(N-1)*2+1]=cps[N-1];\n    // for(int i=0;i<=2*N-1;i++)\n    //   cout<<ps[i]<<\" \";\n    // cout<<endl;\n    for(int i=0;i<=2*(N-1)+1;i++){\n      for(int j=i+1;j<=2*(N-1)+1;j++){\n\t// if(i==10&&j==14){\n\t//   cout<<endl;\n\t// }\n\tint from=i/2;\n\tint to=j/2;\n\tif(i==2*N-2)from=0;\n\telse if(i==2*N-1)from=N-1;\n\tif(j==2*N-2)to=0;\n\telse if(j==2*N-1)to=N-1;\n\tint a=min(from,to);\n\tint b=min(N-1,max(from,to)+1);\n    \t// 条件を満たす線分を使う\n    \tif(check(ps[i],ps[j],a,b)){\n\t  //cout<<i<<\" \"<<j<<endl;\n\t  d[i][j]=d[j][i]=abs(ps[i]-ps[j]);\n\t  prv[i][j]=i;\n\t  prv[j][i]=j;\n\t}\n      }\n    }\n    // for(int i=0;i<=2*N-1;i++)\n    //   prv[i][i]=i;\n    // floyd\n    for(int i=0;i<=2*N-1;i++){\n      for(int j=0;j<=2*N-1;j++){\n    \tfor(int k=0;k<=2*N-1;k++){\n    \t  //d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t  if(d[j][k]>d[j][i]+d[i][k]){\n\t    d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t    // int cp=k;\n\t    // while(cp!=i){\n\t    //   prv[j][cp]=prv[i][cp];\n\t    //   cp=prv[i][cp];\n\t    // }\n\t  }\n\t}\n      }\n    }\n    // int cp=g;\n    // while(1){\n    //   cout<<cp<<\" \";\n    //   if(cp==s)break;\n    //   cp=prv[s][cp];\n    // }\n    // cout<<endl;\n    printf(\"%.10f\\n\",d[s][g]);\n    //break;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    long double d = std::abs(c1.p - c2.p);\n    long double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    long double dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    long double rs = std::sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\nstruct edge {\n    int to;\n    ld cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<circle> cs;\n        vector<point> ps;\n        for(int i=0; i<n; ++i) {\n            ld x, y, r;\n            cin >> x >> y >> r;\n            cs.emplace_back(point(x, y), r);\n        }\n        ps.push_back(cs[0].p);\n        for(int i=0; i<n-1; ++i) {\n            auto cps = is_cc(cs[i], cs[i+1]);\n            if(ccw(cs[i].p, cs[i+1].p, cps[0]) == -1) {\n                swap(cps[0], cps[1]);\n            }\n            for(auto& cp : cps) {\n                ps.push_back(move(cp));\n            }\n        }\n        ps.push_back(cs[n-1].p);\n        const int N = ps.size();\n        graph g(N);\n        for(int i=0; i<N; ++i) {\n            for(int j=i+1; j<N; ++j) {\n                bool ok = true;\n                int idx1, idx2;\n                if(i % 2 == 1) {\n                    idx1 = i+2;\n                } else {\n                    idx1 = i+1;\n                }\n                if(j % 2 == 0) {\n                    idx2 = j-1;\n                } else {\n                    idx2 = j;\n                }\n                for(int k=idx1; k<idx2; k+=2) {\n                    if(ccw(ps[i], ps[j], ps[k]) == -1 || ccw(ps[i], ps[j], ps[k+1]) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok) {\n                    ld dist = abs(ps[i] - ps[j]);\n                    g[i].push_back((edge){j, dist});\n                    g[j].push_back((edge){i, dist});\n                }\n            }\n        }\n        vector<ld> d(N, 1e18);\n        d[0] = 0;\n        using P = pair<ld, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push(make_pair(0, 0));\n        while(!que.empty()) {\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if(d[v] < p.first) {\n                continue;\n            }\n            for(auto& e : g[v]) {\n                if(d[e.to] > d[v] + e.cost) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(make_pair(d[e.to], e.to));\n                }\n            }\n        }\n        cout << fixed << setprecision(10) << d[N-1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef double D;\n\nconst D EPS = 1e-8;\nconst D INF = 1e9;\n\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nstruct P {\n  D x,y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nstruct L {\n  P a,b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\n\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\n\nP operator +(P a, P b) {\n  return P(a.x + b.x, a.y + b.y);\n}\n\nP operator -(P a, P b) {\n  return P(a.x - b.x, a.y - b.y);\n}\n\nP operator *(P a, D b) {\n  return P(a.x * b, a.y * b);\n}\n\nP operator /(P a, D b) {\n  return P(a.x / b, a.y / b);\n}\n\nostream& operator <<(ostream &os, const P &p) {\n  os << \"{ x = \" << p.x << \", y = \" << p.y << \" }\";\n  return os;\n}\n\nostream& operator <<(ostream &os, const C &c) {\n  os << \"{ p = \" << c.p << \", r = \" << c.r << \" }\";\n  return os;\n}\n\n\nD inp(P a, P b) {\n  return a.x*b.x + a.y*b.y;\n}\n\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\n\nD norm(P a) {\n  return inp(a,a);\n}\n\nD abs(P a) {\n  return sqrt(norm(a));\n}\n\nP rot90(P a) {\n  return P(-a.y, a.x);\n}\n\nP vec(P from, P to) { return to - from; }\n\nint ccw(P a, P b, P c) {\n  b = vec(a, b); c = vec(a, c);\n\n  // a - b - c が折れ曲がるとき\n  if(sig(outp(b, c), 0.0) > 0) return +1; // 反時計回り\n  if(sig(outp(b, c), 0.0) < 0) return -1; // 時計回り\n\n  // a - b - c が直線上に並ぶとき\n  if(sig(inp(b, c), 0.0) < 0) return +2; // c - a - b\n  if(norm(b) < norm(c))   return -2; // a - b - c\n  return 0;                          // a - c - b\n}\n\nbool iSS(L s, L t) { // 端を含む\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 2点で接していることを確認すること\nvector<P> cCC(C a, C b) {\n  D d = abs(b.p - a.p);\n  D x = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n  D y = sqrt(a.r*a.r - x*x);\n  P v = (b.p - a.p) / d;\n  vector<P> res;\n  res.emplace_back(a.p + v*x + rot90(v)*y);\n  res.emplace_back(a.p + v*x - rot90(v)*y);\n  return res;\n}\n\nstruct Edge {\n  int to; double cost;\n  Edge() { }\n  Edge(int to_, double cost_) : to(to_), cost(cost_) { }\n};\n\nstruct State {\n  int pos; double cost;\n  State() { };\n  State(int pos_, double cost_) : pos(pos_), cost(cost_) { }\n  bool operator >(const State &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\ndouble shortest_path(const vector<vector<Edge>> &G, const int src, const int dst) {\n  double d[G.size()];\n  fill(d, d + G.size(), INF);\n  d[src] = 0.0;\n  priority_queue<State, vector<State>, greater<State>> Q;\n  Q.emplace(src, 0.0);\n  while(!Q.empty()) {\n    State s = Q.top(); Q.pop();\n    if(s.cost > d[s.pos]) continue;\n    for(const Edge &e : G[s.pos]) {\n      if(d[e.to] > d[s.pos] + e.cost) {\n        d[e.to] = d[s.pos] + e.cost;\n        Q.emplace(e.to, d[e.to]);\n      }\n    }\n  }\n  return d[dst];\n}\n\nint main() {\n  while(true) {\n    int n; cin >> n;\n    if(n == 0) break;\n    vector<C> circle(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> circle[i].p.x >> circle[i].p.y >> circle[i].r;\n    }\n    vector<vector<P>> cross(n-1);\n    for(int i = 0; i < n - 1; ++i) {\n      cross[i] = cCC(circle[i], circle[i+1]);\n    }\n    vector<vector<Edge>> G(2*(n-1)+2);\n    G[2*(n-1)].emplace_back(0, abs(circle[0].p - cross[0][0]));\n    G[2*(n-1)].emplace_back(1, abs(circle[0].p - cross[0][1]));\n    G[2*(n-1)-1].emplace_back(2*(n-1)+1, abs(cross[n-2][0] - circle[n-1].p));\n    G[2*(n-1)-2].emplace_back(2*(n-1)+1, abs(cross[n-2][1] - circle[n-1].p));\n    for(int i = 0; i < n - 2; ++i) {\n      G[2*i].emplace_back(2*i+2, abs(cross[i][0] - cross[i+1][0]));\n      G[2*i].emplace_back(2*i+3, abs(cross[i][0] - cross[i+1][1]));\n      G[2*i+1].emplace_back(2*i+2, abs(cross[i][1] - cross[i+1][0]));\n      G[2*i+1].emplace_back(2*i+3, abs(cross[i][1] - cross[i+1][1]));\n    }\n    {\n      bool ok = true;\n      for(int i = 0; i < n - 1; ++i) {\n        if(iSS(L(circle[0].p, circle[n-1].p), L(cross[i][0], cross[i][1])) == false) ok = false;\n      }\n      if(ok) G[2*(n-1)].emplace_back(2*(n-1)+1, abs(circle[0].p - circle[n-1].p));\n    }\n    {\n      for(int i = 0; i < n - 1; ++i) {\n        for(int j = 0; j < 2; ++j) {\n          bool ok = true;\n          for(int k = 0; k < i; ++k) {\n            if(iSS(L(circle[0].p, cross[i][j]), L(cross[k][0], cross[k][1])) == false) ok = false;\n          }\n          if(ok) {\n            G[2*(n-1)].emplace_back(2*i+j, abs(circle[0].p - cross[i][j]));\n          }\n        }\n      }\n    }\n    {\n      for(int i = 0; i < n - 1; ++i) {\n        for(int j = 0; j < 2; ++j) {\n          bool ok = true;\n          for(int k = i + 1; k < n - 1; ++k) {\n            if(iSS(L(circle[n-1].p, cross[i][j]), L(cross[k][0], cross[k][1])) == false) ok = false;\n          }\n          if(ok) {\n            G[2*i+j].emplace_back(2*(n-1)+1, abs(circle[n-1].p - cross[i][j]));\n          }\n        }\n      }\n    }\n    {\n      for(int i = 0; i < n - 1; ++i) {\n        for(int j = 0; j < 2; ++j) {\n          for(int i2 = i + 1; i2 < n - 1; ++i2) {\n            for(int j2 = 0; j2 < 2; ++j2) {\n              bool ok = true;\n              for(int k = i + 1; k < i2; ++k) {\n                if(iSS(L(cross[i][j], cross[i2][j2]), L(cross[k][0], cross[k][1])) == false) ok = false;\n              }\n              if(ok) {\n                G[2*i+j].emplace_back(2*i2+j2, abs(cross[i][j] - cross[i2][j2]));\n              }\n            }\n          }\n        }\n      }\n    }\n    cout.setf(ios::fixed);\n    cout.precision(4);\n    cout << shortest_path(G, 2*(n-1), 2*(n-1)+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cassert>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF =  1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\nbool operator<(const P &a, const P&b) {\n  return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\ndouble cross(const P &a, const P&b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P &a, const P&b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) {}\n  C() {}\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if(cross(b,c) > 0) return 1;\n  if (cross(b,c) < 0) return -1;\n  if (dot(b,c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nvector<P> crosspointLC(const L &l, const C &c) {\n  vector<P> ret;\n  P center = projection(l, c.p);\n  double d = abs(center-c.p);\n  double t = sqrt(c.r * c.r - d*d);\n  if (isnan(t)) { return ret; }\n  P vect = (l[1]-l[0]);\n  vect /= abs(vect);\n  ret.push_back(center-vect*t);\n  if (t > EPS) {\n    ret.push_back(center+vect*t);\n  }\n  assert(ret.size() == 2);\n  return ret;\n}\n\nvector<P> crosspointCC(const C &c1, const C &c2) {\n  vector<P> ret;\n  double d = abs(c1.p-c2.p);\n  if (max(c1.r,c2.r) - min(c1.r,c2.r) - d > -EPS) {\n    assert(0);\n    return ret;\n  }\n  double x = (d*d+c1.r*c1.r-c2.r*c2.r) / (2*d);\n  P start = c1.p + (c2.p-c1.p) / d * x;\n  P vect = (c1.p-c2.p) * P(0,1);\n  return crosspointLC(L(start, start + vect), c1);\n}\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator<(const Edge &a, const Edge &b) {\n  return a.weight != b.weight ? a.weight > b.weight :\n    a.src != b.src ? a.src < b.src : a.dst < b.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid dijkstra(const Graph &g, int s,vector<Weight> &dist, vector<int> &prev) {\n  const int n = g.size();\n  dist.resize(n);\n  prev.resize(n);\n  for (int i=0; i<n; ++i) {\n    dist[i] = 1e9;\n    prev[i] = -1;\n  }\n  priority_queue<Edge> q;\n  q.push(Edge(-2, s, 0));\n  dist[s] = 0;\n  while(!q.empty()) {\n    Edge e = q.top(); q.pop();\n    if (prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n\n    for (int i=0; i<g[e.dst].size(); ++i) {\n      int w = g[e.dst][i].dst;\n      if (dist[w] > dist[e.dst] + g[e.dst][i].weight) {\n        dist[w] = dist[e.dst] + g[e.dst][i].weight;\n        q.push(Edge(e.dst,w,dist[w]));\n      }\n    }\n  }\n}\n\nC circle[100];\nP cps[100][2];\n\nbool ok(int s, int t, const L &l) {\n  for (int i=s; i<=t; ++i) {\n    if (ccw(l[0], l[1], cps[i][0]) ==-1) return 0;\n    if (ccw(l[0], l[1], cps[i][1]) ==1) return 0;\n  }\n  return 1;\n}\n\nvoid add_edge(Graph &g, int s, int t, Weight d) {\n  //cout << s << \" \" << t <<  \" \"  << d << endl;\n  g[s].push_back(Edge(s, t, d));\n  g[t].push_back(Edge(t,s,d));\n}\nint main() {\n  int n;\n  while(cin>>n , n) {\n    for (int i=0; i<n; ++i) {\n      double x, y, r;\n      cin >> x >> y >> r;\n      circle[i] = C(P(x,y),r);\n    }\n    for (int i=0; i<n-1; ++i) {\n      vector<P> ret = crosspointCC(circle[i], circle[i+1]);\n      if (ccw(circle[i].p, circle[i+1].p,ret[0]) == -1) {\n        swap(ret[0], ret[1]);\n      }\n      cps[i][0] = ret[0];\n      cps[i][1] = ret[1];\n    }\n    Graph g((n-1)*2+2);\n    for (int i=0; i<n-1; ++i) {\n      for (int j=i+1; j<n-1; ++j) {\n        if (ok(i,j,L(cps[i][0], cps[j][0]))) add_edge(g, i*2, j*2, abs(cps[i][0]-cps[j][0]));\n        if (ok(i,j,L(cps[i][0], cps[j][1]))) add_edge(g, i*2, j*2+1, abs(cps[i][0]-cps[j][1]));\n        if (ok(i,j,L(cps[i][1], cps[j][0]))) add_edge(g, i*2+1, j*2, abs(cps[i][1]-cps[j][0]));\n        if (ok(i,j,L(cps[i][1], cps[j][1]))) add_edge(g, i*2+1, j*2+1, abs(cps[i][1]-cps[j][1]));\n      }\n    }\n    for (int i=0; i<n-1; ++i) {\n      if (ok(0,i,L(circle[0].p,cps[i][0]))) add_edge(g, (n-1)*2, i*2, abs(circle[0].p-cps[i][0]));\n      if (ok(0,i,L(circle[0].p,cps[i][1]))) add_edge(g, (n-1)*2, i*2+1, abs(circle[0].p-cps[i][1]));\n      if (ok(i,n-2,L(cps[i][0], circle[n-1].p))) add_edge(g, (n-1)*2+1, i*2, abs(circle[n-1].p-cps[i][0]));\n      if (ok(i,n-2,L(cps[i][1], circle[n-1].p))) add_edge(g, (n-1)*2+1, i*2+1, abs(circle[n-1].p-cps[i][1]));\n    }\n    if (ok(0,n-2,L(circle[0].p, circle[n-1].p))) add_edge(g, (n-1)*2, (n-1)*2+1, abs(circle[0].p-circle[n-1].p));\n    vector<Weight> dist;\n    vector<int> prev;\n    dijkstra(g, (n-1)*2, dist, prev);\n    double ans = dist[(n-1)*2+1];\n    printf(\"%.10f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n};\n\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tbool iscross(line a){\n\t\t//printf(\"check %s %s\\n\",str().c_str(),a.str().c_str());\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\t//printf(\"%lf %lf\\n\",da,db);\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\t//printf(\"%lf %lf\\n\",da,db);\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n};\n\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\n\nstruct circle{\n\tpos p;\n\tdouble r;\n\t\n\tline getintersection(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\t//printf(\"%s %lf %lf %lf   %lf %lf %lf\\n\",cv.str().c_str(),br,dr,lowofcos_getcos( r, cv.norm, a.r),r, cv.norm, a.r);\n\t\t\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\t\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n};\n\n\n\nint main(void){\n\t/*\n\tcircle c1,c2;\n\tc1.p=pos(2,2); c1.r=sqrt(5);\n\tc2.p=pos(5,3); c2.r=sqrt(5);\n\tline li=c1.getintersection(c2);\n\tprintf(\"%s\\n\",li.str().c_str());\n\t*/\n\t\n\tfor(;;){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tvector<circle> dat;\n\t\trep(i,n){\n\t\t\tdouble a,b,c;\n\t\t\tscanf(\"%lf %lf %lf\",&a,&b,&c);\n\t\t\tdat.push_back(circle(pos(a,b),c));\n\t\t}\n\t\t\n\t\tvector<line> ls;\n\t\trep(i,n-1){\n\t\t\tls.push_back(dat[i].getintersection(dat[i+1]));\n\t\t}\n\t\t\n\t\tvector<pos> ps[2];\n\t\tps[0].push_back(dat[0].p);\n\t\tps[1].push_back(dat[0].p);\n\t\trep(i,n-1){\n\t\t\tps[0].push_back(ls[i].p);\n\t\t\tps[1].push_back(ls[i].q);\n\t\t}\n\t\tps[0].push_back(dat[n-1].p);\n\t\tps[1].push_back(dat[n-1].p);\n\t\t\n\t\tvector<double> dp[2];\n\t\trep(i,2)dp[i].resize(n+1);\n\t\tdp[0][0]=dp[1][0]=0;\n\t\treg(i,1,n){\n\t\t\trep(j,2){\n\t\t\t\tdouble nd=10000;\n\t\t\t\trep(p,i){\n\t\t\t\t\trep(q,2){\n\t\t\t\t\t\tbool ok=true;\n\t\t\t\t\t\tline nl=line( pos(ps[q][p]) , pos(ps[j][i]) );\n\t\t\t\t\t\treg(k,p,i-2){\n\t\t\t\t\t\t\tif(!nl.iscross(ls[k]))ok=false;\n\t\t\t\t\t\t\tif(!ok)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ok)continue;\n\t\t\t\t\t\tnd = min(nd, nl.vec.norm+dp[q][p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[j][i]=nd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lf\\n\",min(dp[0][n],dp[1][n]));\n\t}\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define all(a) a.begin(),a.end()\n#define lb(s,x) lower_bound(all(s),x)-s.begin()\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define INF 1e9\ntypedef long long ll;\n\nconst double EPS = 1e-9;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\n// 2????????????\nVP crosspointCC(Point a, double ar, Point b, double br) {\n  VP ps;\n  Point ab = b-a;\n  double d = abs(ab);\n  double crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  Point abN = ab * Point(0, sqrt(ar*ar - crL*crL) / d);\n  Point cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  ps.push_back(cp - abN);\n  return ps;\n}\n\n// VP crosspointCC(Point p1, double r1, Point p2, double r2){\n//   double d = abs(p2-p1);\n//   double t = acos(double((d*d+r1*r1-r2*r2)/(2*d*r1)));\n//   return Line(p1+polar(r1,arg(p2-p1)+t), p1+polar(r1,arg(p2-p1)-t));\n// }\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// ?????????cross(a,b) = |a||b|sin??\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// ??????????????????\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on ps\n  if (norm(b) < norm(c)) return -2;  // a--b--c on ps or a==b\n  return 0;                          // a--c--b on ps or a==c or b==c\n}\n\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n\nint main(void){\n    int n;\n    while(cin>>n, n){\n        VP c(n);\n        vector<double> r(n);\n        rep(i,n){\n            double x,y;\n            cin>>x>>y>>r[i];\n            c[i] = {x,y};\n        }\n\n        vector<VP> ps(n+1);\n        ps[0] = {c[0],c[0]};\n        ps[n] = {c[n-1],c[n-1]};\n        rep(i,n-1){\n            ps[i+1] = crosspointCC(c[i],r[i],c[i+1],r[i+1]);\n        }\n\n        double d[210][210]={};\n        rep(i,210)rep(j,210)d[i][j]=1e8;\n        rep(i,n) FOR(j,i+1,n+1) rep(i2,2) rep(j2,2) {\n            bool connect=true;\n            FOR(k,i+1,j) {\n                connect &= isecSS(ps[i][i2],ps[j][j2],ps[k][0],ps[k][1]);\n            }\n            if(connect){\n                d[i*2+i2][j*2+j2] = abs(ps[i][i2]-ps[j][j2]);\n            }\n\n        }\n\n        rep(k,n*2+2)rep(i,n*2+2)rep(j,n*2+2)\n            d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n        printf(\"%.9f\\n\",d[0][n*2]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-5;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn !(a==b);\n}\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\nPoint operator/(Point p,double c){\n\treturn Point(p.x/c,p.y/c);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\n\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nstruct Circle{\n\tPoint center;\n\tdouble radius;\n\tCircle(){}\n\tCircle(Point c,double r):center(c),radius(r){}\n\tCircle(double x,double y,double r):center(x,y),radius(r){}\n};\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\nostream& operator<<(ostream& os,const Circle& c){\n\treturn os<<'('<<c.center.x<<','<<c.center.y<<','<<c.radius<<')';\n}\n\npair<Point,Point> InterCC(Circle c1,Circle c2){\n\tPoint p1=c1.center,p2=c2.center;\n\tdouble r1=c1.radius,r2=c2.radius;\n\tdouble d=Abs(p1-p2);\n\tdouble a=(d*d+r1*r1-r2*r2)/(2*d);\n\tdouble s=sqrt(r1*r1-a*a);\n\treturn mp(p1+a/d*(p2-p1)+s*Rot((p2-p1)/d,PI/2),\n\t\t\t  p1+a/d*(p2-p1)-s*Rot((p2-p1)/d,PI/2));\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Circle> cs(n);\n\t\trep(i,n) cin>>cs[i].center.x>>cs[i].center.y>>cs[i].radius;\n\t\t//dump(cs);\n\t\t\n\t\tvector<pair<Point,Point> > ps(n-1);\n\t\trep(i,n-1)\n\t\t\tps[i]=InterCC(cs[i],cs[i+1]);\n\t\t\n\t\t//vvd dp(2*n,vd(2*n,INFTY));\n\t\tvvd dp(2*n,vd(2*n,99));\n\t\trep(i,n-1) repi(j,i,n-1){\n\t\t\tif(i==j){\n\t\t\t\tdp[i*2][i*2]=dp[i*2+1][i*2+1]=0;\n\t\t\t\tdp[i*2][i*2+1]=dp[i*2+1][i*2]=Abs(ps[i].first-ps[i].second);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPoint pi1=ps[i].first,pi2=ps[i].second;\n\t\t\tPoint pj1=ps[j].first,pj2=ps[j].second;\n\t\t\tbool flg11=true,flg12=true,flg21=true,flg22=true;\n\t\t\trepi(k,i+1,j){\n\t\t\t\tPoint pk1=ps[k].first,pk2=ps[k].second;\n\t\t\t\tflg11&=CCW(pi1,pk1,pj1)*CCW(pi1,pk2,pj1)<=0;\n\t\t\t\tflg12&=CCW(pi1,pk1,pj2)*CCW(pi1,pk2,pj2)<=0;\n\t\t\t\tflg21&=CCW(pi2,pk1,pj1)*CCW(pi2,pk2,pj1)<=0;\n\t\t\t\tflg22&=CCW(pi2,pk1,pj2)*CCW(pi2,pk2,pj2)<=0;\n\t\t\t}\n\t\t\tif(flg11) dp[i*2+0][j*2+0]=dp[j*2+0][i*2+0]=Abs(pi1-pj1);\n\t\t\tif(flg12) dp[i*2+0][j*2+1]=dp[j*2+1][i*2+0]=Abs(pi1-pj2);\n\t\t\tif(flg21) dp[i*2+1][j*2+0]=dp[j*2+0][i*2+1]=Abs(pi2-pj1);\n\t\t\tif(flg22) dp[i*2+1][j*2+1]=dp[j*2+1][i*2+1]=Abs(pi2-pj2);\n\t\t}\n\t\tint src=2*(n-1),dst=src+1;\n\t\trep(j,n-1){\n\t\t\tPoint psrc=cs[0].center,pj1=ps[j].first,pj2=ps[j].second;\n\t\t\tbool flgs1=true,flgs2=true;\n\t\t\trep(k,j){\n\t\t\t\tPoint pk1=ps[k].first,pk2=ps[k].second;\n\t\t\t\tflgs1&=CCW(psrc,pk1,pj1)*CCW(psrc,pk2,pj1)<=0;\n\t\t\t\tflgs2&=CCW(psrc,pk1,pj2)*CCW(psrc,pk2,pj2)<=0;\n\t\t\t}\n\t\t\tif(flgs1) dp[src][j*2+0]=dp[j*2+0][src]=Abs(psrc-pj1);\n\t\t\tif(flgs2) dp[src][j*2+1]=dp[j*2+1][src]=Abs(psrc-pj2);\n\t\t}\n\t\trep(i,n-1){\n\t\t\tPoint pdst=cs[n-1].center,pi1=ps[i].first,pi2=ps[i].second;\n\t\t\tbool flgd1=true,flgd2=true;\n\t\t\tperi(k,i+1,n-1){\n\t\t\t\tPoint pk1=ps[k].first,pk2=ps[k].second;\n\t\t\t\tflgd1&=CCW(pdst,pk1,pi1)*CCW(pdst,pk2,pi1)<=0;\n\t\t\t\tflgd2&=CCW(pdst,pk1,pi2)*CCW(pdst,pk2,pi2)<=0;\n\t\t\t}\n\t\t\tif(flgd1) dp[dst][i*2+0]=dp[i*2+0][dst]=Abs(pdst-pi1);\n\t\t\tif(flgd2) dp[dst][i*2+1]=dp[i*2+1][dst]=Abs(pdst-pi2);\n\t\t}\n\t\t{\n\t\t\tPoint psrc=cs[0].center,pdst=cs[n-1].center;\n\t\t\tbool flgsd=true;\n\t\t\trep(k,n-1){\n\t\t\t\tPoint pk1=ps[k].first,pk2=ps[k].second;\n\t\t\t\tflgsd&=CCW(psrc,pk1,pdst)*CCW(psrc,pk2,pdst)<=0;\n\t\t\t}\n\t\t\tif(flgsd) dp[src][dst]=dp[dst][src]=Abs(psrc-pdst);\n\t\t}\n\t\t\n\t\trep(k,2*n) rep(i,2*n) rep(j,2*n)\n\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tprintf(\"%f\\n\",dp[src][dst]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define EPS 1e-5\n#define INF 1e9\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\treturn a+b;\n}\n\nclass P{\npublic:\n\tdouble x,y,r;\n\tP(){}\n\tP(double xx,double yy,double rr){\n\t\tx=xx;\n\t\ty=yy;\n\t\tr=rr;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),r);\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),r);\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,r);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d,r);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nclass node{\npublic:\n\tdouble cost;\n\tint v,v2;\n\tnode(){}\n\tnode(double cc,int vv,int vv2){\n\t\tcost=cc;\n\t\tv=vv;\n\t\tv2=vv2;\n\t}\n\tbool operator< (const node& n1)const{\n\t\treturn cost>n1.cost;\n\t}\n};\n\nint n;\nP p[105];\nP data[105][2];\ndouble dp[105][2];\n\ndouble dijk(){\n\tfor(int i=0;i<=n;i++){\n\t\tdp[i][0]=dp[i][1]=INF;\n\t}\n\tpriority_queue<node> que;\n\tque.push(node(0.0,0,0));\n\tdp[0][0]=0.0;\n\twhile(que.size()){\n\t\tnode q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.v2]<q.cost)continue;\n\t\tfor(int next=q.v+1;next<=n;next++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tif(next==n+1 && j==1)continue;\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int k=q.v+1;k<next;k++){\n\t\t\t\t\tif((data[q.v][q.v2]-data[k][0]).det(data[next][j]-data[k][1])==0){\n\t\t\t\t\t\tif(!(on_seg(data[q.v][q.v2],data[k][0],data[next][j])|| on_seg(data[q.v][q.v2],data[k][0],data[k][1]) || on_seg(data[next][j],data[k][1],data[q.v][q.v2])|| on_seg(data[q.v][q.v2],data[k][1],data[k][0])))flag=false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tP r=intersection(data[q.v][q.v2],data[next][j],data[k][0],data[k][1]);\n\t\t\t\t\t\tif(!(on_seg(data[k][0],data[k][1],r) && on_seg(data[q.v][q.v2],data[next][j],r)))flag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tP len=data[next][j]-data[q.v][q.v2];\n\t\t\t\t\tdouble len2=sqrt((len.x*len.x)+(len.y*len.y));\n\t\t\t\t\tif(dp[q.v][q.v2]+len2<dp[next][j]){\n\t\t\t\t\t\tdp[next][j]=dp[q.v][q.v2]+len2;\n\t\t\t\t\t\tque.push(node(dp[next][j],next,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n][0];\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf\",&p[i].x,&p[i].y,&p[i].r);\n\t\t}\n\t\tdata[0][0]=p[0];\n\t\tdata[n][0]=p[n-1];\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tdouble len=(p[i].x-p[i+1].x)*(p[i].x-p[i+1].x)+(p[i].y-p[i+1].y)*(p[i].y-p[i+1].y);\n\t\t\tdouble d=(p[i].r*p[i].r-p[i+1].r*p[i+1].r+len)/(2*sqrt(len));\n\t\t\tdouble c=sqrt(p[i].r*p[i].r-d*d);\n\t\t\tP pp=p[i+1]-p[i];\n\t\t\tdouble ang=atan2(pp.y,pp.x);\n\t\t\tdouble ang2=atan2(c,d);\n\t\t\tdata[i+1][0]=p[i]+P(p[i].r*cos(ang+ang2),p[i].r*sin(ang+ang2),0);\n\t\t\tdata[i+1][1]=p[i]+P(p[i].r*cos(ang-ang2),p[i].r*sin(ang-ang2),0);\n\t\t}\n\t\tprintf(\"%f\\n\",dijk());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nusing namespace std;\n\nclass coord {\npublic:\n\tdouble x, y;\n\tcoord() {}\n\tcoord(double a, double b) {\n\t\tx = a; y = b;\n\t}\n\tcoord(const coord & a) {\n\t\tx = a.x; y = a.y;\n\t}\n\n};\n\nclass circle {\npublic:\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coord a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coord,coord> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coord,coord> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coord(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coord(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\treturn ret;\n}\n\nbool cross_lseg(coord a_start, coord a_end, coord b_start, coord b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\nnamespace konjo {\ndouble distance(coord a, coord b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coord,coord> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coord(v[0].x, v[0].y), coord(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coord,coord> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(pair<coord,coord>(coord(v[v.size() - 1].x, v[v.size() - 1].y), coord(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = konjo::distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = konjo::distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = konjo::distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = konjo::distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoord start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoord end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と円の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-6;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n\tDD x, y;\n\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n\tfriend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n\t\tthis->push_back(a);\n\t\tthis->push_back(b);\n\t}\n\tfriend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n\tDD r;\n\tCircle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n\tfriend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交差判定, 距離\n////////////////////////////\n\n/*\n ccw を用いている\n \n P: point\n L: Line\n S: Segment\n \n distancePL は、「点」と「直線」の距離\n distancePS は、「点」と「線分」の距離\n */\n\nint ccw_for_dis(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nPoint proj(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(const Point &p, const Line &l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(const Point &p, const Line &l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(const Point &p, const Line &s) {\n    return (ccw_for_dis(s[0], s[1], p) == 0);\n}\nbool isinterLL(const Line &l, const Line &m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(const Line &s, const Line &t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw_for_dis(s[0], s[1], t[0]) * ccw_for_dis(s[0], s[1], t[1]) <= 0 &&\n            ccw_for_dis(t[0], t[1], s[0]) * ccw_for_dis(t[0], t[1], s[1]) <= 0);\n}\nDD distancePL(const Point &p, const Line &l) {\n    return abs(p - proj(p, l));\n}\nDD distancePS(const Point &p, const Line &s) {\n    Point h = proj(p, s);\n    if (isinterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nDD distanceLL(const Line &l, const Line &m) {\n    if (isinterLL(l, m)) return 0;\n    else return distancePL(m[0], l);\n}\nDD distanceSS(const Line &s, const Line &t) {\n    if (isinterSS(s, t)) return 0;\n    else return min(min(distancePS(s[0], t), distancePS(s[1], t)), min(distancePS(t[0], s), distancePS(t[1], s)));\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n\tDD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n\tvector<Point> res;\n\tDD d = cross(m[1] - m[0], l[1] - l[0]);\n\tif (abs(d) < EPS) return vector<Point>();\n\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n\tvector<Point> res;\n\tDD d = abs(e - f);\n\tif (d < EPS) return vector<Point>();\n\tif (d > e.r + f.r + EPS) return vector<Point>();\n\tif (d < abs(e.r - f.r) - EPS) return vector<Point>();\n\tDD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n\tif (e.r - abs(rcos) < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (f - e) / d;\n\tPoint p1 = e + dir * Point(rcos, rsin);\n\tPoint p2 = e + dir * Point(rcos, -rsin);\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n\tvector<Point> res;\n\tPoint p = proj_for_crosspoint(e, l);\n\tDD rcos = abs(e - p), rsin;\n\tif (rcos > e.r + EPS) return vector<Point>();\n\telse if (e.r - rcos < EPS) rsin = 0;\n\telse rsin = sqrt(e.r * e.r - rcos * rcos);\n\tPoint dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tPoint p1 = p + dir * rsin;\n\tPoint p2 = p - dir * rsin;\n\tres.push_back(p1);\n\tif (!eq(p1, p2)) res.push_back(p2);\n\treturn res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n\tint N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n\n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n\n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n            //cout << i << \": \" << dp[i] << endl;\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <sstream>\n  \nusing namespace std;\n  \n#define EPS 1e-9\n \nstruct point{\n    double x, y;\n    point(){x = 0;y = 0;}\n    point(double a, double b) : x(a), y(b) {}\n};\n  \ndouble dis(point p1,point p2){\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n \nint ccw(point p1, point p2, point p3) {\n    double ret = (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x);\n    if(abs(ret)<EPS) return 0;\n    return ret > 0 ? 1 : -1;\n}\n \nstruct Line {\n\tpoint p1,p2;\n\tdouble A,B,C;\n    double getDis() {\n        return dis(p1,p2);\n    }\n    Line() {}\n    Line(double xx1, double yy1, double xx2, double yy2) {\n\t\tp1 = point(xx1,yy1), p2 = point(xx2,yy2);\n\t\tA = p1.y-p2.y, B = p2.x-p1.x, C = -(A*p1.x+B*p1.y);\n\t}\n\tLine(point t1, point t2) {\n\t\tp1 = t1, p2 = t2;\n\t\tA = p1.y-p2.y, B = p2.x-p1.x, C = -(A*p1.x+B*p1.y);\n\t}\n};\n  \nbool is_in_line_seg(double x, double y, Line LL) {\n    if(!( min(LL.p1.x,LL.p2.x)-EPS <= x && x <= max(LL.p1.x,LL.p2.x)+EPS \n        && min(LL.p1.y,LL.p2.y)-EPS <= y && y <= max(LL.p1.y,LL.p2.y)+EPS))\n        return false;\n    return abs( LL.A*x + LL.B*y + LL.C ) < EPS;\n}\n\nbool intersection_line_line(Line L1, Line L2, point &p) {\n\tdouble det = L1.A*L2.B - L2.A*L1.B;\n\tif(abs(det) < EPS) return 0;\n\tp.x = -(L2.B*L1.C - L1.B*L2.C) / det;\n\tp.y = -(L1.A*L2.C - L2.A*L1.C) / det;\n\treturn 1;\n}\n\nbool is_cross_line_seg(Line L1, Line L2) {\n\tpoint p;\n\tif(!intersection_line_line(L1,L2,p)) return 0;\n\treturn is_in_line_seg(p.x,p.y,L1) && is_in_line_seg(p.x,p.y,L2);\n}\n  \npoint intersection(point &u1,point &u2,point &v1,point &v2){\n    point ret=u1;\n    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\n    /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\n    ret.x+=(u2.x-u1.x)*t;\n    ret.y+=(u2.y-u1.y)*t;\n    return ret;\n}\n  \nvoid intersection_line_circle(point c, double r,point &l1,point &l2,point& p1,point&p2){\n    point p=c;\n    double t;\n    p.x+=l1.y-l2.y;\n    p.y+=l2.x-l1.x;\n    p=intersection(p,c,l1,l2);\n    t=sqrt(r*r-dis(p,c)*dis(p,c))/dis(l1,l2);\n    p1.x=p.x+(l2.x-l1.x)*t;\n    p1.y=p.y+(l2.y-l1.y)*t;\n    p2.x=p.x-(l2.x-l1.x)*t;\n    p2.y=p.y-(l2.y-l1.y)*t;\n}\n  \nvoid intersection_circle_circle(point c1, double r1,point c2,double r2,point& p1, point& p2){\n    point u,v;\n    double t;\n    t=(1+(r1*r1-r2*r2)/dis(c1,c2)/dis(c1,c2))/2;\n    u.x=c1.x+(c2.x-c1.x)*t;\n    u.y=c1.y+(c2.y-c1.y)*t;\n    v.x=u.x+c1.y-c2.y;\n    v.y=u.y-c1.x+c2.x;\n    intersection_line_circle(c1,r1,u,v,p1,p2);\n}\n\npoint P[111],cP[111][2];\nint X[111],Y[111],R[111],n;\ndouble dp[111][2];\nLine LL[111];\n \nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\n    while(1) {\n        for(int i=0;i<111;++i) dp[i][0] = 1e20, dp[i][1] = 1e20;\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        for(int i=0;i<n;++i) scanf(\"%d%d%d\",X+i,Y+i,R+i), P[i] = point(X[i],Y[i]);\n        cP[0][0] = P[0], cP[0][1] = P[0];\n        cP[n][0] = P[n-1], cP[n][1] = P[n-1];\n        for(int i=0;i<n-1;++i) {\n            intersection_circle_circle(P[i],R[i],P[i+1],R[i+1],cP[i+1][0],cP[i+1][1]);\n            LL[i+1] = Line(cP[i+1][0],cP[i+1][1]);\n        }\n \n        dp[0][0] = dp[0][1] = 0;\n        for(int i=1;i<=n;++i) for(int ai=0;ai<2;++ai) {\n            for(int j=0;j<i;++j) for(int aj=0;aj<2;++aj) {\n                bool can = 1;\n                Line line = Line(cP[i][ai],cP[j][aj]);\n                for(int k=j+1;k<i;++k) {\n                    if(!is_cross_line_seg(line,LL[k])) {can = 0; break;}\n                }\n \n                if(can) dp[i][ai] = min(dp[i][ai], dp[j][aj] + line.getDis());\n            }\n        } printf(\"%.10lf\\n\",dp[n][0]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.emplace_back(c, c);\n\t\t\telse{\n\t\t\t\ts.push_back(S(P(0,1), P(0,0)));//cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.emplace_back(prev, prev);\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.6f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <cassert>\n#include <complex>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> point;\nconst double EPS = 1e-9;\n\nnamespace std {\n\tbool operator==(const point &p, const point &q) {\n\t\treturn abs(p.X - q.X) < EPS && abs(p.Y - q.Y) < EPS;\n\t}\n\n\tbool operator!=(const point &p, const point &q) {\n\t\treturn !(p == q);\n\t}\n\n\tbool operator<(const point &p, const point &q) {\n\t\treturn p.X + EPS < q.X || abs(p.X - q.X) < EPS && p.Y + EPS < q.Y;\n\t}\n\n\tbool operator>(const point &p, const point &q) {\n\t\treturn q < p;\n\t}\n}\n\ndouble dot(const point &l, const point &r) {\n\treturn real(conj(l)*r);\n}\n\ndouble cross(const point &l, const point &r) {\n\treturn imag(conj(l)*r);\n}\n\npoint rotate90(const point &p)\n{\n\treturn point(-p.Y, p.X);\n}\n\npoint rotate(const point &p, const double theta)\n{\n\treturn polar(abs(p), arg(p)+theta);\n}\n\nstruct line {\n\tpoint a, b;\n\tline(const point& a, const point& b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point& a, const point& b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(cross((l.b - l.a), (p - l.a))) / abs(l.b - l.a);\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tif(dot((s.b - s.a), (p - s.a)) < 0) return abs(p - s.a);\n\tif(dot((s.a - s.b), (p - s.b)) < 0) return abs(p - s.b);\n\treturn dist(line(s.a, s.b), p);\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline bool intersect(const circle& c, const segment& s) {\n\treturn dist(s, c.c) < c.r + EPS;\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\n//先に，intersectを用いて交差判定を行うこと\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.X * b.Y - b.X * a.Y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn abs(res) * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.X - a.Y + b.X + b.Y) / 2.0, (a.Y + a.X + b.Y - b.X) / 2.0),\n\t\t\t\tpoint((a.X + a.Y + b.X - b.Y) / 2.0, (a.Y - a.X + b.Y + b.X) / 2.0));\n}\n\n// 点集合 pointsの凸包を求める．\ninline polygon convex_hull(vector<point> points) {\n\tconst int n = points.size();\n\tif(n <= 3)\n\t\treturn points;\n\n\tsort(points.begin(), points.end());\n\tint k = 0;\n\tpolygon res;\n\tres.resize(2 * n);\n\tfor(int i = 0; i < n; res[k++] = points[i++])\n\t\twhile(k >= 2 && ccw(res[k - 2], res[k - 1], points[i]) <= 0)\n\t\t\t--k;\n\n\tconst int t = k + 1;\n\tfor(int i = n - 2; i >= 0; res[k++] = points[i--])\n\t\twhile(k >= t && ccw(res[k - 2], res[k - 1], points[i]) <= 0)\n\t\t\t--k;\n\n\tres.resize(k - 1);\n\treturn res;\n}\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\n// 三角形と点の包含関係，境界は含まない．\n// 含める場合は == -1を <= 0とする．\nbool contain_triangle(const polygon& triangle, const point& p) {\n\tconst int d1 = ccw(p, triangle[0], triangle[1]), d2 = ccw(p, triangle[1], triangle[2]), d3 = ccw(p, triangle[2], triangle[0]);\n\treturn !(d1 * d2 == -1 || d2 * d3 == -1 || d3 * d1 == -1);\n}\n\n// 多角形と点の包含関係．境界を含む．\nbool contain(const polygon& P, const point& p) {\n\tconst int n = P.size();\n\tbool res = false;\n\tfor(int i = 0; i < n; ++i) {\n\t\tpoint v1 = P[i] - p, v2 = P[(i + 1) % n] - p;\n\t\tif(v1.Y > v2.Y)\n\t\t\tswap(v1, v2);\n\n\t\tif(v1.Y < EPS && EPS < v2.Y && cross(v1, v2) > EPS)\n\t\t\tres = !res;\n\n\t\tif(abs(cross(v1, v2)) < EPS && dot(v1, v2) < EPS)\n\t\t\treturn true; // 境界を含まないなら，falseにする．\n\t}\n\n\treturn res;\n}\n\nint n;\nint start, goal;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n};\n\nconst double INF = 1e100;\nconst int MAX = 300;\nvector<edge> G[MAX];\n\ntypedef pair<double, int> pdi;\ndouble d[MAX];\nbool connect[MAX][MAX];\n\nclass node {\npublic:\n\tint v;\n\tnode() {}\n\tnode(int v):v(v) {}\n\n\tbool operator<(const node &r) const {\n\t\treturn d[v] > d[r.v];\n\t}\n};\n\nvector< pair<point, pii> > ps;\n\ndouble dijkstra()\n{\n\tfill(d, d+MAX, INF);\n\tpriority_queue<node> que;\n\n\td[start] = 0;\n\tque.push(node(start));\n\twhile (!que.empty()) {\n\t\tnode n = que.top(); que.pop();\n\t\tif (n.v == goal)\n\t\t\tbreak;\n\t\trep(i, G[n.v].size()) {\n\t\t\tedge e = G[n.v][i];\n\t\t\tdouble c = d[n.v] + e.cost;\n\t\t\tif (d[e.to] > c) {\n\t\t\t\td[e.to] = c;\n\t\t\t\tque.push(node(e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d[goal];\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tvector<circle> cs;\n\t\tps.clear();\n\n\t\trep(i, n) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tcs.push_back(circle(point(x, y), r));\n\t\t}\n\n\t\tps.push_back(make_pair(cs[0].c, pii(0, 0)));\n\t\tfor (int i = 1; i < cs.size(); i++) {\n\t\t\tif (intersect(cs[i-1], cs[i])) {\n\t\t\t\tvector<point> buf = crosspoint(cs[i-1], cs[i]);\n\t\t\t\trep (j, 2)\n\t\t\t\t\tps.push_back(make_pair(buf[j], pii(i-1, i)));\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint t = cs.size()-1;\n\t\t\tps.push_back(make_pair(cs[t].c, pii(t, t)));\n\t\t}\n\n\t\tint sz = ps.size();\n\t\trep(i, sz) {\n\t\t\tREP(j, i+1, sz) {\n\t\t\t\tint lb = ps[i].second.second;\n\t\t\t\tint ub = ps[j].second.first;\n\t\t\t\tbool f = true;\n\t\t\t\tsegment s = segment(ps[i].first, ps[j].first);\n\t\t\t\tfor (int k = lb+1; k <= ub; k++) {\n\t\t\t\t\tvector<point> buf = crosspoint(cs[k-1], cs[k]);\n\t\t\t\t\tsegment t = segment(buf[0], buf[1]);\n\t\t\t\t\tif (!intersect(s, t))\n\t\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t\tconnect[i][j] = f;\n\t\t\t\tconnect[j][i] = f;\n\t\t\t}\n\t\t}\n\n\t\trep(i, sz) {\n\t\t\tvector<edge> e;\n\t\t\trep(j, sz) {\n\t\t\t\tif (j == i) continue;\n\t\t\t\tif (connect[i][j]) {\n\t\t\t\t\tdouble d = dist(ps[i].first, ps[j].first);\n\t\t\t\t\te.push_back( (edge){ j, d } );\n\t\t\t\t}\n\t\t\t}\n\t\t\tG[i] = e;\n\t\t}\n\n\t\tstart = 0;\n\t\tgoal = sz-1;\n\t\tprintf(\"%.20lf\\n\", dijkstra());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define INF 1<<31\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return 1;\n  if(cross(a,b)<-EPS)return -1;\n  if(dot(a,b)<-EPS)return 2;\n  if(norm(a)<norm(b))return -2;\n  return 0;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n/////------Library END-------//////////////////////////////////////\nint main(){\n  int n;\n  while(cin>>n,n){\n    Point p[n*2];int gg=0,j=1;\n    Circle c[n];\n    seg a[n-1],s,t;\n    r(i,n)cin>>c[i].c.x>>c[i].c.y>>c[i].r;\n    r(i,n-1)a[i]=getCrossPoints(c[i],c[i+1]);\n    for(int i=0;i<n-1;i++){\n      p[j]=a[i].p1;j++;\n      p[j]=a[i].p2;j++;\n    }p[0]=c[0].c;p[n*2-1]=c[n-1].c;\n    s.p1=c[0].c;s.p2=c[n-1].c;\n    double w[n*2][n*2];//\n    r(i,n*2)r(j,n*2)w[i][j]=10000000;\n    R(i,0,n*2){\n      R(j,i,n*2){\n        int q1,q2,cc=0;\n        r(k,n-1){if(p[i]==a[k].p1||p[i]==a[k].p2){q1=k;break;}}\n        r(k,n-1){if(p[j]==a[k].p1||p[j]==a[k].p2){q2=k;break;}}\n        if(!i)q1=0;\n        if(j==n*2-1)q2=n-1;\n        else q2++;\n        s.p1=p[i];s.p2=p[j];int ju=q2-q1;\n        R(k,0,n-1)if(intersect(s,a[k]))cc++;\n        if(cc>=ju)w[i][j]=w[j][i]=getDistancePP(p[i],p[j]);\n      }\n    }\n    r(k,n*2)r(i,n*2)r(j,n*2)w[i][j]=min(w[i][j],w[i][k]+w[k][j]);\n    printf(\"%.11f\\n\",w[0][n*2-1]);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \n//constexpr double inf = numeric_limits<double>::max() / 10; \nconstexpr double inf = 30000;\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nnamespace Geometry{\n    struct Point{\n        double x,y;\n        Point(){}\n        Point(double a,double b) : x(a),y(b){}\n        Point(const Point& p) : x(p.x),y(p.y){}\n        Point operator + (Point p){\n            return Point(x+p.x,y+p.y);\n        }\n        Point operator - (Point p){\n            return Point(x-p.x,y-p.y);\n        }\n        Point operator * (double k){\n            return Point(x*k,y*k);\n        }\n    };\n    using Vector = Point;\n    struct Circle{\n        Point c;\n        double r;\n        Circle(){}\n        Circle(Point p,double c) : c(p),r(c){}\n        Circle(double a,double b,double c) : c(Point(a,b)) , r(c){}\n    };\n\n    // for debug\n    ostream& operator<<(ostream& os,const Point& p){\n        os << \"{\" << p.x <<\",\" << p.y <<\"}\";\n        return os;\n    }\n    ostream& operator<<(ostream& os,const Circle& c){\n        os << \"{(\" << c.c.x << \",\" << c.c.y <<\"),\" << c.r << \"}\";\n        return os;\n    }\n\n    // ?????????????????£??????\n    Vector normalize(Vector v){\n        double t = sqrt(v.x*v.x+v.y*v.y);\n        return Vector(v.x/t,v.y/t);\n    }\n\n    // ?????¨???????????¢\n    inline double distance(Point a,Point b){\n        double x=a.x-b.x;\n        double y=a.y-b.y;\n        return sqrt(x*x+y*y);\n    }\n\n    // ????????????\n    pair<Point,Point> getCrossPoint(Circle c1,Circle c2){\n        double d = distance(c1.c,c2.c);\n        Vector v = normalize(c2.c - c1.c);  // ??£????????????????????????????????????\n        Vector dualv = Vector(-v.y,v.x);    // v??¨?????´???????????????\n        double Cos = (c1.r*c1.r+d*d-c2.r*c2.r) / (2*c1.r*d);\n        double Sin = sqrt(1-Cos*Cos);\n        Point a = c1.c + v*Cos*c1.r + dualv*Sin*c1.r;\n        Point b = c1.c + v*Cos*c1.r - dualv*Sin*c1.r;\n        return make_pair(a,b);\n    }\n};\n\nusing namespace Geometry;\n\nint N;\nCircle cir[128];\ndouble x[128],y[128],r[128];\nvector<pair<Point,Point>> cross;\nvector<Point> poi;\nint NN;\n\nvoid solve(){\n    cross.assign(0,pair<Point,Point>());\n    poi.assign(0,Point());\n    rep(i,N){\n        cin >> x[i] >> y[i] >> r[i];\n        cir[i] = Circle(x[i],y[i],r[i]);\n    }\n    for(int i=0;i<N-1;i++){\n        cross.pb(getCrossPoint(cir[i],cir[i+1]));\n    }\n\n    NN = cross.size() * 2 + 2;\n    poi.push_back(Point(x[0],y[0]));\n    for(int i=0;i<cross.size();i++){\n        poi.push_back(cross[i].fi);\n        poi.push_back(cross[i].se);\n    }\n    poi.push_back(Point(x[N-1],y[N-1]));\n\n    vector<vector<double>> d(NN,vector<double>(NN,inf));\n    for(int i=0;i<NN;i++) d[i][i] = 0;\n    for(int i=0;i<NN;i++){\n        for(int j=i+1;j<NN;j++){\n            d[i][j] = d[j][i] = distance(poi[i],poi[j]);\n        }\n    }\n\n    for(int i=0;i<NN;i++){\n        for(int j=i+1;j<NN;j++){\n            bool ok = true;\n            int idx1,idx2;\n            idx1 = (i%2==0) ? i+1 : i+2;\n            idx2 = (j%2==1) ? j-1 : j-2;\n            Vector a(poi[i]-poi[j]);\n            for(int k=idx1;k<=idx2;k+=2){\n                if(k+1>idx2) break;\n                Vector b(poi[k]-poi[i]);\n                Vector c(poi[k+1]-poi[i]);\n                double t1 = a.x*b.y - a.y*b.x;\n                double t2 = a.x*c.y - a.y*c.x;\n                if(t1*t2 >= 0){\n                    ok=false;\n                    break;\n                }\n            }\n            if(!ok){\n                d[i][j] = d[j][i] = inf;\n            }\n        }\n    }\n\n\n    for(int k=0;k<NN;k++){\n        for(int i=0;i<NN;i++){\n            for(int j=0;j<NN;j++){\n                double tmp = d[i][j];\n                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n\n\n    cout << Double(d[0][NN-1]) << endl;\n}\n\nint main(){\n    while(1){\n        cin >> N;\n        if(N==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\n#define eps (1e-10)\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n    Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n    Point operator*(Point p) {return Point(x*p.x-y*p.y,x*p.y+y*p.x);}\n    Point operator*(double k){return Point(x*k,y*k);}\n    double norm(){return x*x+y*y;}\n    double abs(){return sqrt(norm());}\n    bool operator == (const Point &p) const{return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n    double arg(){return atan2(y,x);}\n    double dot(Point p){return x*p.x+y*p.y;}\n    double det(Point p){return x*p.y-y*p.x;}\n};\nint ccw(Point a,Point b,Point c){\n    Point t1=b-a,t2=c-a;\n    if(t1.det(t2)> eps) return 1;//counter clockwise\n    if(t1.det(t2)< -eps) return -1;//clockwise\n    if(t1.dot(t2)< -eps) return 2;//c-a-b online\n    if(t1.norm()<t2.norm()) return -2;//a-b-c online\n    return 0;//a-c-b online\n}\nbool cmp_x(const Point& p,const Point& q){\n  if(p.x!=q.x) return p.x<q.x;\n  return p.y<q.y;\n}\nbool intersectSS(Point a,Point b,Point c,Point d){\n    return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\nstruct Circle{\n    double r;\n    Point p;\n    Circle(){}\n    Circle(Point p,double r):p(p),r(r){}\n};\nbool isIntersectCC(Circle c1,Circle c2){\n    return (c1.p-c2.p).abs()<=c1.r+c2.r+eps;\n}\npair<Point,Point> CrossPointsCC(Circle c1,Circle c2){\n    assert(isIntersectCC(c1,c2));\n    double d=(c1.p-c2.p).abs();\n    double k=acos((d*d+c1.r*c1.r-c2.r*c2.r)/(c1.r*d*2));\n    return make_pair(c1.p+(c2.p-c1.p)*Point(cos(k),sin(k))*(c1.r/d),c1.p+(c2.p-c1.p)*Point(cos(-k),sin(-k))*(c1.r/d));\n}\ndouble INF=1000100010;\ndouble d[101][2];\nCircle c[101];\nPoint po[101][2];\nbool ck(int l,int r,int idl,int idr){\n    Point lp=po[l][idl],rp=po[r][idr];\n    FOR(i,l+1,r){\n        if(!intersectSS(lp,rp,po[i][0],po[i][1])) return false;\n    }\n    return true;\n}\nint main(){\n    int n;\n    double xi,yi,ri;\n    while(cin>>n,n){\n        rep(i,n+1) d[i][0]=d[i][1]=INF;\n        rep(i,n){\n            cin>>xi>>yi>>ri;\n            if(i==0) po[i][0]=po[i][1]=Point(xi,yi);\n            if(i==n-1) po[n][0]=po[n][1]=Point(xi,yi);\n            c[i]=Circle(Point(xi,yi),ri);\n        }\n        rep(i,n-1){\n            pair<Point,Point> pp=CrossPointsCC(c[i],c[i+1]);\n            po[i+1][0]=pp.first;po[i+1][1]=pp.second;\n        }\n        d[0][0]=d[0][1]=0.0;\n        rep(i,n)rep(k,2)FOR(j,i+1,n+1)rep(l,2){\n            if(ck(i,j,k,l)){\n                d[j][l]=min(d[j][l],d[i][k]+(po[i][k]-po[j][l]).abs());\n            }\n        }\n        cout<<fixed<<setprecision(12)<<d[n][0]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<double,int>P;\ntypedef complex<double> C;\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nconst int MAX_N = 105;\n\nC v[MAX_N];\nint r[MAX_N];\nvector<edge> G[2*MAX_N];\nint n;\ndouble d[2*MAX_N];\n\nnamespace std {\n  bool operator < (const C& a, const C& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const C& a, const C& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const C& a, const C& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<C> {\n  L(const C &a, const C &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(C a, C b, C c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const C &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nL cross_line(C p1,int r1,C p2,int r2)\n{\n    double d = norm(p2-p1);\n    double t = r2*r2 - r1*r1 - d;\n    double aa = d,bb = t*(real(p2)-real(p1)),cc = t*t / 4.0 - (imag(p2) - imag(p1))*(imag(p2) - imag(p1))*r1*r1;\n    double x1 = (-bb + sqrt(bb*bb - 4*aa*cc))/(2*aa);\n    double x2 = (-bb - sqrt(bb*bb - 4*aa*cc))/(2*aa);\n    double y1,y2;\n    if(imag(p1) == imag(p2)){\n        y1 = sqrt(r1*r1 - x1*x1);\n        y2 = -y1;\n    }else{\n        y1 = (t+2*(real(p2)-real(p1))*x1)/(-2*(imag(p2)-imag(p1)));\n        y2 = (t+2*(real(p2)-real(p1))*x2)/(-2*(imag(p2)-imag(p1)));\n    }\n    L ln = L(C(x1+real(p1),y1+imag(p1)),C(x2+real(p1),y2+imag(p1)));\n    return ln;\n}\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0.0;\n\tque.push(P(0.0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tque.push(P(d[G[v][i].to],G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        rep(i,2*n){\n            G[i].clear();\n        }\n    \trep(i,n){\n            int bf1,bf2;\n    \t\tscanf(\"%d%d%d\",&bf1,&bf2,&r[i]);\n            v[i] = C(bf1,bf2);\n    \t}\n        vector<L> vec;\n        vector<L> sect;\n        rep(i,n-1){\n            vec.push_back(cross_line(v[i],r[i],v[i+1],r[i+1]));\n        }\n        bool fl = false;\n        rep(k,n-1){\n            if(!intersectSS(L(v[0],v[n-1]),vec[k])){\n                fl =true;\n                break;\n            }\n        }\n        if(!fl){\n            G[0].push_back((edge){2*n-1,abs(v[n-1] - v[0])});\n        }\n        rep(j,n-1){\n            rep(id,2){\n                bool flag = false;\n                rep(k,j){\n                    if(!intersectSS(L(v[0],vec[j][id]),vec[k])){\n                        flag =true;\n                        break;\n                    }\n                }\n                if(!flag){\n                    G[0].push_back((edge){2*j+1+id,abs(vec[j][id] - v[0])});\n                }\n            }\n        }\n        rep(i,n-2){\n            for(int j=i+1;j<=n-2;j++){\n                rep(id,2){\n                    rep(id2,2){\n                        bool flag = false;\n                        for(int k = i+1;k < j;k++){\n                            if(!intersectSS(L(vec[i][id],vec[j][id2]),vec[k])){\n                                flag = true;\n                                break;\n                            }\n                        }\n                        if(!flag){\n                            G[2*i+1+id].push_back((edge){2*j+1+id2,abs(vec[j][id2] - vec[i][id])});\n                        }\n                    }\n                }\n            }\n        }\n        rep(j,n-1){\n            rep(id,2){\n                bool flag = false;\n                for(int k = j+1;k <= n-2;k++){\n                    if(!intersectSS(L(v[n-1],vec[j][id]),vec[k])){\n                        flag =true;\n                        break;\n                    }\n                }\n                if(!flag){\n                    G[2*j+1+id].push_back((edge){2*n-1,abs(vec[j][id] - v[n-1])});\n                }\n            }\n        }\n        fill(d,d+n*2,INF);\n        dijkstra(0);\n        printf(\"%.6f\\n\",d[2*n-1]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double R;//double long double ??????????????? cmath?????¢??°??????????????????????????????????????????????????§????????????\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//??????\n#define EQ(a,b) (abs((a)-(b)) < EPS)//??????????????°???????????????\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//????????????????????????????????????\n\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint n;\nCircle c[200];\n\nR dot(Point a,Point b){\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\nbool is_intersection_two_line_segment(Line a,Line b){\n    Point a1 = a.first,a2 = a.second,b1 = b.first,b2 = b.second;\n    return ( cross(a2 - a1,b1 - a1) * cross(a2 - a1,b2 - a1) < EPS) && (cross(b2 - b1,a1 - b1) * cross(b2 - b1, a2 - b1) < EPS);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//????????????????????????Line?????\\????????????(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))???????????????????????????\n    R a =  abs(c2.first - c1.first);\n    R b = c1.second;\n    R c = c2.second;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ??§???????????????????????????????????§???????????????sqrt ????????? float ?????????????????? long double ????????????????????????????????????????????¨?????§???????????? C ????????°????????§??????sqrt ????????? double ??????????????£??????????????????\n    Point diff = (c2.first - c1.first) / a;\n\n    Line p ;\n    p.first = c1.first + diff * rc + diff * Point(0,1) * rs;\n    p.second = c1.first + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\nbool input(){\n    scanf(\"%d\",&n);\n\n    if(n == 0)\n        return false;\n    REP(i,n){\n        double re,im;\n        cin >> re >> im  >> c[i].second;\n        c[i].first = Point(re,im);\n    }\n    return true;\n}\n\ndouble G[1000][1000];\nPoint ver[200][2];\n\nbool judgecross(Point a,Point b,int a1,int b1){\n    Line c(a,b);\n     FOR(i,a1+1,b1){\n         Line d(ver[i][0],ver[i][1]);\n         if(!is_intersection_two_line_segment(c,d))\n             return false;\n    }\n    return true;\n}\n\n\nvoid solve(){\n    REP(i,1000)\n        REP(j,1000)\n            G[i][j] = 1000000000.0;\n    REP(i,1000)\n        G[i][i] = 0.0;\n\n    REP(i,n-1){\n        Line inter = intersection_of_two_circles(c[i],c[i+1]);\n        ver[i][0] = inter.first;\n        ver[i][1] = inter.second;\n    }\n    //REP(i,n-1)\n        //printf(\"%lf %lf    %lf %lf\\n\",ver[i][0].real(),ver[i][0].imag(),ver[i][1].real(),ver[i][1].imag());\n    REP(i,(n - 1) * 2){\n        FOR(j,i + 1,(n - 1) * 2){\n            int i1 = i / 2;int i2 = i % 2;\n            int j1 = j / 2;int j2 = j % 2;\n            if(!judgecross(ver[i1][i2],ver[j1][j2],i1,j1))\n                continue;\n            G[i][j] = G[j][i] = abs(ver[i1][i2] - ver[j1][j2]);\n        }\n    }\n    Point start(c[0].first.real(),c[0].first.imag());\n    REP(i,(n - 1) * 2){\n        int i1 = i / 2;int i2 = i % 2;\n        if(!judgecross(start,ver[i1][i2],-1,i1))\n            continue;\n        G[i][n * 2 - 2]  = G[n * 2 - 2][i] = abs(start - ver[i1][i2]);\n    }\n    Point end(c[n-1].first.real(),c[n-1].first.imag());\n    REP(i,(n - 1) * 2){\n        int i1 = i / 2;int i2 = i % 2;\n        if(!judgecross(ver[i1][i2],end,i1,n-1))\n            continue;\n        G[i][n * 2 - 1] = G[n * 2 - 1][i] = abs(end - ver[i1][i2]);\n    }\n    if(judgecross(start,end,-1,n-1))\n        G[n * 2 - 1][n * 2 - 2] = G[n * 2 - 2][n * 2 - 1] = abs(start - end);\n    REP(k,n*2){\n        REP(i,n*2){\n            REP(j,n*2){\n                G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n            }\n        }\n    }\n    printf(\"%lf\\n\",G[n*2-2][n*2-1]);\n}\n\nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i, n) for(int i = 0; i < (int)(n); i++)\n\ntypedef long double D;\ntypedef complex<D> P;\n\n\nconst D EPS=1e-8,INF=1e12;\nstatic constexpr D Ae=0;\n\ntemplate<typename T> int sig(T a,T b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\ntemplate<typename T> int eq(T a,T b){return sig(abs(a-b))==0;}\n\n\nD cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\n\nD dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(const P& a, P b, P c) {\n\tb -= a; c -=a;\n\tif (cross(b, c) > 0) return 1;\n\tif (cross(b, c) < 0) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\n// D pfmod(D v, D MOD) {\n// \tD ret = pfmod(max(a, -a), 2*M_PI);\n// \treturn min(ret, 2*M_PI-ret);\n// }\n\nstruct L :public vector<P>{\n\tL(const P& a,const P& b){\n\t\tpush_back(a);push_back(b);\n\t}\n};\n\nbool isIntersectSS(const L&s,const L&t){\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0 &&\n\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nstruct C{\n\tP o;D r;\n\tC(const P &o,D r):o(o),r(r){}\n};\n\nenum RELATION{INCOMPARABLE=0,SAME=1,CONTAIN=2,OVER=4};\n\npair<RELATION,int> cRel(const C&c1,const C&c2){\n\tD d=abs(c1.o-c2.o);\n\tif(eq(c1.o,c2.o) && eq(c1.r,c2.r)) return make_pair(SAME,1<<28);\n\tif(sig(d,c1.r-c2.r)<0)return make_pair(OVER,0);\n\tif(sig(d,c2.r-c1.r)<0)return make_pair(CONTAIN,0);\n\tif(sig(d,c1.r-c2.r)==0)return make_pair(OVER,1);\n\tif(sig(d,c2.r-c1.r)==0)return make_pair(CONTAIN,1);\n\tif(sig(d,c1.r+c2.r)==0)return make_pair(INCOMPARABLE,1);\n\tif(sig(d,c1.r+c2.r)<0)return make_pair(INCOMPARABLE,2);\n\treturn make_pair(INCOMPARABLE,0);\n}\n\nvector<P> IntersectionCC(const C&c1,const C&c2){\n\tpair<RELATION,int> rel=cRel(c1,c2);\n\tD d=abs(c2.o-c1.o);\n\tP diff=(c2.o-c1.o)/d;\n\tvector<P> res;\n\tif(rel.second==1){\n\t\tres.push_back(c1.o+diff*c1.r);\n\t}else if(rel.second==2){\n\t\tdouble rc=(d*d +c1.r*c1.r-c2.r*c2.r)/(2*d);\n\t\tdouble rs=sqrt(c1.r*c1.r-rc*rc);\n\t\tres.push_back(c1.o+diff*P(rc,rs));\n\t\tres.push_back(c1.o+diff*P(rc,-rs));\n\t} \n\treturn res;\n}\n\n\n\n\n\nint main() {\n\n\tcout <<fixed<< setprecision(20);\n\twhile(true){\n\t\tint n;cin >> n;if(n==0)break;\n\n\t\tvector<C> cs;\n\t\tREP(i,n){\n\t\t\tD x,y,r;cin >> x >> y >> r;\n\t\t\tcs.push_back(C(P(x,y),r));\n\t\t} \n\n\t\tvector<P> ps;\n\t\tps.push_back(cs[0].o);\n\n\n\t\tfor(int i=0;i+1<n;i++){\n\t\t\tvector<P> cps=IntersectionCC(cs[i],cs[i+1]);\n\t\t\tREP(j,cps.size()){\n\t\t\t\tps.push_back(cps[j]);\n\t\t\t}\n\t\t}\n\t\tps.push_back(cs[cs.size()-1].o);\n\n\n\t\tvector<vector<bool>> reachable(ps.size(),vector<bool>(ps.size()));\n\t\tREP(i,ps.size())REP(j,ps.size())if(i<j){\n\t\t\tint ll=(i-1)/2+1,rl=(j-1)/2-1;\n\t\t\tif(i==0)ll=0;\n\n\t\t\tbool ok=true;\n\t\t\tfor(int l=ll;l<=rl;l++){\n\t\t\t\tif(!isIntersectSS(L(ps[2*l+1],ps[2*l+2]),L(ps[i],ps[j]))){\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treachable[i][j]=ok;\n\t\t}\n\n\n// REP(i,ps.size())REP(j,ps.size())if(i<j){\n// \tcout << i<<\":\"<<j<<\":\"<<reachable[i][j]<<endl;\n// }\t\t\n\n\t\tvector<D> dp(ps.size(),INF);\n\t\tdp[0]=0;\n\t\tfor(int j=1;j<ps.size();j++){\n\t\t\tD v=INF;\n\t\t\tfor(int i=0;i<j;i++)if(reachable[i][j]){\n\t\t\t\tv=min(v,dp[i]+abs(ps[i]-ps[j]));\n\t\t\t}\n\t\t\tdp[j]=v;\n\t\t}\n\n\t\tcout << dp[ps.size()-1]<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n\n#define INF 1000000.0\n\nusing namespace std;\n\nstruct P{\n\tdouble x, y;\n\tP(double X=0.0, double Y=0.0){\n\t\tx = X;\n\t\ty = Y;\n\t} \n\tP operator+( const P &in ){\n\t\tP tmp( x + in.x , y + in.y );\n\t\treturn tmp;\n\t}\n\tP operator-( const P &in ){\n\t\tP tmp( x - in.x , y - in.y );\n\t\treturn tmp;\n\t}\n\tP operator*( const double &in ){\n\t\tP tmp( x * in , y * in );\n\t\treturn tmp;\n\t}\n\tdouble dot( const P &in ){\n\t\treturn x * in.x + y * in.y;\n\t}\n\tdouble cross( const P &in ){\n\t\treturn x * in.y - y * in.x;\n\t}\n};\n\n\n//交差しているか求める(どの3点も同直線上にない)\nbool check(P a1, P a2, P b1, P b2){\n\tP va = a2 - a1, vb = b2 - b1;\n\tP v1 = b1 - a1, v2 = b2 - a2;\n\n\tif( ( va.cross( v1 ) * va.cross( v2 ) ) < 0.0 &&\n\t\t( vb.cross( v1 ) * vb.cross( v2 ) ) < 0.0 )\n\t\treturn true;\n\t\n\treturn false;\n}\n\n//2円の交点を求める(2円の中心の中点cからのベクトルvを返す(交点はc±v) )\nvoid circlecross(P a, double ra, P b, double rb, P *p1, P *p2){\n\n\tdouble c = sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );\n\tdouble r = (ra*ra - rb*rb + c*c ) / ( 2.0 * c*c );\n\tdouble e = c * r;\n\tdouble d = sqrt( ra*ra - e*e );\n\t\n\tP tmp;\n\ttmp.x = d * (a.y - b.y) / c;\n\ttmp.y = d * (b.x - a.x) / c;\n\n\tP cen = a * (1.0-r) + b * r;\n\t\n\t*p1 = cen + tmp;\n\t*p2 = cen - tmp;\n}\n\nint n;\n\nint solve(){\n\tP c[100], p[101][2];\n\tdouble r[100];\n\tdouble dist[205][205];\n\t\n\tcin >> c[0].x >> c[0].y >> r[0];\n\tp[0][0] = c[0];\n\tp[0][1] = c[0];\n\tfor(int i=1; i<n; i++){\n\t\tcin >> c[i].x >> c[i].y >> r[i];\n\t\tcirclecross( c[i-1], r[i-1], c[i], r[i], &p[i][0], &p[i][1]);\n\t}\n\tp[n][0] = c[n-1];\n\tp[n][1] = c[n-1];\n\n\t//求める\n\tfill( dist[0], dist[0]+205*205, INF );\n\tfor(int i=0; i<n*2; i++){\n\t\tfor(int j=i+1; j<=n*2; j++){\n\t\t\tbool f=true;\n\t\t\tfor(int k=i/2+1; k<j/2; k++){\n\t\t\t\tif( !check( p[i/2][i%2], p[j/2][j%2], p[k][0], p[k][1] ) )\n\t\t\t\t\tf = false;\n\t\t\t}\n\t\t\tif( f ){\n\t\t\t\tdouble x = p[i/2][i%2].x - p[j/2][j%2].x;\n\t\t\t\tdouble y = p[i/2][i%2].y - p[j/2][j%2].y;\n\t\t\t\tdist[i][j] = sqrt( x*x + y*y );\n\t\t\t}\n\t\t}\n\t}\n\t//最短経路\n\tfor(int k=1; k<n*2; k++){\n\t\tfor(int i=0; i<=n*2; i++){\n\t\t\tfor(int j=0; j<=n*2; j++){\n\t\t\t\tdist[i][j] = min( dist[i][j], dist[i][k] + dist[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%0.6f\\n\", dist[0][n*2] );\n\t\n\treturn 0;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\nusing namespace std;\nclass Vec2{\npublic:\n  double x,y;\n  Vec2(){\n    Vec2(0,0);\n  }\n  Vec2(double a,double b){\n    x=a,y=b;\n  }\n  Vec2 operator+(Vec2 a){\n    return Vec2(x-a.x,y-a.y);\n  }\n  Vec2 operator-(Vec2 a){\n    return Vec2(x-a.x,y-a.y);\n  }\n  double norm(void){\n    return sqrt(x*x+y*y);\n  }\n  double sqnorm(void){\n    return x*x+y*y;\n  }\n  Vec2 mul(double k){\n    return Vec2(k*x,k*y);\n  }\n};\n\ndouble cross(Vec2 a,Vec2 b)\n{\n  return a.x*b.y-a.y*b.x;\n}\npair<Vec2,Vec2> cci(pair<Vec2,double> a,pair<Vec2,double> b)\n{\n  double s=(a.second*a.second-b.second*b.second)/(a.first-b.first).sqnorm()/2+0.5;\n  Vec2 ac=(a.first-b.first).mul(s);\n  double k=sqrt(a.second*a.second-ac.sqnorm())/ac.norm();\n  return make_pair(a.first+ac+(Vec2(ac.y,-ac.x)).mul(k),a.first+ac+(Vec2(-ac.y,ac.x)).mul(k));\n}\n\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    vector<pair<Vec2,double> > c(n);\n    REP(i,n) cin >> c[i].first.x >> c[i].first.y >> c[i].second;\n    vector<vector<Vec2> > ip(n+1,vector<Vec2>(2));\n    ip[0].assign(2,c[0].first);\n    REP(i,n-1){\n      auto ipp=cci(c[i],c[i+1]);\n      ip[i+1][0]=ipp.first;\n      ip[i+1][1]=ipp.second;\n    }\n    ip[n].assign(2,c[n-1].first);\n    vector<vector<double> > cost(n+1,vector<double>(2,1e+9));\n    cost[0].assign(2,0.0);\n    REP(i,n+1) REP(j,i)\tREP(k,2) REP(l,2){\n      Vec2 a=ip[j][l],b=ip[i][k];\n      bool flag=true;\n      FOR(m,j+1,i)\n\tif(!(cross(b-a,ip[m][0]-a)*cross(b-a,ip[m][1]-a) < 0 &&\n\t     cross(ip[m][1]-ip[m][0],a-ip[m][0])*cross(ip[m][1]-ip[m][0],b-ip[m][0]))){\n\t  flag=false;\n\t  break;\n\t}\n      if(flag) cost[i][k]=min(cost[i][k],cost[j][l]+(b-a).norm());\n    }\n    cout << fixed << setprecision(10) << cost[n][0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef complex<double> P;\ntypedef vector<P> L;\nstruct C{\n    P p;\n    double r;\n};\nconst double INF = 1e10;\nconst double EPS = 1e-8;\nint sign(double x) {\n    if(x > EPS) return 1;\n    if(x < -EPS) return -1;\n    return 0;\n}\nvector<P> pCC(C a, C b) {\n    vector<P> res;\n\n    double d = abs(b.p - a.p);\n    double l1 = abs(a.r - b.r);\n    double l2 = a.r + b.r;\n    if(sign(d) == 0 && sign(l1) == 0) assert(false);\n    if(sign(d - l1) < 0 || sign(d - l2) > 0) return res;\n\n    double th1 = arg(b.p - a.p);\n\n    if(sign(d - l1) == 0 || sign(d - l2) == 0) {\n        res = {a.p + polar(a.r, th1)};\n    } else {\n        double th2 = acos( (a.r * a.r - b.r * b.r + d * d) / (2 * a.r * d) );\n        res.push_back( a.p + polar(a.r, th1 - th2) );\n        res.push_back( a.p + polar(a.r, th1 + th2) );\n    }\n    return res;\n}\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\nint ccw(P a, P b, P c) {\n    b -= a;\n    c -= a;\n    return sign(cross(b, c)) ? : dot(b, c) < 0 ? 2 : norm(b) < norm(c) ? -2 : 0;\n}\n\nbool iSS(L s, L t) {\n    auto ok = [](L a, L b) {\n        return ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0; \n    };\n    return ok(s, t) && ok(t, s);\n}\nint main() {\n    int n;\n    while(cin >> n && n) {\n        vector<C> cs(n);\n        REP(i, n) {\n            double x, y, r;\n            cin >> x >> y >> r;\n            cs[i] = {{x, y}, r};\n        }\n\n        P cp[111][2] = {};\n        cp[0][0] = cp[0][1] = cs[0].p;\n        for(int i = 0; i + 1 < n; i++) {\n            vector<P> v = pCC(cs[i], cs[i + 1]);\n            REP(j, 2) {\n                cp[i + 1][j] = v[j];\n            }\n        }\n        cp[n][0] = cp[n][1] = cs[n - 1].p;\n\n        double dp[111][2] = {};\n        REP(i, n + 1) REP(j, 2) dp[i][j] = INF;\n        dp[0][0] = dp[0][1] = 0;\n\n        REP(i, n) REP(j, 2) if(dp[i][j] < INF) {\n            P from = cp[i][j];\n            for(int i2 = i + 1; i2 <= n; i2++) REP(k, 2) {\n                P to = cp[i2][k];\n                L path = {from, to};\n                bool ok = true;\n                for(int i3 = i + 1; i3 < i2; i3++) {\n                    L hit = {cp[i3][0], cp[i3][1]};\n                    if(!iSS(path, hit)) {\n                        ok = false;\n                    }\n                }\n                if(ok) {\n                    dp[i2][k] = min(dp[i2][k], dp[i][j] + abs(from - to));\n                }\n            }\n        }\n        double ans = dp[n][0];\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <map>\n#include <queue>\n#include <assert.h>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n \nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(pair<P, P> pp) {\n    push_back(pp.first); push_back(pp.second);\n  }\n};\n \nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n \nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n \nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> circle_circle_intersect(C c1, C c2) {\n  if(c1.p.real() > c2.p.real()) swap(c1, c2);\n  const double d = abs(c2.p - c1.p);\n  const double alpha  = acos((c2.p.real() - c1.p.real()) / d) * ((c1.p.imag() > c2.p.imag()) ? -1.0 : 1.0);\n  const double beta   = acos((c1.r * c1.r - c2.r * c2.r + d * d) / 2.0 / d / c1.r);\n  return make_pair(c1.p + polar(c1.r, alpha - beta), c1.p + polar(c1.r, alpha + beta));\n}\n\nstruct Edge {\n  int to;\n  double cost;\n};\n \nvector<Edge> G[300];\n \nmap<P, int> mp;\nint nidx;\nvoid init_node_map(P ps, P pt, int N) {\n  mp.clear();\n  mp[ps] = 0;\n  mp[pt] = (N-1)*2+1;\n  nidx = 1;\n}\n \nint get_node(P p) {\n  if(mp.find(p) == mp.end()) {\n    mp[p] = nidx++;\n  }\n  return mp[p];\n}\n \n#define MAX (300)\ndouble dist[MAX];\n \ntypedef pair<double, int> Pdi;\n  \ndouble dijkstra(int S, int T) {\n   \n  priority_queue<Pdi, vector<Pdi>, greater<Pdi> > PQ;\n  fill(dist, dist+MAX, INF);\n  dist[S] = 0;\n  PQ.push(Pdi(0., S));\n    \n  while(!PQ.empty()) {\n    Pdi pdi = PQ.top(); PQ.pop();\n    const int u = pdi.second;\n    for(int i=0; i<(int)G[u].size(); i++) {\n      const Edge& e = G[u][i];\n      if(dist[e.to] > dist[u]+e.cost) {\n    dist[e.to] = dist[u]+e.cost;\n    PQ.push(Pdi(dist[e.to], e.to));\n      }\n    }\n  }\n    \n  return dist[T];\n}\n \n#define IINF2 (INT_MAX/2)\n \nint main() {\n   \n  int N;\n  while(cin >> N && N) {\n \n    for(int i=0; i<300; i++) G[i].clear();\n \n    vector<C> cs;\n    for(int i=0; i<N; i++) {\n      double x, y, r; cin >> x >> y >> r;\n      cs.push_back(C(P(x, y), r));\n    }\n     \n    vector<pair<P, P> > ips(N+1);\n    ips[0].first = cs[0].p; // ips[0].second = P(-IINF2, -IINF2);\n    for(int i=0; i<N-1; i++) {\n      ips[i+1] = circle_circle_intersect(cs[i], cs[i+1]);\n    }\n    ips[N].first = cs[N-1].p; // ips.back().second = P(+IINF2, +IINF2);\n     \n    init_node_map(ips[0].first, ips[N].first, N);\n     \n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N+1; j++) {\n     \n    const int dij = j-i;\n     \n    for(int k=0; k<2; k++) {\n       \n      if(i == 0 && k == 1) continue;\n       \n      const P pti = k == 0 ? ips[i].first : ips[i].second;\n      const int a = get_node(pti);\n       \n      for(int l=0; l<2; l++) {\n         \n        if(j == N && l == 1) continue;\n         \n        const P ptj = l == 0 ? ips[j].first : ips[j].second;\n        const int b = get_node(ptj);\n         \n        bool ok = true;\n        const L sa(pti, ptj);\n        // ?¶???????????????°?????????????£?\n        for(int didx=1; didx<dij; didx++) {\n          const L sb(ips[i+didx]);\n          ok = ok && intersectSS(sa, sb);\n        }\n \n         \n        if(ok) {\n          const double len = abs(pti-ptj);\n          G[a].push_back((Edge){b, len});\n          G[b].push_back((Edge){a, len});\n        }\n         \n         \n      }\n    }\n      }\n    }\n     \n    printf(\"%.6f\\n\", dijkstra(get_node(cs[0].p), get_node(cs[N-1].p)));\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> Complex;\ntypedef pair<Complex, Complex> pcc;\n\npcc circles_intersect_points(Complex c1, double r1, Complex c2, double r2) {\n  Complex u = c2 - c1;\n\n  double d = abs(u);\n  double d1 = (r1 * r1 - r2 * r2 + d * d) / (d * 2);\n  double l = sqrt(r1 * r1 - d1 * d1);\n\n  Complex v = Complex(u.imag(), -u.real()) / d;\n  Complex g = c1 + u * (d1 / d);\n\n  pcc ret;\n  ret.fi = g + v * l;\n  ret.se = g - v * l;\n  return ret;\n}\n\ndouble det(Complex a, Complex b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool line_segments_intersect(Complex a, Complex b, Complex c, Complex d) {\n  double ta = det(a - c, d - c);\n  double tb = det(b - c, d - c);\n  double tc = det(c - a, b - a);\n  double td = det(d - a, b - a);\n  return ta * tb < 0 && tc * td < 0;\n}\n\nbool ok(const vector<pcc> &lines, Complex v1, Complex v2, ll p, ll q) {\n  REP(i, p, q + 1) {\n    if(!line_segments_intersect(lines[i].fi, lines[i].se, v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(void) {\n  ll N;\n  while(cin >> N, N) {\n    vector<Complex> P(N);\n    vector<ll> R(N);\n    REP(i, 0, N) {\n      ll x, y;\n      cin >> x >> y >> R[i];\n      P[i] = Complex(x, y);\n    }\n\n    vector<pcc> lines(N - 1);\n    REP(i, 0, N - 1) {\n      lines[i] = circles_intersect_points(P[i], R[i], P[i + 1], R[i + 1]);\n    }\n\n    Complex S = P[0], G = P[N - 1];\n    vector<Complex> points(N * 2);\n    REP(i, 0, N - 1) {\n      points[i * 2] = lines[i].fi;\n      points[i * 2 + 1] = lines[i].se;\n    }\n    points[N * 2 - 2] = S;\n    points[N * 2 - 1] = G;\n\n#define add_edge(u, v) { \\\n  E[u].push_back(v); \\\n  E[v].push_back(u); \\\n}\n\n    vector<vector<ll>> E(N * 2);\n    if(ok(lines, S, G, 0, N - 2)) add_edge(N * 2 - 2, N * 2 - 1);\n    REP(i, 0, N - 1) {\n      if(ok(lines, S, lines[i].fi, 0, i - 1)) add_edge(N * 2 - 2, i * 2);\n      if(ok(lines, S, lines[i].se, 0, i - 1)) add_edge(N * 2 - 2, i * 2 + 1);\n      if(ok(lines, lines[i].fi, G, i + 1, N - 2)) add_edge(i * 2, N * 2 - 1);\n      if(ok(lines, lines[i].se, G, i + 1, N - 2)) add_edge(i * 2 + 1, N * 2 - 1);\n    }\n    REP(i, 0, N - 1) REP(j, i + 1, N - 1) {\n      if(ok(lines, lines[i].fi, lines[j].fi, i + 1, j - 1)) add_edge(i * 2, j * 2);\n      if(ok(lines, lines[i].fi, lines[j].se, i + 1, j - 1)) add_edge(i * 2, j * 2 + 1);\n      if(ok(lines, lines[i].se, lines[j].fi, i + 1, j - 1)) add_edge(i * 2 + 1, j * 2);\n      if(ok(lines, lines[i].se, lines[j].se, i + 1, j - 1)) add_edge(i * 2 + 1, j * 2 + 1);\n    }\n\n    struct state {\n      ll v;\n      double cost;\n      bool operator<(const state s) const { return cost > s.cost; }\n    };\n\n    vector<double> dp(N * 2, 1e20);\n    priority_queue<state> q;\n    q.push((state) { N * 2 - 2, 0 });\n\n    while(q.size()) {\n      ll v = q.top().v;\n      double cost = q.top().cost;\n      q.pop();\n      if(dp[v] <= cost) continue;\n      dp[v] = cost;\n      for(ll nv : E[v]) {\n        double ncost = cost + abs(points[v] - points[nv]);\n        if(dp[nv] > ncost) q.push((state) { nv, ncost });\n      }\n    }\n\n    printf(\"%.15lf\\n\", dp[N * 2 - 1]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n#define tmp template<class t>\n\ntmp void chmax(t&a,t b){if(a<b)a=b;}\ntmp void chmin(t&a,t b){if(a>b)a=b;}\n\ntmp using vc=vector<t>;\ntmp using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntmp ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\ntmp void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll read(){ll i;cin>>i;return i;}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-7;\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nauto cmcmp=[](const cm&a,const cm&b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\nld tri2(cm a,cm b,cm c){\n\treturn crs(b-a,c-a);\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n\nusing ln=pair<cm,cm>;\ncm dir(ln a){return a.b-a.a;}\ncm eval(ln a,ld b){return a.a+dir(a)*b;}\ncm proj(ln a,cm b){\n\tcm c=dir(a);\n\treturn a.a+c*dot(c,b-a.a)/norm(c);\n}\ncm refl(ln a,cm b){\n\treturn ld(2)*proj(a,b)-b;\n}\n//AOJ0153\nld dsp(ln a,cm b){\n\tcm c=proj(a,b);\n\tif(abs(bet(a.a,a.b,c))<=1)return abs(b-c);\n\treturn min(abs(b-a.a),abs(b-a.b));\n}\nint ccw(ln a,cm b){return ccw(a.a,a.b,b);}\n//AOJ1157\n//0-no,1-yes(endpoint),2-yes(innner)\nint iss(ln a,ln b){\n\tint c=ccw(a.a,a.b,b.a)*ccw(a.a,a.b,b.b);\n\tint d=ccw(b.a,b.b,a.a)*ccw(b.a,b.b,a.b);\n\tint e=max(c,d);\n\tif(e)return 1-e;\n\tint f=bet(a.a,a.b,b.a),g=bet(a.a,a.b,b.b);\n\tif(max(f,g)==-2||min(f,g)==2)return 0;\n\treturn 1;\n}\n//AOJ1157\nld dss(ln a,ln b){\n\tif(iss(a,b))return 0;\n\treturn min({dsp(a,b.a),dsp(a,b.b),dsp(b,a.a),dsp(b,a.b)});\n}\n\nusing cr=pair<cm,ld>;\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cr a,cm b){\n\treturn sgn(a.b-abs(b-a.a))+1;\n}\n//AOJ0153\n//0-no,1-touch,2-cross\nint ids(cr a,ln b){\n\treturn sgn(a.b-dsp(b,a.a))+1;\n}\n//AOJ0129 (touch以外)\n//0-no(in),1-touch(in),2-cross,3-touch(out),4-no(out)\nint ics(cr a,ln b){\n\tint c=ids(a,b);\n\tif(c<=1)return 4-c;\n\treturn sgn(max(abs(b.a-a.a),abs(b.b-a.a))-a.b)+1;\n}\nint ccl(cr a,ln b,ld&c,ld&d){\n\tcm e=dir(b);\n\tcm f=b.a-a.a;\n\treturn qeq(norm(e),2*dot(e,f),norm(f)-a.b*a.b,c,d);\n}\n\n//AOJ0023\n//0-apart,1-coinside,2-a<b,3-a<=b,4-a>b,5-a>=b,6-a touch b,7-a cross b\nint icc(cr a,cr b){\n\tld c=abs(a.a-b.a);\n\tif(sgn(c)==0&&sgn(a.b-b.b)==0)return 1;\n\tint d=sgn(c+a.b-b.b);\n\tif(d<=0)return d+3;\n\tint e=sgn(c+b.b-a.b);\n\tif(e<=0)return e+5;\n\tint f=sgn(a.b+b.b-c);\n\tif(f>=0)return f+6;\n\treturn 0;\n}\n\n//two intersections l,r seen be a.a\n//assume two circles cross\nln ccc(cr a,cr b){\n\tld c=arg(b.a-a.a);\n\tld d=arg(a.b,abs(b.a-a.a),b.b);\n\treturn ln(a.a+polar(a.b,c+d),a.a+polar(a.b,c-d));\n}\n\n//not verified\nbool ips(const vc<cm>&a,ln b){\n\tint n=a.size();\n\trep(i,n){\n\t\tcm c=a[(i+n-1)%n],d=a[i],e=a[(i+1)%n];\n\t\tif(iss(ln(c,d),b)==2)return 1;\n\t\tif(ccw(b,d)==0&&bet(b.a,b.b,d)==0){\n\t\t\tif(ccw(c,d,e)==1)return 1;\n\t\t\tif(ccw(b,c)*ccw(b,e)<0)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n//GCJ2019R3D\n//0-out,1-edge,2-in\nint cont(const vc<cm>&a,cm b){\n\tint n=a.size();\n\tint res=0;\n\trep(i,n){\n\t\tcm c=a[i],d=a[(i+1)%n];\n\t\tif(ccw(c,d,b)==0&&abs(bet(c,d,b))<=1)\n\t\t\treturn 1;\n\t\tif(c.y>d.y)swap(c,d);\n\t\tif(sgn(b.y-c.y)>0&&sgn(d.y-b.y)>=0&&ccw(c,d,b)==1)\n\t\t\tres^=1;\n\t}\n\treturn res*2;\n}\n\nld area2(const vc<cm>&a){\n\tint n=a.size();\n\tld b=0;\n\trep(i,n)\n\t\tb+=crs(a[i],a[(i+1)%n]);\n\treturn b;\n}\n\n//AOJ0068\n//no point in edges\nvc<cm> convex(vc<cm> s){\n\tswap(s[0],*min_element(all(s),cmcmp));\n\tsort(s.bg+1,s.ed,[&](cm a,cm b){\n\t\tint c=ccw(s[0],a,b);\n\t\tif(c)return c==1;\n\t\telse return bet(s[0],a,b)==2;\n\t});\n\tvc<cm> t;\n\trep(i,s.size()){\n\t\tint ss;\n\t\twhile((ss=t.size())>=2){\n\t\t\tcm a=t[ss-2];\n\t\t\tcm b=t[ss-1];\n\t\t\tcm c=s[i];\n\t\t\tif(ccw(a,b,c)>0)\n\t\t\t\tbreak;\n\t\t\tt.pop_back();\n\t\t}\n\t\tt.pb(s[i]);\n\t}\n\treturn t;\n}\n\n\ncm readcm(){\n\tld a,b;\n\tcin>>a>>b;\n\treturn cm(a,b);\n}\n\nld readld(){\n\tld a;\n\tcin>>a;\n\treturn a;\n}\n\ntemplate<class E,class D=ll>\nvc<D> dijkstra(const vvc<E>& g,int s){\n\tconst int n=g.size();\n\tusing P=pair<D,int>;\n\tpriority_queue<P,vc<P>,greater<P>> pq;\n\tvc<D> dist(n,1e9);\n\tconst auto ar=[&](int v,D d){\n\t\tif(dist[v]>d){\n\t\t\tdist[v]=d;\n\t\t\tpq.push(P(d,v));\n\t\t}\n\t};\n\tar(s,0);\n\twhile(pq.size()){\n\t\tD d;\n\t\tint v;\n\t\ttie(d,v)=pq.top();pq.pop();\n\t\tfor(auto e:g[v])\n\t\t\tar(e.to,d+e.cost);\n\t}\n\treturn dist;\n}\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\twhile(1){\n\t\tint n=read();\n\t\tif(n==0)break;\n\t\tvc<cr> s(n);\n\t\trep(i,n){\n\t\t\tint a=read(),b=read(),r=read();\n\t\t\ts[i]=cr(cm(a,b),r);\n\t\t}\n\t\tvc<cm> a;\n\t\tint to;\n\t\t{\n\t\t\ta.eb(s[0].a);\n\t\t\trep(i,n-1){\n\t\t\t\tln b=ccc(s[i],s[i+1]);\n\t\t\t\t//a.eb(b.a,i);\n\t\t\t\ta.eb(b.b);\n\t\t\t}\n\t\t\tto=a.size();\n\t\t\ta.eb(s[n-1].a);\n\t\t\tper(i,n-1){\n\t\t\t\tln b=ccc(s[i],s[i+1]);\n\t\t\t\ta.eb(b.a);\n\t\t\t\t//a.eb(b.b,i);\n\t\t\t}\n\t\t}\n\t\tint m=a.size();\n\t\tstruct E{int to;ld cost;};\n\t\tvvc<E> g(m);\n\t\trep(i,m)rep(j,m){\n\t\t\tln c(a[i],a[j]);\n\t\t\tif(!ips(a,c)&&cont(a,eval(c,0.5))){\n\t\t\t\tg[i].pb(E{j,abs(a[i]-a[j])});\n\t\t\t}\n\t\t}\n\t\tcout<<dijkstra<E,ld>(g,0)[to]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,int>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n         \n         Point cen[110];\n         double r[110];\n            Point p[300]; \n            Segment sen[110];\n            vector<pal> G[400];\n            double memo[400];\n            int er[400];\n    int n;        \ndouble saiki(int r){\n\tif(r==2*n){\n\t\ter[r]=-1;\n\t\treturn 0;\n\t}\n\tif(memo[r]>=-1) return memo[r];\n\tdouble l=1000000000.0;\n\t\t\n\tfor(auto v:G[r]){\n\t\tdouble g=v.first+saiki(v.second);\n\t\tif(l>g){\n\t\t\ter[r]=v.second;\n\t\t\tl=g;\n\t\t}\n\t\t//l=min(l,v.first+saiki(v.second));\n\t\t\n\t}\n\tmemo[r]=l;\n\treturn l;\n}\n            \n         signed main(){\n\t\n\t\n         \twhile(1){\n         \tcin>>n;\n         \t\tif(n==0) return 0;\n         \t\t\n         \t\tfor(int i=0;i<400;i++){\n         \t\t\tG[i].clear();\n         \t\t\tmemo[i]=-1000000;\n         \t\t}\n         \t\t\n         \t\tfor(int i=0;i<n;i++){\n         \t\t\tcin>>cen[i].x>>cen[i].y;\n         \t\t\tcin>>r[i];\n         \t\t}\n         \t\n         \t\tp[1]=cen[0];\n         \t\tp[2*n]=cen[n-1];\n         \t\t\n         \t\tfor(int i=1;i<n;i++){\n         \t\t\tpair<Point,Point> z=circle_intersection(cen[i-1],r[i-1],cen[i],r[i]);\n         \t\t\tp[2*i]=z.first;\n         \t\t\tp[2*i+1]=z.second;\n         \t\t//\tcout<<p[2*i].x<<\" \"<<p[2*i].y<<\" \"<<p[2*i+1].x<<\" \"<<p[2*i+1].y<<\" \"<<endl;\n         \t\t\tsen[i]={z.first,z.second};\n         \t\t}\n         \t\t\n         \t\tSegment seg;\n         \t\tseg={cen[0],cen[n-1]};\n         \t\tbool bol=1;\n         \t\tfor(int i=1;i<n;i++)if(!is_intersected_ls(seg,sen[i]))bol=0;\n         \t\tif(bol) G[1].pb(mp((cen[0]-cen[n-1]).absv(),2*n));\n         \t\t\n         \t\tfor(int i=1;i<=n;i++){\n         \t\t\t\n         \t\t\tbol =1;\n         \t\t\tseg={p[1],p[2*i]};\n         \t\t\tfor(int j=1;j<i;j++) if(!is_intersected_ls(seg,sen[j]))bol=0;\n         \t\t\t\n         \t\t\tif(bol) G[1].pb(mp(segment_len(seg),2*i));\n         \t\t\t\n         \t\t\tbol=1;\n         \t\t\tseg={p[1],p[2*i+1]};\n         \t\t\tfor(int j=1;j<i;j++) if(!is_intersected_ls(seg,sen[j]))bol=0;\n         \t\t\tif(bol) G[1].pb(mp(segment_len(seg),2*i+1));\n         \t\t\t\n         \t\t\tbol =1;\n         \t\t\tseg={p[2*n],p[2*i]};\n         \t\t\tfor(int j=i+1;j<n;j++) if(!is_intersected_ls(seg,sen[j]))bol=0;\n         \t\t\tif(bol) G[2*i].pb(mp(segment_len(seg),2*n));\n         \t\t\tbol=1;\n         \t\t\tseg={p[2*n],p[2*i+1]};\n         \t\t\tfor(int j=i+1;j<n;j++) if(!is_intersected_ls(seg,sen[j]))bol=0;\n         \t\t\tif(bol) G[2*i+1].pb(mp(segment_len(seg),2*n));\n         \t\t}\n         \t\t\n         \t\tfor(int i=2;i<2*n;i++)for(int j=i+1;j<2*n;j++)if(i/2 != j/2){\n         \t\t\tbol =1;\n         \t\t\tseg={p[i],p[j]};\n         \t\t\t \n         \t\t\tfor(int k=i/2+1;k<j/2;k++)if(!is_intersected_ls(seg,sen[k]))bol=0;\n         \t\t\tif(bol) G[i].pb(mp(segment_len(seg),j));\n         \t\t\t\n         \t\t}\n         \t//\tfor(int i=1;i<2*n;i++)for(auto v:G[i])cout<<i<<\" \"<<v.second<<\" \"<<v.first<<endl; \n         \t\tprintf(\"%.10lf\\n\",saiki(1));\n         \t\t\n         \t\n         \t}\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nstruct coordinate {\n\tdouble x, y;\n\tcoordinate() {}\n\tcoordinate(double a, double b) {\n\t\tx = a; y = b;\n\t}\n\tbool operator<(const coordinate & a) const{\n\t\treturn (sqr(x) + sqr(y)) < (a.sqr(x) + sqr(y));\n\t}\n};\n\nstruct circle {\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coordinate a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coordinate,coordinate> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coordinate,coordinate> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coordinate(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coordinate(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\treturn ret;\n}\n\nbool cross_lseg(coordinate a_start, coordinate a_end, coordinate b_start, coordinate b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\ndouble distance(coordinate a, coordinate b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coordinate,coordinate> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coordinate(v[0].x, v[0].y), coordinate(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coordinate,coordinate> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(make_pair(coordinate(v[v.size() - 1].x, v[v.size() - 1].y), coordinate(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoordinate start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoordinate end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\nstatic const double pi = 3.141592653589793;\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-10;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\n\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\n////=============================\n\nint N;\nint main() {\n\twhile(cin >> N, N) {\n\t\tvector<pair<P, D>> circls;\n\t\tvector<VP> points;\n\t\tP ps;\n\t\tD dp[110][2];\n\t\trep(i, 101) {\n\t\t\tdp[i][0] = 1e20;\n\t\t\tdp[i][1] = 1e20;\n\t\t}\n\t\tD x,y,rn;\n\t\tD  ans;\n\t\trep(n, N) {\n\t\t\tcin >> x >> y >> rn;\n\t\t\tP pn = P(x, y);\n\t\t\tcircls.push_back(make_pair(pn, rn));\n\t\t\tif (n == 0) {\n\t\t\t\tpoints.push_back({pn, pn});\n\t\t\t\tdp[0][0] = 0;\n\t\t\t} else {\n\t\t\t\tP p1 = get<0>(circls[n - 1]);\n\t\t\t\tD r1 = get<1>(circls[n - 1]);\n\t\t\t\tVP vp1 = crosspointCC(pn,rn,p1,r1);\n\t\t\t\tpoints.push_back(vp1);\n\t\t\t\trep(i,n) {\n\t\t\t\t\trep(k, 2){\n\t\t\t\t\t\trep(k2, 2) {\n\t\t\t\t\t\t\tP pr = vp1[k];\n\t\t\t\t\t\t\tP pl = points[i][k2];\n\t\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\t\t\tP pm1 = points[j][0];\n\t\t\t\t\t\t\t\tP pm2 = points[j][1];\n\t\t\t\t\t\t\t\tf = f & isecSS(pm1, pm2,pr, pl);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(f) dp[n][k] = min(dp[n][k] , dp[i][k2] + abs(pr - pl));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 1e22;\n\t\t\tif (n == N - 1) {\n\t\t\t\trep(i, N) {\n\t\t\t\t\trep(k2, 2) {\n\t\t\t\t\t\tP pr = pn;\n\t\t\t\t\t\tP pl = points[i][k2];\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\t\t\tP pm1 = points[j][0];\n\t\t\t\t\t\t\tP pm2 = points[j][1];\n\t\t\t\t\t\t\tf = f & isecSS(pm1, pm2,pr, pl);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f)continue;\n\t\t\t\t\t\tans = min(ans, dp[i][k2] + abs(pr - pl));\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << setprecision(20) << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-8;\nstruct S{\n  P s,t;\n  S(P s=P(),P t=P()): s(s),t(t) {}\n};\nstruct C{\n  P p;\n  double r;\n  C(P p=P(),double r=0):p(p),r(r){}\n};\n\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\ndouble Sqrt(double a){\n  if(a<0)return 0;\n  return sqrt(a);\n}\n\nint ccw(P a,P b,P c){\n  b-=a;c-=a;a=c*conj(b);\n  if(a.imag()>eps)return 1;\n  if(a.imag()<-eps)return -1;\n  if(a.real()<-eps)return 2;\n  if(abs(b)+eps<abs(c))return -2;\n  return 0;\n}\n\nbool isIntersect(S a,S b){\n  return (ccw(a.s,a.t,b.s)*ccw(a.s,a.t,b.t)<=0 &&\n          ccw(b.s,b.t,a.s)*ccw(b.s,b.t,a.t)<=0);\n}\n\nS crossPoint(C a,C b){\n  P base=b.p-a.p;\n  double k=(-b.r*b.r+a.r*a.r+norm(base));\n  double w=k/(2.0*abs(base)),h=Sqrt(a.r*a.r-w*w);\n  base/=abs(base);\n  return S(a.p+base*P(w,h),a.p+base*P(w,-h));\n}\n/*\nP getCrossPointCC(P p1,double r1,P p2,double r2){\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,sqrt(1.0-cA*cA));\n}\n*/\ndouble abs(S s){\n  return abs(s.s-s.t);\n}\n\nint n;\nvector<C> t;\nvector<S> u;\n\nbool check(int l,int r,S s){\n  for(int i=l;i<=r;i++){\n    if(isIntersect(u[i],s))continue;\n    return false;\n  }\n  return true;\n}\n\ndouble solve(){\n  vector<double> A(n+1,1e9),B(n+1,1e9);\n  u[0].s=u[0].t=t[0].p;\n  u[n].s=u[n].t=t[n-1].p;\n  A[0]=B[0]=0;\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<i;j++){\n      S target;\n      \n      target=S(u[j].s,u[i].s);\n      if(check(j+1,i,target))A[i]=min(A[i],A[j]+abs(target));\n\n      target=S(u[j].t,u[i].s);\n      if(check(j+1,i,target))\n        A[i]=min(A[i],B[j]+abs(target));\n\n      target=S(u[j].s,u[i].t);\n      if(check(j+1,i,target))\n        B[i]=min(B[i],A[j]+abs(target));\n\n      target=S(u[j].t,u[i].t);\n      if(check(j+1,i,target))\n        B[i]=min(B[i],B[j]+abs(target));\n    }\n    // printf(\"%d %.8f\\n\",i,min(A[i],B[i]));\n  }\n  return min(A[n],B[n]);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    t.clear();\n    t.resize(n+1);\n    u.clear();\n    u.resize(n+1);\n    for(int i=0;i<n;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      t[i]=C(P(x,y),r);\n      if(i){\n        u[i]=crossPoint(t[i],t[i-1]);\n        //        u[i].s=getCrossPointCC(t[i].p,t[i].r,t[i-1].p,t[i-1].r);\n        //        u[i].t=getCrossPointCC(t[i-1].p,t[i-1].r,t[i].p,t[i].r);\n      }\n    }\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nconst int N = 210;\nconst double eps = 1e-8;\n\ntypedef complex<double> point;\n\nint n;\ndouble x[N], y[N], r[N], d[N][N];\npoint c[N], p[N];\n\nvoid generate()\n{\n    rep(i, n) c[i] = point(x[i], y[i]);\n\n    p[0] = c[0];\n    rep(i, n - 1) {\n        double d = abs(c[i + 1] - c[i]);\n        double th = arg(c[i + 1] - c[i]);\n        double dth = acos((r[i] * r[i] + d * d - r[i + 1] * r[i + 1]) / (2 * r[i] * d));\n        p[2 * i + 1] = c[i] + polar(r[i], th - dth);\n        p[2 * i + 2] = c[i] + polar(r[i], th + dth);\n    }\n    p[2 * n - 1] = c[n - 1];\n}\n\ndouble cross(point a, point b) { return imag(conj(a) * b); }\n\nbool reachable(int i, int j)\n{\n    repi(k, i + 1, j) {\n        if (k % 2 == 1 and cross(p[j] - p[i], p[k] - p[i]) > eps) return false;            \n        if (k % 2 == 0 and cross(p[j] - p[i], p[k] - p[i]) < eps) return false;\n    }\n    return true;\n}\n\nvoid prepare()\n{\n    rep(i, 2 * n) rep(j, 2 * n) {\n        d[i][j] = 1e9;\n    }\n    rep(i, 2 * n) d[i][i] = 0.0;\n    rep(i, 2 * n) repi(j, i + 1, 2 * n) {\n        if (reachable(i, j)) {\n            d[i][j] = abs(p[j] - p[i]);\n        }\n    }\n}\n\nvoid solve()\n{\n    generate();\n    prepare();\n\n    rep(k, 2 * n) rep(i, 2 * n) rep(j, 2 * n) {\n        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    }\n    printf(\"%.6f\\n\", d[0][2 * n - 1]);\n}\n\nint main()\n{\n    while (cin >> n and n) {\n        rep(i, n) cin >> x[i] >> y[i] >> r[i];\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ndouble eps=1e-8;\nstruct S{\n  P s,t;\n  S(P s=P(),P t=P()): s(s),t(t) {}\n};\nstruct C{\n  P p;\n  double r;\n  C(P p=P(),double r=0):p(p),r(r){}\n};\n\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\ndouble Sqrt(double a){\n  if(a<0)return 0;\n  return sqrt(a);\n}\n\nint ccw(P a,P b,P c){\n  b-=a;c-=a;a=c*conj(b);\n  if(a.imag()>eps)return 1;\n  if(a.imag()<-eps)return -1;\n  if(a.real()<-eps)return 2;\n  if(abs(b)+eps<abs(c))return -2;\n  return 0;\n}\n\nbool isIntersect(S a,S b){\n  return (ccw(a.s,a.t,b.s)*ccw(a.s,a.t,b.t)<=0 &&\n          ccw(b.s,b.t,a.s)*ccw(b.s,b.t,a.t)<=0);\n}\n/*\nS crossPoint(C a,C b){\n  P base=b.p-a.p;\n  double k=(-b.r*b.r+a.r*a.r+norm(base));\n  double w=k/(4.0*abs(base)),h=Sqrt(a.r*a.r-w*w);\n  base/=abs(base);\n  return S(a.p+base*P(w,h),a.p+base*P(w,-h));\n}\n*/\nP getCrossPointCC(P p1,double r1,P p2,double r2){\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,sqrt(1.0-cA*cA));\n}\n\ndouble abs(S s){\n  return abs(s.s-s.t);\n}\n\nint n;\nvector<C> t;\nvector<S> u;\n\nbool check(int l,int r,S s){\n  for(int i=l;i<=r;i++){\n    if(isIntersect(u[i],s))continue;\n    return false;\n  }\n  return true;\n}\n\ndouble solve(){\n  vector<double> A(n+1,1e9),B(n+1,1e9);\n  u[0].s=u[0].t=t[0].p;\n  u[n].s=u[n].t=t[n-1].p;\n  A[0]=B[0]=0;\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<i;j++){\n      S target;\n      \n      target=S(u[j].s,u[i].s);\n      if(check(j+1,i,target))A[i]=min(A[i],A[j]+abs(target));\n\n      target=S(u[j].t,u[i].s);\n      if(check(j+1,i,target))\n        A[i]=min(A[i],B[j]+abs(target));\n\n      target=S(u[j].s,u[i].t);\n      if(check(j+1,i,target))\n        B[i]=min(B[i],A[j]+abs(target));\n\n      target=S(u[j].t,u[i].t);\n      if(check(j+1,i,target))\n        B[i]=min(B[i],B[j]+abs(target));\n    }\n    // printf(\"%d %.8f\\n\",i,min(A[i],B[i]));\n  }\n  return min(A[n],B[n]);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    t.clear();\n    t.resize(n+1);\n    u.clear();\n    u.resize(n+1);\n    for(int i=0;i<n;i++){\n      double x,y,r;\n      cin>>x>>y>>r;\n      t[i]=C(P(x,y),r);\n      if(i){\n        u[i].s=getCrossPointCC(t[i].p,t[i].r,t[i-1].p,t[i-1].r);\n        u[i].t=getCrossPointCC(t[i-1].p,t[i-1].r,t[i].p,t[i].r);\n      }\n    }\n    printf(\"%.8f\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef complex<double> pt;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\nint n;\npt za[105];\ndouble r[105];\nvector<pt> CCintersect (pair<pt,double> c, pair<pt,double> d) {\n    vector<pt> ret;\n    double dist = abs(c.first - d.first);\n    double cr = c.second;\n    double dr = d.second;\n     \n    if (dist > cr + dr) return ret;\n    if (dist < abs(cr - dr)) return ret;\n     \n    double s = (cr + dr + dist) / 2.;\n    double area = sqrt(s * (s - cr) * (s - dr) * (s - dist));\n    double h = 2 * area / dist;\n     \n    pt v = d.first - c.first; v /= abs(v);\n    pt m = c.first + sqrt(cr * cr - h * h) * v;\n    pt n = v * pt(0, 1);\n     \n    ret.push_back(m + n * h);\n    ret.push_back(m - n * h);\n    return ret;\n}\nbool eq(double a,double b){\n  return (-EPS < a-b && b-a < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\ndouble dist_lp(pt a,pt b,pt c){\n\t//senbun a-b to c no dist\n\tif(dot(a-b,c-b) <= 0.0) return abs(c-b);\n\tif(dot(b-a,c-a) <= 0.0) return abs(c-a);\n\treturn abs(cross(b-a,c-a)) / abs(b-a);\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\n\nbool intersect(pt a,pt b,pt c,pt d){\n\treturn (ccw(a,b,c)*ccw(a,b,d) <= 0 && ccw(c,d,a)*ccw(c,d,b) <= 0);\n}\nint main(){\n\twhile(1){\n\t\tcin >> n; if(!n) return 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lf%lf%lf\",&za[i].x,&za[i].y,&r[i]);\n\t\t}\n\t\tvector<pt>v; v.pb(za[1]);\n\t\tfor(int i=1;i<n;i++){\n\t\t\tvector<pt>R = CCintersect(mp(za[i],r[i]),mp(za[i+1],r[i+1]));\n\t\t\tv.pb(R[0]); v.pb(R[1]);\n\t\t}\n\t\tv.pb(za[n]);\n\t\tbool ok[205][205]={};\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\t\tint I,J;\n\t\t\t\tif(i==0) I = 1;\n\t\t\t\telse I = (i+1)/2+1;\n\t\t\t\tif(j==v.size()-1) J = n-1;\n\t\t\t\telse J = (j-1)/2;\n\t\t\t\tif(I>J) ok[i][j] = true;\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=I;k<=J;k++){\n\t\t\t\t\t\tvector<pt>R = CCintersect(mp(za[k],r[k]),mp(za[k+1],r[k+1]));\n\t\t\t\t\t\tif(!intersect(R[0],R[1],v[i],v[j])) goto bad;\n\t\t\t\t\t}\n\t\t\t\t\tok[i][j] = true; bad:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble dist[205];\n\t\tfor(int i=0;i<205;i++){\n\t\t\tdist[i] = 1e9;\n\t\t}\n\t\tdist[0] = 0.0;\n\t\tpriority_queue<pair<double,int>,vector<pair<double,int> >,greater<pair<double,int> > >que;\n\t\tque.push(mp(0.0,0));\n\t\twhile(!que.empty()){\n\t\t\tpair<double,int> di = que.top(); que.pop();\n\t\t\tif(!eq(dist[di.sc],di.fi)) continue;\n\t\t\tfor(int i=0;i<v.size();i++){\n\t\t\t\tif(!ok[di.sc][i]) continue;\n\t\t\t\tif(dist[di.sc]+abs(v[i]-v[di.sc])+EPS < dist[i]){\n\t\t\t\t\tdist[i] = dist[di.sc]+abs(v[i]-v[di.sc]);\n\t\t\t\t\tque.push(mp(dist[i],i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6f\\n\",dist[v.size()-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\n\ntypedef complex < double > P;\ntypedef line               L;\ntypedef vector< L >        LLL;\ntypedef vector< P >        Ps;\ntypedef circle             C;\nconst double EPS = 1e-9;\nconst double INF = 1e8;\n\ndouble cross( P a, P b){\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){\n  return real( conj(a) * b);\n}\nint ccw( P a, P b, P c){\n  b -= a, c -= a;\n  if(cross(b,c) > EPS)    return 1;  // a → b で 時計方向におれて c\n  if(cross(b,c) < -EPS)    return -1; // a → b で 反時計方向におれて c\n  if(dot(b,c) < -EPS)      return 2;  // c -- a -- b\n  if(norm(b) < norm(c) - EPS) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nPs crosspoint(C c1, C c2){\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  Ps ret;\n  ret.push_back( c1.p + m * v + h * v * P(0,1));\n  ret.push_back( c1.p + m * v - h * v * P(0,1));\n  return ret;\n}\nstruct dC{\n  double cost;\n  P pos;\n  int nowi,nowj;\n  bool operator < (const dC &left) const {\n    return cost > left.cost;\n  }\n};\nL make_2_cross(C c1, C c2){\n  Ps a(crosspoint( c1, c2));\n  return L( a[0], a[1]);\n}\n\nint main(){\n  C prev, now;\n  int n;\n\n  while(cin >> n , n){\n    LLL ls;\n\n    cin >> prev.p.real() >> prev.p.imag() >> prev.r;\n    ls.push_back( L( prev.p, prev.p));\n\n    for(int i = 1 ; i < n ; i++ ){\n      cin >> now.p.real() >> now.p.imag() >> now.r;\n      ls.push_back( make_2_cross( prev, now));\n      prev = now;\n    }\n    ls.push_back( L( prev.p, prev.p)); // G\n\n    priority_queue< dC > que;\n    que.push((dC){ 0, ls[0][0], 0, 0});\n    bool used[101][2] = {{}};\n    double ret = INF;\n    while(!que.empty()){\n      dC p = que.top();\n      que.pop();\n      if(p.nowj == n){\n        ret = p.cost;\n        break;\n      }\n      if(used[p.nowj][p.nowi]++) continue;\n      for(int i = 0 ; i < 2 ; i++ ){\n        for(int j = p.nowj + 1 ; j <= n ; j++ ){\n          L l = L( p.pos, ls[j][i]);\n          bool flag = true;\n          for(int k = j - 1 ; k > p.nowj ; k-- ){\n            if(!intersect( l, ls[k])){\n              flag = false;\n              break;\n            }\n          }\n          if(flag) que.push( (dC){ abs( l[0] - l[1]) + p.cost, l[1], i, j});\n        }\n      }\n    }\n    cout << fixed << setprecision(7) << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return norm(outp(dir(), p - at(0))) / norm(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return norm(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return norm(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tconst int p = ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1);\n\t\t\tconst int q = ccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1);\n\t\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tint d = less(s.distance(c), c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.push_back(S(c, c));\n\t\t\telse{\n\t\t\t\ts.push_back(cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.push_back(S(prev, prev));\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.4f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <queue>\n#include <math.h>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0  &&  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)), min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n\n\n/* 円 */\n\nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n\nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n\nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n\n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n\n// 2円の交点\nvoid crosspointCC(P a, D ar, P b, D br, VP& ps) {\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < crL) return;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n}\n\ntypedef vector<D> VD;\ntypedef vector<VD> VVD;\nconst D INF = 1e9;\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    VP cs(n);\n    VI rs(n);\n    rep(i,n) {\n      int x, y;\n      cin >> x >> y >> rs[i];\n      cs[i] = P(x, y);\n    }\n    int m = 2*n;\n    VVD graph(m, VD(m, INF));  // 0: src, 2i+1, 2i+2: i番目とi+1番目の円の交点, 2n-1:sink\n\n    VP ps;\n    ps.push_back(cs[0]);\n    rep (i, n-1) {\n      crosspointCC(cs[i], rs[i], cs[i+1], rs[i+1], ps);\n    }\n    ps.push_back(cs[n-1]);\n\n    rep(i,m) for (int j = i+1; j < m; j++) {\n      P a = ps[i];\n      P b = ps[j];\n      bool ok = true;\n      for (int k = i+1; k < j && ok; k++) {\n      \tif (ccw(a,b, ps[k]) != (k % 2 == 0 ? -1 : 1)) ok = false;\n      }\n      if (ok) graph[i][j] = abs(a - b);\n    }\n\n    VD dist(m, INF);\n    dist[0] = 0;\n    rep (i,m) for (int j = i+1; j < m; j++) {\n      dist[j] = min(dist[j], dist[i] + graph[i][j]);\n    }\n    // rep(i,m) {\n    //   rep(j,m) cout << graph[i][j] << \" \";\n    //   cout << endl;\n    // }\n    printf(\"%.6lf\\n\", dist[m-1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 解答時間→ 101:22(途中) */\n#include <math.h>\n#include <iomanip>\n#include <iostream>\t\t//基本入出力\nusing namespace std;\n\ndouble dist2d(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main(){\n\tdouble dist[50][50];\n\tcout << setprecision(16);\n\twhile(1){\n\t\t//入力\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tdouble x[25],y[25],r[25];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\t\tint V = n * 2;\n\t\tdouble pos_x[50], pos_y[50];\n\t\tpos_x[0] = x[0];\n\t\tpos_y[0] = y[0];\n\t\tpos_x[V - 1] = x[n - 1];\n\t\tpos_y[V - 1] = y[n - 1];\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tdouble d = sqrt(1.0 * (x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1]));\n\t\t\tdouble a = (d * d + r[i] * r[i] - r[i + 1] * r[i + 1]) / (d * 2);\n\t\t\tdouble b = sqrt(-a * a + r[i] * r[i]);\n\t\t\tdouble va_x = a * (x[i + 1] - x[i]) / d, va_y = a * (y[i + 1] - y[i]) / d;\n\t\t\tdouble vb_x = b * (y[i] - y[i + 1]) / d, vb_y = b * (x[i + 1] - x[i]) / d;\n\t\t\tpos_x[i * 2 + 1] = va_x + vb_x + x[i];\n\t\t\tpos_y[i * 2 + 1] = va_y + vb_y + y[i];\n\t\t\tpos_x[i * 2 + 2] = va_x - vb_x + x[i];\n\t\t\tpos_y[i * 2 + 2] = va_y - vb_y + y[i];\n\t\t}\n\t\t//総当りで距離を計算\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tdist[i][j] = DBL_MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < V - 1; i++){\n\t\t\tfor(int j = i + 1; j < V; j++){\n\t\t\t\t//交差判定(準備)\n\t\t\t\tint flg = 1;\n\t\t\t\tdouble x1, y1, x2, y2, x3, y3, x4, y4;\n\t\t\t\tx1 = pos_x[i];\n\t\t\t\ty1 = pos_y[i];\n\t\t\t\tx2 = pos_x[j];\n\t\t\t\ty2 = pos_y[j];\n\t\t\t\tint pos_ls, pos_lg;\n\t\t\t\tif(i == 0)\n\t\t\t\t\tpos_ls = 1;\n\t\t\t\telse\n\t\t\t\t\tpos_ls = (i + 1) / 2 + 1;\n\t\t\t\tif(j == V - 1)\n\t\t\t\t\tpos_lg = n - 1;\n\t\t\t\telse\n\t\t\t\t\tpos_lg = (j + 1) / 2 - 1;\n\t\t\t\t//交差判定(本番)\n\t\t\t\tdouble ta, tb, tc, td;\n\t\t\t\tfor(int k = pos_ls; k <= pos_lg; k++){\n\t\t\t\t\tx3 = pos_x[k * 2 - 1];\n\t\t\t\t\ty3 = pos_y[k * 2 - 1];\n\t\t\t\t\tx4 = pos_x[k * 2];\n\t\t\t\t\ty4 = pos_y[k * 2];\n\t\t\t\t\tta = (x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\t\t\t\ttb = (x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\t\t\t\ttc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\t\t\t\ttd = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\t\t\t\tif((tc*td>=0.0)||(ta*tb>=0.0)){\n\t\t\t\t\t\tflg=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg == 1){\n\t\t\t\t\tdist[i][j] = dist2d(pos_x[i], pos_y[i], pos_x[j], pos_y[j]);\n\t\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ワーシャル・フロイド法\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\tif(dist[i][j] > dist[i][k] + dist[k][j])\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//出力\n\t\tcout << dist[0][V - 1] << \"\\n\";\n\t}\n\tcout << flush;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\nstruct Line{\n  P a,b;\n  Line(P aa,P bb){a=aa,b=bb;};\n};\nconst double eps=1e-9;\n\ndouble dot (P a, P b) { return real(conj(a) * b); }\ndouble cross (P a, P b) { return imag(conj(a) * b); }\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n  vector<double> x(n),y(n),r(n);\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>r[i];\n  const double INF=1e18;\n  vector<double> dp1(n+1,INF); //between dp[0]=chuusin dp[i]=i,i-1 dp[n]=chunsin\n  vector<double> dp2(n+1,INF);//\n  vector<P> p1(n+1);\n  vector<P> p2(n+1);\n  for(int i=0;i<=n;i++){\n    if(i==0){\n      p1[i]=P(x[i],y[i]);\n      p2[i]=P(x[i],y[i]);\n    }\n    else if(i==n){\n      p1[i]=P(x[i-1],y[i-1]);\n      p2[i]=P(x[i-1],y[i-1]);\n    }\n    else{\n      //between i, i-1\n      P pre=P(x[i-1],y[i-1]);\n      P now=P(x[i],y[i]);\n      double pi=acos(-1);\n      double d=abs(now-pre);\n      double s=(r[i]+r[i-1]+d)/2;\n      double SIZE=sqrt(s*(s-r[i])*(s-r[i-1])*(s-d));\n      double dd=SIZE*2/d;\n      P center=pre+(now-pre)*(sqrt(r[i-1]*r[i-1]-dd*dd))/d;\n      P vec=(pre-now)*P(cos(pi/2),sin(pi/2));      \n      vec/=abs(vec);\n      \n            p1[i]=center+(dd+1e-6)*vec;\n\t    p2[i]=center-(dd+1e-6)*vec;\n\n    }\n\n  }\n\n  \n  auto okLine=[p1,p2](Line l,int j,int i){\n    bool isok=true;\n    for(int k=j+1;k<i;k++){\n      isok&=(isis_ss(l,Line(p1[k],p2[k])));\n    }\n    return isok;\n  };\n\t       \n  dp1[0]=0;\n  dp2[0]=0;\n  for(int i=1;i<=n;i++){\n    //renew dp1[i] and dp2[i]\n    for(int j=0;j<i;j++){\n      Line l1=Line(p1[j],p1[i]);\n      Line l2=Line(p2[j],p1[i]);\n\n      if(okLine(l1,j,i)){\n\tdp1[i]=min(dp1[i],dp1[j]+abs(p1[j]-p1[i]));\n      }\n      if(okLine(l2,j,i)){\n\tdp1[i]=min(dp1[i],dp2[j]+abs(p2[j]-p1[i]));\n      }\n      l1=Line(p1[j],p2[i]);\n      l2=Line(p2[j],p2[i]);\n      if(okLine(l1,j,i)){\n\tdp2[i]=min(dp2[i],dp1[j]+abs(p1[j]-p2[i]));\n      }\n      if(okLine(l2,j,i)){\n\tdp2[i]=min(dp2[i],dp2[j]+abs(p2[j]-p2[i]));\n      }\n    }\n  }\n  cout<<setprecision(10)<<fixed;\n  cout<<dp1[n]<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\nR dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    // ax+by+c=0\n    L(R a, R b, R c){\n        if(fabs(a) < eps) *this = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) *this = L(P(-c/a,0),P(-c/a,1));\n        else *this = L(P(-c/a,0), P(0,-c/b));\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p, R r) : p(p), r(r) { }\n    C(){}\n};\n\n// CCW\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return -1; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b 直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c 直線上\n    return 0; // 2点以上が重なっている\n}\n\n// 交差判定\nbool isiLL(const L &l, const L &m) {\n    return\n        abs(cross(l[1]-l[0], m[1]-m[0])) > eps || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < eps;   // same line\n}\n\nbool isiLS(const L &l, const L &s) {\n    return\n        cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < eps; // s[1] is right of l\n}\n\nbool isiLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool isiSS(const L &s, const L &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool isiSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool isiCP(const C &c, const P &p) {\n    // 境界または内部\n    return abs(c.p - p) <= c.r + eps;\n}\n\nint isiCC(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(abs(d - r1 - r2) < eps) return  1; // 接する\n    if(d > r1 + r2)       return  0; // 共通部分を持たない\n    if(d < r1 - r2)       return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)       return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\n\n// 距離\nR dLP(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dLL(const L &l, const L &m) {\n    return isiLL(l, m) ? 0 : dLP(l, m[0]);\n}\n\nR dLS(const L &l, const L &s) {\n    if (isiLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\nR dSP(const L &s, const P &p) {\n    const P r = proj(s, p);\n    if (isiSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dSS(const L &s, const L &t) {\n    if (isiSS(s, t)) return 0;\n    return min(min(dSP(s, t[0]), dSP(s, t[1])),\n               min(dSP(t, s[0]), dSP(t, s[1])));\n}\n\nR dCP(const C &c, const P &p) {\n    return max(0. , abs(c.p - p));\n}\n\n// 交点\nvector<P> iLL(const L &l, const L &m) {\n    R A = cross(l[1] - l[0], m[1] - m[0]);\n    R B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) throw \"PRECONDITION NOT SATISFIED!!!\";\n    return {m[0] + B / A * (m[1] - m[0])};\n}\n\nvector<P> iSS(const L& s, const L& t) {\n    if(isiSS(s,t)) return iLL(s,t);\n    else return {};\n}\n\nvector<P> iLS(const L& l, const L& s){\n    if(isiLS(l,s)) return iLL(l,s);\n    else return {};\n}\n\n// !!! not verified !!!\nvector<P> iCL(const C& c, const L& l){\n    R d = dLP(l,c.p);\n    // 接する\n    if(abs(d-c.r) < eps) return { proj(l, c.p) };\n    // 共有点を持たない\n    if(d > c.r) return {};\n    P h = proj(l, c.p);\n    P v = h - c.p;\n    P u = v * P(0,1) * sqrt(c.r*c.r - d*d) / abs(v);\n    return {h+u, h-u};\n}\n\n// !!! not verified !!!\nvector<P> iCC(const C& c1, const C& c2){\n    int i = isiCC(c1,c2);\n    // 共通部分なし || 内部\n    if(i==0 || abs(i)==3) return {};\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    // 接する\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d };\n    // 2つの交点\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = -2. * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return iCL(c1, L(A,B,C));\n}\n\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<C> cs(n);\n        rep(i,n){\n            int x,y,r;\n            cin>>x>>y>>r;\n            cs[i] = C(P(x,y),r);\n        }\n\n        int N=n*2;\n        double d[N][N];\n        rep(i,N)rep(j,N){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=inf;\n        }\n\n        for(int i=0;i<n-1;i++){\n            auto ps = iCC(cs[i],cs[i+1]);\n            P &p1=ps[0], &p2=ps[1];\n            d[i*2][i*2+1] = abs(p1-p2);\n            for(int j=i+1;j<n-1;j++){\n                auto qs = iCC(cs[j],cs[j+1]);\n                P &q1=qs[0], &q2=qs[1];\n                L s11(p1,q1), s12(p1,q2), s21(p2,q1), s22(p2,q2);\n                bool ok11 = true, ok12 = true, ok21 = true, ok22 = true;\n                for(int k=i+1;k<=j-1;k++){\n                    auto rs = iCC(cs[k],cs[k+1]);\n                    L s(rs[0],rs[1]);\n                    if(!isiSS(s,s11))ok11=false;\n                    if(!isiSS(s,s12))ok12=false;\n                    if(!isiSS(s,s21))ok21=false;\n                    if(!isiSS(s,s22))ok22=false;\n                }\n                if(ok11){\n                    d[i*2][j*2] = d[j*2][i*2] = abs(p1-q1);\n                }\n                if(ok12){\n                    d[i*2][j*2+1] = d[j*2+1][i*2] = abs(p1-q2);\n                }\n                if(ok21){\n                    d[i*2+1][j*2] = d[j*2][i*2+1] = abs(p2-q1);\n                }\n                if(ok22){\n                    d[i*2+1][j*2+1] = d[j*2+1][i*2+1] = abs(p2-q2);\n                }\n            }\n\n            L s1(ps[0],cs[0].p);\n            L s2(ps[1],cs[0].p);\n            bool oks1 = true, oks2 = true;\n            for(int j=0;j<i;j++){\n                auto t = iCC(cs[j],cs[j+1]);\n                L s(t[0],t[1]);\n                if(!isiSS(s,s1)) oks1 = false;\n                if(!isiSS(s,s2)) oks2 = false;\n            }\n            if(oks1){\n                d[N-1][i*2] = d[i*2][N-1] = abs(s1[0]-s1[1]);\n            }\n            if(oks2){\n                d[N-1][i*2+1] = d[i*2+1][N-1] = abs(s2[0]-s2[1]);\n            }\n            L t1(ps[0],cs[n-1].p);\n            L t2(ps[1],cs[n-1].p);\n            bool okt1 = true, okt2 = true;\n            for(int j=i+1;j<n-1;j++){\n                auto t = iCC(cs[j],cs[j+1]);\n                L s(t[0],t[1]);\n                if(!isiSS(s,t1)) okt1 = false;\n                if(!isiSS(s,t2)) okt2 = false;\n            }\n            if(okt1){\n                d[N-2][i*2] = d[i*2][N-2] = abs(t1[0]-t1[1]);\n            }\n            if(okt2){\n                d[N-2][i*2+1] = d[i*2+1][N-2] = abs(t2[0]-t2[1]);\n            }\n        }\n\n        rep(k,N)rep(i,N)rep(j,N)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        printf(\"%.10lf\\n\",d[N-1][N-2]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 円と線分の交点\n//\n// verified:\n//   AOJ 1183 鎖中経路\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL << 60;      // to be set appropriately\nconst DD EPS = 1e-5;        // to be set appropriately\nconst DD PI = acosl(-1.0);\nDD torad(int deg) { return (DD)(deg)* PI / 180; }\nDD todeg(DD ang) { return ang * 180 / PI; }\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) { return s << '(' << p.x << \", \" << p.y << ')'; }\n};\ninline Point operator + (const Point &p, const Point &q) { return Point(p.x + q.x, p.y + q.y); }\ninline Point operator - (const Point &p, const Point &q) { return Point(p.x - q.x, p.y - q.y); }\ninline Point operator * (const Point &p, DD a) { return Point(p.x * a, p.y * a); }\ninline Point operator * (DD a, const Point &p) { return Point(a * p.x, a * p.y); }\ninline Point operator * (const Point &p, const Point &q) { return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x); }\ninline Point operator / (const Point &p, DD a) { return Point(p.x / a, p.y / a); }\ninline Point conj(const Point &p) { return Point(p.x, -p.y); }\ninline Point rot(const Point &p, DD ang) { return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y); }\ninline Point rot90(const Point &p) { return Point(-p.y, p.x); }\ninline DD cross(const Point &p, const Point &q) { return p.x * q.y - p.y * q.x; }\ninline DD dot(const Point &p, const Point &q) { return p.x * q.x + p.y * q.y; }\ninline DD norm(const Point &p) { return dot(p, p); }\ninline DD abs(const Point &p) { return sqrt(dot(p, p)); }\ninline DD amp(const Point &p) { DD res = atan2(p.y, p.x); if (res < 0) res += PI * 2; return res; }\ninline bool eq(const Point &p, const Point &q) { return abs(p - q) < EPS; }\ninline bool operator < (const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y); }\ninline bool operator >(const Point &p, const Point &q) { return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y); }\ninline Point operator / (const Point &p, const Point &q) { return p * conj(q) / norm(q); }\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) { return s << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct Circle : Point {\n    DD r;\n    Circle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n    friend ostream& operator << (ostream &s, const Circle &c) { return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\n\n\n////////////////////////////\n// 円や直線の交点\n////////////////////////////\n\nPoint proj_for_crosspoint(const Point &p, const Line &l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nvector<Point> crosspoint(const Line &l, const Line &m) {\n    vector<Point> res;\n    DD d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < EPS) return vector<Point>();\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<Point> crosspoint(const Circle &e, const Circle &f) {\n    vector<Point> res;\n    DD d = abs(e - f);\n    if (d < EPS) return vector<Point>();\n    if (d > e.r + f.r + EPS) return vector<Point>();\n    if (d < abs(e.r - f.r) - EPS) return vector<Point>();\n    DD rcos = (d * d + e.r * e.r - f.r * f.r) / (2.0 * d), rsin;\n    if (e.r - abs(rcos) < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (f - e) / d;\n    Point p1 = e + dir * Point(rcos, rsin);\n    Point p2 = e + dir * Point(rcos, -rsin);\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\nvector<Point> crosspoint(const Circle &e, const Line &l) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, l);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (l[1] - l[0]) / abs(l[1] - l[0]);\n    Point p1 = p + dir * rsin;\n    Point p2 = p - dir * rsin;\n    res.push_back(p1);\n    if (!eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n\n// 円と線分の交点\nint ccw_for_crosspoint_cs(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\nbool isinterPS_crosspoint_cs(const Point &p, const Line &s) {\n    return (ccw_for_crosspoint_cs(s[0], s[1], p) == 0);\n}\nvector<Point> crosspoint_CS(const Circle &e, const Line &s) {\n    vector<Point> res;\n    Point p = proj_for_crosspoint(e, s);\n    DD rcos = abs(e - p), rsin;\n    if (rcos > e.r + EPS) return vector<Point>();\n    else if (e.r - rcos < EPS) rsin = 0;\n    else rsin = sqrt(e.r * e.r - rcos * rcos);\n    Point dir = (s[1] - s[0]) / abs(s[1] - s[0]);\n    Point p1 = p - dir * rsin;\n    Point p2 = p + dir * rsin;\n    if (isinterPS_crosspoint_cs(p1, s)) res.push_back(p1);\n    if (isinterPS_crosspoint_cs(p2, s) && !eq(p1, p2)) res.push_back(p2);\n    return res;\n}\n\n// 円 C と、三角形 ((0, 0), ia, ib) との共通部分の面積\nDD calc_common_area(const Circle &c, const Point &ia, const Point &ib) {\n    Point a = ia - c, b = ib - c;\n    if (abs(a - b) < EPS) return 0;\n    auto sub = [&](const Point &x, const Point &y, bool triangle) {\n        if (triangle) return cross(x, y) / 2;\n        else {\n            Point tmp = y * Point(x.x, -x.y);\n            DD ang = atan2(tmp.y, tmp.x);\n            return c.r * c.r * ang / 2;\n        }\n    };\n    bool isin_a = (abs(a) < c.r + EPS);\n    bool isin_b = (abs(b) < c.r + EPS);\n    if (isin_a && isin_b) return sub(a, b, true);\n    Circle oc(Point(0, 0), c.r);\n    Line seg(a, b);\n    auto cr = crosspoint_CS(oc, seg);\n    if (cr.empty()) return sub(a, b, false);\n    auto s = cr[0], t = cr.back();\n    return sub(a, s, isin_a) + sub(s, t, true) + sub(t, b, isin_b);\n}\n\nDD calc_common_area(const Circle &c, const vector<Point> &pol) {\n    DD res = 0;\n    int N = pol.size();\n    for (int i = 0; i < N; ++i) {\n        res += calc_common_area(c, pol[i], pol[(i+1)%N]);\n    }\n    return res;\n}\n\n\n\n////////////////////////////\n// AOJ 1183 鎖中経路\n////////////////////////////\n\nbool isin(const vector<Circle> &cs, const Line &l) {\n    vector<Point> vps;\n    for (auto c : cs) {\n        auto cps = crosspoint_CS(c, l);\n        for (auto p : cps) vps.push_back(p);\n    }\n    sort(vps.begin(), vps.end());\n    for (int i = 0; i+1 < vps.size(); ++i) {\n        Point p = (vps[i] + vps[i+1]) / 2;\n        bool exist = false;\n        for (auto c : cs) {\n            if (abs(c - p) < c.r + EPS) exist = true;\n        }\n        if (!exist) return false;\n    }\n    return true;\n}\n\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vector<Circle> cs(N);\n        for (int i = 0; i < N; ++i) cin >> cs[i].x >> cs[i].y >> cs[i].r;\n        \n        vector<Point> ips;\n        ips.push_back(Point(cs[0].x, cs[0].y));\n        for (int i = 0; i+1 < N; ++i) {\n            auto cp = crosspoint(cs[i], cs[i+1]);\n            for (auto p : cp) ips.push_back(p);\n        }\n        ips.push_back(Point(cs[N-1].x, cs[N-1].y));\n        \n        vector<DD> dp((int)ips.size() + 1, INF);\n        dp[0] = 0;\n        for (int i = 0; i < ips.size(); ++i) {\n            for (int j = i+1; j < ips.size(); ++j) {\n                Line l(ips[i], ips[j]);\n                if (isin(cs, l)) dp[j] = min(dp[j], dp[i] + abs(l[0] - l[1]));\n            }\n        }\n        cout << fixed << setprecision(10) << dp[(int)ips.size()-1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t\tBOOL intersect(const S &s)const {\n\t\t\tif(online(s[0]) || online(s[0]) || s.online(at(0)) || s.online(at(1))) return BORDER;\n\t\t\treturn (ccw(at(0), at(1),  s[0], 1) * ccw(at(0), at(1),  s[1], 1) <= 0 &&\n\t\t\t\t\tccw( s[0],  s[1], at(0), 1) * ccw( s[0],  s[1], at(1), 1) <= 0);\n\t\t}\n\t\tBOOL intersect(const L &l)const {\n\t\t\tif(l.online(at(0)) || l.online(at(1))) return BORDER;\n\t\t\treturn (sig(outp(l.dir(), at(0)-l[0])) * sig(outp(l.dir(), at(1)-l[0])) <= 0);\n\t\t}\n\t\tR distance(const L &l)const {\n\t\t\tif(intersect(l)) return .0;\n\t\t\treturn min(l.distance(at(0)), l.distance(at(1)));\n\t\t}\n\t\tR distance(const S &s)const {\n\t\t\tif(intersect(s)) return .0;\n\t\t\treturn min(min(s.distance(at(0)), s.distance(at(1))), \n\t\t\t\t\t   min(distance(s[0]), distance(s[1])));\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\treturn ((less(abs(a.r-b.r), abs(a-b)) ^ less(abs(a-b), a.r+b.r))+1) % 2;\n//\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n//\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\tinline S cc_crosspoint(const C &c1, const C &c2){\n\t\tif(!cc_intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tBOOL contains(const S &s)const {return contains(s[0]) && contains(s[1]);}\n\t\tBOOL contains(const L &l)const {return false;}\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <class T> R distance(const T& t){\n\t\t\tif(contains(t)) return .0;\n\t\t\tR res = INF;\n\t\t\tREP(i, size()){\n\t\t\t\tres = min(res, edge(i).distance(t));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n, n){\n\t\tvector<S> s;\n\t\tC prev;\n\t\tREP(i, n){\n\t\t\tC c;\n\t\t\tcin >> c;\n\t\t\tif(i == 0) s.emplace_back(c, c);\n\t\t\telse{\n\t\t\t\ts.push_back(cc_crosspoint(c, prev));\n\t\t\t}\n\t\t\tprev = c;\n\t\t}\n\t\ts.emplace_back(prev, prev);\n\t\tn = s.size() - 1;\n\t\tvector<vector<R>> dp(n+1, vector<R>(2, INF));\n\t\tdp[0][0] = dp[0][1] = .0;\n\t\tREPS(i, n)REP(j, i)REP(ik, 2)REP(jk, 2){\n\t\t\tS t(s[j][jk], s[i][ik]);\n\t\t\tif([&](){\n\t\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\t\tif(!t.intersect(s[k])) return false;\n\t\t\t\treturn true;\n\t\t\t}() == false) continue;\n\t\t\tdp[i][ik] = min(dp[i][ik], dp[j][jk] + abs(t.dir()));\n\t\t}\n\t\tprintf(\"%.4f\\n\", dp[n][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;       // counter clockwise\n\tif(cross(b, c) < 0)   return -1;       // clockwise\n\tif(dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif(norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\ntypedef double W;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> State;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph G, vector<W>& d, vector<int>& prev) {\n\tpriority_queue< State, vector<State>, greater<State> > que;\n\tfill(d.begin(), d.end(), INF);\n\tfill(prev.begin(), prev.end(), -1);\n\n\td[s] = 0;\n\tque.push(State(0, s));\n\twhile(!que.empty()) {\n\t\tState p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\tprev[e.to] = v;\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(State(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble x[100], y[100], r[100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> r[i];\n\t\t}\n\n\t\tGraph G(2 * n);\n\t\tvector<P> c;\n\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\tdouble r1 = r[i], r2 = r[i + 1];\n\t\t\tP p1(x[i], y[i]), p2(x[i + 1], y[i + 1]);\n\t\t\tP v = p2 - p1;\n\t\t\tdouble t = (r1 * r1 + norm(v) - r2 * r2) / (2 * abs(v));\n\t\t\tdouble theta = acos(t / r1);\n\t\t\tP b1 = p1 + v / abs(v) * r1 * polar(1.0, theta);\n\t\t\tP b2 = p1 + v / abs(v) * r1 * polar(1.0, -theta);\n\t\t\tc.push_back(b1);\n\t\t\tc.push_back(b2);\n\t\t}\n\n\t\tfor(int i = 0; i < c.size(); i++) {\n\t\t\tfor(int j = i + 1; j < c.size(); j++) {\n\t\t\t\tint n1 = i / 2, n2 = j / 2;\n\t\t\t\tif(n1 == n2) continue;\n\n\t\t\t\tL line(c[i], c[j]);\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = n1 + 1; k <= n2 - 1; k++) {\n\t\t\t\t\tif(!intersectSS(line, L(c[2 * k], c[2 * k + 1]))) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag) {\n\t\t\t\t\tdouble cost = abs(c[i] - c[j]);\n\t\t\t\t\tG[i].push_back(edge{ j, cost });\n\t\t\t\t\tG[j].push_back(edge{ i, cost });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint start = 2 * n - 2, goal = 2 * n - 1;\n\t\tc.push_back(P(x[0], y[0]));\n\t\tc.push_back(P(x[n - 1], y[n - 1]));\n\t\tfor(int i = 0; i < start; i++) {\n\t\t\tint n1 = i / 2;\n\t\t\tL line(c[i], c[start]);\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0; k <= n1 - 1; k++) {\n\t\t\t\tif(!intersectSS(line, L(c[2 * k], c[2 * k + 1]))) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tdouble cost = abs(c[i] - c[start]);\n\t\t\t\tG[start].push_back(edge{ i, cost });\n\t\t\t\tG[i].push_back(edge{ start, cost });\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < start; i++) {\n\t\t\tint n1 = i / 2;\n\t\t\tL line(c[i], c[goal]);\n\t\t\tbool flag = true;\n\t\t\tfor(int k = n1 + 1; k < n - 1; k++) {\n\t\t\t\tif(!intersectSS(line, L(c[2 * k], c[2 * k + 1]))) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tdouble cost = abs(c[i] - c[goal]);\n\t\t\t\tG[i].push_back(edge{ goal, cost });\n\t\t\t\tG[goal].push_back(edge{ i, cost });\n\t\t\t}\n\t\t}\n\n\t\tL line(c[start], c[goal]);\n\t\tbool flag = true;\n\t\tfor(int k = 0; k <= n - 1; k++) {\n\t\t\tif(!intersectSS(line, L(c[2 * k], c[2 * k + 1]))) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) {\n\t\t\tdouble cost = abs(c[start] - c[goal]);\n\t\t\tG[start].push_back(edge{ goal, cost });\n\t\t}\n\n\t\tvector<W> d(2 * n);\n\t\tvector<int> prev(2 * n);\n\t\tdijkstra(start, G, d, prev);\n\t\tcout << setprecision(15) << d[goal] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<complex>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\n\n\ntypedef complex<double> Point;\ntypedef pair<int,double> pid;\n\nclass Line{\n\tpublic:\n\tdouble A,B,C;\n\tLine(double A,double B,double C):A(A),B(B),C(C){}\n\tLine(){}\n};\nclass Circle : public Point{\n\tpublic:\n\tdouble R;\n\tCircle(Point pt, double R):Point(pt),R(R){}\n\tCircle(){}\n};\ndouble Dot(Point p1, Point p2){return p1.X*p2.X + p1.Y*p2.Y;}\ndouble Cross(Point p1, Point p2){return p1.X*p2.Y - p1.Y*p2.X;}\n\nbool CircleHit(Circle a, Circle b){return abs(a-b) <= a.R + b.R;}\n\nLine CircleCommonLine(Circle a,Circle b){\n\tdouble C = pow(b.R, 2)-pow(a.R, 2)+norm(a)-norm(b);\n\treturn Line(2*(b.X-a.X), 2*(b.Y-a.Y), C);\n}\n\npair<Point,Point> Suisen(Line line, Point pt){\n\tPoint v(line.A, line.B);  v/=Point(abs(v),0);\n\tPoint toPoint;\n\t\n\tif(line.B!=0){\n\t\tPoint slide = pt-Point(0, -line.C/line.B);\n\t\ttoPoint = v*Point(Dot(v,slide),0);\n\t}else{\n\t\ttoPoint = Point(pt.X + line.C/line.A, 0);\n\t}\n\treturn pair<Point,Point>(pt-toPoint, toPoint);\n}\n\npair<Point,Point> CircleCross(Circle a, Circle b){\n\tLine commonLine = CircleCommonLine(a,b);\n\tpair<Point,Point> s = Suisen(commonLine, a);\n\t\n\tdouble d = abs(s.second);\n\tif(d!=0){\n\t\tPoint e = s.second*Point(0,1)/d;\n\t\tdouble dist = sqrt(a.R*a.R - d*d);\n\t\treturn pair<Point,Point>(s.first+e*Point(dist,0), s.first+e*Point(-dist,0));\n\t}\n\treturn pair<Point,Point>(s.first-Point(0,a.R), s.first+Point(0,a.R));\n}\n\nbool ccw(Point p1, Point p2, Point p3){\n\tdouble ret = Cross(p2-p1, p3-p1);\n\t//cout<<\"ccw \"<<(p2-p1)<<\" \"<<(p3-p1)<<\" \"<<ret<<endl;\n\treturn ret>=0;\n}\n\nconst int N = 111;\ntypedef pair<int,double> pid;\n\nint n;\nCircle cir[N];\n\nvector<pid> edge[N];\npair<Point,Point> cross[N];\n\nvoid init(){\n\trep(i,N){\n\t\tedge[i].clear();\n\t\tcir[i] = Circle();\n\t\tcross[i] = pair<Point,Point>(Point(),Point());\n\t}\n}\n\nvoid setCross(){\n\trep(i,n-1){\n\t\tcross[i] = CircleCross(cir[i],cir[i+1]);\n\t}\n\trep(i,n-1){\n\t\tif(!ccw(cir[i], cross[i].first, cross[i].second)){\n\t\t\tswap(cross[i].first, cross[i].second);\n\t\t}\n\t}\n\t/*\n\trep(i,n-1){\n\t\tcout<<\"cross \"<<cross[i].first<<\" \"<<cross[i].second<<endl;\n\t}*/\n}\n\nbool canAdd(Point pt, Point pt2, int from, int to){\n\tif(from<0)from=0;\n\treps(i,from,to){\n\t\tif(!ccw(pt, pt2, cross[i].second))return false;\n\t}\n\treps(i,from,to){\n\t\tif(ccw(pt, pt2, cross[i].first))return false;\n\t}\n\treturn true;\n}\n\nvoid addEdge(Point pt,int num, int now){\n\treps(i,now+1,n){\n\t\tif(i!=n-1){\n\t\t\tif(canAdd(pt, cross[i].second, now+1, i)){\n\t\t\t\tedge[num].push_back(pid(i*2, abs(cross[i].second-pt)));\n\t\t\t}\n\t\t\tif(canAdd(pt, cross[i].first, now+1, i)){\n\t\t\t\tedge[num].push_back(pid(i*2+1, abs(cross[i].first-pt)));\n\t\t\t}\n\t\t}else{\n\t\t\tif(canAdd(pt, cir[n-1], now+1, n-1)){\n\t\t\t\tedge[num].push_back(pid(n*2, abs(cir[n-1]-pt)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid makeEdge(){\n\t\n\treps(i,-1,n-1){\n\t\tif(i==-1){\n\t\t\taddEdge(cir[0],n*2-1,i);\n\t\t}else{\n\t\t\taddEdge(cross[i].first,i*2+1, i);\n\t\t\taddEdge(cross[i].second,i*2, i);\n\t\t}\n\t}\n}\n\nclass P{\n\tpublic:\n\tint now;\n\tdouble val;\n\tP(int now,double val):now(now),val(val){}\n\tbool operator<(const P& a)const{\n\t\treturn val>a.val;\n\t}\n};\ndouble dijkstra(){\n\t\n\t/*\n\trep(i,n*2+2){\n\t\tprintf(\"i(%d) :: \",i);\n\t\trep(j,edge[i].size()){\n\t\t\tprintf(\"(%d,%lf)\",edge[i][j].first, edge[i][j].second);\n\t\t}puts(\"\");\n\t}*/\n\t\n\tpriority_queue<P> que;\n\tque.push(P(n*2-1, 0));\n\t\n\tint visit[111]={0};\n\twhile(1){\n\t\tif(que.empty())break;\n\t\t\n\t\tP u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(u.now==n*2)return u.val;\n\t\tif(visit[u.now]==1)continue;\n\t\tvisit[u.now]=1;\n\t\t\n\t\t//printf(\"ijk %d %lf\\n\",u.now,u.val);\n\t\trep(i,edge[u.now].size()){\n\t\t\tpid e = edge[u.now][i];\n\t\t\tque.push(P(e.first, u.val+e.second));\n\t\t}\n\t}\n\treturn -1;\n}\n\ndouble solve(){\n\tinit();\n\t\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tcir[i] = Circle(Point(a,b),c);\n\t}\n\t\n\tsetCross();\n\tmakeEdge();\n\t\n\treturn dijkstra();\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%.9lf\\n\",solve());\n\t\t//break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n     \n    Point operator * (Point p){\n        return Point(p.x*x-p.y*y,p.x*y+p.y*x);\n    }\n\n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n    \n    Point operator = (Point p){\n        x = p.x;\n        y = p.y;\n        return *this;\n    }\n\n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n    //?????????????????§?????????2???\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n    //?????????????????§??????\n    return sqrt(norm(p));\n}\nPoint UnitVector(Point a){\n    //??????????????????\n    return a/pabs(a);\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //?????????\n    double r; //??????\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a???b ??§???????¨?????????????c ccw\n    if(cross(b,c) < 0)return -1; //a???b ??§????¨?????????????c ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\n\nPoint projection(Line l, Point p){\n    double t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + (l[0]-l[1])*t;\n}\n\nPoint reflection(Line l, Point p){\n    return p + (projection(l,p)-p)*2.0; \n}\n\nbool intersectSS(Line l,Line m){\n    //l??¨m??????????????????????????????\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<EPS)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<EPS);\n}\n\nbool intersectSP(Line l, Point p){\n    //??????l??¨???p?????????????????????\n    return !ccw(l[0],l[1],p);\n}\n\ndouble distanceLP(Line l,Point p){\n    //??????l??¨???p????????¢\n    p = p - l[0];\n    l[1] = l[1] - l[0];\n    if(intersectSP(l,p))return 0.0;\n    return fabs(cross(p,l[1])/pabs(l[1]));\n}\n\nbool intersectLL(Line l,Line m){\n    return fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //????????§??????\n            fabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //????????????\n}\n\nbool intersectCP(Circle c,Point p){\n    //???c??¨???p???????????????\n    //true->???c????????¨??????p????????¨????????????.\n    return fabs(pabs(p-c.p)-c.r)<EPS;\n}\n\nint intersectCL(Circle c,Line l,Point *p,Point *q){\n    if(norm(projection(l,c.p) - c.p) - c.r*c.r > EPS)return 0;\n    double d1 = pabs(c.p-l[0]);\n    double d2 = pabs(c.p-l[1]);\n    if(d1 < c.r + EPS && d2 < c.r + EPS)return 0;\n    if(d1 < c.r - EPS && d2 > c.r+EPS\n        || d1 > c.r + EPS && d2 < c.r -EPS)return 1;\n    Point h = projection(l,c.p);\n    if(dot(l[0] - h,l[1] - h) < 0)return 2;\n    return 0;\n}\n\nint intersectCC(Circle a,Circle b,Point *p,Point *q){\n    double dist = pabs(a.p-b.p);\n    if(dist < fabs(a.r-b.r) || dist > a.r+b.r){\n        //????????????????????´??????????????¨???\n        //????????????????????¨???????????¨???\n        *p = Point(1e15,1e15);\n        *q = Point(1e15,1e15);\n        return 0;\n    }\n    else if(fabs(dist-a.r-b.r) < EPS){\n        //??????1?????§????????£???????????¨???\n        Point way;\n        way = b.p-a.p;\n        *p = a.p+UnitVector(way)*a.r;\n        *q = *p;\n        return 1;\n    }\n    else{\n        //??????2?????§????????£???????????¨???\n        if(a.r < b.r){\n            swap(a.r,b.r);\n            swap(a.p,b.p);\n        }\n        double s = (a.r + b.r + dist) / 2.0 ;\n        double area = sqrt(s * (s - a.r) * (s - b.r) * (s - dist));\n        double h = 2.0 * area / dist;\n\n        Point  v = b.p-a.p;\n        v = UnitVector(v);\n        Point  m = a.p + (v*sqrt(a.r*a.r-h*h));\n        Point  n = v * Point(0.0,1.0);\n        \n        *p = m + (n * h);\n        *q = m - (n * h);\n        return 2;\n    }\n}\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5; //?????????????????¨??????????????§??¨???\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea; //?????????????????¨??????????????§??¨???\n}\n\nPoint crosspoint(Line l,Line m){\n    //??????l??¨??????m?????????\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nPolygon ConvexHull(Polygon v){\n    //??????????????????\n    int n = v.size();\n    int k = 0;\n    sort(v.begin(),v.end());\n    Polygon e(2*n);\n    for(int i=0;i<n;e[k++]=v[i++])\n        while(k>=2&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n    for(int i=n-2,t=k+1;i>=0;e[k++]=v[i--])\n        while(k>=t&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n    e.resize(k-1);\n    return e;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n    edge(){}\n    edge(int _to,double _cost){\n        to = _to;\n        cost = _cost;\n    }\n    bool operator < (const edge &a)const{\n        return a.cost<cost;\n    }\n};\ntypedef pair<Point,int> P;\n\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        Circle C[128];\n        vector < pair < Point , int >  > points;\n        Point start,goal;\n        rep(i,N){\n            double x,y,r;\n            scanf(\"%lf%lf%lf\",&x,&y,&r);\n            if(i == 0){\n                start = Point(x,y);\n            }\n            if(i == N-1){\n                goal = Point(x,y);\n            }\n            C[i] = Circle(Point(x,y),r);\n        }\n        vector < Line > arc;\n        points.PB(P(start,0));\n        rep(i,N){\n            reps(j,i+1,N){\n                Point p,q;\n                int tmp = intersectCC(C[i],C[j],&p,&q);\n                if(tmp > 0){\n                    points.PB(P(p,j));\n                    points.PB(P(q,j));\n                    Line l;\n                    l.PB(p);l.PB(q);\n                    arc.PB(l);\n         //         cout << p.x << \" \" << p.y << \"\\n\";\n         //         cout << q.x << \" \" << q.y << \"\\n\";\n                }\n            }\n        }\n       // puts(\"$$$$$$$$$$$$$$$$$$$$$$\");\n        points.PB(P(goal,N-1));\n        int goal_ID = points.size()-1;\n\n        vector< edge > G[250];\n        rep(i,points.size()){\n            reps(j,i+1,points.size()){\n                double dist = pabs(points[i].fi-points[j].fi);\n                Line l;\n                l.PB(points[i].fi);\n                l.PB(points[j].fi);\n                int cnt = 0;\n                Point p,q;\n                bool flg = true;\n        //        cout << \"&\" <<points[i].se+1 << \" \" << points[j].se << \"\\n\";\n                for(int k = points[i].se+1; k < points[j].se+1; k++){\n                    bool a = true;\n                    a = intersectSS(l,arc[k-1]);\n                    //cout << a << \"\\n\";\n                    if(!a){\n                        flg = false;\n                    }\n                }\n                if(!flg)continue;\n                G[i].PB(edge(j,dist));\n                G[j].PB(edge(i,dist));\n            //    cout << i << \" \" << j << \" \" << dist << \" \"<< flg <<\"\\n\";\n            }\n        }\n\n        double d[128];\n        fill(d,d+128,INF);\n        priority_queue < edge > Q;\n        Q.push(edge(0,0.0));\n\n        while(!Q.empty()){\n            edge e = Q.top();Q.pop();\n            if(d[e.to] != INF)continue;\n            d[e.to] = e.cost;\n            rep(i,G[e.to].size()){\n                Q.push(edge(G[e.to][i].to,G[e.to][i].cost+d[e.to]));\n            }\n        }\n\n        printf(\"%lf\\n\",d[goal_ID]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\n\ndouble eps = 1e-9;\n\ndouble add(double a, double b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(double a, double b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    double x, y;\n    P() {}\n    P(double x, double y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(double d) const {return P(x*d, y*d);}\n    double dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    double det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    double dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\n\n// ??????p1-p2?????????q???????????????????????????\n// ????¢????\nbool on_seg(P p1, P p2, P q) {\n    return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2?????????\n// ????¢????\nP intersection(P p1, P p2, P q1, P q2) {\n    return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\ndouble square(double x) {return x*x;}\n\nconst int MAXN = 101;\nconst double INF = 1e18;\nint n;\ndouble x[MAXN], y[MAXN], r[MAXN];\ndouble dp[MAXN][2];\nP ps[MAXN][2];\n\nbool ok(int from, int fromi, int to, int toi) {\n    for (int i = from+1; i < to; i++) {\n        P inter = intersection(ps[from][fromi], ps[to][toi], ps[i][0], ps[i][1]);\n        if (on_seg(ps[i][0], ps[i][1], inter)) continue;\n        else return false;\n    }\n    return true;\n}\n\nvoid solve() {\n    ps[0][0].x = ps[0][1].x = x[0];\n    ps[0][0].y = ps[0][1].y = y[0];\n    ps[n][0].x = ps[n][1].x = x[n-1];\n    ps[n][0].y = ps[n][1].y = y[n-1];\n    for (int i = 0; i <= n; i++) for (int j = 0; j < 2; j++) {\n        dp[i][j] = INF;\n    }\n    dp[0][0] = dp[0][1] = 0;\n    for (int i = 0; i < n-1; i++) {\n        double x1 = x[i+1] - x[i];\n        double y1 = y[i+1] - y[i];\n        double r1 = r[i], r2 = r[i+1];\n        double a = (square(x1) + square(y1) + square(r1) - square(r2)) / 2;\n        ps[i+1][0].x = (a*x1 + y1 * sqrt((square(x1) + square(y1)) * square(r1) - square(a))) / (square(x1) + square(y1)) + x[i];\n        ps[i+1][1].x = (a*x1 - y1 * sqrt((square(x1) + square(y1)) * square(r1) - square(a))) / (square(x1) + square(y1)) + x[i];\n        ps[i+1][0].y = (a*y1 - x1 * sqrt((square(x1) + square(y1)) * square(r1) - square(a))) / (square(x1) + square(y1)) + y[i];\n        ps[i+1][1].y = (a*y1 + x1 * sqrt((square(x1) + square(y1)) * square(r1) - square(a))) / (square(x1) + square(y1)) + y[i];\n    }\n    //for (int i = 0; i <= n; i++) {\n    //    cout << i << endl;\n    //    cout << ps[i][0].x << \"  \" << ps[i][0].y << endl;\n    //    cout << ps[i][1].x << \"  \" << ps[i][1].y << endl;\n    //}\n    for (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) {\n        for (int k = i+1; k <= n; k++) for (int l = 0; l < 2; l++) {\n            if (ok(i, j, k, l)) {\n                dp[k][l] = min(dp[k][l], dp[i][j] + ps[i][j].dist(ps[k][l]));\n            }\n        }\n    }\n    printf(\"%.15lf\\n\", dp[n][0]);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> n) {\n        if (n == 0) break;\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> r[i];\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst double INF = 1e10;\n\nbool isEqual(double a, double b) { return abs(a - b) < EPS; }\ndouble dot(C a, C b) { return a.cx * b.cx + a.cy * b.cy; }\ndouble det(C a, C b) { return a.cx * b.cy - a.cy * b.cx; }\nbool isPointOnSegment(C a, C b, C c) { return isEqual(abs(a-b) - abs(a-c) - abs(b-c), 0.0); }\nbool isLineParallel(C a1, C a2, C b1, C b2) { return isEqual(det(a1-a2, b1-b2), 0.0); }\nC intersectionLine(C a1, C a2, C b1, C b2) { \n  C a = a2 - a1, b  = b2 - b1;\n  return a1 + a * det(b, b1 - a1) / det(b, a);\n}\n\nll n, x[100], y[100], r[100];\nC c[100], p[2][101];\ndouble d[2][101];\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    for (ll i = 0; i < n; i++) scanf(\"%lld%lld%lld\", &x[i], &y[i], &r[i]), c[i] = C(x[i], y[i]);\n    p[0][0] = p[1][0] = c[0];\n    p[0][n] = p[1][n] = c[n-1];\n    for (ll i = 0; i < n-1; i++) {\n      double len = abs(c[i] - c[i+1]);\n      double t1 = (len * len + r[i] * r[i] - r[i+1] * r[i+1]) / (2 * len);\n      C temp = t1 / len * (c[i+1] - c[i]) + c[i];\n      C dir = sqrt(r[i] * r[i] - t1 * t1) * (c[i+1] - c[i]) / abs(c[i+1] - c[i]) * I;\n      p[0][i+1] = temp + dir;\n      p[1][i+1] = temp - dir;\n    }\n    for (ll i = 1; i <= n; i++) d[0][i] = d[1][i] = INF;\n    d[0][0] = d[1][0] = 0;\n    for (ll i = 1; i <= n; i++) {\n      for (ll j = 0; j < i; j++) {\n        for (ll k = 0; k < 4; k++) {\n          ll s = (k&2) ? 1 : 0, t = k&1;\n          C c1 = p[s][j], c2 = p[t][i];\n          bool flag = true;\n          for (ll r = j+1; r < i; r++) {\n            if (isLineParallel(c1, c2, p[0][r], p[1][r])) { flag = false; break; }\n            C temp = intersectionLine(c1, c2, p[0][r], p[1][r]);\n            if (!isPointOnSegment(c1, c2, temp) || !isPointOnSegment(p[0][r], p[1][r], temp)) { flag = false; break; }\n          }\n          if (flag) d[t][i] = min(d[t][i], d[s][j] + abs(p[s][j]-p[t][i]));\n        }\n      }\n    }\n    printf(\"%.9lf\\n\", d[0][n]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\ntypedef pair<P,double> circle;\n\nstruct L { P p, q; L(P p, P q) : p(p), q(q) {} };\n\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nbool ssIntersect(L a, L b){\n\tif(abs(imag((a.q-a.p)/(b.q-b.p)))<EPS) return false;\n\treturn cross(a.q-a.p, b.p-a.p)*cross(a.q-a.p, b.q-a.p) < 0 &&\n    \t   cross(b.q-b.p, a.p-b.p)*cross(b.q-b.p, a.q-b.p) < 0;\n}\n\nvoid crossPoint(vector<P> &res, circle c1, circle c2){\n\tdouble r1 = c1.second;\n\tdouble r2 = c2.second;\n\tdouble r3 = abs(c1.first-c2.first);\n\tdouble rc = (r3*r3+r1*r1-r2*r2)/(2*r3);\n\tdouble rs = sqrt(r1*r1-rc*rc);\n\tP dif = (c2.first-c1.first)/r3;\n\tres.push_back(c1.first+dif*P(rc, rs));\n\tres.push_back(c1.first+dif*P(rc,-rs));\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<circle> vc(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y, r; cin >> x >> y >> r;\n\t\t\tvc[i] = make_pair(P(x,y), r);\n\t\t}\n\t\tvector<P> vp;\n\t\tvp.push_back(vc[0].first);\n\t\tfor(int i=0;i+1<n;i++) crossPoint(vp, vc[i], vc[i+1]);\n\t\tvp.push_back(vc.back().first);\n\n\t\tvector<double> dist(2*n, 1e12);\n\t\tdist[0] = 0;\n\t\tfor(int i=0;i<2*n;i++){\n\t\t\tfor(int j=i+1;j<2*n;j++){\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int k=(i+1)/2+1;ok && k<(j+1)/2;k++)\n\t\t\t\t\tok &= ssIntersect(L(vp[i], vp[j]), L(vp[2*k-1], vp[2*k]));\n\t\t\t\tif(ok) dist[j] = min(dist[j], dist[i]+abs(vp[i]-vp[j]));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", dist[2*n-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 17:30~ 22:30\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n\n#define INF 1000000.0\n\nusing namespace std;\n\nstruct P{\n\tdouble x, y;\n\tP(double X=0.0, double Y=0.0){\n\t\tx = X;\n\t\ty = Y;\n\t} \n\tP operator+( const P &in ){\n\t\tP tmp( x + in.x , y + in.y );\n\t\treturn tmp;\n\t}\n\tP operator-( const P &in ){\n\t\tP tmp( x - in.x , y - in.y );\n\t\treturn tmp;\n\t}\n\tP operator*( const double &in ){\n\t\tP tmp( x * in , y * in );\n\t\treturn tmp;\n\t}\n\tdouble dot( const P &in ){\n\t\treturn x * in.x + y * in.y;\n\t}\n\tdouble cross( const P &in ){\n\t\treturn x * in.y - y * in.x;\n\t}\n\tdouble length(){\n\t\treturn sqrt( x*x + y*y );\n\t}\n};\n\n\n//交差しているか求める(どの3点も同直線上にない)\nbool check(P a1, P a2, P b1, P b2){\n\tP va = a2 - a1, vb = b2 - b1;\n\tP v1 = b1 - a1, v2 = b2 - a2;\n\n\tif( ( va.cross( v1 ) * va.cross( v2 ) ) < 0.0 &&\n\t\t( vb.cross( v1 ) * vb.cross( v2 ) ) < 0.0 )\n\t\treturn true;\n\t\n\treturn false;\n}\n\n//2円の交点を求める(2円の中心の中点cからのベクトルvを返す(交点はc±v) )\nvoid circlecross(P a, double ra, P b, double rb, P *p1, P *p2){\n\n\tdouble c = (a - b).length();\n\tdouble r = (ra*ra - rb*rb + c*c ) / ( 2.0 * c*c );\n\tdouble d = sqrt( ra*ra - c*c*r*r );\n\t\n\tP tmp( d*(a.y - b.y)/c, d*(b.x - a.x)/c);\n\tP cen = a * (1.0-r) + b * r;\n\t\n\t*p1 = cen + tmp;\n\t*p2 = cen - tmp;\n}\n\nint n;\n\nint solve(){\n\tP c[100], p[101][2];\n\tdouble r[100];\n\tdouble dist[205][205];\n\t\n\tcin >> c[0].x >> c[0].y >> r[0];\n\tp[0][0] = c[0];\n\tp[0][1] = c[0];\n\tfor(int i=1; i<n; i++){\n\t\tcin >> c[i].x >> c[i].y >> r[i];\n\t\tcirclecross( c[i-1], r[i-1], c[i], r[i], &p[i][0], &p[i][1]);\n\t}\n\tp[n][0] = c[n-1];\n\tp[n][1] = c[n-1];\n\n\t//求める\n\tfill( dist[0], dist[0]+205*205, INF );\n\tfor(int i=0; i<n*2; i++){\n\t\tfor(int j=i+1; j<=n*2; j++){\n\t\t\tbool f=true;\n\t\t\tfor(int k=i/2+1; k<j/2; k++){\n\t\t\t\tif( !check( p[i/2][i%2], p[j/2][j%2], p[k][0], p[k][1] ) )\n\t\t\t\t\tf = false;\n\t\t\t}\n\t\t\tif( f ){\n\t\t\t\tdouble x = p[i/2][i%2].x - p[j/2][j%2].x;\n\t\t\t\tdouble y = p[i/2][i%2].y - p[j/2][j%2].y;\n\t\t\t\tdist[i][j] = sqrt( x*x + y*y );\n\t\t\t}\n\t\t}\n\t}\n\t//最短経路\n\tfor(int k=1; k<n*2; k++){\n\t\tfor(int i=0; i<=n*2; i++){\n\t\t\tfor(int j=0; j<=n*2; j++){\n\t\t\t\tdist[i][j] = min( dist[i][j], dist[i][k] + dist[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%0.6f\\n\", dist[0][n*2] );\n\t\n\treturn 0;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nclass Dice\n{\npublic:\n\tvector<int> numbers;\n\t\n\tDice(int t, int f) {\n\t\tnumbers = vector<int>(6, 0);\n\t\tnumbers[4] = t;\n\t\tnumbers[5] = 7-t;\n\t\tnumbers[0] = f;\n\t\tnumbers[2] = 7-f;\n\t\tnumbers[1] = 1 + sides(t-1, f-1);\n\t\tnumbers[3] = 7 - numbers[1];\n\t}\n\t\n\tint sides(int t, int f) {\n\t\treturn vector<vector<int>>({{ 0, 4, 2, 5, 3, 0 },\n\t\t\t\t\t     { 3, 0, 6, 1, 0, 4 },\n\t\t\t\t\t     { 5, 1, 0, 0, 6, 2 },\n\t\t\t\t         { 2, 6, 0, 0, 1, 5 },\n\t\t\t\t         { 4, 0, 1, 6, 0, 3 },\n\t\t\t\t         { 0, 3, 5, 2, 4, 0 }})[t][f];\n\t}\n\t\n\tvoid rotate(int d) {\n\t\tvector<vector<int>> v({{ 5, 1, 4, 3, 0, 2},\n\t\t\t\t\t           { 0, 5, 2, 4, 1, 3},\n\t\t\t\t\t           { 4, 1, 5, 3, 2, 0},\n\t\t\t\t\t           { 0, 4, 2, 5, 3, 1}});\n\t\t\n\t\tvector<int> next(6, 0);\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tnext[v[d][i]] = numbers[i];\n\t\t}\n\t\t\n\t\tnumbers = next;\t           \n\t}\n};\n\nint main() {\n\tfor(int n; (cin >> n) && n; ) {\n\t\tint table[256][256] = {0};\n\t\tint depth[256][256] = {0};\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint t, f;\n\t\t\tcin >> t >> f;\n\t\t\t\n\t\t\tDice dice(t, f);\n\t\t\tfor(int x = 128, y = 128; ; ) {\n\t\t\t\tint d = -1;\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tif(((d == -1) || dice.numbers[d] < dice.numbers[i]) && depth[x][y] > depth[x + dx[i]][y + dy[i]]) {\n\t\t\t\t\t\td = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// cant rotate\n\t\t\t\tif(d == -1 || dice.numbers[d] <= 3) {\n\t\t\t\t\ttable[x][y] = dice.numbers[4]; // top\n\t\t\t\t\tdepth[x][y]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdice.rotate(d);\n\t\t\t\tx += dx[d]; y += dy[d];\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> v(7, 0);\n\t\tfor(int i = 0; i < 256; i++) {\n\t\t\tfor(int j = 0; j < 256; j++) {\n\t\t\t\tv[table[i][j]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < 7; i++) {\n\t\t\tcout << v[i] << (i + 1 == 7 ? '\\n' : ' ');\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b-a) + EPS < abs(c-a) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(abs(a.first-b.first) < EPS ||\n     abs(a.first-b.second) < EPS ||\n     abs(a.second-b.first) < EPS ||\n     abs(a.second-b.second) < EPS) return true;\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\nP n_vector(P a){\n  //a????????????????????´?????????????????????\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\nL cpcc(C a, C b){\n  //?????¨????????????\n  double d = abs(a.first-b.first), ra = a.second, rb = b.second;\n  double t = (ra*ra-rb*rb+d*d)/2/d, h = sqrt(ra*ra-t*t);\n  P m = t/abs(b.first-a.first)*(b.first-a.first)+a.first;\n  L cp;\n  P n = n_vector(a.first-b.first);\n  cp = L(m-n*h, m+n*h);\n  return cp;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    double x, y, r;\n    vector<C> Cs;\n    vector<L> cps;\n    vector<P> points;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y >> r;\n      Cs.push_back(make_pair(P(x,y),r));\n    }\n    points.push_back(Cs[0].first);\n    for(int i = 1; i < n; ++i){\n      L cp = cpcc(Cs[i],Cs[i-1]);\n      cps.push_back(cp);\n      points.push_back(cp.first);\n      points.push_back(cp.second);\n    }\n    points.push_back(Cs[n-1].first);\n    vector< vector<double> > dist(2*n,vector<double>(2*n,INF));\n    for(int i = 0; i < 2*n; ++i){\n      for(int j = i; j < 2*n; ++j){\n\tif(i == j){\n\t  dist[i][j] = 0;\n\t  continue;\n\t}\n\tint s = min(max(0,i-1)/2,n-2), e = min(max(0,j-1)/2,n-2);\n\t//int s = (i-1)/2, e = (j-1)/2;\n\tbool f = true;\n\tfor(int k = s; k <= e; ++k){\n\t  if(!is_cross(L(points[i],points[j]), cps[k])){\n\t    //cout << points[i] << points[j] << cps[k].first << cps[k].second << endl;\n\t    f = false;\n\t    break;\n\t  }\n\t}\n\tif(f){\n\t  dist[i][j] = abs(points[i]-points[j]);\n\t  dist[j][i] = abs(points[i]-points[j]);\n\t}\n      }\n    }\n    /*\n    for(int i = 0; i < 2*n; ++i)\n      for(int j = 0; j < 2*n; ++j)\n\tcout << dist[i][j] << endl;\n    */\n    \n\n    for(int k = 0; k < 2*n; ++k)\n      for(int i = 0; i < 2*n; ++i)\n\tfor(int j = 0; j < 2*n; ++j)\n\t  dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\n    printf(\"%.10f\\n\", dist[0][2*n-1]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n#include <utility>\n#include <stdio.h>\n#define inf 1e9\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec2d{\n  double x, y;\n  vec2d(){}\n  vec2d(double x, double y){\n    this->x = x, this->y = y;\n  }\n  double add(double a, double b){\n    if(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n    return a+b;\n  }\n  vec2d operator+(vec2d ope){\n    return vec2d(add(x, ope.x), add(y, ope.y));\n  }\n  vec2d operator-(vec2d ope){\n    return vec2d(add(x, -ope.x), add(y, -ope.y));\n  }\n  vec2d operator*(double t){\n    return vec2d(x*t, y*t);\n  }\n  vec2d operator/(double t){\n    return vec2d(x/t, y/t);\n  }\n  double dot(vec2d ope){\n    return add(x*ope.x, y*ope.y);\n  }\n  double cross(vec2d ope){\n    return add(x*ope.y, -y*ope.x);\n  }\n  double norm(){\n    double d2 = dot(*this);\n    if(d2 > 0) return sqrt(d2);\n    return 0.0;\n  }\n};\n\ndouble distPP(vec2d p, vec2d q){\n  return (p-q).norm();\n}\ndouble distSP(vec2d p, vec2d q, vec2d x){\n  if((x-p).dot(q-p) <= 0) return distPP(p, x);\n  if((x-q).dot(p-q) <= 0) return distPP(q, x);\n  return fabs((x-p).cross(q-p) / distPP(p, q));\n}\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n  return (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n  if((q-p).cross(s-r) == 0){\n    return isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\n  }\n  double t = (r-p).cross(s-r) / (q-p).cross(s-r);\n  vec2d x = p + (q-p)*t;\n  return isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nvoid getCrossPointCC(vec2d c1, double r1, vec2d c2, double r2, vec2d &lp, vec2d &rp)\n{\n  vec2d v = c2 - c1, n;\n  double d = v.norm();\n  double x = (r1*r1-r2*r2+d*d) / (2*d);\n\n  v = v*(x/d);\n  n = vec2d(-v.y, v.x);\n  if(x >= 0){\n    n = n*(sqrt(r1*r1-x*x) / n.norm());\n    lp = c1 + v - n, rp = c1 + v + n;\n  }\n  else{\n    n = n*(sqrt(r2*r2-(d-x)*(d-x))) / n.norm();\n    lp = c1 + v + n, rp = c1 + v - n;\n  }\n}\n\nint n;\nvec2d p[105];\ndouble r[105];\nvector<pair<vec2d, int> > vec;\nvec2d lp[305], rp[305];\ndouble G[305][305];\ndouble dist[305][305];\n\nint main(void)\n{\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 1; i <= n; i++){\n      cin >> p[i].x >> p[i].y >> r[i];\n    }\n\n    vec.clear();\n    vec.push_back(make_pair(p[1], 0)), vec.push_back(make_pair(p[n], n));\n    for(int i = 1; i < n; i++){\n      vec2d u, v;\n      getCrossPointCC(p[i], r[i], p[i+1], r[i+1], u, v);\n      vec.push_back(make_pair(u, i)), vec.push_back(make_pair(v, i));\n      lp[i] = u, rp[i] = v;\n    }\n    //cout << vec.size() << endl;\n\n    /*for(int i = 0; i <vec.size(); i++){\n      cout << vec[i].first.x << \" \" << vec[i].first.y << endl;\n      }*/\n\n    int V = vec.size();\n    for(int i = 0; i < V; i++){\n      for(int j = 0; j < V; j++){\n\tif(i == j) G[i][j] = 0;\n\telse G[i][j] = inf;\n      }\n    }\n   \n\n    for(int i = 0; i < V; i++){\n      for(int j = 0; j < V; j++){\n\tif(i >= j) continue;\n\tbool flag = true;\n\tint L = min(vec[i].second, vec[j].second);\n\tint R = max(vec[i].second, vec[j].second);\n\tfor(int k = L+1; k <= R-1; k++){\n\t  if(!isCross(vec[i].first, vec[j].first, lp[k], rp[k])) flag = false;\n\t}\n\tif(flag) G[i][j] = G[j][i] = distPP(vec[i].first, vec[j].first);\n      }\n    }\n\n    /*for(int i = 0; i < V; i++){\n      for(int j = 0; j < V; j++){\n\tcout << G[i][j] << \" \";\n      }\n      cout << endl;\n      }*/\n\n    for(int i = 0; i < V; i++){\n      for(int j = 0; j < V; j++){\n\tdist[i][j] = G[i][j];\n      }\n    }\n    for(int k = 0; k < V; k++){\n      for(int i = 0; i < V; i++){\n\tfor(int j = 0; j < V; j++){\n\t  dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t}\n      }\n    }\n    printf(\"%11f\\n\", dist[0][1]);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<map>\nusing namespace std;\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//線分p1-p2上に点qがあるか判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//直線p1-p2と直線q1-q2の交点\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n//線分p1-p2と線分q1-q2が交差するか\nbool intersecting(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//平行\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n\n//円同士の交点を計算\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//交点なし\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n\n\nint main(){\n\tint n,ans;\n\tdouble x[100],y[100],r[100];\n\tdouble d[200][200];\n\tvector<P> v;\n\tvector<pair<P,P> > line;\n\tvector<int> L;\n\twhile(cin>>n&&n){\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i]>>r[i];\n\t\tfor(int i=0;i<200;i++)for(int j=0;j<200;j++)d[i][j]=INF;\n\t\tline.clear();\n\t\tv.clear();\n\t\tv.push_back(P(x[0],y[0]));\n\t\tL.clear();\n\t\tL.push_back(-1);\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tpair<P,P> a = circle_intersection(x[i],y[i],r[i],x[i+1],y[i+1],r[i+1]);\n\t\t\tv.push_back(a.first);\n\t\t\tv.push_back(a.second);\n\t\t\tL.push_back(i);L.push_back(i);\n\t\t\tline.push_back(a);\n\t\t}\n\t\tv.push_back(P(x[n-1],y[n-1]));\n\t\tL.push_back(n-1);\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\t\tint k;\n\t\t\t\tfor(k=L[i]+1;k<L[j];k++){\n\t\t\t\t\tif(!intersecting(v[i],v[j],line[k].first,line[k].second))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k>=L[j])//間の交点間の線分全てと交差する\n\t\t\t\t\td[i][j]=d[j][i]=dist(v[i],v[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<v.size();k++)\n\t\t\tfor(int i=0;i<v.size();i++)\n\t\t\t\tfor(int j=0;j<v.size();j++)\n\t\t\t\t\td[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\tprintf(\"%.4f\\n\",d[0][v.size()-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <list>\n#include <map>\n#include <cmath>\n#include <utility>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <set>\n#include <climits>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI = acos(-1.0);\n\ntemplate<class T>\nclass Po{\n\tT x,y;\n\tPo() : x(0),y(0) {}\n\tPo(const T &x,const T &y) : x(x),y(y) {}\n\tPo operator+(const Po& a) const { return P(x + a.x,y + a.y); }\n\tPo operator-(const Po& a) const { return P(x - a.x,y - a.y); }\n\tPo operator*(const double& a) const { return P(x * a, y * a); }\n\tPo operator/(const double& a) const { return P(x / a, y / a); }\n};\n\nenum{ CCW = 1,CW = -1,ON = 0};\n\ntypedef Po<double> P;\n\ndouble SQ(double x) {return x* x; }\ndouble abs(const P& a) { return sqrt(SQ(a.x) + SQ(a.y)); }\ndouble dot( const P& a,const P &b){ return a.x * b.x + a.y * b.y ; }\ndouble cross( const P& a,const P &b){ return a.x * b.y - a.y * b.x ; }\n\nP rot(const P& a, double theta){\n\treturn P( a.x * cos(theta) - a.y * sin(theta) ,\n\t\ta.x * sin(theta) + a.y * cos(theta) );\n}\n\nint ccw(P a,P b,P c){\n\tb = b - a; c = c - a;\n\tdouble rdir = cross(b,c);\n\tdouble len = abs(b) * abs(c);\n\tif( rdir > EPS *len) return CCW;\n\telse if( rdir < -EPS * len) return CW;\n\treturn ON;\n}\n\nbool intersect(P& a1,P& b1,P& a2, P& b2){\n\tif(max(a1.x,b1.x) + EPS < min(a2.x,b2.x)\n\t||max(a1.y,b1.y) + EPS < min(a2.y,b2.y)\n\t||max(a2.x,b2.x) + EPS < min(a1.x,b1.x)\n\t||max(a2.y,b2.y) + EPS < min(a1.y,b1.y) ) return false;\n\treturn ccw(a1,b1,a2) * ccw(a1,b1,b2) <= 0\n\t\t&& ccw(a2,b2,a1) * ccw(a2,b2,b1) <= 0;\n}\n\ntypedef pair<P,P> PD;\n\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\nint n;\nP p[100];\ndouble r[100];\ndouble dp[202][202];\n\n#define FOR(i,n) for(int i = 0; i < (n) ; i++)\n\n\nint main(){\n\n\twhile(cin>>n,n){\n\t\tvector<P> us;\n\t\tvector<PD> vpd;\n\t\tFOR(i,n) cin>>p[i].x >> p[i].y >> r[i];\n\t\tFOR(i,202) FOR(j,202) dp[i][j] = 1e50;\n\t\tus.push_back(p[0]);\n\n\t\tfor (int i = 0; i < n - 1; i++){\n\t\t\tPD pd = GetContact(p[i],p[i+1],r[i],r[i+1]);\n\t\t\tus.push_back(pd.first);\n\t\t\tus.push_back(pd.second);\n\t\t\tvpd.push_back(pd);\n\t\t}\n\t\tus.push_back(p[n-1]);\n\n\t\tfor(int i = 0; i < (int)us.size(); i++){\n\t\t\tfor(int j = i + 1; j < (int)us.size(); j++){\n\t\t\t\tbool ok = true;\n\t\t\t\tint l  = (1 + i) / 2;\n\t\t\t\tint r = (1 + j) / 2 - 1;\n\t\t\t\tfor (int k = l; k < r; k++){\n\t\t\t\t\tif(!intersect(us[i],us[j],vpd[k].first,vpd[k].second))\n\t\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(!ok) continue;\n\t\t\t\tdouble dist = abs(us[i] - us[j]);\n\t\t\t\tdp[j][i] = dp[i][j] = dist;\n\t\t\t}\n\t\t}\n\n\t\tint a = (int)us.size();\n\t\tFOR(k,a) FOR(i,a) FOR(j,a) dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);\n\n\t\tprintf(\"%.10lf\\n\",dp[0][a - 1]);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define INF 2147483647\nusing namespace std;\ntypedef complex<double> xy_t;\n\nclass vertex\n{\npublic:\n  int n;\n  double d;\n  vertex()\n  {\n    n=-1;\n    d=0;\n  }\n  vertex(int v,double dis)\n  {\n    n=v;\n    d=dis;\n  }\n  bool operator<(const vertex b) const\n  {\n    return (fabs(d-b.d)>0.00001 && d<b.d);\n  }\n};\nclass edge\n{\npublic:\n  int vt;\n  double d;\n  edge()\n  {\n    vt=-1;\n    d=0;\n  }\n  edge(int v,double dis)\n  {\n    vt=v;\n    d=dis;\n  }\n  /*bool operator<(const vertex b) const\n  {\n    return (fabs(d-b.d)>0.00001 && d<b.d)\n  }*/\n};\n\n\n\nclass circle\n{\npublic:\n  xy_t center;\n  int r;\n  circle()\n  {\n    center=xy_t(0,0);\n    r=0;\n  }\n  circle(int x, int y, int rad)\n  {\n    center=xy_t(x,y);\n    r=rad;\n  }\n};\npriority_queue<vertex> Q;\nvector<edge> E[202];\nint n;\ncircle circles[101];\nxy_t intercept[202];\ndouble dist[202];\n\nxy_t cross(circle C_1,circle C_2,bool p)\n{\n  int a=C_1.center.real();\n  int b=C_1.center.imag();\n  int r=C_1.r;\n  int c=C_2.center.real();\n  int d=C_2.center.imag();\n  int R=C_2.r;\n  int A=2*(a-c);\n  int B=2*(b-d);\n  int C=R*R-r*r+a*a+b*b-c*c-d*d;\n  double x,y;\n  if (B==0)\n  {\n    x=1.0l*C/(1.0l*A);\n    double BB=-2*b;\n    double CC=b*b-r*r+x*x-2*a*x+a*a;\n    double delta=BB*BB-4*CC;\n    if (p==true)\n      y=(-BB+sqrt(delta))/(2.0l);\n    else\n      y=(-BB-sqrt(delta))/(2.0l);\n  }\n  else\n  {\n    int AA=A*A+B*B;\n    int BB=-2*A*C-2*a*B*B+2*b*A*B;\n    int CC=-B*B*(r*r-a*a-b*b)-2*b*B*C+C*C;\n    double delta=BB*BB-4*AA*CC;\n    if (p==true)\n      x=(-1.0l*BB+sqrt(delta))/(2.0l*AA);\n    else\n      x=(-1.0l*BB-sqrt(delta))/(2.0l*AA);\n    y=(1.0l*C-1.0l*A*x)/(1.0l*B);\n  }\n  return xy_t(x,y);\n}\nint calc()\n{\n  int count=0;\n  intercept[count++]=circles[0].center;\n  //cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  for(int i=1;i<n;i++)\n  {\n    intercept[count++]=cross(circles[i-1],circles[i],false);\n    //cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n    intercept[count++]=cross(circles[i-1],circles[i],true);\n    //cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  }\n  intercept[count++]=circles[n-1].center;\n  //cout<<intercept[count-1].real()<<','<<intercept[count-1].imag()<<endl;\n  return count;\n}\n\ndouble dis(int i,int j)\n{\n  return abs(intercept[i]-intercept[j]);\n}\n\ndouble cross_product(xy_t a,xy_t b)\n{\n  return (conj(a)*b).imag();\n}\n\nbool isleft(int a, int b, int c)\n{\n  xy_t a1=intercept[b]-intercept[a];\n  xy_t a2=intercept[c]-intercept[b];\n  return cross_product(a1,a2)>0;\n}\n\nbool iszero(int a, int b, int c)\n{\n  xy_t a1=intercept[b]-intercept[a];\n  xy_t a2=intercept[c]-intercept[b];\n  return abs(cross_product(a1,a2))<0.00001;\n}\n\nbool legal(int i,int j)\n{\n  for(int k=(i+3)/2;k<=(j-1)/2;k++)\n  {\n    if(!iszero(i,2*k,j)&&!iszero(i,2*k-1,j)&&isleft(i,2*k,j)==isleft(i,2*k-1,j))\n      return false;\n  }\n  return true;\n}\nvoid make_edge(int n)\n{\n  for(int i=0;i<n;i++)\n  {\n    E[i].clear();\n    for(int j=i+1;j<n;j++)\n    {\n      if(legal(i,j))\n      {\n        E[i].push_back(edge(j,dis(i,j)));\n        //cout<<i<<\",\"<<j<<\",\"<<dis(i,j)<<endl;\n      }\n    }\n  }\n}\nvoid dijkstra(int nofv)\n{\n  for(int i=0;i<nofv;i++)\n    dist[i]=INF;\n  dist[0]=0;\n  Q.push(vertex(0,dist[0]));\n  while(!Q.empty())\n  {\n    vertex now=Q.top();\n    Q.pop();\n    int nowv=now.n;\n    for(vector<edge>::iterator it=E[nowv].begin();it!=E[nowv].end();++it)\n    {\n      int vt=(*it).vt;double d=(*it).d;\n      if (dist[vt]>dist[nowv]+d)\n      {\n        dist[vt]=dist[nowv]+d;\n        Q.push(vertex(vt,dist[vt]));\n      }\n    }\n  }\n}\nint main()\n{\n  while(1)\n  {\n    cin>>n;\n    if(n==0) break;\n    for(int i=0;i<n;i++)\n    {\n      int x,y,r;\n      cin>>x>>y>>r;\n      circles[i]=circle(x,y,r);\n    }\n    int nofv=calc();\n    make_edge(nofv);\n    dijkstra(nofv);\n    cout<<dist[nofv-1]<<endl;\n  }\n\n  //cout<<cross(circle(0,0,1),circle(1,0,1),0)<<endl;\n  //cout<<cross(circle(0,0,1),circle(1,0,1),1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst int N = 100;\nconst double EPS = 1e-8;\nconst double INF = 1 << 29;\n\nstruct Circle{\n  P c; \n  double r;\n  Circle(P c=P(0,0), double r=0):c(c),r(r){}\n};\n\nstruct state{\n  P p;\n  double d;\n  state(P p=P(0,0), double d=0):p(p),d(d){}\n  bool operator < (const state &s) const {\n    return d < s.d;\n  }\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nP proj(P p, L l){\n  return l.first + dot(p - l.first, l.second - l.first) / norm(l.second - l.first) * (l.second - l.first);\n}\n\nvector<P> getIntersectCS(Circle c, L s){\n  vector<P> res;\n  P h = proj(c.c, s);\n  double d = abs(c.c - h);\n  if(d > c.r + EPS);\n  else if(d > c.r - EPS){\n    if(isIntersectSP(s,h)) res.push_back(h);\n  }\n  else {\n    P v = s.second - s.first;\n    v = (sqrt(c.r*c.r - d*d) / abs(v)) * v;\n    if(isIntersectSP(s, h+v)) res.push_back(h+v);\n    if(isIntersectSP(s, h-v)) res.push_back(h-v);\n  }\n  return res;\n}\n\nvector<P> getIntersectCC(Circle c1, Circle c2){\n  vector<P> res;\n  double r1 = c1.r, r2 = c2.r, d;\n  P p1 = c1.c, p2 = c2.c;\n  d = abs(p1-p2);\n\n  if(d < EPS && abs(r1-r2) < EPS) return res;\n  if(r1 + r2 < d - EPS || d + EPS < abs(r1-r2)) return res;\n\n  double a = (r1*r1 - r2*r2 + d*d) / (2*d);\n  double h = sqrt(max(r1*r1 - a*a, 0.0));\n  P tmp1 = p1 + a / d * (p2-p1);\n  P tmp2 = h / d * (p2-p1);\n\n  if(abs(tmp2) < EPS) res.push_back(tmp1);\n  else {\n    res.push_back(P(real(tmp1) - imag(tmp2), imag(tmp1) + real(tmp2)));\n    res.push_back(P(real(tmp1) + imag(tmp2), imag(tmp1) - real(tmp2)));\n  }\n  return res;\n}\n\n\nint n;\nvector<Circle> v;\n\nbool isOk(P st, P go){\n  vector<state> sv;\n  \n  for(int i=0;i<n;i++){\n    vector<P> res = getIntersectCS(v[i], L(st,go));\n    for(int j=0;j<res.size();j++){\n      if(abs(res[j]-st) <= EPS || abs(res[j]-go) <= EPS) continue;\n      sv.push_back(state(res[j], abs(res[j]-st)));\n    }\n  }\n  sv.push_back(state(st, 0.0));\n  sv.push_back(state(go, abs(st-go)));\n\n  sort(sv.begin(), sv.end());\n\n  for(int i=0;i<sv.size()-1;i++){\n    P mid = (sv[i].p + sv[i+1].p) / 2.0;\n    bool f = true;\n    for(int j=0;j<n;j++){\n      if(abs(mid - v[j].c) <= v[j].r + EPS){\n        f = false;\n        break;\n      }\n    }\n    if(f) return false;\n  }\n  return true;\n}\n\ndouble solve(){\n  double G[N*2+2][N*2+2];\n\n  fill(G[0], G[n*2+2], INF);\n  for(int i=0;i<n*2+2;i++) G[i][i] = 0;\n\n  //??°????????????\n  for(int i=0;i<n-1;i++){\n    vector<P> res = getIntersectCC(v[i],v[i+1]);\n    for(int j=i+1;j<n-1;j++){\n      vector<P> res2 = getIntersectCC(v[j],v[j+1]);\n      for(int k=0;k<res.size();k++){\n        for(int l=0;l<res2.size();l++){\n          if(!isOk(res[k], res2[l])) continue;\n          G[2*i+k][2*j+l] = G[2*j+l][2*i+k] = min(G[2*i+k][2*j+l], abs(res[k] - res2[l]));\n        }\n      }\n    }\n    if(res.size() == 2){\n      G[2*i][2*i+1] = G[2*i+1][2*i] = min(G[2*i][2*i+1], abs(res[0] - res[1]));\n    }\n    for(int j=0;j<res.size();j++){\n      if(isOk(v[0].c, res[j])){\n        G[2*n][2*i+j] = G[2*i+j][2*n] = min(G[2*n][2*i+j], abs(v[0].c - res[j]));\n      }\n      if(isOk(v[n-1].c, res[j])){\n        G[2*n+1][2*i+j] = G[2*i+j][2*n+1] = min(G[2*n+1][2*i+j], abs(v[n-1].c - res[j]));\n      }\n    }\n  }\n  if(isOk(v[0].c, v[n-1].c)){\n    G[2*n][2*n+1] = G[2*n+1][2*n] = min(G[2*n][2*n+1], abs(v[0].c - v[n-1].c));\n  }\n\n  //???????????£???????????????\n  for(int k=0;k<2*n+2;k++){\n    for(int i=0;i<2*n+2;i++){\n      for(int j=0;j<2*n+2;j++){\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n      }\n    }\n  }\n\n  return G[2*n][2*n+1];\n}\n\nint main(){\n  while(cin >> n && n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      double x,y,r;\n      cin >> x >> y >> r;\n      v.push_back(Circle(P(x,y),r));\n    }\n    printf(\"%.7f\\n\",solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nbool isCrossed(complex<double> p1, complex<double> p2, complex<double> p3, complex<double> p4) {\n    if ( ((p1.real() - p2.real()) * (p3.imag() - p1.imag()) + (p1.imag() - p2.imag()) * (p1.real() - p3.real())) *\n            ((p1.real() - p2.real()) * (p4.imag() - p1.imag()) + (p1.imag() - p2.imag()) * (p1.real() - p4.real())) > 0)\n        return false;\n    return true;\n}\n\nint main() {\n    int N = 0;\n    while (cin>>N && N) {\n        vector<pair<complex<double>, double> > circles(N);\n        complex<double> centerize;\n        for (int n = 0; n < N; n++) {\n            int x,y,r;\n            cin>>x>>y>>r;\n            if (n == 0) {\n                centerize = complex<double>(x,y);\n                circles[n] = make_pair(complex<double>(0.0, 0.0), (double)r);\n            }\n            circles[n] = make_pair(complex<double>(x,y)-centerize, (double)r);\n        }\n\n        vector<complex<double> > vertices(2 * N);\n        vertices[0] = circles[0].first;\n        vertices[1] = circles[N-1].first;\n        for (int n = 0; n < N-1; n++) {\n            complex<double> v = circles[n+1].first - circles[n].first;\n            double a = atan2(v.imag(), v.real());\n            double theta = acos((norm(v) + circles[n].second*circles[n].second - circles[n+1].second*circles[n+1].second)\n                / (2 * abs(v) * circles[n].second));\n            vertices[2+2*n] = complex<double>(circles[n].second * cos(a+theta), circles[n].second * sin(a+theta)) + circles[n].first;\n            vertices[3+2*n] = complex<double>(circles[n].second * cos(a-theta), circles[n].second * sin(a-theta)) + circles[n].first;\n            /*\n            double a = (v.real()*v.real()+v.imag()*v.imag()+circles[n].second*circles[n].second-circles[n+1].second*circles[n+1].second) / 2.0;\n            double x1 = ( a*v.real() + v.imag()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double y1 = ( a*v.imag() - v.real()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double x2 = ( a*v.real() - v.imag()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double y2 = ( a*v.imag() + v.real()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            vertices[2+2*n] = complex<double>(x1,y1);\n            vertices[3+2*n] = complex<double>(x2,y2);*/\n        }\n\n        multimap<int, pair<int, double> > ds;\n        for (int n = 0; n < N; n++) {\n            for (int s = 0; s < 2; s++) {\n                for (int i = n+1; i < N+1; i++) {\n                    for (int t = 0; t < 2; t++) {\n                        if (i != N) {\n                            bool flag = true;\n                            for (int u = n+1; u < i; u++) {\n                                if (!(isCrossed(vertices[2*n+s], vertices[2*i+t], vertices[2*u], vertices[2*u+1]) &&\n                                        isCrossed(vertices[2*u], vertices[2*u+1], vertices[2*n+s], vertices[2*i+t]))) {\n                                    flag = false;\n                                    break;\n                                }\n                            }\n                            if (flag) ds.insert(make_pair(2*n+s, make_pair(2*i+t, (double)abs(vertices[2*i+t] - vertices[2*n+s]))));\n                        } else {\n                            bool flag = true;\n                            for (int u = n+1; u < i; u++) {\n                                if (!(isCrossed(vertices[2*n+s], vertices[1], vertices[2*u], vertices[2*u+1]) &&\n                                        isCrossed(vertices[2*u], vertices[2*u+1], vertices[2*n+s], vertices[1]))) {\n                                    flag = false;\n                                    break;\n                                }\n                            }\n                            if (flag) ds.insert(make_pair(2*n+s, make_pair(1, (double)abs(vertices[1] - vertices[2*n+s]))));\n                            break;\n                        }\n                    }\n                }\n                if (n == 0) break;\n            }\n        }\n\n        priority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > pqueue;\n        double finalDs[1000] = {};\n        for (int n = 0; n < N; n++) {\n            finalDs[2*n] = -1.0;\n            finalDs[2*n+1] = -1.0;\n        }\n\n        pqueue.push(make_pair(0.0, 0));\n        while (!pqueue.empty()) {\n            auto p = pqueue.top();\n            pqueue.pop();\n            if (finalDs[p.second] < 0.0) finalDs[p.second] = p.first;\n            else continue;\n\n            auto it = ds.lower_bound(p.second);\n            auto last = ds.upper_bound(p.second);\n            for (; it != last; it++) {\n                pqueue.push(make_pair(p.first+it->second.second, it->second.first));\n            }\n        }\n        cout<<fixed<<finalDs[1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define X(r) real((r))\n#define Y(r) imag((r))\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n\n//?????¨????????????????±???????\nvector<point> crossPoint(const C& a, const C& b){\n\tdouble d = abs(b.p-a.p);\n\tdouble arg = atan2(Y(b.p-a.p), X(b.p-a.p));\n\tdouble arg2 = acos((d*d+a.r*a.r-b.r*b.r)/(2*d*a.r));\n\tif(abs(arg2)<EPS) return {a.r*complex<double>(cos(arg), sin(arg))+a.p};\n\tif(abs(a.r-b.r)<d && d < a.r+b.r) return {a.r*complex<double>(cos(arg+arg2), sin(arg+arg2))+a.p, a.r*complex<double>(cos(arg-arg2), sin(arg-arg2))+a.p};\n\treturn {};\n}\nstruct Edge{\n\tint to;\n\tdouble cost;\n};\n\ndouble dist[100010];\nvector<Edge> es[100010];\n\nint main(){\n\tint n;\n\twhile(cin>>n && n){\n\t\tvector<C> c;\n\t\trep(i, n){\n\t\t\tdouble x, y, r;\n\t\t\tcin>>x>>y>>r;\n\t\t\tc.pb(C({x, y}, r));\n\t\t}\n\t\tvector<vector<P> > v;\n\t\tfor(int i = 0; i < n-1; i++) v.pb(crossPoint(c[i], c[i+1]));\n\t\trep(i, 100010) dist[i] = 1e18, es[i].clear();\n\t\tdist[0] = 0.0;\n\t\tint goal=n*2-1;\n\n\t\tfor(int i = -1; i <= (int)v.size(); i++) {\n\t\t\tvector<point> ps;\n\t\t\tint now;\n\t\t\tif(i == -1) ps.pb(c[0].p), now = 0;\n\t\t\telse if(i == v.size()) ps.pb(c.back().p), now = goal;\n\t\t\telse ps = v[i], now = i*2+1;\n\t\t\tfor(auto&p:ps){\n\t\t\t\tfor(int k = -1; k <= (int)v.size(); k++){\n\t\t\t\t\tif(k == i) continue;\n\t\t\t\t\tvector<point> ps2;\n\t\t\t\t\tint nxt;\n\t\t\t\t\tif(k == -1) ps2.pb(c[0].p), nxt = 0;\n\t\t\t\t\telse if(k == v.size()) ps2.pb(c.back().p), nxt = goal;\n\t\t\t\t\telse ps2 = v[k], nxt = k*2+1;\n\t\t\t\t\tfor(auto& p2 : ps2){\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor(int l = (k < i ? k+1 : i+1); l < (k < i ? i:k); l++){\n\t\t\t\t\t\t\tif(!intersectSS({p, p2}, {v[l][0], v[l][1]})) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(f) {\n\t\t\t\t\t\t\tes[now].pb({nxt, abs(p - p2)});\n\t\t\t\t\t\t\t//es[nxt].pb({now, abs(p - p2)});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnxt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t\tauto dijkstra = [&](){\n\t\t\ttypedef pair<double, int> PP;\n\t\t\tpriority_queue<PP, vector<PP>, greater<PP> > q;\n\t\t\tPP p;\n\t\t\tq.push({0.0, 0});\n\t\t\twhile(!q.empty()){\n\t\t\t\tp = q.top();\tq.pop();\n\t\t\t\tint from = p.se;\n\t\t\t\tdouble cost = p.fi;\n\t\t\t\tif(dist[from] < cost - EPS) continue;\n\t\t\t\tfor(auto& e : es[from]) {\n\t\t\t\t\tint to = e.to;\n\t\t\t\t\tdouble newCost = cost+e.cost;\n\t\t\t\t\tif(dist[to] > newCost + EPS) {\n\t\t\t\t\t\tdist[to] = newCost;\n\t\t\t\t\t\tq.push({dist[to], to});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdijkstra();\n\t\tprintf(\"%.15lf\\n\", dist[goal]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\nusing Real = double;\nconst Real PI = acos(-1);\n\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar((Real)1.0, theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n            B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nconst int COUNTER_CLOCKWISE = 1,\n        CLOCKWISE = -1,\n        ONLINE_BACK = 2,\n        ONLINE_FRONT = -2,\n        ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n                 distance(s2, s1.a), distance(s2, s1.b) });\n}\n\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n            B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<Point> p(n);\n        vector<double> r(n);\n        REP(i, n) {\n            double x, y; cin >> x >> y >> r[i];\n            p[i] = { x, y };\n        }\n\n        vector<array<Point,2>> s(n-1);\n        REP(i, n-1) {\n            double d = abs(p[i+1] - p[i]);\n            double a = acos((r[i]*r[i] + d*d - r[i+1]*r[i+1]) / (2 * r[i] * d));\n            double t = arg(p[i+1] - p[i]);\n            s[i] = { p[i] + polar(r[i], t + a),\n                     p[i] + polar(r[i], t - a)};\n        }\n\n        vector<double> dist(2*n, 1e9);\n\n        REP(i, n-1) {\n            REP(k, 2) {\n                bool valid = true;\n                REP(j, i) {\n                    if (!intersected(\n                            Segment{s[j][0],s[j][1]},\n                            Segment{p[0], s[i][k]})) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    chmin(dist[2 * i + k], abs(s[i][k] - p[0]));\n                }\n            }\n        }\n\n        REP(i, n-1) {\n            REP(ik, 2) {\n                FOR(j, i+1, n-1) {\n                    REP(jk, 2) {\n                        bool valid = true;\n                        FOR(l, i+1, j) {\n                            if (!intersected(\n                                    Segment{ s[l][0], s[l][1] },\n                                    Segment{ s[i][ik], s[j][jk] }\n                                    )) {\n                                valid = false;\n                                break;\n                            }\n                        }\n                        if (valid) {\n                            chmin(dist[2 * j + jk], dist[2 * i + ik] + abs(s[i][ik] - s[j][jk]));\n                        }\n                    }\n                }\n            }\n        }\n\n        REP(i, n-1) {\n            REP(k, 2) {\n                bool valid = true;\n                FOR(j, i+1, n-1) {\n                    if (!intersected(\n                            Segment{s[j][0],s[j][1]},\n                            Segment{p[n-1], s[i][k]})) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    chmin(dist[2 * n - 1], dist[2 * i + k] + abs(s[i][k] - p[n-1]));\n                }\n            }\n        }\n\n        bool valid = true;\n        REP(i, n-1) {\n            if (!intersected(\n                    Segment{s[i][0], s[i][1]},\n                    Segment{p[0], p[n - 1]}\n            )) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) {\n            chmin(dist[2 * n - 1], abs(p[0] - p[n-1]));\n        }\n\n        cout << dist[2 * n - 1] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r;\n\tC() {}\n\tC(P pp, D rr) : p(pp), r(rr) {}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn abs(res)/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tif (ps.size()==1) return ps;\n\t\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// 凸多角形を直線で切断し、左側を残す\nG convex_cut(G g, L l)\n{\n\tG res;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(l.a, l.b, a) != RIGHT) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) res.push_back(cLL(L(a, b), l));\n\t}\n\treturn res;\n}\n\n/** Problem1183 : Chain-Confined Path **/\nconst int MAX_V = 110;\n\nD cost[MAX_V][MAX_V];\n\n\nvector<C> list;\nvector<vector<P> > cp;\nint N;\n\nvoid check(P sp, P tp, int si, int ti, int id1, int id2)\n{\n\tbool ok=true;\n\t\n\tL l(sp, tp);\n\tfor (int i = si; i<ti; i++) {\n\t\tL m(cp[i][0], cp[i][1]);\n\t\tif (!iSS(l, m)) {\n\t\t\tok = false;\n\t\t}\n\t}\n\t\n\tif (ok) {\n\t\tcost[id1][id2] = cost[id2][id1] = abs(sp-tp);\n\t}\n}\n\nint main()\n{\n\twhile (cin>>N, N) {\n\t\tlist.clear();\n\t\tcp.clear();\n\t\t\n\t\tfill(cost[0], cost[0]+MAX_V*MAX_V, INF);\n\t\t\n\t\tlist.resize(N);\n\t\trep(i, N) {\n\t\t\tcin>>list[i].p.X>>list[i].p.Y>>list[i].r;\n\t\t}\n\t\t\n\t\tcp.resize(N+1);\n\t\tcp[0].push_back(list[0].p);\n\t\tcp[0].push_back(list[0].p);\n\t\tcp[N].push_back(list[N-1].p);\n\t\tcp[N].push_back(list[N-1].p);\n\t\t\n\t\tfor (int i=1; i<N; i++) {\n\t\t\tcp[i] = cCC(list[i], list[i-1]);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<N+1; i++) {\n\t\t\tfor (int j=i+1; j<N+1; j++) {\n\t\t\t\tcheck(cp[i][0], cp[j][0], i+1, j, 2*i, 2*j);\n\t\t\t\tcheck(cp[i][0], cp[j][1], i+1, j, 2*i, 2*j+1);\n\t\t\t\tcheck(cp[i][1], cp[j][0], i+1, j, 2*i+1, 2*j);\n\t\t\t\tcheck(cp[i][1], cp[j][1], i+1, j, 2*i+1, 2*j+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0; k<2*(N+1); k++) {\n\t\t\tfor (int i=0; i<2*(N+1); i++) {\n\t\t\t\tfor (int j=0; j<2*(N+1); j++) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << fixed << setprecision(15);\n\t\tcout << cost[0][2*(N+1)-1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max()/2;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\ntypedef pair<ld,ld> P;\n\nconst ld eps = 1e-12, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c : counter-clockwise\n\tif (cross(b, c) < -eps) return -1; // a,b,c : clockwise\n\tif (dot(b, c) < 0) return 2;       // c,a,b : on a line\n\tif (norm(b) < norm(c)) return -2;  // a,b,c : on a line\n\treturn 0;                          // a,c,b : on a line\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nstruct Edge{\n    int to;\n    ld cost;\n    Edge(int to,ld cost): to(to), cost(cost){}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool operator < (const Edge &e, const Edge &f){\n    return e.cost > f.cost;\n}\n\nld dijkstra(const Graph &g, int s){\n    vector<ld> d(g.size(),INF);\n    vector<int> p(g.size(),-1);\n    d[s] = 0;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(P(0,s)); // P(dis, pos)\n    while(!que.empty()){\n        ld dist = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if(d[v]<dist) continue;\n        for(const auto &e: g[v]){\n            if(d[e.to]<=d[v]+e.cost) continue;\n            d[e.to] = d[v] + e.cost;\n            que.push(P(d[e.to], e.to));\n            p[e.to]=v;\n        }\n    }\n    int tmpp=g.size()-1;\n    vector<int> path;\n    while(tmpp!=-1){\n        path.push_back(tmpp);\n        tmpp=p[tmpp];\n    }\n    reverse(path.begin(),path.end());\n    //for(int i=0;i<path.size();++i)cout<<path[i]<<\" \";\n    //cout<<endl;\n    return d[g.size()-1];\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    while(cin>>n,n){\n        vector<Circle> c;\n        for(int i=0;i<n;i++){\n            ld x,y,r;cin>>x>>y>>r;\n            c.push_back(Circle(Point(x,y),r));\n        }\n        Point st=c[0].p, gt=c[n-1].p;\n        vector<Point> ps;\n        vector<Line> ls;\n        ps.push_back(st);\n        for(int i=1;i<n;i++){\n            vector<Point> res=is_cc(c[i],c[i-1]);\n            ps.push_back(res[0]);\n            ps.push_back(res[1]);\n            ls.push_back(Line(res[0],res[1]));\n        }\n        ps.push_back(gt);\n        \n        int sz=ps.size();\n        vector<vector<ld>> dis(sz,vector<ld>(sz,INF));\n        Graph g(sz);\n        for(int i=0;i<sz;i++) dis[i][i]=0;\n\n        // st->mid\n        for(int i=1;i<sz-1;i++){\n            int idx=(i+1)/2;\n            ld d=abs(st-ps[i]);\n            bool ftmp=true;\n            for(int j=0;j<idx-1;j++){\n                if(isis_ss(ls[j],Line(st,ps[i]))) continue;\n                ftmp=false;\n            }\n            if(ftmp){\n                dis[0][i]=dis[i][0]=d;\n                g[0].push_back(Edge(i,d));\n                g[i].push_back(Edge(0,d));\n            }\n        }\n        // st->gt\n        bool f=true;\n        for(int i=0;i<(int)ls.size();i++){\n            if(isis_ss(ls[i],Line(st,gt))) continue;\n            f=false;\n        }\n        if(f){\n            dis[0][sz-1]=dis[sz-1][0]=abs(st-gt);\n            g[0].push_back(Edge(sz-1,abs(st-gt)));\n            g[sz-1].push_back(Edge(0,abs(st-gt)));\n        }\n\n        // mid->mid\n        for(int i=1;i<sz-1;i++){\n            int idx=(i+1)/2;\n            for(int j=i+1;j<sz-1;j++){\n                int jdx=(j+1)/2;\n                if(idx==jdx){\n                    dis[i][j]=dis[j][i]=abs(ps[i]-ps[j]);\n                    g[i].push_back(Edge(j,abs(ps[i]-ps[j])));\n                    g[j].push_back(Edge(i,abs(ps[i]-ps[j])));\n                    continue;\n                }\n                ld d=abs(ps[i]-ps[j]);\n                bool ftmp=true;\n                for(int k=idx;k<jdx-1;k++){\n                    if(isis_ss(ls[k],Line(ps[i],ps[j]))) continue;\n                    ftmp=false;\n                }\n                if(ftmp){\n                    dis[i][j]=dis[j][i]=d;\n                    g[i].push_back(Edge(j,d));\n                    g[j].push_back(Edge(i,d));\n                }\n            }\n        }\n        // mid->gt\n        for(int i=1;i<sz-1;i++){\n            int idx=(i+1)/2;\n            ld d=abs(ps[i]-gt);\n            bool ftmp=true;\n            for(int j=idx;j<(int)ls.size();j++){\n                if(isis_ss(ls[j],Line(ps[i],gt))) continue;\n                ftmp=false;\n            }\n            if(ftmp){\n                dis[i][sz-1]=dis[sz-1][i]=d;\n                g[i].push_back(Edge(sz-1,d));\n                g[sz-1].push_back(Edge(i,d));\n            }\n        }\n\n        //cout<<fixed<<setprecision(10)<<dis[1][10]<<endl;\n        for(int k=0;k<sz;k++){\n            for(int i=0;i<sz;i++){\n                for(int j=0;j<sz;j++){\n                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n                }\n            }\n        }\n        //cout<<fixed<<setprecision(10)<<dis[0][sz-1]<<endl;\n        cout<<fixed<<setprecision(10)<<dijkstra(g,0)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\n\tPoint operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n\tPoint operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n\tPoint operator*(const double m) const { return Point(x*m, y*m); }\n\n\tPoint operator/(const double d) const { return Point(x/d, y/d); }\n\n\tbool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n\tdouble dot(const Point &o) const { return x * o.x + y * o.y; }\n\n\tdouble atan() const { return atan2(y, x); }\n\n\tdouble norm() const { return sqrt(dot(*this)); }\n\n\tdouble distance(const Point &o) const { return (o - (*this)).norm(); }\n\n\tdouble area(const Point &a,const Point &b) {\n\t\tPoint p = a - (*this), p2 = b - (*this); \n\t\treturn p.cross(p2);\n\t}\n\n\tdouble area_abs(const Point &a,const Point &b) const {\n\t\tPoint p = a - (*this), p2 = b - (*this);\n\t\treturn fabs(p.cross(p2)) / 2.0;\n\t}\t\n\n\t//線分abが自身に含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b) {\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)  return ((a.x <= x) && (x <= b.x)) || ((a.x >= x) && (x >= b.x));\n\t\telse return ((a.y <= y) && (y <= b.y)) || ((a.y >= y) && (y >= b.y));\n\t}      \n\n\tdouble distance_seg(const Point& a,const Point& b) {\n\t\tif((b-a).dot(*this-a) < EPS) {\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS) {\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n\n\tbool hitPolygon(const Point& a,const Point& b,const Point& c) {\n\t\tdouble t = (b-a).cross(*this-b);\n\t\tdouble t2 = (c-b).cross(*this-c);\n\t\tdouble t3 = (a-c).cross(*this-a);\t\n\n\t\tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n};\n\nistream &operator >> (istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\nostream &operator << (ostream &out, const Point &p) {\n\tcout << \"(\" << p.x << \",\" << p.y << \")\";\n\treturn out;\n}\n\nstruct Seg {\n\tPoint a,b;\n\n\tSeg (Point a, Point b) : a(a),b(b) {}\n\n\tbool isOrthogonal(Seg &s) { return equals((b - a).dot(s.b - s.a),0.0); }\n\n\tbool isParallel(Seg &s) { return equals((b-a).cross(s.b - s.a),0.0); }\n\n\tbool isIntersect(Seg &s) {\n\t\tif(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);\n\t}\n\n\tbool distance(Seg &s) {\n\t\tif((*this).isIntersect(s)) return 0.0;\n\n\t\treturn min(min(a.distance_seg(s.a,s.b),b.distance_seg(s.a,s.b)),min(s.a.distance_seg(a,b),s.b.distance_seg(a,b)));\n\t}\n\n\tPoint getCrossPoint(Seg &s) {\n\t\tPoint p = s.b - s.a;\n\t\tdouble d = abs(p.cross(a-s.a));\n\t\tdouble d2 = abs(p.cross(b-s.a));\n\n\t\tdouble t = d / (d+d2);\n\t\treturn a + (b-a)*t;\n\t}\n\n\tPoint project(Point &p) {\n\t\tPoint base = b - a;\n\t\tdouble t = base.dot(p-a) / base.dot(base);\n\t\treturn a + base * t;\n\t}\n\n\tPoint reflect(Point &p) {\n\t\treturn p + (project(p) - p) * 2.0;\n\t}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\n\tCircle() : p(Point(0,0)), r(0) {}\n\n\tCircle(Point o, double r) : p(o), r(r) {}\n\n\tCircle(double x,double y, double r) : p(Point(x,y)), r(r) {}\n\n\tbool isCircleIn(const Point& o) {\n\t\tPoint res = o-p;\n\t\treturn res.dot(res) < r*r + EPS;\n\t}\n\n\t// 1:外で接する，0:交差なし，-1:内で接する，2:交差，-2:内包\n\tint isIntersect(const Circle& c) {\n\t\tdouble d = (c.p - p).dot(c.p - p);\n\t\tdouble len = (c.r + r) * (c.r + r);\n\n\t\tif(equals(d,len)) return 1;\n\t\tif(d > len) return 0;\n\n\t\tdouble R = fabs(c.r - r) * fabs(c.r - r);\n\t\tif(equals(d,R)) return -1;\n\t\tif(d > R) return 2;\n\t\treturn -2;\n\t}\n\n\tvector<Point> getCrossPoint(const Circle& c) {\n\t\tvector<Point> ret;\n\t\tint ch = isIntersect(c);\n\n\t\tif(ch == 0 || ch == -2) return ret;\n\n\t\tPoint base = c.p - p;\n\t\tdouble len = base.dot(base);\n\t\tdouble t = (r*r - c.r*c.r + len) / (2.0 * len);\n\n\t\tif(ch == 2) {\n\t\t\tPoint n(-base.y,base.x);\n\t\t\tn = n / (n.norm());\n\t\t\tdouble h = sqrt(r * r - t*t*len);\n\n\t\t\tret.push_back(p + (base*t) + (n*h));\n\t\t\tret.push_back(p + (base*t) - (n*h));\n\t\t} else {\n\t\t\tret.push_back(p + (base*t));\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\nstruct edge {\n\tint from,to;\n\tdouble cost;\n\n\tedge(int t,double c) : to(t),cost(c) {}\n\tedge(int f,int t,double c) : from(f),to(t),cost(c) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nvector<edge> G[100 * 100 + 5];\ndouble d[100 * 100 + 5];\n\nvoid dijkstra(int s,int n) {\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfill(d,d+n,INF);\n\n\td[s] = 0;\n\tque.push(P(0,s));\n\n\twhile(que.size()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n && n) {\n\t\trep(i, 100 * 100 + 5) {\n\t\t\tG[i].clear();\n\t\t}\n\n\t\tvector<Circle> v(n);\n\t\trep(i, n) {\n\t\t\tcin >> v[i].p >> v[i].r;\n\t\t}\n\n\t\tvector<Seg> seg;\n\t\trep(i, n - 1) {\n\t\t\tvector<Point> ret = v[i].getCrossPoint(v[i+1]);\n\t\t\tseg.push_back(Seg(ret[0], ret[1]));\n\t\t}\n\n\t\trep(i, n-1) {\n\t\t\tSeg s1(v[0].p, seg[i].a);\n\t\t\tint id = (i+1) * 2;\n\t\t\tbool flag = true;\n\n\t\t\trep(j, i) {\n\t\t\t\tif(s1.isIntersect(seg[j])) continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\n\t\t\tif(flag) {\n\t\t\t\tdouble dist = v[0].p.distance(s1.b);\n\t\t\t\tG[0].push_back(edge(id-1, dist));\n\t\t\t\tG[id-1].push_back(edge(0, dist));\n\t\t\t}\n\n\t\t\tSeg s2(v[0].p, seg[i].b);\n\t\t\tflag = true;\n\t\t\trep(j, i) {\n\t\t\t\tif(s2.isIntersect(seg[j])) continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\t\n\t\t\tif(flag) {\n\t\t\t\tdouble dist = v[0].p.distance(s2.b);\n\t\t\t\tG[0].push_back(edge(id, dist));\n\t\t\t\tG[id].push_back(edge(0, dist));\n\t\t\t}\n\t\t}\n\n\t\trep(i, n-1) {\n\t\t\tbool flag = true;\n\t\t\tint id = (i+1) * 2;\n\n\t\t\tREP(j, i+1, n-1) {\n\t\t\t\tSeg sj1(seg[i].a, seg[j].a);\n\t\t\t\tint nid = (j+1) * 2;\n\t\t\t\tflag = true;\n\t\t\t\tREP(k, i+1, j) {\n\t\t\t\t\tif(sj1.isIntersect(seg[k])) continue;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\n\t\t\t\tif(flag) {\n\t\t\t\t\tdouble dist = seg[i].a.distance(seg[j].a);\n\t\t\t\t\tG[id-1].push_back(edge(nid-1, dist));\n\t\t\t\t\tG[nid-1].push_back(edge(id-1, dist));\n\t\t\t\t}\n\t\t\n\t\t\t\tSeg sj2(seg[i].a, seg[j].b);\n\t\t\t\tflag = true;\n\t\t\t\tREP(k, i+1, j) {\n\t\t\t\t\tif(sj2.isIntersect(seg[k])) continue;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\n\t\t\t\tif(flag) {\n\t\t\t\t\tdouble dist = seg[i].a.distance(seg[j].b);\n\t\t\t\t\tG[id-1].push_back(edge(nid, dist));\n\t\t\t\t\tG[nid].push_back(edge(id-1, dist));\n\t\t\t\t}\n\t\t\n\t\t\t\tSeg sj3(seg[i].b, seg[j].a);\n\t\t\t\tflag = true;\n\t\t\t\tREP(k, i+1, j) {\n\t\t\t\t\tif(sj3.isIntersect(seg[k])) continue;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\n\t\t\t\tif(flag) {\n\t\t\t\t\tdouble dist = seg[i].b.distance(seg[j].a);\n\t\t\t\t\tG[id].push_back(edge(nid-1, dist));\n\t\t\t\t\tG[nid-1].push_back(edge(id, dist));\n\t\t\t\t}\n\t\t\n\t\t\t\tSeg sj4(seg[i].b, seg[j].b);\n\t\t\t\tflag = true;\n\t\t\t\tREP(k, i+1, j) {\n\t\t\t\t\tif(sj4.isIntersect(seg[k])) continue;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\n\t\t\t\tif(flag) {\n\t\t\t\t\tdouble dist = seg[i].b.distance(seg[j].b);\n\t\t\t\t\tG[id].push_back(edge(nid, dist));\n\t\t\t\t\tG[nid].push_back(edge(id, dist));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}\n\n\t\trep(i, n-1) {\n\t\t\tSeg s3(seg[i].a, v[n-1].p);\n\t\t\tbool flag = true;\n\t\t\tint id = (i+1) * 2;\n\n\t\t\tREP(j, i+1, n-1) {\n\t\t\t\tif(s3.isIntersect(seg[j])) continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\n\t\t\tif(flag) {\n\t\t\t\tdouble dist = seg[i].a.distance(v[n-1].p);\n\t\t\t\tG[n*2-1].push_back(edge(id-1, dist));\n\t\t\t\tG[id-1].push_back(edge(n*2-1, dist));\n\t\t\t}\n\n\t\t\tSeg s4(seg[i].b, v[n-1].p);\n\t\t\tflag = true;\n\t\t\tREP(j, i+1, n-1) {\n\t\t\t\tif(s4.isIntersect(seg[j])) continue;\n\t\t\t\tflag = false;\n\t\t\t}\n\n\t\t\tif(flag) {\n\t\t\t\tdouble dist = seg[i].b.distance(v[n-1].p);\n\t\t\t\tG[n*2-1].push_back(edge(id, dist));\n\t\t\t\tG[id].push_back(edge(n*2-1, dist));\n\t\t\t}\n\t\t}\n\n\t\tSeg s(v[0].p, v[n-1].p);\n\t\tbool flag = true;\n\t\trep(i, n-1) {\n\t\t\tif(s.isIntersect(seg[i])) continue;\n\t\t\tflag = false;\n\t\t}\n\n\t\tif(flag) {\n\t\t\tdouble dist = v[0].p.distance(v[n-1].p);\n\t\t\tG[0].push_back(edge(n*2-1, dist));\n\t\t\tG[n*2-1].push_back(edge(0, dist));\n\t\t}\n\n\t\tdijkstra(0, n*2);\n\n\t\tcout << fixed;\n\t\tcout.precision(10);\n\n\t\tcout << d[n*2-1] << endl;\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\ntypedef vector<Point> Polygon;\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint c;\n\t\tdouble r;\n\t\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n\treturn isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n\treturn isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n\treturn isPointOnLine(s.p1, s.p2, c);\n}\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n\treturn distanceLPoint(s.p1, s.p2, c);\n}\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n\treturn distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n\treturn intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n\treturn isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n\treturn intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//点の内包\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i,n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n\t\tif( a.imag() > b.imag() ) swap(a, b);\n\t\tif( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n\t}\n\treturn ( x ? IN : OUT );\n}\n\n//弧度法から度数法の変換\ndouble radianToDegree(double rad){\n\treturn 180 * rad / M_PI;\n}\n\n//度数法から変弧度法の換\ndouble degreeToRadian(double deg){\n\treturn M_PI * deg / 180;\n}\n\n//2つのベクトルからなる角度を求める\ndouble angleOf2Vector(Vector a, Vector b){\n\treturn acos( dot(a,b) / (abs(a) * abs(b)) );\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//凸包\nPolygon convexHull( Polygon s ){\n\tPolygon u;\n\tif( s.size() < 3 ) return s;\n\tsort(s.begin(), s.end());\n\n\trange(i,0,s.size()){\n\t\t//== COUNTER_CLOCKWISEだと内角は180以下（一直線上に並んでいても、頂点として数える）\n\t\t//!= CLOCKWISEだと内角は180未満（一直線上の頂点は数えない）\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\tfor(int i = s.size() - 2; i >= 0; i--){\n\t\t//ここも == と != を変更する\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.emplace_back(s[i]);\n\t}\n\n\treverse(u.begin(), u.end());\n\tu.pop_back();\n\n\t//最も下にある点の中で最も右にある点から反時計回りに並び替え\n\t/*\n\t   int i = 0;\n\t   while(i < u.size() - 1){\n\t   if(u[i].imag() > u[i + 1].imag()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n\t   u.emplace_back(u[i]);\n\t   u.erase(u.begin());\n\t   continue;\n\t   }\n\t   break;\n\t   }\n\t   */\n\n\treturn u;\n}\n\n//キャリパー法を用いて凸多角形の直径を求める\ndouble diameterOfConvexPolygon(Polygon p){\n\tPolygon s = convexHull(p);\n\tint n = s.size();\n\n\tif(n == 2) return abs(s[1] - s[0]);\n\n\tint i = 0, j = 0;\n\trep(k,n){\n\t\tif(not (s[i] < s[k])) i = k;\n\t\tif(s[j] < s[k]) j = k;\n\t}\n\n\tdouble ret = 0.0;\n\tint is = i, js = j;\n\n\twhile(i != js || j != is){\n\t\tret = max(ret, abs(s[i] - s[j]));\n\t\tif(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n\t\t\ti = (i + 1) % n;\n\t\t}else{\n\t\t\tj = (j + 1) % n;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//凸多角形の切り取りに使う関数。これがなんなのかはまだ知らない。\nPoint getCrossPointLL(Line a, Line b){\n\tdouble A = cross(a.p2 - a.p1, b.p2 - b.p1);\n\tdouble B = cross(a.p2 - a.p1, a.p2 - b.p1);\n\tif(abs(A) < EPS && abs(B) < EPS) return b.p1;\n\treturn b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\trep(i,p.size()){\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tq.emplace_back(getCrossPointLL(Line{a, b}, l));\n\t\t}\n\t}\n\treturn q;\n}\n\n//三角形の面積\ndouble AreaOfTriangle(Point a, Point b, Point c){\n\tdouble w, x, y, z;\n\tw = b.real()-a.real();\n\tx = b.imag()-a.imag();\n\ty = c.real()-a.real();\n\tz = c.imag()-a.imag();\n\treturn abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n\tint n = g.size();\n\tdouble ret = 0.0;\n\trep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n\treturn abs(ret) / 2.0;\n}\n\n//凸多角形かどうかの判定\nbool isConvex(Polygon g){\n\tint n = g.size();\n\trep(i,n){\n\t\tif(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n\t}\n\treturn true;\n}\n\n//凹多角形を線分lで切断した際の多角形の数\nint dividedPolygonNumber(Polygon p, Line l){\n\tint cnt = 0;\n\trep(i,p.size()){\n\t\tif(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n\t}\n\treturn cnt / 2 + 1;\n}\n\n//多角形が点対象となる点の座標\nPoint pointSymmetry(Polygon g){\n\tint size = g.size() / 2;\n\tif(g.size() % 2) return Point{INF,INF};\n\n\tset<Point> s;\n\trep(i,size){\n\t\trep(j,size){\n\t\t\tif(i == j) continue;\n\t\t\ts.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n\t\t}\n\t}\n\tif(s.size() > 1) return Point{INF,INF};\n\treturn *s.begin();\n}\n\nbool isConnected(vector<Segment>& seg, int a, int b, Point p1, Point p2){\n\tSegment e = Segment{p1,p2};\n\trange(i,a,b){\n\t\tif(not isIntersectedLs(seg[i], e)) return false;\n\t}\n\treturn true;\n}\n\nstruct Edge{\n\tint to;\n\tdouble cost;\n\tEdge(int to, double cost) : to(to), cost(cost) {}\n};\n\nstruct Node{\n\tdouble dis;\n\tbool used;\n\tNode() : dis(INF), used(false) { }\n\tNode(double d, bool f) : dis(d), used(f) { }\n};\n\ntypedef vector<vector<Edge>> graph;\n\ndouble dijkstra(graph g, int s, int n){\n\tvector<Node> node(n);\n\tpriority_queue<pair<double,int>, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n\tq.push(make_pair(0, s));\n\tnode[s] = Node{0, true};\n\n\twhile(not q.empty()){\n\t\tdouble dis;\n\t\tint pos;\n\t\ttie(dis, pos) = q.top(); q.pop();\n\t\tnode[pos].used = true;\n\n\t\tfor(auto e : g[pos]){\n\t\t\tif(node[e.to].used == true) continue;\n\t\t\tif(node[e.to].dis > dis + e.cost){\n\t\t\t\tnode[e.to].dis = dis + e.cost;\n\t\t\t\tq.emplace(node[e.to].dis, e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn node[n - 1].dis;\n}\n\nvoid addEdge(graph& g, int a, int b, double dis){\n\t//cout << a << ' ' << b << ' ' << dis << endl;\n\tg[a].emplace_back(Edge{b,dis});\n\tg[b].emplace_back(Edge{a,dis});\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\n\t\tvector<Circle> c(n);\n\t\trep(i,n){\n\t\t\tdouble x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tc[i] = Circle{Point{x,y}, r};\n\t\t}\n\n\t\tint s = n - 1;\n\t\tvector<pair<Point,Point>> cr(s);\n\t\tvector<Segment> seg(s);\n\t\trep(i,s){\n\t\t\tcr[i] = getCrossPoints(c[i], c[i + 1]);\n\t\t\tseg[i] = Segment{cr[i].first, cr[i].second};\n\t\t}\n\n\t\tgraph g(s * 2 + 2);\n\t\trep(i,s){\n\t\t\trange(j,i + 1,s){\n\t\t\t\tif(isConnected(seg, i, j, seg[i].p1, seg[j].p1)) addEdge(g, i, j, abs(seg[i].p1 - seg[j].p1));\n\t\t\t\tif(isConnected(seg, i, j, seg[i].p1, seg[j].p2)) addEdge(g, i, j + s, abs(seg[i].p1 - seg[j].p2));\n\t\t\t\tif(isConnected(seg, i, j, seg[i].p2, seg[j].p1)) addEdge(g, i + s, j, abs(seg[i].p2 - seg[j].p1));\n\t\t\t\tif(isConnected(seg, i, j, seg[i].p2, seg[j].p2)) addEdge(g, i + s, j + s, abs(seg[i].p2 - seg[j].p2));\n\t\t\t}\n\t\t}\n\n\t\trep(i,s){\n\t\t\tif(isConnected(seg, 0, i + 1, c[0].c, seg[i].p1)) addEdge(g, s * 2, i, abs(c[0].c - seg[i].p1));\n\t\t\tif(isConnected(seg, 0, i + 1, c[0].c, seg[i].p2)) addEdge(g, s * 2, i + s, abs(c[0].c - seg[i].p2));\n\t\t\tif(isConnected(seg, i, s, c[n - 1].c, seg[i].p1)) addEdge(g, s * 2 + 1, i, abs(c[n - 1].c - seg[i].p1));\n\t\t\tif(isConnected(seg, i, s, c[n - 1].c, seg[i].p2)) addEdge(g, s * 2 + 1, i + s, abs(c[n - 1].c - seg[i].p2));\n\t\t}\n\n\t\tif(isConnected(seg, 0, s, c[0].c, c[n - 1].c)) addEdge(g, s * 2, s * 2 + 1, abs(c[0].c - c[n - 1].c));\n\n\t\tcout << fixed << setprecision(10) << dijkstra(g, s * 2, s * 2 + 2) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n    if( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line \n    return ON;\n}\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) { a = a_; b = b_; }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n};\n// 円の表現\nstruct Circle{\n\t// 円の中心\n\tP p;\n\t// 円の半径\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\tCircle(){}\n\t// 円の面積\n\tdouble get_area() { return r * r * PI; }\n\t// 円周\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t// 2つの円の位置関係\n\t// 2 つの円が離れている => 0\n\t// 2 つの円が外接する   => 1\n\t// 2 つの円が交わる     => 2\n\t// 2 つの円が内接する    => 3 (2つの円が等しいときは内接)\n\t// 円が含まれている       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // 離れている\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // 外接する\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // 内接する\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // 含まれる\n\t\t\treturn 4;\n\t\t}else { // 交わる\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// 2 つの円の交わる点を返す\n\t// 2 つの円が離れている・内包する => 交点は 0 個, (INF_P,INF_P) を返す.\n\t// 2 つの円が外接 or 内接する   => 交点は 1 個, (firstとsecondに同じ値が入る)\n\t// 2 つの円が交わる            => 交点は 2 個.\n\t// 2 つの円は等しい            => 交点は 無限 個, (INF_P,INF_P) を返す.\n\tpair<P,P> intersection(const Circle& c) {\n\t\tdouble d = abs( p - c.p );\n\t\tdouble rc = ( d*d + r*r - c.r*c.r ) / (2.0*d);\n\t\tdouble rs = sqrt( r*r - rc*rc );\n\t\tP diff = (c.p - p) / d;\n\t\treturn pair<P,P> ( p + diff * P(rc, rs) , p + diff * P(rc, -rs) );\n\t}\n};\n\n// 円 i の 交点 p1 から 円 j の交点 p2 まで直線で移動できるかどうかを返す.\nbool is_move(vector<Segment>& vs, int i, int j, P p1, P p2){\n\tSegment s(p1,p2);\n\tfor(int k=i+1 ; k < j ; k++ ){\n\t\tif( !vs[k].is_intersection(s) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// スタート sp から 円 i の交点 p1 まで直線で移動できるかどうか\nbool is_start_to_p(vector<Segment>& vs, P sp, int i, P p1){\n\tSegment s(sp,p1);\n\tfor(int k=0 ; k < i ; k++ ){\n\t\tif( !vs[k].is_intersection(s) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// ゴール gp から 円 i の交点 p1 まで直線で移動できるかどうか\nbool is_goal_to_p(vector<Segment>& vs, P gp, int i, P p1){\n\tSegment s(gp,p1);\n\tfor(int k=vs.size()-1 ; i < k ; k-- ){\n\t\tif( !vs[k].is_intersection(s) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// スタート sp から ゴール gp まで直線で移動できるかどうか\nbool is_start_to_goal(vector<Segment>& vs, P sp, P gp){\n\tSegment s(sp,gp);\n\tfor(int k=0 ; k < vs.size() ; k++ ){\n\t\tif( !vs[k].is_intersection(s) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// グラフの最大の頂点数\nconst int MAX_V = 210;\n// グラフ\ndouble G[MAX_V][MAX_V];\n\n// 初期化\nvoid ini(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t}\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, double cost){\n\tG[u][v] = G[v][u] = cost;\n}\n\n// ワーシャルフロイド法\ndouble warshall_floyd(int V, int s, int g){\n\tfor(int k=0 ; k < V ; k++ ){\n\t\tfor(int i=0 ; i < V ; i++ ){\n\t\t\tfor(int j=0 ; j < V ; j++ ){\n\t\t\t\tG[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\treturn G[s][g];\n}\n\nint main(){\n\tint n;\n\twhile( scanf(\"%d\", &n) , n ){\n\t\tini();\n\t\tP sp, gp;\n\t\tvector<Circle> v(n);\n\t\tvector<Segment> vs;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, r;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &r );\n\t\t\tv[i] = Circle( P(x,y) , r );\n\t\t\tif( i == 0 ) sp = P(x,y);\n\t\t\tif( i == n-1 ) gp = P(x,y);\n\t\t}\n\t\tfor(int i=1 ; i < n ; i++ ){\n\t\t\tpair<P,P> pp = v[i-1].intersection( v[i] );\n\t\t\tvs.push_back( Segment( pp.first , pp.second ) );\n\t\t}\n\t\t\n\t\t// 直線でスタートからゴールに行ける時\n\t\tif( is_start_to_goal(vs, sp, gp) ){\n\t\t\tcout << dist(sp,gp) << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint g = 2 * vs.size() + 1;\n\t\t// 直線で移動できる2点をエッジとしたグラフをつくる\n\t\tfor(int i=0 ; i < vs.size() ; i++ ){\n\t\t\tP p1 = vs[i].a;\n\t\t\tP p2 = vs[i].b;\n\t\t\tint u = 2*i + 1;\n\t\t\tint v = 2*i + 2;\n\t\t\tif( is_start_to_p(vs, sp, i, p1) ){\n\t\t\t\tadd_edge( 0 , u , dist(sp,p1) );\n\t\t\t}\n\t\t\tif( is_start_to_p(vs, sp, i, p2) ){\n\t\t\t\tadd_edge( 0 , v , dist(sp,p2) );\n\t\t\t}\n\t\t\tif( is_goal_to_p(vs, gp, i, p1) ){\n\t\t\t\tadd_edge( g , u , dist(gp,p1) );\n\t\t\t}\n\t\t\tif( is_goal_to_p(vs, gp, i, p2) ){\n\t\t\t\tadd_edge( g , v , dist(gp,p2) );\n\t\t\t}\n\t\t\tfor(int j=i+1 ; j < vs.size() ; j++ ){\n\t\t\t\tP p3 = vs[j].a;\n\t\t\t\tP p4 = vs[j].b;\n\t\t\t\tint u2 = 2*j + 1;\n\t\t\t\tint v2 = 2*j + 2;\n\t\t\t\tif( is_move(vs, i, j, p1, p3) ){\n\t\t\t\t\tadd_edge( u , u2 , dist(p1,p3) );\n\t\t\t\t}\n\t\t\t\tif( is_move(vs, i, j, p1, p4) ){\n\t\t\t\t\tadd_edge( u , v2 , dist(p1,p4) );\n\t\t\t\t}\n\t\t\t\tif( is_move(vs, i, j, p2, p3) ){\n\t\t\t\t\tadd_edge( v , u2 , dist(p2,p3) );\n\t\t\t\t}\n\t\t\t\tif( is_move(vs, i, j, p2, p4) ){\n\t\t\t\t\tadd_edge( v , v2 , dist(p2,p4) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = warshall_floyd( g+1 , 0 , g );\n\t\tprintf(\"%.6f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<complex<double>,complex<double>> pp;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint n;\nint x[200],y[200],r[200];\n\nP ver[1000][2];\n\npp get_2cross_point_of_2circle(double x1,double y1,double r1,double x2,double y2,double r2){\n    P c1(x1,y1),c2(x2,y2);\n    double a =abs(c2 - c1);\n    double b = r1;\n    double c = r2;\n\n    double rc = (a * a + b * b - c * c) / (2.0 * a);\n    double rs = sqrt(b * b - rc * rc);\n    P diff = (c2 - c1) / a;\n\n    pp p;\n    p.first = c1 + diff * rc + (diff * P(0,1) * rs);\n    p.second = c1 + diff * rc + (diff * P(0,-1) * rs);\n\n    return p;\n}\n\nbool judge(P a1,P a2,P b1,P b2){\n    P a = a2 - a1;\n    P c1 = b1 - a1;\n    P c2 = b2 - a1;\n    return (a.real() * c1.imag() - a.imag() * c1.real()) * (a.real() * c2.imag() - a.imag() * c2.real()) <= 0.0;\n}\n\nbool judgecross(P a,P b,int a1,int b1){\n    FOR(i,a1+1,b1)\n        if(!judge(a,b,ver[i][0],ver[i][1]))\n            return false;\n    return true;\n}\n\nbool input(){\n    scanf(\"%d\",&n);\n    if(n == 0)\n        return false;\n    REP(i,n){\n        scanf(\"%d%d%d\",&x[i],&y[i],&r[i]);\n    }\n    return true;\n}\n\ndouble G[1000][1000];\nvoid solve(){\n\n    REP(i,1000)\n        REP(j,1000)\n            G[i][j] = 1000000000.0;\n    REP(i,1000)\n        G[i][i] = 0.0;\n\n    REP(i,n-1){\n        pp p = get_2cross_point_of_2circle(x[i],y[i],r[i],x[i + 1],y[i + 1],r[i + 1]);\n        ver[i][0] = p.first;\n        ver[i][1] = p.second;\n    }\n    REP(i,(n - 1) * 2){\n        FOR(j,i + 1,(n - 1) * 2){\n            int i1 = i / 2;int i2 = i % 2;\n            int j1 = j / 2;int j2 = j % 2;\n            if(!judgecross(ver[i1][i2],ver[j1][j2],i1,j1))\n                continue;\n            G[i][j] = G[j][i] = abs(ver[i1][i2] - ver[j1][j2]);\n        }\n    }\n    P start(x[0],y[0]);\n    REP(i,(n - 1) * 2){\n        int i1 = i / 2;int i2 = i % 2;\n        if(!judgecross(start,ver[i1][i2],-1,i1))\n            continue;\n        G[i][n * 2 - 2]  = G[n * 2 - 2][i] = abs(start - ver[i1][i2]);\n    }\n    P end(x[n-1],y[n-1]);\n    REP(i,(n - 1) * 2){\n        int i1 = i / 2;int i2 = i % 2;\n        if(!judgecross(ver[i1][i2],end,i1,n-1))\n            continue;\n        G[i][n * 2 - 1] = G[n * 2 - 1][i] = abs(end - ver[i1][i2]);\n    }\n    if(judgecross(start,end,-1,n-1))\n        G[n * 2 - 1][n * 2 - 2] = G[n * 2 - 2][n * 2 - 1] = abs(start - end);\n\n    REP(k,n*2){\n        REP(i,n*2){\n            REP(j,n*2){\n                G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n            }\n        }\n    }\n    printf(\"%lf\\n\",G[n*2-2][n*2-1]);\n}\n\n\n\nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-10;\nconst double inf=1e12;\nconst double PI=acos(-1);\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nstruct C{\n  P p;\n  double r;\n  C(const P& p,double r):p(p),r(r){}\n};\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\nbool intersectSS(const L& s,const L& t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\ndouble distanceSP(const L& s,const P& p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\nvoid crosspointCC(const C& c1,const C& c2,P& p1,P& p2){\n  double x1=x(c2.p)-x(c1.p),y1=y(c2.p)-y(c1.p);\n  double r1=c1.r,r2=c2.r;\n  double a=(x1*x1+y1*y1+r1*r1-r2*r2)/2.0;\n  p1=P(((a*x1+y1*sqrt((x1*x1+y1*y1)*r1*r1-a*a))/(x1*x1+y1*y1))+x(c1.p),((a*y1-x1*sqrt((x1*x1+y1*y1)*r1*r1-a*a))/(x1*x1+y1*y1))+y(c1.p));\n  p2=P(((a*x1-y1*sqrt((x1*x1+y1*y1)*r1*r1-a*a))/(x1*x1+y1*y1))+x(c1.p),((a*y1+x1*sqrt((x1*x1+y1*y1)*r1*r1-a*a))/(x1*x1+y1*y1))+y(c1.p));\n}\n\ndouble d[333];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int n;\n    vector<C> cs;\n    vector<P> ps;\n    cin>>n;\n    if(n==0)break;\n    rep(i,n){\n      double x,y,r;\n      cin>>x>>y>>r;\n      cs.pb(C(P(x,y),r));\n    }\n    ps.push_back(cs[0].p);\n    rep(i,n-1){\n      P p1,p2;\n      crosspointCC(cs[i],cs[i+1],p1,p2);\n      ps.push_back(p1);ps.push_back(p2);\n    }\n    ps.push_back(cs[n-1].p);\n    rep(i,333)d[i]=inf;\n    d[0]=0;\n    int m=ps.size();\n    rep(i,m)repl(j,i+i%2+1,m){\n      // i->j\n      bool ok=true;\n      repl(k,(i%2==0?i-1:i),(j%2==0?j:j+1)){\n        if(!intersectSS(L(ps[k],ps[k+1]),L(ps[i],ps[j])))ok=false;\n        k++;\n      }\n      if(ok){\n        minch(d[j],d[i]+abs(ps[i]-ps[j]));\n      }\n    }\n    printf(\"%.10f\\n\", d[m-1]);\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    G to_g() const\n    {\n        G res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nG convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    G res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const G& g)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n    {\n        if (ccw(g[(i - 1 + g.size()) % g.size()], g[i], g[(i + 1) % g.size()]) < 0)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079, AOJ0187\ngtype area(const G& g)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t\ts += cross(g[i], g[(i + 1) % g.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012, AOJ0143\nenum res_contain { OUT, ON, IN };\nres_contain contain_GP(const G& g, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)g.size(); ++i)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (intersect_SP(Line(g[i], g[(i + 1) % g.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n// AOJ0214\n// a contains b?\nbool contain_GG(const G& a, const G& b)\n{\n    rep(i, b.size())\n        if (contain_GP(a, b[i]) == OUT)\n            return false;\n    return true;\n}\n// AOJ0214\nbool intersect_GG(const G& a, const G& b)\n{\n    rep(i, a.size()) rep(j, b.size())\n        if (intersect_SS(Line(a[i], a[(i + 1) % a.size()]), Line(b[j], b[(j + 1) % b.size()])))\n            return true;\n    return contain_GG(a, b) || contain_GG(b, a);\n}\n\n// 円\n\n// AOJ0023(feps = 0)\nenum res_pos_CC\n{\n    not_intersect,\n    intersect,\n\n    tangent,\n\n    a_in_b,\n    b_in_a,\n};\nres_pos_CC pos_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-10;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\n\nbool intersect_GC(const G& g, const Circle& c)\n{\n    for (int i = 0; i < (int)g.size(); ++i)\n        if (dist_SP(Line(g[i], g[(i + 1) % g.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(g, c.p) != OUT;\n}\n\n// AOJ0129\nres_contain contain_CP(const Circle& c, const Point& p)\n{\n    const gtype feps = 1e-9;\n    gtype d = abs(c.p - p);\n    if (d > c.r + feps)\n        return OUT;\n    else if (d < c.r + feps)\n        return IN;\n    else\n        return ON;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    if (pos_CC(a, b) != intersect)\n        return vector<Point>();\n\n    Point ab = b.p - a.p;\n    gtype t = (norm(ab) + a.r*a.r - b.r*b.r) / (2 * abs(ab));\n    Point u = ab / abs(ab);\n    Point q = a.p + t * u;\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - t*t));\n    Point v = Point(0, h) * u;\n\n    vector<Point> res;\n    res.pb(q + v);\n    if (h > feps)\n        res.pb(q - v); // 2点\n    return res;\n}\nvector<Point> ip_CL(const Circle& c, const Line& line)\n{\n    const gtype feps = 1e-9;\n\n    Point p = projection(line, c.p);\n    Point cp = p - c.p;\n    gtype d = abs(cp);\n    if (d > c.r + feps)\n        return vector<Point>();\n\n    gtype t = sqrt(max<gtype>(0, c.r*c.r - d*d));\n    Point u = line.second - line.first;\n    Point v = u / abs(u) * t;\n\n    vector<Point> res;\n    res.pb(p + v);\n    if (t > feps)\n        res.pb(p - v); // 2点\n    return res;\n}\nvector<Point> ip_LC(const Line& line, const Circle& c)\n{\n    return ip_CL(c, line);\n}\nvector<Point> ip_CS(const Circle& c, const Seg& seg)\n{\n    vector<Point> ip = ip_CL(c, seg);\n    vector<Point> res;\n    rep(i, ip.size())\n        if (intersect_SP(seg, ip[i]))\n            res.pb(ip[i]);\n    return res;\n}\nvector<Point> ip_SC(const Seg& seg, const Circle& c)\n{\n    return ip_CS(c, seg);\n}\n\n/////////////////// \nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\n\n\nint n;\nCircle c[111];\nPoint ip[111][2];\nbool reachable(int i, int a, int j, int b)\n{\n    Seg seg(ip[i][a], ip[j][b]);\n    Point vec = seg.second - seg.first;\n    vec *= 1e-2 / abs(vec);\n    rep(w, n)\n    {\n        vector<Point> pp = ip_CS(c[w], seg);\n        foreach (p, pp)\n        {\n            bool ok = false;\n            rep(t, n)\n            {\n                if (contain_CP(c[t], *p + vec))\n                {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok)\n                return false;\n        }\n    }\n    return true;\n}\nint main()\n{\n    while (cin >> n, n)\n    {\n        rep(i, n)\n            cin >> c[i].p >> c[i].r;\n\n        rep(i, 2)\n        {\n            ip[0][i] = c[0].p;\n            ip[n][i] = c[n - 1].p;\n        }        \n        rep(i, n - 1)\n        {\n            vector<Point> t = ip_CC(c[i], c[i + 1]);\n            assert(t.size() == 2);\n            ip[i + 1][0] = t[0], ip[i + 1][1] = t[1];\n        }\n        \n        // erep(i, n) rep(j, 2)\n        // {\n        //     printf(\"%d, %d: \", i, j);\n        //     cout << ip[i][j] << endl;\n        // }\n\n        const double eps = 1e-9;\n        const double inf = 1e9;\n        typedef pair<double, pint> P;\n        priority_queue<P, vector<P>, greater<P> > q;\n        double dp[111][2];\n        erep(i, n) rep(j, 2)\n            dp[i][j] = inf;\n        dp[0][0] = dp[0][1] = 0;\n        q.push(P(0, pint(0, 0)));\n        double res = -1;\n        while (!q.empty())\n        {\n            P t = q.top();\n            q.pop();\n\n            int u = t.second.first, w = t.second.second;\n            double d = t.first;\n            if (d > dp[u][w] + eps)\n                continue;\n            else if (u == n)\n            {\n                res = d;\n                break;\n            }\n\n            for (int v = u; v <= n; ++v) rep(s, 2)\n            {\n                if (reachable(u, w, v, s))\n                {\n                    double nd = d + abs(ip[v][s] - ip[u][w]);\n                    if (nd + eps < dp[v][s])\n                    {\n                        dp[v][s] = nd;\n                        q.push(P(nd, pint(v, s)));\n                    }\n                }\n            }\n        }\n        assert(res >= 0);\n        printf(\"%.6f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <stdio.h>\n#define inf 1e9\n#define eps 1e-9\n\nusing namespace std;\ntypedef pair<double, int> P;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ndouble distPP(vec2d p, vec2d q){\n\treturn (p-q).norm();\n}\n\ndouble distSP(vec2d p, vec2d q, vec2d x)\n{\n\tif((x-p).dot(q-p) <= 0) return distPP(p, x);\n\tif((x-q).dot(p-q) <= 0) return distPP(q, x);\n\treturn fabs( (x-p).cross(q-p) / distPP(p, q) );\n}\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\t\n\t}\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nstruct edge{\n\tint to;\n\tdouble cost;\n\tedge(){}\n\tedge(int a, double b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint n;\nvec2d p[105];\ndouble r[105];\n\nint V;\nvector< pair<vec2d, int> > cp;\nvector<edge> G[205];\ndouble dist[205];\n\nvoid dijkstra()\n{\n\tfor(int i = 0; i < cp.size(); i++) dist[i] = inf;\n\tdist[0] = 0;\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, 0) );\n\t\n\tint v; double d;\n\twhile(Q.size()){\n\t\tv = Q.top().second;\n\t\td = Q.top().first;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> r[i];\n\t\t}\n\t\t\n\t\tcp.clear();\n\t\tcp.push_back( make_pair(p[0], -1) );\n\t\tcp.push_back( make_pair(p[n-1], n) );\n\t\t\n\t\tvec2d l, nl, c1, c2;\n\t\tdouble x, L, h;\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tL = distPP(p[i], p[i+1]);\n\t\t\tx = (L*L + r[i+1]*r[i+1] - r[i]*r[i]) / (2*L);\n\t\t\th = sqrt(r[i+1]*r[i+1] - x*x);\n\t\t\t\n\t\t\tl = p[i+1] - p[i];\n\t\t\tl = l / l.norm();\n\t\t\tnl.x = l.y, nl.y = -l.x;\n\t\t\t\n\t\t\tc1 = p[i] + l*(L-x) + nl*h;\n\t\t\tc2 = p[i] + l*(L-x) - nl*h;\n\t\t\tcp.push_back( make_pair(c1, i) );\n\t\t\tcp.push_back( make_pair(c2, i) );\n\t\t}\n\t\t\n\t\tdouble d;\n\t\tfor(int i = 0; i < cp.size(); i++) G[i].clear();\n\t\tfor(int i = 0; i < cp.size(); i++){\n\t\t\tfor(int j = 0; j < cp.size(); j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tbool flag = true;\n\t\t\t\tint s = min(cp[i].second, cp[j].second);\n\t\t\t\tint t = max(cp[i].second, cp[j].second);\n\t\t\t\tfor(int k = s+1; k <= t-1; k++){\n\t\t\t\t\tif(k < 0 || k >= n-1) continue;\n\t\t\t\t\tif(!isCross(cp[i].first, cp[j].first, cp[2*(k+1)].first, cp[2*(k+1)+1].first)){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag) continue;\n\t\t\t\td = distPP(cp[i].first, cp[j].first);\n\t\t\t\tG[i].push_back( edge(j, d) );\n\t\t\t\tG[j].push_back( edge(i, d) );\n\t\t\t}\n\t\t}\n\t\tdijkstra();\n\t\t\n\t\tprintf(\"%.8f\\n\", dist[1]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\nusing i64 = long long;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\ntemplate<class T> vector<T> vec_in(int n) { vector<T> res(n); for (auto& x : res) cin >> x; return res;}\ntemplate<class T> void print_vec(const vector<T>& v) { for (auto& x : v) cout << x << ' '; cout << endl;}\nusing R = double;\nusing P = complex<R>;\nconst R EPS = 1.0e-7;\nconst R INF = 1.0e18;\nint main() {\n    for (int n; cin >> n && n != 0; ) {\n        vector<P> points(n);\n        vector<R> r(n);\n        for (int i : in(n)) {\n            R a, b, c;\n            cin >> a >> b >> c;\n            points[i] = P(a, b);\n            r[i] = c;\n        }\n        int v_num = 2 * n;\n        int start = v_num - 2, goal = v_num - 1;\n        vector<P> vertex(v_num);\n        vertex[start] = points.front();\n        vertex[goal] = points.back();\n        for (int i : in(n - 1)) {\n            R r1 = r[i], r2 = r[i + 1];\n            P p1to2 = points[i + 1] - points[i];\n            R d = abs(p1to2);\n            P unit = p1to2 / d;\n            R sa = (r1 * r1 - r2 * r2) / d;\n            R a  = (d + sa) / 2.0;\n            R k = sqrt(r1 * r1 - a * a);\n            P unit2(-unit.imag(), unit.real());\n            P cross1 = points[i] + a * unit + k * unit2;\n            P cross2 = points[i] + a * unit - k * unit2;\n            vertex[i] = cross1;\n            vertex[i + 1] = cross2;\n        }\n        struct Edge {\n            int to;\n            R dist;\n            Edge(int a, R d): to(a), dist(d) {}\n        };\n        vector<vector<Edge>> adj(v_num);\n        auto add_edge = [&](int a, int b) {\n            R d = abs(vertex[a] - vertex[b]);\n            adj[a].emplace_back(b, d);\n            adj[b].emplace_back(a, d);\n        };\n        for (int i : in(n - 2)) {\n            int u[2] = {i, i + 1};\n            add_edge(u[0], u[1]);\n            for (int j : in(i + 1, n - 1)) {\n                int v[2] = {j, j + 1};\n                // ????????????????????????????????????\n                for (int p1 : u) {\n                    for (int p2 : v) {\n                        bool ok = true;\n                        for (int k : in(i + 1, j)) {\n                            P c = points[k];\n                            R grad = abs(vertex[p2] - vertex[p1]);\n                            // y + p1.imag() = grad(x + p1.real())\n                            // grad*x - y + grad * p1.real() - p1.imag() = 0\n                            R tmp = grad * c.real() - c.imag() + grad * vertex[p1].real() - vertex[p1].imag();\n                            R d = abs(tmp) / abs(c);\n                            if (d > r[k] + EPS) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                        if(ok) add_edge(p1, p2);\n                    }\n                }\n            }\n            // start??¨?????????\n            for (int k : in(i)) {\n                P c = points[k];\n                \n            }\n        }\n        vector<R> dist(v_num, INF);\n        dist[start] = 0.0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <limits.h>\n#include <float.h>\n#include <queue>\n#include <cstring>\n\n#define eps 10e-5\n#define INF 1e8\n#define M INT_MAX\nusing namespace std;\n\nstruct P{\n\tdouble x;\n\tdouble y;\n\n\tP(){\n\t\tx=M; y=M;\n\t}\n\n\tP(const double &s , const double &e)\n\t\t{ x=s; y=e;}\n\n\tP operator - (const P &t) const\n\t{ return P(x-t.x , y-t.y); }\n\n\tP operator + (const P &t) const\n\t{ return P(x+t.x , y+t.y); }\n\n\tP operator * (const double &d) const\n\t{ return P(x*d , y*d); }\n\n};\n\ndouble dis(P t);\n\nstruct L{\n\tP p1,p2;\n\n\tL(){}\n\n\tL(const P &s , const P &e)\n\t\t{ p1=s; p2=e;}\n\tdouble ldis(){\n\t\treturn dis(p1-p2);\n\t}\n};\n\nstruct C{\n\tP a;\n\tdouble r;\n\tC(){}\n\tC(const P &s , const double &e)\n\t\t{ a=s; r=e;}\n};\n\n//距離を求める\ndouble dis(P t){\n\treturn sqrt(t.x*t.x+t.y*t.y);\n}\n\n//単位ベクトルを求める\nP unit_vector(P t){\n\tdouble u=fabs(dis(t));\n\treturn P(t.x/u , t.y/u);\n}\n\n//外積を求める a×b\ndouble cross(P a,P b){\n\treturn (a.x*b.y-a.y*b.x);\n}\n\n//線分交差判定\nbool intersect_s(P a1 , P a2 , P b1 , P b2){\n\treturn ( cross(a2-a1 , b1-a1)*cross(a2-a1 , b2-a1) < eps) &&\n\t\t   ( cross(b2-b1 , a1-b1)*cross(b2-b1 , a2-b1) < eps);\n}\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nP rotate(P t , P p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn P(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nL interpoint_cc(C a , C b){\n\tdouble di=fabs(dis(a.a-b.a));\n\tif(di > a.r+b.r || di < fabs(a.r-b.r)) return L(P(0, 0), P(0, 0));\n\tdouble t=(a.r*a.r-b.r*b.r+di*di)/(di+di);\n\tdouble rd=acos(t/a.r);\n\n\tP dv=unit_vector(b.a-a.a);\n\tP g1=rotate(dv , P(0,0) , rd);\n\tP g2=rotate(dv , P(0,0) , -rd);\n\treturn L(a.a+g1*a.r, a.a+g2*a.r);\n}\n\nclass State{\npublic:\n\tdouble sum;\n\tint t,s;\n\tP cur;\n\tState(){}\n\tState(double c, int a, int b, P p):sum(c),t(a),s(b),cur(p){}\n\tbool operator < (const State &opp)const{\n\t\treturn sum > opp.sum;\n\t}\n};\n\n\ndouble dp[101][2];\nint v[101][2];\nvector <L> Lines;\n\nbool check(L l, int s, int t){\n\tfor(;s<t;s++) if(!intersect_s(l.p1, l.p2, Lines[s].p1, Lines[s].p2))return 0;\n\treturn 1;\n}\n\nmain(){\n\tint i,j,n;\n\n\twhile(cin>>n, n){\n\t\tpriority_queue<State> S;\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor(i=0;i<=100;i++) dp[i][0] = dp[i][1] = INF;\n\t\tLines.clear();\n\t\tC Prev, Now;\n\t\tcin >> Now.a.x >> Now.a.y >> Now.r;\n\t\tP Start = Now.a;\n\t\tLines.push_back(L(Start, Start));\n\t\tfor(i=1;i<n;i++){\n\t\t\tPrev = Now;\n\t\t\tcin >> Now.a.x >> Now.a.y >> Now.r;\n\t\t\tLines.push_back(interpoint_cc(Now, Prev));\n\t\t}\n\t\tLines.push_back(L(Now.a, Now.a));\n\t\tS.push(State(0, 0, 0, Start));\n\t\twhile(!S.empty()){\n\t\t\tState t = S.top();S.pop();\n\t\t\tif(v[t.t][t.s]) continue;\n\t\t\tv[t.t][t.s] = 1;\n\t\t\tif(t.t == n) break;\n\t\t\tfor(i=t.t+1;i<=n;i++){\n\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\tif(v[i][j]) continue;\n\t\t\t\t\tL l = L(t.cur, (j?Lines[i].p2:Lines[i].p1));\n\t\t\t\t\tif(!check(l, t.t+1, i)) continue;\n\t\t\t\t\tif(dp[i][j] < l.ldis() + t.sum) continue;\n\t\t\t\t\tdp[i][j] = l.ldis() + t.sum;\n\t\t\t\t\tS.push(State(dp[i][j], i, j, l.p2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.4lf\\n\", dp[n][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<C> c(n);\n\t\trep(i, n) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tc[i] = C{ P{(double)x,(double)y},(double)r };\n\t\t}\n\t\tvector<double[2]> dp(n - 1);\n\t\tvector<L> s(n - 1);\n\t\trep(i, n - 1) {\n\t\t\tauto x = is_cc(c[i], c[i + 1]);\n\t\t\ts[i] = { x[0],x[1] };\n\t\t}\n\t\tVP p = { c[n - 1].p };\n\t\trep1(i, n - 2) {\n\t\t\tdp[i][0] = min(dp[i - 1][0] + abs(s[i].a - s[i - 1].a), dp[i - 1][1] + abs(s[i].a - s[i - 1].b));\n\t\t\tdp[i][1] = min(dp[i - 1][0] + abs(s[i].b - s[i - 1].a), dp[i - 1][1] + abs(s[i].b - s[i - 1].b));\n\t\t}\n\t\tint prev = (dp[n - 2][0] < dp[n - 2][1] ? 0 : 1);\n\t\tp.push_back(prev ? s[n - 2].b : s[n - 2].a);\n\t\trrep(i, n - 2) {\n\t\t\tprev = (dp[i][0] + abs(s[i].a - (prev ? s[i + 1].b : s[i + 1].a)) == dp[i + 1][prev] ? 0 : 1);\n\t\t\tp.push_back(prev ? s[i].b : s[i].a);\n\t\t}\n\t\tp.push_back(c[0].p);\n\t\treverse(ALL(p));\n\t\tVP ans = { p[0] };\n\t\trep1(i, n - 1) {\n\t\t\tif (!isis_ls({ ans.back(),p[i + 1] }, s[i - 1]))ans.push_back(p[i]);\n\t\t}\n\t\tans.push_back(p.back());\n\t\tdouble a = 0;\n\t\trep(i, ans.size() - 1)a += abs(ans[i] - ans[i + 1]);\n\t\tcout << a << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nbool isCrossed(complex<double> p1, complex<double> p2, complex<double> p3, complex<double> p4) {\n    if ( ((p1.real() - p2.real()) * (p3.imag() - p1.imag()) + (p1.imag() - p2.imag()) * (p1.real() - p3.real())) *\n            ((p1.real() - p2.real()) * (p4.imag() - p1.imag()) + (p1.imag() - p2.imag()) * (p1.real() - p4.real())) > 0)\n        return false;\n    return true;\n}\n\nint main() {\n    int N = 0;\n    while (cin>>N && N) {\n        vector<pair<complex<double>, double> > circles(N);\n        complex<double> centerize;\n        for (int n = 0; n < N; n++) {\n            int x,y,r;\n            cin>>x>>y>>r;\n            if (n == 0) {\n                centerize = complex<double>(x,y);\n                circles[n] = make_pair(complex<double>(0.0, 0.0), (double)r);\n            }\n            circles[n] = make_pair(complex<double>(x,y)-centerize, (double)r);\n        }\n\n        vector<complex<double> > vertices(2 * N);\n        vertices[0] = circles[0].first;\n        vertices[1] = circles[N-1].first;\n        for (int n = 0; n < N-1; n++) {\n            complex<double> v = circles[n+1].first - circles[n].first;\n            double a = atan2(v.imag(), v.real());\n            double theta = acos((norm(v) + circles[n].second*circles[n].second - circles[n+1].second*circles[n+1].second)\n                / (2 * abs(v) * circles[n].second));\n            vertices[2+2*n] = complex<double>(circles[n].second * cos(a+theta), circles[n].second * sin(a+theta)) + circles[n].first;\n            vertices[3+2*n] = complex<double>(circles[n].second * cos(a-theta), circles[n].second * sin(a-theta)) + circles[n].first;\n            /*\n            double a = (v.real()*v.real()+v.imag()*v.imag()+circles[n].second*circles[n].second-circles[n+1].second*circles[n+1].second) / 2.0;\n            double x1 = ( a*v.real() + v.imag()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double y1 = ( a*v.imag() - v.real()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double x2 = ( a*v.real() - v.imag()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            double y2 = ( a*v.imag() + v.real()*sqrt((v.real()*v.real()+v.imag()*v.imag())*circles[n].second*circles[n].second-a*a) )\n                            / (v.real()*v.real()+v.imag()*v.imag());\n            vertices[2+2*n] = complex<double>(x1,y1);\n            vertices[3+2*n] = complex<double>(x2,y2);*/\n        }\n\n        multimap<int, pair<int, double> > ds;\n        for (int n = 0; n < N; n++) {\n            for (int s = 0; s < 2; s++) {\n                for (int i = n+1; i < N+1; i++) {\n                    for (int t = 0; t < 2; t++) {\n                        if (i != N) {\n                            bool flag = true;\n                            for (int u = n+1; u < i; u++) {\n                                if (!(isCrossed(vertices[2*n+s], vertices[2*i+t], vertices[2*u], vertices[2*u+1]) &&\n                                        isCrossed(vertices[2*u], vertices[2*u+1], vertices[2*n+s], vertices[2*i+t]))) {\n                                    flag = false;\n                                    break;\n                                }\n                            }\n                            if (flag) ds.insert(make_pair(2*n+s, make_pair(2*i+t, (double)abs(vertices[2*i+t] - vertices[2*n+s]))));\n                        } else {\n                            bool flag = true;\n                            for (int u = n+1; u < i; u++) {\n                                if (!(isCrossed(vertices[2*n+s], vertices[1], vertices[2*u], vertices[2*u+1]) &&\n                                        isCrossed(vertices[2*u], vertices[2*u+1], vertices[2*n+s], vertices[1]))) {\n                                    flag = false;\n                                    break;\n                                }\n                            }\n                            if (flag) ds.insert(make_pair(2*n+s, make_pair(1, (double)abs(vertices[1] - vertices[2*n+s]))));\n                            break;\n                        }\n                    }\n                }\n                if (n == 0) break;\n            }\n        }\n\n        priority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > pqueue;\n        double finalDs[1000] = {};\n        for (int n = 0; n < N; n++) {\n            finalDs[2*n] = -1.0;\n            finalDs[2*n+1] = -1.0;\n        }\n\n        pqueue.push(make_pair(0.0, 0));\n        while (!pqueue.empty()) {\n            auto p = pqueue.top();\n            pqueue.pop();\n            if (finalDs[p.second] < 0.0) finalDs[p.second] = p.first;\n            else continue;\n\n            auto it = ds.lower_bound(p.second);\n            auto last = ds.upper_bound(p.second);\n            for (; it != last; it++) {\n                pqueue.push(make_pair(p.first+it->second.second, it->second.first));\n            }\n        }\n        cout<<finalDs[1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nstruct coord {\n\tdouble x, y;\n\tcoord() {}\n\tcoord(double a, double b) {\n\t\tx = a; y = b;\n\t}\n\tbool operator<(const coord & a) const {\n\t\treturn (sqr(x) + sqr(y)) < (a.sqr(x) + sqr(y));\n\t}\n};\n\nstruct circle {\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coord a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coord,coord> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coord,coord> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coord(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coord(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\treturn ret;\n}\n\nbool cross_lseg(coord a_start, coord a_end, coord b_start, coord b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\ndouble distance(coord a, coord b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coord,coord> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coord(v[0].x, v[0].y), coord(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coord,coord> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(pair<coord,coord>(coord(v[v.size() - 1].x, v[v.size() - 1].y), coord(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoord start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoord end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\ntemplate<class T> T at(vector<T> v, int i) {return v[i % v.size()];}\n\n#define X real()\n#define Y imag()\n\ntypedef double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\n// 比較関数\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator==(P a, P b) {return norm(a - b) < EPS;}\n  bool operator<(L a, L b) {return a.a != b.a ? a.a < b.a : a.b < b.b;}\n}\n\nD sr(D a) {return sqrt(max(a, (D)0));}\n\n// 内積\nD dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.b - a.a;}\n\n// 線分abに対する点cの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  if (a == c || b == c) return ON;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\n// 射影\nP proj(P a, P b) {return a * dot(a, b) / norm(a);}\nP perp(L l, P p) {return l.a + proj(vec(l), p - l.a);}\n\n// 距離\nD dLP(L l, P p) {return abs(det(vec(l), p - l.a)) / abs(vec(l));}\nD dSP(L s, P p) {\n  if (dot(vec(s), p - s.a) < 0) return abs(p - s.a);\n  if (dot(vec(s), p - s.b) > 0) return abs(p - s.b);\n  return dLP(s, p);\n}\n\n// 円\nstruct C{P c; D r;};\n\n// 交差判定\nbool iCP(C c, P p) {return sig(abs(p - c.c), c.r) <= 0;}\nbool iCS(C c, L s) {return sig(c.r, dSP(s, c.c)) >= 0;}\nbool iCSc(C c, L s) {return iCS(c, s) && sig(c.r, max(abs(s.a - c.c), abs(s.b - c.c))) <= 0;}\n\n// 交点\npair<P, P> pCC(C a, C b) {\n  D x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  P e = (b.c - a.c) / abs(b.c - a.c);\n  P y = e * P(0, sr(a.r * a.r - x * x));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\npair<P, P> pCL(C c, L l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\n// 線分アレンジメント 隣の点への辺のみを持つ\nvector<vector<int> > sArr(vector<L> s, vector<P> &vp) {\n  //s = merge(s);\n  rep (i, s.size()) {\n    vp.push_back(s[i].a);\n    vp.push_back(s[i].b);\n  }\n  //rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) vp.push_back(pLL(s[i], s[j]));\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end()), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i].a, s[i].b, vp[j]) == ON) {\n      v.push_back(make_pair(norm(vp[j] - s[i].a), j));\n    }\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return g;\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    C c[n];\n    rep (i, n) cin >> c[i].c.X >> c[i].c.Y >> c[i].r;\n    vector<P> vp;\n    vp.push_back(c[0].c);\n    vp.push_back(c[n - 1].c);\n    rep (i, n - 1) {\n      pair<P, P> pp = pCC(c[i], c[i + 1]);\n      vp.push_back(pp.first);\n      vp.push_back(pp.second);\n    }\n    vector<L> vs;\n    rep (i, vp.size()) rep (j, i) {\n      L s = {vp[i], vp[j]};\n      vector<P> v;\n      rep (k, n) if (iCSc(c[k], s)) {\n\tpair<P, P> pp = pCL(c[k], s);\n\tif (ccw(s.a, s.b, pp.first) == ON) v.push_back(pp.first);\n\tif (ccw(s.a, s.b, pp.second) == ON) v.push_back(pp.second);\n      }\n      sort(v.begin(), v.end());\n      rep (t, v.size() - 1) {\n\tbool ok = false;\n\tP m = (v[t] + v[t + 1]) / (D)2;\n\trep (k, n) if (iCP(c[k], m)) {\n\t  ok = true;\n\t  break;\n\t}\n\tif (!ok) goto next;\n      }\n      vs.push_back(s);\n    next:;\n    }\n    vector<P> p;\n    vector<vector<int> > g = sArr(vs, p);\n    int start = -1, goal = -1;\n    rep (i, p.size()) if (p[i] == c[0].c) start = i;\n    rep (i, p.size()) if (p[i] == c[n - 1].c) goal = i;\n    D dis[p.size()];\n    rep (i, p.size()) dis[i] = 1e100;\n    priority_queue<pair<D, int>, vector<pair<D, int> >, greater<pair<D, int> > > que;\n    que.push(make_pair(0, start));\n    while (!que.empty()) {\n      pair<D, int> now = que.top();\n      que.pop();\n      if (sig(dis[now.second], now.first) <= 0) continue;\n      dis[now.second] = now.first;\n      rep (i, g[now.second].size()) {\n\tque.push(make_pair(now.first + abs(p[now.second] - p[g[now.second][i]]), g[now.second][i]));\n      }\n    }\n    printf(\"%.12lf\\n\", dis[goal]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\n#define fi first\n#define se second\n\n// ----- debug macro -----\n#define DMPPT(p) (p).X << \",\" << (p).Y\n// ----- ----- ----- -----\n\n// ????????????????§???????????????????????????\\??????????????????????????¨???????????????\ntypedef complex<double> PT;\ntypedef complex<double> VC;\n// ??´?????????????????????????§?????????????????????\\??§??\\??????typedef\ntypedef pair<PT,PT> LN;\ntypedef pair<PT,PT> SG;\n// ????????????????§????\ntypedef pair<PT,double> CIR;\n\n// paramater\nconst double EPS = 1e-8;\n\ndouble dot_prod(VC a, VC b) {\n\treturn a.X * b.X + a.Y * b.Y;\n}\ndouble cross_prod(VC a, VC b) {\n\treturn a.X * b.Y - a.Y * b.X;\n}\n\n// ??´??? or ???????????????????????????????????????\nVC get_vc_normal(VC a) {\n\ta = a * PT(0,-1);\n\treturn a / abs(a);\n}\n\n// ??±?????\\???(common tangent) ?????????????????????????????¨?????????????????§??¨???(???????????\\????????????)\nvector<LN> get_comm_tan(CIR c0, CIR c1) {\n\tvector<LN> res;\n\tVC v, n;\n\tdouble d;\n\tdouble theta, phi, psi;\n\tconst int sign[] = {1,-1};\n\n\tif(c0.se > c1.se)\n\t\tswap(c0,c1);\n\tv = c1.fi-c0.fi;\n\tn = get_vc_normal(v);\n\td = abs(v);\n\ttheta = arg(v);\n\t// ??±?????\\?????????\n\tif(d < abs(c1.se-c0.se) + EPS)\n\t\treturn res;\n\t// ??±?????\\??? (2???????????§??????)\n\tif(abs(abs(c1.se-c0.se)-d) < EPS || d < abs(c1.se-c0.se)) {\n\t\t// ????????\\??????\n\t\tassert(abs(c1.se-c0.se) > EPS);\n\t\tv *= c0.se / (c1.se - c0.se);\n\t\tres.push_back(LN(c0.fi + v, c0.fi + v + n));\n\t}\n\telse {\n\t\tphi = asin((c1.se-c0.se)/d) + M_PI / 2.0;\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tpsi = theta + sign[i] * phi;\n\t\t\tres.push_back(SG(c0.fi + polar(c0.se, psi),\n\t\t\t\t\tc1.fi + polar(c1.se, psi)));\n\t\t}\n\t}\n\t// ??±?????\\??? (2???????????§??????)\n\tif(abs(c0.se + c1.se - d) < EPS) {\n\t\t// ????????\\??????\n\t\tv *= c0.se / (c0.se + c1.se);\n\t\tres.push_back(LN(c0.fi + v, c0.fi + v + n));\n\t}\n\telse if(c0.se + c1.se < d) {\n\t\tphi = acos((c0.se+c1.se)/d);\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tpsi = theta + sign[i] * phi;\n\t\t\tres.push_back(SG(c0.fi + polar(c0.se, psi),\n\t\t\t\t\t\tc1.fi + polar(c1.se, psi + M_PI)));\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble dist_pts_line(PT p, LN l) {\n\tVC a, b;\n\ta = l.fi - p;\n\tb = l.se - p;\n\treturn abs(cross_prod(a,b)) / abs(l.fi-l.se);\n}\n\nvector<PT> intersec_line_line(LN a, LN b) {\n\tvector<PT> res;\n\tif(abs(cross_prod(a.fi-a.se, b.fi-b.se)) < EPS)\n\t\treturn res;\n\tif(abs(cross_prod(b.fi-a.fi, b.se-a.fi)) < EPS)\n\t\tswap(a.fi, a.se);\n\n\tVC va, vb, vc;\n\tdouble s, t;\n\tva = b.fi-a.fi;\n\tvb = b.se-a.fi;\n\tvc = a.se-a.fi;\n\ts = cross_prod(va,vc) / cross_prod(va,vb);\n\tt = cross_prod(vc,vb) / cross_prod(va,vb);\n\tres.push_back(a.fi + (t * va + s * vb) / (s+t));\n\treturn res;\n}\n\nbool on_seg(PT p, SG a) {\n\tVC b, c;\n\tb = a.fi - p;\n\tc = a.se - p;\n\treturn dot_prod(b,c) < EPS && abs(cross_prod(b,c)) < EPS;\n}\n\nvector<PT> intersec_seg_seg(SG a, SG b) {\n\tvector<PT> tmp, res;\n\ttmp = intersec_line_line(a,b);\n\tfor(int i = 0; i < tmp.size(); i++) {\n\t\tif(on_seg(tmp[i],a) && on_seg(tmp[i],b))\n\t\t\tres.push_back(tmp[i]);\n\t}\n\treturn res;\n}\n\nvector<PT> intersec_circle_circle(CIR a, CIR b) {\n\tvector<PT> res;\n\tdouble d = abs(a.fi-b.fi);\n\tif(abs(a.se+b.se-d) < EPS || abs(abs(a.se-b.se)-d) < EPS) {\n\t\tres.push_back(a.fi + polar(a.se, arg(b.fi-a.fi)));\n\t\treturn res;\n\t}\n\tif(a.se+b.se < d || d < abs(a.se-b.se))\n\t\treturn res;\n\tdouble theta;\n\tdouble aa, bb, cc;\n\taa = b.se;\n\tbb = a.se;\n\tcc = d;\n\t// ????????????\n\ttheta = acos((bb*bb + cc*cc - aa*aa)/ (2.0*bb*cc));\n\tfor(int i = 0; i < 2; i++) {\n\t\tres.push_back(a.fi + polar(a.se, theta + arg(b.fi-a.fi)));\n\t\ttheta *= -1;\n\t}\n\treturn res;\n}\n\n// test code\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rrep(i,n) for(int i = n-1; i >= 0; i--)\n\ntypedef pair<double,int> pdi;\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvector<CIR> v(n);\n\t\trep(i,n) {\n\t\t\tint a, b, r;\n\t\t\tcin >> a >> b >> r;\n\t\t\tv[i] = CIR(PT(a,b),r);\n\t\t}\n\t\tvector<vector<pair<PT,int> > > p; // pt, id;\n\t\tvector<vector<pdi> > edge; // to, cost\n\t\tvector<SG> sg;\n\n\t\tint id_cnt = 0;\n\t\trep(i,n) {\n\t\t\tvector<PT> tmp;\n\t\t\tvector<pair<PT,int> > push_v;\n\t\t\tif(i) {\n\t\t\t\ttmp = intersec_circle_circle(v[i],v[i-1]);\n\t\t\t\tsg.push_back(SG(tmp[0],tmp[1]));\n\t\t\t\tassert(abs(tmp[0]-tmp[1]) > EPS);\n\t\t\t}\n\t\t\ttmp.push_back(v[i].fi);\n\t\t\trep(j,tmp.size()) {\n\t\t\t\tpush_v.push_back(pair<PT,int>(tmp[j],id_cnt++));\n\t\t\t}\n\t\t\tp.push_back(push_v);\n\t\t}\n\t\tedge.resize(id_cnt);\n\t\trep(i,p.size()) {\n\t\t\t// ?§????\n\t\t\trep(j,p[i].size()) {\n\t\t\t\t// ??????\n\t\t\t\trep(k,p[i].size()) {\n\t\t\t\t\tif(j == k)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tedge[p[i][j].se].push_back(pdi(abs(p[i][k].fi-p[i][j].fi), p[i][k].se));\n\t\t\t\t}\n\t\t\t\t// ??????\n\t\t\t\trrep(k,i) {\n\t\t\t\t\t// ??????\n\t\t\t\t\trep(l,p[k].size()) {\n\t\t\t\t\t\tSG a(p[i][j].fi, p[k][l].fi);\n\t\t\t\t\t\tbool flg = true;\n\t\t\t\t\t\tfor(int m = k; m < i; m++) {\n\t\t\t\t\t\t\tif(intersec_seg_seg(a,sg[m]).size() == 0)\n\t\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) {\n\t\t\t\t\t\t\tdouble dist = abs(p[i][j].fi-p[k][l].fi);\n\t\t\t\t\t\t\tedge[p[i][j].se].push_back(pdi(dist, p[k][l].se));\n\t\t\t\t\t\t\tedge[p[k][l].se].push_back(pdi(dist, p[i][j].se));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i,edge.size()) {\n\t\t\trep(j,edge[i].size())\n\t\t\t\tcout << edge[i][j].fi << \":\" << edge[i][j].se << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\trep(i,p.size()) {\n\t\t\trep(j,p[i].size())\n\t\t\t\tcout << DMPPT(p[i][j].fi) << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tpriority_queue<pdi> q;\n\t\tvector<double> mincost(id_cnt, 1e9);\n\t\tmincost[0] = 0;\n\t\tq.push(pdi(0,0));\n\t\twhile(q.size()) {\n\t\t\tpdi a = q.top(); q.pop();\n\t\t\tif(mincost[a.se] < -a.fi)\n\t\t\t\tcontinue;\n\t\t\trep(i,edge[a.se].size()) {\n\t\t\t\tpdi b;\n\t\t\t\tb = edge[a.se][i];\n\t\t\t\tif(mincost[b.se] > -a.fi + b.fi) {\n\t\t\t\t\tmincost[b.se] = -a.fi + b.fi;\n\t\t\t\t\tq.push(pdi(a.fi-b.fi, b.se));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < mincost.size(); i++)\n\t\t\tcout << mincost[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tprintf(\"%.10lf\\n\", mincost[id_cnt-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\nint sign(double x){\n    if(x > EPS) return 1;\n    if(x < -EPS) return -1;\n    return 0;\n}\ndouble dot(Point a, Point b){\n    return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    double len = abs(b) * abs(c); // 速さが気になるときは1にする\n    if (cross(b, c) > +len * EPS)   return +1; // 反時計回り\n    if (cross(b, c) < -len * EPS)   return -1; // 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n    return 0;                         // 点が線分ab上にある\n}\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\nbool intersectSS(Line s, Line t) {\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(Point p, double r) : p(p), r(r) { }\n};\nvector<Point> crosspointCC(Circle a, Circle b){\n    vector<Point> res;\n\n    double l = abs(b.p - a.p);\n\n    if(sign(l) == 0 && sign(a.r - b.r) == 0) assert(false); // 解が無限に存在する\n    if(sign(l - abs(a.r - b.r)) < 0 || sign(l - (a.r + b.r)) > 0) return res; // 解が存在しない\n\n    double th1 = arg(b.p - a.p);\n    if(sign(l - abs(a.r - b.r)) == 0 || sign(l - (a.r + b.r)) == 0){\n        res.push_back(a.p + polar(a.r, th1));\n    }else {\n        double th2 = acos( (a.r * a.r - b.r * b.r + l * l) / (2 * a.r * l) );\n        res.push_back(a.p + polar(a.r, th1 - th2));\n        res.push_back(a.p + polar(a.r, th1 + th2));\n    }\n    return res;\n}\nint main(){\n    int N;\n    while(cin >> N && N){\n        vector<Circle> cv(N);\n        REP(i, N){\n            double x, y, r;\n            cin >> x >> y >> r;\n            cv[i] = Circle(Point(x, y), r);\n        }\n        vector<Line> midl;\n        midl.push_back(Line(cv[0].p, cv[0].p));\n        for(int i = 0; i < N - 1; i++){\n            vector<Point> cp = crosspointCC(cv[i], cv[i + 1]);\n            assert(cp.size() == 2);\n            midl.push_back(Line(cp[0], cp[1]));\n        }\n        midl.push_back(Line(cv[N - 1].p, cv[N - 1].p));\n\n        double dp[111][2] = {};\n        REP(i, N + 2) dp[i][0] = dp[i][1] = 1e15;\n        dp[0][0] = 0;\n        \n        for(int i = 0; i < midl.size(); i++){\n            for(int b1 = 0; b1 < 2; b1++){\n                if(dp[i][b1] == 1e15) continue;\n                for(int j = i + 1; j < midl.size(); j++){\n                    for(int b2 = 0; b2 < 2; b2++){\n                        Line s(midl[i][b1], midl[j][b2]);\n                        bool ok = true;\n                        for(int k = i + 1; k < j; k++){\n                            if(!intersectSS(s, midl[k])) ok = false;\n                        }\n                        if(ok){\n                            dp[j][b2] = min(dp[j][b2], dp[i][b1] + abs(s.vector()));\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%.12f\\n\", dp[midl.size() - 1][0]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n    if( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line \n    return ON;\n}\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) { a = a_; b = b_; }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n};\n// 円の表現\nstruct Circle{\n\t// 円の中心\n\tP p;\n\t// 円の半径\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\tCircle(){}\n\t// 円の面積\n\tdouble get_area() { return r * r * PI; }\n\t// 円周\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t// 2つの円の位置関係\n\t// 2 つの円が離れている => 0\n\t// 2 つの円が外接する   => 1\n\t// 2 つの円が交わる     => 2\n\t// 2 つの円が内接する    => 3 (2つの円が等しいときは内接)\n\t// 円が含まれている       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // 離れている\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // 外接する\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // 内接する\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // 含まれる\n\t\t\treturn 4;\n\t\t}else { // 交わる\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// 2 つの円の交わる点を返す\n\t// 2 つの円が離れている・内包する => 交点は 0 個, (INF_P,INF_P) を返す.\n\t// 2 つの円が外接 or 内接する   => 交点は 1 個, (firstとsecondに同じ値が入る)\n\t// 2 つの円が交わる            => 交点は 2 個.\n\t// 2 つの円は等しい            => 交点は 無限 個, (INF_P,INF_P) を返す.\n\tpair<P,P> intersection(const Circle& c) {\n\t\tdouble d = abs( p - c.p );\n\t\tdouble rc = ( d*d + r*r - c.r*c.r ) / (2.0*d);\n\t\tdouble rs = sqrt( r*r - rc*rc );\n\t\tP diff = (c.p - p) / d;\n\t\treturn pair<P,P> ( p + diff * P(rc, rs) , p + diff * P(rc, -rs) );\n\t}\n};\n\n// 円 i の 交点 p1 から 円 j の交点 p2 まで直線で移動できるかどうかを返す.\nbool is_move(vector<Segment>& vs, int i, int j, P p1, P p2){\n\tSegment s(p1,p2);\n\tfor(int k=i+1 ; k < j ; k++ ){\n\t\tif( !vs[k].is_intersection(s) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// スタート sp から 円 i の交点 p1 まで直線で移動できるかどうか\nbool is_start_to_p(vector<Segment>& vs, P sp, int i, P p1){\n\tSegment s(sp,p1);\n\tfor(int k=0 ; k < i ; k++ ){\n\t\tif( !vs[k].is_intersection(s) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// ゴール gp から 円 i の交点 p1 まで直線で移動できるかどうか\nbool is_goal_to_p(vector<Segment>& vs, P gp, int i, P p1){\n\tSegment s(gp,p1);\n\tfor(int k=vs.size()-1 ; i < k ; k-- ){\n\t\tif( !vs[k].is_intersection(s) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// スタート sp から ゴール gp まで直線で移動できるかどうか\nbool is_start_to_goal(vector<Segment>& vs, P sp, P gp){\n\tSegment s(sp,gp);\n\tfor(int k=0 ; k < vs.size() ; k++ ){\n\t\tif( !vs[k].is_intersection(s) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// グラフの最大の頂点数\nconst int MAX_V = 210;\n// グラフ\ndouble G[MAX_V][MAX_V];\n\n// 初期化\nvoid ini(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t}\n\t}\n}\n\n// 辺の追加\nvoid add_edge(int u, int v, double cost){\n\tG[u][v] = G[v][u] = cost;\n}\n\n// ワーシャルフロイド法\ndouble warshall_floyd(int V, int s, int g){\n\tfor(int k=0 ; k < V ; k++ ){\n\t\tfor(int i=0 ; i < V ; i++ ){\n\t\t\tfor(int j=0 ; j < V ; j++ ){\n\t\t\t\tG[i][j] = min( G[i][j] , G[i][k] + G[k][j] );\n\t\t\t}\n\t\t}\n\t}\n\treturn G[s][g];\n}\n\nint main(){\n\tint n;\n\twhile( scanf(\"%d\", &n) , n ){\n\t\tini();\n\t\tP sp, gp;\n\t\tvector<Circle> v(n);\n\t\tvector<Segment> vs;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint x, y, r;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &r );\n\t\t\tv[i] = Circle( P(x,y) , r );\n\t\t\tif( i == 0 ) sp = P(x,y);\n\t\t\tif( i == n-1 ) gp = P(x,y);\n\t\t}\n\t\tfor(int i=1 ; i < n ; i++ ){\n\t\t\tpair<P,P> pp = v[i-1].intersection( v[i] );\n\t\t\tvs.push_back( Segment( pp.first , pp.second ) );\n\t\t}\n\t\t\n\t\t// 直線でスタートからゴールに行ける時\n\t\tif( is_start_to_goal(vs, sp, gp) ){\n\t\t\tdouble ans = dist(sp,gp);\n\t\t\tprintf(\"%.6f\\n\", ans);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint g = 2 * vs.size() + 1;\n\t\t// 直線で移動できる2点をエッジとしたグラフをつくる\n\t\tfor(int i=0 ; i < vs.size() ; i++ ){\n\t\t\tP p1 = vs[i].a;\n\t\t\tP p2 = vs[i].b;\n\t\t\tint u = 2*i + 1;\n\t\t\tint v = 2*i + 2;\n\t\t\tif( is_start_to_p(vs, sp, i, p1) ){\n\t\t\t\tadd_edge( 0 , u , dist(sp,p1) );\n\t\t\t}\n\t\t\tif( is_start_to_p(vs, sp, i, p2) ){\n\t\t\t\tadd_edge( 0 , v , dist(sp,p2) );\n\t\t\t}\n\t\t\tif( is_goal_to_p(vs, gp, i, p1) ){\n\t\t\t\tadd_edge( g , u , dist(gp,p1) );\n\t\t\t}\n\t\t\tif( is_goal_to_p(vs, gp, i, p2) ){\n\t\t\t\tadd_edge( g , v , dist(gp,p2) );\n\t\t\t}\n\t\t\tfor(int j=i+1 ; j < vs.size() ; j++ ){\n\t\t\t\tP p3 = vs[j].a;\n\t\t\t\tP p4 = vs[j].b;\n\t\t\t\tint u2 = 2*j + 1;\n\t\t\t\tint v2 = 2*j + 2;\n\t\t\t\tif( is_move(vs, i, j, p1, p3) ){\n\t\t\t\t\tadd_edge( u , u2 , dist(p1,p3) );\n\t\t\t\t}\n\t\t\t\tif( is_move(vs, i, j, p1, p4) ){\n\t\t\t\t\tadd_edge( u , v2 , dist(p1,p4) );\n\t\t\t\t}\n\t\t\t\tif( is_move(vs, i, j, p2, p3) ){\n\t\t\t\t\tadd_edge( v , u2 , dist(p2,p3) );\n\t\t\t\t}\n\t\t\t\tif( is_move(vs, i, j, p2, p4) ){\n\t\t\t\t\tadd_edge( v , v2 , dist(p2,p4) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = warshall_floyd( g+1 , 0 , g );\n\t\tprintf(\"%.6f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n    //return a.Y < b.Y;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) return CCW; // ccw\n  if (cross(b, c) < -EPS) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  if (s[0] > s[1]) swap(s[0], s[1]);\n  for (Point p : res) {\n    if (s[0] <= p && p <= s[1]) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nLine CapCS(Circle c, Line s) {\n  Point inf(INF, INF);\n  vector<Point> cros = CrossPointCS(c, s);\n  if (cros.empty()) return Line{inf, inf};\n\n  if (cros.size() == 1) {\n    double ad = abs(s[0]-c.c);\n    double bd = abs(s[1]-c.c);\n    if (ad < min(bd, c.r)) cros.push_back(s[0]);\n    else if (bd < min(ad, c.r)) cros.push_back(s[1]);\n    else { \n      Point p = cros[0];\n      cros.push_back(p); // avoid an undefined behavior\n    }\n  }\n\n  if (cros[1] < cros[0]) {\n    swap(cros[0], cros[1]);\n  }\n  \n  return Line{cros[0], cros[1]};\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nGeometory ContainsPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\nint n;\nCircle cs[114514];\ndouble mind[400][400];\nvector<Point> ps;\n\ntypedef pair<Point, int> Event;\nvector<Event> es;\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    ps.clear();\n    for (int i=0; i<n; i++) {\n      int x, y;\n      double r;\n      scanf(\"%d%d%lf\", &x, &y, &r);\n      cs[i] = Circle{Point(x, y), r};\n      ps.push_back(cs[i].c);\n    }\n  \n    for (int i=1; i<n; i++) {\n      vector<Point> cros = CrossPointCC(cs[i-1], cs[i]);\n      assert (cros.size() == 2);\n      ps.push_back(cros[0]);\n      ps.push_back(cros[1]);\n    }\n  \n    int m = ps.size();\n    for (int i=0; i<m; i++) for (int j=0; j<m; j++) mind[i][j] = INF;\n    for (int i=0; i<m; i++) {\n      mind[i][i] = 0;\n      for (int j=i+1; j<m; j++) {\n        es.clear();\n\n        for (int k=0; k<n; k++) {\n          Line s = CapCS(cs[k], Line{ps[i], ps[j]});\n          es.push_back(Event(s[0], -1));\n          es.push_back(Event(s[1], +1));\n  \n          Vec v1 = ps[i]-cs[k].c;\n          Vec v2 = ps[j]-cs[k].c;\n          if (EQ(abs(v1), cs[k].r) && EQ(abs(v2), cs[k].r)) {\n            double ar = abs(arg(v2/v1)) * cs[k].r;\n            double g = min(mind[i][j], ar);\n            mind[i][j] = mind[j][i] = g;\n          }\n        }\n  \n        sort(es.begin(), es.end());\n        int cnt = 0;\n        bool fail = false;\n        Point lim = Point(-INF, -INF);\n        for (int idx=0; idx<es.size(); idx++) {\n          Event &e = es[idx];\n          Point p = e.first;\n          if (idx == 0 && !EQ(p, min(ps[i], ps[j]))) {\n            fail = true;\n            break;\n          }\n\n          cnt += e.second;\n          lim = max(lim, p);\n          if (cnt > 0 || (cnt == 0 && idx < es.size()-1)) {\n            fail = true;\n            break;\n          }\n        }\n        if (!es.empty() && !EQ(lim, max(ps[i], ps[j]))) fail = true;\n  \n        if (!fail) {\n          mind[i][j] = mind[j][i] = abs(ps[i]-ps[j]);\n        }\n      }\n    }\n  \n    for (int k=0; k<m; k++) {\n      for (int i=0; i<m; i++) {\n        for (int j=0; j<m; j++) {\n          mind[i][j] = min(mind[i][j], mind[i][k]+mind[k][j]);\n        }\n      }\n    }\n  \n    printf(\"%.10f\\n\", mind[0][n-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define sqr(x) ((x)*(x))\n#define INF 1000000000\n\nstruct coordinate {\n\tdouble x, y;\n\tcoordinate() {}\n\tcoordinate(double a, double b) {\n\t\tx = a; y = b;\n\t}\n\tbool operator<(const coordinate & a) const {\n\t\treturn (sqr(x) + sqr(y)) < (a.sqr(x) + sqr(y));\n\t}\n};\n\nstruct circle {\n\tdouble x, y, r;\n\tcircle() {}\n\tcircle(double a, double b, double c) {\n\t\tx = a; y = b; r = c;\n\t}\n\tcircle(coordinate a, double b) {\n\t\tx = a.x; y = a.y; r = b;\n\t}\n};\n\npair<coordinate,coordinate> cross_cc_pt(circle a, circle b) {\n\tdouble theta, phi;\n\tdouble sqr_d;\n\tpair<coordinate,coordinate> ret;\n\n\tphi = atan2(b.y - a.y, b.x - a.x);\n\tsqr_d = sqr(b.x - a.x) + sqr(b.y - a.y);\n\ttheta = acos((sqr(a.r) + sqr_d - sqr(b.r)) / (2 * a.r * sqrt(sqr_d)));\n\n\tret.first  = coordinate(a.r * cos(phi + theta) + a.x, a.r * sin(phi + theta) + a.y);\n\tret.second = coordinate(a.r * cos(phi - theta) + a.x, a.r * sin(phi - theta) + a.y);\n\n\treturn ret;\n}\n\nbool cross_lseg(coordinate a_start, coordinate a_end, coordinate b_start, coordinate b_end) {\n\tdouble xa, xb, xc, ya, yb, yc;\n\tdouble s, t;\n\n\txa = b_start.x - a_start.x; ya = b_start.y - a_start.y;\n\txb = b_end.x   - a_start.x; yb = b_end.y   - a_start.y;\n\txc = a_end.x   - a_start.x; yc = a_end.y   - a_start.y;\n\n\ts = (xc * yb - xb * yc) / (xa * yb - xb * ya);\n\tt = (xa * yc - xc * ya) / (xa * yb - xb * ya);\n\n\treturn (s + t >= 1) && (s >= 0) && (t >= 0);\n}\n\ndouble distance(coordinate a, coordinate b) {\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<circle> v;\n\t\tdouble table[256][256] = {0};\n\t\tvector<pair<coordinate,coordinate> > virtex;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x, y, r;\n\t\t\tcin >> x >> y >> r;\n\t\t\tv.push_back(circle(x, y, r));\n\t\t}\n\n\t\tvirtex.push_back(make_pair(coordinate(v[0].x, v[0].y), coordinate(v[0].x, v[0].y)));\n\t\tfor(int i = 1; i < v.size(); i++) {\n\t\t\tpair<coordinate,coordinate> tmp;\n\t\t\ttmp = cross_cc_pt(v[i - 1], v[i]);\n\t\t\tvirtex.push_back(tmp);\n\t\t}\n\t\tvirtex.push_back(pair<coordinate,coordinate>(coordinate(v[v.size() - 1].x, v[v.size() - 1].y), coordinate(v[v.size() - 1].x, v[v.size() - 1].y)));\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\t\tfor(int j = 0; j < virtex.size(); j++) {\n\t\t\t\ttable[i * 2][j * 2] = distance(virtex[i].first, virtex[j].first);\n\t\t\t\ttable[i * 2][j * 2 + 1] = distance(virtex[i].first, virtex[j].second);\n\t\t\t\ttable[i * 2 + 1][j * 2] = distance(virtex[i].second, virtex[j].first);\n\t\t\t\ttable[i * 2 + 1][j * 2 + 1] = distance(virtex[i].second, virtex[j].second);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tprintf(\"% 4.3f \", table[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < virtex.size(); i++) {\n\t\tfor(int i_ = 0; i_ < 2; i_++) {\n\t\t\tcoordinate start;\n\t\t\tstart = i_ == 0 ? virtex[i].first : virtex[i].second;\n\t\t\tfor(int j = i; j < virtex.size(); j++) {\n\t\t\tfor(int j_ = 0; j_ < 2; j_++) {\n\t\t\t\tcoordinate end;\n\t\t\t\tend = j_ == 0 ? virtex[j].first : virtex[j].second;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = i + 1; k < j; k++) {\n\t\t\t\t\tflag &= cross_lseg(virtex[k].first, virtex[k].second, start, end);\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t\ttable[i * 2 + i_][j * 2 + j_] = table[j * 2 + j_][i * 2 + i_] = INF;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < virtex.size() * 2; i++) {\n\t\t\tfor(int j = 0; j < virtex.size() * 2; j++) {\n\t\t\t\tfor(int k = 0; k < virtex.size() * 2; k++) {\n\t\t\t\t\ttable[j][k] = min(table[j][k], table[j][i] + table[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", table[0][virtex.size() * 2 - 1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\nint cross_lib(double x1,double y1,double x2,double y2,\n\t\tdouble x3,double y3,double x4,double y4) {\n\tdouble b12x,b12y,b34x,b34y;\n\tdouble b24x,b24y;\n\tdouble b13x,b13y,b14x,b14y,b32x,b32y;\n\tdouble g1213,g1214,g3431,g3432;\n\tdouble n1213,n1214,n3431,n3432;\n\tdouble n2123,n2124,n4341,n4342;\n\n\tb12x=x2-x1;b12y=y2-y1;\n\tb34x=x4-x3;b34y=y4-y3;\n\tb13x=x3-x1;b13y=y3-y1;\n\tb14x=x4-x1;b14y=y4-y1;\n\tb32x=x2-x3;b32y=y2-y3;\n\tb24x=x4-x2;b24y=y4-y2;\n\n\tg1213=b12x*b13y-b13x*b12y;\n\tg1214=b12x*b14y-b14x*b12y;\n\tg3431=b34x*(-b13y)-(-b13x)*b34y;\n\tg3432=b34x*b32y-b32x*b34y;\n\n\tn1213=b12x*b13x+b12y*b13y;\n\tn1214=b12x*b14x+b12y*b14y;\n\tn3431=b34x*(-b13x)+b34y*(-b13y);\n\tn3432=b34x*b32x+b34y*b32y;\n\tn2123=(-b12x)*(-b32x)+(-b12y)*(-b32y);\n\tn2124=(-b12x)*b24x+(-b12y)*b24y;\n\tn4341=(-b34x)*(-b14x)+(-b34y)*(-b14y);\n\tn4342=(-b34x)*(-b24x)+(-b34y)*(-b24y);\n\n\tif(\n\t\t((g1213+EPS<0 && g1214>EPS) || (g1213>EPS && g1214+EPS<0)) &&\n\t\t((g3431+EPS<0 && g3432>EPS) || (g3431>EPS && g3432+EPS<0))\n\t) return 1;\n\tif(\n\t\t(fabs(g1213)<EPS && n1213+EPS>0 && n2123+EPS>0) ||\n\t\t(fabs(g1214)<EPS && n1214+EPS>0 && n2124+EPS>0) ||\n\t\t(fabs(g3431)<EPS && n3431+EPS>0 && n4341+EPS>0) ||\n\t\t(fabs(g3432)<EPS && n3432+EPS>0 && n4342+EPS>0)\n\t) return 1;\n\n\treturn 0;\n}\n\ntypedef struct {\n\tdouble x,y;\n} point_t;\n\ntypedef struct {\n\tpoint_t c;\n\tdouble r;\n} circle_t;\n\nint cross(const point_t* p1,const point_t* p2,const point_t* p3,const point_t* p4) {\n\treturn cross_lib(p1->x,p1->y,p2->x,p2->y,p3->x,p3->y,p4->x,p4->y);\n}\n\n/*\n(x-x1)^2+(y-y1)^2=r1^2\n(x-x2)^2+(y-y2)^2=r2^2\n\nx^2-2.0*x*x1+x1^2 + y^2-2.0*y*y1+y1^2 = r1^2\nx^2-2.0*x*x2+x2^2 + y^2-2.0*y*y2+y2^2 = r2^2\n\n-2.0*x*(x1-x2)+(x1^2-x2^2) -2.0*y*(y1-y2)+(y1^2-y2^2) = (r1^2-r2^2)\n\nif(fabs(x1-x2)>EPS) {\n\tx = (r1^2-r2^2+2*y*(y1-y2)-(x1^2-x2^2)-(y1^2-y2^2))/(-2.0*(x1-x2))\n\t\ta=(r1^2-r2^2-x1^2+x2^2-y1^2+y2^2)/(-2.0*(x1-x2))-x1\n\t\tb=-(y1-y2)/(x1-x2)\n\tx = (a+x1)+b*y\n\t(b*y+a)^2+(y-y1)^2=r1^2\n\t(b*b+1)*y^2 + 2*(a*b-y1)*y + (a*a+y1*y1-r1*r1) == 0\n}\n*/\n\nvoid get_kouten(point_t* p1,point_t* p2,const circle_t* c1,const circle_t* c2) {\n\tdouble x1=c1->c.x;\n\tdouble y1=c1->c.y;\n\tdouble r1=c1->r;\n\tdouble x2=c2->c.x;\n\tdouble y2=c2->c.y;\n\tdouble r2=c2->r;\n\tdouble aa,bb;\n\tdouble a,b,c,sqrD;\n\tint xyriv_flag=0;\n\tif(fabs(x1-x2)<EPS) {\n\t\tdouble tmp;\n\t\ttmp=x1;x1=y1;y1=tmp;\n\t\ttmp=x2;x2=y2;y2=tmp;\n\t\txyriv_flag=1;\n\t}\n\taa=(r1*r1-r2*r2-x1*x1+x2*x2-y1*y1+y2*y2)/(-2.0*(x1-x2))-x1;\n\tbb=-(y1-y2)/(x1-x2);\n\n\ta=bb*bb+1.0;\n\tb=2.0*(aa*bb-y1);\n\tc=aa*aa+y1*y1-r1*r1;\n\tsqrD=sqrt(b*b-4.0*a*c);\n\tp1->y=(-b-sqrD)/(2.0*a);\n\tp2->y=(-b+sqrD)/(2.0*a);\n\tp1->x=(aa+x1)+bb*p1->y;\n\tp2->x=(aa+x1)+bb*p2->y;\n\tif(xyriv_flag) {\n\t\tdouble tmp;\n\t\ttmp=p1->x;p1->x=p1->y;p1->y=tmp;\n\t\ttmp=p2->x;p2->x=p2->y;p2->y=tmp;\n\t}\n}\n\ndouble get_dist(const point_t* p1,const point_t* p2) {\n\treturn sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\nint main(void) {\n\tint n;\n\twhile(scanf(\"%d\",&n)==1 && n>0) {\n\t\tstatic double dist[200][200];\n\t\tcircle_t c[100];\n\t\tpoint_t c_kouten[100][2];\n\t\tint i,j,k;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf%lf%lf\",&c[i].c.x,&c[i].c.y,&c[i].r);\n\t\tfor(i=0;i<n*2;i++) {\n\t\t\tfor(j=0;j<n*2;j++) {\n\t\t\t\tdist[i][j]=(i==j?0:1e200);\n\t\t\t}\n\t\t}\n\t\t/* en no kouten wo motomeru */\n\t\tfor(i=0;i+1<n;i++) {\n\t\t\tget_kouten(&c_kouten[i][0],&c_kouten[i][1],&c[i],&c[i+1]);\n\t\t}\n\t\t/* hen wo haru */\n\t\t/* start -> cross point */\n\t\tfor(i=0;i<n-1;i++) {\n\t\t\tint ok0=1,ok1=1;\n\t\t\tfor(j=0;j<i;j++) {\n\t\t\t\tif(!cross(&c[0].c,&c_kouten[i][0],&c_kouten[j][0],&c_kouten[j][1])) {\n\t\t\t\t\tok0=0;\n\t\t\t\t}\n\t\t\t\tif(!cross(&c[0].c,&c_kouten[i][1],&c_kouten[j][0],&c_kouten[j][1])) {\n\t\t\t\t\tok1=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok0)dist[0][i*2+2]=dist[i*2+2][0]=get_dist(&c[0].c,&c_kouten[i][0]);\n\t\t\tif(ok1)dist[0][i*2+3]=dist[i*2+3][0]=get_dist(&c[0].c,&c_kouten[i][1]);\n\t\t}\n\t\t/* cross point -> goal */\n\t\tfor(i=0;i<n-1;i++) {\n\t\t\tint ok0=1,ok1=1;\n\t\t\tfor(j=i+1;j<n-1;j++) {\n\t\t\t\tif(!cross(&c[n-1].c,&c_kouten[i][0],&c_kouten[j][0],&c_kouten[j][1])) {\n\t\t\t\t\tok0=0;\n\t\t\t\t}\n\t\t\t\tif(!cross(&c[n-1].c,&c_kouten[i][1],&c_kouten[j][0],&c_kouten[j][1])) {\n\t\t\t\t\tok1=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok0)dist[1][i*2+2]=dist[i*2+2][1]=get_dist(&c[n-1].c,&c_kouten[i][0]);\n\t\t\tif(ok1)dist[1][i*2+3]=dist[i*2+3][1]=get_dist(&c[n-1].c,&c_kouten[i][1]);\n\t\t}\n\t\t/* start -> goal */\n\t\t{\n\t\t\tint ok=1;\n\t\t\tfor(j=0;j<n-1;j++) {\n\t\t\t\tif(!cross(&c[0].c,&c[n-1].c,&c_kouten[j][0],&c_kouten[j][1])) {\n\t\t\t\t\tok=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)dist[0][1]=dist[1][0]=get_dist(&c[0].c,&c[n-1].c);\n\t\t}\n\t\t/* cross point -> cross point */\n\t\tfor(i=0;i<n-1;i++) {\n\t\t\tfor(j=i+1;j<n-1;j++) {\n\t\t\t\tint ok00=1,ok01=1,ok10=1,ok11=1;\n\t\t\t\tfor(k=i+1;k<j;k++) {\n\t\t\t\t\tif(!cross(&c_kouten[i][0],&c_kouten[j][0],\n\t\t\t\t\t&c_kouten[k][0],&c_kouten[k][1])) {\n\t\t\t\t\t\tok00=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(!cross(&c_kouten[i][0],&c_kouten[j][1],\n\t\t\t\t\t&c_kouten[k][0],&c_kouten[k][1])) {\n\t\t\t\t\t\tok01=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(!cross(&c_kouten[i][1],&c_kouten[j][0],\n\t\t\t\t\t&c_kouten[k][0],&c_kouten[k][1])) {\n\t\t\t\t\t\tok10=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(!cross(&c_kouten[i][1],&c_kouten[j][1],\n\t\t\t\t\t&c_kouten[k][0],&c_kouten[k][1])) {\n\t\t\t\t\t\tok11=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok00)dist[i*2+2][j*2+2]=dist[j*2+2][i*2+2]=\n\t\t\t\t\tget_dist(&c_kouten[i][0],&c_kouten[j][0]);\n\t\t\t\tif(ok01)dist[i*2+2][j*2+3]=dist[j*2+3][i*2+2]=\n\t\t\t\t\tget_dist(&c_kouten[i][0],&c_kouten[j][1]);\n\t\t\t\tif(ok10)dist[i*2+3][j*2+2]=dist[j*2+2][i*2+3]=\n\t\t\t\t\tget_dist(&c_kouten[i][1],&c_kouten[j][0]);\n\t\t\t\tif(ok11)dist[i*2+3][j*2+3]=dist[j*2+3][i*2+3]=\n\t\t\t\t\tget_dist(&c_kouten[i][1],&c_kouten[j][1]);\n\t\t\t}\n\t\t}\n\t\t/* waasyaru furoido hou */\n\t\tfor(k=0;k<n*2;k++) {\n\t\t\tfor(i=0;i<n*2;i++) {\n\t\t\t\tfor(j=0;j<n*2;j++) {\n\t\t\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j]) {\n\t\t\t\t\t\tdist[i][j]=dist[i][k]+dist[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* print the answer */\n\t\tprintf(\"%f\\n\",dist[0][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1183 Chain-Confined Path\n// 2018.3.7 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define QMAX 1000\ntypedef struct { int s; double t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, double t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG;\ntypedef struct { double x, y, r; } C;\n\n#define EPS 1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\nPP d2p(double x, double y) { PP r; r.x = x, r.y = y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\ndouble dist(PP p1, PP p2) {\treturn vabs(vsub(p1, p2)); }\nvoid p2v(SEG *s, PP p1, PP p2) { s->s = p1, s->e = p2; } \nint ccw(PP p0, PP p1, PP p2) { PP a, b;\tdouble t;\n\ta = vsub(p1, p0), b = vsub(p2, p0), t = cross(a, b);\n\tif (t >  EPS) return 1;\tif (t < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\n\nint intersectSS(SEG s1, SEG s2)\n{\n\treturn ccw(s1.s, s1.e, s2.s) * ccw(s1.s, s1.e, s2.e) <= 0 &&\n\t\t   ccw(s2.s, s2.e, s1.s) * ccw(s2.s, s2.e, s1.e) <= 0;\n}\n\nint intersectCC(C c1, C c2, PP *p1, PP *p2)\n{\n\tdouble x1 = c1.x, y1 = c1.y, r1 = c1.r;\n\tdouble x2 = c2.x, y2 = c2.y, r2 = c2.r;\n\tdouble d = dist(d2p(x1, y1), d2p(x2, y2));\n\tdouble w, n, x, y, p, q;\n\tdouble u, v;\n\n\tu = r1+r2, v = fabs(r1-r2);\n\n\tif ((fabs(d-u) > EPS && d >= u) || fabs(v-d) > EPS && d <= v) return 0;\n\tw = ((r1*r1 - r2*r2)/d + d) / 2;\n\tn = sqrt(r1*r1 - w*w);\n\tx = x1 + (x2-x1)*w / d;\n\ty = y1 + (y2-y1)*w / d;\n\tp = (y2-y1)*n / d;\n\tq = (x2-x1)*n / d;\n\n\tp1->x = x+p, p2->x = x-p;\n\tp1->y = y-q; p2->y = y+q;\n\tif (fabs(d-u) <= EPS) return 1;\n\tif (d == r1+r2) return 1;\n\treturn 2;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nC c[102];\nSEG a[102];\nPP p[202]; int sz;\nint hi[402], to[402][402];\nchar mk[202];\n\ndouble dijkstra(int start, int goal)\n{\n\tint i, s, e;\n\tdouble d;\n\n\tmemset(mk, 0, sizeof(mk));\n\tqsize = 0; d = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (s == goal) break;\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\tif (mk[e]) continue;\n\t\t\tenq(e, d + dist(p[s], p[e]));\n\t\t}\n\t}\n\treturn d;\n}\n\nint check(int p1, int p2, int s1, int s2)\n{\n\tint i; SEG s;\n\tp2v(&s, p[p1], p[p2]);\n\tfor (i = s2; i >= s1; i--) if (!intersectSS(s, a[i])) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tint n, i, j, ii, jj;\n\n\twhile (n = in()) {\n\t\tfor (i = 0; i < n; i++) c[i].x = in(), c[i].y = in(), c[i].r = in();\n\t\tp[0] = d2p(c[0].x, c[0].y), sz = 1;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tintersectCC(c[i-1], c[i], &a[i].e, &a[i].s);\n\t\t\tp[sz++] = a[i].s, p[sz++] = a[i].e;\n\t\t}\n\t\tp[sz++] = d2p(c[n-1].x, c[n-1].y);\n\n\t\tif (check(0, sz-1, 1, n-1)) { printf(\"%lf\\n\", dist(p[0], p[sz-1])); continue; }\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (i = 0; i < sz; i++) {\n\t\t\tii = (i+1) >> 1;\n\t\t\tfor (j = sz-1; j > i; j--) {\n\t\t\t\tjj = (j+1) >> 1;\n\t\t\t\tif (ii == jj) break;\n\t\t\t\tif (check(i, j, ii+1, jj-1)) to[i][hi[i]++] = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lf\\n\", dijkstra(0, sz-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main{\n\tpublic static Point[][] vec;\n\tpublic static int n;\n//\tpublic static Point[][] vec;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = in.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\tCircle[] chain = new Circle[n];\n\t\t\tPoint bc = null;\n\t\t\tvec = new Point[2][n+1];\n\t\t\t// init\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tchain[i] = new Circle(in.nextInt(), in.nextInt(), in.nextInt());\n\t\t\t\tif(i==0){\n\t\t\t\t\tbc = chain[i].p;\n\t\t\t\t\tvec[0][0] = bc;\n\t\t\t\t\tvec[1][0] = bc;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tPoint[] p = chain[i].crossPoint(chain[i-1]);\n\t\t\t\tPoint c = chain[i].p.center(chain[i-1].p);\n\t\t\t\tint s1 = ccw(c, bc, p[0]) < 0 ? 0 : 1;\n\t\t\t\tint s2 = s1 == 0 ? 1 : 0;\n\t\t\t\tvec[s1][i] = p[0];\n\t\t\t\tvec[s2][i] = p[1];\n\t\t\t\tbc = c;\n\t\t\t}\n\t\t\tvec[0][n] = chain[n-1].p;\n\t\t\tvec[1][n] = chain[n-1].p;\n\t\t\tArrayList<Point> res = new ArrayList<Point>();\n\t\t\tdouble[][] dp = new double[2][n+1];\n\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\t\tdp[i][j] = 1e9;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] sign = new int[2][n+1];\n\t\t\tdp[0][0] = Math.sqrt(vec[0][0].dist2(vec[0][1]));\n\t\t\tdp[1][0] = Math.sqrt(vec[1][0].dist2(vec[1][1]));\n\t\t\t// end init\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tfor(int k=0; k<2; k++){\n\t\t\t\t\t\tdouble d = dp[k][i-1] + Math.sqrt(vec[k][i-1].dist2(vec[j][i]));\n\t\t\t\t\t\tif(dp[j][i] > d){\n\t\t\t\t\t\t\tdp[j][i] = d;\n\t\t\t\t\t\t\tsign[j][i] = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tStack<Point> stack = new Stack<Point>();\n\t\t\tstack.push(vec[0][n]);\n\t\t\tint s = sign[0][n];\n\t\t\tfor(int i=n-1; i>=0; i--){\n\t\t\t\tstack.push(vec[s][i]);\n\t\t\t\ts = sign[s][i];\n\t\t\t}\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\tres.add(stack.pop());\n\t\t\t}\n\t\t\t\n//\t\t\tres.add(vec[0][0]);\n//\t\t\tres.addAll(1, root(0, 0, 0, n));\n//\t\t\tres.add(vec[0][n]);\n\t\t\tfor(int i=0; i<100; i++) opt(res);\n\t\t\tSystem.out.println(length(res));\n\t\t}\n\t}\n\t\n\tstatic void opt(ArrayList<Point> p){\n\t\tQueue<Point> rem = new LinkedList<Point>();\n\t\tint[] sign = new int[p.size()];\n\t\tint idx = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\tif(vec[j][i] == p.get(idx)){\n\t\t\t\t\tsign[idx++] = j==0?-1:1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPoint bp = p.get(0);\n\t\tfor(int i=1; i<p.size()-1; i++){\n\t\t\tif(sign[i] != sign[i+1] && i<p.size()-2\n\t\t\t\t\t|| ccw(bp, p.get(i), p.get(i+1))*sign[i] < 0){\n\t\t\t\tbp = p.get(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trem.add(p.get(i));\n\t\t}\n\t\tfor(Point r: rem){\n\t\t\tp.remove(r);\n\t\t}\n\t}\n\t\n\tstatic double length(ArrayList<Point> p){\n\t\tdouble res = 0;\n\t\tfor(int i=1; i<p.size(); i++){\n\t\t\tres += Math.sqrt(p.get(i).dist2(p.get(i-1)));\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t// v1??????v2???????????????????????§????????±?????????????±???????\n\t// ???????????°????????????\n\tstatic ArrayList<Point> root(int s1, int v1, int s2, int v2){\n\t\tPoint p2 = vec[s2][v2];\n\t\tArrayList<Point> res = new ArrayList<Point>();\n\t\tif(v2-v1 < 2) return res;\n\t\tfor(int i=v1; i<v2-1; i++){\n\t\t\tif(ccw(vec[0][i], vec[0][i+1], p2) > 0){\n\t\t\t\tres.addAll(root(s1, v1, 0, i+1));\n\t\t\t\tres.add(vec[0][i+1]);\n\t\t\t\tres.addAll(root(0, i+1, s2, v2));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ccw(vec[1][i], vec[1][i+1], p2) < 0){\n\t\t\t\tres.addAll(root(s1, v1, 1, i+1));\n\t\t\t\tres.add(vec[1][i+1]);\n\t\t\t\tres.addAll(root(1, i+1, s2, v2));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t// p1-p2??¨p3-p4??????????????????????????????\n\tstatic boolean cross(Point p1, Point p2, Point p3, Point p4){\n\t\tif(p1 == p3) return false;\n\t\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n\t\t\t\t&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n\t}\n\t\n\t// a,b,c??????????¨????????????¨?????£?????¢???\n\tstatic double ccw(Point a, Point b, Point c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n\t\n}\n\nclass Circle{\n\tfinal static double EPS = 1e-8;\n\t\n\tPoint p;\n\tdouble r;\n\tpublic Circle(double x, double y, double r){\n\t\tp = new Point(x, y);\n\t\tthis.r = r;\n\t}\n\t\n\tpublic Point[] crossPoint(Circle c){\n\t\tif(!cross(c)) return null;\n\t\tdouble x1 = c.p.x - p.x;\n\t\tdouble y1 = c.p.y - p.y;\n\t\tdouble a = (x1*x1+y1*y1+r*r-c.r*c.r)/2.0;\n\t\tPoint[] res = {\n\t\t\t\tnew Point(culc(x1, y1, r, a, true)+p.x, culc(y1, x1, r, a, false)+p.y),\n\t\t\t\tnew Point(culc(x1, y1, r, a, false)+p.x, culc(y1, x1, r, a, true)+p.y),\n\t\t};\n\t\treturn res;\n\t}\n\t\n\tprivate static double culc(double x, double y, double r, double a, boolean sign){\n\t\treturn (a*x + (sign?1:-1)*y*Math.sqrt((x*x+y*y)*r*r-a*a)+EPS)/(x*x+y*y);\n\t}\n\t\n\tpublic boolean cross(Circle c){\n\t\treturn p.dist2(c.p) <= (r+c.r)*(r+c.r) + EPS;\n\t}\n}\n\nclass Point{\n\tdouble x, y;\n\tpublic Point(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic double dist2(Point p){\n\t\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n\t}\n\t\n\tpublic Point center(Point p){\n\t\treturn new Point((x+p.x)/2, (y+p.y)/2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\npublic class Main{\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1183();\n\t}\n\tclass AOJ1183{\n\t\tAOJ1183(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tsolve(n);\n\t\t\t}\n\t\t}\n\t\tfinal double INF = Double.MAX_VALUE/4;\n\t\tC[] c;\n\t\tPoint2D.Double[][] p;\n\t\tPoint2D.Double[] p2;\n\t\tvoid solve(int n){\n\t\t\tc=new C[n];\n\t\t\tfor(int i=0; i<n; ++i)\tc[i]=new C(sc.nextInt(),sc.nextInt(),sc.nextInt());\n\t\t\tp = new Point2D.Double[n][2];\t// 交点の座標\n\t\t\tfor(int i=0; i<n-1; ++i)\tp[i]=intersectR(c[i], c[i+1]);\n\t\t\tp2=new Point2D.Double[2*n];\n\t\t\tp2[0]=(java.awt.geom.Point2D.Double) c[0].p;\n\t\t\tp2[2*n-1]=(java.awt.geom.Point2D.Double) c[n-1].p;\n\t\t\tfor(int i=0; i<n-1; ++i){\n\t\t\t\tp2[i*2+1]=p[i][0];\n\t\t\t\tp2[i*2+2]=p[i][1];\n\t\t\t}\n//\t\t\tSystem.out.println(Arrays.toString(p2));\n\t\t\t\n\t\t\tdouble[] dp=new double[2*n];\n\t\t\tfor(int i=0; i<2*n; ++i)\tdp[i]=INF;\n\t\t\tdp[0]=0;\n\t\t\tfor(int i=0; i<2*n; ++i){\n\t\t\t\tfor(int j=i+1; j<2*n; ++j){\n\t\t\t\t\tif(!f1(i,j))\tcontinue;\n\t\t\t\t\tdp[j]=min(dp[j], dp[i]+p2[i].distance(p2[j]));\n//\t\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+dp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dp[2*n-1]);\n\t\t}\n\t\tboolean f1(int from,int to){\n\t\t\tint f=(from+1)/2-1, t=(to+1)/2-1;\n\t\t\tLine2D.Double l=new Line2D.Double(p2[from], p2[to]);\n\t\t\tfor(int i=f+1; i<t; ++i)if(!new Line2D.Double(p[i][0], p[i][1]).intersectsLine(l))\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\tPoint2D.Double[] intersectR(C a,C b){\n\t\t\tdouble dis = a.p.distance(b.p);\n\t\t\tif(dis > a.r + b.r)\treturn null;\n\t\t\tPoint2D v = sub(b.p, a.p);\n\t\t\tdouble rc = (dis*dis+a.r*a.r-b.r*b.r)/(2*dis);\n\t\t\tdouble rate = rc/dis;\n\t\t\tv = mul(rate,v);\n\t\t\tPoint2D c = add(v, a.p);\n\t\t\tdouble disC2c = c.distance(b.p);\n\t\t\tdouble disqc = Math.sqrt(b.r*b.r - disC2c*disC2c);\n\t\t\tPoint2D v2 = sub(b.p, c);\n\t\t\tv2 = mul(disqc / disC2c, v2);\n\t\t\tPoint2D.Double[] ret = new Point2D.Double[2];\n\t\t\tret[0] = (Point2D.Double)add(normalVector1(v2), c);\n\t\t\tret[1] = (Point2D.Double)add(normalVector2(v2), c);\n\t\t\treturn ret;\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(), p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D mul(double v,Point2D p){\n\t\t\treturn new Point2D.Double(p.getX()*v, p.getY()*v);\n\t\t}\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D normalVector2(Point2D p){\n\t\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t\t}\n\t\tclass C{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tC(int x,int y,int r){\n\t\t\t\tthis.p=new Point2D.Double(x,y);\n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n    Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n    \tnew Main();\n    }\n    \n    public Main() {\n    \tnew AOJ1183().doIt();\n    }\n    \n    class AOJ1183{\n    \tLine2D ls[];\n    \tint n;\n    \tCircle circle[];\n    \tdouble[][] cost;\n    \tdouble INF = Double.MAX_VALUE/2;\n    \tPoint2D p[];\n    \tvoid solve(){\n    \t\tint m = (n-1)*2+2;\n    \t\tp = new Point2D[m];\n    \t\tp[0] = circle[0].p;\n    \t\tp[m-1] = circle[n-1].p;\n    \t\tfor(int i=0;i<n-1;i++){\n    \t\t\tPoint2D kp[] = intersectPtCC(circle[i], circle[i+1]);\n    \t\t\tp[i*2+1] = kp[0];\n    \t\t\tp[i*2+2] = kp[1];\n    \t\t}\n//    \t\tfor(int i=0;i<m;i++)System.out.println(p[i]);\n    \t\tls = new Line2D[n];\n    \t\tfor(int i=1;i<n;i++){\n    \t\t\tLine2D l = new Line2D.Double(p[(i-1)*2+1],p[(i-1)*2+2]);\n//    \t\t\tSystem.out.println(l.getP1()+\"-----\"+l.getP2());\n    \t\t\tls[i] = l;\n    \t\t}\n    \t\tcost = new double[(n-1)*2+2][(n-1)*2+2];\n    \t\tfor(int i=0;i<(n-1)*2+2;i++)Arrays.fill(cost[i], INF); \n    \t\tfor(int i=0;i<m;i++){\n    \t\t\tfor(int s=i+1;s<m;s++)if(s!=i){\n    \t\t\t\tLine2D l = new Line2D.Double(p[i],p[s]);\n    \t\t\t\tint start = (1+i)/2;\n    \t\t\t\tint end = (1+s)/2;\n    \t\t\t\tif(i==0)start = 1;\n    \t\t\t\tif(s==m-1)end = ls.length-1;\n//    \t\t\t\tSystem.out.println(\"start = \"+ start + \" goal = \"+end + \" point= \"+p[i]+\"-----\"+p[s]);\n    \t\t\t\tif(isOkay(l, start, end))cost[i][s] = cost[s][i] = p[i].distance(p[s]);\n    \t\t\t}\n    \t\t}\n//    \t\tfor(int i=0;i<m;i++){\n//    \t\t\tfor(int s=0;s<m;s++)System.out.print(cost[i][s]+\" \");\n//    \t\t\tSystem.out.println();\n//    \t\t}\n    \t\tfor(int k=0;k<m;k++)for(int i=0;i<m;i++)for(int j=0;j<m;j++){\n    \t\t\tcost[i][j] = Math.min(cost[i][j], cost[i][k]+cost[k][j]);\n    \t\t}\n    \t\tSystem.out.printf(\"%.5f\\n\",cost[0][m-1]);\n    \t}\n    \t\n    \tboolean isOkay(Line2D a,int start,int goal){\n    \t\tfor(int i=start;i<=goal;i++){\n//    \t\t\tSystem.out.println(ls[i].getP1()+\"---\"+ls[i].getP2()+\" \"+a.getP1()+\"-----\"+a.getP2());\n    \t\t\tif(a.intersectsLine(ls[i])==false){\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t}\n    \t\treturn true;\n    \t}\n    \t\n    \tvoid doIt(){\n    \t\twhile(in.hasNext()){\n    \t\t\tn = in.nextInt();\n    \t\t\tif(n==0)break;\n    \t\t\tcircle = new Circle[n];\n    \t\t\tfor(int i=0;i<n;i++)circle[i] = new Circle(in.nextDouble(), in.nextDouble(), in.nextDouble());\n    \t\t\tsolve();\n    \t\t}\n    \t}\n    }\n    \n    class Circle{\n    \tPoint2D p;\n    \tdouble r;\n    \tpublic Circle(double x,double y,double r) {\n    \t\tthis.p = new Point2D.Double(x, y);\n    \t\tthis.r = r;\n    \t}\n    }\n    \n    double EPS = 1.0e-8;\n    \n    double cross(Point2D p1,Point2D p2){\n    \treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n    }\n    \n    Point2D diff(Point2D p1,Point2D p2){\n    \treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n    }\n    \n    Point2D sub(Point2D p1,Point2D p2){\n    \treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n    }\n    \n    Point2D mul(double n,Point2D p1){\n    \treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n    }\n    \n    Point2D add(Point2D p1,Point2D p2){\n    \treturn new Point2D.Double(p1.getX()+p2.getX(),p1.getY()+p2.getY());\n    }\n    \n    Point2D normalVector1(Point2D p){\n    \treturn new Point2D.Double(-p.getY(),p.getX());\n    }\n    Point2D normalVector2(Point2D p){\n    \treturn new Point2D.Double(p.getY(),-p.getX());\n    }\n    \n    Point2D[] intersectPtCC(Circle a,Circle b){\n    \tdouble dis = a.p.distance(b.p);\n    \tif(dis>a.r+b.r)return null;\n    \tPoint2D v = sub(b.p,a.p);\n    \tdouble rc = (dis*dis+a.r*a.r-b.r*b.r)/(2*dis);\n    \tdouble rate = rc/dis;\n    \tv = mul(rate,v);\n    \tPoint2D c = add(v,a.p);\n    \tdouble disC2c = c.distance(b.p);\n    \tdouble disqc = Math.sqrt(b.r*b.r - disC2c*disC2c);\n    \tPoint2D v2 = sub(b.p,c);\n    \tv2 = mul(disqc/disC2c,v2);\n    \tPoint2D[] ret = new Point2D.Double[2];\n    \tret[0] = add(normalVector1(v2),c);\n    \tret[1] = add(normalVector2(v2),c);\n    \treturn ret;\n    }\n    \n    boolean intersectLL(Line2D l1,Line2D l2){\n    \treturn intersectLL(l1.getP1(), l1.getP2(),l2.getP1(),l2.getP2());\n    }\n    \n    boolean intersectLL(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n    \treturn (Math.abs(cross(diff(a2,a1),diff(b2,b1)))>EPS) || (Math.abs(cross(diff(a2,a1),diff(a1,b1)))<EPS);\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble INF = Double.POSITIVE_INFINITY;\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tCircle[] cs = new Circle[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tPoint[] ps = new Point[2 * n];\n\t\t\tps[0] = new Point(cs[0].x, cs[0].y);\n\t\t\tps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);\n\t\t\tLine[] ls = new Line[n - 1];\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tPoint[] cis = cs[i + 1].circleInterSection(cs[i]);\n\t\t\t\tps[2 * i + 1] = cis[0];\n\t\t\t\tps[2 * i + 2] = cis[1];\n\t\t\t\tls[i] = new Line(cis[0], cis[1]);\n\t\t\t}\n\t\t\tdouble[][] cost = new double[2 * n][2 * n];\n\t\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\t\tArrays.fill(cost[i], INF);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= 2 * n - 4; i++) {\n\t\t\t\tfor (int j = i + 1; j < 2 * n; j++) {\n\t\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\t\tLine l1 = new Line(ps[i], ps[j]);\n\t\t\t\t\t\tboolean inCircle = true;\n\t\t\t\t\t\tfor (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {\n\t\t\t\t\t\t\tLine l2 = ls[k];\n\t\t\t\t\t\t\tif (!l2.intersectsLine(l1)) {\n\t\t\t\t\t\t\t\tinCircle = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (inCircle) {\n\t\t\t\t\t\t\tcost[i][j] = l1.length();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLine l1 = new Line(ps[i], ps[j]);\n\t\t\t\t\t\tboolean inCircle = true;\n\t\t\t\t\t\tfor (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {\n\t\t\t\t\t\t\tLine l2 = ls[k];\n\t\t\t\t\t\t\tif (!l2.intersectsLine(l1)) {\n\t\t\t\t\t\t\t\tinCircle = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (inCircle) {\n\t\t\t\t\t\t\tcost[i][j] = l1.length();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])\n\t\t\t\t\t.length();\n\t\t\tcost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])\n\t\t\t\t\t.length();\n\t\t\tfor (int k = 0; k < 2 * n; k++) {\n\t\t\t\tfor (int i = 0; i < 2 * n; i++) {\n\t\t\t\t\tif (k < i)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfor (int j = i + 1; j < 2 * n; j++) {\n\t\t\t\t\t\tcost[i][j] = Math.min(cost[i][j], cost[i][k]\n\t\t\t\t\t\t\t\t+ cost[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.5f\\n\", cost[0][2 * n - 1]);\n\t\t}\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass Point extends Point2D.Double {\n\tPoint(int x, int y) {\n\t\tsuper(x, y);\n\t}\n\n\tPoint(double x, double y) {\n\t\tsuper(x, y);\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass Line extends Line2D.Double {\n\n\tLine(Point p1, Point p2) {\n\t\tsuper(p1, p2);\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t}\n}\n\nclass Circle {\n\tint x;\n\tint y;\n\tint r;\n\n\tCircle(int x, int y, int r) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.r = r;\n\t}\n\n\tpublic Point[] circleInterSection(Circle c2) {\n\t\tCircle c1 = this;\n\t\tdouble a = c1.x;\n\t\tdouble b = c1.y;\n\t\tdouble r = c1.r;\n\t\tdouble c = c2.x;\n\t\tdouble d = c2.y;\n\t\tdouble s = c2.r;\n\t\tdouble norm = (c - a) * (c - a) + (d - b) * (d - b);\n\t\tdouble t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);\n\t\tdouble th = Math.acos(t / r);\n\t\tdouble th0 = Math.atan2((d - b), (c - a));\n\t\tdouble p1 = a + r * Math.cos(th + th0);\n\t\tdouble q1 = b + r * Math.sin(th + th0);\n\t\tdouble p2 = a + r * Math.cos(-th + th0);\n\t\tdouble q2 = b + r * Math.sin(-th + th0);\n\t\tPoint[] ps = { new Point(p1, q1), new Point(p2, q2) };\n\t\treturn ps;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"x,y,r \" + x + \" \" + y + \" \" + r + \" \";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] circle = new Point2D[n];\n\t\t\tint[] circle_r = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tcircle[i] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\t\tcircle_r[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D[] points = new Point2D[n * 2];\n\t\t\t\n\t\t\tpoints[0] = new Point2D(circle[0].x, circle[0].y);\n\t\t\t\n\t\t\tfor(int num = 0; num < n - 1; num++){\n\t\t\t\tPoint2D[] result = Point2D.cross_ss(circle[num], circle_r[num], circle[num+1], circle_r[num+1]);\n\t\t\t\tpoints[2 * num + 1] = result[0];\n\t\t\t\tpoints[2 * num + 2] = result[1];\n\t\t\t}\n\t\t\t\n\t\t\tpoints[2*n-1] = new Point2D(circle[n-1].x, circle[n-1].y);\n\t\t\t\n\t\t\tdouble[][] adj = new double[n * 2][n * 2];\n\t\t\tfor(int i = 0; i < n * 2; i++){\n\t\t\t\tArrays.fill(adj[i], Double.MAX_VALUE);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int from = 0; from < 2 * n; from++){\n\t\t\t\tfor(int to = from + 1; to < 2 * n; to++){\n\t\t\t\t\tfinal int start = Math.min(n - 2, (from - 1) / 2);\n\t\t\t\t\tfinal int end = Math.min(n - 2, (to - 1) / 2);\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(from + \" \" + start + \" \" + to + \" \" + end + \" : \" + n);\n\t\t\t\t\t\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor(int line = start; line <= end; line++){\n\t\t\t\t\t\tfinal int s_line = line * 2 + 1;\n\t\t\t\t\t\tfinal int e_line = line * 2 + 2;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//System.out.println(s_line + \" \" + e_line);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!Point2D.intersect_s(points[from], points[to], points[s_line], points[e_line])){\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\tadj[from][to] = adj[to][from] = points[from].dist(points[to]);\n\t\t\t\t\t\t//System.out.println(from + \" \" + to + \" =>\" + adj[from][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble[] dist = new double[n * 2];\n\t\t\tboolean[] used = new boolean[n * 2];\n\t\t\tArrays.fill(dist, Double.MAX_VALUE);\n\t\t\tdist[0] = 0;\n\t\t\t\n\t\t\tfor(int tt = 0; tt < 2 * n; tt++){\n\t\t\t\tint min_pos = -1;\n\t\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\t\t\n\t\t\t\t//System.out.println(tt + Arrays.toString(dist));\n\t\t\t\t\n\t\t\t\tfor(int pos = 0; pos < 2 * n; pos++){\n\t\t\t\t\tif(!used[pos] && dist[pos] < min){\n\t\t\t\t\t\tmin = dist[pos];\n\t\t\t\t\t\tmin_pos = pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tused[min_pos] = true;\n\t\t\t\tif(min_pos == 2 * n - 1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int to = 0; to < 2 * n; to++){\n\t\t\t\t\tif(used[to] || adj[min_pos][to] == Double.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdist[to] = Math.min(dist[to], dist[min_pos] + adj[min_pos][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.6f\\n\", dist[2 * n - 1]);\n\t\t}\n\t}\n\t\n\tpublic static class Point2D{\n\t\tpublic double x;\n\t\tpublic double y;\n\n\t\tpublic static final double EPS = 1e-9;\n\n\t\tpublic Point2D(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\t//オマケ\n\t\tpublic Point2D(Point2D point) {\n\t\t\tthis.x = point.x;\n\t\t\tthis.y = point.y;\n\t\t}\n\n\t\t//オマケ\n\t\tpublic String toString() {\n\t\t\treturn x + \",\" + y;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Point2D) {\n\t\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\t\n\t\t\t\tif(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tpublic Point2D add(Point2D another) {\n\t\t\tPoint2D ret = new Point2D(this);\n\t\t\tret.x += another.x;\n\t\t\tret.y += another.y;\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic Point2D minus(){\n\t\t\tPoint2D ret = new Point2D(this);\n\t\t\tret.x = -ret.x;\n\t\t\tret.y = -ret.y;\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic Point2D sub(Point2D another) {\n\t\t\treturn this.add(another.minus());\n\t\t}\n\n\t\tpublic Point2D mul(double d) {\n\t\t\tPoint2D ret = new Point2D(this);\n\t\t\tret.x *= d;\n\t\t\tret.y *= d;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic Point2D div(double d) {\n\t\t\tPoint2D ret = new Point2D(this);\n\t\t\tret.x /= d;\n\t\t\tret.y /= d;\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic double dot(Point2D another) {\n\t\t\treturn this.x * another.x + this.y * another.y;\n\t\t}\n\n\t\tpublic double cross(double x, double y) {\n\t\t\treturn this.x * y - this.y * x;\n\t\t}\n\n\t\tpublic double cross(Point2D another) {\n\t\t\treturn this.x * another.y - this.y * another.x;\n\t\t}\n\t\t\n\t\tpublic double dist(Point2D another){\n\t\t\treturn Math.sqrt((this.x - another.x) * (this.x - another.x) +\n\t\t\t\t\t \t\t (this.y - another.y) * (this.y - another.y));\n\t\t}\n\n\t\tpublic double dist_o() {\n\t\t\tfinal Point2D ZERO = new Point2D(0, 0);\n\t\t\treturn this.dist(ZERO);\n\t\t}\n\n\t\tpublic Point2D unit() {\n\t\t\treturn this.div(this.dist_o());\n\t\t}\n\n\t\tpublic boolean pol(Point2D start, Point2D end) {\n\t\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t\t}\n\n\t\tpublic boolean pos(Point2D start, Point2D end) {\n\t\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t\t}\n\n\t\tpublic double pld(Point2D start, Point2D end) {\n\t\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t\t/ end.sub(start).dist_o());\n\t\t}\n\n\t\tpublic double psd(Point2D start, Point2D end) {\n\t\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\t\treturn this.dist(start);\n\t\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\t\treturn this.dist(end);\n\t\t\t} else {\n\t\t\t\treturn Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static int signum(double x){\n\t\t\treturn Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n\t\t}\n\t\t\n\t\tpublic static boolean eq(double x, double y){\n\t\t\treturn signum(x - y) == 0;\n\t\t}\n\t\t\n\t\tpublic static int ccw(Point2D p, Point2D r, Point2D s){\n\t\t\tPoint2D a = r.sub(p);\n\t\t\tPoint2D b = s.sub(p);\n\t\t\t\n\t\t\tfinal int sgn = Point2D.signum(a.cross(b));\n\t\t\tif(sgn != 0){\n\t\t\t\treturn sgn;\n\t\t\t}else if(a.x * b.x < -EPS && a.y * b.y < -EPS){\n\t\t\t\treturn -1;\n\t\t\t}else if(a.dist_o() < b.dist_o() - EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\t\tPoint2D b2) {\n\t\t\treturn (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n\t\t\t\t\t&& (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n\t\t}\n\n\t\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\t\tPoint2D b2) {\n\t\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t\t}\n\n\t\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\t\tPoint2D b2) {\n\t\t\tPoint2D b = b2.sub(b1);\n\t\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\t\treturn a1.add(v);\n\t\t}\n\n\t\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\t\tPoint2D b2) {\n\t\t\tPoint2D a = a2.sub(a1);\n\t\t\tPoint2D b = b2.sub(b1);\n\t\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\t\tPoint2D v = a.mul(t);\n\t\t\treturn a1.add(v);\n\t\t}\n\n\t\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\t\tdouble r2) {\n\t\t\tdouble dis = p1.dist(p2);\n\n\t\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\t\treturn new Point2D[0]; // same\n\t\t\t}\n\n\t\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\t\tret[0] = p1.add(tmp);\n\t\t\t\treturn ret;\n\t\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\t\treturn new Point2D[0]; // out\n\t\t\t}\n\n\t\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\t\tPoint2D tmp = null;\n\t\t\t\tif (r1 > r2) {\n\t\t\t\t\ttmp = p2.sub(p1);\n\t\t\t\t} else {\n\t\t\t\t\ttmp = p1.sub(p2);\n\t\t\t\t}\n\n\t\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\t\tret[0] = p1.add(tmp);\n\t\t\t\treturn ret;\n\t\t\t} else if (dis_m + EPS > dis) {\n\t\t\t\treturn new Point2D[0]; // inner\n\t\t\t} else {\n\t\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t\t/ (2 * dis * r1));\n\t\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n\t\t\tif(Point2D.intersect_s(start1, end1, start2, end2)){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\treturn Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\t\tPoint2D ans[]) {\n\t\t\tif (c.pld(start, end) > r + EPS)\n\t\t\t\treturn;\n\t\t\tPoint2D v = end.sub(start).unit();\n\t\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\t\tdouble t = -v.dot(start.sub(c));\n\t\t\tdouble s = Math.sqrt(delta);\n\t\t\tans[0] = start.add(v.mul(t + s));\n\t\t\tans[1] = start.add(v.mul(t + s));\n\t\t}\n\n\t\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\t\tPoint2D v = b.sub(a).unit();\n\t\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t\t(-1) * v.y, v.x);\n\t\t\treturn v.mul(p.pld(a, b));\n\t\t}\n\n\t\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.awt.geom.*;\n\nclass Circle {\n    public Point2D.Double o;\n    public double r;\n    Circle() {\n        this.o = new Point2D.Double(0, 0);\n        this.r = 0;\n    }\n    Circle(Point2D.Double o, double r) {\n        this.o = o;\n        this.r = r;\n    }\n    Point2D.Double[] intersectionPoint(Circle c) {\n        Point2D.Double[] ip = new Point2D.Double[2];\n        double l = o.distance(c.o);\n        double a = Math.atan2(c.o.y - o.y, c.o.x - o.x);\n        double t = Math.acos((r*r - c.r*c.r + l*l) / (2 * l * r));\n        ip[0] = new Point2D.Double(r*Math.cos(a+t) + o.x, r*Math.sin(a+t) + o.y);\n        ip[1] = new Point2D.Double(r*Math.cos(a-t) + o.x, r*Math.sin(a-t) + o.y);\n        return ip;\n    }\n}\n\npublic class Main {\n    int n;\n    Circle[] cs;\n    Point2D.Double[] p;\n    Scanner sc;\n\n    Main() {\n        sc = new Scanner(System.in);\n    }\n\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n        cs = new Circle[n];\n        for (int i = 0; i < n; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            double r = sc.nextDouble();\n            cs[i] = new Circle(new Point2D.Double(x, y), r);\n        }\n\n        p = new Point2D.Double[2*n];\n        p[0] = cs[0].o; p[2*n-1] = cs[n-1].o;\n        for (int i = 0; i < n-1; i++) {\n            Point2D.Double[] _p = cs[i].intersectionPoint(cs[i+1]);\n            p[i*2+1] = _p[0];\n            p[i*2+2] = _p[1];\n        }\n \n//        for (int i = 0; i < 2*n; i++) {\n//            System.out.println(p[i]);\n//        }\n        return true;\n    }\n\n    void run() {\n        while (init()) {\n            double[][] graph = new double[2*n][2*n];\n            for (int i = 0; i < 2*n; i++) \n                for (int j = 0; j < 2*n; j++) \n                    graph[i][j] = 1e18;\n \n            for (int i = 0; i < 2*n; i++) {\n                for (int j = 0; j < 2*n; j++) {\n                    Line2D.Double line = new Line2D.Double(p[i], p[j]);\n                    if (0 <= j - i && j - i <= 2) {\n                        graph[i][j] = p[i].distance(p[j]);\n                        graph[j][i] = graph[i][j];\n                    } else {\n                        for (int k = (i+1)/2+1; k < (j+1)/2; k++) {\n                            if (!line.intersectsLine(new Line2D.Double(p[k*2-1], p[k*2]))) {\n//                                System.out.println(\"Line \" + (k*2-1) + \",\" + k*2 + \n//                                        \" and Line \" + i + \",\" + j + \" are not intersects\");\n                                graph[i][j] = 1e18;\n                                break;\n                            }\n                            graph[i][j] = p[i].distance(p[j]);\n                            graph[j][i] = graph[i][j];\n                        }\n                    }\n                }\n            }\n\n            for (int k = 0; k < 2*n; k++) \n                for (int i = 0; i < 2*n; i++) \n                    for (int j = 0; j < 2*n; j++) \n                        graph[i][j] = Math.min(graph[i][j], graph[i][k]+graph[k][j]);\n\n            System.out.println(graph[0][2*n-1]);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\n\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tstatic class P{\n\t\tstatic Comparator<P> comp=new Comparator<P>(){\n\t\t\tpublic int compare(P p1, P p2) {\n\t\t\t\treturn p1.x!=p2.x?signum(p1.x-p2.x):signum(p1.y-p2.y);\n\t\t\t}\n\t\t};\n\n\t\t//geo\n\t\tstatic final double EPS=1e-10;\n\t\tstatic int signum(double x){\n\t\t\treturn x<-EPS?-1:x>EPS?1:0;\n\t\t}\n\t\tpublic static  final P\n\t\t\tXunit=new P(1,0),\n\t\t\tYunit=new P(0,1),\n\t\t\tO=new P(0,0);\n\n\t\tdouble x,y;\n\t\tP(double _x,double _y){\n\t\t\tx=_x;\n\t\t\ty=_y;\n\t\t}\n\n\t\t//x+yi x-yi\n\t\tP conj(){\n\t\t\treturn new P(x,-y);\n\t\t}\n\t\tP add(P a){\n\t\t\treturn new P(x+a.x,y+a.y);\n\t\t}\n\t\tP sub(P a){\n\t\t\treturn new P(x-a.x,y-a.y);\n\t\t}\n\t\tP mul(P a){\n\t\t\treturn new P(x*a.x-y*a.y,x*a.y+y*a.x);\n\t\t}\n\t\tP div(P a){\n\t\t\tdouble d2=a.dist2(O);\n\t\t\treturn new P(dot(a,this)/d2,cross(a,this)/d2);\n\t\t}\n\t\t//a・b=|a||b|cosθ=a.x*b.x+a.y*b.y\n\t\tstatic double dot(P a,P b){\n\t\t\treturn  a.x*b.x+a.y*b.y;\n\t\t}\n\t\t//a×b=|a||b|sinθ=a.x*b.y-a.y*b.x\n\t\tstatic double cross(P a,P b){\n\t\t\treturn  a.x*b.y-a.y*b.x;\n\t\t}\n\t\t//二乗距離\n\t\tdouble dist2(P p){\n\t\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y);\n\t\t}\n\t\t//a,b間の距離\n\t\tdouble dist(P p){\n\t\t\treturn sqrt(dist2(p));\n\t\t}\n\t\tpublic double norm(){\n\t\t\treturn dist(O);\n\t\t}\n\t\t//oからみたaの角度\n\t\tstatic double arg(P a,P o){\n\t\t\tP dir=a.sub(o);\n\t\t\tdouble s=acos(dir.x/dir.norm());\n\t\t\treturn dir.y>0?s:2*PI-s;\n\t\t}\n\t\tP rotate(P o,double arg){//oを中心に回転\n\t\t\treturn this.add(this.sub(o).mul(new P(cos(arg),sin(arg))));\n\t\t}\n\t\tstatic P polar(double abs,double arg){//絶対値と偏角から複素数取得\n\t\t\treturn new P(abs*cos(arg),abs*sin(arg));\n\t\t}\n\t\tstatic int ccw(P a,P b,P c){// a→b→cと進むときの向き\n\t\t\tb=b.sub(a);c=c.sub(a);\n\t\t\tif(cross(b,c)>EPS)return 1;//counter clockwise\n\t\t\tif(cross(b,c)<-EPS)return -1;//clockwise\n\t\t\tif(dot(b,c)<-EPS)return 2;//c--a--b on line\n\t\t\tif(b.norm()<c.norm()-EPS)return -2;//a--b--c on line\n\t\t\treturn 0;//a--c--b on line (or b==c)\n\t\t}\n\t\t//→AO,→BOの面積の2倍\n\t\tstatic double S2(P a,P b,P o){\n\t\t\treturn cross(a.sub(o),b.sub(o));\n\t\t}\n\t\tstatic double S(P a,P b,P o){\n\t\t\treturn S2(a,b,o)/2;\n\t\t}\n\t\t// ?\n\t\tstatic P proj(P p,P o){\n\t\t\treturn o.mul(new P(dot(p,o)/o.norm(),0));\n\t\t}\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif(obj instanceof P){\n\t\t\t\tP p=(P)obj;\n\t\t\t\treturn signum(x-p.x)==0 && signum(y-p.y)==0;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t}\n\n\tstatic class C {\n\t\t//geo\n\t\tstatic final double EPS=1e-10;\n\t\tstatic int signum(double x){\n\t\t\treturn x<-EPS?-1:x>EPS?1:0;\n\t\t}\n\t\tP p;\n\t\tdouble r;\n\t\tC(P _p,double _r){\n\t\t\tp=_p;\n\t\t\tr=_r;\n\t\t}\n\t\tstatic  final C Unit=new C(P.O,1);\n\t\t//二円の交点\n\t\tstatic ArrayList<P> intersection(C c1,C c2){\n\t\t\tArrayList<P> res=new ArrayList<P>();\n\t \t\tdouble d=c1.p.dist(c2.p);\n\t\t\tif(d<EPS && abs(c1.r-c2.r)<EPS){//重なる\n\t\t\t}else if(abs(c1.r+c2.r-d)<EPS){//円が接する\n\t\t\t\tP diff=c2.p.sub(c1.p).div(new P(d,0));\n\t\t\t\tres.add(c1.p.add(diff.mul(new P(c1.r,0))));\n\t\t\t}else if(d<c1.r+c2.r){//二円が交差\n\t\t\t\tdouble rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n\t\t\t\tdouble rs=Math.sqrt(c1.r*c1.r-rc*rc);\n\t\t\t\tP diff=c2.p.sub(c1.p).div(new P(d,0));\n\t\t\t\tres.add(c1.p.add(diff.mul(new P(rc,rs))));\n\t\t\t\tres.add(c1.p.add(diff.mul(new P(rc,-rs))));\n\t\t\t}else{//交点なし\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\t//線分\n\tstatic class S extends AL{\n\t\tS(P _p1, P _p2) {super(_p1, _p2);}\n\t\tboolean isIntersect(P p){//|a-p|+|p-b|<=|a-b|\n\t\t\treturn p1.sub(p).norm()+p2.sub(p).norm()<=p1.sub(p2).norm()+EPS;\n\t\t}\n\t\tboolean isIntersect(S l){\n\t\t\treturn P.ccw(p1,p2,l.p1)*P.ccw(p1,p2,l.p2)<=0\n\t\t\t&& P.ccw(l.p1,l.p2,p1)*P.ccw(l.p1,l.p2,p2)<=0;\n\t\t}\n\t\t//線分と点\n\t\tdouble dist(P p){\n\t\t\tif(P.dot(p2.sub(p1),p.sub(p1))<EPS)return p.sub(p1).norm();\n\t\t\tif(P.dot(p1.sub(p2),p.sub(p2))<EPS)return p.sub(p2).norm();\n\t\t\treturn abs(P.S(p2,p,p1))/p1.sub(p2).norm();\n\t\t}\n\t\t//線分と線分\n\t\tdouble dist(S l){\n\t\t\tif(isIntersect(l))return 0;\n\t\t\treturn min(min(dist(l.p1),dist(l.p2)),min(l.dist(p1),l.dist(p2)));\n\t\t}\n\t}\n\tabstract static class AL{\n\t\t//geo\n\t\t\tstatic final double EPS=1e-10;\n\t\t\tstatic int signum(double x){\n\t\t\t\treturn x<-EPS?-1:x>EPS?1:0;\n\t\t\t}\n\t\tpublic P p1,p2;\n\t\tAL(P _p1,P _p2){\n\t\t\tp1=_p1;\n\t\t\tp2=_p2;\n\t\t}\n//\t\t//交点 (交差判定なし)\n//\t\tstatic P intersection(AL l1,AL l2){\n//\t\t\tP dl1=l1.p2.sub(l1.p1),dl2=l2.p2.sub(l2.p1);\n//\t\t\tdouble a=P.cross(dl2,l2.p1.sub(l1.p1));\n//\t\t\tdouble b=P.cross(dl2,dl1);\n//\t\t\tif(abs(a)<EPS && abs(b) <EPS)return l1.p1;//same\n//\t\t\treturn l1.p1.add(dl1.mul(new P(a/b,0.0)));\n//\t\t}\n\n\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif(obj instanceof AL){\n\t\t\t\tAL l=(AL)obj;\n\t\t\t\treturn this.p1.equals(l.p1) && this.p2.equals(l.p2);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn p1+\"-\"+p2;\n\t\t}\n\t}\n\n\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)return;\n\t\t\tC[] cs=new C[n];\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcs[i]=new C(new P(sc.nextInt(),sc.nextInt()),sc.nextInt());\n\t\t\t}\n\t\t\tdouble[] dp=new double[2*n];\n\t\t\tArrays.fill(dp,Double.MAX_VALUE);\n\n\t\t\t//先頭++二円の交点 2*(n-1)個++最後\n\t\t\tP[] ips=new P[2*n];\n\t\t\tips[0]=cs[0].p;ips[2*n-1]=cs[n-1].p;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\t//i-1とiの円の交点を計算\n\t\t\t\tList<P> ip=C.intersection(cs[i],cs[i+1]);\n\t\t\t\tips[2*i+1]=ip.get(0);ips[2*i+2]=ip.get(1);\n\t\t\t}\n\n\t\t\t//通過線分\n\t\t\tS[] ss=new S[n-1];\n\t\t\tfor(int i=0;i<n-1;i++)ss[i]=new S(ips[2*i+1],ips[2*i+2]);\n\n\t\t\t//初期点からのdp\n\t\t\tdp[0]=0;\n\t\t\tfor(int i=0;i<2*n;i++){//dp\n\t\t\t\tfor(int j=i+1;j<2*n;j++){\n\t\t\t\t\tint slen=(j-1)/2;\n\t\t\t\t\t//全てリンクしてるかチェック\n\t\t\t\t\tboolean isIn=true;\n\t\t\t\t\tfor(int k=(i-1)/2;k<slen;k++){\n\t\t\t\t\t\tif(!ss[k].isIntersect(new S(ips[j],ips[i]))){\n\t\t\t\t\t\t\tisIn=false;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(isIn)dp[j]=min(dp[j],dp[i]+ips[i].dist(ips[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(dp[2*n-1]);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t// from this\n//\t\tstatic BufferedReader in;\n//\t\tstatic PrintWriter out;\n//\t\tstatic {\n//\t    \ttry {\n//\t\t\t\tin =new BufferedReader(new FileReader(\"file.in\")); Project/file.in\n//\t\t\t\tout=new PrintWriter(new BufferedWriter(new FileWriter(\"file.out\")));\n//\t    \t} catch (IOException e) {\n//\t\t\t\te.printStackTrace();\n//\t\t\t}\n\t//  }\n\t// end\n\n\tstatic Scanner sc=new Scanner(in);\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\npublic class Main{\n\tdouble EPS = 1.0e-08;\n\tint INF = 1 << 24;\n\t//1240 start\n\t//1333 cording end\n\t//2325 restart\n\t//0007 sample match\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tCircle [] clist = new Circle[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tPoint2D p = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\tclist[i] = new Circle(p, sc.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Point2D> cand = new ArrayList<Point2D>();\n\t\t\tcand.add(clist[0].p);\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tPoint2D [] res = intersectPtCC(clist[i], clist[i+1]);\n\t\t\t\tcand.add(res[0]);\n\t\t\t\tcand.add(res[1]);\n\t\t\t}\n\t\t\tcand.add(clist[n-1].p);\n\t\t\t\n\t\t\tint len = cand.size();\n\t\t\tdouble [][] dp = new double[len][len];\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t\tdp[i][i] = 0.0;\n\t\t\t}\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfor(int j = i + 1; j < len; j++){\n\t\t\t\t\tboolean isOK = true;\n\t\t\t\t\tLine2D m = new Line2D.Double(cand.get(i), cand.get(j));\n\t\t\t\t\tfor(int k = j - 2; k > i; k -= 2){\n\t\t\t\t\t\tLine2D l;\n\t\t\t\t\t\tif(k % 2 == 0){\n\t\t\t\t\t\t\tl = new Line2D.Double(cand.get(k-1), cand.get(k));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl = new Line2D.Double(cand.get(k), cand.get(k + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(! m.intersectsLine(l)){\n\t\t\t\t\t\t\tisOK = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(isOK){\n\t\t\t\t\t\tdp[i][j] = cand.get(i).distance(cand.get(j));\n\t\t\t\t\t\tdp[j][i] = cand.get(i).distance(cand.get(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\t\tfor(int k = 0; k < len; k++){\n\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][k], dp[i][j] + dp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\",dp[0][len-1]);\n\t\t}\n\t}\n\t\n\tpublic class Circle{\n\t\tPoint2D p;\n\t\tdouble r;\n\t\tpublic Circle(Point2D p, double r) {\n\t\t\tthis.p = p; this.r = r;\n\t\t}\n\t}\n\t\n\t//円と円の交点\n\tPoint2D [] intersectPtCC(Circle a,Circle b) {\n\t\tdouble dis = a.p.distance(b.p);\n\t\tPoint2D v = sub(b.p, a.p);\n\t\tdouble rc = (dis * dis + a.r * a.r - b.r * b.r) / (2 * dis);\n\t\tdouble rate = rc / dis;\n\t\tv = mul(v, rate);\n\t\tPoint2D c = add(v, a.p);\n\t\tdouble disC2c = c.distance(b.p);\n\t\tdouble disqc = Math.sqrt(b.r * b.r - disC2c * disC2c);\n\t\tPoint2D v2 = sub(b.p, c);\n\t\tv2 = mul(v2, disqc / disC2c);\n\t\tPoint2D [] res = new Point2D[2];\n\t\tres[0] = add(normalV1(v2), c);\n\t\tres[1] = add(normalV2(v2), c);\n\t\treturn res;\n\t}\n\t\n\tprivate Point2D normalV1(Point2D p) {\n\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t}\n\t\n\tprivate Point2D normalV2(Point2D p) {\n\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t}\n\n\tprivate Point2D add(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() + p2.getX();\n\t\tdouble y = p1.getY() + p2.getY();\n\t\treturn new Point2D.Double(x,y);\n\t}\n\n\tprivate Point2D mul(Point2D v, double rate) {\n\t\treturn new Point2D.Double(v.getX() * rate, v.getY() * rate);\n\t}\n\n\tprivate Point2D sub(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x,y);\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1183();\n\t}\n\t\n\tclass AOJ1183{\n\t\tAOJ1183(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tsolve(n);\n\t\t\t}\n\t\t}\n\t\tCircle[] c;\n\t\tPoint2D[][] p1;\n\t\tPoint2D[] p2;\n\t\tvoid solve(int n){\n\t\t\tc=new Circle[n];\n\t\t\tfor(int i=0; i<n; ++i)\tc[i]=new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tp1=new Point2D[n-1][2];\n\t\t\tfor(int i=0; i<n-1; ++i)\tp1[i]=intersectPtCC(c[i], c[i+1]);\n\t\t\tp2=new Point2D[2*n];\n\t\t\tp2[0]=c[0].p;\n\t\t\tp2[2*n-1]=c[n-1].p;\n\t\t\tfor(int i=0; i<n-1; ++i){\n\t\t\t\tp2[2*i+1]=p1[i][0];\n\t\t\t\tp2[2*i+2]=p1[i][1];\n\t\t\t}\n\t\t\tdouble[] dp=new double[2*n];\n\t\t\tfor(int i=1; i<2*n; ++i)\tdp[i]=Double.MAX_VALUE/4;\n\t\t\tfor(int i=0; i<2*n; ++i)for(int j=i+1; j<2*n; ++j){\n\t\t\t\tif(i==j || !f1(i,j))\tcontinue;\n\t\t\t\tdp[j]=min(dp[j], dp[i]+p2[j].distance(p2[i]));\n\t\t\t}\n\t\t\tSystem.out.println(dp[2*n-1]);\n\t\t}\n\t\tboolean f1(int from,int to){\n\t\t\tLine2D l=new Line2D.Double(p2[from],p2[to]);\n\t\t\tint f=(from+1)/2-1,t=(to+1)/2-1;\n\t\t\tfor(int i=f+1; i<t; ++i)if(!new Line2D.Double(p1[i][0],p1[i][1]).intersectsLine(l))\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(), p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n, p1.getY()*n);\n\t\t}\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D normalVector2(Point2D p){\n\t\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t\t}\n\t\tclass Circle{\n\t\t\tPoint2D p;\n\t\t\tdouble r;\n\t\t\tCircle(double x,double y,double r){\n\t\t\t\tthis.p=new Point2D.Double(x,y);\n\t\t\t\tthis.r=r;\n\t\t\t}\n\t\t}\n\t\tPoint2D[] intersectPtCC(Circle a,Circle b){\n\t\t\tdouble dis = a.p.distance(b.p);\n\t\t\tif(dis > a.r+b.r)\treturn null;\n\t\t\tPoint2D v = sub(b.p, a.p);\n\t\t\tdouble rc = (dis*dis + a.r*a.r - b.r*b.r)/(2*dis);\n\t\t\tdouble rate = rc/dis;\n\t\t\tv = mul(rate, v);\n\t\t\tPoint2D c = add(v, a.p);\n\t\t\tdouble disC2c = c.distance(b.p);\n\t\t\tdouble disqc = Math.sqrt(b.r*b.r - disC2c*disC2c);\n\t\t\tPoint2D v2 = sub(b.p, c);\n\t\t\tv2 = mul(disqc/disC2c, v2);\n\t\t\tPoint2D[] ret = new Point2D.Double[2];\n\t\t\tret[0] = add(normalVector1(v2), c);\n\t\t\tret[1] = add(normalVector2(v2), c);\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tP[][] cps;\n\tC[] cs;\n\tdouble[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tcs = new C[n];\n\t\t\tfor(int i=0;i<n;i++) cs[i] = new C(sc.nextDouble(), sc.nextDouble(), sc.nextDouble());\n\t\t\t\n\t\t\tcps = new P[n-1][];\n\t\t\tfor(int i=0;i<n-1;i++) cps[i] = circleIntersection(cs[i].p, cs[i+1].p, cs[i].r, cs[i+1].r);\n//\t\t\tfor(int i=0;i<n-1;i++) debug(cps[i][0].x, cps[i][0].y, cps[i][1].x, cps[i][1].y);\n\t\t\t\n\t\t\tes = new double[2*n][2*n];\n\t\t\tfor(double[] a: es) fill(a, INF);\n\t\t\t\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tif(isCross(cs[0].p, cps[i][0], 0, i)) es[0][2*(i+1)-1] = cs[0].p.abs(cps[i][0]);\n\t\t\t\tif(isCross(cs[0].p, cps[i][1], 0, i)) es[0][2*(i+1)] = cs[0].p.abs(cps[i][1]);\n\t\t\t\tif(isCross(cs[n-1].p, cps[i][0], i+1, n-1)) es[2*(i+1)-1][2*n-1] = cs[n-1].p.abs(cps[i][0]);\n\t\t\t\tif(isCross(cs[n-1].p, cps[i][1], i+1, n-1)) es[2*(i+1)][2*n-1] = cs[n-1].p.abs(cps[i][1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n-1;i++) for(int j=i+1;j<n-1;j++) {\n\t\t\t\tif(isCross(cps[i][0], cps[j][0], i+1, j)) es[2*(i+1)-1][2*(j+1)-1] = cps[i][0].abs(cps[j][0]);\n\t\t\t\tif(isCross(cps[i][0], cps[j][1], i+1, j)) es[2*(i+1)-1][2*(j+1)] = cps[i][0].abs(cps[j][1]);\n\t\t\t\tif(isCross(cps[i][1], cps[j][0], i+1, j)) es[2*(i+1)][2*(j+1)-1] = cps[i][1].abs(cps[j][0]);\n\t\t\t\tif(isCross(cps[i][1], cps[j][1], i+1, j)) es[2*(i+1)][2*(j+1)] = cps[i][1].abs(cps[j][1]);\n\t\t\t}\n\t\t\t\n\t\t\tif(isCross(cs[0].p, cs[n-1].p, 0, n-1)) es[0][2*n-1] = cs[0].p.abs(cs[n-1].p);\n\t\t\t\n//\t\t\tfor(double[] a: es) debug(a);\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\t\n\tdouble dijkstra() {\n\t\tdouble[] d = new double[2*n];\n\t\tboolean[] used = new boolean[2*n];\n\t\tint[] path = new int[2*n];\n\t\tfill(d, INF);d[0] = 0;\n\t\tfor(;;) {\n\t\t\tint v = -1;\n\t\t\tfor(int u=0;u<2*n;u++) if(!used[u] && (v == -1 || d[v] > d[u])) v = u;\n\t\t\tif(v == -1) {\n//\t\t\t\tdebug(path);\n\t\t\t\treturn d[2*n-1];\n\t\t\t}\n\t\t\t\n\t\t\tused[v] = true;\n\t\t\tfor(int u=0;u<2*n;u++) {\n\t\t\t\tpath[u] = d[u] > d[v] + es[v][u]? v: path[u];\n\t\t\t\td[u] = min(d[u], d[v] + es[v][u]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean isCross(P s, P e, int p, int q) {\n//\t\tdebug(s.x, s.y, e.x, e.y);\n\t\tfor(int i=p;i<q;i++) {\n\t\t\tif(!cross(s, e, cps[i][0], cps[i][1])) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\t\n\n\tP[] circleIntersection(P a, P b, double r1, double r2) {\n\t\tP AB = b.sub(a);\n\n\t\tdouble ab = AB.abs();\n\t\tdouble ai = ( r1*r1 - r2*r2 + ab*ab ) / ( 2 * ab );\n\t\tP AI = AB.mlt(ai/ab);\n\n\t\tdouble ip = sqrt( r1*r1 - ai * ai);\n\t\tP IP = new P(AB.y * ip/ab, -AB.x* ip/ab);\n\n\t\tP P1 = a.add(AI).add(IP);\n\n\t\tIP = IP.mlt(-1.0);\n\t\tP P2 = a.add(AI).add(IP);\n\t\t\n//\t\tdebug(ab, ai, ip);\n//\t\tdebug(\"P1:\", P1.x, P1.y);\n//\t\tdebug(\"P2:\", P2.x, P2.y);\n\t\t\n\t\t\n\t\treturn new P[] {P1, P2};\n\t}\n\t\n\t//線分交差判定\n\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t}\n\n\t//時計回りなのか．反時計回りなのか，直線状なのか，とにかく位置関係をみる\n\tint ccw (P a, P b, P c) {\n\t\tP s = b.sub(a);\n\t\tP t = c.sub(a);\n\t\tif( s.det(t) > EPS ) return 1;\n\t\tif( s.det(t) < -EPS ) return -1;\n\t\tif( s.dot(t) < -EPS ) return 2;\n\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\treturn 0;\n\t}\n\t\n\tclass C {\n\t\tP p;\n\t\tdouble r;\n\t\tC(double x, double y, double r) {\n\t\t\tp = new P(x, y);\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\t\n\tclass P {\n\t\tdouble EPS = 1e-10;\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble add(double a, double b) {\n\t\t\t//誤差を考慮\n\t\t\tif( Math.abs(a+b) < EPS * ( Math.abs(a) + Math.abs(b) ) ) return 0;\n\t\t\treturn a + b;\n\t\t}\n\n\t\tP add(P p) {\t//和\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p) {\t//差\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\n\t\tP mlt(double k) {\n\t\t\treturn new P(x*k, y*k);\n\t\t}\n\n\t\tdouble dot(P p) {\t//内積\n\t\t\t\treturn add(x*p.x, y*p.y);\n\t\t}\n\n\t\tdouble det(P p) {\t//外積\n\t\t\treturn add(x*p.y, -y*p.x);\n\t\t}\n\n\t\tdouble abs() {\n\t\t\tdouble ret = sqrt( add(x*x, y*y) );\n\t\t\tif ( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble abs(P p) {\n\t\t\tdouble dx = add( x, -p.x );\n\t\t\tdouble dy = add( y, -p.y );\n\t\t\tdouble ret = sqrt( add(dx*dx, dy*dy) );\n\t\t\tif( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tdouble[] r = new double[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tdouble[][] p = new double[2 * n][];\n\t\t\tp[0] = new double[] { x[0], y[0] };\n\t\t\tp[2 * n - 1] = new double[] { x[n - 1], y[n - 1] };\n\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tdouble a = -2 * (x[i] - x[i + 1]);\n\t\t\t\tdouble b = -2 * (y[i] - y[i + 1]);\n\t\t\t\tdouble c = x[i] * x[i] - x[i + 1] * x[i + 1] + y[i] * y[i] - y[i + 1] * y[i + 1] - r[i] * r[i]\n\t\t\t\t\t\t+ r[i + 1] * r[i + 1];\n\n\t\t\t\tdouble w = -c * a / (a * a + b * b);\n\t\t\t\tdouble v = -c * b / (a * a + b * b);\n\n\t\t\t\tdouble f = 1 / (a * a + b * b) * (-b * (w - x[i]) + a * (v - y[i]));\n\t\t\t\tdouble g = 1 / (a * a + b * b) * ((w - x[i]) * (w - x[i]) + (v - y[i]) * (v - y[i]) - r[i] * r[i]);\n\t\t\t\tdouble t1 = -f + Math.sqrt(f * f - g);\n\t\t\t\tdouble t2 = -f - Math.sqrt(f * f - g);\n\t\t\t\tp[2 * i + 1] = new double[] { w - b * t1, v + a * t1 };\n\t\t\t\tp[2 * i + 2] = new double[] { w - b * t2, v + a * t2 };\n\n\t\t\t}\n\n\t\t\tLine2D.Double[] seg = new Line2D.Double[n - 1];\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tseg[i] = new Line2D.Double(p[2 * i + 1][0], p[2 * i + 1][1], p[2 * i + 2][0], p[2 * i + 2][1]);\n\t\t\t}\n\n\t\t\tdouble[][] dis = new double[2 * n][2 * n];\n\t\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\t\tfor (int j = 0; j < 2 * n; ++j) {\n\t\t\t\t\tif (i != j)\n\t\t\t\t\t\tdis[i][j] = Double.MAX_VALUE / 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int src = 0; src < 2 * n; ++src) {\n\t\t\t\tfor (int dst = src + 1; dst < 2 * n; ++dst) {\n\t\t\t\t\tint s = (src == 0 ? -1 : (src - 1) / 2) + 1;\n\t\t\t\t\tint d = (dst - 1) / 2 - 1;\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tLine2D.Double path = new Line2D.Double(p[src][0], p[src][1], p[dst][0], p[dst][1]);\n\t\t\t\t\tfor (int i = s; i <= d; ++i) {\n\t\t\t\t\t\tif (!path.intersectsLine(seg[i]))\n\t\t\t\t\t\t\tf = false;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tdouble distance = Math.sqrt((p[src][0] - p[dst][0]) * (p[src][0] - p[dst][0])\n\t\t\t\t\t\t\t\t+ (p[src][1] - p[dst][1]) * (p[src][1] - p[dst][1]));\n\t\t\t\t\t\tdis[src][dst] = distance;\n\t\t\t\t\t\tdis[dst][src] = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int mid = 0; mid < 2 * n; ++mid) {\n\t\t\t\tfor (int src = 0; src < 2 * n; ++src) {\n\t\t\t\t\tfor (int dst = 0; dst < 2 * n; ++dst) {\n\t\t\t\t\t\tdis[src][dst] = Math.min(dis[src][dst], dis[src][mid] + dis[mid][dst]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dis[0][2 * n - 1]);\n\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Line2D.Double;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tdouble[] x = new double[2*n];\n\t\t\tdouble[] y = new double[2*n];\n\t\t\tLine2D.Double[] cross = new Line2D.Double[n];\n\t\t\tLine2D.Double p = new Line2D.Double();\n\t\t\tdouble[][] cost = new double[2*n][2*n];\n\t\t\tfor(int i=0;i<2*n;i++) Arrays.fill(cost[i], Integer.MAX_VALUE);\n\t\t\t\n\t\t\tint cnt = 1;\n\t\t\t\n\t\t\tdouble xa = sc.nextDouble();\n\t\t\tdouble ya = sc.nextDouble();\n\t\t\tdouble ra = sc.nextDouble();\n\t\t\tdouble xb = 0;\n\t\t\tdouble yb = 0;\n\t\t\tdouble rb = 0;\n\t\t\tdouble x1 = 0;\n\t\t\tdouble x2 = 0;\n\t\t\tdouble y1 = 0;\n\t\t\tdouble y2 = 0;\n\t\t\tdouble a, b, c, A, B, C;\n\t\t\t\n\t\t\tx[0] = xa;\n\t\t\ty[0] = ya;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\txb = sc.nextDouble();\n\t\t\t\tyb = sc.nextDouble();\n\t\t\t\trb = sc.nextDouble();\n\t\t\t\t\n\t\t\t\tA = xa-xb;\n\t\t\t\tB = ya-yb;\n\t\t\t\tC = (A*xa+A*xb+B*ya+B*yb+rb*rb-ra*ra)/2;\n\t\t\t\tif(A==0){\n\t\t\t\t\tc = (C/B-ya)*(C/B-ya)+xa*xa-ra*ra;\n\t\t\t\t\tx1 = xa+Math.sqrt(xa*xa-c);\n\t\t\t\t\tx2 = xa-Math.sqrt(xa*xa-c);\n\t\t\t\t\ty1 = C/B;\n\t\t\t\t\ty2 = C/B;\n\t\t\t\t}else if(B==0){\n\t\t\t\t\tc = (C/A-xa)*(C/A-xa)+ya*ya-ra*ra;\n\t\t\t\t\ty1 = ya+Math.sqrt(ya*ya-c);\n\t\t\t\t\ty2 = ya-Math.sqrt(ya*ya-c);\n\t\t\t\t\tx1 = C/A;\n\t\t\t\t\tx2 = C/A;\n\t\t\t\t}else{\n\t\t\t\t\ta = 1+(A*A)/(B*B);\n\t\t\t\t\tb = (2*A*ya*B-2*A*C-2*xa*B*B)/(B*B);\n\t\t\t\t\tc = (C/B-ya)*(C/B-ya)+xa*xa-ra*ra;\n\t\t\t\t\tx1 = (-b+Math.sqrt(b*b-4*a*c))/(2*a);\n\t\t\t\t\tx2 = (-b-Math.sqrt(b*b-4*a*c))/(2*a);\n\t\t\t\t\ty1 = (C-A*x1)/B;\n\t\t\t\t\ty2 = (C-A*x2)/B;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx[cnt] = x1;\n\t\t\t\ty[cnt] = y1;\n\t\t\t\tcnt++;\n\t\t\t\tx[cnt] = x2;\n\t\t\t\ty[cnt] = y2;\n\t\t\t\tcnt++;\n\t\t\t\tcross[i] = new Line2D.Double(x1,y1,x2,y2);\n\t\t\t\t\n\t\t\t\txa = xb;\n\t\t\t\tya = yb;\n\t\t\t\tra = rb;\n\t\t\t}\n\t\t\tx[cnt] = xb;\n\t\t\ty[cnt] = yb;\n\t\t\t\n\t\t\tboolean flag;\n\t\t\tfor(int i=0;i<2*n;i++){\n\t\t\t\tfor(int j=i+1;j<2*n;j++){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tp.setLine(x[i], y[i], x[j], y[j]);\n\t\t\t\t\tfor(int k=(i+1)/2;k<(j+1)/2;k++){\n\t\t\t\t\t\tif(k!=0 && p.intersectsLine(cross[k])==false){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==false){\n\t\t\t\t\t\tcost[i][j] = Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<2*n;i++) cost[i][i] = 0;\n\t\t\tfor(int i=0;i<2*n;i++){\n\t\t\t\tfor(int j=0;j<2*n;j++){\n\t\t\t\t\tfor(int k=0;k<2*n;k++){\n\t\t\t\t\t\tif(cost[j][i]!=Integer.MAX_VALUE && cost[i][k]!=Integer.MAX_VALUE){\n\t\t\t\t\t\t\tcost[j][k] = Math.min(cost[j][k], cost[j][i]+cost[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cost[0][2*n-1]);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Line2D.Double;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tdouble[] x = new double[2*n];\n\t\t\tdouble[] y = new double[2*n];\n\t\t\tLine2D.Double[] cross = new Line2D.Double[n];\n\t\t\tLine2D.Double p = new Line2D.Double();\n\n\t\t\t\n\t\t\tdouble xa = sc.nextDouble();\n\t\t\tdouble ya = sc.nextDouble();\n\t\t\tdouble ra = sc.nextDouble();\n\t\t\tdouble xb = 0;\n\t\t\tdouble yb = 0;\n\t\t\tdouble rb = 0;\n\t\t\tdouble a, b, c, A, B, C;\n\t\t\t\n\t\t\tx[0] = xa;\n\t\t\ty[0] = ya;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\txb = sc.nextDouble();\n\t\t\t\tyb = sc.nextDouble();\n\t\t\t\trb = sc.nextDouble();\n\t\t\t\t\n\t\t\t\tA = xa-xb;\n\t\t\t\tB = ya-yb;\n\t\t\t\tC = (A*xa+A*xb+B*ya+B*yb+rb*rb-ra*ra)/2;\n\t\t\t\tif(A==0){\n\t\t\t\t\tc = (C/B-ya)*(C/B-ya)+xa*xa-ra*ra;\n\t\t\t\t\tx[2*i-1] = xa+Math.sqrt(xa*xa-c);\n\t\t\t\t\tx[2*i] = xa-Math.sqrt(xa*xa-c);\n\t\t\t\t\ty[2*i-1] = C/B;\n\t\t\t\t\ty[2*i] = C/B;\n\t\t\t\t}else if(B==0){\n\t\t\t\t\tc = (C/A-xa)*(C/A-xa)+ya*ya-ra*ra;\n\t\t\t\t\ty[2*i-1] = ya+Math.sqrt(ya*ya-c);\n\t\t\t\t\ty[2*i] = ya-Math.sqrt(ya*ya-c);\n\t\t\t\t\tx[2*i-1] = C/A;\n\t\t\t\t\tx[2*i] = C/A;\n\t\t\t\t}else{\n\t\t\t\t\ta = 1+(A*A)/(B*B);\n\t\t\t\t\tb = (2*A*ya*B-2*A*C-2*xa*B*B)/(B*B);\n\t\t\t\t\tc = (C/B-ya)*(C/B-ya)+xa*xa-ra*ra;\n\t\t\t\t\tx[2*i-1] = (-b+Math.sqrt(b*b-4*a*c))/(2*a);\n\t\t\t\t\tx[2*i] = (-b-Math.sqrt(b*b-4*a*c))/(2*a);\n\t\t\t\t\ty[2*i-1] = (C-A*x[2*i-1])/B;\n\t\t\t\t\ty[2*i] = (C-A*x[2*i])/B;\n\t\t\t\t}\n\t\t\t\tcross[i] = new Line2D.Double(x[2*i-1],y[2*i-1],x[2*i],y[2*i]);\n\t\t\t\t\n\t\t\t\txa = xb;\n\t\t\t\tya = yb;\n\t\t\t\tra = rb;\n\t\t\t}\n\t\t\tx[2*n-1] = xb;\n\t\t\ty[2*n-1] = yb;\n\t\t\t\n\t\t\tdouble[][] cost = new double[2*n][2*n];\n\t\t\tfor(int i=0;i<2*n;i++) Arrays.fill(cost[i], Integer.MAX_VALUE);\t\t\t\n\t\t\tboolean flag;\n\t\t\tfor(int i=0;i<2*n;i++){\n\t\t\t\tfor(int j=i+1;j<2*n;j++){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tp.setLine(x[i], y[i], x[j], y[j]);\n\t\t\t\t\tfor(int k=(i+1)/2;k<(j+1)/2;k++){\n\t\t\t\t\t\tif(k!=0 && p.intersectsLine(cross[k])==false){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==false)\tcost[i][j] = Math.sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<2*n;i++) cost[i][i] = 0;\n\t\t\tfor(int i=0;i<2*n;i++){\n\t\t\t\tfor(int j=0;j<2*n;j++){\n\t\t\t\t\tfor(int k=0;k<2*n;k++){\n\t\t\t\t\t\tif(cost[j][i]!=Integer.MAX_VALUE && cost[i][k]!=Integer.MAX_VALUE){\n\t\t\t\t\t\t\tcost[j][k] = Math.min(cost[j][k], cost[j][i]+cost[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cost[0][2*n-1]);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Chain-Confined Path\npublic class Main{\n\n\tfinal double EPS = 1e-8;\n\t\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble[][] circleCrossPoint(double x1, double y1, double r1, double x2, double y2, double r2){\n\t\tdouble vx = x2-x1, vy = y2-y1, D = Math.sqrt(vx*vx+vy*vy);\n\t\tvx/=D; vy/=D;\n\t\tvx*=r1; vy*=r1;\n\t\tdouble thita = Math.acos((r1*r1+D*D-r2*r2)/(2*r1*D));\n\t\tdouble px = Math.cos(thita)*vx-Math.sin(thita)*vy, py = Math.sin(thita)*vx+Math.cos(thita)*vy;\n\t\tdouble px2 = Math.cos(-thita)*vx-Math.sin(-thita)*vy, py2 = Math.sin(-thita)*vx+Math.cos(-thita)*vy;\n\t\tdouble[][] res = new double[2][2];\n\t\tres[0][0] = x1+px; res[0][1] = y1+py;\n\t\tres[1][0] = x1+px2; res[1][1] = y1+py2;\n\t\treturn res;\n\t}\n\t\n\tint INF = 1<<29;\n\tdouble[][] dist;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tdouble[] cx = new double[n], cy = new double[n], r = new double[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcx[i] = sc.nextDouble(); cy[i] = sc.nextDouble(); r[i] = sc.nextDouble();\n\t\t\t}\n\t\t\tdouble[][] x = new double[n+1][2], y = new double[n+1][2];\n\t\t\tx[0][0] = x[0][1] = cx[0];\n\t\t\ty[0][0] = y[0][1] = cy[0];\n\t\t\tx[n][0] = x[n][1] = cx[n-1];\n\t\t\ty[n][0] = y[n][1] = cy[n-1];\n\t\t\tfor(int i=0;i+1<n;i++){\n\t\t\t\tdouble[][] p = circleCrossPoint(cx[i], cy[i], r[i], cx[i+1], cy[i+1], r[i+1]);\n\t\t\t\tx[i+1][0] = p[0][0]; y[i+1][0] = p[0][1];\n\t\t\t\tx[i+1][1] = p[1][0]; y[i+1][1] = p[1][1];\n\t\t\t}\n\t\t\tdouble[][][][] adj = new double[n+1][2][n+1][2];\n\t\t\tfor(int i=0;i<=n;i++)for(int j=0;j<2;j++)for(int k=0;k<=n;k++)for(int l=0;l<2;l++)adj[i][j][k][l] = INF;\n\t\t\tfor(int i=0;i<=n;i++)for(int j=0;j<2;j++)for(int k=i+1;k<=n;k++)for(int l=0;l<2;l++){\n\t\t\t\tboolean ok = true;\n\t\t\t\tdouble[] A = new double[]{x[i][j], y[i][j]}, B = new double[]{x[k][l], y[k][l]};\n\t\t\t\tfor(int m=i+1;m<k;m++){\n\t\t\t\t\tif(ex(A, B, new double[]{x[m][0], y[m][0]}) * ex(A, B, new double[]{x[m][1], y[m][1]}) > -EPS)ok = false;\n\t\t\t\t}\n\t\t\t\tif(ok)adj[i][j][k][l] = norm(A, B);\n\t\t\t}\n\t\t\tdist = new double[n+1][2];\n\t\t\tfor(double[]d:dist)Arrays.fill(d, INF);\n\t\t\tdist[0][0] = dist[0][1] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn (int)Math.signum(dist[o1[0]][o1[1]] - dist[o2[0]][o2[1]]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0, 0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] V = q.poll();\n\t\t\t\tint i = V[0], j = V[1];\n\t\t\t\tfor(int k=i+1;k<=n;k++)for(int l=0;l<2;l++){\n\t\t\t\t\tdouble w = dist[i][j] + adj[i][j][k][l];\n\t\t\t\t\tif(w < dist[k][l]){\n\t\t\t\t\t\tdist[k][l] = w; q.add(new int[]{k, l});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.8f\\n\", dist[n][0]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        double INF = Double.MAX_VALUE / 2;\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            Circle[] cs = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());\n            }\n            Point[] ps = new Point[2 * n];\n            ps[0] = new Point(cs[0].x, cs[0].y);\n            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);\n            int c = 1;\n            Line[] ls = new Line[n - 1];\n            for (int i = 1; i < n; i++) {\n                Point[] cis = cs[i].circleInterSection(cs[i - 1]);\n                ps[c++] = cis[0];\n                ps[c++] = cis[1];\n                ls[i - 1] = new Line(cis[0], cis[1]);\n            }\n            double[][] cost = new double[2 * n][2 * n];\n            for (int i = 0; i < 2 * n; i++) {\n                Arrays.fill(cost[i], INF);\n            }\n            for (int i = 0; i <= 2 * n - 4; i++) {\n                for (int j = i + 1; j < 2 * n; j++) {\n                    if (j % 2 == 0) {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            cost[i][j] = l1.length();\n                        }\n                    } else {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            cost[i][j] = l1.length();\n                        }\n                    }\n                }\n            }\n            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])\n                    .length();\n            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])\n                    .length();\n            for (int k = 0; k < 2 * n; k++) {\n                for (int i = 0; i < 2 * n; i++) {\n                    if (k < i)\n                        break;\n                    for (int j = i + 1; j < 2 * n; j++) {\n                        cost[i][j] = Math.min(cost[i][j], cost[i][k]\n                                + cost[k][j]);\n                    }\n                }\n            }\n            System.out.printf(\"%.5f\\n\", cost[0][2 * n - 1]);\n        }\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Point extends Point2D.Double {\n    Point(int x, int y) {\n        super(x, y);\n    }\n\n    Point(double x, double y) {\n        super(x, y);\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Line extends Line2D.Double {\n\n    Line(Point p1, Point p2) {\n        super(p1, p2);\n    }\n\n    public double length() {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    public double ip(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);\n    }\n\n    public double ep(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);\n    }\n}\n\nclass Circle {\n    int x;\n    int y;\n    int r;\n\n    Circle(int x, int y, int r) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n    }\n\n    public Point[] circleInterSection(Circle c2) {\n        Circle c1 = this;\n        double a = c1.x;\n        double b = c1.y;\n        double r = c1.r;\n        double c = c2.x;\n        double d = c2.y;\n        double s = c2.r;\n        double norm = (c - a) * (c - a) + (d - b) * (d - b);\n        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);\n        double th = Math.acos(t / r);\n        double th0 = Math.atan2((d - b), (c - a));\n        double p1 = a + r * Math.cos(th + th0);\n        double q1 = b + r * Math.sin(th + th0);\n        double p2 = a + r * Math.cos(-th + th0);\n        double q2 = b + r * Math.sin(-th + th0);\n        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };\n        return ps;\n    }\n    public String toString() {\n        return \"x,y,r \" + x + \" \" + y + \" \" + r + \" \";\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\npublic class Main{\n\tdouble EPS = 1.0e-08;\n\tint INF = 1 << 24;\n\t//1240 start\n\t//1333 cording end\n\t//2325 restart\n\t//0007 sample match\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tCircle [] clist = new Circle[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tPoint2D p = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\tclist[i] = new Circle(p, sc.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Point2D> cand = new ArrayList<Point2D>();\n\t\t\tcand.add(clist[0].p);\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tPoint2D [] res = intersectPtCC(clist[i], clist[i+1]);\n\t\t\t\tcand.add(res[0]);\n\t\t\t\tcand.add(res[1]);\n\t\t\t}\n\t\t\tcand.add(clist[n-1].p);\n\t\t\t\n\t\t\tint len = cand.size();\n\t\t\tdouble [][] dp = new double[len][len];\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t\tdp[i][i] = 0.0;\n\t\t\t}\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfor(int j = i + 1; j < len; j++){\n\t\t\t\t\tboolean isOK = true;\n\t\t\t\t\tLine2D m = new Line2D.Double(cand.get(i), cand.get(j));\n\t\t\t\t\tfor(int k = j - 2; k > i; k -= 2){\n\t\t\t\t\t\tLine2D l;\n\t\t\t\t\t\tif(k % 2 == 0){\n\t\t\t\t\t\t\tl = new Line2D.Double(cand.get(k-1), cand.get(k));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl = new Line2D.Double(cand.get(k), cand.get(k + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(! m.intersectsLine(l)){\n\t\t\t\t\t\t\tisOK = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(isOK){\n\t\t\t\t\t\tdp[i][j] = cand.get(i).distance(cand.get(j));\n\t\t\t\t\t\tdp[j][i] = cand.get(i).distance(cand.get(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[0][len-1] == INF){\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\t\t\tfor(int k = 0; k < len; k++){\n\t\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][k], dp[i][j] + dp[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\",dp[0][len-1]);\n\t\t}\n\t}\n\t\n\tpublic class Circle{\n\t\tPoint2D p;\n\t\tdouble r;\n\t\tpublic Circle(Point2D p, double r) {\n\t\t\tthis.p = p; this.r = r;\n\t\t}\n\t}\n\t\n\t//円と円の交点\n\tPoint2D [] intersectPtCC(Circle a,Circle b) {\n\t\tdouble dis = a.p.distance(b.p);\n\t\tPoint2D v = sub(b.p, a.p);\n\t\tdouble rc = (dis * dis + a.r * a.r - b.r * b.r) / (2 * dis);\n\t\tdouble rate = rc / dis;\n\t\tv = mul(v, rate);\n\t\tPoint2D c = add(v, a.p);\n\t\tdouble disC2c = c.distance(b.p);\n\t\tdouble disqc = Math.sqrt(b.r * b.r - disC2c * disC2c);\n\t\tPoint2D v2 = sub(b.p, c);\n\t\tv2 = mul(v2, disqc / disC2c);\n\t\tPoint2D [] res = new Point2D[2];\n\t\tres[0] = add(normalV1(v2), c);\n\t\tres[1] = add(normalV2(v2), c);\n\t\treturn res;\n\t}\n\t\n\tprivate Point2D normalV1(Point2D p) {\n\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t}\n\t\n\tprivate Point2D normalV2(Point2D p) {\n\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t}\n\n\tprivate Point2D add(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() + p2.getX();\n\t\tdouble y = p1.getY() + p2.getY();\n\t\treturn new Point2D.Double(x,y);\n\t}\n\n\tprivate Point2D mul(Point2D v, double rate) {\n\t\treturn new Point2D.Double(v.getX() * rate, v.getY() * rate);\n\t}\n\n\tprivate Point2D sub(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x,y);\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        double INF = Double.MAX_VALUE / 2;\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            Circle[] cs = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());\n            }\n            Point[] ps = new Point[2 * n];\n            ps[0] = new Point(cs[0].x, cs[0].y);\n            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);\n            int c = 1;\n            Line[] ls = new Line[n - 1];\n            for (int i = 1; i < n; i++) {\n                Point[] cis = cs[i].circleInterSection(cs[i - 1]);\n                ps[c++] = cis[0];\n                ps[c++] = cis[1];\n                ls[i - 1] = new Line(cis[0], cis[1]);\n            }\n            double[][] cost = new double[2 * n][2 * n];\n            for (int i = 0; i < 2 * n; i++) {\n                Arrays.fill(cost[i], INF);\n            }\n            for (int i = 0; i <= 2 * n - 4; i++) {\n                for (int j = i + 1; j < 2 * n; j++) {\n                    if (j % 2 == 0) {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            cost[i][j] = l1.length();\n                        }\n                    } else {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            cost[i][j] = l1.length();\n                        }\n                    }\n                }\n            }\n            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])\n                    .length();\n            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])\n                    .length();\n            for (int k = 0; k < 2 * n; k++) {\n                for (int i = 0; i < 2 * n; i++) {\n                    if (k < i)\n                        break;\n                    for (int j = i + 1; j < 2 * n; j++) {\n                        cost[i][j] = Math.min(cost[i][j], cost[i][k]\n                                + cost[k][j]);\n                    }\n                }\n            }\n            System.out.printf(\"%.5f\\n\", cost[0][2 * n - 1]);\n        }\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Point extends Point2D.Double {\n    Point(int x, int y) {\n        super(x, y);\n    }\n\n    Point(double x, double y) {\n        super(x, y);\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Line extends Line2D.Double {\n\n    Line(Point p1, Point p2) {\n        super(p1, p2);\n    }\n\n    public double length() {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    public double ip(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);\n    }\n\n    public double ep(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);\n    }\n}\n\nclass Circle {\n    int x;\n    int y;\n    int r;\n\n    Circle(int x, int y, int r) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n    }\n\n    public Point[] circleInterSection(Circle c2) {\n        Circle c1 = this;\n        double a = c1.x;\n        double b = c1.y;\n        double r = c1.r;\n        double c = c2.x;\n        double d = c2.y;\n        double s = c2.r;\n        double norm = (c - a) * (c - a) + (d - b) * (d - b);\n        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);\n        double th = Math.acos(t / r);\n        double th0 = Math.atan2((d - b), (c - a));\n        double p1 = a + r * Math.cos(th + th0);\n        double q1 = b + r * Math.sin(th + th0);\n        double p2 = a + r * Math.cos(-th + th0);\n        double q2 = b + r * Math.sin(-th + th0);\n        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };\n        return ps;\n    }\n    public String toString() {\n        return \"x,y,r \" + x + \" \" + y + \" \" + r + \" \";\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\npublic class Main{\n\tdouble EPS = 1.0e-08;\n\tint INF = 1 << 24;\n\t//1240 start\n\t//1333 cording end\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tCircle [] clist = new Circle[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tPoint2D p = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\tclist[i] = new Circle(p, sc.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Point2D> cand = new ArrayList<Point2D>();\n\t\t\tcand.add(clist[0].p);\n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tPoint2D [] res = clist[i].intersectPtCC(clist[i+1]);\n\t\t\t\tcand.add(res[0]);\n\t\t\t\tcand.add(res[1]);\n\t\t\t}\n\t\t\tcand.add(clist[n-1].p);\n\t\t\t\n\t\t\tint len = cand.size();\n\t\t\tdouble [][] dp = new double[len][len];\n\t\t\tfor(int i = 0 ; i < len; i++){\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t\tdp[i][i] = 0.0;\n\t\t\t}\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfor(int j = i + 1; j < len; j++){\n\t\t\t\t\t//dp[i][j]の直線が大丈夫ならdp[i][j].distanceでよい\n\t\t\t\t\tboolean isOK = true;\n\t\t\t\t\tLine2D m = new Line2D.Double(cand.get(i), cand.get(j));\n\t\t\t\t\tfor(int k = j - 2; k > i; k -= 2){\n\t\t\t\t\t\tLine2D l;\n\t\t\t\t\t\tif(k % 2 == 0){\n\t\t\t\t\t\t\tl = new Line2D.Double(cand.get(k-1), cand.get(k));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl = new Line2D.Double(cand.get(k), cand.get(k + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(! m.intersectsLine(l)){\n\t\t\t\t\t\t\tisOK = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(isOK){\n\t\t\t\t\t\tdp[i][j] = cand.get(i).distance(cand.get(j));\n\t\t\t\t\t\tdp[j][i] = cand.get(i).distance(cand.get(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//debug\n//\t\t\tSystem.out.println(\"dp = \");\n//\t\t\tfor(int i = 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < len; j++){\n//\t\t\t\t\tif(dp[i][j] >= INF){\n//\t\t\t\t\t\tSystem.out.print(\"INF \");\t\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.printf(\"%.1f \",dp[i][j]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\t\tfor(int k = 0; k < len; k++){\n\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][k], dp[i][j] + dp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\",dp[0][len-1]);\n\t\t\t//debug\n//\t\t\tSystem.out.println(cand.toString());\n//\t\t\tSystem.out.println(\"dp = \");\n//\t\t\tfor(int i = 0; i < len; i++){\n//\t\t\t\tfor(int j = 0; j < len; j++){\n//\t\t\t\t\tif(dp[i][j] >= INF){\n//\t\t\t\t\t\tSystem.out.print(\"INF \");\t\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.printf(\"%.1f \",dp[i][j]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic class Circle{\n\t\tPoint2D p;\n\t\tdouble r;\n\t\tpublic Circle(Point2D p, double r) {\n\t\t\tthis.p = p; this.r = r;\n\t\t}\n\t\t\n\t\t//円と円の交点\n\t\t\n\t\tPoint2D [] intersectPtCC(Circle c2) {\n\t\t\tdouble dis = this.p.distance(c2.p);\n\t\t\tPoint2D v = sub(c2.p, this.p);\n\t\t\tdouble rc = (dis * dis + this.r * this.r - c2.r * c2.r) / (2 * dis);\n\t\t\tdouble rate = rc / dis;\n\t\t\tv = mul(v, rate);\n\t\t\tPoint2D c = add(v, this.p);\n\t\t\t\n\t\t\tdouble disC2c = c.distance(c2.p);\n\t\t\tdouble disqc = Math.sqrt(c2.r * c2.r - disC2c * disC2c);\n\t\t\tPoint2D v2 = sub(c2.p, c);\n\t\t\tv2 = mul(v2, disqc / disC2c);\n\t\t\tPoint2D [] res = new Point2D[2];\n\t\t\tres[0] = add(normalV1(v2), c);\n\t\t\tres[1] = add(normalV2(v2), c);\n\t\t\treturn res;\n\t\t}\n\t\tprivate Point2D normalV1(Point2D p) {\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\t\n\t\tprivate Point2D normalV2(Point2D p) {\n\t\t\treturn new Point2D.Double(p.getY(), -p.getX());\n\t\t}\n\n\t\tprivate Point2D add(Point2D p1, Point2D p2) {\n\t\t\tdouble x = p1.getX() + p2.getX();\n\t\t\tdouble y = p1.getY() + p2.getY();\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\n\t\tprivate Point2D mul(Point2D v, double rate) {\n\t\t\treturn new Point2D.Double(v.getX() * rate, v.getY() * rate);\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p1, Point2D p2) {\n\t\t\tdouble x = p1.getX() - p2.getX();\n\t\t\tdouble y = p1.getY() - p2.getY();\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tdouble[] x = new double[n];\n\t\t\tdouble[] y = new double[n];\n\t\t\tdouble[] r = new double[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tx[i] = sc.nextDouble();\n\t\t\t\ty[i] = sc.nextDouble();\n\t\t\t\tr[i] = sc.nextDouble();\n\t\t\t}\n\n\t\t\tdouble[][] p = new double[2 * n][];\n\t\t\tp[0] = new double[] { x[0], y[0] };\n\t\t\tp[2 * n - 1] = new double[] { x[n - 1], y[n - 1] };\n\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tdouble a = -2 * (x[i] - x[i + 1]);\n\t\t\t\tdouble b = -2 * (y[i] - y[i + 1]);\n\t\t\t\tdouble c = x[i] * x[i] - x[i + 1] * x[i + 1] + y[i] * y[i] - y[i + 1] * y[i + 1] - r[i] * r[i]\n\t\t\t\t\t\t+ r[i + 1] * r[i + 1];\n\n\t\t\t\tdouble w = -c * a / (a * a + b * b);\n\t\t\t\tdouble v = -c * b / (a * a + b * b);\n\n\t\t\t\tdouble f = 1 / (a * a + b * b) * (-b * (w - x[i]) + a * (v - y[i]));\n\t\t\t\tdouble g = 1 / (a * a + b * b) * ((w - x[i]) * (w - x[i]) + (v - y[i]) * (v - y[i]) - r[i] * r[i]);\n\t\t\t\tdouble t1 = -f + Math.sqrt(f * f - g);\n\t\t\t\tdouble t2 = -f - Math.sqrt(f * f - g);\n\t\t\t\tp[2 * i + 1] = new double[] { w - b * t1, v + a * t1 };\n\t\t\t\tp[2 * i + 2] = new double[] { w - b * t2, v + a * t2 };\n\n\t\t\t}\n\n\t\t\tLine2D.Double[] seg = new Line2D.Double[n - 1];\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tseg[i] = new Line2D.Double(p[2 * i + 1][0], p[2 * i + 1][1], p[2 * i + 2][0], p[2 * i + 2][1]);\n\t\t\t}\n\n\t\t\tdouble[][] dis = new double[2 * n][2 * n];\n\t\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\t\tfor (int j = 0; j < 2 * n; ++j) {\n\t\t\t\t\tif (i != j)\n\t\t\t\t\t\tdis[i][j] = Double.MAX_VALUE / 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int src = 0; src < 2 * n; ++src) {\n\t\t\t\tfor (int dst = src + 1; dst < 2 * n; ++dst) {\n\t\t\t\t\tint s = (src == 0 ? -1 : (src - 1) / 2) + 1;\n\t\t\t\t\tint d = (dst - 1) / 2 - 1;\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tLine2D.Double path = new Line2D.Double(p[src][0], p[src][1], p[dst][0], p[dst][1]);\n\t\t\t\t\tfor (int i = s; i <= d; ++i) {\n\t\t\t\t\t\tif (!path.intersectsLine(seg[i]))\n\t\t\t\t\t\t\tf = false;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tdouble distance = Math.sqrt((p[src][0] - p[dst][0]) * (p[src][0] - p[dst][0])\n\t\t\t\t\t\t\t\t+ (p[src][1] - p[dst][1]) * (p[src][1] - p[dst][1]));\n\t\t\t\t\t\tdis[src][dst] = distance;\n\t\t\t\t\t\tdis[dst][src] = distance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int mid = 0; mid < 2 * n; ++mid) {\n\t\t\t\tfor (int src = 0; src < 2 * n; ++src) {\n\t\t\t\t\tfor (int dst = 0; dst < 2 * n; ++dst) {\n\t\t\t\t\t\tdis[src][dst] = Math.min(dis[src][dst], dis[src][mid] + dis[mid][dst]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpw.println(dis[0][2 * n - 1]);\n\n\t\t}\n\t\tsc.close();\n\t\tpw.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        double INF = Double.MAX_VALUE / 2;\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            Circle[] cs = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());\n            }\n            Point[] ps = new Point[2 * n];\n            ps[0] = new Point(cs[0].x, cs[0].y);\n            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);\n            int c = 1;\n            Line[] ls = new Line[n - 1];\n            for (int i = 1; i < n; i++) {\n                Point[] cis = cs[i].circleInterSection(cs[i - 1]);\n                ps[c++] = cis[0];\n                ps[c++] = cis[1];\n                ls[i - 1] = new Line(cis[0], cis[1]);\n            }\n            double[][] cost = new double[2 * n][2 * n];\n            for (int i = 0; i < 2 * n; i++) {\n                Arrays.fill(cost[i], INF);\n            }\n            for (int i = 0; i <= 2 * n - 4; i++) {\n                for (int j = i + 1; j < 2 * n; j++) {\n                    if (j % 2 == 0) {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            cost[i][j] = l1.length();\n                        }\n                    } else {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            cost[i][j] = l1.length();\n                        }\n                    }\n                }\n            }\n            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])\n                    .length();\n            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])\n                    .length();\n            for (int k = 0; k < 2 * n; k++) {\n                for (int i = 0; i < 2 * n; i++) {\n                    if (k < i)\n                        break;\n                    for (int j = i + 1; j < 2 * n; j++) {\n                        cost[i][j] = Math.min(cost[i][j], cost[i][k]\n                                + cost[k][j]);\n                    }\n                }\n            }\n            System.out.printf(\"%.5f\\n\", cost[0][2 * n - 1]);\n        }\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Point extends Point2D.Double {\n    Point(int x, int y) {\n        super(x, y);\n    }\n\n    Point(double x, double y) {\n        super(x, y);\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Line extends Line2D.Double {\n\n    Line(Point p1, Point p2) {\n        super(p1, p2);\n    }\n\n    public double length() {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    public double ip(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);\n    }\n\n    public double ep(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);\n    }\n}\n\nclass Circle {\n    int x;\n    int y;\n    int r;\n\n    Circle(int x, int y, int r) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n    }\n\n    public Point[] circleInterSection(Circle c2) {\n        Circle c1 = this;\n        double a = c1.x;\n        double b = c1.y;\n        double r = c1.r;\n        double c = c2.x;\n        double d = c2.y;\n        double s = c2.r;\n        double norm = (c - a) * (c - a) + (d - b) * (d - b);\n        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);\n        double th = Math.acos(t / r);\n        double th0 = Math.atan2((d - b), (c - a));\n        double p1 = a + r * Math.cos(th + th0);\n        double q1 = b + r * Math.sin(th + th0);\n        double p2 = a + r * Math.cos(-th + th0);\n        double q2 = b + r * Math.sin(-th + th0);\n        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };\n        return ps;\n    }\n    public String toString() {\n        return \"x,y,r \" + x + \" \" + y + \" \" + r + \" \";\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.awt.geom.*;\n\nclass Circle {\n    public Point2D.Double o;\n    public double r;\n    Circle() {\n        this.o = new Point2D.Double(0, 0);\n        this.r = 0;\n    }\n    Circle(Point2D.Double o, double r) {\n        this.o = o;\n        this.r = r;\n    }\n    Point2D.Double[] intersectionPoint(Circle c) {\n        Point2D.Double[] ip = new Point2D.Double[2];\n        double l = o.distance(c.o);\n        double a = Math.atan2(c.o.y - o.y, c.o.x - o.x);\n        double t = Math.acos((r*r - c.r*c.r + l*l) / (2 * l * r));\n        ip[0] = new Point2D.Double(r*Math.cos(a+t) + o.x, r*Math.sin(a+t) + o.y);\n        ip[1] = new Point2D.Double(r*Math.cos(a-t) + o.x, r*Math.sin(a-t) + o.y);\n        return ip;\n    }\n}\n\npublic class Main {\n    int n;\n    Circle[] cs;\n    Point2D.Double[] p;\n    Scanner sc;\n\n    Main() {\n        sc = new Scanner(System.in);\n    }\n\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n        cs = new Circle[n];\n        for (int i = 0; i < n; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            double r = sc.nextDouble();\n            cs[i] = new Circle(new Point2D.Double(x, y), r);\n        }\n\n        p = new Point2D.Double[2*n];\n        p[0] = cs[0].o; p[2*n-1] = cs[n-1].o;\n        for (int i = 0; i < n-1; i++) {\n            Point2D.Double[] _p = cs[i].intersectionPoint(cs[i+1]);\n            p[i*2+1] = _p[0];\n            p[i*2+2] = _p[1];\n        }\n \n//        for (int i = 0; i < 2*n; i++) {\n//            System.out.println(p[i]);\n//        }\n        return true;\n    }\n\n    void run() {\n        while (init()) {\n            double[][] graph = new double[2*n][2*n];\n            for (int i = 0; i < 2*n; i++) {\n                for (int j = 0; j < 2*n; j++) {\n                    Line2D.Double line = new Line2D.Double(p[i], p[j]);\n                    if (0 <= j - i && j - i <= 2) {\n                        graph[i][j] = p[i].distance(p[j]);\n                        graph[j][i] = graph[i][j];\n                    } else {\n                        for (int k = (i+1)/2+1; k < (j+1)/2; k++) {\n                            if (!line.intersectsLine(new Line2D.Double(p[k*2-1], p[k*2]))) {\n//                                System.out.println(\"Line \" + (k*2-1) + \",\" + k*2 + \n//                                        \" and Line \" + i + \",\" + j + \" are not intersects\");\n                                graph[i][j] = 1e18;\n                                break;\n                            }\n                            graph[i][j] = p[i].distance(p[j]);\n                            graph[j][i] = graph[i][j];\n                        }\n                    }\n                }\n            }\n\n//            for (int i = 0; i < 2*n; i++) {\n//                for (int j = 0; j < 2*n; j++) {\n//                    System.out.print(graph[i][j] + \" \");\n//                }\n//                System.out.println(\"\");\n//            }\n\n//            for (int i = 0; i < 2*n; i++)\n//                System.out.print(p[i].x + \",\" + p[i].y + \" \");\n//            System.out.println(\"\");\n\n            for (int i = 0; i < 2*n; i++) {\n                for (int j = 0; j < 2*n; j++) {\n                    if (graph[i][j] == 0) \n                        graph[i][j] = 1e18;\n//                    System.out.print(graph[i][j] + \" \");\n                }\n//                System.out.println(\"\");\n            }\n            for (int k = 0; k < 2*n; k++) \n                for (int i = 0; i < 2*n; i++) \n                    for (int j = 0; j < 2*n; j++) \n                        graph[i][j] = Math.min(graph[i][j], graph[i][k]+graph[k][j]);\n//            for (int i = 0; i < 2*n; i++) {\n//                for (int j = 0; j < 2*n; j++) {\n//                    System.out.print(graph[i][j]);\n//                }\n//                System.out.println(\"\");\n//            }\n            System.out.println(graph[0][2*n-1]);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        double INF = Double.MAX_VALUE / 2;\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            Circle[] cs = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());\n            }\n            Point[] ps = new Point[2 * n];\n            ps[0] = new Point(cs[0].x, cs[0].y);\n            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);\n            int c = 1;\n            Line[] ls = new Line[n - 1];\n            for (int i = 1; i < n; i++) {\n                Point[] cis = cs[i].circleInterSection(cs[i - 1]);\n                ps[c++] = cis[0];\n                ps[c++] = cis[1];\n                ls[i - 1] = new Line(cis[0], cis[1]);\n            }\n            // System.out.println(Arrays.toString(ps));\n            double[][] cost = new double[2 * n][2 * n];\n            for (int i = 0; i < 2 * n; i++) {\n                Arrays.fill(cost[i], INF);\n            }\n            for (int i = 0; i <= 2 * n - 4; i++) {\n                for (int j = i + 1; j < 2 * n; j++) {\n                    if (j % 2 == 0) {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            // System.out.println(i + \" => \" + j);\n                            cost[i][j] = l1.length();\n                        }\n                    } else {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            // System.out.println(i + \" => \" + j);\n                            cost[i][j] = l1.length();\n                        }\n                    }\n                }\n            }\n            // for (int i = 0; i < 2 * n; i++) {\n            // System.out.println(Arrays.toString(cost[i]));\n            // }\n            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])\n                    .length();\n            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])\n                    .length();\n            for (int k = 0; k < 2 * n; k++) {\n                for (int i = 0; i < 2 * n; i++) {\n                    if (k < i)\n                        break;\n                    for (int j = i + 1; j < 2 * n; j++) {\n                        cost[i][j] = Math.min(cost[i][j], cost[i][k]\n                                + cost[k][j]);\n                    }\n                }\n            }\n            System.out.printf(\"%.5f\\n\", cost[0][2 * n - 1]);\n        }\n\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Point extends Point2D.Double {\n    Point(int x, int y) {\n        super(x, y);\n    }\n\n    Point(double x, double y) {\n        super(x, y);\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Line extends Line2D.Double {\n\n    Line(Point p1, Point p2) {\n        super(p1, p2);\n    }\n\n    public double length() {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    public double ip(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);\n    }\n\n    public double ep(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);\n    }\n}\n\nclass Circle {\n    int x;\n    int y;\n    int r;\n\n    Circle(int x, int y, int r) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n    }\n\n    public Point[] circleInterSection(Circle c2) {\n        Circle c1 = this;\n        double a = c1.x;\n        double b = c1.y;\n        double r = c1.r;\n        double c = c2.x;\n        double d = c2.y;\n        double s = c2.r;\n        double norm = (c - a) * (c - a) + (d - b) * (d - b);\n        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);\n        double th = Math.acos(t / r);\n        double th0 = Math.atan2((d - b), (c - a));\n        double p1 = a + r * Math.cos(th + th0);\n        double q1 = b + r * Math.sin(th + th0);\n        double p2 = a + r * Math.cos(-th + th0);\n        double q2 = b + r * Math.sin(-th + th0);\n        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };\n        return ps;\n    }\n\n    public String toString() {\n        return \"x,y,r \" + x + \" \" + y + \" \" + r + \" \";\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        double INF = Double.MAX_VALUE / 2;\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            Circle[] cs = new Circle[n];\n            for (int i = 0; i < n; i++) {\n                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());\n            }\n            Point[] ps = new Point[2 * n];\n            ps[0] = new Point(cs[0].x, cs[0].y);\n            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);\n            int c = 1;\n            Line[] ls = new Line[n - 1];\n            for (int i = 1; i < n; i++) {\n                Point[] cis = cs[i].circleInterSection(cs[i - 1]);\n                ps[c++] = cis[0];\n                ps[c++] = cis[1];\n                ls[i - 1] = new Line(cis[0], cis[1]);\n            }\n            double[][] cost = new double[2 * n][2 * n];\n            for (int i = 0; i < 2 * n; i++) {\n                Arrays.fill(cost[i], INF);\n            }\n            for (int i = 0; i <= 2 * n - 4; i++) {\n                for (int j = i + 1; j < 2 * n; j++) {\n                    if (j % 2 == 0) {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            cost[i][j] = l1.length();\n                        }\n                    } else {\n                        Line l1 = new Line(ps[i], ps[j]);\n                        boolean inCircle = true;\n                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {\n                            Line l2 = ls[k];\n                            if (!l2.intersectsLine(l1)) {\n                                inCircle = false;\n                                break;\n                            }\n                        }\n                        if (inCircle) {\n                            cost[i][j] = l1.length();\n                        }\n                    }\n                }\n            }\n            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])\n                    .length();\n            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])\n                    .length();\n            for (int k = 0; k < 2 * n; k++) {\n                for (int i = 0; i < 2 * n; i++) {\n                    if (k < i)\n                        break;\n                    for (int j = i + 1; j < 2 * n; j++) {\n                        cost[i][j] = Math.min(cost[i][j], cost[i][k]\n                                + cost[k][j]);\n                    }\n                }\n            }\n            System.out.printf(\"%.5f\\n\", cost[0][2 * n - 1]);\n        }\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Point extends Point2D.Double {\n    Point(int x, int y) {\n        super(x, y);\n    }\n\n    Point(double x, double y) {\n        super(x, y);\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass Line extends Line2D.Double {\n\n    Line(Point p1, Point p2) {\n        super(p1, p2);\n    }\n\n    public double length() {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    public double ip(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);\n    }\n\n    public double ep(Line l) {\n        Point q1 = new Point(l.x1, l.y1);\n        Point q2 = new Point(l.x2, l.y2);\n        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);\n    }\n}\n\nclass Circle {\n    int x;\n    int y;\n    int r;\n\n    Circle(int x, int y, int r) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n    }\n\n    public Point[] circleInterSection(Circle c2) {\n        Circle c1 = this;\n        double a = c1.x;\n        double b = c1.y;\n        double r = c1.r;\n        double c = c2.x;\n        double d = c2.y;\n        double s = c2.r;\n        double norm = (c - a) * (c - a) + (d - b) * (d - b);\n        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);\n        double th = Math.acos(t / r);\n        double th0 = Math.atan2((d - b), (c - a));\n        double p1 = a + r * Math.cos(th + th0);\n        double q1 = b + r * Math.sin(th + th0);\n        double p2 = a + r * Math.cos(-th + th0);\n        double q2 = b + r * Math.sin(-th + th0);\n        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };\n        return ps;\n    }\n    public String toString() {\n        return \"x,y,r \" + x + \" \" + y + \" \" + r + \" \";\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#include <complex>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\nR dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    // ax+by+c=0\n    L(R a, R b, R c){\n        if(fabs(a) < eps) *this = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) *this = L(P(-c/a,0),P(-c/a,1));\n        else *this = L(P(-c/a,0), P(0,-c/b));\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p, R r) : p(p), r(r) { }\n    C(){}\n};\n\n// CCW\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return -1; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b 直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c 直線上\n    return 0; // 2点以上が重なっている\n}\n\n// 交差判定\nbool isiLL(const L &l, const L &m) {\n    return\n        abs(cross(l[1]-l[0], m[1]-m[0])) > eps || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < eps;   // same line\n}\n\nbool isiLS(const L &l, const L &s) {\n    return\n        cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < eps; // s[1] is right of l\n}\n\nbool isiLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool isiSS(const L &s, const L &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool isiSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool isiCP(const C &c, const P &p) {\n    // 境界または内部\n    return abs(c.p - p) <= c.r + eps;\n}\n\nint isiCC(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(abs(d - r1 - r2) < eps) return  1; // 接する\n    if(d > r1 + r2)       return  0; // 共通部分を持たない\n    if(d < r1 - r2)       return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)       return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\n\n// 距離\nR dLP(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dLL(const L &l, const L &m) {\n    return isiLL(l, m) ? 0 : dLP(l, m[0]);\n}\n\nR dLS(const L &l, const L &s) {\n    if (isiLS(l, s)) return 0;\n    return min(dLP(l, s[0]), dLP(l, s[1]));\n}\n\nR dSP(const L &s, const P &p) {\n    const P r = proj(s, p);\n    if (isiSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dSS(const L &s, const L &t) {\n    if (isiSS(s, t)) return 0;\n    return min(min(dSP(s, t[0]), dSP(s, t[1])),\n               min(dSP(t, s[0]), dSP(t, s[1])));\n}\n\nR dCP(const C &c, const P &p) {\n    return max(0. , abs(c.p - p));\n}\n\n// 交点\nvector<P> iLL(const L &l, const L &m) {\n    R A = cross(l[1] - l[0], m[1] - m[0]);\n    R B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) throw \"PRECONDITION NOT SATISFIED!!!\";\n    return {m[0] + B / A * (m[1] - m[0])};\n}\n\nvector<P> iSS(const L& s, const L& t) {\n    if(isiSS(s,t)) return iLL(s,t);\n    else return {};\n}\n\nvector<P> iLS(const L& l, const L& s){\n    if(isiLS(l,s)) return iLL(l,s);\n    else return {};\n}\n\n// !!! not verified !!!\nvector<P> iCL(const C& c, const L& l){\n    R d = dLP(l,c.p);\n    // 接する\n    if(abs(d-c.r) < eps) return { proj(l, c.p) };\n    // 共有点を持たない\n    if(d > c.r) return {};\n    P h = proj(l, c.p);\n    P v = h - c.p;\n    P u = v * P(0,1) * sqrt(c.r*c.r - d*d) / abs(v);\n    return {h+u, h-u};\n}\n\n// !!! not verified !!!\nvector<P> iCC(const C& c1, const C& c2){\n    int i = isiCC(c1,c2);\n    // 共通部分なし || 内部\n    if(i==0 || abs(i)==3) return {};\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    // 接する\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d };\n    // 2つの交点\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = -2. * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return iCL(c1, L(A,B,C));\n}\n\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<C> cs(n);\n        rep(i,n){\n            int x,y,r;\n            cin>>x>>y>>r;\n            cs[i] = C(P(x,y),r);\n        }\n\n        int N=n*2;\n        double d[N][N];\n        rep(i,N)rep(j,N){\n            if(i==j)d[i][j]=0;\n            else d[i][j]=inf;\n        }\n\n        for(int i=0;i<n-1;i++){\n            auto ps = iCC(cs[i],cs[i+1]);\n            P &p1=ps[0], &p2=ps[1];\n            d[i*2][i*2+1] = abs(p1-p2);\n            for(int j=i+1;j<n-1;j++){\n                auto qs = iCC(cs[j],cs[j+1]);\n                P &q1=qs[0], &q2=qs[1];\n                L s11(p1,q1), s12(p1,q2), s21(p2,q1), s22(p2,q2);\n                bool ok11 = true, ok12 = true, ok21 = true, ok22 = true;\n                for(int k=i+1;k<=j-1;k++){\n                    auto rs = iCC(cs[k],cs[k+1]);\n                    L s(rs[0],rs[1]);\n                    if(!isiSS(s,s11))ok11=false;\n                    if(!isiSS(s,s12))ok12=false;\n                    if(!isiSS(s,s21))ok21=false;\n                    if(!isiSS(s,s22))ok22=false;\n                }\n                if(ok11){\n                    d[i*2][j*2] = d[j*2][i*2] = abs(p1-q1);\n                }\n                if(ok12){\n                    d[i*2][j*2+1] = d[j*2+1][i*2] = abs(p1-q2);\n                }\n                if(ok21){\n                    d[i*2+1][j*2] = d[j*2][i*2+1] = abs(p2-q1);\n                }\n                if(ok22){\n                    d[i*2+1][j*2+1] = d[j*2+1][i*2+1] = abs(p2-q2);\n                }\n            }\n\n            L s1(ps[0],cs[0].p);\n            L s2(ps[1],cs[0].p);\n            bool oks1 = true, oks2 = true;\n            for(int j=0;j<i;j++){\n                auto t = iCC(cs[j],cs[j+1]);\n                L s(t[0],t[1]);\n                if(!isiSS(s,s1)) oks1 = false;\n                if(!isiSS(s,s2)) oks2 = false;\n            }\n            if(oks1){\n                d[N-1][i*2] = d[i*2][N-1] = abs(s1[0]-s1[1]);\n            }\n            if(oks2){\n                d[N-1][i*2+1] = d[i*2+1][N-1] = abs(s2[0]-s2[1]);\n            }\n            L t1(ps[0],cs[n-1].p);\n            L t2(ps[1],cs[n-1].p);\n            bool okt1 = true, okt2 = true;\n            for(int j=i+1;j<n-1;j++){\n                auto t = iCC(cs[j],cs[j+1]);\n                L s(t[0],t[1]);\n                if(!isiSS(s,t1)) okt1 = false;\n                if(!isiSS(s,t2)) okt2 = false;\n            }\n            if(okt1){\n                d[N-2][i*2] = d[i*2][N-2] = abs(t1[0]-t1[1]);\n            }\n            if(okt2){\n                d[N-2][i*2+1] = d[i*2+1][N-2] = abs(t2[0]-t2[1]);\n            }\n        }\n\n        rep(k,N)rep(i,N)rep(j,N)d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        printf(\"%.10lf\\n\",d[N-1][N-2]);\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "\nclass Graph\n  Infinity = 1000000000\n  attr_accessor :size, :cost\n  def initialize(size, adjacentMatrix=Array.new(n){Array.new(n)})\n    @size = size\n    @cost = adjacentMatrix.map(&:dup)\n\n  end\n  \n  def Dijkstra(from, to)\n    distance = Array.new(@size, Infinity)\n    distance[from] = 0\n    unused = (0...@size).to_a\n    until unused.empty? do\n      current = unused.sort!{|a,b| distance[a]<=>distance[b]}.shift             \n      break if distance[current] == Infinity\n      unused.each do |v|\n        next unless @cost[current][v]\n        distance[v] = [distance[v], distance[current]+@cost[current][v]].min\n\n      end\n    end\n\n    distance[to] == Infinity ? nil : distance[to]\n  end\nend\n\nEPS = 1e-10\n\nclass Class\n  def ===(other)\n    self==other\n  end\nend\n\nclass Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x.to_f, y.to_f\n  end\n\n  def <=>(p)\n    @x != p.x ? @x <=> p.x : @y <=> p.y\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n\n  def times(f)\n    Point.new(@x*f, @y*f)\n  end\n  def dot(p)\n    @x*p.x + @y*p.y\n  end\n  def cross(p)\n    @x*p.y - @y*p.x\n  end\n  def abs\n    Math::hypot(@x, @y)\n  end\n  def norm\n    @x**2 + @y**2\n  end\n  \n  def ccw(b, p)\n    a = self\n    v1, v2 = b-a, p-a\n    return 1 if v1.cross(v2) > 0\n    return -1 if v1.cross(v2) < 0\n    return 2 if v1.dot(v2) < 0\n    return -2 if v1.norm < v2.norm\n    0\n  end\nend\n\nclass Line\n  attr_accessor :a, :b\n  def initialize(p1=Point.new, p2=Point.new)\n    @a, @b = p1, p2\n  end\n\n  \n  def ccw(p)\n    v1, v2 = @b - @a, p - @a\n    return 1 if v1.cross(v2) > 0\n    return -1 if v1.cross(v2) < 0\n    return 2 if v1.dot(v2) < 0\n    return -2 if v1.norm < v2.norm\n    0\n  end\n  \n  def intersect?(target)\n    case target.class\n      when Point\n        v1, v2 = @a-target, @b-target\n        return (v2.cross(v1)).abs == 0.0\n      when Segment\n        v1, v2, v3 = @b-@a, target.a-@a, target.b-@a\n        return v1.cross(v2) * v1.cross(v3) <= 0.0\n      when Line\n        v1, v2, v3 = @b-@a, target.b-target.a, target.a-@a\n        return v1.cross(v2).abs > 0.0 || v1.cross(v3).abs == 0.0\n    end\n  end\n  \n  def projection(p)\n    v1, v2 = p-a, a-b\n    a + v2.times(v1.dot(v2)/v2.norm)\n  end\n  \n  def reflection(p)\n    p + (projection(p) - p).times(2.0)\n  end\n  \n  def distance(target)\n    case target.class\n      when Point\n        return (target - projection(target)).abs\n      when Segment\n        return intersect?(target) ? 0.0 : [distance(target.a), distance(target.b)].min\n      when Line\n        return intersect?(target) ? 0.0 : distance(target.a)\n    end\n  end\n  \n  def crosspoint(l)\n    v1, v2, v3 = @b-@a, l.b-l.a, @b-l.a\n    a, b = v1.cross(v2), v1.cross(v3)\n    return l.a if a.abs == 0.0 && b.abs == 0.0\n    l.a + v2.times(b/a)\n  end\nend\n\nclass Segment < Line\n  \n  def intersect?(target)\n    case target.class\n      when Point\n        return (@a-target).abs + (@b-target).abs == (@b-@a).abs\n      when Segment\n        return target.ccw(@a) * target.ccw(@b) <= 0 && ccw(target.a) * ccw(target.b) <= 0\n      when Line\n        return target.intersect?(self)\n    end\n  end\n  \n  def distance(target)\n    case target.class\n      when Point\n        p = projection(target)\n        return intersect?(p) ? (p-target).abs : [(@a-target).abs, (@b-target).abs].min\n      when Segment\n        return intersect?(target) ? 0.0 : [distance(target.a), distance(target.b), target.distance(@a), target.distance(@b)].min\n      when Line\n        return target.distance(self)\n    end\n  end\nend\n\nclass Circle\n  include Comparable\n  attr_accessor :x, :y, :r\n  def initialize(x=0.0, y=0.0, r=1.0)\n    @x, @y, @r = x.to_f, y.to_f, r.to_f\n  end\n\n  def <=>(c)\n    @x!=c.x ? @x<=>c.x : (@y!=c.y ? @y<=>c.y : @r<=>c.r)\n  end\n\n  def point\n    Point.new(@x, @y)\n  end\n  def distance(c)\n    (point-c.point).abs\n  end\n  \n  def include?(p)\n    (point-p).abs - @r <= EPS\n  end\n  \n  def in?(c)\n    distance(c) - (@r-c.r).abs < EPS\n  end\n  \n  def touch?(c)\n    distance(c) <= @r + c.r     \n  end\n  \n  def crossPoint(c)\n    angle = Math::atan2(c.y-@y, c.x-@x)\n    d = distance(c)\n    add = Math::acos((d**2 + @r**2 - c.r**2) / (2.0*d*@r))\n    p1 = Point.new(@x+@r*Math::cos(angle+add), @y+@r*Math::sin(angle+add))\n    p2 = Point.new(@x+@r*Math::cos(angle-add), @y+@r*Math::sin(angle-add))\n    [p1, p2]\n  end\nend\n\nwhile (n = gets.to_i) != 0\n  circle = Array.new\n  n.times do\n    circle.push(Circle.new(*gets.split.map(&:to_f)))\n  end\n  vertex = Array.new\n  vertex.push(circle.first.point)\n  gate = Array.new\n  (circle.size - 1).times do |i|\n    p = circle[i].crossPoint(circle[i + 1])\n    gate.push(Segment.new(*p))\n    vertex.push(p.pop) until p.empty?\n  end\n  vertex.push(circle.last.point)\n  matrix = Array.new(vertex.size){Array.new(vertex.size)}\n  (0...vertex.size - 1).each do |i|\n    (i + 1...vertex.size).each do |j|\n      edge = Segment.new(vertex[i], vertex[j])\n      firstGate = (i + 1) / 2\n      lastGate = (j + 1) / 2 - 1\n      lastGate -= 1 if j == vertex.size - 1\n      ok = true\n      (firstGate..lastGate).each do |k|\n        ok = false unless edge.intersect?(gate[k])\n      end\n      if ok\n        matrix[i][j] = (vertex[i] - vertex[j]).abs\n      end\n    end\n  end\n\n  g = Graph.new(vertex.size, matrix)\n  p g.Dijkstra(0, vertex.size - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.out_edges << e\n\t\tv.in_edges << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef layers_from(start)\n\t\treached = Set[*start]\n\t\tlayers = [start]\n\n\t\tloop {\n\t\t\tlayers << []\n\t\t\tlayers[-2].each{|u|\n\t\t\t\tu.to_nodes.each{|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tlayers[-1] << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\tif layers[-1].empty?\n\t\t\t\tlayers.pop\n\t\t\t\treturn layers\n\t\t\tend\n\t\t}\n\tend\nend\n\nrequire 'matrix'\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\tcircles = (1..n).map {\n\t\tx, y, r = gets.split.map &:to_f\n\t\t[Vector[x, y], r]\n\t}\n\tcross_points = [[circles[0][0]]]\n\tcircles.each_cons(2){|c1, c2|\n\t\tv1, r1 = c1\n\t\tv2, r2 = c2\n\t\tab = (v1 - v2).r\n\t\tah = (r1**2 - r2**2)/(2*ab) + ab/2\n\t\tph = Math.sqrt(r1**2 - ah**2)\n\t\tl = Vector[(v2[1]-v1[1])/ab, (v1[0]-v2[0])/ab]\n\t\tv = v1 + (v2 - v1) * ah / ab\n\t\tcross_points << [v + l * ph, v - l * ph]\t\n\t}\n\tcross_points << [circles[-1][0]]\n\n\tg = Digraph.new\n\tnodes = {}\n\n\t(0..n-1).each{|i|\n\t\t(i+1..n).each{|j|\n\t\t\tcross_points[i].each{|cp1|\n\t\t\t\tnodes[cp1] ||= g.add_node\n\t\t\t\tcross_points[j].each{|cp2|\n\t\t\t\t\tnodes[cp2] ||= g.add_node\n\t\t\t\t\tu = cp2 - cp1\n\t\t\t\t\tif (i+1..j-1).all?{|k|\n\t\t\t\t\t\tv = cross_points[k][0] - cp1\t\n\t\t\t\t\t\tw = cross_points[k][1] - cp1\t\n\t\t\t\t\t\t(u[0]*v[1]-u[1]*v[0]) * (u[0]*w[1]-u[1]*w[0]) <= 0\n\t\t\t\t\t\t}\n\t\t\t\t\tthen\n\t\t\t\t\t\tg.add_edge(nodes[cp1], nodes[cp2], {:length => (cp2 - cp1).r})\t\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tp g.dijkstra([nodes[circles[0][0]]]){|v| v == nodes[circles[-1][0]]}\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/bin/ruby\nrequire 'complex'\ndef cross(a,b)\n  return a.real*b.imag-a.imag*b.real\nend\nuntil (n=gets.to_i)==0\n  xyr=n.times.map{gets.split.map(&:to_i)}\n  p=xyr.map{|e|Complex(e[0],e[1])}\n  cp=(n-1).times.map{|x|\n    c=(p[x+1]-p[x]).abs\n    theta=Math.acos((1.0*xyr[x][2]**2+c**2-xyr[x+1][2]**2)/(2*xyr[x][2]*c))\n    alpha=(p[x+1]-p[x]).arg\n    [\n     Complex.polar(xyr[x][2],alpha+theta)+p[x],\n     Complex.polar(xyr[x][2],alpha-theta)+p[x]\n    ]\n  }\n  dp=[[0,0,p[0]]]\n  list=(0...cp.size).reduce([]){|r,x|\n    r+[[x+1,cp[x][0]],[x+1,cp[x][1]]]\n  } << [p.size,p[-1]]\n  list.each do |e|\n    d=1e99\n    c=nil\n    dp.each do |f|\n      if (f[0]..e[0]-2).all?{|g|\n          cross(f[2]-e[1],cp[g][0]-e[1])*cross(f[2]-e[1],cp[g][1]-e[1])<0&&\n          cross(cp[g][1]-cp[g][0],f[2]-cp[g][0])*cross(cp[g][1]-cp[g][0],e[1]-cp[g][0])<0\n        }then\n        cd=(e[1]-f[2]).abs+f[1]\n        if cd<d then\n          d=cd\n          c=[e[0],d,e[1]]\n        end\n      end\n    end\n    dp << c\n  end\n  puts dp[-1][1]\nend"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nwhile 1:\n    n = input()\n    if n == 0:\n        break\n    C = [map(int, raw_input().split()) for i in xrange(n)]\n    P = [[C[0][:2]]]\n    # calculate intersections of the circles\n    for i in xrange(n-1):\n        x0, y0, r0 = C[i]\n        x1, y1, r1 = C[i+1]\n        rr = (x1 - x0)**2 + (y1 - y0)**2; rd = sqrt(rr)\n        rc = (r0**2 + rr - r1**2) / (2 * rd); rs = sqrt(4*r0**2*rr - (r0**2 + rr - r1**2)**2) / (2 * rd)\n        ex = (x1 - x0) / rd; ey = (y1 - y0) / rd\n        bx = x0 + ex * rc; by = y0 + ey * rc\n        P.append([(bx + ey * rs, by - ex * rs), (bx - ey * rs, by + ex * rs)])\n    P.append([C[-1][:2]])\n\n    def calc((x0, y0), (x1, y1)):\n        return sqrt((x1 - x0)**2 + (y1 - y0)**2)\n    def cross((x0, y0), (x1, y1), (x2, y2)):\n        return (x1-x0) * (y2-y0) - (x2-x0) * (y1-y0)\n    INF = 10**18\n    dist = {(0, 0): 0}\n    for i in xrange(n):\n        for j, (x, y) in enumerate(P[i]):\n            left = p_left = None; right = p_right = None\n            d = dist[i, j]\n            for k in xrange(i+1, n):\n                lp, rp = P[k]\n                # update left and right\n                if left is None or cross((x, y), left, lp) >= 0:\n                    left = lp\n                if right is None or cross((x, y), rp, right) >= 0:\n                    right = rp\n                # check if left <= right\n                if cross((x, y), left, right) < 0:\n                    break\n\n                # propagate cost from P[i][j] to P[k][0] or P[k][1] if possible\n                if p_left != left:\n                    dist[k, 0] = min(dist.get((k, 0), INF), d + calc((x, y), left))\n                    p_left = left\n                if p_right != right:\n                    dist[k, 1] = min(dist.get((k, 1), INF), d + calc((x, y), right))\n                    p_right = right\n            else:\n                # P[i][j] -> goal\n\n                gp = P[-1][0]\n                # check if left <= goal <= right\n                if (left is None and right is None) or (cross((x, y), left, gp) >= 0 and cross((x, y), gp, right) >= 0):\n                    dist[len(P)-1, 0] = min(dist.get((len(P)-1, 0), INF), d + calc((x, y), gp))\n    print \"%.06f\" % dist[len(P)-1, 0]"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nclass Vec:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __mul__(self, other):\n        return Vec(self.x * other, self.y * other)\n\n    def length(self):\n        return math.sqrt(self.x * self.x + self.y * self.y)\n\n    def __str__(self):\n        return \"({},{})\".format(self.x, self.y)\n\n    def __sub__(self, other):\n        return Vec(self.x - other.x, self.y - other.y)\n\n    def __add__(self, other):\n        return Vec(self.x + other.x, self.y + other.y)\n\n    def __truediv__(self, other):\n        return Vec(self.x / other, self.y / other)\n\n    def turn90(self):\n        return Vec(-self.y, self.x)\n\n    def normalized(self):\n        return self / self.length()\n\n    def is_clock(self, other):\n        return self.x * other.y - self.y * other.x < 0\n\n\nclass Circle:\n    def __init__(self, x, y, r):\n        self.r = r\n        self.center = Vec(x, y)\n\n    def intersection(self, other):\n        d = (self.center - other.center).length()\n        r1 = self.r\n        r2 = other.r\n        d1 = (d * d + r1 * r1 - r2 * r2) / 2 / d\n        x = math.sqrt(r1 * r1 - d1 * d1)\n        e1 = (other.center - self.center).normalized()\n        e2 = e1.turn90()\n\n        p1 = self.center + e1 * d1 + e2 * x\n        p2 = self.center + e1 * d1 - e2 * x\n        return p1, p2\n\n    def __str__(self):\n        return \"({},{})\".format(self.center, self.r)\n\n\ndef solve(ps: [Circle]):\n    intersects = []\n    for i in range(len(ps) - 1):\n        ci = ps[i]\n        ci_next = ps[i + 1]\n        intersection1, intersection2 = ci.intersection(ci_next)\n        intersects.append((intersection1, intersection2))\n\n    res = [[ps[0].center, -1, 0]]  # 候補座標とその深度と左右(0,1)\n    dists = [[2 ** 32, 2 ** 32] for _ in range(len(intersects))]  # 各交点の距離バッファ\n\n    min_path_length = 2 ** 32\n\n    while len(res) != 0:\n        res = sorted(res, key=lambda a: a[1], reverse=True)\n\n        c, depth, lr = res.pop()\n        current_path_length = dists[depth][lr] if depth != -1 else 0\n        if depth == len(intersects) - 1:\n            last_path = ps[-1].center - c\n            min_path_length = min(min_path_length, current_path_length + last_path.length())\n            continue\n\n        l_limit_min, r_limit_min = [a - c for a in intersects[depth + 1]]  # 左右の限界\n        l_limit, r_limit = l_limit_min, r_limit_min  # 到達可能限界\n        l_limit_d, r_limit_d = depth + 1, depth + 1\n\n        for i in range(depth + 2, len(intersects)):\n            l_limit2, r_limit2 = [a - c for a in intersects[i]]\n\n            if l_limit_min.is_clock(l_limit2):  # 限界更新\n                l_limit_min = l_limit2\n                if l_limit2.is_clock(r_limit_min):  # 到達可能なら、こっちも更新\n                    l_limit = l_limit2\n                    l_limit_d = i\n            if r_limit2.is_clock(r_limit_min):  # 限界更新\n                r_limit_min = r_limit2\n                if l_limit_min.is_clock(r_limit2):  # 到達可能なら、こっちも更新\n                    r_limit = r_limit2\n                    r_limit_d = i\n        last_path = ps[-1].center - c\n        if l_limit_min.is_clock(last_path) and last_path.is_clock(r_limit_min):  # この点からゴールまで行ける\n            min_path_length = min(min_path_length, current_path_length + last_path.length())\n            continue\n        if dists[l_limit_d][0] > l_limit.length() + current_path_length:\n            dists[l_limit_d][0] = l_limit.length() + current_path_length\n            res.append([l_limit + c, l_limit_d, 0])\n        if dists[r_limit_d][1] > r_limit.length() + current_path_length:\n            dists[r_limit_d][1] = r_limit.length() + current_path_length\n            res.append([r_limit + c, r_limit_d, 1])\n    return min_path_length\n\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        ps = [Circle(*[int(a) for a in input().split()]) for _ in range(n)]\n\n        print(solve(ps))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nclass Vec:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __mul__(self, other):\n        return Vec(self.x * other, self.y * other)\n\n    def length(self):\n        return math.sqrt(self.x * self.x + self.y * self.y)\n\n    def __str__(self):\n        return \"({},{})\".format(self.x, self.y)\n\n    def __sub__(self, other):\n        return Vec(self.x - other.x, self.y - other.y)\n\n    def __add__(self, other):\n        return Vec(self.x + other.x, self.y + other.y)\n\n    def __truediv__(self, other):\n        return Vec(self.x / other, self.y / other)\n\n    def turn90(self):\n        return Vec(-self.y, self.x)\n\n    def normalized(self):\n        return self / self.length()\n\n    def is_clock(self, other):\n        return self.x * other.y - self.y * other.x < 0\n\n\nclass Circle:\n    def __init__(self, x, y, r):\n        self.r = r\n        self.center = Vec(x, y)\n\n    def intersection(self, other):\n        d = (self.center - other.center).length()\n        r1 = self.r\n        r2 = other.r\n        d1 = (d * d + r1 * r1 - r2 * r2) / 2 / d\n        x = math.sqrt(r1 * r1 - d1 * d1)\n        e1 = (other.center - self.center).normalized()\n        e2 = e1.turn90()\n\n        p1 = self.center + e1 * d1 + e2 * x\n        p2 = self.center + e1 * d1 - e2 * x\n        return p1, p2\n\n    def __str__(self):\n        return \"({},{})\".format(self.center, self.r)\n\n\ndef solve(ps: [Circle]):\n    intersects = []\n    for i in range(len(ps) - 1):\n        ci = ps[i]\n        ci_next = ps[i + 1]\n        intersection1, intersection2 = ci.intersection(ci_next)\n        intersects.append((intersection1, intersection2))\n\n    res = [[ps[0].center, -1, 0]]  # 候補座標とその深度と左右(0,1)\n    dists = [[2 ** 32, 2 ** 32] for _ in range(len(intersects))]  # 各交点の距離バッファ\n\n    min_path_length = 2 ** 32\n\n    while len(res) != 0:\n        res = sorted(res, key=lambda a: a[1], reverse=True)\n\n        c, depth, lr = res.pop()\n        current_path_length = dists[depth][lr] if depth != -1 else 0\n        if depth == len(intersects) - 1:\n            last_path = ps[-1].center - c\n            min_path_length = min(min_path_length, current_path_length + last_path.length())\n            continue\n\n        l_limit_min, r_limit_min = [a - c for a in intersects[depth + 1]]  # 左右の限界\n        l_limit, r_limit = l_limit_min, r_limit_min  # 到達可能限界\n        l_limit_d, r_limit_d = depth + 1, depth + 1\n\n        for i in range(depth + 2, len(intersects)):\n            l_limit2, r_limit2 = [a - c for a in intersects[i]]\n\n            if l_limit_min.is_clock(l_limit2):  # 限界更新\n                l_limit_min = l_limit2\n                if l_limit2.is_clock(r_limit_min):  # 到達可能なら、こっちも更新\n                    l_limit = l_limit2\n                    l_limit_d = i\n            if r_limit2.is_clock(r_limit_min):  # 限界更新\n                r_limit_min = r_limit2\n                if l_limit_min.is_clock(r_limit2):  # 到達可能なら、こっちも更新\n                    r_limit = r_limit2\n                    r_limit_d = i\n\n            # if l_limit.is_clock(l_limit2) and l_limit2.is_clock(r_limit):\n            #     l_limit = l_limit2\n            #     l_limit_d = i\n            # if l_limit.is_clock(r_limit2) and r_limit2.is_clock(r_limit):\n            #     r_limit = r_limit2\n            #     r_limit_d = i\n        last_path = ps[-1].center - c\n        if l_limit.is_clock(last_path) and last_path.is_clock(r_limit):  # この点からゴールまで行ける\n            min_path_length = min(min_path_length, current_path_length + last_path.length())\n            continue\n        if dists[l_limit_d][0] > l_limit.length() + current_path_length:\n            dists[l_limit_d][0] = l_limit.length() + current_path_length\n            res.append([l_limit + c, l_limit_d, 0])\n        if dists[r_limit_d][1] > r_limit.length() + current_path_length:\n            dists[r_limit_d][1] = r_limit.length() + current_path_length\n            res.append([r_limit + c, r_limit_d, 1])\n    return min_path_length\n\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        ps = [Circle(*[int(a) for a in input().split()]) for _ in range(n)]\n\n        print(solve(ps))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from math import acos\n    from cmath import phase, rect, pi\n    \n    from sys import stdin\n    file_input = stdin\n    \n    while True:\n        n = int(file_input.readline())\n        if n == 0:\n            break\n        \n        C = (map(int, file_input.readline().split()) for i in range(n))\n        P = []\n        x, y, r1 = next(C)\n        c1 = x + y * 1j\n        P.append(c1)\n        \n        # calculation of cross points of circles\n        for x, y, r2 in C:\n            c2 = x + y * 1j\n            \n            base = c2 - c1\n            d = abs(base)\n            a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n            t = phase(base)\n            cp1 = c1 + rect(r1, t + a)\n            cp2 = c1 + rect(r1, t - a)\n            \n            P.append(cp1)\n            P.append(cp2)\n            \n            c1, r1 = c2, r2\n        \n        # search path and calculation of its cost\n        lim = 5000\n        dist = [lim] * (2 * n)\n        dist[0] = 0\n        goal = c1\n        g_idx = 2 * n - 1\n        indices = ((i + (i % 2) + 1, i + (i % 2) + 2) for i in range(g_idx))\n        \n        for tpl_idx, cp, d in zip(indices, P, dist):\n            j, k = tpl_idx\n            if j != g_idx:\n                s1 = P[j] - cp\n                s2 = P[k] - cp\n            else:\n                s1 = goal - cp\n                s2 = goal - cp\n            p_s1 = None\n            p_s2 = None\n            for l, cp1, cp2 in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n                t_s1 = cp1 - cp\n                t_s2 = cp2 - cp\n                if phase(s1 / t_s1) >= 0:\n                    s1 = t_s1\n                if phase(s2 / t_s2) <= 0:\n                    s2 = t_s2\n                if phase(s1 / s2) < 0:\n                    break\n                \n                if p_s1 != s1:\n                    dist[l] = min(dist[l], d + abs(s1))\n                    p_s1 = s1\n                if p_s2 != s2:\n                    dist[l+1] = min(dist[l+1], d + abs(s2))\n                    p_s2 = s2\n            else:\n                gs = goal - cp\n                if phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0:\n                    dist[g_idx] = min(dist[g_idx], d + abs(gs))\n        \n        print(dist[g_idx])\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop, heappush\n\ndef cross(a,b):\n    return a[0]*b[1]-a[1]*b[0]\n\ndef calc(r1,r2):\n    a = ((r1[0]-r2[0])**2+(r1[1]-r2[1])**2)**0.5\n    b = r1[2]\n    c = r2[2]\n    cos = (a**2+b**2-c**2)/(2*a*b)\n    s = b*cos\n    t = (b**2-s**2)**0.5\n    e = ((r2[0]-r1[0])/a,(r2[1]-r1[1])/a)\n    h = (-e[1],e[0])\n    return [[r1[0]+s*e[0]+t*h[0], r1[1]+s*e[1]+t*h[1]],[r1[0]+s*e[0]-t*h[0], r1[1]+s*e[1]-t*h[1]]]\n\ndef check(a,b,s,t):\n    v = (b[0]-a[0],b[1]-a[1])\n    v1 = (s[0]-a[0],s[1]-a[1])\n    v2 = (t[0]-a[0],t[1]-a[1])\n    if cross(v,v1)*cross(v,v2) > 0:\n        return 0\n    v = (t[0]-s[0],t[1]-s[1])\n    v1 = (a[0]-s[0],a[1]-s[1])\n    v2 = (b[0]-s[0],b[1]-s[1])\n    if cross(v,v1)*cross(v,v2) > 0:\n        return 0\n    return 1\n\ndef dijkstra(m,v):\n    dist = [float(\"inf\")]*m\n    q = [(0,0)]\n    dist[0] = 0\n    while q:\n        dx,x = heappop(q)\n        for y,d in v[x]:\n            if dist[y] > dx+d:\n                dist[y] = dx+d\n                heappush(q,(dx+d,y))\n    return dist[m-1]\ndef solve(n):\n    r = [[int(x) for x in input().split()] for i in range(n)]\n    p = [[r[0][0],r[0][1]]]\n    for i in range(n-1):\n        p += calc(r[i],r[i+1])\n    p.append([r[-1][0],r[-1][1]])\n    m = 2*n\n    v = [[] for i in range(m)]\n    gate = []\n    for i in range(1,n):\n        gate.append([p[2*i-1],p[2*i]])\n\n    for i in range(m):\n        x = p[i]\n        for j in range(i+1,m):\n            y = p[j]\n            for g1,g2 in gate[(i-1)//2+1:(j-1)//2]:\n                if not check(x,y,g1,g2):\n                    break\n            else:\n                d = ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\n                v[i].append((j,d))\n                v[j].append((i,d))\n    print(dijkstra(m,v))\n\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    solve(n)\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef _kosa(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    tc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3)\n    td = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4)\n    return tc*td < 0\n\ndef kosa(a1, a2, b1, b2):\n    return _kosa(a1,a2,b1,b2) and _kosa(b1,b2,a1,a2)\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\ndef distance_p(a, b):\n    return distance(a[0], a[1], b[0], b[1])\n\ndef polar(a, r):\n    return (math.cos(r) * a, math.sin(r) * a)\n\ndef intersection_c(ap, bp):\n    ax,ay,ar = ap\n    bx,by,br = bp\n    d = distance(ax,ay,bx,by)\n    if d > ar + br or d < abs(ar - br):\n        return None\n\n    ac = math.acos((ar**2 + d**2 - br**2) / (2 * ar * d))\n    t = math.atan2(by - ay, bx - ax)\n    r1 = polar(ar, t + ac)\n    r2 = polar(ar, t - ac)\n    return [(ax+r1[0], ay+r1[1]), (ax+r2[0], ay+r2[1])]\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = [LI() for _ in range(n)]\n        inters = []\n        for i in range(n-1):\n            inters.append(intersection_c(a[i], a[i+1]))\n        dp = [[inf]*2 for _ in range(n-1)]\n        s = a[0][:2]\n        rt = a[-1][:2]\n        rf = True\n        for k in range(n-1):\n            if not kosa(s,rt,inters[k][0],inters[k][1]):\n                rf = False\n                break\n        if rf:\n            return distance_p(s,rt)\n\n        for i in range(n-1):\n            for j in range(2):\n                t = inters[i][j]\n                f = True\n                for k in range(i):\n                    if not kosa(s,t, inters[k][0], inters[k][1]):\n                        f = False\n                        break\n                if f:\n                    dp[i][j] = distance_p(s,t)\n\n        r = inf\n        # print('dp', dp)\n        for i in range(n-1):\n            for j in range(2):\n                s = inters[i][j]\n                sd = dp[i][j]\n                for k in range(i+1,n-1):\n                    for l in range(2):\n                        t = inters[k][l]\n                        f = True\n                        for m in range(i+1,k):\n                            if not kosa(s,t,inters[m][0], inters[m][1]):\n                                f = False\n                                break\n                        # print('s,t,f',s,t,f)\n                        if f:\n                            nd = sd + distance_p(s,t)\n                            if dp[k][l] > nd:\n                                dp[k][l] = nd\n                t = a[-1][:2]\n                f = True\n                for k in range(i+1,n-1):\n                    if not kosa(s,t,inters[k][0], inters[k][1]):\n                        f = False\n                        break\n                if f:\n                    nd = sd + distance_p(s,t)\n                    if r > nd:\n                        r = nd\n            # print('i',i,inters[i])\n            # print('dp', dp)\n            # print('r', r)\n        return '{:0.5f}'.format(r)\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nclass Vec:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __mul__(self, other):\n        return Vec(self.x * other, self.y * other)\n\n    def length(self):\n        return math.sqrt(self.x * self.x + self.y * self.y)\n\n    def __str__(self):\n        return \"({},{})\".format(self.x, self.y)\n\n    def __sub__(self, other):\n        return Vec(self.x - other.x, self.y - other.y)\n\n    def __add__(self, other):\n        return Vec(self.x + other.x, self.y + other.y)\n\n    def __truediv__(self, other):\n        return Vec(self.x / other, self.y / other)\n\n    def turn90(self):\n        return Vec(-self.y, self.x)\n\n    def normalized(self):\n        return self / self.length()\n\n    def is_clock(self, other):\n        return self.x * other.y - self.y * other.x < 0\n\n\nclass Circle:\n    def __init__(self, x, y, r):\n        self.r = r\n        self.center = Vec(x, y)\n\n    def intersection(self, other):\n        d = (self.center - other.center).length()\n        r1 = self.r\n        r2 = other.r\n        d1 = (d * d + r1 * r1 - r2 * r2) / 2 / d\n        x = math.sqrt(r1 * r1 - d1 * d1)\n        e1 = (other.center - self.center).normalized()\n        e2 = e1.turn90()\n\n        p1 = self.center + e1 * d1 + e2 * x\n        p2 = self.center + e1 * d1 - e2 * x\n        return p1, p2\n\n    def __str__(self):\n        return \"({},{})\".format(self.center, self.r)\n\n\ndef solve(ps: [Circle]):\n    intersects = []\n    for i in range(len(ps) - 1):\n        ci = ps[i]\n        ci_next = ps[i + 1]\n        intersection1, intersection2 = ci.intersection(ci_next)\n        intersects.append((intersection1, intersection2))\n\n    res = [[ps[0].center, -1, 0]]  # 候補座標とその深度と左右(0,1)\n    dists = [[2 ** 32, 2 ** 32] for _ in range(len(intersects))]  # 各交点の距離バッファ\n\n    min_path_length = 2 ** 32\n\n    while len(res) != 0:\n        res = sorted(res, key=lambda a: a[1], reverse=True)\n\n        c, depth, lr = res.pop()\n        current_path_length = dists[depth][lr] if depth != -1 else 0\n        if depth == len(intersects) - 1:\n            last_path = ps[-1].center - c\n            min_path_length = min(min_path_length, current_path_length + last_path.length())\n            continue\n\n        l_limit_min, r_limit_min = [a - c for a in intersects[depth + 1]]  # 左右の限界\n        l_limit, r_limit = l_limit_min, r_limit_min  # 到達可能限界\n        l_limit_d, r_limit_d = depth + 1, depth + 1\n\n        flag = True\n        for i in range(depth + 2, len(intersects)):\n            l_limit2, r_limit2 = [a - c for a in intersects[i]]\n\n            if l_limit_min.is_clock(l_limit2):  # 限界更新\n                l_limit_min = l_limit2\n                if l_limit2.is_clock(r_limit_min):  # 到達可能なら、こっちも更新\n                    l_limit = l_limit2\n                    l_limit_d = i\n            if r_limit2.is_clock(r_limit_min):  # 限界更新\n                r_limit_min = r_limit2\n                if l_limit_min.is_clock(r_limit2):  # 到達可能なら、こっちも更新\n                    r_limit = r_limit2\n                    r_limit_d = i\n            if r_limit_min.is_clock(l_limit_min):\n                flag = False\n                break\n        last_path = ps[-1].center - c\n        if flag and l_limit_min.is_clock(last_path) and last_path.is_clock(r_limit_min):  # この点からゴールまで行ける\n            min_path_length = min(min_path_length, current_path_length + last_path.length())\n            continue\n        if dists[l_limit_d][0] > l_limit.length() + current_path_length:\n            dists[l_limit_d][0] = l_limit.length() + current_path_length\n            res.append([l_limit + c, l_limit_d, 0])\n        if dists[r_limit_d][1] > r_limit.length() + current_path_length:\n            dists[r_limit_d][1] = r_limit.length() + current_path_length\n            res.append([r_limit + c, r_limit_d, 1])\n    return min_path_length\n\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        ps = [Circle(*[int(a) for a in input().split()]) for _ in range(n)]\n\n        print(solve(ps))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom sys import stdin, stdout\nreadline = stdin.readline\nwrite = stdout.write\nwhile 1:\n    n = int(readline())\n    if n == 0:\n        break\n    C = [map(int, readline().split()) for i in xrange(n)]\n    P = {(0, 0): C[0][:2], (n, 0): C[-1][:2]}\n    # calculate intersections of the circles\n    for i in xrange(n-1):\n        x0, y0, r0 = C[i]\n        x1, y1, r1 = C[i+1]\n        rr = (x1 - x0)**2 + (y1 - y0)**2; rd = sqrt(rr)\n        rc = (r0**2 + rr - r1**2) / (2 * rd); rs = sqrt(4*r0**2*rr - (r0**2 + rr - r1**2)**2) / (2 * rd)\n        ex = (x1 - x0) / rd; ey = (y1 - y0) / rd\n        bx = x0 + ex * rc; by = y0 + ey * rc\n        P[i+1, 0] = (bx + ey * rs, by - ex * rs)\n        P[i+1, 1] = (bx - ey * rs, by + ex * rs)\n\n    def calc((x0, y0), (x1, y1)):\n        return sqrt((x1 - x0)**2 + (y1 - y0)**2)\n    def cross((x0, y0), (x1, y1), (x2, y2)):\n        return (x1-x0) * (y2-y0) - (x2-x0) * (y1-y0)\n    INF = 10**18\n    dist = {(0, 0): 0}\n    gp = P[n, 0]\n    for i, j in sorted(P):\n        pos = P[i, j]\n        left = p_left = right = p_right = None\n        d = dist[i, j]\n        for k in xrange(i+1, n):\n            lp = P[k, 0]; rp = P[k, 1]\n            # update left and right\n            if left is None or cross(pos, left, lp) >= 0:\n                left = lp\n            if right is None or cross(pos, rp, right) >= 0:\n                right = rp\n            # check if left <= right\n            if cross(pos, left, right) < 0:\n                break\n\n            # propagate cost from P[i][j] to P[k][0] or P[k][1] if possible\n            if p_left != left:\n                dist[k, 0] = min(dist.get((k, 0), INF), d + calc(pos, left))\n                p_left = left\n            if p_right != right:\n                dist[k, 1] = min(dist.get((k, 1), INF), d + calc(pos, right))\n                p_right = right\n        else:\n            # P[i][j] -> goal\n            # check if left <= goal <= right\n            if (left is None and right is None) or (cross(pos, left, gp) >= 0 and cross(pos, gp, right) >= 0):\n                dist[n, 0] = min(dist.get((n, 0), INF), d + calc(pos, gp))\n    write(\"%.06f\\n\" % dist[n, 0])"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from math import acos\n    from cmath import phase, rect, pi\n    \n    from sys import stdin\n    file_input = stdin\n    \n    while True:\n        n = int(file_input.readline())\n        if n == 0:\n            break\n        \n        C = (map(int, file_input.readline().split()) for i in range(n))\n        P = []\n        x, y, r1 = next(C)\n        c1 = x + y * 1j\n        P.append(c1)\n        \n        # calculation of cross points of circles\n        for x, y, r2 in C:\n            c2 = x + y * 1j\n            \n            base = c2 - c1\n            d = abs(base)\n            a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n            t = phase(base)\n            cp1 = c1 + rect(r1, t + a)\n            cp2 = c1 + rect(r1, t - a)\n            \n            P.append(cp1)\n            P.append(cp2)\n            \n            c1, r1 = c2, r2\n        \n        # search path and calculation of its cost\n        lim = 5000\n        dist = [lim] * (2 * n)\n        dist[0] = 0\n        goal = c1\n        g_idx = 2 * n - 1\n        indices = ((i + (i % 2) + 1, i + (i % 2) + 2) for i in range(g_idx))\n        \n        for tpl_idx, cp, d in zip(indices, P, dist):\n            j, k = tpl_idx\n            s1 = None\n            s2 = None\n            p_s1 = None\n            p_s2 = None\n            for l, cp1, cp2 in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n                t_s1 = cp1 - cp\n                t_s2 = cp2 - cp\n                if s1 is None or phase(s1 / t_s1) >= 0:\n                    s1 = t_s1\n                if s2 is None or phase(s2 / t_s2) <= 0:\n                    s2 = t_s2\n                if phase(s1 / s2) < 0:\n                    break\n                \n                if p_s1 != s1:\n                    dist[l] = min(dist[l], d + abs(s1))\n                    p_s1 = s1\n                if p_s2 != s2:\n                    dist[l+1] = min(dist[l+1], d + abs(s2))\n                    p_s2 = s2\n            else:\n                gs = goal - cp\n                if (s1 is None and s2 is None) or \\\n                phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0:\n                    dist[g_idx] = min(dist[g_idx], d + abs(gs))\n        \n        print(dist[g_idx])\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom sys import stdin, stdout\nreadline = stdin.readline\nwrite = stdout.write\nwhile 1:\n    n = int(readline())\n    if n == 0:\n        break\n    C = [map(int, readline().split()) for i in xrange(n)]\n    P = [[C[0][:2]]]\n    # calculate intersections of the circles\n    for i in xrange(n-1):\n        x0, y0, r0 = C[i]\n        x1, y1, r1 = C[i+1]\n        rr = (x1 - x0)**2 + (y1 - y0)**2; rd = sqrt(rr)\n        rc = (r0**2 + rr - r1**2) / (2 * rd); rs = sqrt(4*r0**2*rr - (r0**2 + rr - r1**2)**2) / (2 * rd)\n        ex = (x1 - x0) / rd; ey = (y1 - y0) / rd\n        bx = x0 + ex * rc; by = y0 + ey * rc\n        P.append([(bx + ey * rs, by - ex * rs), (bx - ey * rs, by + ex * rs)])\n    P.append([C[-1][:2]])\n\n    def calc((x0, y0), (x1, y1)):\n        return sqrt((x1 - x0)**2 + (y1 - y0)**2)\n    def cross((x0, y0), (x1, y1), (x2, y2)):\n        return (x1-x0) * (y2-y0) - (x2-x0) * (y1-y0)\n    INF = 10**18\n    dist = {(0, 0): 0}\n    for i in xrange(n):\n        for j, (x, y) in enumerate(P[i]):\n            left = p_left = None; right = p_right = None\n            d = dist[i, j]\n            for k in xrange(i+1, n):\n                lp, rp = P[k]\n                # update left and right\n                if left is None or cross((x, y), left, lp) >= 0:\n                    left = lp\n                if right is None or cross((x, y), rp, right) >= 0:\n                    right = rp\n                # check if left <= right\n                if cross((x, y), left, right) < 0:\n                    break\n\n                # propagate cost from P[i][j] to P[k][0] or P[k][1] if possible\n                if p_left != left:\n                    dist[k, 0] = min(dist.get((k, 0), INF), d + calc((x, y), left))\n                    p_left = left\n                if p_right != right:\n                    dist[k, 1] = min(dist.get((k, 1), INF), d + calc((x, y), right))\n                    p_right = right\n            else:\n                # P[i][j] -> goal\n                gp = P[n][0]\n                # check if left <= goal <= right\n                if (left is None and right is None) or (cross((x, y), left, gp) >= 0 and cross((x, y), gp, right) >= 0):\n                    dist[n, 0] = min(dist.get((n, 0), INF), d + calc((x, y), gp))\n    write(\"%.06f\\n\" % dist[n, 0])"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nwhile 1:\n    n = input()\n    if n == 0:\n        break\n    C = [map(int, raw_input().split()) for i in xrange(n)]\n    P = [[C[0][:2]]]\n    for i in xrange(n-1):\n        x0, y0, r0 = C[i]\n        x1, y1, r1 = C[i+1]\n        rr = (x1 - x0)**2 + (y1 - y0)**2; rd = sqrt(rr)\n        rc = (r0**2 + rr - r1**2) / (2 * rd); rs = sqrt(4*r0**2*rr - (r0**2 + rr - r1**2)**2) / (2 * rd)\n        ex = (x1 - x0) / rd; ey = (y1 - y0) / rd\n        bx = x0 + ex * rc; by = y0 + ey * rc\n        P.append([(bx + ey * rs, by - ex * rs), (bx - ey * rs, by + ex * rs)])\n        #for x, y in P[-1]:\n        #    assert (x - x1)**2 + (y - y1)**2 <= r1**2 + 10**-6, \"%f, %f\" % ((x - x1)**2 + (y - y1)**2, r1**2)\n    P.append([C[-1][:2]])\n    #print \"\\n\".join(str(e) for e in P)\n    #print\n\n    def calc((x0, y0), (x1, y1)):\n        return sqrt((x1 - x0)**2 + (y1 - y0)**2)\n    def cross((x0, y0), (x1, y1), (x2, y2)):\n        return (x1-x0) * (y2-y0) - (x2-x0) * (y1-y0)\n    INF = 10**18\n    dist = {(0, 0): 0}\n    for i in xrange(n):\n        #print i\n        for j, (x, y) in enumerate(P[i]):\n            left = p_left = None; right = p_right = None\n            d = dist[i, j]\n            for k in xrange(i+1, n):\n                lp, rp = P[k]\n                # left\n                if left is None or cross((x, y), left, lp) >= 0:\n                    left = lp\n                if right is None or cross((x, y), rp, right) >= 0:\n                    right = rp\n                if cross((x, y), left, right) < 0:\n                    break\n                #print k, left, right, cross((x, y), left, right)\n                if p_left != left:\n                    #G.setdefault((i, j), set()).add((k, 0))\n                    dist[k, 0] = min(dist.get((k, 0), INF), d + calc((x, y), left))\n                    p_left = left\n                if p_right != right:\n                    #G.setdefault((i, j), set()).add((k, 1))\n                    dist[k, 1] = min(dist.get((k, 1), INF), d + calc((x, y), right))\n                    p_right = right\n            else:\n                # (x, y) -> goal\n                gp = P[-1][0]\n                if (left is None and right is None) or (cross((x, y), left, gp) >= 0 and cross((x, y), gp, right) >= 0):\n                    #G.setdefault((i, j), set()).add((len(P)-1, 0))\n                    dist[len(P)-1, 0] = min(dist.get((len(P)-1, 0), INF), d + calc((x, y), gp))\n    print \"%.06f\" % dist[len(P)-1, 0]"
  }
]