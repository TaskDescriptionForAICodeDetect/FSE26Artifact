[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x, y, r;\n} Circle;\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool is_inside(Circle c, Point p) {\n    return distance(p, (Point){c.x, c.y}) <= c.r + 1e-9;\n}\n\nPoint intersect(Circle c1, Circle c2, Point p1, Point p2) {\n    double d = distance((Point){c1.x, c1.y}, (Point){c2.x, c2.y});\n    if (d < 1e-9) return p1;\n    double a = (c1.r * c1.r - c2.r * c2.r + d * d) / (2 * d);\n    double h = sqrt(c1.r * c1.r - a * a);\n    Point c1p = {c1.x, c1.y};\n    Point c2p = {c2.x, c2.y};\n    Point temp = {\n        c1p.x + a * (c2p.x - c1p.x) / d,\n        c1p.y + a * (c2p.y - c1p.y) / d\n    };\n    Point intersection = {\n        temp.x + h * (c2p.y - c1p.y) / d,\n        temp.y - h * (c2p.x - c1p.x) / d\n    };\n    return intersection;\n}\n\ndouble shortest_path(Circle* circles, int n) {\n    if (n == 1) return 0.0;\n\n    Point start = {circles[0].x, circles[0].y};\n    Point end = {circles[n-1].x, circles[n-1].y};\n\n    double dist = distance(start, end);\n    if (n == 2) return dist;\n\n    double min_dist = DBL_MAX;\n    Point* path = malloc(n * sizeof(Point));\n    path[0] = start;\n    path[n-1] = end;\n\n    for (int i = 1; i < n-1; ++i) {\n        Point p = intersect(circles[i-1], circles[i], path[i-1], path[i]);\n        if (!is_inside(circles[i], p)) {\n            p.x = circles[i].x;\n            p.y = circles[i].y;\n        }\n        path[i] = p;\n    }\n\n    double total_dist = 0.0;\n    for (int i = 0; i < n-1; ++i) {\n        total_dist += distance(path[i], path[i+1]);\n    }\n    min_dist = total_dist;\n\n    free(path);\n    return min_dist;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Circle circles[n];\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%lf %lf %lf\", &circles[i].x, &circles[i].y, &circles[i].r);\n    }\n    printf(\"%.6f\\n\", shortest_path(circles, n));\n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass CirclePath {\n    static class Circle {\n        double x, y, r;\n        Circle(double x, double y, double r) {\n            this.x = x;\n            this.y = y;\n            this.r = r;\n        }\n    }\n\n    static double distance(double x1, double y1, double x2, double y2) {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    static boolean isInside(Circle c1, Circle c2) {\n        double dist = distance(c1.x, c1.y, c2.x, c2.y);\n        return dist <= Math.abs(c1.r - c2.r);\n    }\n\n    static double shortestPath(List<Circle> circles) {\n        int n = circles.size();\n        Circle start = circles.get(0);\n        Circle end = circles.get(n - 1);\n\n        double[][] dp = new double[n][2];\n        for (double[] row : dp) Arrays.fill(row, Double.MAX_VALUE);\n\n        dp[0][0] = start.r;\n        dp[0][1] = start.r;\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (isInside(circles.get(j), circles.get(i))) {\n                    dp[i][0] = Math.min(dp[i][0], dp[j][0] + distance(circles.get(j).x, circles.get(j).y, circles.get(i).x, circles.get(i).y));\n                    dp[i][1] = Math.min(dp[i][1], dp[j][1] + distance(circles.get(j).x, circles.get(j).y, circles.get(i).x, circles.get(i).y));\n                }\n            }\n        }\n\n        return Math.min(dp[n-1][0] + end.r, dp[n-1][1] + end.r);\n    }\n\n    public static void main(String[] args) {\n        List<Circle> circles = new ArrayList<>();\n        circles.add(new Circle(0, 0, 5));\n        circles.add(new Circle(3, 4, 3));\n        circles.add(new Circle(7, 8, 2));\n\n        System.out.println(shortestPath(circles));\n    }\n}",
    "timestamp": "2025-08-05 19:11:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool is_inside(const Point& p, const Point& center, double radius) {\n    return distance(p, center) <= radius + 1e-9;\n}\n\nvector<Point> get_tangent_points(const Point& p, const Point& c, double r) {\n    vector<Point> points;\n    double d = distance(p, c);\n    if (d <= r) return {c};\n    double theta = acos(r / d);\n    double angle = atan2(p.y - c.y, p.x - c.x);\n    points.emplace_back(c.x + r * cos(angle + theta), c.y + r * sin(angle + theta));\n    points.emplace_back(c.x + r * cos(angle - theta), c.y + r * sin(angle - theta));\n    return points;\n}\n\ndouble shortest_path(const vector<Point>& centers, const vector<double>& radii) {\n    int n = centers.size();\n    if (n == 0) return 0;\n    if (n == 1) return 0;\n\n    vector<double> dist(n, numeric_limits<double>::max());\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n    dist[0] = 0;\n    pq.push({0, 0});\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n        int u = current.second;\n        double current_dist = current.first;\n\n        if (current_dist > dist[u]) continue;\n\n        for (int v = 0; v < n; ++v) {\n            if (u == v) continue;\n            double d = distance(centers[u], centers[v]);\n            if (is_inside(centers[u], centers[v], radii[v]) || is_inside(centers[v], centers[u], radii[u])) {\n                if (dist[v] > dist[u] + d) {\n                    dist[v] = dist[u] + d;\n                    pq.push({dist[v], v});\n                }\n            } else {\n                auto tangent_points_u = get_tangent_points(centers[u], centers[v], radii[v]);\n                auto tangent_points_v = get_tangent_points(centers[v], centers[u], radii[u]);\n                for (const auto& pu : tangent_points_u) {\n                    for (const auto& pv : tangent_points_v) {\n                        double total_dist = dist[u] + distance(centers[u], pu) + distance(pu, pv) + distance(pv, centers[v]);\n                        if (total_dist < dist[v]) {\n                            dist[v] = total_dist;\n                            pq.push({dist[v], v});\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return dist[n - 1];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> centers(n);\n    vector<double> radii(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> centers[i].x >> centers[i].y >> radii[i];\n    }\n    cout << shortest_path(centers, radii) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:11:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y, r;\n} Circle;\n\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\ndouble point_circle_distance(double px, double py, Circle c) {\n    return fabs(distance(px, py, c.x, c.y) - c.r);\n}\n\nint point_inside_circle(double px, double py, Circle c) {\n    return distance(px, py, c.x, c.y) <= c.r;\n}\n\ndouble shortest_path(Circle* chain, int n, double* start_x, double* start_y, double* end_x, double* end_y) {\n    double min_dist = DBL_MAX;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            \n            Circle c1 = chain[i];\n            Circle c2 = chain[j];\n            \n            double dx1 = *start_x - c1.x;\n            double dy1 = *start_y - c1.y;\n            double dx2 = *end_x - c2.x;\n            double dy2 = *end_y - c2.y;\n            \n            double d1 = sqrt(dx1*dx1 + dy1*dy1);\n            double d2 = sqrt(dx2*dx2 + dy2*dy2);\n            \n            double path_length = d1 + d2 + fabs(distance(c1.x, c1.y, c2.x, c2.y));\n            \n            int valid_path = 0;\n            for (int k = 0; k < n; k++) {\n                if (point_inside_circle(*start_x, *start_y, chain[k]) ||\n                    point_inside_circle(*end_x, *end_y, chain[k]) ||\n                    point_inside_circle(c1.x, c1.y, chain[k]) ||\n                    point_inside_circle(c2.x, c2.y, chain[k])) {\n                    valid_path = 1;\n                    break;\n                }\n            }\n            \n            if (valid_path && path_length < min_dist) {\n                min_dist = path_length;\n            }\n        }\n    }\n    \n    return min_dist;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Circle* chain = malloc(n * sizeof(Circle));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf\", &chain[i].x, &chain[i].y, &chain[i].r);\n    }\n    \n    double start_x, start_y, end_x, end_y;\n    scanf(\"%lf %lf %lf %lf\", &start_x, &start_y, &end_x, &end_y);\n    \n    double result = shortest_path(chain, n, &start_x, &start_y, &end_x, &end_y);\n    \n    printf(\"%.2f\\n\", result);\n    \n    free(chain);\n    return 0;\n}",
    "timestamp": "2025-08-05 19:12:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n#include <iomanip>\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\nstruct Circle {\n    Point center;\n    double radius;\n    Circle(Point c, double r) : center(c), radius(r) {}\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return std::sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool pointInCircle(const Point& p, const Circle& c) {\n    return distance(p, c.center) <= c.radius;\n}\n\ndouble shortestPathInCircles(const std::vector<Circle>& circles, const Point& start, const Point& end) {\n    int n = circles.size();\n    std::vector<std::vector<double>> graph(n + 2, std::vector<double>(n + 2, std::numeric_limits<double>::max()));\n    \n    // Add start and end nodes\n    std::vector<Circle> extendedCircles = circles;\n    extendedCircles.push_back(Circle(start, 0));\n    extendedCircles.push_back(Circle(end, 0));\n    \n    // Build graph\n    for (int i = 0; i < extendedCircles.size(); i++) {\n        for (int j = i + 1; j < extendedCircles.size(); j++) {\n            double dist = distance(extendedCircles[i].center, extendedCircles[j].center);\n            \n            // Check if path between points lies within a circle\n            bool pathInCircle = false;\n            for (const auto& circle : circles) {\n                Point midPoint((extendedCircles[i].center.x + extendedCircles[j].center.x) / 2,\n                               (extendedCircles[i].center.y + extendedCircles[j].center.y) / 2);\n                \n                if (pointInCircle(midPoint, circle)) {\n                    pathInCircle = true;\n                    break;\n                }\n            }\n            \n            if (pathInCircle) {\n                graph[i][j] = graph[j][i] = dist;\n            }\n        }\n    }\n    \n    // Dijkstra's algorithm\n    std::vector<double> dist(n + 2, std::numeric_limits<double>::max());\n    std::vector<bool> visited(n + 2, false);\n    dist[n] = 0;\n    \n    for (int count = 0; count < n + 2; count++) {\n        int u = -1;\n        double minDist = std::numeric_limits<double>::max();\n        \n        for (int v = 0; v < n + 2; v++) {\n            if (!visited[v] && dist[v] < minDist) {\n                minDist = dist[v];\n                u = v;\n            }\n        }\n        \n        if (u == -1) break;\n        visited[u] = true;\n        \n        for (int v = 0; v < n + 2; v++) {\n            if (!visited[v] && graph[u][v] != std::numeric_limits<double>::max()) {\n                dist[v] = std::min(dist[v], dist[u] + graph[u][v]);\n            }\n        }\n    }\n    \n    return dist[n + 1];\n}\n\nint main() {\n    std::vector<Circle> circles = {\n        Circle(Point(0, 0), 5),\n        Circle(Point(3, 4), 2),\n        Circle(Point(6, 8), 3)\n    };\n    \n    Point start(0, 0);\n    Point end(6, 8);\n    \n    double shortestPath = shortestPathInCircles(circles, start, end);\n    \n    std::cout << std::fixed << std::setprecision(2);\n    std::cout << \"Shortest path: \" << shortestPath << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:12:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    double x, y;\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Circle {\n    Point center;\n    double radius;\n    Circle(Point center, double radius) {\n        this.center = center;\n        this.radius = radius;\n    }\n}\n\npublic class ShortestPathInCircles {\n    private static double distance(Point a, Point b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n\n    private static boolean isPointInCircle(Point p, Circle c) {\n        return distance(p, c.center) <= c.radius;\n    }\n\n    private static List<Point> findTangentPoints(Point p, Circle c) {\n        List<Point> tangents = new ArrayList<>();\n        double d = distance(p, c.center);\n        if (d <= c.radius) {\n            return tangents;\n        }\n        double r = c.radius;\n        double dx = c.center.x - p.x;\n        double dy = c.center.y - p.y;\n        double dd = Math.sqrt(dx * dx + dy * dy);\n        double a = Math.asin(r / d);\n        double b = Math.atan2(dy, dx);\n\n        double t1 = b + a;\n        Point t1Point = new Point(p.x + dd * Math.cos(t1), p.y + dd * Math.sin(t1));\n        tangents.add(t1Point);\n\n        double t2 = b - a;\n        Point t2Point = new Point(p.x + dd * Math.cos(t2), p.y + dd * Math.sin(t2));\n        tangents.add(t2Point);\n\n        return tangents;\n    }\n\n    private static double shortestPath(List<Circle> circles) {\n        if (circles.isEmpty()) return 0;\n        if (circles.size() == 1) return 0;\n\n        Point start = circles.get(0).center;\n        Point end = circles.get(circles.size() - 1).center;\n\n        if (isPointInCircle(end, circles.get(0))) {\n            return distance(start, end);\n        }\n\n        double minDist = Double.MAX_VALUE;\n        Queue<Point> queue = new LinkedList<>();\n        queue.add(start);\n        Map<Point, Double> dist = new HashMap<>();\n        dist.put(start, 0.0);\n\n        while (!queue.isEmpty()) {\n            Point current = queue.poll();\n            double currentDist = dist.get(current);\n\n            for (Circle circle : circles) {\n                if (!isPointInCircle(current, circle)) continue;\n\n                List<Point> tangents = findTangentPoints(current, circle);\n                for (Point tangent : tangents) {\n                    if (!isPointInCircle(tangent, circle)) continue;\n\n                    double newDist = currentDist + distance(current, tangent);\n                    if (!dist.containsKey(tangent) || newDist < dist.get(tangent)) {\n                        dist.put(tangent, newDist);\n                        queue.add(tangent);\n                    }\n                }\n            }\n\n            if (isPointInCircle(end, circles.get(circles.size() - 1))) {\n                double totalDist = currentDist + distance(current, end);\n                if (totalDist < minDist) {\n                    minDist = totalDist;\n                }\n            }\n        }\n\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Circle> circles = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            double r = scanner.nextDouble();\n            circles.add(new Circle(new Point(x, y), r));\n        }\n        System.out.printf(\"%.6f\", shortestPath(circles));\n    }\n}",
    "timestamp": "2025-08-05 19:13:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from math import sqrt, acos, pi\nfrom scipy.optimize import minimize\n\ndef distance(x1, y1, x2, y2):\n    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef path_length(points, radii):\n    length = 0\n    for i in range(len(points) - 1):\n        r1 = radii[i]\n        r2 = radii[i + 1]\n        d = distance(*points[i], *points[i + 1])\n        if d <= r1 + r2:\n            length += d\n        else:\n            length += r1 + r2\n    return length\n\ndef objective(x, centers, radii):\n    num_circles = len(centers)\n    points = [(x[2 * i], x[2 * i + 1]) for i in range(num_circles)]\n    return path_length(points, radii)\n\ndef find_shortest_path(centers, radii):\n    num_circles = len(centers)\n    x0 = [c for center in centers for c in center]\n    bounds = [(cx - r, cx + r) if i % 2 == 0 else (cy - r, cy + r) \n               for i, ((cx, cy), r) in enumerate(zip(centers, radii))]\n\n    result = minimize(objective, x0, args=(centers, radii), bounds=bounds)\n\n    path_points = [(result.x[2 * i], result.x[2 * i + 1]) for i in range(num_circles)]\n    return path_points\n\n# Example usage\ncenters = [(0, 0), (2, 2), (4, 4)]\nradii = [1, 1.5, 1]\n\npath_points = find_shortest_path(centers, radii)\nprint(path_points)",
    "timestamp": "2025-08-13 02:57:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ShortestPathInCircles {\n\n    static class Circle {\n        Point2D center;\n        double radius;\n\n        Circle(double x, double y, double r) {\n            center = new Point2D.Double(x, y);\n            radius = r;\n        }\n\n        boolean contains(Point2D point) {\n            return center.distance(point) <= radius;\n        }\n    }\n\n    public static List<Point2D> shortestPathInCircles(List<Circle> circles) {\n        List<Point2D> path = new ArrayList<>();\n        if (circles.isEmpty()) return path;\n\n        Circle start = circles.get(0);\n        Circle end = circles.get(circles.size() - 1);\n\n        int n = circles.size();\n        double[][] dp = new double[n][n];\n        int[][] next = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j] = Double.MAX_VALUE;\n                next[i][j] = -1;\n            }\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (circles.get(i).contains(circles.get(j).center) || \n                    circles.get(j).contains(circles.get(i).center)) {\n                    double distance = circles.get(i).center.distance(circles.get(j).center);\n                    dp[i][j] = distance;\n                    next[i][j] = j;\n                }\n            }\n        }\n\n        // Perform the Floyd-Warshall algorithm to find the shortest path within circles\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (dp[i][j] > dp[i][k] + dp[k][j]) {\n                        dp[i][j] = dp[i][k] + dp[k][j];\n                        next[i][j] = k;\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the path from start to end\n        int current = 0;\n        path.add(start.center);\n        while (current != n - 1) {\n            current = next[current][n - 1];\n            path.add(circles.get(current).center);\n        }\n\n        return path;\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        List<Circle> circles = new ArrayList<>();\n        circles.add(new Circle(0, 0, 2));\n        circles.add(new Circle(3, 0, 2));\n        circles.add(new Circle(6, 0, 2));\n        circles.add(new Circle(9, 0, 2));\n\n        List<Point2D> shortestPath = shortestPathInCircles(circles);\n        for (Point2D point : shortestPath) {\n            System.out.println(point);\n        }\n    }\n}",
    "timestamp": "2025-08-13 02:57:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_CIRCLES 100\n#define INF 1e9\n\ntypedef struct {\n    double x, y, radius;\n} Circle;\n\n// utility function to calculate distance between two points\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// function to check if two circles overlap or touch\nint overlap(Circle c1, Circle c2) {\n    return distance(c1.x, c1.y, c2.x, c2.y) <= (c1.radius + c2.radius);\n}\n\n// recursive depth-first search function to find shortest path through circles\ndouble dfs(int circleIdx, int lastIdx, int target, int circleCount, Circle circles[], double pathLength) {\n    if(circleIdx == target) {\n        return pathLength;\n    }\n\n    double minLength = INF;\n    for(int i = 0; i < circleCount; ++i) {\n        if(i != lastIdx && overlap(circles[circleIdx], circles[i])) {\n            double newPathLength = pathLength + distance(circles[circleIdx].x, circles[circleIdx].y, circles[i].x, circles[i].y);\n            double result = dfs(i, circleIdx, target, circleCount, circles, newPathLength);\n            if(result < minLength) {\n                minLength = result;\n            }\n        }\n    }\n    \n    return minLength;\n}\n\nint main() {\n    int n;\n    Circle circles[MAX_CIRCLES];\n\n    // Read number of circles\n    scanf(\"%d\", &n);\n\n    // Read all circles' (x, y, radius)\n    for(int i = 0; i < n; ++i) {\n        scanf(\"%lf %lf %lf\", &circles[i].x, &circles[i].y, &circles[i].radius);\n    }\n\n    // Start DFS from first circle to last circle\n    double shortestPath = dfs(0, -1, n-1, n, circles, 0.0);\n\n    // Output the shortest path\n    printf(\"%.6lf\\n\", shortestPath);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:57:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nimport itertools\n\nclass Circle:\n    def __init__(self, x, y, r):\n        self.x = x\n        self.y = y\n        self.r = r\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef point_inside_circle(point, circle):\n    return distance(point, (circle.x, circle.y)) <= circle.r\n\ndef circles_intersect(c1, c2):\n    dist = distance((c1.x, c1.y), (c2.x, c2.y))\n    return dist <= c1.r + c2.r\n\ndef find_shortest_path(circles):\n    start = (circles[0].x, circles[0].y)\n    end = (circles[-1].x, circles[-1].y)\n    n = len(circles)\n\n    # Direct path\n    direct_dist = distance(start, end)\n\n    # Check if direct path is inside any circle\n    for circle in circles:\n        if point_inside_circle(start, circle) and point_inside_circle(end, circle):\n            return direct_dist\n\n    # Try paths through intermediate circles\n    min_path = float('inf')\n    for k in range(1, n):\n        for subset in itertools.combinations(circles[1:-1], k):\n            subset = list(subset)\n            subset = [circles[0]] + subset + [circles[-1]]\n            \n            # Check if subset forms a connected path\n            valid_path = True\n            total_path = 0\n            for i in range(len(subset) - 1):\n                c1, c2 = subset[i], subset[i+1]\n                if not circles_intersect(c1, c2):\n                    valid_path = False\n                    break\n                total_path += distance((c1.x, c1.y), (c2.x, c2.y))\n            \n            if valid_path:\n                min_path = min(min_path, total_path)\n\n    return min_path if min_path != float('inf') else -1\n\n# Example usage\ncircles = [\n    Circle(0, 0, 5),\n    Circle(3, 4, 3),\n    Circle(7, 8, 2)\n]\n\nprint(find_shortest_path(circles))",
    "timestamp": "2025-08-13 02:58:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef shortest_path(circles):\n    if not circles:\n        return 0.0\n    \n    # Extract centers and radii\n    centers = [(c[0], c[1]) for c in circles]\n    radii = [c[2] for c in circles]\n    n = len(centers)\n    \n    # Start and end points\n    start = centers[0]\n    end = centers[-1]\n    \n    # Direct distance between start and end\n    direct_dist = math.hypot(end[0] - start[0], end[1] - start[1])\n    \n    # Check if direct line is entirely within at least one circle\n    for i in range(n):\n        cx, cy = centers[i]\n        r = radii[i]\n        # Check if both start and end are within circle i\n        start_in = (math.hypot(start[0] - cx, start[1] - cy) <= r)\n        end_in = (math.hypot(end[0] - cx, end[1] - cy) <= r)\n        if start_in and end_in:\n            return direct_dist\n    \n    # If not, find the shortest path via intermediate circles\n    # Build a graph where nodes are centers and edges are connections within circles\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            ci, ri = centers[i], radii[i]\n            cj, rj = centers[j], radii[j]\n            dist_ij = math.hypot(ci[0] - cj[0], ci[1] - cj[1])\n            if dist_ij <= ri + rj:\n                graph[i].append(j)\n                graph[j].append(i)\n    \n    # BFS to find the shortest path from 0 to n-1\n    from collections import deque\n    queue = deque()\n    queue.append((0, 0.0))\n    visited = {0: 0.0}\n    \n    while queue:\n        current, current_dist = queue.popleft()\n        if current == n - 1:\n            break\n        for neighbor in graph[current]:\n            new_dist = current_dist + math.hypot(\n                centers[current][0] - centers[neighbor][0],\n                centers[current][1] - centers[neighbor][1]\n            )\n            if neighbor not in visited or new_dist < visited[neighbor]:\n                visited[neighbor] = new_dist\n                queue.append((neighbor, new_dist))\n    \n    if (n - 1) in visited:\n        return min(direct_dist, visited[n - 1])\n    else:\n        return float('inf')",
    "timestamp": "2025-08-13 02:58:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Circle {\n    double x, y, r;\n};\n\nstruct State {\n    int circle;\n    double angle;\n    double distance;\n};\n\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\nbool canTravel(const Circle& c1, const Circle& c2) {\n    double dist = distance(c1.x, c1.y, c2.x, c2.y);\n    return dist <= c1.r + c2.r && dist >= abs(c1.r - c2.r);\n}\n\ndouble computePathDistance(const Circle& from, double angle1, const Circle& to, double angle2) {\n    double x1 = from.x + from.r * cos(angle1);\n    double y1 = from.y + from.r * sin(angle1);\n    double x2 = to.x + to.r * cos(angle2);\n    double y2 = to.y + to.r * sin(angle2);\n    return distance(x1, y1, x2, y2);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Circle> circles(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> circles[i].x >> circles[i].y >> circles[i].r;\n    }\n\n    vector<vector<pair<int, double>>> adj(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (canTravel(circles[i], circles[j])) {\n                double dist = distance(circles[i].x, circles[i].y, circles[j].x, circles[j].y);\n                adj[i].push_back({j, dist});\n                adj[j].push_back({i, dist});\n            }\n        }\n    }\n\n    vector<double> dist(n, numeric_limits<double>::infinity());\n    dist[0] = 0.0;\n    vector<bool> visited(n, false);\n    vector<int> parent(n, -1);\n\n    for (int i = 0; i < n; ++i) {\n        int u = -1;\n        for (int j = 0; j < n; ++j) {\n            if (!visited[j] && (u == -1 || dist[j] < dist[u])) {\n                u = j;\n            }\n        }\n\n        if (dist[u] == numeric_limits<double>::infinity())\n            break;\n\n        visited[u] = true;\n        for (auto& edge : adj[u]) {\n            int v = edge.first;\n            double length = edge.second;\n            if (dist[u] + length < dist[v]) {\n                dist[v] = dist[u] + length;\n                parent[v] = u;\n            }\n        }\n    }\n\n    // Output the shortest distance from the first circle to the last circle\n    cout << dist[n-1] << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:08:43"
  }
]